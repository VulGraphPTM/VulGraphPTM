import json
import time

from .node import Node
from .edge import Edge
from .method import Method
from os.path import join, exists
from os import listdir
from typing import Dict, List
from tqdm import tqdm


class Cpg:
    """
    A class for the cpg structure
    Contains: nodes: Dict[int, Node], methods: Dict[str, Method]
    """
    def __init__(self, cpg_path, src_path=None):
        self.cpg_path = cpg_path
        self.src_path = src_path
        self.nodes: Dict[int, Node] = {}
        self.methods: List[Method] = []
        self.method_map: List[str, int] = {method.name: idx for idx, method in enumerate(self.methods)}
        self._parse_from_files()

    def _parse_from_files(self):
        """
        Traverse cpg files to  parse nodes and edges information in this method
        Cpg files are generated by joern, divided in function level
        """
        if exists(self.cpg_path):
            # Parse nodes
            nodes_path = join(self.cpg_path, "NodesForAll.json")
            if not exists(nodes_path):
                raise FileNotFoundError(f"Can't find cpg nodes file {nodes_path}, please verify your path.")
            print("Loading cpg nodes...")
            with open(nodes_path, "r", encoding="utf-8") as nodes_file:
                nodes = json.load(nodes_file)
                self._parse_nodes(nodes)
            # Parse methods
            method_dir = join(self.cpg_path, "cpgs/")
            if not exists(method_dir):
                raise FileNotFoundError(f"Can't find method information folder path {method_dir}, please verify your path.")
            if self.src_path:
                with open(self.src_path, 'r') as fp:
                    samples = [json.loads(line) for line in fp.readlines()]
                code_dict = {}
                for sam in samples:
                    key = f'{sam["idx"]}_{sam["target"]}.txt'
                    code_dict[key] = sam['func']
            method_files = listdir(method_dir)
            for method_file in tqdm(method_files, desc="Loading function cpgs"):
                code = None
                if self.src_path:
                    key = method_file.split('_')[0] + '_' + method_file.split('_')[-1]
                    if key in code_dict.keys():
                        code = code_dict[key]
                file = join(method_dir, method_file)
                with open(file, "r", encoding="utf-8") as fp:
                    cpg = fp.readlines()
                    try:
                        self._parse_cpg(cpg, method_file, code)
                    except (KeyError, IndexError):
                        continue
        else:
            raise FileNotFoundError(f"Can't find cpg folder {self.cpg_path}, please verify your path.")

    def _parse_nodes(self, nodes: Dict):
        """
        Parse dict format nodes info into Node class format
        """
        for n in nodes:
            if "overlays" in n:
                continue
            node = Node(n)
            self.nodes[node.id] = node

    def _parse_cpg(self, cpg: List[str], methodname: str, code=None):
        """
        Parse cpg information into Method class format.
        Cpg format:
            digraph "myfunc" {
                "20" [label = "(METHOD,myfunc)" ]
                "21" [label = "(PARAM,int b)" ]
                ...
                ...
                  "20" -> "21"  [ label = "AST: "]
                  "20" -> "22"  [ label = "AST: "]
                ...
                ...
            }
        ### The first part is nodes set, which contains node's id and features;
            The second part is edges set, each edge contains in-node id and out-node
            id with "->" connecting them which indicates the direction; The labels
            classify the edges into 4 types: ["AST", "CFG", "CDG", "DDG"];
            The id of nodes is corresponding to the Node's id;
        """
        m_line = False
        e_line = False
        method_entry = None
        method_nodes = []
        method_edges = []
        target = int(methodname.split('_')[-1].strip().replace('.txt', ''))

        for line in cpg:
            line = line.strip()
            if not line or line.isspace():
                continue
            if "digraph" in line:
                m_line = True
                e_line = False
                continue
            if len(line) < 3:
                continue

            if not e_line:
                if "->" in line:
                    e_line = True
                    items = line.split(" [ label = ")
                    edge = items[0].replace('"', '').strip()
                    label = items[1].replace('"', '')[:3]
                    node_in, node_out = edge.split(" -> ")
                    node_in = int(node_in)
                    node_out = int(node_out)
                    method_edges.append(Edge(node_in, node_out, label))
                    continue
                items = line.split(" [label = ")
                ids = int(items[0].strip().replace('"', ''))
                method_nodes.append(self.nodes[ids])
                if m_line:
                    method_entry = ids
                    m_line = False
            else:
                items = line.split(" [ label = ")
                edge = items[0].replace('"', '').strip()
                label = items[1].replace('"', '')[:3]
                node_in, node_out = edge.split(" -> ")
                node_in = int(node_in)
                node_out = int(node_out)
                method_edges.append(Edge(node_in, node_out, label))

        method = Method(method_entry, method_nodes[-1].id, target, methodname, method_nodes, method_edges, code=code)
        self.methods.append(method)

    def get_method(self, name: str, types: str = None):
        """
        Select method by method's name, and returns
        """
        for method in self.methods:
            if method.name == name:
                return method
        return None

    def get_node_info(self, nid):
        """
        Searching for the node which id is nid and returns the testID and the method the node is in
        """
        for testID in self.methods:
            for method in self.methods[testID]:
                if nid in method.node_id_set:
                    return testID, method
        return None, None

    def get_method_by_id(self, testID: str, nid: int):
        """
        Given the testID and the node id, return the method
        """
        if testID in self.methods:
            for method in self.methods[testID]:
                if nid in method.node_id_set:
                    return method
        return None

    def get_method_by_filename(self, testID: str, filename: str):
        """
        Select and return method by method's path
        """
        if testID in self.methods:
            for method in self.methods[testID]:
                if method.filename == filename:
                    return method
        return None
