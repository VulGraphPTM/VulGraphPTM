{"idx": 186627, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8096, "func": "static inline GBool isSameGfxColor(const GfxColor &colorA, const GfxColor &colorB, Guint nComps, double delta) {\n  for (Guint k = 0; k < nComps; ++k) {\n    if (abs(colorA.c[k] - colorB.c[k]) > delta) {\n      return false;\n    }\n  }\n  return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186716, "func": "bool SniffMimeType(const char* content,\n                   size_t content_size,\n                   const GURL& url,\n                   const std::string& type_hint,\n                   std::string* result) {\n  DCHECK_LT(content_size, 1000000U);  \n  DCHECK(content);\n  DCHECK(result);\n\n  bool have_enough_content = true;\n\n  result->assign(type_hint);\n\n  if (IsOfficeType(type_hint))\n    return SniffForInvalidOfficeDocs(content, content_size, url, result);\n\n   const bool hint_is_unknown_mime_type = IsUnknownMimeType(type_hint);\n \n  if (hint_is_unknown_mime_type && !url.SchemeIsFile() &&\n      SniffForHTML(content, content_size, &have_enough_content, result)) {\n    return true;\n   }\n \n  const bool hint_is_text_plain = (type_hint == \"text/plain\");\n  if (hint_is_unknown_mime_type || hint_is_text_plain) {\n    if (!SniffBinary(content, content_size, &have_enough_content, result)) {\n      if (hint_is_text_plain) {\n        return have_enough_content;\n      }\n    }\n  }\n\n  if (type_hint == \"text/xml\" || type_hint == \"application/xml\") {\n    if (SniffXML(content, content_size, &have_enough_content, result))\n      return true;\n    return have_enough_content;\n  }\n\n  if (SniffCRX(content, content_size, url, type_hint,\n               &have_enough_content, result))\n    return true;\n\n  if (SniffForOfficeDocs(content, content_size, url,\n                         &have_enough_content, result))\n    return true;  \n\n  if (type_hint == \"application/octet-stream\")\n    return have_enough_content;\n\n  if (SniffForMagicNumbers(content, content_size,\n                           &have_enough_content, result))\n    return true;  \n\n  return have_enough_content;\n}\n", "target": 1, "flaw_line_index": "27,28,29,30,31,32,33,34"}
{"idx": 8207, "func": "static int stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                            const struct stat *stbuf,\n                            V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187272, "func": "void RenderFrameDevToolsAgentHost::UpdateFrameHost(\n    RenderFrameHostImpl* frame_host) {\n  if (frame_host == frame_host_) {\n    if (frame_host && !render_frame_alive_) {\n      render_frame_alive_ = true;\n      for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n        inspector->TargetReloadedAfterCrash();\n      MaybeReattachToRenderFrame();\n    }\n    return;\n  }\n\n  if (frame_host && !ShouldCreateDevToolsForHost(frame_host)) {\n    DestroyOnRenderFrameGone();\n    return;\n  }\n \n   if (IsAttached())\n     RevokePolicy();\n   frame_host_ = frame_host;\n   agent_ptr_.reset();\n   if (!render_frame_alive_) {\n     render_frame_alive_ = true;\n     for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n       inspector->TargetReloadedAfterCrash();\n   }\n   if (IsAttached()) {\n     GrantPolicy();\n     for (DevToolsSession* session : sessions()) {\n      session->SetRenderer(frame_host ? frame_host->GetProcess()->GetID() : -1,\n                           frame_host);\n    }\n    MaybeReattachToRenderFrame();\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187301, "func": "std::string TestURLLoader::TestUntendedLoad() {\n  pp::URLRequestInfo request(instance_);\n  request.SetURL(\"test_url_loader_data/hello.txt\");\n  request.SetRecordDownloadProgress(true);\n  TestCompletionCallback callback(instance_->pp_instance(), callback_type());\n\n  pp::URLLoader loader(instance_);\n  callback.WaitForResult(loader.Open(request, callback.GetCallback()));\n  CHECK_CALLBACK_BEHAVIOR(callback);\n  ASSERT_EQ(PP_OK, callback.result());\n\n  int64_t bytes_received = 0;\n  int64_t total_bytes_to_be_received = 0;\n  while (true) {\n     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);\n     if (total_bytes_to_be_received <= 0)\n       return ReportError(\"URLLoader::GetDownloadProgress total size\",\n          total_bytes_to_be_received);\n     if (bytes_received == total_bytes_to_be_received)\n       break;\n    if (pp::Module::Get()->core()->IsMainThread()) {\n      NestedEvent event(instance_->pp_instance());\n      event.PostSignal(10);\n      event.Wait();\n    }\n  }\n  std::string body;\n  std::string error = ReadEntireResponseBody(&loader, &body);\n  if (!error.empty())\n    return error;\n  if (body != \"hello\\n\")\n    return ReportError(\"Couldn't read data\", callback.result());\n\n  PASS();\n}\n", "target": 1, "flaw_line_index": "21"}
{"idx": 8307, "func": "XFixesDestroyRegion (Display *dpy, XserverRegion region)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesDestroyRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesDestroyRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesDestroyRegion;\n    req->region = region;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187029, "func": "    ShouldCancelAndIgnore(NavigationHandle* handle) {\n  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 7904, "func": "static void ccall(JF, js_Ast *fun, js_Ast *args)\n{\n\tint n;\n\tswitch (fun->type) {\n\tcase EXP_INDEX:\n\t\tcexp(J, F, fun->a);\n\t\temit(J, F, OP_DUP);\n\t\tcexp(J, F, fun->b);\n\t\temit(J, F, OP_GETPROP);\n\t\temit(J, F, OP_ROT2);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, fun->a);\n\t\temit(J, F, OP_DUP);\n\t\temitstring(J, F, OP_GETPROP_S, fun->b->string);\n\t\temit(J, F, OP_ROT2);\n\t\tbreak;\n\tcase EXP_IDENTIFIER:\n\t\tif (!strcmp(fun->string, \"eval\")) {\n\t\t\tceval(J, F, fun, args);\n\t\t\treturn;\n\t\t}\n\tdefault:\n\t\tcexp(J, F, fun);\n\t\temit(J, F, J->strict ? OP_UNDEF : OP_GLOBAL);\n\t\tbreak;\n\t}\n\tn = cargs(J, F, args);\n\temit(J, F, OP_CALL);\n\temitraw(J, F, n);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7957, "func": "static void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1);\n        vnc_framebuffer_update(vs, absolute, 0,\n                               pixman_image_get_width(vs->vd->server),\n                               pixman_image_get_height(vs->vd->server),\n                               VNC_ENCODING_POINTER_TYPE_CHANGE);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186542, "func": "void DiceResponseHandler::ProcessDiceSignoutHeader(\n    const std::vector<signin::DiceResponseParams::AccountInfo>& account_infos) {\n  VLOG(1) << \"Start processing Dice signout response\";\n  if (account_consistency_ ==\n      signin::AccountConsistencyMethod::kDiceFixAuthErrors) {\n    return;\n  }\n\n  std::string primary_account = signin_manager_->GetAuthenticatedAccountId();\n  bool primary_account_signed_out = false;\n  for (const auto& account_info : account_infos) {\n    std::string signed_out_account =\n        account_tracker_service_->PickAccountIdForAccount(account_info.gaia_id,\n                                                          account_info.email);\n    if (signed_out_account == primary_account) {\n      primary_account_signed_out = true;\n      RecordDiceResponseHeader(kSignoutPrimary);\n      RecordGaiaSignoutMetrics(\n          (account_info.session_index == 0)\n              ? kChromePrimaryAccountIsFirstGaiaAccount\n              : kChromePrimaryAccountIsSecondaryGaiaAccount);\n\n      if (account_consistency_ == signin::AccountConsistencyMethod::kDice) {\n         token_service_->UpdateCredentials(\n             primary_account,\n            MutableProfileOAuth2TokenServiceDelegate::kInvalidRefreshToken);\n       } else {\n         continue;\n       }\n     } else {\n      token_service_->RevokeCredentials(signed_out_account);\n     }\n \n    for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n      std::string token_fetcher_account_id =\n          account_tracker_service_->PickAccountIdForAccount(\n              it->get()->gaia_id(), it->get()->email());\n      if (token_fetcher_account_id == signed_out_account) {\n        token_fetchers_.erase(it);\n        break;\n      }\n    }\n  }\n\n  if (!primary_account_signed_out) {\n    RecordDiceResponseHeader(kSignoutSecondary);\n    RecordGaiaSignoutMetrics(primary_account.empty()\n                                 ? kNoChromePrimaryAccount\n                                 : kChromePrimaryAccountIsNotInGaiaAccounts);\n  }\n}\n", "target": 1, "flaw_line_index": "28,35"}
{"idx": 7488, "func": "int v9fs_set_xattr(FsContext *ctx, const char *path, const char *name,\n                   void *value, size_t size, int flags)\n{\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n    if (xops) {\n        return xops->setxattr(ctx, path, name, value, size, flags);\n    }\n    errno = EOPNOTSUPP;\n    return -1;\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7405, "func": "ZEND_API void _zend_ts_hash_init_ex(TsHashTable *ht, uint nSize, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection ZEND_FILE_LINE_DC)\n{\n#ifdef ZTS\n\tht->mx_reader = tsrm_mutex_alloc();\n\tht->mx_writer = tsrm_mutex_alloc();\n\tht->reader = 0;\n#endif\n\t_zend_hash_init_ex(TS_HASH(ht), nSize, pDestructor, persistent, bApplyProtection ZEND_FILE_LINE_RELAY_CC);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186853, "func": "media::mojom::VideoFrameDataPtr MakeVideoFrameData(\n    const scoped_refptr<media::VideoFrame>& input) {\n  if (input->metadata()->IsTrue(media::VideoFrameMetadata::END_OF_STREAM)) {\n    return media::mojom::VideoFrameData::NewEosData(\n        media::mojom::EosVideoFrameData::New());\n  }\n\n  if (input->storage_type() == media::VideoFrame::STORAGE_MOJO_SHARED_BUFFER) {\n     media::MojoSharedBufferVideoFrame* mojo_frame =\n         static_cast<media::MojoSharedBufferVideoFrame*>(input.get());\n \n     mojo::ScopedSharedBufferHandle dup = mojo_frame->Handle().Clone(\n        mojo::SharedBufferHandle::AccessMode::READ_ONLY);\n     DCHECK(dup.is_valid());\n \n     return media::mojom::VideoFrameData::NewSharedBufferData(\n        media::mojom::SharedBufferVideoFrameData::New(\n            std::move(dup), mojo_frame->MappedSize(),\n            mojo_frame->stride(media::VideoFrame::kYPlane),\n            mojo_frame->stride(media::VideoFrame::kUPlane),\n            mojo_frame->stride(media::VideoFrame::kVPlane),\n            mojo_frame->PlaneOffset(media::VideoFrame::kYPlane),\n            mojo_frame->PlaneOffset(media::VideoFrame::kUPlane),\n            mojo_frame->PlaneOffset(media::VideoFrame::kVPlane)));\n  }\n\n  if (input->HasTextures()) {\n    std::vector<gpu::MailboxHolder> mailbox_holder(\n        media::VideoFrame::kMaxPlanes);\n    size_t num_planes = media::VideoFrame::NumPlanes(input->format());\n    for (size_t i = 0; i < num_planes; i++)\n      mailbox_holder[i] = input->mailbox_holder(i);\n    return media::mojom::VideoFrameData::NewMailboxData(\n        media::mojom::MailboxVideoFrameData::New(std::move(mailbox_holder)));\n  }\n\n  NOTREACHED() << \"Unsupported VideoFrame conversion\";\n  return nullptr;\n}\n", "target": 1, "flaw_line_index": "13"}
{"idx": 8180, "func": "void Gfx::pushStateGuard() {\n    stateGuards.push_back(stackHeight);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7557, "func": "static inline void var_push(php_unserialize_data_t *var_hashx, zval **rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push(%ld): %d\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_PP(rval));\n#endif\n\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\n\t\tif (!(*var_hashx)->first) {\n\t\t\t(*var_hashx)->first = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last)->next = var_hash;\n\t\t}\n\n\t\t(*var_hashx)->last = var_hash;\n\t}\n\n\tvar_hash->data[var_hash->used_slots++] = *rval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187094, "func": "void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,\n                                                              bool ask_user,\n                                                              bool is_allowed) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  auto iter = sessions_.find(session_id);\n  if (iter == sessions_.end())\n    return;\n\n  Session* session = iter->second.get();\n\n  if (session->abort_requested)\n    return;\n\n   if (ask_user) {\n     SpeechRecognitionSessionContext& context = session->context;\n     context.label = media_stream_manager_->MakeMediaAccessRequest(\n        context.render_process_id, context.render_frame_id, session_id,\n        StreamControls(true, false), context.security_origin,\n         base::BindOnce(\n             &SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,\n             weak_factory_.GetWeakPtr(), session_id));\n    return;\n  }\n\n  if (is_allowed) {\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,\n                       weak_factory_.GetWeakPtr(), session_id, EVENT_START));\n  } else {\n    OnRecognitionError(\n        session_id, blink::mojom::SpeechRecognitionError(\n                        blink::mojom::SpeechRecognitionErrorCode::kNotAllowed,\n                        blink::mojom::SpeechAudioErrorDetails::kNone));\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,\n                       weak_factory_.GetWeakPtr(), session_id, EVENT_ABORT));\n  }\n}\n", "target": 1, "flaw_line_index": "18,19"}
{"idx": 7703, "func": "static int dotl_to_open_flags(int flags)\n{\n    int i;\n    int oflags = flags & O_ACCMODE;\n\n    struct dotl_openflag_map dotl_oflag_map[] = {\n        { P9_DOTL_CREATE, O_CREAT },\n        { P9_DOTL_EXCL, O_EXCL },\n        { P9_DOTL_NOCTTY , O_NOCTTY },\n        { P9_DOTL_TRUNC, O_TRUNC },\n        { P9_DOTL_APPEND, O_APPEND },\n        { P9_DOTL_NONBLOCK, O_NONBLOCK } ,\n        { P9_DOTL_DSYNC, O_DSYNC },\n        { P9_DOTL_FASYNC, FASYNC },\n        { P9_DOTL_DIRECT, O_DIRECT },\n        { P9_DOTL_LARGEFILE, O_LARGEFILE },\n        { P9_DOTL_DIRECTORY, O_DIRECTORY },\n        { P9_DOTL_NOFOLLOW, O_NOFOLLOW },\n        { P9_DOTL_NOATIME, O_NOATIME },\n        { P9_DOTL_SYNC, O_SYNC },\n    };\n\n    for (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n        if (flags & dotl_oflag_map[i].dotl_flag) {\n            oflags |= dotl_oflag_map[i].open_flag;\n        }\n    }\n\n    return oflags;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8224, "func": "static void v9fs_mknod(void *opaque)\n{\n\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186533, "func": "  void AddRemainingAxes() {\n     for (const auto& axes_data_pair : axes_data_) {\n      if (!IsUsed(axes_data_pair.first))\n         AddButton(axes_data_pair.second);\n     }\n   }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7679, "func": "static int handle_mknod(FsContext *fs_ctx, V9fsPath *dir_path,\n                       const char *name, FsCred *credp)\n{\n    int dirfd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    ret = mknodat(dirfd, name, credp->fc_mode, credp->fc_rdev);\n    if (!ret) {\n        ret = handle_update_file_cred(dirfd, name, credp);\n    }\n    close(dirfd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7755, "func": "static void __h2_deinit(void)\n{\n\tpool_destroy(pool_head_h2s);\n\tpool_destroy(pool_head_h2c);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7701, "func": "static inline int name_to_handle(int dirfd, const char *name,\n                                 struct file_handle *fh, int *mnt_id, int flags)\n{\n    return name_to_handle_at(dirfd, name, fh, mnt_id, flags);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186536, "func": "  bool TryAddNextUnusedAxesButton() {\n     for (const auto& axes_data_pair : axes_data_) {\n       vr::EVRButtonId button_id = axes_data_pair.first;\n       if (IsUsed(button_id))\n         continue;\n \n      if (TryAddAxesButton(button_id, AxesRequirement::kRequired))\n         return true;\n     }\n \n    return false;\n  }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 187293, "func": "FileBrowserHandlerCustomBindings::FileBrowserHandlerCustomBindings(\n     ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetExternalFileEntry\",\n      base::Bind(&FileBrowserHandlerCustomBindings::GetExternalFileEntry,\n                 base::Unretained(this)));\n  RouteFunction(\"GetEntryURL\",\n                base::Bind(&FileBrowserHandlerCustomBindings::GetEntryURL,\n                           base::Unretained(this)));\n }\n", "target": 1, "flaw_line_index": "5,6,7,8,9,10"}
{"idx": 7659, "func": "static ssize_t socket_read(int sockfd, void *buff, size_t size)\n{\n    ssize_t retval, total = 0;\n\n    while (size) {\n        retval = read(sockfd, buff, size);\n        if (retval == 0) {\n            return -EIO;\n        }\n        if (retval < 0) {\n            if (errno == EINTR) {\n                continue;\n            }\n            return -errno;\n        }\n        size -= retval;\n        buff += retval;\n        total += retval;\n    }\n    return total;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8278, "func": "XRenderHasDepths (Display *dpy)\n{\n    int\ts;\n\n    for (s = 0; s < ScreenCount (dpy); s++)\n    {\n\tCARD32\t\t    depths = 0;\n\tCARD32\t\t    missing;\n\tScreen\t\t    *scr = ScreenOfDisplay (dpy, s);\n\tint\t\t    d;\n\n\tfor (d = 0; d < scr->ndepths; d++)\n\t    depths |= DEPTH_MASK(scr->depths[d].depth);\n\tmissing = ~depths & REQUIRED_DEPTHS;\n\tif (missing)\n\t{\n\t    DepthCheckRec   dc, **dp;\n\t    XErrorHandler   previousHandler;\n\n\t    dc.dpy = dpy;\n\t    dc.missing = 0;\n\t    dc.serial = XNextRequest (dpy);\n\t    _XLockMutex(_Xglobal_lock);\n\t    dc.next = depthChecks;\n\t    depthChecks = &dc;\n\t    _XUnlockMutex (_Xglobal_lock);\n\t    previousHandler = XSetErrorHandler (XRenderDepthCheckErrorHandler);\n\t    for (d = 1; d <= 32; d++)\n\t\tif ((missing & DEPTH_MASK(d)) && d != 1)\n\t\t{\n\t\t    Pixmap  p;\n\t\t    p = XCreatePixmap (dpy, RootWindow (dpy, s), 1, 1, d);\n\t\t    XFreePixmap (dpy, p);\n\t\t}\n\t    XSync (dpy, False);\n\t    XSetErrorHandler (previousHandler);\n\t    _XLockMutex(_Xglobal_lock);\n\t    for (dp = &depthChecks; *dp; dp = &(*dp)->next)\n\t    {\n\t\tif (*dp == &dc)\n\t\t{\n\t\t    *dp = dc.next;\n\t\t    break;\n\t\t}\n\t    }\n\t    _XUnlockMutex (_Xglobal_lock);\n\t    if (dc.missing)\n\t\treturn False;\n\t}\n    }\n    return True;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187064, "func": " void PaymentRequest::CanMakePayment() {\n   if (observer_for_testing_)\n     observer_for_testing_->OnCanMakePaymentCalled();\n \n  if (!delegate_->GetPrefService()->GetBoolean(kCanMakePaymentEnabled) ||\n      !state_) {\n    CanMakePaymentCallback(\nfalse);\n  } else {\n    state_->CanMakePayment(\n        base::BindOnce(&PaymentRequest::CanMakePaymentCallback,\n                       weak_ptr_factory_.GetWeakPtr()));\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7991, "func": "static VncBasicInfo *vnc_basic_info_get_from_remote_addr(int fd)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    return vnc_basic_info_get(&sa, salen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7885, "func": "uint64_t xbzrle_mig_pages_cache_miss(void)\n{\n    return acct_info.xbzrle_cache_miss;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187187, "func": "bool LocalFrame::ShouldReuseDefaultView(const KURL& url) const {\n   if (!Loader().StateMachine()->IsDisplayingInitialEmptyDocument())\n     return false;\n \n   return GetDocument()->IsSecureTransitionTo(url);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7671, "func": "static int handle_ioc_getversion(FsContext *ctx, V9fsPath *path,\n                                 mode_t st_mode, uint64_t *st_gen)\n{\n#ifdef FS_IOC_GETVERSION\n    int err;\n    V9fsFidOpenState fid_open;\n\n    if (!S_ISREG(st_mode) && !S_ISDIR(st_mode)) {\n        errno = ENOTTY;\n        return -1;\n    }\n    err = handle_open(ctx, path, O_RDONLY, &fid_open);\n    if (err < 0) {\n        return err;\n    }\n    err = ioctl(fid_open.fd, FS_IOC_GETVERSION, st_gen);\n    handle_close(ctx, &fid_open);\n    return err;\n#else\n    errno = ENOTTY;\n    return -1;\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187159, "func": "void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(\n    uint32_t download_id,\n    const content::DownloadTargetCallback& callback,\n    const base::FilePath& suggested_path) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n \n   callback.Run(suggested_path,\n                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,\n               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\n                suggested_path.AddExtension(FILE_PATH_LITERAL(\".crdownload\")),\n                content::DOWNLOAD_INTERRUPT_REASON_NONE);\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 186452, "func": "void BackgroundLoaderOffliner::StartSnapshot() {\n  if (!pending_request_.get()) {\n    DVLOG(1) << \"Pending request was cleared during delay.\";\n    return;\n  }\n  DCHECK(is_low_bar_met_)\n      << \"Minimum quality must have been reached before saving a snapshot\";\n\n  AddLoadingSignal(\"Snapshotting\");\n\n  SavePageRequest request(*pending_request_.get());\n  if (page_load_state_ != SUCCESS) {\n    Offliner::RequestStatus status;\n    switch (page_load_state_) {\n      case RETRIABLE_NET_ERROR:\n        status = Offliner::RequestStatus::LOADING_FAILED_NET_ERROR;\n        break;\n      case RETRIABLE_HTTP_ERROR:\n        status = Offliner::RequestStatus::LOADING_FAILED_HTTP_ERROR;\n        break;\n      case NONRETRIABLE:\n        status = Offliner::RequestStatus::LOADING_FAILED_NO_RETRY;\n        break;\n      default:\n        NOTREACHED();\n        status = Offliner::RequestStatus::LOADING_FAILED;\n    }\n\n    std::move(completion_callback_).Run(request, status);\n    ResetState();\n    return;\n  }\n\n  content::WebContents* web_contents(\n      content::WebContentsObserver::web_contents());\n\n  Offliner::RequestStatus loaded_page_error =\n      CanSavePageInBackground(web_contents);\n  if (loaded_page_error != Offliner::RequestStatus::UNKNOWN) {\n    std::move(completion_callback_).Run(request, loaded_page_error);\n    ResetState();\n    return;\n  }\n\n  save_state_ = SAVING;\n\n   RequestStats& image_stats = stats_[ResourceDataType::IMAGE];\n   RequestStats& css_stats = stats_[ResourceDataType::TEXT_CSS];\n   RequestStats& xhr_stats = stats_[ResourceDataType::XHR];\n  bool image_complete = (image_stats.requested == image_stats.completed);\n  bool css_complete = (css_stats.requested == css_stats.completed);\n  bool xhr_complete = (xhr_stats.requested == xhr_stats.completed);\n  RecordResourceCompletionUMA(image_complete, css_complete, xhr_complete);\n \n  if (IsOfflinePagesLoadSignalCollectingEnabled()) {\n    signal_data_.SetDouble(\"StartedImages\", image_stats.requested);\n    signal_data_.SetDouble(\"CompletedImages\", image_stats.completed);\n    signal_data_.SetDouble(\"StartedCSS\", css_stats.requested);\n    signal_data_.SetDouble(\"CompletedCSS\", css_stats.completed);\n    signal_data_.SetDouble(\"StartedXHR\", xhr_stats.requested);\n    signal_data_.SetDouble(\"CompletedXHR\", xhr_stats.completed);\n\n    std::string headers = base::StringPrintf(\n        \"%s\\r\\n%s\\r\\n\\r\\n\", kContentTransferEncodingBinary, kXHeaderForSignals);\n    std::string body;\n    base::JSONWriter::Write(signal_data_, &body);\n    std::string content_type = kContentType;\n    std::string content_location = base::StringPrintf(\n        \"cid:signal-data-%\" PRId64 \"@mhtml.blink\", request.request_id());\n\n    content::MHTMLExtraParts* extra_parts =\n        content::MHTMLExtraParts::FromWebContents(web_contents);\n    DCHECK(extra_parts);\n    if (extra_parts != nullptr) {\n      extra_parts->AddExtraMHTMLPart(content_type, content_location, headers,\n                                     body);\n    }\n  }\n\n  std::unique_ptr<OfflinePageArchiver> archiver(new OfflinePageMHTMLArchiver());\n\n  OfflinePageModel::SavePageParams params;\n  params.url = web_contents->GetLastCommittedURL();\n  params.client_id = request.client_id();\n  params.proposed_offline_id = request.request_id();\n  params.is_background = true;\n  params.use_page_problem_detectors = true;\n  params.request_origin = request.request_origin();\n\n  if (!request.original_url().is_empty())\n    params.original_url = request.original_url();\n  else if (params.url != request.url())\n    params.original_url = request.url();\n\n  offline_page_model_->SavePage(\n      params, std::move(archiver), web_contents,\n      base::Bind(&BackgroundLoaderOffliner::OnPageSaved,\n                 weak_ptr_factory_.GetWeakPtr()));\n}\n", "target": 1, "flaw_line_index": "54,55,56,57"}
{"idx": 7911, "func": "static void checkdup(JF, js_Ast *list, js_Ast *end)\n{\n\tchar nbuf[32], sbuf[32];\n\tconst char *needle, *straw;\n\n\tif (end->a->type == EXP_NUMBER)\n\t\tneedle = jsV_numbertostring(J, nbuf, end->a->number);\n\telse\n\t\tneedle = end->a->string;\n\n\twhile (list->a != end) {\n\t\tif (list->a->type == end->type) {\n\t\t\tjs_Ast *prop = list->a->a;\n\t\t\tif (prop->type == EXP_NUMBER)\n\t\t\t\tstraw = jsV_numbertostring(J, sbuf, prop->number);\n\t\t\telse\n\t\t\t\tstraw =  prop->string;\n\t\t\tif (!strcmp(needle, straw))\n\t\t\t\tjsC_error(J, list, \"duplicate property '%s' in object literal\", needle);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7420, "func": "ZEND_API void zend_ts_hash_destroy(TsHashTable *ht)\n{\n\tbegin_write(ht);\n\tzend_hash_destroy(TS_HASH(ht));\n\tend_write(ht);\n\n#ifdef ZTS\n\ttsrm_mutex_free(ht->mx_reader);\n\ttsrm_mutex_free(ht->mx_writer);\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187252, "func": "ExtensionFunction::ResponseAction TabsCaptureVisibleTabFunction::Run() {\n  using api::extension_types::ImageDetails;\n\n  EXTENSION_FUNCTION_VALIDATE(args_);\n\n  int context_id = extension_misc::kCurrentWindowId;\n  args_->GetInteger(0, &context_id);\n\n  std::unique_ptr<ImageDetails> image_details;\n  if (args_->GetSize() > 1) {\n    base::Value* spec = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->Get(1, &spec) && spec);\n    image_details = ImageDetails::FromValue(*spec);\n  }\n \n   std::string error;\n   WebContents* contents = GetWebContentsForID(context_id, &error);\n \n   const CaptureResult capture_result = CaptureAsync(\n       contents, image_details.get(),\n      base::BindOnce(&TabsCaptureVisibleTabFunction::CopyFromSurfaceComplete,\n                     this));\n  if (capture_result == OK) {\n    return did_respond() ? AlreadyResponded() : RespondLater();\n  }\n\n  return RespondNow(Error(CaptureResultToErrorMessage(capture_result)));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186555, "func": "  static void Register(const GURL& url,\n                       const base::FilePath& root_http,\n                       ReportResponseHeadersOnUI report_on_ui) {\n    EXPECT_TRUE(\n        content::BrowserThread::CurrentlyOn(content::BrowserThread::IO));\n    base::FilePath file_path(root_http);\n    file_path =\n        file_path.AppendASCII(url.scheme() + \".\" + url.host() + \".html\");\n    net::URLRequestFilter::GetInstance()->AddUrlInterceptor(\n        url, base::WrapUnique(\n                 new MirrorMockJobInterceptor(file_path, report_on_ui)));\n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12"}
{"idx": 7717, "func": "static void coroutine_fn v9fs_fix_fid_paths(V9fsPDU *pdu, V9fsPath *olddir,\n                                            V9fsString *old_name,\n                                            V9fsPath *newdir,\n                                            V9fsString *new_name)\n{\n    V9fsFidState *tfidp;\n    V9fsPath oldpath, newpath;\n    V9fsState *s = pdu->s;\n\n\n    v9fs_path_init(&oldpath);\n    v9fs_path_init(&newpath);\n    v9fs_co_name_to_path(pdu, olddir, old_name->data, &oldpath);\n    v9fs_co_name_to_path(pdu, newdir, new_name->data, &newpath);\n\n    for (tfidp = s->fid_list; tfidp; tfidp = tfidp->next) {\n        if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {\n            v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));\n        }\n    }\n    v9fs_path_free(&oldpath);\n    v9fs_path_free(&newpath);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187193, "func": "BluetoothChooserDesktop::~BluetoothChooserDesktop() {\n   bluetooth_chooser_controller_->ResetEventHandler();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7845, "func": "void isa_register_soundhw(const char *name, const char *descr,\n                          int (*init_isa)(ISABus *bus))\n{\n    assert(soundhw_count < ARRAY_SIZE(soundhw) - 1);\n    soundhw[soundhw_count].name = name;\n    soundhw[soundhw_count].descr = descr;\n    soundhw[soundhw_count].isa = 1;\n    soundhw[soundhw_count].init.init_isa = init_isa;\n    soundhw_count++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186954, "func": "bool AppCacheDatabase::FindEntriesForUrl(\n    const GURL& url, std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"\n       \"  WHERE url = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindString(0, url.spec());\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().url == url);\n  }\n\n  return statement.Succeeded();\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 7825, "func": "  TT_MulFix14( FT_Int32  a,\n               FT_Int    b )\n  {\n    FT_Int32   m, s, hi;\n    FT_UInt32  l, lo;\n\n\n    l  = (FT_UInt32)( ( a & 0xFFFFU ) * b );\n    m  = ( a >> 16 ) * b;\n\n    lo = l + (FT_UInt32)( m << 16 );\n    hi = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo < l );\n\n    s   = hi >> 31;\n    l   = lo + (FT_UInt32)s;\n    hi += s + ( l < lo );\n    lo  = l;\n\n    l   = lo + 0x2000U;\n    hi += l < lo;\n\n    return ( hi << 18 ) | ( l >> 14 );\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7648, "func": "static int proxy_rename(FsContext *ctx, const char *oldpath,\n                        const char *newpath)\n{\n    int retval;\n    V9fsString oldname, newname;\n\n    v9fs_string_init(&oldname);\n    v9fs_string_init(&newname);\n\n    v9fs_string_sprintf(&oldname, \"%s\", oldpath);\n    v9fs_string_sprintf(&newname, \"%s\", newpath);\n    retval = v9fs_request(ctx->private, T_RENAME, NULL, &oldname, &newname);\n    v9fs_string_free(&oldname);\n    v9fs_string_free(&newname);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186598, "func": "bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return true;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 187140, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n       UTRANS_FORWARD, parse_error, status));\n \n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n                                   \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f] > n; [\u0167\u0442\u04ad\u050f] > t;\"\n                                   \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1f] > w; [\u043c\u04ce] > m;\"\n                                   \"[\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f; [\u04ab\u1004] > c;\"\n                                   \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n                                   \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23] > s; \u1042 > j;\"\n                                   \"[\u0437\u04e1] > 3\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186671, "func": "void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,\n                               const CallLocation location) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n  MostVisitedURLList top_sites(new_top_sites);\n  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);\n  AddPrepopulatedPages(&top_sites, num_forced_urls);\n\n  TopSitesDelta delta;\n  DiffMostVisited(cache_->top_sites(), top_sites, &delta);\n\n  TopSitesBackend::RecordHistogram record_or_not =\n      TopSitesBackend::RECORD_HISTOGRAM_NO;\n\n  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&\n      !histogram_recorded_) {\n    size_t delta_size =\n        delta.deleted.size() + delta.added.size() + delta.moved.size();\n    UMA_HISTOGRAM_COUNTS_100(\"History.FirstSetTopSitesDeltaSize\", delta_size);\n    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;\n    histogram_recorded_ = true;\n  }\n\n  bool should_notify_observers = false;\n  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {\n    backend_->UpdateTopSites(delta, record_or_not);\n    should_notify_observers = true;\n  }\n  if (!should_notify_observers)\n    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);\n\n   cache_->SetTopSites(top_sites);\n \n  if (!temp_images_.empty()) {\n    for (const MostVisitedURL& mv : top_sites) {\n      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);\n      for (TempImages::iterator it = temp_images_.begin();\n           it != temp_images_.end(); ++it) {\n        if (canonical_url == cache_->GetCanonicalURL(it->first)) {\n          bool success = SetPageThumbnailEncoded(\n              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);\n          if (success) {\n            UMA_HISTOGRAM_ENUMERATION(\"Thumbnails.AddedToTopSites\",\n                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,\n                                      THUMBNAIL_EVENT_COUNT);\n          }\n          temp_images_.erase(it);\n          break;\n        }\n      }\n    }\n  }\n\n  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)\n    temp_images_.clear();\n\n  ResetThreadSafeCache();\n  ResetThreadSafeImageCache();\n\n  if (should_notify_observers) {\n    if (location == CALL_LOCATION_FROM_FORCED_URLS)\n      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);\n    else\n      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);\n  }\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8154, "func": "void Gfx::opSetMiterLimit(Object args[], int numArgs) {\n  state->setMiterLimit(args[0].getNum());\n  out->updateMiterLimit(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186480, "func": "DevToolsClient::DevToolsClient(\n    RenderFrame* main_render_frame,\n    const std::string& compatibility_script)\n    : RenderFrameObserver(main_render_frame),\n       compatibility_script_(compatibility_script),\n       web_tools_frontend_(\n           WebDevToolsFrontend::create(main_render_frame->GetWebFrame(), this)) {\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186878, "func": "std::unique_ptr<base::DictionaryValue> ParsePrintSettings(\n    int command_id,\n    const base::DictionaryValue* params,\n    HeadlessPrintSettings* settings) {\n  if (const base::Value* landscape_value = params->FindKey(\"landscape\"))\n    settings->landscape = landscape_value->GetBool();\n\n  if (const base::Value* display_header_footer_value =\n          params->FindKey(\"displayHeaderFooter\")) {\n    settings->display_header_footer = display_header_footer_value->GetBool();\n  }\n\n  if (const base::Value* should_print_backgrounds_value =\n          params->FindKey(\"printBackground\")) {\n    settings->should_print_backgrounds =\n        should_print_backgrounds_value->GetBool();\n  }\n  if (const base::Value* scale_value = params->FindKey(\"scale\"))\n    settings->scale = scale_value->GetDouble();\n  if (settings->scale > kScaleMaxVal / 100 ||\n      settings->scale < kScaleMinVal / 100)\n    return CreateInvalidParamResponse(command_id, \"scale\");\n  if (const base::Value* page_ranges_value = params->FindKey(\"pageRanges\"))\n    settings->page_ranges = page_ranges_value->GetString();\n\n  if (const base::Value* ignore_invalid_page_ranges_value =\n          params->FindKey(\"ignoreInvalidPageRanges\")) {\n    settings->ignore_invalid_page_ranges =\n        ignore_invalid_page_ranges_value->GetBool();\n  }\n\n  double paper_width_in_inch = printing::kLetterWidthInch;\n\n  if (const base::Value* paper_width_value = params->FindKey(\"paperWidth\"))\n    paper_width_in_inch = paper_width_value->GetDouble();\n\n  double paper_height_in_inch = printing::kLetterHeightInch;\n\n  if (const base::Value* paper_height_value = params->FindKey(\"paperHeight\"))\n    paper_height_in_inch = paper_height_value->GetDouble();\n  if (paper_width_in_inch <= 0)\n    return CreateInvalidParamResponse(command_id, \"paperWidth\");\n  if (paper_height_in_inch <= 0)\n    return CreateInvalidParamResponse(command_id, \"paperHeight\");\n  settings->paper_size_in_points =\n      gfx::Size(paper_width_in_inch * printing::kPointsPerInch,\n                paper_height_in_inch * printing::kPointsPerInch);\n\n  double default_margin_in_inch = 1000.0 / printing::kHundrethsMMPerInch;\n  double margin_top_in_inch = default_margin_in_inch;\n  double margin_bottom_in_inch = default_margin_in_inch;\n  double margin_left_in_inch = default_margin_in_inch;\n  double margin_right_in_inch = default_margin_in_inch;\n\n  if (const base::Value* margin_top_value = params->FindKey(\"marginTop\"))\n    margin_top_in_inch = margin_top_value->GetDouble();\n\n  if (const base::Value* margin_bottom_value = params->FindKey(\"marginBottom\"))\n    margin_bottom_in_inch = margin_bottom_value->GetDouble();\n\n  if (const base::Value* margin_left_value = params->FindKey(\"marginLeft\"))\n    margin_left_in_inch = margin_left_value->GetDouble();\n\n   if (const base::Value* margin_right_value = params->FindKey(\"marginRight\"))\n     margin_right_in_inch = margin_right_value->GetDouble();\n \n   if (margin_top_in_inch < 0)\n     return CreateInvalidParamResponse(command_id, \"marginTop\");\n   if (margin_bottom_in_inch < 0)\n    return CreateInvalidParamResponse(command_id, \"marginBottom\");\n  if (margin_left_in_inch < 0)\n    return CreateInvalidParamResponse(command_id, \"marginLeft\");\n  if (margin_right_in_inch < 0)\n    return CreateInvalidParamResponse(command_id, \"marginRight\");\n  settings->margins_in_points.top =\n      margin_top_in_inch * printing::kPointsPerInch;\n  settings->margins_in_points.bottom =\n      margin_bottom_in_inch * printing::kPointsPerInch;\n  settings->margins_in_points.left =\n      margin_left_in_inch * printing::kPointsPerInch;\n  settings->margins_in_points.right =\n      margin_right_in_inch * printing::kPointsPerInch;\n\n  return nullptr;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186618, "func": "bool DataReductionProxyConfig::ShouldAddDefaultProxyBypassRules() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return true;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 186745, "func": " ServiceWorkerHandler::ServiceWorkerHandler()\n     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),\n       enabled_(false),\n      process_(nullptr),\n       weak_factory_(this) {}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186552, "func": "  explicit HeaderTestDispatcherHostDelegate(const GURL& watch_url)\n       : watch_url_(watch_url) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186460, "func": " void HTMLFormControlElement::updateVisibleValidationMessage() {\n   Page* page = document().page();\n  if (!page)\n     return;\n   String message;\n   if (layoutObject() && willValidate())\n    message = validationMessage().stripWhiteSpace();\n\n  m_hasValidationMessage = true;\n  ValidationMessageClient* client = &page->validationMessageClient();\n  TextDirection messageDir = LTR;\n  TextDirection subMessageDir = LTR;\n  String subMessage = validationSubMessage().stripWhiteSpace();\n  if (message.isEmpty())\n    client->hideValidationMessage(*this);\n  else\n    findCustomValidationMessageTextDirection(message, messageDir, subMessage,\n                                             subMessageDir);\n  client->showValidationMessage(*this, message, messageDir, subMessage,\n                                subMessageDir);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187163, "func": " Node::InsertionNotificationRequest SVGStyleElement::InsertedInto(\n     ContainerNode* insertion_point) {\n   SVGElement::InsertedInto(insertion_point);\n  return kInsertionShouldCallDidNotifySubtreeInsertions;\n}\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 7949, "func": "static void audio_capture(void *opaque, void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8148, "func": "void Gfx::opSetFlat(Object args[], int numArgs) {\n  state->setFlatness((int)args[0].getNum());\n  out->updateFlatness(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186485, "func": " void DesktopWindowTreeHostX11::SetVisible(bool visible) {\n   if (compositor())\n     compositor()->SetVisible(visible);\n  if (IsVisible() != visible)\n    native_widget_delegate_->OnNativeWidgetVisibilityChanged(visible);\n }\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 7638, "func": "static int proxy_mknod(FsContext *fs_ctx, V9fsPath *dir_path,\n                       const char *name, FsCred *credp)\n{\n    int retval;\n    V9fsString fullname;\n\n    v9fs_string_init(&fullname);\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    retval = v9fs_request(fs_ctx->private, T_MKNOD, NULL, &fullname,\n                          credp->fc_mode, credp->fc_rdev,\n                          credp->fc_uid, credp->fc_gid);\n    v9fs_string_free(&fullname);\n    if (retval < 0) {\n        errno = -retval;\n        retval = -1;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7667, "func": "static int handle_closedir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return closedir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7890, "func": "static void addjump(JF, enum js_AstType type, js_Ast *target, int inst)\n{\n\tjs_JumpList *jump = js_malloc(J, sizeof *jump);\n\tjump->type = type;\n\tjump->inst = inst;\n\tjump->next = target->jumps;\n\ttarget->jumps = jump;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187133, "func": "void MediaElementAudioSourceHandler::Process(size_t number_of_frames) {\n  AudioBus* output_bus = Output(0).Bus();\n\n  MutexTryLocker try_locker(process_lock_);\n  if (try_locker.Locked()) {\n    if (!MediaElement() || !source_sample_rate_) {\n      output_bus->Zero();\n      return;\n    }\n\n    if (source_number_of_channels_ != output_bus->NumberOfChannels()) {\n      output_bus->Zero();\n      return;\n    }\n\n    AudioSourceProvider& provider = MediaElement()->GetAudioSourceProvider();\n    if (multi_channel_resampler_.get()) {\n      DCHECK_NE(source_sample_rate_, Context()->sampleRate());\n      multi_channel_resampler_->Process(&provider, output_bus,\n                                        number_of_frames);\n    } else {\n      DCHECK_EQ(source_sample_rate_, Context()->sampleRate());\n       provider.ProvideInput(output_bus, number_of_frames);\n     }\n    if (!PassesCORSAccessCheck()) {\n      if (maybe_print_cors_message_) {\n        maybe_print_cors_message_ = false;\n        PostCrossThreadTask(\n            *task_runner_, FROM_HERE,\n            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,\n                            WrapRefCounted(this), current_src_string_));\n      }\n       output_bus->Zero();\n     }\n   } else {\n    output_bus->Zero();\n  }\n}\n", "target": 1, "flaw_line_index": "37,38,39"}
{"idx": 8053, "func": "void vnc_write(VncState *vs, const void *data, size_t len)\n{\n    buffer_reserve(&vs->output, len);\n\n    if (vs->csock != -1 && buffer_empty(&vs->output)) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, vnc_client_write, vs);\n    }\n\n    buffer_append(&vs->output, data, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187325, "func": "xsltFindTemplate(xsltTransformContextPtr ctxt, const xmlChar *name,\n\t         const xmlChar *nameURI) {\n    xsltTemplatePtr cur;\n    xsltStylesheetPtr style;\n\n    if ((ctxt == NULL) || (name == NULL))\n \treturn(NULL);\n     style = ctxt->style;\n     while (style != NULL) {\n\tcur = style->templates;\n\twhile (cur != NULL) {\n\t    if (xmlStrEqual(name, cur->name)) {\n\t\tif (((nameURI == NULL) && (cur->nameURI == NULL)) ||\n\t\t    ((nameURI != NULL) && (cur->nameURI != NULL) &&\n\t\t     (xmlStrEqual(nameURI, cur->nameURI)))) {\n\t\t    return(cur);\n\t\t}\n\t    }\n\t    cur = cur->next;\n\t}\n \n \tstyle = xsltNextImport(style);\n     }\n    return(NULL);\n}\n", "target": 1, "flaw_line_index": "10,11,12,13,14,15,16,17,18,19,20"}
{"idx": 8294, "func": "XRRFreeOutputInfo (XRROutputInfo *outputInfo)\n{\n    Xfree (outputInfo);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186755, "func": " Response StorageHandler::UntrackCacheStorageForOrigin(\n     const std::string& origin) {\n  if (!process_)\n     return Response::InternalError();\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid())\n    return Response::InvalidParams(origin + \" is not a valid URL\");\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::BindOnce(&CacheStorageObserver::UntrackOriginOnIOThread,\n                     base::Unretained(GetCacheStorageObserver()),\n                     url::Origin::Create(origin_url)));\n  return Response::OK();\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186450, "func": "bool BackgroundLoaderOffliner::LoadAndSave(\n    const SavePageRequest& request,\n    CompletionCallback completion_callback,\n    const ProgressCallback& progress_callback) {\n  DCHECK(completion_callback);\n  DCHECK(progress_callback);\n  DCHECK(offline_page_model_);\n\n  if (pending_request_) {\n    DVLOG(1) << \"Already have pending request\";\n    return false;\n  }\n\n  ClientPolicyController* policy_controller =\n      offline_page_model_->GetPolicyController();\n  if (policy_controller->RequiresSpecificUserSettings(\n          request.client_id().name_space) &&\n      (AreThirdPartyCookiesBlocked(browser_context_) ||\n        IsNetworkPredictionDisabled(browser_context_))) {\n     DVLOG(1) << \"WARNING: Unable to load when 3rd party cookies blocked or \"\n              << \"prediction disabled\";\n    if (AreThirdPartyCookiesBlocked(browser_context_)) {\n      UMA_HISTOGRAM_ENUMERATION(\n          \"OfflinePages.Background.CctApiDisableStatus\",\n          static_cast<int>(OfflinePagesCctApiPrerenderAllowedStatus::\n                               THIRD_PARTY_COOKIES_DISABLED),\n          static_cast<int>(OfflinePagesCctApiPrerenderAllowedStatus::\n                               NETWORK_PREDICTION_DISABLED) +\n              1);\n    }\n    if (IsNetworkPredictionDisabled(browser_context_)) {\n      UMA_HISTOGRAM_ENUMERATION(\n          \"OfflinePages.Background.CctApiDisableStatus\",\n          static_cast<int>(OfflinePagesCctApiPrerenderAllowedStatus::\n                               NETWORK_PREDICTION_DISABLED),\n          static_cast<int>(OfflinePagesCctApiPrerenderAllowedStatus::\n                               NETWORK_PREDICTION_DISABLED) +\n              1);\n    }\n     return false;\n   }\n \n  if (request.client_id().name_space == kCCTNamespace) {\n    UMA_HISTOGRAM_ENUMERATION(\n        \"OfflinePages.Background.CctApiDisableStatus\",\n        static_cast<int>(\n            OfflinePagesCctApiPrerenderAllowedStatus::PRERENDER_ALLOWED),\n        static_cast<int>(OfflinePagesCctApiPrerenderAllowedStatus::\n                             NETWORK_PREDICTION_DISABLED) +\n            1);\n  }\n   if (!OfflinePageModel::CanSaveURL(request.url())) {\n     DVLOG(1) << \"Not able to save page for requested url: \" << request.url();\n     return false;\n  }\n\n  ResetLoader();\n  AttachObservers();\n\n  MarkLoadStartTime();\n\n  pending_request_.reset(new SavePageRequest(request));\n  completion_callback_ = std::move(completion_callback);\n  progress_callback_ = progress_callback;\n\n  if (IsOfflinePagesRenovationsEnabled()) {\n    if (!page_renovation_loader_)\n      page_renovation_loader_ = std::make_unique<PageRenovationLoader>();\n\n    auto script_injector = std::make_unique<RenderFrameScriptInjector>(\n        loader_->web_contents()->GetMainFrame(),\n        ISOLATED_WORLD_ID_CHROME_INTERNAL);\n    page_renovator_ = std::make_unique<PageRenovator>(\n        page_renovation_loader_.get(), std::move(script_injector),\n        request.url());\n  }\n\n  loader_.get()->LoadPage(request.url());\n\n  snapshot_controller_ = std::make_unique<BackgroundSnapshotController>(\n      base::ThreadTaskRunnerHandle::Get(), this,\n      static_cast<bool>(page_renovator_));\n\n  return true;\n}\n", "target": 1, "flaw_line_index": "22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,45,46,47,48,49,50,51,52,53,54"}
{"idx": 7595, "func": "static int cirrus_read_hidden_dac(CirrusVGAState * s)\n{\n    if (++s->cirrus_hidden_dac_lockindex == 5) {\n        s->cirrus_hidden_dac_lockindex = 0;\n        return s->cirrus_hidden_dac_data;\n    }\n    return 0xff;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186459, "func": "bool NavigationRateLimiter::CanProceed() {\n  if (!enabled)\n    return true;\n\n  static constexpr int kStateUpdateLimit = 200;\n  static constexpr base::TimeDelta kStateUpdateLimitResetInterval =\n      base::TimeDelta::FromSeconds(10);\n\n  if (++count_ <= kStateUpdateLimit)\n    return true;\n\n  const base::TimeTicks now = base::TimeTicks::Now();\n  if (now - time_first_count_ > kStateUpdateLimitResetInterval) {\n    time_first_count_ = now;\n    count_ = 1;\n    error_message_sent_ = false;\n    return true;\n   }\n \n   if (!error_message_sent_) {\n     error_message_sent_ = true;\n     if (auto* local_frame = DynamicTo<LocalFrame>(frame_.Get())) {\n      local_frame->Console().AddMessage(ConsoleMessage::Create(\n          mojom::ConsoleMessageSource::kJavaScript,\n          mojom::ConsoleMessageLevel::kWarning,\n          \"Throttling navigation to prevent the browser from hanging. See \"\n          \"https:\n          \"--disable-ipc-flooding-protection can be used to bypass the \"\n          \"protection\"));\n    }\n  }\n\n  return false;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186325, "func": "bool CheckClientDownloadRequest::ShouldUploadForMalwareScan(\n    DownloadCheckResultReason reason) {\n  if (!base::FeatureList::IsEnabled(kDeepScanningOfDownloads))\n    return false;\n\n  if (reason != DownloadCheckResultReason::REASON_DOWNLOAD_SAFE &&\n      reason != DownloadCheckResultReason::REASON_DOWNLOAD_UNCOMMON &&\n      reason != DownloadCheckResultReason::REASON_VERDICT_UNKNOWN)\n    return false;\n\n  content::BrowserContext* browser_context =\n      content::DownloadItemUtils::GetBrowserContext(item_);\n  if (!browser_context)\n    return false;\n\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  if (!profile)\n    return false;\n\n  int send_files_for_malware_check = profile->GetPrefs()->GetInteger(\n      prefs::kSafeBrowsingSendFilesForMalwareCheck);\n  if (send_files_for_malware_check !=\n          SendFilesForMalwareCheckValues::SEND_DOWNLOADS &&\n      send_files_for_malware_check !=\n           SendFilesForMalwareCheckValues::SEND_UPLOADS_AND_DOWNLOADS)\n     return false;\n \n  return !policy::BrowserDMTokenStorage::Get()->RetrieveDMToken().empty();\n }\n", "target": 1, "flaw_line_index": "29,30"}
{"idx": 186436, "func": "void InspectorNetworkAgent::WillSendRequestInternal(\n    ExecutionContext* execution_context,\n    unsigned long identifier,\n     DocumentLoader* loader,\n     const ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n    const FetchInitiatorInfo& initiator_info) {\n   String request_id = IdentifiersFactory::RequestId(identifier);\n   String loader_id = loader ? IdentifiersFactory::LoaderId(loader) : \"\";\n   resources_data_->ResourceCreated(request_id, loader_id, request.Url());\n  InspectorPageAgent::ResourceType type = InspectorPageAgent::kOtherResource;\n  if (initiator_info.name == FetchInitiatorTypeNames::xmlhttprequest) {\n     type = InspectorPageAgent::kXHRResource;\n    resources_data_->SetResourceType(request_id, type);\n  } else if (initiator_info.name == FetchInitiatorTypeNames::document) {\n    type = InspectorPageAgent::kDocumentResource;\n    resources_data_->SetResourceType(request_id, type);\n  }\n \n   String frame_id = loader && loader->GetFrame()\n                         ? IdentifiersFactory::FrameId(loader->GetFrame())\n                        : \"\";\n  std::unique_ptr<protocol::Network::Initiator> initiator_object =\n      BuildInitiatorObject(loader && loader->GetFrame()\n                               ? loader->GetFrame()->GetDocument()\n                               : nullptr,\n                           initiator_info);\n  if (initiator_info.name == FetchInitiatorTypeNames::document) {\n    FrameNavigationInitiatorMap::iterator it =\n        frame_navigation_initiator_map_.find(frame_id);\n    if (it != frame_navigation_initiator_map_.end())\n      initiator_object = it->value->clone();\n  }\n\n  std::unique_ptr<protocol::Network::Request> request_info(\n      BuildObjectForResourceRequest(request));\n\n  if (loader) {\n    request_info->setMixedContentType(MixedContentTypeForContextType(\n        MixedContentChecker::ContextTypeForInspector(loader->GetFrame(),\n                                                     request)));\n  }\n\n  request_info->setReferrerPolicy(\n      GetReferrerPolicy(request.GetReferrerPolicy()));\n  if (initiator_info.is_link_preload)\n    request_info->setIsLinkPreload(true);\n\n  String resource_type = InspectorPageAgent::ResourceTypeJson(type);\n  String documentURL =\n      loader ? UrlWithoutFragment(loader->Url()).GetString()\n             : UrlWithoutFragment(execution_context->Url()).GetString();\n  Maybe<String> maybe_frame_id;\n  if (!frame_id.IsEmpty())\n    maybe_frame_id = frame_id;\n  GetFrontend()->requestWillBeSent(\n      request_id, loader_id, documentURL, std::move(request_info),\n      MonotonicallyIncreasingTime(), CurrentTime(), std::move(initiator_object),\n      BuildObjectForResourceResponse(redirect_response), resource_type,\n      std::move(maybe_frame_id));\n  if (pending_xhr_replay_data_ && !pending_xhr_replay_data_->Async())\n    GetFrontend()->flush();\n}\n", "target": 1, "flaw_line_index": "7,11,12,14,15,16,17,18"}
{"idx": 7855, "func": "uint64_t norm_mig_bytes_transferred(void)\n{\n    return acct_info.norm_pages * TARGET_PAGE_SIZE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186571, "func": " void AcceleratedStaticBitmapImage::EnsureMailbox(MailboxSyncMode mode,\n                                                  GLenum filter) {\n   if (!texture_holder_->IsMailboxTextureHolder()) {\n     TRACE_EVENT0(\"blink\", \"AcceleratedStaticBitmapImage::EnsureMailbox\");\n \n    if (!original_skia_image_) {\n      RetainOriginalSkImage();\n    }\n\n    texture_holder_ = std::make_unique<MailboxTextureHolder>(\n        std::move(texture_holder_), filter);\n  }\n  texture_holder_->Sync(mode);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7522, "func": "  tt_size_run_fpgm( TT_Size  size,\n                    FT_Bool  pedantic )\n  {\n    TT_Face         face = (TT_Face)size->root.face;\n    TT_ExecContext  exec;\n    FT_Error        error;\n\n\n    exec = size->context;\n\n    error = TT_Load_Context( exec, face, size );\n    if ( error )\n      return error;\n\n    exec->callTop = 0;\n    exec->top     = 0;\n\n    exec->period    = 64;\n    exec->phase     = 0;\n    exec->threshold = 0;\n\n    exec->instruction_trap = FALSE;\n    exec->F_dot_P          = 0x4000L;\n\n    exec->pedantic_hinting = pedantic;\n\n    {\n      FT_Size_Metrics*  metrics    = &exec->metrics;\n      TT_Size_Metrics*  tt_metrics = &exec->tt_metrics;\n\n\n      metrics->x_ppem   = 0;\n      metrics->y_ppem   = 0;\n      metrics->x_scale  = 0;\n      metrics->y_scale  = 0;\n\n      tt_metrics->ppem  = 0;\n      tt_metrics->scale = 0;\n      tt_metrics->ratio = 0x10000L;\n    }\n\n    TT_Set_CodeRange( exec,\n                      tt_coderange_font,\n                      face->font_program,\n                      (FT_Long)face->font_program_size );\n\n    TT_Clear_CodeRange( exec, tt_coderange_cvt );\n    TT_Clear_CodeRange( exec, tt_coderange_glyph );\n\n    if ( face->font_program_size > 0 )\n    {\n      TT_Goto_CodeRange( exec, tt_coderange_font, 0 );\n\n      FT_TRACE4(( \"Executing `fpgm' table.\\n\" ));\n      error = face->interpreter( exec );\n#ifdef FT_DEBUG_LEVEL_TRACE\n      if ( error )\n        FT_TRACE4(( \"  interpretation failed with error code 0x%x\\n\",\n                    error ));\n#endif\n    }\n    else\n      error = FT_Err_Ok;\n\n    size->bytecode_ready = error;\n\n    if ( !error )\n      TT_Save_Context( exec, size );\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 187165, "func": "void OfflineAudioDestinationHandler::NotifyComplete() {\n  DCHECK(IsMainThread());\n \n   render_thread_.reset();\n \n   if (Context() && Context()->GetExecutionContext())\n     Context()->FireCompletionEvent();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7441, "func": "ZEND_API void zend_ts_hash_apply_with_argument(TsHashTable *ht, apply_func_arg_t apply_func, void *argument TSRMLS_DC)\n{\n\tbegin_write(ht);\n\tzend_hash_apply_with_argument(TS_HASH(ht), apply_func, argument TSRMLS_CC);\n\tend_write(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8031, "func": "static void vnc_listen_regular_read(void *opaque)\n{\n    vnc_listen_read(opaque, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186997, "func": "bool BitReaderCore::ReadBitsInternal(int num_bits, uint64_t* out) {\n  DCHECK_GE(num_bits, 0);\n\n  if (num_bits == 0) {\n    *out = 0;\n    return true;\n  }\n\n  if (num_bits > nbits_ && !Refill(num_bits)) {\n     nbits_ = 0;\n     reg_ = 0;\n     return false;\n   }\n \n  bits_read_ += num_bits;\n\n  if (num_bits == kRegWidthInBits) {\n    *out = reg_;\n    reg_ = 0;\n    nbits_ = 0;\n    return true;\n  }\n\n  *out = reg_ >> (kRegWidthInBits - num_bits);\n  reg_ <<= num_bits;\n  nbits_ -= num_bits;\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186347, "func": " void InitializeOriginStatFromOriginRequestSummary(\n     OriginStat* origin,\n     const OriginRequestSummary& summary) {\n  origin->set_origin(summary.origin.spec());\n   origin->set_number_of_hits(1);\n   origin->set_average_position(summary.first_occurrence + 1);\n   origin->set_always_access_network(summary.always_access_network);\n  origin->set_accessed_network(summary.accessed_network);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 7443, "func": "ZEND_API int zend_ts_hash_compare(TsHashTable *ht1, TsHashTable *ht2, compare_func_t compar, zend_bool ordered TSRMLS_DC)\n{\n\tint retval;\n\n\tbegin_read(ht1);\n\tbegin_read(ht2);\n\tretval = zend_hash_compare(TS_HASH(ht1), TS_HASH(ht2), compar, ordered TSRMLS_CC);\n\tend_read(ht2);\n\tend_read(ht1);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187099, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u0517\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u0909\u0993\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7899, "func": "static void cassignforin(JF, js_Ast *stm)\n{\n\tjs_Ast *lhs = stm->a;\n\n\tif (stm->type == STM_FOR_IN_VAR) {\n\t\tif (lhs->b)\n\t\t\tjsC_error(J, lhs->b, \"more than one loop variable in for-in statement\");\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs->a->a); \n\t\temit(J, F, OP_POP);\n\t\treturn;\n\t}\n\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\temit(J, F, OP_ROT3);\n\t\temit(J, F, OP_SETPROP);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\temit(J, F, OP_ROT2);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in for-in loop assignment\");\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186380, "func": "void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(\n    const GURL& url,\n     const std::string& file_name,\n     const std::string& download_digest_sha256) {\n   if (client_) {\n     base::Value event(base::Value::Type::DICTIONARY);\n     event.SetStringKey(kKeyUrl, url.spec());\n     event.SetStringKey(kKeyFileName, file_name);\n    event.SetStringKey(kKeyDownloadDigestSha256, download_digest_sha256);\n    event.SetStringKey(kKeyProfileUserName, GetProfileUserName());\n    ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(event));\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7730, "func": "static void coroutine_fn v9fs_readlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    size_t offset = 7;\n    V9fsString target;\n    int32_t fid;\n    int err = 0;\n    V9fsFidState *fidp;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_readlink(pdu->tag, pdu->id, fid);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    v9fs_string_init(&target);\n    err = v9fs_co_readlink(pdu, &fidp->path, &target);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"s\", &target);\n    if (err < 0) {\n        v9fs_string_free(&target);\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_readlink_return(pdu->tag, pdu->id, target.data);\n    v9fs_string_free(&target);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187084, "func": " void MediaStreamManager::CancelAllRequests(int render_process_id,\n                                           int render_frame_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   auto request_it = requests_.begin();\n   while (request_it != requests_.end()) {\n     if (request_it->second->requesting_process_id != render_process_id ||\n        request_it->second->requesting_frame_id != render_frame_id) {\n       ++request_it;\n       continue;\n     }\n    const std::string label = request_it->first;\n    ++request_it;\n    CancelRequest(label);\n  }\n}\n", "target": 1, "flaw_line_index": "2,7"}
{"idx": 187076, "func": " void MediaStreamDispatcherHost::CancelAllRequests() {\n  if (!bindings_.empty())\n    return;\n  media_stream_manager_->CancelAllRequests(render_process_id_,\n                                           render_frame_id_);\n }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 8114, "func": "void Gfx::opConcat(Object args[], int numArgs) {\n  state->concatCTM(args[0].getNum(), args[1].getNum(),\n\t\t   args[2].getNum(), args[3].getNum(),\n\t\t   args[4].getNum(), args[5].getNum());\n  out->updateCTM(state, args[0].getNum(), args[1].getNum(),\n\t\t args[2].getNum(), args[3].getNum(),\n\t\t args[4].getNum(), args[5].getNum());\n  fontChanged = gTrue;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7733, "func": "static void coroutine_fn v9fs_setattr(void *opaque)\n{\n    int err = 0;\n    int32_t fid;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsIattr v9iattr;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"dI\", &fid, &v9iattr);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (v9iattr.valid & P9_ATTR_MODE) {\n        err = v9fs_co_chmod(pdu, &fidp->path, v9iattr.mode);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_ATIME | P9_ATTR_MTIME)) {\n        struct timespec times[2];\n        if (v9iattr.valid & P9_ATTR_ATIME) {\n            if (v9iattr.valid & P9_ATTR_ATIME_SET) {\n                times[0].tv_sec = v9iattr.atime_sec;\n                times[0].tv_nsec = v9iattr.atime_nsec;\n            } else {\n                times[0].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9iattr.valid & P9_ATTR_MTIME) {\n            if (v9iattr.valid & P9_ATTR_MTIME_SET) {\n                times[1].tv_sec = v9iattr.mtime_sec;\n                times[1].tv_nsec = v9iattr.mtime_nsec;\n            } else {\n                times[1].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if ((v9iattr.valid & (P9_ATTR_UID | P9_ATTR_GID)) ||\n        ((v9iattr.valid & P9_ATTR_CTIME)\n         && !((v9iattr.valid & P9_ATTR_MASK) & ~P9_ATTR_CTIME))) {\n        if (!(v9iattr.valid & P9_ATTR_UID)) {\n            v9iattr.uid = -1;\n        }\n        if (!(v9iattr.valid & P9_ATTR_GID)) {\n            v9iattr.gid = -1;\n        }\n        err = v9fs_co_chown(pdu, &fidp->path, v9iattr.uid,\n                            v9iattr.gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_SIZE)) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9iattr.size);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8290, "func": "XRRAllocateMonitor(Display *dpy, int noutput)\n{\n    XRRMonitorInfo *monitor = calloc(1, sizeof (XRRMonitorInfo) + noutput * sizeof (RROutput));\n    if (!monitor)\n\treturn NULL;\n    monitor->outputs = (RROutput *) (monitor + 1);\n    monitor->noutput = noutput;\n    return monitor;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186812, "func": " void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n  } else {\n    auto sensor_fusion_algorithm =\n        std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(\n            true \n);\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n", "target": 1, "flaw_line_index": "3,11,23"}
{"idx": 186766, "func": "RenderProcessHost* SharedWorkerDevToolsAgentHost::GetProcess() {\n  return worker_host_ ? RenderProcessHost::FromID(worker_host_->process_id())\n                      : nullptr;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 187158, "func": "void DownloadCoreServiceImpl::SetDownloadManagerDelegateForTesting(\n    std::unique_ptr<ChromeDownloadManagerDelegate> new_delegate) {\n   manager_delegate_.swap(new_delegate);\n   DownloadManager* dm = BrowserContext::GetDownloadManager(profile_);\n   dm->SetDelegate(manager_delegate_.get());\n  manager_delegate_->SetDownloadManager(dm);\n   if (new_delegate)\n     new_delegate->Shutdown();\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 7754, "func": "append_text_move(pdf_text_state_t *pts, double dw)\n{\n    int count = pts->buffer.count_moves;\n    int pos = pts->buffer.count_chars;\n    double rounded;\n\n    if (count > 0 && pts->buffer.moves[count - 1].index == pos) {\n        dw += pts->buffer.moves[--count].amount;\n    }\n    rounded = floor(dw + 0.5);\n    if (fabs(dw - rounded) < 0.001)\n        dw = rounded;\n    if (dw < -MAX_USER_COORD) {\n        return -1;\n    }\n    if (dw != 0) {\n        if (count == MAX_TEXT_BUFFER_MOVES)\n            return -1;\n        pts->buffer.moves[count].index = pos;\n        pts->buffer.moves[count].amount = dw;\n        ++count;\n    }\n    pts->buffer.count_moves = count;\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8141, "func": "void Gfx::opSetExtGState(Object args[], int numArgs) {\n  Object obj1, obj2, obj3, obj4, obj5;\n  GfxBlendMode mode;\n  GBool haveFillOP;\n  Function *funcs[4];\n  GfxColor backdropColor;\n  GBool haveBackdropColor;\n  GfxColorSpace *blendingColorSpace;\n  GBool alpha, isolated, knockout;\n  int i;\n\n  if (!res->lookupGState(args[0].getName(), &obj1)) {\n    return;\n  }\n  if (!obj1.isDict()) {\n    error(getPos(), \"ExtGState '%s' is wrong type\", args[0].getName());\n    obj1.free();\n    return;\n  }\n  if (printCommands) {\n    printf(\"  gfx state dict: \");\n    obj1.print();\n    printf(\"\\n\");\n  }\n\n  if (!obj1.dictLookup(\"BM\", &obj2)->isNull()) {\n    if (state->parseBlendMode(&obj2, &mode)) {\n      state->setBlendMode(mode);\n      out->updateBlendMode(state);\n    } else {\n      error(getPos(), \"Invalid blend mode in ExtGState\");\n    }\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"ca\", &obj2)->isNum()) {\n    state->setFillOpacity(obj2.getNum());\n    out->updateFillOpacity(state);\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"CA\", &obj2)->isNum()) {\n    state->setStrokeOpacity(obj2.getNum());\n    out->updateStrokeOpacity(state);\n  }\n  obj2.free();\n\n  if ((haveFillOP = (obj1.dictLookup(\"op\", &obj2)->isBool()))) {\n    state->setFillOverprint(obj2.getBool());\n    out->updateFillOverprint(state);\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"OP\", &obj2)->isBool()) {\n    state->setStrokeOverprint(obj2.getBool());\n    out->updateStrokeOverprint(state);\n    if (!haveFillOP) {\n      state->setFillOverprint(obj2.getBool());\n      out->updateFillOverprint(state);\n    }\n  }\n  obj2.free();\n\n  if (obj1.dictLookup(\"SA\", &obj2)->isBool()) {\n    state->setStrokeAdjust(obj2.getBool());\n    out->updateStrokeAdjust(state);\n  }\n  obj2.free();\n\n  if (obj1.dictLookup(\"TR2\", &obj2)->isNull()) {\n    obj2.free();\n    obj1.dictLookup(\"TR\", &obj2);\n  }\n  if (obj2.isName(\"Default\") ||\n      obj2.isName(\"Identity\")) {\n    funcs[0] = funcs[1] = funcs[2] = funcs[3] = NULL;\n    state->setTransfer(funcs);\n    out->updateTransfer(state);\n  } else if (obj2.isArray() && obj2.arrayGetLength() == 4) {\n    for (i = 0; i < 4; ++i) {\n      obj2.arrayGet(i, &obj3);\n      funcs[i] = Function::parse(&obj3);\n      obj3.free();\n      if (!funcs[i]) {\n\tbreak;\n      }\n    }\n    if (i == 4) {\n      state->setTransfer(funcs);\n      out->updateTransfer(state);\n    }\n  } else if (obj2.isName() || obj2.isDict() || obj2.isStream()) {\n    if ((funcs[0] = Function::parse(&obj2))) {\n      funcs[1] = funcs[2] = funcs[3] = NULL;\n      state->setTransfer(funcs);\n      out->updateTransfer(state);\n    }\n  } else if (!obj2.isNull()) {\n    error(getPos(), \"Invalid transfer function in ExtGState\");\n  }\n  obj2.free();\n\n  if (obj1.dictLookup(\"AIS\", &obj2)->isBool()) {\n    state->setAlphaIsShape(obj2.getBool());\n    out->updateAlphaIsShape(state);\n  }\n  obj2.free();\n\n  if (obj1.dictLookup(\"TK\", &obj2)->isBool()) {\n    state->setTextKnockout(obj2.getBool());\n    out->updateTextKnockout(state);\n  }\n  obj2.free();\n\n  if (!obj1.dictLookup(\"SMask\", &obj2)->isNull()) {\n    if (obj2.isName(\"None\")) {\n      out->clearSoftMask(state);\n    } else if (obj2.isDict()) {\n      if (obj2.dictLookup(\"S\", &obj3)->isName(\"Alpha\")) {\n\talpha = gTrue;\n      } else { \n\talpha = gFalse;\n      }\n      obj3.free();\n      funcs[0] = NULL;\n      if (!obj2.dictLookup(\"TR\", &obj3)->isNull()) {\n\tfuncs[0] = Function::parse(&obj3);\n\tif (funcs[0]->getInputSize() != 1 ||\n\t    funcs[0]->getOutputSize() != 1) {\n\t  error(getPos(),\n\t\t\"Invalid transfer function in soft mask in ExtGState\");\n\t  delete funcs[0];\n\t  funcs[0] = NULL;\n\t}\n      }\n      obj3.free();\n      if ((haveBackdropColor = obj2.dictLookup(\"BC\", &obj3)->isArray())) {\n\tfor (i = 0; i < gfxColorMaxComps; ++i) {\n\t  backdropColor.c[i] = 0;\n\t}\n\tfor (i = 0; i < obj3.arrayGetLength() && i < gfxColorMaxComps; ++i) {\n\t  obj3.arrayGet(i, &obj4);\n\t  if (obj4.isNum()) {\n\t    backdropColor.c[i] = dblToCol(obj4.getNum());\n\t  }\n\t  obj4.free();\n\t}\n      }\n      obj3.free();\n      if (obj2.dictLookup(\"G\", &obj3)->isStream()) {\n\tif (obj3.streamGetDict()->lookup(\"Group\", &obj4)->isDict()) {\n\t  blendingColorSpace = NULL;\n\t  isolated = knockout = gFalse;\n\t  if (!obj4.dictLookup(\"CS\", &obj5)->isNull()) {\n\t    blendingColorSpace = GfxColorSpace::parse(&obj5, this);\n\t  }\n\t  obj5.free();\n\t  if (obj4.dictLookup(\"I\", &obj5)->isBool()) {\n\t    isolated = obj5.getBool();\n\t  }\n\t  obj5.free();\n\t  if (obj4.dictLookup(\"K\", &obj5)->isBool()) {\n\t    knockout = obj5.getBool();\n\t  }\n\t  obj5.free();\n\t  if (!haveBackdropColor) {\n\t    if (blendingColorSpace) {\n\t      blendingColorSpace->getDefaultColor(&backdropColor);\n\t    } else {\n\t      for (i = 0; i < gfxColorMaxComps; ++i) {\n\t\tbackdropColor.c[i] = 0;\n\t      }\n\t    }\n\t  }\n\t  doSoftMask(&obj3, alpha, blendingColorSpace,\n\t\t     isolated, knockout, funcs[0], &backdropColor);\n\t  if (funcs[0]) {\n\t    delete funcs[0];\n\t  }\n\t} else {\n\t  error(getPos(), \"Invalid soft mask in ExtGState - missing group\");\n\t}\n\tobj4.free();\n      } else {\n\terror(getPos(), \"Invalid soft mask in ExtGState - missing group\");\n      }\n      obj3.free();\n    } else if (!obj2.isNull()) {\n      error(getPos(), \"Invalid soft mask in ExtGState\");\n    }\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"Font\", &obj2)->isArray()) {\n    GfxFont *font;\n    if (obj2.arrayGetLength() == 2) {\n      Object fargs0, fargs1;\n\n      obj2.arrayGetNF(0,&fargs0);\n      obj2.arrayGet(1,&fargs1);\n      if (fargs0.isRef() && fargs1.isNum()) {\n\tObject fobj;\n\tRef r;\n\n\tfargs0.fetch(xref, &fobj);\n\tif (fobj.isDict()) {\n\t  r = fargs0.getRef();\n\t  font = GfxFont::makeFont(xref,args[0].getName(),r,fobj.getDict());\n\t  state->setFont(font,fargs1.getNum());\n\t  fontChanged = gTrue;\n\t}\n\tfobj.free();\n      }\n      fargs0.free();\n      fargs1.free();\n    } else {\n      error(getPos(), \"Number of args mismatch for /Font in ExtGState\");\n    }\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"LW\", &obj2)->isNum()) {\n    opSetLineWidth(&obj2,1);\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"LC\", &obj2)->isInt()) {\n    opSetLineCap(&obj2,1);\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"LJ\", &obj2)->isInt()) {\n    opSetLineJoin(&obj2,1);\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"ML\", &obj2)->isNum()) {\n    opSetMiterLimit(&obj2,1);\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"D\", &obj2)->isArray()) {\n    if (obj2.arrayGetLength() == 2) {\n      Object dargs[2];\n\n      obj2.arrayGetNF(0,&dargs[0]);\n      obj2.arrayGet(1,&dargs[1]);\n      if (dargs[0].isArray() && dargs[1].isInt()) {\n\topSetDash(dargs,2);\n      }\n      dargs[0].free();\n      dargs[1].free();\n    } else {\n      error(getPos(), \"Number of args mismatch for /D in ExtGState\");\n    }\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"RI\", &obj2)->isName()) {\n    opSetRenderingIntent(&obj2,1);\n  }\n  obj2.free();\n  if (obj1.dictLookup(\"FL\", &obj2)->isNum()) {\n    opSetFlat(&obj2,1);\n  }\n  obj2.free();\n\n  obj1.free();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187304, "func": "bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,\n                                          GURL site_url) {\n  if (RenderProcessHost::run_renderer_in_process())\n    return false;\n\n  if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))\n    return false;\n\n   if (site_url.SchemeIs(content::kGuestScheme))\n     return false;\n \n  if (site_url.SchemeIs(content::kChromeUIScheme))\n    return false;\n  if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,\n                                                         site_url)) {\n    return false;\n  }\n\n  return true;\n}\n", "target": 1, "flaw_line_index": "19,20,21"}
{"idx": 187079, "func": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false \n, std::string(),\n                            MediaStreamDevice());\n    return;\n   }\n \n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, page_request_id, device_id, type,\n      std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n }\n", "target": 1, "flaw_line_index": "17,18"}
{"idx": 7993, "func": "static void vnc_client_cache_addr(VncState *client)\n{\n    VncBasicInfo *bi = vnc_basic_info_get_from_remote_addr(client->csock);\n\n    if (bi) {\n        client->info = g_malloc0(sizeof(*client->info));\n        client->info->base = bi;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186341, "func": "void LoadingStatsCollectorTest::TestRedirectStatusHistogram(\n    const std::string& initial_url,\n    const std::string& prediction_url,\n    const std::string& navigation_url,\n    RedirectStatus expected_status) {\n   const std::string& script_url = \"https:\n   PreconnectPrediction prediction = CreatePreconnectPrediction(\n       GURL(prediction_url).host(), initial_url != prediction_url,\n      {{GURL(script_url).GetOrigin(), 1, net::NetworkIsolationKey()}});\n   EXPECT_CALL(*mock_predictor_, PredictPreconnectOrigins(GURL(initial_url), _))\n       .WillOnce(DoAll(SetArgPointee<1>(prediction), Return(true)));\n \n  std::vector<content::mojom::ResourceLoadInfoPtr> resources;\n  resources.push_back(\n      CreateResourceLoadInfoWithRedirects({initial_url, navigation_url}));\n  resources.push_back(\n      CreateResourceLoadInfo(script_url, content::ResourceType::kScript));\n  PageRequestSummary summary =\n      CreatePageRequestSummary(navigation_url, initial_url, resources);\n\n  stats_collector_->RecordPageRequestSummary(summary);\n\n  histogram_tester_->ExpectUniqueSample(\n      internal::kLoadingPredictorPreconnectLearningRedirectStatus,\n      static_cast<int>(expected_status), 1);\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 187190, "func": "void AutofillManager::GetAvailableSuggestions(\n    const FormData& form,\n    const FormFieldData& field,\n    std::vector<Suggestion>* suggestions,\n    SuggestionsContext* context) {\n  DCHECK(suggestions);\n  DCHECK(context);\n\n  bool is_autofill_possible = RefreshDataModels();\n\n  bool got_autofillable_form =\n      GetCachedFormAndField(form, field, &context->form_structure,\n                            &context->focused_field) &&\n      context->form_structure->ShouldBeParsed();\n\n  if (got_autofillable_form) {\n    if (context->focused_field->Type().group() == CREDIT_CARD) {\n      context->is_filling_credit_card = true;\n      driver()->DidInteractWithCreditCardForm();\n      credit_card_form_event_logger_->OnDidInteractWithAutofillableForm(\n          context->form_structure->form_signature());\n    } else {\n      address_form_event_logger_->OnDidInteractWithAutofillableForm(\n          context->form_structure->form_signature());\n    }\n  }\n\n  context->is_context_secure =\n      !IsFormNonSecure(form) ||\n      !base::FeatureList::IsEnabled(\n          features::kAutofillRequireSecureCreditCardContext);\n\n\n  if (!is_autofill_possible || !driver()->RendererIsAvailable() ||\n      !got_autofillable_form)\n    return;\n\n  context->is_autofill_available = true;\n\n  if (context->is_filling_credit_card) {\n    *suggestions =\n        GetCreditCardSuggestions(field, context->focused_field->Type(),\n                                 &context->is_all_server_suggestions);\n\n    if (base::FeatureList::IsEnabled(kAutofillCreditCardAblationExperiment) &&\n        !suggestions->empty()) {\n      context->suppress_reason = SuppressReason::kCreditCardsAblation;\n      suggestions->clear();\n      return;\n    }\n  } else {\n    if (!base::FeatureList::IsEnabled(kAutofillAlwaysFillAddresses) &&\n        IsDesktopPlatform() && !field.should_autocomplete) {\n      context->suppress_reason = SuppressReason::kAutocompleteOff;\n      return;\n    }\n\n    *suggestions = GetProfileSuggestions(*context->form_structure, field,\n                                         *context->focused_field);\n  }\n\n  if (!suggestions->empty() && context->is_filling_credit_card &&\n      !context->is_context_secure) {\n    Suggestion warning_suggestion(\n        l10n_util::GetStringUTF16(IDS_AUTOFILL_WARNING_INSECURE_CONNECTION));\n     warning_suggestion.frontend_id =\n         POPUP_ITEM_ID_INSECURE_CONTEXT_PAYMENT_DISABLED_MESSAGE;\n     suggestions->assign(1, warning_suggestion);\n  } else {\n    context->section_has_autofilled_field = SectionHasAutofilledField(\n        *context->form_structure, form, context->focused_field->section);\n    if (context->section_has_autofilled_field) {\n      std::set<base::string16> seen_values;\n      for (auto iter = suggestions->begin(); iter != suggestions->end();) {\n        if (!seen_values.insert(iter->value).second) {\n          iter = suggestions->erase(iter);\n        } else {\n          iter->label.clear();\n          iter->icon.clear();\n          ++iter;\n        }\n      }\n    }\n   }\n }\n", "target": 1, "flaw_line_index": "85,86"}
{"idx": 7583, "func": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n        memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n\toff_begin += off_pitch;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186799, "func": " PlatformSensor::PlatformSensor(mojom::SensorType type,\n                               mojo::ScopedSharedBufferMapping mapping,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n      shared_buffer_mapping_(std::move(mapping)),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n", "target": 1, "flaw_line_index": "2,5"}
{"idx": 187038, "func": "DocumentInit& DocumentInit::WithPreviousDocumentCSP(\n    const ContentSecurityPolicy* previous_csp) {\n  DCHECK(!previous_csp_);\n  previous_csp_ = previous_csp;\n  return *this;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7785, "func": "static int h2_snd_buf(struct conn_stream *cs, struct buffer *buf, int flags)\n{\n\tstruct h2s *h2s = cs->ctx;\n\tint total = 0;\n\n\tif (!(h2s->flags & H2_SF_OUTGOING_DATA) && buf->o)\n\t\th2s->flags |= H2_SF_OUTGOING_DATA;\n\n\twhile (h2s->res.state < HTTP_MSG_DONE && buf->o) {\n\t\tif (h2s->res.state < HTTP_MSG_BODY) {\n\t\t\ttotal += h2s_frt_make_resp_headers(h2s, buf);\n\n\t\t\tif (h2s->st >= H2_SS_ERROR)\n\t\t\t\tbreak;\n\n\t\t\tif (h2s->flags & H2_SF_BLK_ANY)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (h2s->res.state < HTTP_MSG_TRAILERS) {\n\t\t\ttotal += h2s_frt_make_resp_data(h2s, buf);\n\n\t\t\tif (h2s->st >= H2_SS_ERROR)\n\t\t\t\tbreak;\n\n\t\t\tif (h2s->flags & H2_SF_BLK_ANY)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (h2s->res.state == HTTP_MSG_TRAILERS) {\n\t\t\tint count = h1_measure_trailers(buf);\n\n\t\t\tif (unlikely(count <= 0)) {\n\t\t\t\tif (count < 0)\n\t\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal += count;\n\t\t\tbo_del(buf, count);\n\n\t\t\tbo_del(buf, buf->o);\n\n\t\t\th2s->res.state = HTTP_MSG_DONE;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcs->flags |= CS_FL_ERROR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (h2s->st == H2_SS_ERROR || h2s->flags & H2_SF_RST_RCVD) {\n\t\tcs->flags |= CS_FL_ERROR;\n\t\tif (h2s_send_rst_stream(h2s->h2c, h2s) > 0)\n\t\t\th2s_close(h2s);\n\t}\n\n\tif (h2s->flags & H2_SF_BLK_SFCTL) {\n\t\tLIST_DEL(&h2s->list);\n\t\tLIST_INIT(&h2s->list);\n\t}\n\telse if (LIST_ISEMPTY(&h2s->list)) {\n\t\tif (h2s->flags & H2_SF_BLK_MFCTL)\n\t\t\tLIST_ADDQ(&h2s->h2c->fctl_list, &h2s->list);\n\t\telse if (h2s->flags & (H2_SF_BLK_MBUSY|H2_SF_BLK_MROOM))\n\t\t\tLIST_ADDQ(&h2s->h2c->send_list, &h2s->list);\n\t}\n\n\treturn total;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8115, "func": "void Gfx::opCurveTo(Object args[], int numArgs) {\n  double x1, y1, x2, y2, x3, y3;\n\n  if (!state->isCurPt()) {\n    error(getPos(), \"No current point in curveto\");\n    return;\n  }\n  x1 = args[0].getNum();\n  y1 = args[1].getNum();\n  x2 = args[2].getNum();\n  y2 = args[3].getNum();\n  x3 = args[4].getNum();\n  y3 = args[5].getNum();\n  state->curveTo(x1, y1, x2, y2, x3, y3);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187191, "func": "void AutofillManager::OnQueryFormFieldAutofillImpl(\n    int query_id,\n    const FormData& form,\n    const FormFieldData& field,\n    const gfx::RectF& transformed_box,\n    bool autoselect_first_suggestion) {\n  external_delegate_->OnQuery(query_id, form, field, transformed_box);\n\n  std::vector<Suggestion> suggestions;\n  SuggestionsContext context;\n  GetAvailableSuggestions(form, field, &suggestions, &context);\n\n  if (context.is_autofill_available) {\n    switch (context.suppress_reason) {\n      case SuppressReason::kNotSuppressed:\n        break;\n\n      case SuppressReason::kCreditCardsAblation:\n        enable_ablation_logging_ = true;\n        autocomplete_history_manager_->CancelPendingQuery();\n        external_delegate_->OnSuggestionsReturned(query_id, suggestions,\n                                                  autoselect_first_suggestion);\n        return;\n\n      case SuppressReason::kAutocompleteOff:\n        return;\n    }\n\n    if (!suggestions.empty()) {\n      if (context.is_filling_credit_card) {\n        AutofillMetrics::LogIsQueriedCreditCardFormSecure(\n            context.is_context_secure);\n      }\n\n      if (!has_logged_address_suggestions_count_ &&\n          !context.section_has_autofilled_field) {\n         AutofillMetrics::LogAddressSuggestionsCount(suggestions.size());\n         has_logged_address_suggestions_count_ = true;\n       }\n    }\n  }\n\n  if (suggestions.empty() && !ShouldShowCreditCardSigninPromo(form, field) &&\n      field.should_autocomplete &&\n      !(context.focused_field &&\n        (IsCreditCardExpirationType(\n             context.focused_field->Type().GetStorableType()) ||\n         context.focused_field->Type().html_type() == HTML_TYPE_UNRECOGNIZED ||\n         context.focused_field->Type().GetStorableType() ==\n             CREDIT_CARD_NUMBER ||\n         context.focused_field->Type().GetStorableType() ==\n             CREDIT_CARD_VERIFICATION_CODE))) {\n    autocomplete_history_manager_->OnGetAutocompleteSuggestions(\n        query_id, field.name, field.value, field.form_control_type);\n    return;\n  }\n\n  autocomplete_history_manager_->CancelPendingQuery();\n  external_delegate_->OnSuggestionsReturned(query_id, suggestions,\n                                            autoselect_first_suggestion,\n                                            context.is_all_server_suggestions);\n}\n", "target": 1, "flaw_line_index": "39,40"}
{"idx": 7848, "func": "static void mig_sleep_cpu(void *opq)\n{\n    qemu_mutex_unlock_iothread();\n    g_usleep(30*1000);\n    qemu_mutex_lock_iothread();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186980, "func": " std::string SerializeDefaultPaddingKey() {\n  return (*GetPaddingKey())->key();\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8259, "func": "WireToLibRange(\n    xRecordRange *wire_range,\n    XRecordRange *lib_range)\n{\n    lib_range->core_requests.first = wire_range->coreRequestsFirst;\n    lib_range->core_requests.last = wire_range->coreRequestsLast;\n    lib_range->core_replies.first = wire_range->coreRepliesFirst;\n    lib_range->core_replies.last = wire_range->coreRepliesLast;\n    lib_range->ext_requests.ext_major.first = wire_range->extRequestsMajorFirst;\n    lib_range->ext_requests.ext_major.last = wire_range->extRequestsMajorLast;\n    lib_range->ext_requests.ext_minor.first = wire_range->extRequestsMinorFirst;\n    lib_range->ext_requests.ext_minor.last = wire_range->extRequestsMinorLast;\n    lib_range->ext_replies.ext_major.first = wire_range->extRepliesMajorFirst;\n    lib_range->ext_replies.ext_major.last = wire_range->extRepliesMajorLast;\n    lib_range->ext_replies.ext_minor.first = wire_range->extRepliesMinorFirst;\n    lib_range->ext_replies.ext_minor.last = wire_range->extRepliesMinorLast;\n    lib_range->delivered_events.first = wire_range->deliveredEventsFirst;\n    lib_range->delivered_events.last = wire_range->deliveredEventsLast;\n    lib_range->device_events.first = wire_range->deviceEventsFirst;\n    lib_range->device_events.last = wire_range->deviceEventsLast;\n    lib_range->errors.first = wire_range->errorsFirst;\n    lib_range->errors.last = wire_range->errorsLast;\n    lib_range->client_started = wire_range->clientStarted;\n    lib_range->client_died = wire_range->clientDied;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7698, "func": "static int handle_unlinkat(FsContext *ctx, V9fsPath *dir,\n                           const char *name, int flags)\n{\n    int dirfd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n    int rflags;\n\n    dirfd = open_by_handle(data->mountfd, dir->data, O_PATH);\n    if (dirfd < 0) {\n        return dirfd;\n    }\n\n    rflags = 0;\n    if (flags & P9_DOTL_AT_REMOVEDIR) {\n        rflags |= AT_REMOVEDIR;\n    }\n\n    ret = unlinkat(dirfd, name, rflags);\n\n    close(dirfd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8111, "func": "void Gfx::opCloseEOFillStroke(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    return;\n  }\n  if (state->isPath() && !contentIsHidden()) {\n    state->closePath();\n    if (state->getFillColorSpace()->getMode() == csPattern) {\n      doPatternFill(gTrue);\n    } else {\n      out->eoFill(state);\n    }\n    if (state->getStrokeColorSpace()->getMode() == csPattern) {\n      doPatternStroke();\n    } else {\n      out->stroke(state);\n    }\n  }\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187118, "func": " void GCInfoTable::EnsureGCInfoIndex(const GCInfo* gc_info,\n                                     size_t* gc_info_index_slot) {\n   DCHECK(gc_info);\n   DCHECK(gc_info_index_slot);\n  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());\n  MutexLocker locker(mutex);\n \n   if (*gc_info_index_slot)\n     return;\n \n  int index = ++gc_info_index_;\n   size_t gc_info_index = static_cast<size_t>(index);\n   CHECK(gc_info_index < GCInfoTable::kMaxIndex);\n  if (gc_info_index >= gc_info_table_size_)\n     Resize();\n \n  g_gc_info_table[gc_info_index] = gc_info;\n   ReleaseStore(reinterpret_cast<int*>(gc_info_index_slot), index);\n }\n", "target": 1, "flaw_line_index": "5,6,7,15,18"}
{"idx": 186896, "func": "void ResourceCoordinatorService::OnStart() {\n  ref_factory_.reset(new service_manager::ServiceContextRefFactory(\n      base::Bind(&service_manager::ServiceContext::RequestQuit,\n                 base::Unretained(context()))));\n\n  ukm_recorder_ = ukm::MojoUkmRecorder::Create(context()->connector());\n\n  registry_.AddInterface(\n      base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,\n                 base::Unretained(&introspector_)));\n\n  auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();\n  registry_.AddInterface(\n      base::Bind(&PageSignalGeneratorImpl::BindToInterface,\n                 base::Unretained(page_signal_generator_impl.get())));\n  coordination_unit_manager_.RegisterObserver(\n      std::move(page_signal_generator_impl));\n\n  coordination_unit_manager_.RegisterObserver(\n      std::make_unique<MetricsCollector>());\n\n  coordination_unit_manager_.RegisterObserver(\n      std::make_unique<IPCVolumeReporter>(\n          std::make_unique<base::OneShotTimer>()));\n\n  coordination_unit_manager_.OnStart(&registry_, ref_factory_.get());\n  coordination_unit_manager_.set_ukm_recorder(ukm_recorder_.get());\n\n  memory_instrumentation_coordinator_ =\n      std::make_unique<memory_instrumentation::CoordinatorImpl>(\n          context()->connector());\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(\n      base::BindRepeating(&tracing::AgentRegistry::BindAgentRegistryRequest,\n                          base::Unretained(tracing_agent_registry_.get())));\n\n  tracing_coordinator_ = std::make_unique<tracing::Coordinator>();\n  registry_.AddInterface(\n      base::BindRepeating(&tracing::Coordinator::BindCoordinatorRequest,\n                          base::Unretained(tracing_coordinator_.get())));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7795, "func": "static int h2c_frt_recv_preface(struct h2c *h2c)\n{\n\tint ret1;\n\tint ret2;\n\n\tret1 = b_isteq(h2c->dbuf, 0, h2c->dbuf->i, ist(H2_CONN_PREFACE));\n\n\tif (unlikely(ret1 <= 0)) {\n\t\tif (ret1 < 0 || conn_xprt_read0_pending(h2c->conn))\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\treturn 0;\n\t}\n\n\tret2 = h2c_snd_settings(h2c);\n\tif (ret2 > 0)\n\t\tbi_del(h2c->dbuf, ret1);\n\n\treturn ret2;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187049, "func": " bool SVGElement::HasSVGParent() const {\n  return ParentOrShadowHostElement() &&\n         ParentOrShadowHostElement()->IsSVGElement();\n }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 186559, "func": "  const net::HttpRequestHeaders& request_headers() const {\n    return request_headers_;\n  }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 186546, "func": " void ProfileChooserView::SignOutAllWebAccounts() {\n   Hide();\n   ProfileOAuth2TokenServiceFactory::GetForProfile(browser_->profile())\n      ->RevokeAllCredentials();\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186690, "func": "size_t NormalPage::objectPayloadSizeForTesting() {\n  size_t objectPayloadSize = 0;\n  Address headerAddress = payload();\n  markAsSwept();\n  ASSERT(headerAddress != payloadEnd());\n  do {\n     HeapObjectHeader* header =\n         reinterpret_cast<HeapObjectHeader*>(headerAddress);\n     if (!header->isFree()) {\n      ASSERT(header->checkHeader());\n       objectPayloadSize += header->payloadSize();\n     }\n     ASSERT(header->size() < blinkPagePayloadSize());\n    headerAddress += header->size();\n    ASSERT(headerAddress <= payloadEnd());\n  } while (headerAddress < payloadEnd());\n  return objectPayloadSize;\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 186514, "func": "void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {\n  DCHECK(submission->method() == FormSubmission::PostMethod ||\n         submission->method() == FormSubmission::GetMethod);\n  DCHECK(submission->data());\n  DCHECK(submission->form());\n  if (submission->action().isEmpty())\n    return;\n  if (document().isSandboxed(SandboxForms)) {\n    document().addConsoleMessage(ConsoleMessage::create(\n        SecurityMessageSource, ErrorMessageLevel,\n        \"Blocked form submission to '\" + submission->action().elidedString() +\n            \"' because the form's frame is sandboxed and the 'allow-forms' \"\n            \"permission is not set.\"));\n     return;\n   }\n \n   if (protocolIsJavaScript(submission->action())) {\n    if (!document().contentSecurityPolicy()->allowFormAction(\n            submission->action()))\n      return;\n     document().frame()->script().executeScriptIfJavaScriptURL(\n         submission->action(), this);\n     return;\n  }\n\n  Frame* targetFrame = document().frame()->findFrameForNavigation(\n      submission->target(), *document().frame());\n  if (!targetFrame) {\n    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&\n        !UserGestureIndicator::utilizeUserGesture())\n      return;\n    targetFrame = document().frame();\n  } else {\n    submission->clearTarget();\n  }\n  if (!targetFrame->host())\n    return;\n\n  UseCounter::count(document(), UseCounter::FormsSubmitted);\n  if (MixedContentChecker::isMixedFormAction(document().frame(),\n                                             submission->action()))\n    UseCounter::count(document().frame(),\n                      UseCounter::MixedContentFormsSubmitted);\n\n  if (targetFrame->isLocalFrame()) {\n    toLocalFrame(targetFrame)\n        ->navigationScheduler()\n        .scheduleFormSubmission(&document(), submission);\n  } else {\n    FrameLoadRequest frameLoadRequest =\n        submission->createFrameLoadRequest(&document());\n    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);\n  }\n}\n", "target": 1, "flaw_line_index": "20,21,22"}
{"idx": 7787, "func": "static void h2_update_poll(struct conn_stream *cs)\n{\n\tstruct h2s *h2s = cs->ctx;\n\n\tif (!h2s)\n\t\treturn;\n\n\n\tif (cs->flags & CS_FL_DATA_RD_ENA) {\n\t\th2s->h2c->flags &= ~H2_CF_DEM_SFULL;\n\t\tif (h2s->h2c->dsi == h2s->id) {\n\t\t\tconn_xprt_want_recv(cs->conn);\n\t\t\tconn_xprt_want_send(cs->conn);\n\t\t}\n\t}\n\n\n\tif (cs->flags & CS_FL_DATA_WR_ENA) {\n\t\tif (LIST_ISEMPTY(&h2s->list)) {\n\t\t\tif (LIST_ISEMPTY(&h2s->h2c->send_list) &&\n\t\t\t    !h2s->h2c->mbuf->o && \n\t\t\t    !(cs->conn->flags & CO_FL_SOCK_WR_SH))\n\t\t\t\tconn_xprt_want_send(cs->conn);\n\t\t\tLIST_ADDQ(&h2s->h2c->send_list, &h2s->list);\n\t\t}\n\t}\n\telse if (!LIST_ISEMPTY(&h2s->list)) {\n\t\tLIST_DEL(&h2s->list);\n\t\tLIST_INIT(&h2s->list);\n\t\th2s->flags &= ~(H2_SF_BLK_MBUSY | H2_SF_BLK_MROOM | H2_SF_BLK_MFCTL);\n\t}\n\n\tif (h2s->h2c->mbuf->o && !(cs->conn->flags & CO_FL_XPRT_WR_ENA))\n\t\tconn_xprt_want_send(cs->conn);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7960, "func": "static int current_led_state(VncState *vs)\n{\n    int ledstate = 0;\n\n    if (vs->modifiers_state[0x46]) {\n        ledstate |= QEMU_SCROLL_LOCK_LED;\n    }\n    if (vs->modifiers_state[0x45]) {\n        ledstate |= QEMU_NUM_LOCK_LED;\n    }\n    if (vs->modifiers_state[0x3a]) {\n        ledstate |= QEMU_CAPS_LOCK_LED;\n    }\n\n    return ledstate;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186599, "func": "bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return true;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 7603, "func": "static void cirrus_vga_mem_write(void *opaque,\n                                 hwaddr addr,\n                                 uint64_t mem_value,\n                                 uint32_t size)\n{\n    CirrusVGAState *s = opaque;\n    unsigned bank_index;\n    unsigned bank_offset;\n    unsigned mode;\n\n    if ((s->vga.sr[0x07] & 0x01) == 0) {\n        vga_mem_writeb(&s->vga, addr, mem_value);\n        return;\n    }\n\n    if (addr < 0x10000) {\n\tif (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n\t    *s->cirrus_srcptr++ = (uint8_t) mem_value;\n\t    if (s->cirrus_srcptr >= s->cirrus_srcptr_end) {\n\t\tcirrus_bitblt_cputovideo_next(s);\n\t    }\n\t} else {\n\t    bank_index = addr >> 15;\n\t    bank_offset = addr & 0x7fff;\n\t    if (bank_offset < s->cirrus_bank_limit[bank_index]) {\n\t\tbank_offset += s->cirrus_bank_base[bank_index];\n\t\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\t\t    bank_offset <<= 4;\n\t\t} else if (s->vga.gr[0x0B] & 0x02) {\n\t\t    bank_offset <<= 3;\n\t\t}\n\t\tbank_offset &= s->cirrus_addr_mask;\n\t\tmode = s->vga.gr[0x05] & 0x7;\n\t\tif (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {\n\t\t    *(s->vga.vram_ptr + bank_offset) = mem_value;\n                    memory_region_set_dirty(&s->vga.vram, bank_offset,\n                                            sizeof(mem_value));\n\t\t} else {\n\t\t    if ((s->vga.gr[0x0B] & 0x14) != 0x14) {\n\t\t\tcirrus_mem_writeb_mode4and5_8bpp(s, mode,\n\t\t\t\t\t\t\t bank_offset,\n\t\t\t\t\t\t\t mem_value);\n\t\t    } else {\n\t\t\tcirrus_mem_writeb_mode4and5_16bpp(s, mode,\n\t\t\t\t\t\t\t  bank_offset,\n\t\t\t\t\t\t\t  mem_value);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    } else if (addr >= 0x18000 && addr < 0x18100) {\n\tif ((s->vga.sr[0x17] & 0x44) == 0x04) {\n\t    cirrus_mmio_blt_write(s, addr & 0xff, mem_value);\n\t}\n    } else {\n#ifdef DEBUG_CIRRUS\n        printf(\"cirrus: mem_writeb \" TARGET_FMT_plx \" value 0x%02\" PRIu64 \"\\n\", addr,\n               mem_value);\n#endif\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8237, "func": "static void v9fs_symlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsString name;\n    V9fsString symname;\n    V9fsFidState *dfidp;\n    V9fsQID qid;\n    struct stat stbuf;\n    int32_t dfid;\n    int err = 0;\n    gid_t gid;\n    size_t offset = 7;\n\n    v9fs_string_init(&name);\n    v9fs_string_init(&symname);\n    err = pdu_unmarshal(pdu, offset, \"dssd\", &dfid, &name, &symname, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_symlink(pdu->tag, pdu->id, dfid, name.data, symname.data, gid);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    err = v9fs_co_symlink(pdu, dfidp, &name, symname.data, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err =  pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_symlink_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n    v9fs_string_free(&symname);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186886, "func": "void BaseRenderingContext2D::setStrokeStyle(\n    const StringOrCanvasGradientOrCanvasPattern& style) {\n  DCHECK(!style.IsNull());\n\n  String color_string;\n  CanvasStyle* canvas_style = nullptr;\n  if (style.IsString()) {\n    color_string = style.GetAsString();\n    if (color_string == GetState().UnparsedStrokeColor())\n      return;\n    Color parsed_color = 0;\n    if (!ParseColorOrCurrentColor(parsed_color, color_string))\n      return;\n    if (GetState().StrokeStyle()->IsEquivalentRGBA(parsed_color.Rgb())) {\n      ModifiableState().SetUnparsedStrokeColor(color_string);\n      return;\n    }\n    canvas_style = CanvasStyle::CreateFromRGBA(parsed_color.Rgb());\n  } else if (style.IsCanvasGradient()) {\n    canvas_style = CanvasStyle::CreateFromGradient(style.GetAsCanvasGradient());\n   } else if (style.IsCanvasPattern()) {\n     CanvasPattern* canvas_pattern = style.GetAsCanvasPattern();\n \n    if (OriginClean() && !canvas_pattern->OriginClean()) {\n      SetOriginTainted();\n      ClearResolvedFilters();\n    }\n \n     canvas_style = CanvasStyle::CreateFromPattern(canvas_pattern);\n   }\n\n  DCHECK(canvas_style);\n\n  ModifiableState().SetStrokeStyle(canvas_style);\n  ModifiableState().SetUnparsedStrokeColor(color_string);\n  ModifiableState().ClearResolvedFilter();\n}\n", "target": 1, "flaw_line_index": "24,25,26,27"}
{"idx": 186675, "func": " void BackendImpl::OnEntryDestroyEnd() {\n   DecreaseNumRefs();\n  if (data_->header.num_bytes > max_size_ && !read_only_ &&\n      (up_ticks_ > kTrimDelay || user_flags_ & kNoRandom))\n    eviction_.TrimCache(false);\n }\n", "target": 1, "flaw_line_index": "3,4,5"}
{"idx": 186318, "func": "const service_manager::Manifest& GetChromeContentBrowserOverlayManifest() {\n  static base::NoDestructor<service_manager::Manifest> manifest {\n    service_manager::ManifestBuilder()\n        .ExposeCapability(\"gpu\",\n                          service_manager::Manifest::InterfaceList<\n                              metrics::mojom::CallStackProfileCollector>())\n        .ExposeCapability(\"renderer\",\n                          service_manager::Manifest::InterfaceList<\n                              chrome::mojom::AvailableOfflineContentProvider,\n                              chrome::mojom::CacheStatsRecorder,\n                              chrome::mojom::NetBenchmarking,\n                              data_reduction_proxy::mojom::DataReductionProxy,\n                              metrics::mojom::CallStackProfileCollector,\n#if defined(OS_WIN)\n                              mojom::ModuleEventSink,\n#endif\n                              rappor::mojom::RapporRecorder,\n                              safe_browsing::mojom::SafeBrowsing>())\n        .RequireCapability(\"ash\", \"system_ui\")\n        .RequireCapability(\"ash\", \"test\")\n        .RequireCapability(\"ash\", \"display\")\n        .RequireCapability(\"assistant\", \"assistant\")\n        .RequireCapability(\"assistant_audio_decoder\", \"assistant:audio_decoder\")\n        .RequireCapability(\"chrome\", \"input_device_controller\")\n        .RequireCapability(\"chrome_printing\", \"converter\")\n        .RequireCapability(\"cups_ipp_parser\", \"ipp_parser\")\n        .RequireCapability(\"device\", \"device:fingerprint\")\n        .RequireCapability(\"device\", \"device:geolocation_config\")\n        .RequireCapability(\"device\", \"device:geolocation_control\")\n        .RequireCapability(\"device\", \"device:ip_geolocator\")\n        .RequireCapability(\"ime\", \"input_engine\")\n        .RequireCapability(\"mirroring\", \"mirroring\")\n        .RequireCapability(\"nacl_broker\", \"browser\")\n        .RequireCapability(\"nacl_loader\", \"browser\")\n        .RequireCapability(\"noop\", \"noop\")\n        .RequireCapability(\"patch\", \"patch_file\")\n        .RequireCapability(\"preferences\", \"pref_client\")\n        .RequireCapability(\"preferences\", \"pref_control\")\n        .RequireCapability(\"profile_import\", \"import\")\n        .RequireCapability(\"removable_storage_writer\",\n                           \"removable_storage_writer\")\n        .RequireCapability(\"secure_channel\", \"secure_channel\")\n        .RequireCapability(\"ui\", \"ime_registrar\")\n        .RequireCapability(\"ui\", \"input_device_controller\")\n        .RequireCapability(\"ui\", \"window_manager\")\n        .RequireCapability(\"unzip\", \"unzip_file\")\n        .RequireCapability(\"util_win\", \"util_win\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_provider\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_test_hook\")\n#if defined(OS_CHROMEOS)\n        .RequireCapability(\"multidevice_setup\", \"multidevice_setup\")\n#endif\n        .ExposeInterfaceFilterCapability_Deprecated(\n            \"navigation:frame\", \"renderer\",\n            service_manager::Manifest::InterfaceList<\n                autofill::mojom::AutofillDriver,\n                autofill::mojom::PasswordManagerDriver,\n                chrome::mojom::OfflinePageAutoFetcher,\n#if defined(OS_CHROMEOS)\n                 chromeos_camera::mojom::CameraAppHelper,\n                 chromeos::cellular_setup::mojom::CellularSetup,\n                 chromeos::crostini_installer::mojom::PageHandlerFactory,\n                chromeos::crostini_upgrader::mojom::PageHandlerFactory,\n                 chromeos::ime::mojom::InputEngineManager,\n                 chromeos::machine_learning::mojom::PageHandler,\n                 chromeos::media_perception::mojom::MediaPerception,\n                chromeos::multidevice_setup::mojom::MultiDeviceSetup,\n                chromeos::multidevice_setup::mojom::PrivilegedHostDeviceSetter,\n                chromeos::network_config::mojom::CrosNetworkConfig,\n                cros::mojom::CameraAppDeviceProvider,\n#endif\n                contextual_search::mojom::ContextualSearchJsApiService,\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n                extensions::KeepAlive,\n#endif\n                media::mojom::MediaEngagementScoreDetailsProvider,\n                media_router::mojom::MediaRouter,\n                page_load_metrics::mojom::PageLoadMetrics,\n                translate::mojom::ContentTranslateDriver,\n\n                downloads::mojom::PageHandlerFactory,\n                feed_internals::mojom::PageHandler,\n                new_tab_page::mojom::PageHandlerFactory,\n#if defined(OS_ANDROID)\n                explore_sites_internals::mojom::PageHandler,\n#else\n                app_management::mojom::PageHandlerFactory,\n#endif\n#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \\\n    defined(OS_CHROMEOS)\n                discards::mojom::DetailsProvider, discards::mojom::GraphDump,\n#endif\n#if defined(OS_CHROMEOS)\n                add_supervision::mojom::AddSupervisionHandler,\n#endif\n                mojom::BluetoothInternalsHandler,\n                mojom::InterventionsInternalsPageHandler,\n                mojom::OmniboxPageHandler, mojom::ResetPasswordHandler,\n                mojom::SiteEngagementDetailsProvider,\n                mojom::UsbInternalsPageHandler,\n                snippets_internals::mojom::PageHandlerFactory>())\n        .PackageService(prefs::GetManifest())\n#if defined(OS_CHROMEOS)\n        .PackageService(chromeos::multidevice_setup::GetManifest())\n#endif  \n        .Build()\n  };\n  return *manifest;\n}\n", "target": 1, "flaw_line_index": "64"}
{"idx": 187062, "func": " void PaymentRequest::Abort() {\n\n  bool accepting_abort = !state_->IsPaymentAppInvoked();\n  if (accepting_abort)\n    RecordFirstAbortReason(JourneyLogger::ABORT_REASON_ABORTED_BY_MERCHANT);\n\n  if (client_.is_bound())\n    client_->OnAbort(accepting_abort);\n\n  if (observer_for_testing_)\n    observer_for_testing_->OnAbortCalled();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7711, "func": "static void coroutine_fn v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err += offset;\n    memcpy(&s->root_qid, &qid, sizeof(qid));\n    trace_v9fs_attach_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path);\n    if (!s->migration_blocker) {\n        s->root_fid = fid;\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        migrate_add_blocker(s->migration_blocker);\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8099, "func": "GBool GfxResources::lookupGState(char *name, Object *obj) {\n  if (!lookupGStateNF(name, obj))\n    return gFalse;\n\n  if (!obj->isRef())\n    return gTrue;\n  \n  const Ref ref = obj->getRef();\n  if (!gStateCache.lookup(ref, obj)->isNull())\n    return gTrue;\n  obj->free();\n\n  gStateCache.put(ref)->copy(obj);\n  return gTrue;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186388, "func": " void DataReductionProxyConfigServiceClient::RetrieveRemoteConfig() {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   CreateClientConfigRequest request;\n   std::string serialized_request;\n #if defined(OS_ANDROID)\n  request.set_telephony_network_operator(\n      net::android::GetTelephonyNetworkOperator());\n#endif\n\n  data_reduction_proxy::ConfigDeviceInfo* device_info =\n      request.mutable_device_info();\n  device_info->set_total_device_memory_kb(\n      base::SysInfo::AmountOfPhysicalMemory() / 1024);\n  const std::string& session_key = request_options_->GetSecureSession();\n  if (!session_key.empty())\n    request.set_session_key(request_options_->GetSecureSession());\n  request.set_dogfood_group(\n      base::FeatureList::IsEnabled(features::kDogfood)\n          ? CreateClientConfigRequest_DogfoodGroup_DOGFOOD\n          : CreateClientConfigRequest_DogfoodGroup_NONDOGFOOD);\n  data_reduction_proxy::VersionInfo* version_info =\n      request.mutable_version_info();\n  uint32_t build;\n  uint32_t patch;\n  util::GetChromiumBuildAndPatchAsInts(util::ChromiumVersion(), &build, &patch);\n  version_info->set_client(util::GetStringForClient(io_data_->client()));\n  version_info->set_build(build);\n  version_info->set_patch(patch);\n  version_info->set_channel(io_data_->channel());\n  request.SerializeToString(&serialized_request);\n\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\"data_reduction_proxy_config\", R\"(\n        semantics {\n          sender: \"Data Reduction Proxy\"\n          description:\n            \"Requests a configuration that specifies how to connect to the \"\n            \"data reduction proxy.\"\n          trigger:\n            \"Requested when Data Saver is enabled and the browser does not \"\n            \"have a configuration that is not older than a threshold set by \"\n            \"the server.\"\n          data: \"None.\"\n          destination: GOOGLE_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: NO\n          setting:\n            \"Users can control Data Saver on Android via 'Data Saver' setting. \"\n            \"Data Saver is not available on iOS, and on desktop it is enabled \"\n            \"by insalling the Data Saver extension.\"\n          policy_exception_justification: \"Not implemented.\"\n        })\");\n  fetch_in_progress_ = true;\n\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n  resource_request->url = config_service_url_;\n  resource_request->method = \"POST\";\n  resource_request->load_flags = net::LOAD_BYPASS_PROXY;\n  resource_request->allow_credentials = false;\n  url_loader_ = variations::CreateSimpleURLLoaderWithVariationsHeader(\n      std::move(resource_request), variations::InIncognito::kNo,\n      variations::SignedIn::kNo, traffic_annotation);\n\n  url_loader_->AttachStringForUpload(serialized_request,\n                                     \"application/x-protobuf\");\n  static const int kMaxRetries = 5;\n  url_loader_->SetRetryOptions(\n      kMaxRetries, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE);\n  url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(\n      url_loader_factory_.get(),\n      base::BindOnce(&DataReductionProxyConfigServiceClient::OnURLLoadComplete,\n                     base::Unretained(this)));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7918, "func": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\tcstm(J, F, finallystm); \n\t\t\temit(J, F, OP_THROW); \n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (J->strict) {\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\tL3 = emitjump(J, F, OP_JUMP); \n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187013, "func": "void DragController::PerformDrag(DragData* drag_data, LocalFrame& local_root) {\n  DCHECK(drag_data);\n  document_under_mouse_ =\n      local_root.DocumentAtPoint(LayoutPoint(drag_data->ClientPosition()));\n  std::unique_ptr<UserGestureIndicator> gesture = Frame::NotifyUserActivation(\n      document_under_mouse_ ? document_under_mouse_->GetFrame() : nullptr,\n      UserGestureToken::kNewGesture);\n  if ((drag_destination_action_ & kDragDestinationActionDHTML) &&\n      document_is_handling_drag_) {\n    bool prevented_default = false;\n    if (local_root.View()) {\n      DataTransfer* data_transfer =\n          CreateDraggingDataTransfer(kDataTransferReadable, drag_data);\n      data_transfer->SetSourceOperation(\n          drag_data->DraggingSourceOperationMask());\n      EventHandler& event_handler = local_root.GetEventHandler();\n      prevented_default = event_handler.PerformDragAndDrop(\n                              CreateMouseEvent(drag_data), data_transfer) !=\n                          WebInputEventResult::kNotHandled;\n      if (!prevented_default) {\n        const LayoutPoint point = local_root.View()->RootFrameToContents(\n            LayoutPoint(drag_data->ClientPosition()));\n        const HitTestResult result = event_handler.HitTestResultAtPoint(point);\n        prevented_default |=\n            IsHTMLPlugInElement(*result.InnerNode()) &&\n            ToHTMLPlugInElement(result.InnerNode())->CanProcessDrag();\n      }\n\n      data_transfer->SetAccessPolicy(kDataTransferNumb);\n    }\n    if (prevented_default) {\n      document_under_mouse_ = nullptr;\n      CancelDrag();\n      return;\n    }\n  }\n\n  if ((drag_destination_action_ & kDragDestinationActionEdit) &&\n      ConcludeEditDrag(drag_data)) {\n    document_under_mouse_ = nullptr;\n    return;\n  }\n\n  document_under_mouse_ = nullptr;\n\n  if (OperationForLoad(drag_data, local_root) != kDragOperationNone) {\n    if (page_->GetSettings().GetNavigateOnDragDrop()) {\n      ResourceRequest resource_request(drag_data->AsURL());\n       resource_request.SetRequestorOrigin(\n           SecurityOrigin::Create(KURL(drag_data->AsURL())));\n       page_->MainFrame()->Navigate(FrameLoadRequest(nullptr, resource_request));\n     }\n \n    local_root.GetEventHandler().ClearDragState();\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186914, "func": "int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n  if (HasTextBeingDragged())\n    return ui::DragDropTypes::DRAG_NONE;\n\n  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {\n    GURL url;\n    base::string16 title;\n    if (data.GetURLAndTitle(\n            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {\n      base::string16 text(\n          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));\n      if (model()->CanPasteAndGo(text)) {\n        model()->PasteAndGo(text);\n        return ui::DragDropTypes::DRAG_COPY;\n      }\n    }\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;\n    }\n  }\n\n  return ui::DragDropTypes::DRAG_NONE;\n}\n", "target": 1, "flaw_line_index": "20"}
{"idx": 7519, "func": "  tt_size_init( FT_Size  ttsize )           \n  {\n    TT_Size   size  = (TT_Size)ttsize;\n    FT_Error  error = FT_Err_Ok;\n\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->bytecode_ready = -1;\n    size->cvt_ready      = -1;\n#endif\n\n    size->ttmetrics.valid = FALSE;\n    size->strike_index    = 0xFFFFFFFFUL;\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7512, "func": "  tt_face_done( FT_Face  ttface )           \n  {\n    TT_Face       face = (TT_Face)ttface;\n    FT_Memory     memory;\n    FT_Stream     stream;\n    SFNT_Service  sfnt;\n\n\n    if ( !face )\n      return;\n\n    memory = ttface->memory;\n    stream = ttface->stream;\n    sfnt   = (SFNT_Service)face->sfnt;\n\n    if ( face->extra.finalizer )\n      face->extra.finalizer( face->extra.data );\n\n    if ( sfnt )\n      sfnt->done_face( face );\n\n    tt_face_done_loca( face );\n\n    tt_face_free_hdmx( face );\n\n    FT_FREE( face->cvt );\n    face->cvt_size = 0;\n\n    FT_FRAME_RELEASE( face->font_program );\n    FT_FRAME_RELEASE( face->cvt_program );\n    face->font_program_size = 0;\n    face->cvt_program_size  = 0;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    tt_done_blend( face );\n    face->blend = NULL;\n#endif\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8293, "func": "XRRSetMonitor(Display *dpy, Window window, XRRMonitorInfo *monitor)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRSetMonitorReq\t    *req;\n\n    RRSimpleCheckExtension (dpy, info);\n\n    LockDisplay(dpy);\n    GetReq (RRSetMonitor, req);\n    req->reqType = info->codes->major_opcode;\n    req->randrReqType = X_RRSetMonitor;\n    req->length += monitor->noutput;\n    req->window = window;\n    req->monitor.name = monitor->name;\n    req->monitor.primary = monitor->primary;\n    req->monitor.automatic = False;\n    req->monitor.noutput = monitor->noutput;\n    req->monitor.x = monitor->x;\n    req->monitor.y = monitor->y;\n    req->monitor.width = monitor->width;\n    req->monitor.height = monitor->height;\n    req->monitor.widthInMillimeters = monitor->mwidth;\n    req->monitor.heightInMillimeters = monitor->mheight;\n    Data32 (dpy, monitor->outputs, monitor->noutput * 4);\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186735, "func": "void NetworkHandler::GetResponseBodyForInterception(\n     const String& interception_id,\n     std::unique_ptr<GetResponseBodyForInterceptionCallback> callback) {\n   DevToolsInterceptorController* interceptor =\n      DevToolsInterceptorController::FromBrowserContext(\n          process_->GetBrowserContext());\n   if (!interceptor) {\n     callback->sendFailure(Response::InternalError());\n     return;\n  }\n  interceptor->GetResponseBody(interception_id, std::move(callback));\n}\n", "target": 1, "flaw_line_index": "5,6"}
{"idx": 7510, "func": "  tt_driver_done( FT_Module  ttdriver )     \n  {\n    FT_UNUSED( ttdriver );\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186370, "func": " void TabletModeWindowManager::Shutdown() {\n  base::flat_map<aura::Window*, WindowStateType> windows_in_splitview =\n      GetCarryOverWindowsInSplitView();\n  SplitViewController* split_view_controller =\n      Shell::Get()->split_view_controller();\n  if (split_view_controller->InSplitViewMode()) {\n    OverviewController* overview_controller =\n        Shell::Get()->overview_controller();\n    if (!overview_controller->InOverviewSession() ||\n        overview_controller->overview_session()->IsEmpty()) {\n      Shell::Get()->split_view_controller()->EndSplitView(\n          SplitViewController::EndReason::kExitTabletMode);\n      overview_controller->EndOverview();\n     }\n   }\n \n  for (aura::Window* window : added_windows_)\n    window->RemoveObserver(this);\n  added_windows_.clear();\n  Shell::Get()->RemoveShellObserver(this);\n  Shell::Get()->session_controller()->RemoveObserver(this);\n  Shell::Get()->overview_controller()->RemoveObserver(this);\n  display::Screen::GetScreen()->RemoveObserver(this);\n  RemoveWindowCreationObservers();\n \n   ScopedObserveWindowAnimation scoped_observe(GetTopWindow(), this,\ntrue);\n  ArrangeWindowsForClamshellMode(windows_in_splitview);\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30"}
{"idx": 7968, "func": "static void pixel_format_message (VncState *vs) {\n    char pad[3] = { 0, 0, 0 };\n\n    vs->client_pf = qemu_default_pixelformat(32);\n\n    vnc_write_u8(vs, vs->client_pf.bits_per_pixel); \n    vnc_write_u8(vs, vs->client_pf.depth); \n\n#ifdef HOST_WORDS_BIGENDIAN\n    vnc_write_u8(vs, 1);             \n#else\n    vnc_write_u8(vs, 0);             \n#endif\n    vnc_write_u8(vs, 1);             \n    vnc_write_u16(vs, vs->client_pf.rmax);     \n    vnc_write_u16(vs, vs->client_pf.gmax);     \n    vnc_write_u16(vs, vs->client_pf.bmax);     \n    vnc_write_u8(vs, vs->client_pf.rshift);    \n    vnc_write_u8(vs, vs->client_pf.gshift);    \n    vnc_write_u8(vs, vs->client_pf.bshift);    \n    vnc_write(vs, pad, 3);           \n\n    vnc_hextile_set_pixel_conversion(vs, 0);\n    vs->write_pixels = vnc_write_pixels_copy;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7970, "func": "static void press_key(VncState *vs, int keysym)\n{\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n    qemu_input_event_send_key_delay(0);\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n    qemu_input_event_send_key_delay(0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186949, "func": " void AppCache::RemoveEntry(const GURL& url) {\n   auto found = entries_.find(url);\n   DCHECK(found != entries_.end());\n   cache_size_ -= found->second.response_size();\n   entries_.erase(found);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7933, "func": "static int findlocal(JF, const char *name)\n{\n\tint i;\n\tfor (i = F->varlen; i > 0; --i)\n\t\tif (!strcmp(F->vartab[i-1], name))\n\t\t\treturn i;\n\treturn -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186965, "func": "  void MakeGroupObsolete() {\n    PushNextTask(\n        base::BindOnce(&AppCacheStorageImplTest::Verify_MakeGroupObsolete,\n                       base::Unretained(this)));\n\n     MakeCacheAndGroup(kManifestUrl, 1, 1, true);\n    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);\n \n     AppCacheDatabase::EntryRecord entry_record;\n    entry_record.cache_id = 1;\n    entry_record.flags = AppCacheEntry::FALLBACK;\n    entry_record.response_id = 1;\n    entry_record.url = kEntryUrl;\n    EXPECT_TRUE(database()->InsertEntry(&entry_record));\n\n    AppCacheDatabase::NamespaceRecord fallback_namespace_record;\n    fallback_namespace_record.cache_id = 1;\n    fallback_namespace_record.namespace_.target_url = kEntryUrl;\n    fallback_namespace_record.namespace_.namespace_url = kFallbackNamespace;\n    fallback_namespace_record.origin = url::Origin::Create(kManifestUrl);\n    EXPECT_TRUE(database()->InsertNamespace(&fallback_namespace_record));\n\n    AppCacheDatabase::OnlineWhiteListRecord online_whitelist_record;\n    online_whitelist_record.cache_id = 1;\n    online_whitelist_record.namespace_url = kOnlineNamespace;\n    EXPECT_TRUE(database()->InsertOnlineWhiteList(&online_whitelist_record));\n\n    storage()->MakeGroupObsolete(group_.get(), delegate(), 0);\n    EXPECT_FALSE(group_->is_obsolete());\n  }\n", "target": 1, "flaw_line_index": "10"}
{"idx": 7564, "func": "static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n{\n    int copy_count;\n    uint8_t *end_ptr;\n\n    if (s->cirrus_srccounter > 0) {\n        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n            cirrus_bitblt_common_patterncopy(s, s->cirrus_bltbuf);\n        the_end:\n            s->cirrus_srccounter = 0;\n            cirrus_bitblt_reset(s);\n        } else {\n            do {\n                (*s->cirrus_rop)(s, s->vga.vram_ptr +\n                                 (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n                                  s->cirrus_bltbuf, 0, 0, s->cirrus_blt_width, 1);\n                cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n                                         s->cirrus_blt_width, 1);\n                s->cirrus_blt_dstaddr += s->cirrus_blt_dstpitch;\n                s->cirrus_srccounter -= s->cirrus_blt_srcpitch;\n                if (s->cirrus_srccounter <= 0)\n                    goto the_end;\n                end_ptr = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n                copy_count = s->cirrus_srcptr_end - end_ptr;\n                memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n                s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n                s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n            } while (s->cirrus_srcptr >= s->cirrus_srcptr_end);\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186617, "func": "void DataReductionProxyConfig::InitializeOnIOThread(\n    scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,\n    WarmupURLFetcher::CreateCustomProxyConfigCallback\n        create_custom_proxy_config_callback,\n    NetworkPropertiesManager* manager) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  network_properties_manager_ = manager;\n  network_properties_manager_->ResetWarmupURLFetchMetrics();\n\n  secure_proxy_checker_.reset(new SecureProxyChecker(url_loader_factory));\n  warmup_url_fetcher_.reset(new WarmupURLFetcher(\n      url_loader_factory, create_custom_proxy_config_callback,\n      base::BindRepeating(\n          &DataReductionProxyConfig::HandleWarmupFetcherResponse,\n          base::Unretained(this)),\n      base::BindRepeating(&DataReductionProxyConfig::GetHttpRttEstimate,\n                           base::Unretained(this)),\n       ui_task_runner_));\n \n  if (ShouldAddDefaultProxyBypassRules())\n    AddDefaultProxyBypassRules();\n \n   network_connection_tracker_->AddNetworkConnectionObserver(this);\n   network_connection_tracker_->GetConnectionType(\n      &connection_type_,\n      base::BindOnce(&DataReductionProxyConfig::OnConnectionChanged,\n                      weak_factory_.GetWeakPtr()));\n }\n", "target": 1, "flaw_line_index": "20,21"}
{"idx": 186936, "func": "bool CrossesExtensionProcessBoundary(\n    const ExtensionSet& extensions,\n    const GURL& old_url,\n    const GURL& new_url,\n    bool should_consider_workaround) {\n  const extensions::Extension* old_url_extension = GetNonBookmarkAppExtension(\n      extensions,\n      old_url);\n  const extensions::Extension* new_url_extension = GetNonBookmarkAppExtension(\n      extensions,\n      new_url);\n\n  if (should_consider_workaround) {\n    bool old_url_is_hosted_app = old_url_extension &&\n        !old_url_extension->web_extent().is_empty() &&\n        !AppIsolationInfo::HasIsolatedStorage(old_url_extension);\n    bool new_url_is_normal_or_hosted = !new_url_extension ||\n        (!new_url_extension->web_extent().is_empty() &&\n         !AppIsolationInfo::HasIsolatedStorage(new_url_extension));\n    bool either_is_web_store =\n        (old_url_extension &&\n        old_url_extension->id() == extensions::kWebStoreAppId) ||\n        (new_url_extension &&\n        new_url_extension->id() == extensions::kWebStoreAppId);\n    if (old_url_is_hosted_app &&\n        new_url_is_normal_or_hosted &&\n        !either_is_web_store)\n       return false;\n   }\n \n   return old_url_extension != new_url_extension;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186397, "func": "  void RunScrollbarThumbDragLatencyTest() {\n#if !defined(OS_ANDROID)\n    blink::WebFloatPoint scrollbar_thumb(795, 30);\n    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n        0);\n    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n        scrollbar_thumb.y + 10, 0);\n    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n    RunUntilInputProcessed(GetWidgetHost());\n    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n    RunUntilInputProcessed(GetWidgetHost());\n    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n        scrollbar_thumb.y + 20, 0);\n    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n    RunUntilInputProcessed(GetWidgetHost());\n    FetchHistogramsFromChildProcesses();\n    const std::string scroll_types[] = {\"ScrollBegin\", \"ScrollUpdate\"};\n    for (const std::string& scroll_type : scroll_types) {\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.TimeToScrollUpdateSwapBegin4\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.RendererSwapToBrowserNotified2\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type + \".Scrollbar.GpuSwap2\"));\n      std::string thread_name =\n          DoesScrollbarScrollOnMainThread() ? \"Main\" : \"Impl\";\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type + \".Scrollbar.TimeToHandled2_\" +\n                 thread_name));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.HandledToRendererSwap2_\" + thread_name));\n    }\n#endif  \n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53"}
{"idx": 7937, "func": "js_Function *jsC_compile(js_State *J, js_Ast *prog)\n{\n\treturn newfun(J, NULL, NULL, prog, 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7738, "func": "static void coroutine_fn v9fs_walk(void *opaque)\n{\n    int name_idx;\n    V9fsQID *qids = NULL;\n    int i, err = 0;\n    V9fsPath dpath, path;\n    uint16_t nwnames;\n    struct stat stbuf;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsString *wnames = NULL;\n    V9fsFidState *fidp;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsQID qid;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n    offset += err;\n\n    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);\n\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        wnames = g_malloc0(sizeof(wnames[0]) * nwnames);\n        qids   = g_malloc0(sizeof(qids[0]) * nwnames);\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        goto out;\n    }\n\n    v9fs_path_copy(&dpath, &fidp->path);\n    v9fs_path_copy(&path, &fidp->path);\n    for (name_idx = 0; name_idx < nwnames; name_idx++) {\n        if (not_same_qid(&pdu->s->root_qid, &qid) ||\n            strcmp(\"..\", wnames[name_idx].data)) {\n            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,\n                                       &path);\n            if (err < 0) {\n                goto out;\n            }\n\n            err = v9fs_co_lstat(pdu, &path, &stbuf);\n            if (err < 0) {\n                goto out;\n            }\n            stat_to_qid(&stbuf, &qid);\n            v9fs_path_copy(&dpath, &path);\n        }\n        memcpy(&qids[name_idx], &qid, sizeof(qid));\n    }\n    if (fid == newfid) {\n        if (fidp->fid_type != P9_FID_NONE) {\n            err = -EINVAL;\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else {\n        newfidp = alloc_fid(s, newfid);\n        if (newfidp == NULL) {\n            err = -EINVAL;\n            goto out;\n        }\n        newfidp->uid = fidp->uid;\n        v9fs_path_copy(&newfidp->path, &path);\n    }\n    err = v9fs_walk_marshal(pdu, nwnames, qids);\n    trace_v9fs_walk_return(pdu->tag, pdu->id, nwnames, qids);\nout:\n    put_fid(pdu, fidp);\n    if (newfidp) {\n        put_fid(pdu, newfidp);\n    }\n    v9fs_path_free(&dpath);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        for (name_idx = 0; name_idx < nwnames; name_idx++) {\n            v9fs_string_free(&wnames[name_idx]);\n        }\n        g_free(wnames);\n        g_free(qids);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186458, "func": "  void OnDidAddMessageToConsole(int32_t,\n                                const base::string16& message,\n                                int32_t,\n                                const base::string16&) {\n    callback_.Run(message);\n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 186649, "func": "bool WebRequestPermissions::HideRequest(\n    const extensions::InfoMap* extension_info_map,\n    const extensions::WebRequestInfo& request) {\n  if (request.is_web_view)\n    return false;\n\n  if (request.is_pac_request)\n    return true;\n \n  bool is_request_from_browser = request.render_process_id == -1;\n   bool is_request_from_webui_renderer = false;\n   if (!is_request_from_browser) {\n    if (request.is_web_view)\n      return false;\n\n    if (extension_info_map &&\n        extension_info_map->process_map().Contains(extensions::kWebStoreAppId,\n                                                   request.render_process_id)) {\n      return true;\n    }\n\n    is_request_from_webui_renderer =\n        content::ChildProcessSecurityPolicy::GetInstance()->HasWebUIBindings(\n            request.render_process_id);\n  }\n\n  return IsSensitiveURL(request.url, is_request_from_browser ||\n                                         is_request_from_webui_renderer) ||\n         !HasWebRequestScheme(request.url);\n}\n", "target": 1, "flaw_line_index": "15"}
{"idx": 186512, "func": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n   return Textfield::ShouldShowPlaceholderText() &&\n         !model()->is_caret_visible() && !model()->is_keyword_selected();\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7818, "func": "  Current_Ratio( EXEC_OP )\n  {\n    if ( !CUR.tt_metrics.ratio )\n    {\n#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING\n      if ( CUR.face->unpatented_hinting )\n      {\n        if ( CUR.GS.both_x_axis )\n          CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;\n        else\n          CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;\n      }\n      else\n#endif\n      {\n        if ( CUR.GS.projVector.y == 0 )\n          CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;\n\n        else if ( CUR.GS.projVector.x == 0 )\n          CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;\n\n        else\n        {\n          FT_Long  x, y;\n\n\n          x = TT_MULDIV( CUR.GS.projVector.x,\n                         CUR.tt_metrics.x_ratio, 0x4000 );\n          y = TT_MULDIV( CUR.GS.projVector.y,\n                         CUR.tt_metrics.y_ratio, 0x4000 );\n          CUR.tt_metrics.ratio = TT_VecLen( x, y );\n        }\n      }\n    }\n    return CUR.tt_metrics.ratio;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7905, "func": "static void cdelete(JF, js_Ast *exp)\n{\n\tswitch (exp->type) {\n\tcase EXP_IDENTIFIER:\n\t\tif (J->strict)\n\t\t\tjsC_error(J, exp, \"delete on an unqualified name is not allowed in strict mode\");\n\t\temitlocal(J, F, OP_DELLOCAL, OP_DELVAR, exp);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, exp->a);\n\t\tcexp(J, F, exp->b);\n\t\temit(J, F, OP_DELPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, exp->a);\n\t\temitstring(J, F, OP_DELPROP_S, exp->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, exp, \"invalid l-value in delete expression\");\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187011, "func": "void RemoteFrame::Navigate(const FrameLoadRequest& passed_request) {\n  FrameLoadRequest frame_request(passed_request);\n\n  FrameLoader::SetReferrerForFrameRequest(frame_request);\n   FrameLoader::UpgradeInsecureRequest(frame_request.GetResourceRequest(),\n                                       frame_request.OriginDocument());\n \n  frame_request.GetResourceRequest().SetHasUserGesture(\n      Frame::HasTransientUserActivation(this));\n   Client()->Navigate(frame_request.GetResourceRequest(),\n                      frame_request.ReplacesCurrentItem());\n }\n", "target": 1, "flaw_line_index": "11,12"}
{"idx": 8051, "func": "double vnc_update_freq(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n    double total = 0;\n    int num = 0;\n\n    x =  (x / VNC_STAT_RECT) * VNC_STAT_RECT;\n    y =  (y / VNC_STAT_RECT) * VNC_STAT_RECT;\n\n    for (j = y; j <= y + h; j += VNC_STAT_RECT) {\n        for (i = x; i <= x + w; i += VNC_STAT_RECT) {\n            total += vnc_stat_rect(vs->vd, i, j)->freq;\n            num++;\n        }\n    }\n\n    if (num) {\n        return total / num;\n    } else {\n        return 0;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8210, "func": "static int v9fs_complete_rename(V9fsPDU *pdu, V9fsFidState *fidp,\n                                int32_t newdirfid, V9fsString *name)\n{\n    char *end;\n    int err = 0;\n    V9fsPath new_path;\n    V9fsFidState *tfidp;\n    V9fsState *s = pdu->s;\n    V9fsFidState *dirfidp = NULL;\n    char *old_name, *new_name;\n\n    v9fs_path_init(&new_path);\n    if (newdirfid != -1) {\n        dirfidp = get_fid(pdu, newdirfid);\n        if (dirfidp == NULL) {\n            err = -ENOENT;\n            goto out_nofid;\n        }\n        BUG_ON(dirfidp->fid_type != P9_FID_NONE);\n        v9fs_co_name_to_path(pdu, &dirfidp->path, name->data, &new_path);\n    } else {\n        old_name = fidp->path.data;\n        end = strrchr(old_name, '/');\n        if (end) {\n            end++;\n        } else {\n            end = old_name;\n        }\n        new_name = g_malloc0(end - old_name + name->size + 1);\n        strncat(new_name, old_name, end - old_name);\n        strncat(new_name + (end - old_name), name->data, name->size);\n        v9fs_co_name_to_path(pdu, NULL, new_name, &new_path);\n        g_free(new_name);\n    }\n    err = v9fs_co_rename(pdu, &fidp->path, &new_path);\n    if (err < 0) {\n        goto out;\n    }\n    for (tfidp = s->fid_list; tfidp; tfidp = tfidp->next) {\n        if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {\n            v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));\n        }\n    }\nout:\n    if (dirfidp) {\n        put_fid(pdu, dirfidp);\n    }\n    v9fs_path_free(&new_path);\nout_nofid:\n    return err;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186550, "func": "void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(\n    const ClientOAuthResult& result,\n    Profile* profile,\n    Profile::CreateStatus status) {\n  if (is_force_sign_in_with_usermanager_)\n    UnlockProfileAndHideLoginUI(profile_->GetPath(), handler_.get());\n  Browser* browser = NULL;\n  if (handler_) {\n    browser = handler_->GetDesktopBrowser();\n  }\n\n  AboutSigninInternals* about_signin_internals =\n      AboutSigninInternalsFactory::GetForProfile(profile_);\n  about_signin_internals->OnRefreshTokenReceived(\"Successful\");\n\n  std::string account_id =\n      AccountTrackerServiceFactory::GetForProfile(profile_)\n          ->SeedAccountInfo(gaia_id_, email_);\n\n  signin_metrics::AccessPoint access_point =\n      signin::GetAccessPointForPromoURL(current_url_);\n  signin_metrics::Reason reason =\n      signin::GetSigninReasonForPromoURL(current_url_);\n\n  SigninManager* signin_manager = SigninManagerFactory::GetForProfile(profile_);\n  std::string primary_email =\n      signin_manager->GetAuthenticatedAccountInfo().email;\n  if (gaia::AreEmailsSame(email_, primary_email) &&\n      (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK) &&\n      !password_.empty() && profiles::IsLockAvailable(profile_)) {\n    LocalAuth::SetLocalAuthCredentials(profile_, password_);\n  }\n\n#if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)\n  if (!password_.empty()) {\n    scoped_refptr<password_manager::PasswordStore> password_store =\n        PasswordStoreFactory::GetForProfile(profile_,\n                                            ServiceAccessType::EXPLICIT_ACCESS);\n    if (password_store && !primary_email.empty()) {\n      password_store->SaveGaiaPasswordHash(\n          primary_email, base::UTF8ToUTF16(password_),\n          password_manager::metrics_util::SyncPasswordHashChange::\n              SAVED_ON_CHROME_SIGNIN);\n    }\n  }\n#endif\n\n   if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK ||\n       reason == signin_metrics::Reason::REASON_ADD_SECONDARY_ACCOUNT) {\n    ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)->\n        UpdateCredentials(account_id, result.refresh_token);\n \n     if (signin::IsAutoCloseEnabledInURL(current_url_)) {\n      bool show_account_management = ShouldShowAccountManagement(\n          current_url_,\n          AccountConsistencyModeManager::IsMirrorEnabledForProfile(profile_));\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&InlineLoginHandlerImpl::CloseTab, handler_,\n                                    show_account_management));\n    }\n\n    if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n        reason == signin_metrics::Reason::REASON_UNLOCK) {\n      signin_manager->MergeSigninCredentialIntoCookieJar();\n    }\n    LogSigninReason(reason);\n  } else {\n    browser_sync::ProfileSyncService* sync_service =\n        ProfileSyncServiceFactory::GetForProfile(profile_);\n    SigninErrorController* error_controller =\n        SigninErrorControllerFactory::GetForProfile(profile_);\n\n    OneClickSigninSyncStarter::StartSyncMode start_mode =\n        OneClickSigninSyncStarter::CONFIRM_SYNC_SETTINGS_FIRST;\n    if (access_point == signin_metrics::AccessPoint::ACCESS_POINT_SETTINGS ||\n        choose_what_to_sync_) {\n      bool show_settings_without_configure =\n          error_controller->HasError() && sync_service &&\n          sync_service->IsFirstSetupComplete();\n      if (!show_settings_without_configure)\n        start_mode = OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST;\n    }\n\n    OneClickSigninSyncStarter::ConfirmationRequired confirmation_required =\n        confirm_untrusted_signin_ ?\n            OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN :\n            OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;\n\n    bool start_signin = !HandleCrossAccountError(\n        result.refresh_token, confirmation_required, start_mode);\n    if (start_signin) {\n      CreateSyncStarter(browser, current_url_, result.refresh_token,\n                        OneClickSigninSyncStarter::CURRENT_PROFILE, start_mode,\n                        confirmation_required);\n      base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);\n    }\n  }\n}\n", "target": 1, "flaw_line_index": "53,54"}
{"idx": 186333, "func": "void UrlFetcherDownloader::OnNetworkFetcherComplete(base::FilePath file_path,\n                                                    int net_error,\n                                                     int64_t content_size) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n \n  const base::TimeTicks download_end_time(base::TimeTicks::Now());\n  const base::TimeDelta download_time =\n      download_end_time >= download_start_time_\n          ? download_end_time - download_start_time_\n          : base::TimeDelta();\n\n   int error = -1;\n  if (!file_path.empty() && response_code_ == 200) {\n    DCHECK_EQ(0, net_error);\n     error = 0;\n  } else if (response_code_ != -1) {\n     error = response_code_;\n  } else {\n     error = net_error;\n  }\n \n   const bool is_handled = error == 0 || IsHttpServerError(error);\n \n   Result result;\n   result.error = error;\n  if (!error) {\n    result.response = file_path;\n  }\n \n   DownloadMetrics download_metrics;\n   download_metrics.url = url();\n  download_metrics.downloader = DownloadMetrics::kUrlFetcher;\n  download_metrics.error = error;\n  download_metrics.downloaded_bytes = error ? -1 : content_size;\n  download_metrics.total_bytes = total_bytes_;\n  download_metrics.download_time_ms = download_time.InMilliseconds();\n\n  VLOG(1) << \"Downloaded \" << content_size << \" bytes in \"\n          << download_time.InMilliseconds() << \"ms from \" << url().spec()\n          << \" to \" << result.response.value();\n\n  if (error && !download_dir_.empty()) {\n    base::PostTask(FROM_HERE, kTaskTraits,\n                   base::BindOnce(IgnoreResult(&base::DeleteFileRecursively),\n                                  download_dir_));\n  }\n\n  main_task_runner()->PostTask(\n      FROM_HERE, base::BindOnce(&UrlFetcherDownloader::OnDownloadComplete,\n                                base::Unretained(this), is_handled, result,\n                                download_metrics));\n}\n", "target": 1, "flaw_line_index": "2,16,17,19,21,23,29,30,31"}
{"idx": 7907, "func": "static void cexit(JF, enum js_AstType T, js_Ast *node, js_Ast *target)\n{\n\tjs_Ast *prev;\n\tdo {\n\t\tprev = node, node = node->parent;\n\t\tswitch (node->type) {\n\t\tdefault: \n break;\n\t\tcase STM_WITH:\n\t\t\temit(J, F, OP_ENDWITH);\n\t\t\tbreak;\n\t\tcase STM_FOR_IN:\n\t\tcase STM_FOR_IN_VAR:\n\t\t\tif (F->script) {\n\t\t\t\tif (T == STM_RETURN || T == STM_BREAK || (T == STM_CONTINUE && target != node)) {\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_CONTINUE)\n\t\t\t\t\temit(J, F, OP_ROT2); \n\t\t\t} else {\n\t\t\t\tif (T == STM_RETURN) {\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_BREAK || (T == STM_CONTINUE && target != node))\n\t\t\t\t\temit(J, F, OP_POP); \n\t\t\t}\n\t\t\tbreak;\n\t\tcase STM_TRY:\n\t\t\tif (prev == node->a) {\n\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\tif (node->d) cstm(J, F, node->d); \n\t\t\t}\n\t\t\tif (prev == node->c) {\n\t\t\t\tif (node->d) {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\t\tcstm(J, F, node->d); \n\t\t\t\t} else {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (node != target);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186935, "func": " void ExtensionBrowserTest::OpenWindow(content::WebContents* contents,\n                                       const GURL& url,\n                                       bool newtab_process_should_equal_opener,\n                                       content::WebContents** newtab_result) {\n   content::WebContentsAddedObserver tab_added_observer;\n   ASSERT_TRUE(content::ExecuteScript(contents,\n                                      \"window.open('\" + url.spec() + \"');\"));\n   content::WebContents* newtab = tab_added_observer.GetWebContents();\n   ASSERT_TRUE(newtab);\n   WaitForLoadStop(newtab);\n  EXPECT_EQ(url, newtab->GetLastCommittedURL());\n   if (newtab_process_should_equal_opener) {\n     EXPECT_EQ(contents->GetMainFrame()->GetSiteInstance(),\n               newtab->GetMainFrame()->GetSiteInstance());\n  } else {\n    EXPECT_NE(contents->GetMainFrame()->GetSiteInstance(),\n              newtab->GetMainFrame()->GetSiteInstance());\n  }\n\n  if (newtab_result)\n    *newtab_result = newtab;\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 187162, "func": "void SVGStyleElement::DidNotifySubtreeInsertionsToDocument() {\n  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\n      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 7579, "func": "static int cirrus_get_bpp(VGACommonState *s1)\n{\n    CirrusVGAState * s = container_of(s1, CirrusVGAState, vga);\n    uint32_t ret = 8;\n\n    if ((s->vga.sr[0x07] & 0x01) != 0) {\n\tswitch (s->vga.sr[0x07] & CIRRUS_SR7_BPP_MASK) {\n\tcase CIRRUS_SR7_BPP_8:\n\t    ret = 8;\n\t    break;\n\tcase CIRRUS_SR7_BPP_16_DOUBLEVCLK:\n\t    ret = cirrus_get_bpp16_depth(s);\n\t    break;\n\tcase CIRRUS_SR7_BPP_24:\n\t    ret = 24;\n\t    break;\n\tcase CIRRUS_SR7_BPP_16:\n\t    ret = cirrus_get_bpp16_depth(s);\n\t    break;\n\tcase CIRRUS_SR7_BPP_32:\n\t    ret = 32;\n\t    break;\n\tdefault:\n#ifdef DEBUG_CIRRUS\n\t    printf(\"cirrus: unknown bpp - sr7=%x\\n\", s->vga.sr[0x7]);\n#endif\n\t    ret = 8;\n\t    break;\n\t}\n    } else {\n\tret = 0;\n    }\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187302, "func": "  void TestProcessOverflow() {\n    int tab_count = 1;\n    int host_count = 1;\n    WebContents* tab1 = NULL;\n    WebContents* tab2 = NULL;\n    content::RenderProcessHost* rph1 = NULL;\n    content::RenderProcessHost* rph2 = NULL;\n    content::RenderProcessHost* rph3 = NULL;\n\n    const extensions::Extension* extension =\n        LoadExtension(test_data_dir_.AppendASCII(\"options_page\"));\n\n    GURL omnibox(chrome::kChromeUIOmniboxURL);\n    ui_test_utils::NavigateToURL(browser(), omnibox);\n    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    rph1 = tab1->GetMainFrame()->GetProcess();\n    EXPECT_EQ(omnibox, tab1->GetURL());\n    EXPECT_EQ(host_count, RenderProcessHostCount());\n\n    GURL page1(\"data:text/html,hello world1\");\n\n    ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n        content::NotificationService::AllSources());\n    ::ShowSingletonTab(browser(), page1);\n    observer1.Wait();\n\n    tab_count++;\n    host_count++;\n    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    rph2 = tab1->GetMainFrame()->GetProcess();\n    EXPECT_EQ(tab1->GetURL(), page1);\n    EXPECT_EQ(host_count, RenderProcessHostCount());\n    EXPECT_NE(rph1, rph2);\n\n    GURL page2(\"data:text/html,hello world2\");\n    ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n        content::NotificationService::AllSources());\n    ::ShowSingletonTab(browser(), page2);\n    observer2.Wait();\n    tab_count++;\n    if (content::AreAllSitesIsolatedForTesting())\n      host_count++;\n    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    EXPECT_EQ(tab2->GetURL(), page2);\n    EXPECT_EQ(host_count, RenderProcessHostCount());\n    if (content::AreAllSitesIsolatedForTesting())\n      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);\n     else\n       EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n \n    GURL history(chrome::kChromeUIHistoryURL);\n    ui_test_utils::WindowedTabAddedNotificationObserver observer3(\n        content::NotificationService::AllSources());\n     ::ShowSingletonTab(browser(), history);\n     observer3.Wait();\n     tab_count++;\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n     EXPECT_EQ(tab2->GetURL(), GURL(history));\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);\n \n     GURL extension_url(\"chrome-extension:\n    ui_test_utils::WindowedTabAddedNotificationObserver observer4(\n        content::NotificationService::AllSources());\n    ::ShowSingletonTab(browser(), extension_url);\n\n    observer4.Wait();\n    tab_count++;\n    host_count++;\n    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    rph3 = tab1->GetMainFrame()->GetProcess();\n    EXPECT_EQ(tab1->GetURL(), extension_url);\n    EXPECT_EQ(host_count, RenderProcessHostCount());\n    EXPECT_NE(rph1, rph3);\n    EXPECT_NE(rph2, rph3);\n  }\n", "target": 1, "flaw_line_index": "59,73"}
{"idx": 7630, "func": "static int proxy_init(FsContext *ctx)\n{\n    V9fsProxy *proxy = g_malloc(sizeof(V9fsProxy));\n    int sock_id;\n\n    if (ctx->export_flags & V9FS_PROXY_SOCK_NAME) {\n        sock_id = connect_namedsocket(ctx->fs_root);\n    } else {\n        sock_id = atoi(ctx->fs_root);\n        if (sock_id < 0) {\n            error_report(\"Socket descriptor not initialized\");\n        }\n    }\n    if (sock_id < 0) {\n        g_free(proxy);\n        return -1;\n    }\n    g_free(ctx->fs_root);\n    ctx->fs_root = NULL;\n\n    proxy->in_iovec.iov_base  = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n    proxy->in_iovec.iov_len   = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n    proxy->out_iovec.iov_base = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n    proxy->out_iovec.iov_len  = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n\n    ctx->private = proxy;\n    proxy->sockfd = sock_id;\n    qemu_mutex_init(&proxy->mutex);\n\n    ctx->export_flags |= V9FS_PATHNAME_FSCONTEXT;\n    ctx->exops.get_st_gen = proxy_ioc_getversion;\n     return 0;\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186569, "func": "void DestroySkImageOnOriginalThread(\n    sk_sp<SkImage> image,\n    base::WeakPtr<WebGraphicsContext3DProviderWrapper> context_provider_wrapper,\n    std::unique_ptr<gpu::SyncToken> sync_token) {\n  if (context_provider_wrapper &&\n      image->isValid(\n          context_provider_wrapper->ContextProvider()->GetGrContext())) {\n    if (sync_token->HasData()) {\n      context_provider_wrapper->ContextProvider()\n          ->ContextGL()\n          ->WaitSyncTokenCHROMIUM(sync_token->GetData());\n    }\n     image->getTexture()->textureParamsModified();\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186491, "func": " void GM2TabStyle::PaintBackgroundStroke(gfx::Canvas* canvas,\n                                        bool active,\n                                         SkColor stroke_color) const {\n   SkPath outer_path =\n      GetPath(TabStyle::PathType::kBorder, canvas->image_scale(), active);\n   gfx::ScopedCanvas scoped_canvas(canvas);\n   float scale = canvas->UndoDeviceScaleFactor();\n   cc::PaintFlags flags;\n   flags.setAntiAlias(true);\n   flags.setColor(stroke_color);\n   flags.setStyle(cc::PaintFlags::kStroke_Style);\n  flags.setStrokeWidth(GetStrokeThickness(active) * scale);\n   canvas->DrawPath(outer_path, flags);\n }\n", "target": 1, "flaw_line_index": "2,5,12"}
{"idx": 7971, "func": "static int protocol_client_auth(VncState *vs, uint8_t *data, size_t len)\n{\n    if (data[0] != vs->auth) { \n       VNC_DEBUG(\"Reject auth %d because it didn't match advertized\\n\", (int)data[0]);\n       vnc_write_u32(vs, 1);\n       if (vs->minor >= 8) {\n           static const char err[] = \"Authentication failed\";\n           vnc_write_u32(vs, sizeof(err));\n           vnc_write(vs, err, sizeof(err));\n       }\n       vnc_client_error(vs);\n    } else { \n       VNC_DEBUG(\"Client requested auth %d\\n\", (int)data[0]);\n       switch (vs->auth) {\n       case VNC_AUTH_NONE:\n           VNC_DEBUG(\"Accept auth none\\n\");\n           if (vs->minor >= 8) {\n               vnc_write_u32(vs, 0); \n               vnc_flush(vs);\n           }\n           start_client_init(vs);\n           break;\n\n       case VNC_AUTH_VNC:\n           VNC_DEBUG(\"Start VNC auth\\n\");\n           start_auth_vnc(vs);\n           break;\n\n#ifdef CONFIG_VNC_TLS\n       case VNC_AUTH_VENCRYPT:\n           VNC_DEBUG(\"Accept VeNCrypt auth\\n\");\n           start_auth_vencrypt(vs);\n           break;\n#endif \n\n#ifdef CONFIG_VNC_SASL\n       case VNC_AUTH_SASL:\n           VNC_DEBUG(\"Accept SASL auth\\n\");\n           start_auth_sasl(vs);\n           break;\n#endif \n\n       default: \n           VNC_DEBUG(\"Reject auth %d server code bug\\n\", vs->auth);\n           vnc_write_u8(vs, 1);\n           if (vs->minor >= 8) {\n               static const char err[] = \"Authentication failed\";\n               vnc_write_u32(vs, sizeof(err));\n               vnc_write(vs, err, sizeof(err));\n           }\n           vnc_client_error(vs);\n       }\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8220, "func": "static void v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\n    }\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7624, "func": "static int proxy_chmod(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n{\n    int retval;\n    retval = v9fs_request(fs_ctx->private, T_CHMOD, NULL, fs_path,\n                          credp->fc_mode);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186494, "func": " void GM2TabStyle::PaintTabBackground(gfx::Canvas* canvas,\n                                     bool active,\n                                      int fill_id,\n                                      int y_inset,\n                                      const SkPath* clip) const {\n   DCHECK(!y_inset || fill_id);\n \n  const SkColor active_color =\n      tab_->controller()->GetTabBackgroundColor(TAB_ACTIVE);\n  const SkColor inactive_color =\n      tab_->GetThemeProvider()->GetDisplayProperty(\n          ThemeProperties::SHOULD_FILL_BACKGROUND_TAB_COLOR)\n          ? tab_->controller()->GetTabBackgroundColor(TAB_INACTIVE)\n          : SK_ColorTRANSPARENT;\n   const SkColor stroke_color =\n       tab_->controller()->GetToolbarTopSeparatorColor();\n  const bool paint_hover_effect = !active && IsHoverActive();\n  const float stroke_thickness = GetStrokeThickness(active);\n \n  PaintTabBackgroundFill(canvas, active, paint_hover_effect, active_color,\n                         inactive_color, fill_id, y_inset);\n   if (stroke_thickness > 0) {\n     gfx::ScopedCanvas scoped_canvas(clip ? canvas : nullptr);\n     if (clip)\n       canvas->sk_canvas()->clipPath(*clip, SkClipOp::kDifference, true);\n    PaintBackgroundStroke(canvas, active, stroke_color);\n   }\n \n   PaintSeparators(canvas);\n }\n", "target": 1, "flaw_line_index": "2,9,10,11,12,13,14,15,18,19,21,22,27"}
{"idx": 187203, "func": "void CoordinatorImpl::FinalizeGlobalMemoryDumpIfAllManagersReplied() {\n  TRACE_EVENT0(base::trace_event::MemoryDumpManager::kTraceCategory,\n               \"GlobalMemoryDump.Computation\");\n  DCHECK(!queued_memory_dump_requests_.empty());\n\n  QueuedRequest* request = &queued_memory_dump_requests_.front();\n  if (!request->dump_in_progress || request->pending_responses.size() > 0 ||\n      request->heap_dump_in_progress) {\n    return;\n  }\n\n  QueuedRequestDispatcher::Finalize(request, tracing_observer_.get());\n\n  queued_memory_dump_requests_.pop_front();\n  request = nullptr;\n\n  if (!queued_memory_dump_requests_.empty()) {\n     base::SequencedTaskRunnerHandle::Get()->PostTask(\n         FROM_HERE,\n         base::BindOnce(&CoordinatorImpl::PerformNextQueuedGlobalMemoryDump,\n                       base::Unretained(this)));\n   }\n }\n", "target": 1, "flaw_line_index": "22"}
{"idx": 186483, "func": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n \n   CalculateVisiblePages();\n   return most_visible_page_;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7741, "func": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    uint64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    if (size > XATTR_SIZE_MAX) {\n        err = -E2BIG;\n        goto out_nofid;\n    }\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (file_fidp->fid_type != P9_FID_NONE) {\n        err = -EINVAL;\n        goto out_put_fid;\n    }\n\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.xattrwalk_fid = false;\n    xattr_fidp->fs.xattr.len = size;\n    xattr_fidp->fs.xattr.flags = flags;\n    v9fs_string_init(&xattr_fidp->fs.xattr.name);\n    v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    xattr_fidp->fs.xattr.value = g_malloc0(size);\n    err = offset;\nout_put_fid:\n    put_fid(pdu, file_fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7726, "func": "static void coroutine_fn v9fs_mkdir(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    size_t offset = 7;\n    int32_t fid;\n    struct stat stbuf;\n    V9fsQID qid;\n    V9fsString name;\n    V9fsFidState *fidp;\n    gid_t gid;\n    int mode;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdd\", &fid, &name, &mode, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mkdir(pdu->tag, pdu->id, fid, name.data, mode, gid);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mkdir(pdu, fidp, &name, mode, fidp->uid, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mkdir_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8160, "func": "void Gfx::opSetStrokeGray(Object args[], int numArgs) {\n  GfxColor color;\n\n  state->setStrokePattern(NULL);\n  state->setStrokeColorSpace(new GfxDeviceGrayColorSpace());\n  out->updateStrokeColorSpace(state);\n  color.c[0] = dblToCol(args[0].getNum());\n  state->setStrokeColor(&color);\n  out->updateStrokeColor(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186669, "func": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), nullptr, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n             R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n             R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n            R\"([ijl\\u0131]\\u0307)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8118, "func": "void Gfx::opEOClip(Object args[], int numArgs) {\n  clip = clipEO;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7967, "func": "static void make_challenge(VncState *vs)\n{\n    int i;\n\n    srand(time(NULL)+getpid()+getpid()*987654+rand());\n\n    for (i = 0 ; i < sizeof(vs->challenge) ; i++)\n        vs->challenge[i] = (int) (256.0*rand()/(RAND_MAX+1.0));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8243, "func": "static int v9fs_xattr_fid_clunk(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    int retval = 0;\n\n    if (fidp->fs.xattr.copied_len == -1) {\n        goto free_value;\n    }\n    if (fidp->fs.xattr.len != fidp->fs.xattr.copied_len) {\n        retval = -EINVAL;\n        goto free_out;\n    }\n    if (fidp->fs.xattr.len) {\n        retval = v9fs_co_lsetxattr(pdu, &fidp->path, &fidp->fs.xattr.name,\n                                   fidp->fs.xattr.value,\n                                   fidp->fs.xattr.len,\n                                   fidp->fs.xattr.flags);\n    } else {\n        retval = v9fs_co_lremovexattr(pdu, &fidp->path, &fidp->fs.xattr.name);\n    }\nfree_out:\n    v9fs_string_free(&fidp->fs.xattr.name);\nfree_value:\n    g_free(fidp->fs.xattr.value);\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7903, "func": "static void cbinary(JF, js_Ast *exp, int opcode)\n{\n\tcexp(J, F, exp->a);\n\tcexp(J, F, exp->b);\n\temit(J, F, opcode);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186839, "func": "void RenderProcessHostImpl::CreateSharedRendererHistogramAllocator() {\n  if (!base::GlobalHistogramAllocator::Get()) {\n    if (is_initialized_) {\n      HistogramController::GetInstance()->SetHistogramMemory<RenderProcessHost>(\n          this, mojo::ScopedSharedBufferHandle());\n    }\n    return;\n  }\n\n  base::ProcessHandle destination = GetHandle();\n  if (destination == base::kNullProcessHandle)\n    return;\n\n  if (!metrics_allocator_) {\n    std::unique_ptr<base::SharedMemory> shm(new base::SharedMemory());\n    if (!shm->CreateAndMapAnonymous(2 << 20))  \n      return;\n    metrics_allocator_.reset(new base::SharedPersistentMemoryAllocator(\n        std::move(shm), GetID(), \"RendererMetrics\", \nfalse));\n  }\n\n   HistogramController::GetInstance()->SetHistogramMemory<RenderProcessHost>(\n       this, mojo::WrapSharedMemoryHandle(\n                 metrics_allocator_->shared_memory()->handle().Duplicate(),\n                metrics_allocator_->shared_memory()->mapped_size(), false));\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186704, "func": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n   UErrorCode status = U_ZERO_ERROR;\n   int32_t result =\n       uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), nullptr, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n   if (deviation_characters_.containsSome(label_string))\n     return false;\n \n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n   if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n       kana_letters_exceptions_.containsNone(label_string) &&\n       combining_diacritics_exceptions_.containsNone(label_string)) {\n     return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n   }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(DangerousPatternTLS().Get());\n  if (!dangerous_pattern) {\n    dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be\\u4e36\\u4e40\\u4e41\\u4e3f])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u4e00\\u3127])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n\n            R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n\n            R\"(\\u0131[\\u0300-\\u0339]|)\"\n\n            R\"(\\u3099|\\u309A|)\"\n\n            R\"([ijl]\\u0307)\",\n            -1, US_INV),\n        0, status);\n    DangerousPatternTLS().Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187055, "func": " void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {\n   visitor->Trace(factory_);\n   visitor->Trace(resolver_);\n   visitor->Trace(options_);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7622, "func": "static void vga_draw_cursor_line(uint8_t *d1,\n                                 const uint8_t *src1,\n                                 int poffset, int w,\n                                 unsigned int color0,\n                                 unsigned int color1,\n                                 unsigned int color_xor)\n{\n    const uint8_t *plane0, *plane1;\n    int x, b0, b1;\n    uint8_t *d;\n\n    d = d1;\n    plane0 = src1;\n    plane1 = src1 + poffset;\n    for (x = 0; x < w; x++) {\n        b0 = (plane0[x >> 3] >> (7 - (x & 7))) & 1;\n        b1 = (plane1[x >> 3] >> (7 - (x & 7))) & 1;\n        switch (b0 | (b1 << 1)) {\n        case 0:\n            break;\n        case 1:\n            ((uint32_t *)d)[0] ^= color_xor;\n            break;\n        case 2:\n            ((uint32_t *)d)[0] = color0;\n            break;\n        case 3:\n            ((uint32_t *)d)[0] = color1;\n            break;\n        }\n        d += 4;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186801, "func": " PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n    mojo::ScopedSharedBufferMapping mapping,\n     PlatformSensorProvider* provider)\n    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n", "target": 1, "flaw_line_index": "2,4"}
{"idx": 8215, "func": "static void v9fs_fix_fid_paths(V9fsPDU *pdu, V9fsPath *olddir,\n                               V9fsString *old_name, V9fsPath *newdir,\n                               V9fsString *new_name)\n{\n    V9fsFidState *tfidp;\n    V9fsPath oldpath, newpath;\n    V9fsState *s = pdu->s;\n\n\n    v9fs_path_init(&oldpath);\n    v9fs_path_init(&newpath);\n    v9fs_co_name_to_path(pdu, olddir, old_name->data, &oldpath);\n    v9fs_co_name_to_path(pdu, newdir, new_name->data, &newpath);\n\n    for (tfidp = s->fid_list; tfidp; tfidp = tfidp->next) {\n        if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {\n            v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));\n        }\n    }\n    v9fs_path_free(&oldpath);\n    v9fs_path_free(&newpath);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7891, "func": "static void addlocal(JF, js_Ast *ident, int reuse)\n{\n\tconst char *name = ident->string;\n\tif (J->strict) {\n\t\tif (!strcmp(name, \"arguments\"))\n\t\t\tjsC_error(J, ident, \"redefining 'arguments' is not allowed in strict mode\");\n\t\tif (!strcmp(name, \"eval\"))\n\t\t\tjsC_error(J, ident, \"redefining 'eval' is not allowed in strict mode\");\n\t}\n\tif (reuse || J->strict) {\n\t\tint i;\n\t\tfor (i = 0; i < F->varlen; ++i) {\n\t\t\tif (!strcmp(F->vartab[i], name)) {\n\t\t\t\tif (reuse)\n\t\t\t\t\treturn;\n\t\t\t\tif (J->strict)\n\t\t\t\t\tjsC_error(J, ident, \"duplicate formal parameter '%s'\", name);\n\t\t\t}\n\t\t}\n\t}\n\tif (F->varlen >= F->varcap) {\n\t\tF->varcap = F->varcap ? F->varcap * 2 : 16;\n\t\tF->vartab = js_realloc(J, F->vartab, F->varcap * sizeof *F->vartab);\n\t}\n\tF->vartab[F->varlen++] = name;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187217, "func": "static int _hid_get_string_descriptor(struct hid_device_priv* dev, int _index,\n\t\t\t\t\t\t\t\t\t  void *data, size_t *size)\n{\n\tvoid *tmp = NULL;\n\tsize_t tmp_size = 0;\n\tint i;\n\tchar string_langid[] = {\n\t\t0x09,\n\t\t0x04\n\t};\n\tif ((*size < 2) || (*size > 255)) {\n\t\treturn LIBUSB_ERROR_OVERFLOW;\n\t}\n\tif (_index == 0) {\n\t\ttmp = string_langid;\n\t\ttmp_size = sizeof(string_langid)+2;\n\t} else {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tif (_index == (dev->string_index[i])) {\n\t\t\t\ttmp = dev->string[i];\n\t\t\t\ttmp_size = (_hid_wcslen(dev->string[i])+1) * sizeof(WCHAR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 3) {\t\n\t\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t\t}\n\t}\n\tif(!tmp_size) {\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tif (tmp_size < *size) {\n\t\t*size = tmp_size;\n\t}\n\t((uint8_t*)data)[0] = (uint8_t)*size;\n\t((uint8_t*)data)[1] = LIBUSB_DT_STRING;\n\tmemcpy((uint8_t*)data+2, tmp, *size-2);\n\treturn LIBUSB_COMPLETED;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40"}
{"idx": 7413, "func": "ZEND_API void zend_ts_hash_apply_with_argument(TsHashTable *ht, apply_func_arg_t apply_func, void *argument)\n{\n\tbegin_write(ht);\n\tzend_hash_apply_with_argument(TS_HASH(ht), apply_func, argument);\n\tend_write(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186905, "func": "HTMLFrameOwnerElement::HTMLFrameOwnerElement(const QualifiedName& tag_name,\n                                             Document& document)\n     : HTMLElement(tag_name, document),\n       content_frame_(nullptr),\n       embedded_content_view_(nullptr),\n      sandbox_flags_(kSandboxNone) {}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 186522, "func": "void DataReductionProxySettings::InitPrefMembers() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  spdy_proxy_auth_enabled_.Init(\n      prefs::kDataSaverEnabled, GetOriginalProfilePrefs(),\n      base::Bind(&DataReductionProxySettings::OnProxyEnabledPrefChange,\n                 base::Unretained(this)));\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 8085, "func": "void Gfx::doShowText(GooString *s) {\n  GfxFont *font;\n  int wMode;\n  double riseX, riseY;\n  CharCode code;\n  Unicode *u = NULL;\n  double x, y, dx, dy, dx2, dy2, curX, curY, tdx, tdy, lineX, lineY;\n  double originX, originY, tOriginX, tOriginY;\n  double oldCTM[6], newCTM[6];\n  double *mat;\n  Object charProc;\n  Dict *resDict;\n  Parser *oldParser;\n  char *p;\n  int len, n, uLen, nChars, nSpaces, i;\n\n  font = state->getFont();\n  wMode = font->getWMode();\n\n  if (out->useDrawChar()) {\n    out->beginString(state, s);\n  }\n\n  if (font->getType() == fontType3 && out->interpretType3Chars()) {\n    mat = state->getCTM();\n    for (i = 0; i < 6; ++i) {\n      oldCTM[i] = mat[i];\n    }\n    mat = state->getTextMat();\n    newCTM[0] = mat[0] * oldCTM[0] + mat[1] * oldCTM[2];\n    newCTM[1] = mat[0] * oldCTM[1] + mat[1] * oldCTM[3];\n    newCTM[2] = mat[2] * oldCTM[0] + mat[3] * oldCTM[2];\n    newCTM[3] = mat[2] * oldCTM[1] + mat[3] * oldCTM[3];\n    mat = font->getFontMatrix();\n    newCTM[0] = mat[0] * newCTM[0] + mat[1] * newCTM[2];\n    newCTM[1] = mat[0] * newCTM[1] + mat[1] * newCTM[3];\n    newCTM[2] = mat[2] * newCTM[0] + mat[3] * newCTM[2];\n    newCTM[3] = mat[2] * newCTM[1] + mat[3] * newCTM[3];\n    newCTM[0] *= state->getFontSize();\n    newCTM[1] *= state->getFontSize();\n    newCTM[2] *= state->getFontSize();\n    newCTM[3] *= state->getFontSize();\n    newCTM[0] *= state->getHorizScaling();\n    newCTM[2] *= state->getHorizScaling();\n    state->textTransformDelta(0, state->getRise(), &riseX, &riseY);\n    curX = state->getCurX();\n    curY = state->getCurY();\n    lineX = state->getLineX();\n    lineY = state->getLineY();\n    oldParser = parser;\n    p = s->getCString();\n    len = s->getLength();\n    while (len > 0) {\n      n = font->getNextChar(p, len, &code,\n\t\t\t    &u, &uLen,\n\t\t\t    &dx, &dy, &originX, &originY);\n      dx = dx * state->getFontSize() + state->getCharSpace();\n      if (n == 1 && *p == ' ') {\n\tdx += state->getWordSpace();\n      }\n      dx *= state->getHorizScaling();\n      dy *= state->getFontSize();\n      state->textTransformDelta(dx, dy, &tdx, &tdy);\n      state->transform(curX + riseX, curY + riseY, &x, &y);\n      saveState();\n      state->setCTM(newCTM[0], newCTM[1], newCTM[2], newCTM[3], x, y);\n      out->updateCTM(state, 1, 0, 0, 1, 0, 0);\n      if (!out->beginType3Char(state, curX + riseX, curY + riseY, tdx, tdy,\n\t\t\t       code, u, uLen)) {\n\t((Gfx8BitFont *)font)->getCharProc(code, &charProc);\n\tif ((resDict = ((Gfx8BitFont *)font)->getResources())) {\n\t  pushResources(resDict);\n\t}\n\tif (charProc.isStream()) {\n\t  display(&charProc, gFalse);\n\t} else {\n\t  error(getPos(), \"Missing or bad Type3 CharProc entry\");\n\t}\n\tout->endType3Char(state);\n\tif (resDict) {\n\t  popResources();\n\t}\n\tcharProc.free();\n      }\n      restoreState();\n      curX += tdx;\n      curY += tdy;\n      state->moveTo(curX, curY);\n      state->textSetPos(lineX, lineY);\n      p += n;\n      len -= n;\n    }\n    parser = oldParser;\n\n  } else if (out->useDrawChar()) {\n    state->textTransformDelta(0, state->getRise(), &riseX, &riseY);\n    p = s->getCString();\n    len = s->getLength();\n    while (len > 0) {\n      n = font->getNextChar(p, len, &code,\n\t\t\t    &u, &uLen,\n\t\t\t    &dx, &dy, &originX, &originY);\n      if (wMode) {\n\tdx *= state->getFontSize();\n\tdy = dy * state->getFontSize() + state->getCharSpace();\n\tif (n == 1 && *p == ' ') {\n\t  dy += state->getWordSpace();\n\t}\n      } else {\n\tdx = dx * state->getFontSize() + state->getCharSpace();\n\tif (n == 1 && *p == ' ') {\n\t  dx += state->getWordSpace();\n\t}\n\tdx *= state->getHorizScaling();\n\tdy *= state->getFontSize();\n      }\n      state->textTransformDelta(dx, dy, &tdx, &tdy);\n      originX *= state->getFontSize();\n      originY *= state->getFontSize();\n      state->textTransformDelta(originX, originY, &tOriginX, &tOriginY);\n      if (!contentIsHidden()) {\n        out->drawChar(state, state->getCurX() + riseX, state->getCurY() + riseY,\n\t\t      tdx, tdy, tOriginX, tOriginY, code, n, u, uLen);\n      }\n      state->shift(tdx, tdy);\n      p += n;\n      len -= n;\n    }\n\n  } else {\n    dx = dy = 0;\n    p = s->getCString();\n    len = s->getLength();\n    nChars = nSpaces = 0;\n    while (len > 0) {\n      n = font->getNextChar(p, len, &code,\n\t\t\t    &u, &uLen,\n\t\t\t    &dx2, &dy2, &originX, &originY);\n      dx += dx2;\n      dy += dy2;\n      if (n == 1 && *p == ' ') {\n\t++nSpaces;\n      }\n      ++nChars;\n      p += n;\n      len -= n;\n    }\n    if (wMode) {\n      dx *= state->getFontSize();\n      dy = dy * state->getFontSize()\n\t   + nChars * state->getCharSpace()\n\t   + nSpaces * state->getWordSpace();\n    } else {\n      dx = dx * state->getFontSize()\n\t   + nChars * state->getCharSpace()\n\t   + nSpaces * state->getWordSpace();\n      dx *= state->getHorizScaling();\n      dy *= state->getFontSize();\n    }\n    state->textTransformDelta(dx, dy, &tdx, &tdy);\n    if (!contentIsHidden())\n      out->drawString(state, s);\n    state->shift(tdx, tdy);\n  }\n\n  if (out->useDrawChar()) {\n    out->endString(state);\n  }\n\n  updateLevel += 10 * s->getLength();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186777, "func": " void VaapiVideoDecodeAccelerator::VaapiH264Accelerator::FillVAPicture(\n     VAPictureH264* va_pic,\n     scoped_refptr<H264Picture> pic) {\n   VASurfaceID va_surface_id = VA_INVALID_SURFACE;\n \n   if (!pic->nonexisting) {\n    scoped_refptr<VaapiDecodeSurface> dec_surface =\n        H264PictureToVaapiDecodeSurface(pic);\n    va_surface_id = dec_surface->va_surface()->id();\n  }\n\n  va_pic->picture_id = va_surface_id;\n  va_pic->frame_idx = pic->frame_num;\n  va_pic->flags = 0;\n\n  switch (pic->field) {\n    case H264Picture::FIELD_NONE:\n      break;\n    case H264Picture::FIELD_TOP:\n      va_pic->flags |= VA_PICTURE_H264_TOP_FIELD;\n      break;\n    case H264Picture::FIELD_BOTTOM:\n      va_pic->flags |= VA_PICTURE_H264_BOTTOM_FIELD;\n      break;\n  }\n\n  if (pic->ref) {\n    va_pic->flags |= pic->long_term ? VA_PICTURE_H264_LONG_TERM_REFERENCE\n                                    : VA_PICTURE_H264_SHORT_TERM_REFERENCE;\n  }\n\n  va_pic->TopFieldOrderCnt = pic->top_field_order_cnt;\n  va_pic->BottomFieldOrderCnt = pic->bottom_field_order_cnt;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7709, "func": "ssize_t pdu_unmarshal(V9fsPDU *pdu, size_t offset, const char *fmt, ...)\n{\n    ssize_t ret;\n    va_list ap;\n\n    va_start(ap, fmt);\n    ret = virtio_pdu_vunmarshal(pdu, offset, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186631, "func": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {\n  current_content_source_id_ = next_source_id;\n  did_receive_first_frame_after_navigation_ = false;\n\n  if (enable_surface_synchronization_) {\n     visual_properties_ack_pending_ = false;\n    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();\n     if (view_)\n       view_->DidNavigate();\n    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();\n    if (old_surface_id == new_surface_id)\n      return;\n   } else {\n    if (last_received_content_source_id_ >= current_content_source_id_)\n      return;\n  }\n\n  if (!new_content_rendering_timeout_)\n    return;\n\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}\n", "target": 1, "flaw_line_index": "10,13,14,15,16,17,18,19,20,21,22"}
{"idx": 7472, "func": "static ssize_t fremovexattrat_nofollow(int dirfd, const char *filename,\n                                       const char *name)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = lremovexattr(proc_path, name);\n    g_free(proc_path);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187061, "func": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path,\n                                          CreateWriterCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   FileSystemURL url(context_->CrackURL(file_path));\n   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n   if (opt_error) {\n    std::move(callback).Run(opt_error.value(), nullptr);\n    return;\n  }\n  if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr);\n    return;\n  }\n\n  blink::mojom::FileWriterPtr writer;\n  mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(\n                              url, context_->CreateFileSystemOperationRunner(),\n                              blob_storage_context_->context()->AsWeakPtr()),\n                          MakeRequest(&writer));\n  std::move(callback).Run(base::File::FILE_OK, std::move(writer));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7677, "func": "static int handle_lstat(FsContext *fs_ctx, V9fsPath *fs_path,\n                        struct stat *stbuf)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fstatat(fd, \"\", stbuf, AT_EMPTY_PATH);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187212, "func": "static int _hid_get_descriptor(struct hid_device_priv* dev, HANDLE hid_handle, int recipient,\n\t\t\t\t\t\t\t   int type, int _index, void *data, size_t *size)\n{\n\tswitch(type) {\n\tcase LIBUSB_DT_DEVICE:\n\t\tusbi_dbg(\"LIBUSB_DT_DEVICE\");\n\t\treturn _hid_get_device_descriptor(dev, data, size);\n\tcase LIBUSB_DT_CONFIG:\n\t\tusbi_dbg(\"LIBUSB_DT_CONFIG\");\n\t\tif (!_index)\n\t\t\treturn _hid_get_config_descriptor(dev, data, size);\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\tcase LIBUSB_DT_STRING:\n\t\tusbi_dbg(\"LIBUSB_DT_STRING\");\n\t\treturn _hid_get_string_descriptor(dev, _index, data, size);\n\tcase LIBUSB_DT_HID:\n\t\tusbi_dbg(\"LIBUSB_DT_HID\");\n\t\tif (!_index)\n\t\t\treturn _hid_get_hid_descriptor(dev, data, size);\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\tcase LIBUSB_DT_REPORT:\n\t\tusbi_dbg(\"LIBUSB_DT_REPORT\");\n\t\tif (!_index)\n\t\t\treturn _hid_get_report_descriptor(dev, data, size);\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\tcase LIBUSB_DT_PHYSICAL:\n\t\tusbi_dbg(\"LIBUSB_DT_PHYSICAL\");\n\t\tif (HidD_GetPhysicalDescriptor(hid_handle, data, (ULONG)*size))\n\t\t\treturn LIBUSB_COMPLETED;\n\t\treturn LIBUSB_ERROR_OTHER;\n\t}\n\tusbi_dbg(\"unsupported\");\n\treturn LIBUSB_ERROR_INVALID_PARAM;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34"}
{"idx": 7518, "func": "  tt_size_done_bytecode( FT_Size  ftsize )\n  {\n    TT_Size    size   = (TT_Size)ftsize;\n    TT_Face    face   = (TT_Face)ftsize->face;\n    FT_Memory  memory = face->root.memory;\n\n    if ( size->context )\n    {\n      TT_Done_Context( size->context );\n      size->context = NULL;\n    }\n\n    FT_FREE( size->cvt );\n    size->cvt_size = 0;\n\n    FT_FREE( size->storage );\n    size->storage_size = 0;\n\n    tt_glyphzone_done( &size->twilight );\n\n    FT_FREE( size->function_defs );\n    FT_FREE( size->instruction_defs );\n\n    size->num_function_defs    = 0;\n    size->max_function_defs    = 0;\n    size->num_instruction_defs = 0;\n    size->max_instruction_defs = 0;\n\n    size->max_func = 0;\n    size->max_ins  = 0;\n\n    size->bytecode_ready = -1;\n    size->cvt_ready      = -1;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8282, "func": "short *XRRConfigRates (XRRScreenConfiguration *config, int sizeID, int *nrates)\n{\n    short   *r = config->rates;\n    int\t    nents = config->nrates;\n\n    while (sizeID > 0 && nents > 0)\n    {\n\tint i = (*r + 1);\n\tr += i;\n\tnents -= i;\n\tsizeID--;\n    }\n    if (!nents)\n    {\n\t*nrates = 0;\n\treturn NULL;\n    }\n    *nrates = (int) *r;\n    return r + 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186858, "func": "void MojoVideoEncodeAcceleratorService::UseOutputBitstreamBuffer(\n    int32_t bitstream_buffer_id,\n    mojo::ScopedSharedBufferHandle buffer) {\n  DVLOG(2) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id;\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  if (!encoder_)\n    return;\n  if (!buffer.is_valid()) {\n    DLOG(ERROR) << __func__ << \" invalid |buffer|.\";\n    NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);\n    return;\n  }\n  if (bitstream_buffer_id < 0) {\n    DLOG(ERROR) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id\n                << \" must be >= 0\";\n    NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);\n    return;\n  }\n \n   base::SharedMemoryHandle handle;\n   size_t memory_size = 0;\n  bool read_only = false;\n   auto result = mojo::UnwrapSharedMemoryHandle(std::move(buffer), &handle,\n                                               &memory_size, &read_only);\n   if (result != MOJO_RESULT_OK || memory_size == 0u) {\n     DLOG(ERROR) << __func__ << \" mojo::UnwrapSharedMemoryHandle() failed\";\n     NotifyError(::media::VideoEncodeAccelerator::kPlatformFailureError);\n    return;\n  }\n\n  if (memory_size < output_buffer_size_) {\n    DLOG(ERROR) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id\n                << \" has a size of \" << memory_size\n                << \"B, different from expected \" << output_buffer_size_ << \"B\";\n    NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);\n    return;\n  }\n\n  encoder_->UseOutputBitstreamBuffer(\n      BitstreamBuffer(bitstream_buffer_id, handle, memory_size));\n}\n", "target": 1, "flaw_line_index": "23,25"}
{"idx": 186945, "func": "void AppCache::AddEntry(const GURL& url, const AppCacheEntry& entry) {\n   DCHECK(entries_.find(url) == entries_.end());\n   entries_.insert(EntryMap::value_type(url, entry));\n   cache_size_ += entry.response_size();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186788, "func": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitFrameMetadata(\n    const H264SPS* sps,\n    const H264PPS* pps,\n    const H264DPB& dpb,\n    const H264Picture::Vector& ref_pic_listp0,\n     const H264Picture::Vector& ref_pic_listb0,\n     const H264Picture::Vector& ref_pic_listb1,\n     const scoped_refptr<H264Picture>& pic) {\n   VAPictureParameterBufferH264 pic_param;\n   memset(&pic_param, 0, sizeof(pic_param));\n \n#define FROM_SPS_TO_PP(a) pic_param.a = sps->a\n#define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a\n  FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1);\n  FROM_SPS_TO_PP2(pic_height_in_map_units_minus1, picture_height_in_mbs_minus1);\n  FROM_SPS_TO_PP(bit_depth_luma_minus8);\n  FROM_SPS_TO_PP(bit_depth_chroma_minus8);\n#undef FROM_SPS_TO_PP\n#undef FROM_SPS_TO_PP2\n\n#define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a\n#define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a\n  FROM_SPS_TO_PP_SF(chroma_format_idc);\n  FROM_SPS_TO_PP_SF2(separate_colour_plane_flag,\n                     residual_colour_transform_flag);\n  FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);\n  FROM_SPS_TO_PP_SF(frame_mbs_only_flag);\n  FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag);\n  FROM_SPS_TO_PP_SF(direct_8x8_inference_flag);\n  pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31);\n  FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4);\n  FROM_SPS_TO_PP_SF(pic_order_cnt_type);\n  FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4);\n  FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag);\n#undef FROM_SPS_TO_PP_SF\n#undef FROM_SPS_TO_PP_SF2\n\n#define FROM_PPS_TO_PP(a) pic_param.a = pps->a\n  FROM_PPS_TO_PP(pic_init_qp_minus26);\n  FROM_PPS_TO_PP(pic_init_qs_minus26);\n  FROM_PPS_TO_PP(chroma_qp_index_offset);\n  FROM_PPS_TO_PP(second_chroma_qp_index_offset);\n#undef FROM_PPS_TO_PP\n\n#define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a\n#define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a\n  FROM_PPS_TO_PP_PF(entropy_coding_mode_flag);\n  FROM_PPS_TO_PP_PF(weighted_pred_flag);\n  FROM_PPS_TO_PP_PF(weighted_bipred_idc);\n  FROM_PPS_TO_PP_PF(transform_8x8_mode_flag);\n\n  pic_param.pic_fields.bits.field_pic_flag = 0;\n  FROM_PPS_TO_PP_PF(constrained_intra_pred_flag);\n  FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag,\n                     pic_order_present_flag);\n  FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag);\n  FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag);\n  pic_param.pic_fields.bits.reference_pic_flag = pic->ref;\n#undef FROM_PPS_TO_PP_PF\n#undef FROM_PPS_TO_PP_PF2\n\n  pic_param.frame_num = pic->frame_num;\n\n  InitVAPicture(&pic_param.CurrPic);\n  FillVAPicture(&pic_param.CurrPic, pic);\n\n  for (int i = 0; i < 16; ++i)\n    InitVAPicture(&pic_param.ReferenceFrames[i]);\n\n  FillVARefFramesFromDPB(dpb, pic_param.ReferenceFrames,\n                         arraysize(pic_param.ReferenceFrames));\n\n  pic_param.num_ref_frames = sps->max_num_ref_frames;\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,\n                                    sizeof(pic_param), &pic_param))\n    return false;\n\n  VAIQMatrixBufferH264 iq_matrix_buf;\n  memset(&iq_matrix_buf, 0, sizeof(iq_matrix_buf));\n\n  if (pps->pic_scaling_matrix_present_flag) {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            pps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            pps->scaling_list8x8[i][j];\n    }\n  } else {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            sps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            sps->scaling_list8x8[i][j];\n    }\n  }\n\n  return vaapi_wrapper_->SubmitBuffer(VAIQMatrixBufferType,\n                                      sizeof(iq_matrix_buf), &iq_matrix_buf);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7917, "func": "static void ctrycatch(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm)\n{\n\tint L1, L2;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tif (J->strict) {\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\tL2 = emitjump(J, F, OP_JUMP); \n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L2);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7923, "func": "static void cvarinit(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *var = list->a;\n\t\tif (var->b) {\n\t\t\tcexp(J, F, var->b);\n\t\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, var->a);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7474, "func": "static XattrOperations *get_xattr_operations(XattrOperations **h,\n                                             const char *name)\n{\n    XattrOperations *xops;\n    for (xops = *(h)++; xops != NULL; xops = *(h)++) {\n        if (!strncmp(name, xops->name, strlen(xops->name))) {\n            return xops;\n        }\n    }\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7962, "func": "static void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187180, "func": "void DownloadRequestLimiter::TabDownloadState::DidStartNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->IsInMainFrame())\n    return;\n\n   download_seen_ = false;\n   ui_status_ = DOWNLOAD_UI_DEFAULT;\n \n  if (navigation_handle->IsRendererInitiated() &&\n      (status_ == PROMPT_BEFORE_DOWNLOAD || status_ == DOWNLOADS_NOT_ALLOWED)) {\n    return;\n   }\n \n   if (status_ == DownloadRequestLimiter::ALLOW_ALL_DOWNLOADS ||\n      status_ == DownloadRequestLimiter::DOWNLOADS_NOT_ALLOWED) {\n    if (!initial_page_host_.empty() &&\n        navigation_handle->GetURL().host_piece() == initial_page_host_) {\n      return;\n    }\n  }\n\n  NotifyCallbacks(false);\n  host_->Remove(this, web_contents());\n}\n", "target": 1, "flaw_line_index": "9,10,11,12,13,14,15,16"}
{"idx": 8142, "func": "void Gfx::opSetFillCMYKColor(Object args[], int numArgs) {\n  GfxColor color;\n  int i;\n\n  if (textHaveCSPattern && drawText) {\n    GBool needFill = out->deviceHasTextClip(state);\n    out->endTextObject(state);\n    if (needFill) {\n      doPatternFill(gTrue);\n    }\n    out->restoreState(state);\n  }\n  state->setFillPattern(NULL);\n  state->setFillColorSpace(new GfxDeviceCMYKColorSpace());\n  out->updateFillColorSpace(state);\n  for (i = 0; i < 4; ++i) {\n    color.c[i] = dblToCol(args[i].getNum());\n  }\n  state->setFillColor(&color);\n  out->updateFillColor(state);\n  if (textHaveCSPattern) {\n    out->beginTextObject(state);\n    out->updateRender(state);\n    out->updateTextMat(state);\n    out->updateTextPos(state);\n    textHaveCSPattern = gFalse;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186366, "func": "SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n    const base::CommandLine& command_line,\n    Profile* profile) {\n  DCHECK(profile);\n  PrefService* prefs = profile->GetPrefs();\n  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);\n\n#if defined(OS_CHROMEOS)\n  const bool is_first_run =\n      user_manager::UserManager::Get()->IsCurrentUserNew();\n  const bool did_restart = false;\n  StartupBrowserCreator::WasRestarted();\n#else\n  const bool is_first_run = first_run::IsChromeFirstRun();\n  const bool did_restart = StartupBrowserCreator::WasRestarted();\n#endif\n\n  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))\n    pref.type = SessionStartupPref::DEFAULT;\n\n  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&\n      !profile->IsNewProfile()) {\n    pref.type = SessionStartupPref::LAST;\n  }\n\n  if (!profile->IsGuestSession()) {\n    ProfileAttributesEntry* entry = nullptr;\n    bool has_entry =\n        g_browser_process->profile_manager()\n            ->GetProfileAttributesStorage()\n            .GetProfileAttributesWithPath(profile->GetPath(), &entry);\n\n    if (has_entry && entry->IsSigninRequired())\n       pref.type = SessionStartupPref::LAST;\n   }\n \n  if (pref.type == SessionStartupPref::LAST &&\n      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n    pref.type = SessionStartupPref::DEFAULT;\n  }\n\n  return pref;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8143, "func": "void Gfx::opSetFillColor(Object args[], int numArgs) {\n  GfxColor color;\n  int i;\n\n  if (numArgs != state->getFillColorSpace()->getNComps()) {\n    error(getPos(), \"Incorrect number of arguments in 'sc' command\");\n    return;\n  }\n  state->setFillPattern(NULL);\n  for (i = 0; i < numArgs; ++i) {\n    color.c[i] = dblToCol(args[i].getNum());\n  }\n  state->setFillColor(&color);\n  out->updateFillColor(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7728, "func": "static void coroutine_fn v9fs_op_not_supp(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    pdu_complete(pdu, -EOPNOTSUPP);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186781, "func": " bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::OutputPicture(\n     const scoped_refptr<H264Picture>& pic) {\n   scoped_refptr<VaapiDecodeSurface> dec_surface =\n       H264PictureToVaapiDecodeSurface(pic);\n   dec_surface->set_visible_rect(pic->visible_rect);\n  vaapi_dec_->SurfaceReady(dec_surface);\n\n  return true;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7618, "func": "static void map_linear_vram(CirrusVGAState *s)\n{\n    if (s->bustype == CIRRUS_BUSTYPE_PCI && !s->linear_vram) {\n        s->linear_vram = true;\n        memory_region_add_subregion_overlap(&s->pci_bar, 0, &s->vga.vram, 1);\n    }\n    map_linear_vram_bank(s, 0);\n    map_linear_vram_bank(s, 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8302, "func": "XFixesCopyRegion (Display *dpy, XserverRegion dst, XserverRegion src)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesCopyRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesCopyRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesCopyRegion;\n    req->source = src;\n    req->destination = dst;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7509, "func": "  tt_check_trickyness_family( FT_String*  name )\n  {\n\n#define TRICK_NAMES_MAX_CHARACTERS  19\n#define TRICK_NAMES_COUNT            9\n\n    static const char trick_names[TRICK_NAMES_COUNT]\n                                 [TRICK_NAMES_MAX_CHARACTERS + 1] =\n    {\n      \"DFKaiSho-SB\",        \n      \"DFKaiShu\",\n      \"DFKai-SB\",           \n      \"HuaTianKaiTi?\",      \n      \"HuaTianSongTi?\",     \n      \"Ming(for ISO10646)\", \n      \"MingLiU\",            \n      \"PMingLiU\",           \n      \"MingLi43\",           \n    };\n\n    int  nn;\n\n\n    for ( nn = 0; nn < TRICK_NAMES_COUNT; nn++ )\n      if ( ft_strstr( name, trick_names[nn] ) )\n        return TRUE;\n\n    return FALSE;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7481, "func": "int notsup_setxattr(FsContext *ctx, const char *path, const char *name,\n                    void *value, size_t size, int flags)\n{\n    errno = ENOTSUP;\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187283, "func": "void ElementsUploadDataStreamTest::FileChangedHelper(\n    const base::FilePath& file_path,\n    const base::Time& time,\n    bool error_expected) {\n   std::vector<std::unique_ptr<UploadElementReader>> element_readers;\n  element_readers.push_back(base::MakeUnique<UploadFileElementReader>(\n       base::ThreadTaskRunnerHandle::Get().get(), file_path, 1, 2, time));\n \n   TestCompletionCallback init_callback;\n  std::unique_ptr<UploadDataStream> stream(\n      new ElementsUploadDataStream(std::move(element_readers), 0));\n  ASSERT_THAT(stream->Init(init_callback.callback(), NetLogWithSource()),\n              IsError(ERR_IO_PENDING));\n  int error_code = init_callback.WaitForResult();\n  if (error_expected)\n    ASSERT_THAT(error_code, IsError(ERR_UPLOAD_FILE_CHANGED));\n  else\n    ASSERT_THAT(error_code, IsOk());\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 7789, "func": "static void h2_wake_some_streams(struct h2c *h2c, int last, uint32_t flags)\n{\n\tstruct eb32_node *node;\n\tstruct h2s *h2s;\n\n\tif (h2c->st0 >= H2_CS_ERROR || h2c->conn->flags & CO_FL_ERROR)\n\t\tflags |= CS_FL_ERROR;\n\n\tif (conn_xprt_read0_pending(h2c->conn))\n\t\tflags |= CS_FL_EOS;\n\n\tnode = eb32_lookup_ge(&h2c->streams_by_id, last + 1);\n\twhile (node) {\n\t\th2s = container_of(node, struct h2s, by_id);\n\t\tif (h2s->id <= last)\n\t\t\tbreak;\n\t\tnode = eb32_next(node);\n\n\t\tif (!h2s->cs) {\n\t\t\th2s_destroy(h2s);\n\t\t\tcontinue;\n\t\t}\n\n\t\th2s->cs->flags |= flags;\n\t\th2s->cs->data_cb->recv(h2s->cs);\n\t\th2s->cs->data_cb->wake(h2s->cs);\n\n\t\tif (flags & CS_FL_ERROR && h2s->st < H2_SS_ERROR)\n\t\t\th2s->st = H2_SS_ERROR;\n\t\telse if (flags & CS_FL_EOS && h2s->st == H2_SS_OPEN)\n\t\t\th2s->st = H2_SS_HREM;\n\t\telse if (flags & CS_FL_EOS && h2s->st == H2_SS_HLOC)\n\t\t\th2s_close(h2s);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7421, "func": "ZEND_API int zend_ts_hash_exists(TsHashTable *ht, zend_string *key)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_exists(TS_HASH(ht), key);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187037, "func": "void Document::InitSecurityContext(const DocumentInit& initializer) {\n  DCHECK(!GetSecurityOrigin());\n\n  if (!initializer.HasSecurityContext()) {\n    cookie_url_ = KURL(g_empty_string);\n    SetSecurityOrigin(SecurityOrigin::CreateUniqueOpaque());\n    InitContentSecurityPolicy();\n    ApplyFeaturePolicy({});\n    return;\n  }\n\n  SandboxFlags sandbox_flags = initializer.GetSandboxFlags();\n  if (fetcher_->Archive()) {\n    sandbox_flags |=\n        kSandboxAll &\n        ~(kSandboxPopups | kSandboxPropagatesToAuxiliaryBrowsingContexts);\n  }\n  EnforceSandboxFlags(sandbox_flags);\n  SetInsecureRequestPolicy(initializer.GetInsecureRequestPolicy());\n  if (initializer.InsecureNavigationsToUpgrade()) {\n    for (auto to_upgrade : *initializer.InsecureNavigationsToUpgrade())\n       AddInsecureNavigationUpgrade(to_upgrade);\n   }\n \n  const ContentSecurityPolicy* policy_to_inherit = nullptr;\n \n   if (IsSandboxed(kSandboxOrigin)) {\n     cookie_url_ = url_;\n    scoped_refptr<SecurityOrigin> security_origin =\n        SecurityOrigin::CreateUniqueOpaque();\n    Document* owner = initializer.OwnerDocument();\n    if (owner) {\n      if (owner->GetSecurityOrigin()->IsPotentiallyTrustworthy())\n         security_origin->SetOpaqueOriginIsPotentiallyTrustworthy(true);\n       if (owner->GetSecurityOrigin()->CanLoadLocalResources())\n         security_origin->GrantLoadLocalResources();\n      policy_to_inherit = owner->GetContentSecurityPolicy();\n     }\n     SetSecurityOrigin(std::move(security_origin));\n   } else if (Document* owner = initializer.OwnerDocument()) {\n     cookie_url_ = owner->CookieURL();\n     SetSecurityOrigin(owner->GetMutableSecurityOrigin());\n    policy_to_inherit = owner->GetContentSecurityPolicy();\n   } else {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::Create(url_));\n  }\n\n  if (initializer.IsHostedInReservedIPRange()) {\n    SetAddressSpace(GetSecurityOrigin()->IsLocalhost()\n                        ? mojom::IPAddressSpace::kLocal\n                        : mojom::IPAddressSpace::kPrivate);\n  } else if (GetSecurityOrigin()->IsLocal()) {\n    SetAddressSpace(mojom::IPAddressSpace::kLocal);\n  } else {\n    SetAddressSpace(mojom::IPAddressSpace::kPublic);\n  }\n\n  if (ImportsController()) {\n     SetContentSecurityPolicy(\n         ImportsController()->Master()->GetContentSecurityPolicy());\n   } else {\n    InitContentSecurityPolicy(nullptr, policy_to_inherit,\n                              initializer.PreviousDocumentCSP());\n   }\n \n   if (Settings* settings = initializer.GetSettings()) {\n    if (!settings->GetWebSecurityEnabled()) {\n      GetMutableSecurityOrigin()->GrantUniversalAccess();\n    } else if (GetSecurityOrigin()->IsLocal()) {\n      if (settings->GetAllowUniversalAccessFromFileURLs()) {\n        GetMutableSecurityOrigin()->GrantUniversalAccess();\n      } else if (!settings->GetAllowFileAccessFromFileURLs()) {\n        GetMutableSecurityOrigin()->BlockLocalAccessFromLocalOrigin();\n      }\n    }\n  }\n\n  if (GetSecurityOrigin()->IsOpaque() &&\n      SecurityOrigin::Create(url_)->IsPotentiallyTrustworthy())\n    GetMutableSecurityOrigin()->SetOpaqueOriginIsPotentiallyTrustworthy(true);\n\n  ApplyFeaturePolicy({});\n\n  InitSecureContextState();\n}\n", "target": 1, "flaw_line_index": "34,52,60"}
{"idx": 187103, "func": "bool PermissionsData::CanCaptureVisiblePage(\n    const GURL& document_url,\n    int tab_id,\n    std::string* error,\n    CaptureRequirement capture_requirement) const {\n  bool has_active_tab = false;\n  bool has_all_urls = false;\n  bool has_page_capture = false;\n  url::Origin origin = url::Origin::Create(document_url);\n  const GURL origin_url = origin.GetURL();\n  {\n    base::AutoLock auto_lock(runtime_lock_);\n    if (location_ != Manifest::COMPONENT &&\n        IsPolicyBlockedHostUnsafe(origin_url)) {\n      if (error)\n        *error = extension_misc::kPolicyBlockedScripting;\n      return false;\n    }\n\n    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);\n     has_active_tab = tab_permissions &&\n                      tab_permissions->HasAPIPermission(APIPermission::kTab);\n \n    const URLPattern all_urls(URLPattern::SCHEME_ALL,\n                              URLPattern::kAllUrlsPattern);\n    has_all_urls =\n        active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);\n     has_page_capture = active_permissions_unsafe_->HasAPIPermission(\n         APIPermission::kPageCapture);\n   }\n  std::string access_error;\n  if (capture_requirement == CaptureRequirement::kActiveTabOrAllUrls) {\n    if (!has_active_tab && !has_all_urls) {\n      if (error)\n        *error = manifest_errors::kAllURLOrActiveTabNeeded;\n      return false;\n    }\n\n    if (GetPageAccess(origin_url, tab_id, &access_error) ==\n        PageAccess::kAllowed)\n      return true;\n  } else {\n    DCHECK_EQ(CaptureRequirement::kPageCapture, capture_requirement);\n    if (!has_page_capture) {\n      if (error)\n        *error = manifest_errors::kPageCaptureNeeded;\n    }\n\n    if ((origin_url.SchemeIs(url::kHttpScheme) ||\n         origin_url.SchemeIs(url::kHttpsScheme)) &&\n        !origin.IsSameOriginWith(url::Origin::Create(\n            ExtensionsClient::Get()->GetWebstoreBaseURL()))) {\n      return true;\n    }\n  }\n\n\n  if (origin_url.host() == extension_id_)\n    return true;\n\n  bool allowed_with_active_tab =\n      origin_url.SchemeIs(content::kChromeUIScheme) ||\n      origin_url.SchemeIs(kExtensionScheme) ||\n      document_url.SchemeIs(url::kDataScheme) ||\n      origin.IsSameOriginWith(\n          url::Origin::Create(ExtensionsClient::Get()->GetWebstoreBaseURL()));\n\n  if (!allowed_with_active_tab) {\n    if (error)\n      *error = access_error;\n    return false;\n  }\n  if (has_active_tab)\n    return true;\n\n  if (error)\n    *error = manifest_errors::kActiveTabPermissionNotGranted;\n  return false;\n}\n", "target": 1, "flaw_line_index": "32,33,34,35"}
{"idx": 7521, "func": "  tt_size_ready_bytecode( TT_Size  size,\n                          FT_Bool  pedantic )\n  {\n    FT_Error  error = FT_Err_Ok;\n\n\n    if ( size->bytecode_ready < 0 )\n      error = tt_size_init_bytecode( (FT_Size)size, pedantic );\n    else\n      error = size->bytecode_ready;\n\n    if ( error )\n      goto Exit;\n\n    if ( size->cvt_ready < 0 )\n    {\n      FT_UInt  i;\n      TT_Face  face = (TT_Face)size->root.face;\n\n\n      for ( i = 0; i < size->cvt_size; i++ )\n        size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );\n\n      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )\n      {\n        size->twilight.org[i].x = 0;\n        size->twilight.org[i].y = 0;\n        size->twilight.cur[i].x = 0;\n        size->twilight.cur[i].y = 0;\n      }\n\n      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )\n        size->storage[i] = 0;\n\n      size->GS = tt_default_graphics_state;\n\n      error = tt_size_run_prep( size, pedantic );\n    }\n    else\n      error = size->cvt_ready;\n\n  Exit:\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8168, "func": "void Gfx::opShowSpaceText(Object args[], int numArgs) {\n  Array *a;\n  Object obj;\n  int wMode;\n  int i;\n\n  if (!state->getFont()) {\n    error(getPos(), \"No font in show/space\");\n    return;\n  }\n  if (fontChanged) {\n    out->updateFont(state);\n    fontChanged = gFalse;\n  }\n  out->beginStringOp(state);\n  wMode = state->getFont()->getWMode();\n  a = args[0].getArray();\n  for (i = 0; i < a->getLength(); ++i) {\n    a->get(i, &obj);\n    if (obj.isNum()) {\n      if (wMode) {\n\tstate->textShift(0, -obj.getNum() * 0.001 *\n\t\t\t    fabs(state->getFontSize()));\n      } else {\n\tstate->textShift(-obj.getNum() * 0.001 *\n\t\t\t fabs(state->getFontSize()), 0);\n      }\n      out->updateTextShift(state, obj.getNum());\n    } else if (obj.isString()) {\n      doShowText(obj.getString());\n    } else {\n      error(getPos(), \"Element of show/space array must be number or string\");\n    }\n    obj.free();\n  }\n  out->endStringOp(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187046, "func": " std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n \n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\"--\" + switch_name + L\"=\";\n  for (size_t i = 1; i < as_array.size(); ++i) {\n    const std::wstring& arg = as_array[i];\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }\n\n  return std::wstring();\n}\n", "target": 1, "flaw_line_index": "8,9"}
{"idx": 187224, "func": "static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)\n{\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);\n\tHANDLE hid_handle;\n\tint current_interface;\n\tCHECK_HID_AVAILABLE;\n\tcurrent_interface = transfer_priv->interface_number;\n\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\tCancelIo(hid_handle);\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13"}
{"idx": 186820, "func": "void PlatformSensorProviderLinux::CreateSensorAndNotify(\n    mojom::SensorType type,\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n  if (sensor_device && mapping && StartPollingThread()) {\n    sensor =\n        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n                                polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n", "target": 1, "flaw_line_index": "6,7,8,9,10"}
{"idx": 7978, "func": "static int32_t read_s32(uint8_t *data, size_t offset)\n{\n    return (int32_t)((data[offset] << 24) | (data[offset + 1] << 16) |\n                     (data[offset + 2] << 8) | data[offset + 3]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187132, "func": "bool MediaElementAudioSourceHandler::PassesCurrentSrcCORSAccessCheck(\n    const KURL& current_src) {\n  DCHECK(IsMainThread());\n  return Context()->GetSecurityOrigin() &&\n         Context()->GetSecurityOrigin()->CanRequest(current_src);\n }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 7436, "func": "ZEND_API int _zend_ts_hash_init(TsHashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n#ifdef ZTS\n\tht->mx_reader = tsrm_mutex_alloc();\n\tht->mx_writer = tsrm_mutex_alloc();\n\tht->reader = 0;\n#endif\n\treturn _zend_hash_init(TS_HASH(ht), nSize, pHashFunction, pDestructor, persistent ZEND_FILE_LINE_RELAY_CC);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8151, "func": "void Gfx::opSetLineCap(Object args[], int numArgs) {\n  state->setLineCap(args[0].getInt());\n  out->updateLineCap(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186695, "func": "  TestWCDelegateForDialogsAndFullscreen()\n      : is_fullscreen_(false), message_loop_runner_(new MessageLoopRunner) {}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7430, "func": "ZEND_API int zend_ts_hash_rehash(TsHashTable *ht)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_rehash(TS_HASH(ht));\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186432, "func": "std::string SanitizeRevision(const std::string& revision) {\n  for (size_t i = 0; i < revision.length(); i++) {\n    if (!(revision[i] == '@' && i == 0)\n        && !(revision[i] >= '0' && revision[i] <= '9')\n        && !(revision[i] >= 'a' && revision[i] <= 'z')\n        && !(revision[i] >= 'A' && revision[i] <= 'Z')) {\n      return std::string();\n    }\n  }\n  return revision;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11"}
{"idx": 186404, "func": "void PageInfo::OnChangePasswordButtonPressed(\n     content::WebContents* web_contents) {\n #if defined(FULL_SAFE_BROWSING)\n   DCHECK(password_protection_service_);\n  DCHECK(safe_browsing_status_ == SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE ||\n         safe_browsing_status_ ==\n             SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE);\n   password_protection_service_->OnUserAction(\n       web_contents,\n      safe_browsing_status_ == SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE\n           ? PasswordReuseEvent::SIGN_IN_PASSWORD\n           : PasswordReuseEvent::ENTERPRISE_PASSWORD,\n       safe_browsing::WarningUIType::PAGE_INFO,\n      safe_browsing::WarningAction::CHANGE_PASSWORD);\n#endif\n}\n", "target": 1, "flaw_line_index": "5,6,7,10"}
{"idx": 186601, "func": "bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n    return false;\n  if (init_cb_)\n    return false;\n  if (failed_)\n    return false;\n  return true;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10"}
{"idx": 8218, "func": "static void v9fs_getlock(void *opaque)\n{\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsGetlock glock;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&glock.client_id);\n    err = pdu_unmarshal(pdu, offset, \"dbqqds\", &fid, &glock.type,\n                        &glock.start, &glock.length, &glock.proc_id,\n                        &glock.client_id);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getlock(pdu->tag, pdu->id, fid,\n                       glock.type, glock.start, glock.length);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    glock.type = P9_LOCK_TYPE_UNLCK;\n    err = pdu_marshal(pdu, offset, \"bqqds\", glock.type,\n                          glock.start, glock.length, glock.proc_id,\n                          &glock.client_id);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_getlock_return(pdu->tag, pdu->id, glock.type, glock.start,\n                              glock.length, glock.proc_id);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&glock.client_id);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7662, "func": "static int v9fs_receivefd(int sockfd, int *status)\n{\n    struct iovec iov;\n    struct msghdr msg;\n    struct cmsghdr *cmsg;\n    int retval, data, fd;\n    union MsgControl msg_control;\n\n    iov.iov_base = &data;\n    iov.iov_len = sizeof(data);\n\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = &msg_control;\n    msg.msg_controllen = sizeof(msg_control);\n\n    do {\n        retval = recvmsg(sockfd, &msg, 0);\n    } while (retval < 0 && errno == EINTR);\n    if (retval <= 0) {\n        return retval;\n    }\n    if (data != V9FS_FD_VALID) {\n        *status = data;\n        return 0;\n    }\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n            cmsg->cmsg_level != SOL_SOCKET ||\n            cmsg->cmsg_type != SCM_RIGHTS) {\n            continue;\n        }\n        fd = *((int *)CMSG_DATA(cmsg));\n        *status = fd;\n        return 0;\n    }\n    *status = -ENFILE;  \n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8076, "func": "void Gfx::doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,\n\t\t  GBool transpGroup, GBool softMask,\n\t\t  GfxColorSpace *blendingColorSpace,\n\t\t  GBool isolated, GBool knockout,\n\t\t  GBool alpha, Function *transferFunc,\n\t\t  GfxColor *backdropColor) {\n  Parser *oldParser;\n  double oldBaseMatrix[6];\n  int i;\n\n  pushResources(resDict);\n\n  saveState();\n\n  state->clearPath();\n\n  oldParser = parser;\n\n  state->concatCTM(matrix[0], matrix[1], matrix[2],\n\t\t   matrix[3], matrix[4], matrix[5]);\n  out->updateCTM(state, matrix[0], matrix[1], matrix[2],\n\t\t matrix[3], matrix[4], matrix[5]);\n\n  state->moveTo(bbox[0], bbox[1]);\n  state->lineTo(bbox[2], bbox[1]);\n  state->lineTo(bbox[2], bbox[3]);\n  state->lineTo(bbox[0], bbox[3]);\n  state->closePath();\n  state->clip();\n  out->clip(state);\n  state->clearPath();\n\n  if (softMask || transpGroup) {\n    if (state->getBlendMode() != gfxBlendNormal) {\n      state->setBlendMode(gfxBlendNormal);\n      out->updateBlendMode(state);\n    }\n    if (state->getFillOpacity() != 1) {\n      state->setFillOpacity(1);\n      out->updateFillOpacity(state);\n    }\n    if (state->getStrokeOpacity() != 1) {\n      state->setStrokeOpacity(1);\n      out->updateStrokeOpacity(state);\n    }\n    out->clearSoftMask(state);\n    out->beginTransparencyGroup(state, bbox, blendingColorSpace,\n\t\t\t\tisolated, knockout, softMask);\n  }\n\n  for (i = 0; i < 6; ++i) {\n    oldBaseMatrix[i] = baseMatrix[i];\n    baseMatrix[i] = state->getCTM()[i];\n  }\n\n  GfxState *stateBefore = state;\n\n  display(str, gFalse);\n  \n  if (stateBefore != state) {\n    if (state->isParentState(stateBefore)) {\n      error(-1, \"There's a form with more q than Q, trying to fix\");\n      while (stateBefore != state) {\n        restoreState();\n      }\n    } else {\n      error(-1, \"There's a form with more Q than q\");\n    }\n  }\n\n  if (softMask || transpGroup) {\n    out->endTransparencyGroup(state);\n  }\n\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = oldBaseMatrix[i];\n  }\n\n  parser = oldParser;\n\n  restoreState();\n\n  popResources();\n\n  if (softMask) {\n    out->setSoftMask(state, bbox, alpha, transferFunc, backdropColor);\n  } else if (transpGroup) {\n    out->paintTransparencyGroup(state, bbox);\n  }\n\n  return;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7699, "func": "static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp)\n{\n    int fd, ret;\n    fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n    if (ret < 0) {\n        goto err_out;\n    }\n    ret = fchmod(fd, credp->fc_mode & 07777);\nerr_out:\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8005, "func": "static long vnc_client_write_tls(gnutls_session_t *session,\n                                 const uint8_t *data,\n                                 size_t datalen)\n{\n    long ret = gnutls_write(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186626, "func": "bool LocalFrameClientImpl::NavigateBackForward(int offset) const {\n  WebViewImpl* webview = web_frame_->ViewImpl();\n  if (!webview->Client())\n    return false;\n\n  DCHECK(offset);\n  if (offset > webview->Client()->HistoryForwardListCount())\n     return false;\n   if (offset < -webview->Client()->HistoryBackListCount())\n     return false;\n  webview->Client()->NavigateBackForwardSoon(offset);\n   return true;\n }\n", "target": 1, "flaw_line_index": "11"}
{"idx": 8043, "func": "void vnc_sent_lossy_rect(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n\n    w = (x + w) / VNC_STAT_RECT;\n    h = (y + h) / VNC_STAT_RECT;\n    x /= VNC_STAT_RECT;\n    y /= VNC_STAT_RECT;\n\n    for (j = y; j <= h; j++) {\n        for (i = x; i <= w; i++) {\n            vs->lossy_rect[j][i] = 1;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7562, "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\t\t\t\t\t    const uint8_t * src)\n{\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n    if (blit_is_unsafe(s))\n        return 0;\n\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186748, "func": "StorageHandler::GetCacheStorageObserver() {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (!cache_storage_observer_) {\n     cache_storage_observer_ = std::make_unique<CacheStorageObserver>(\n         weak_ptr_factory_.GetWeakPtr(),\n         static_cast<CacheStorageContextImpl*>(\n            process_->GetStoragePartition()->GetCacheStorageContext()));\n   }\n   return cache_storage_observer_.get();\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 8081, "func": "void Gfx::doPatchMeshShFill(GfxPatchMeshShading *shading) {\n  int start, i;\n\n  if (shading->getNPatches() > 128) {\n    start = 3;\n  } else if (shading->getNPatches() > 64) {\n    start = 2;\n  } else if (shading->getNPatches() > 16) {\n    start = 1;\n  } else {\n    start = 0;\n  }\n  for (i = 0; i < shading->getNPatches(); ++i) {\n    fillPatch(shading->getPatch(i), shading->getColorSpace()->getNComps(),\n\t      start);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187028, "func": "void ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy(\n    int32_t element_instance_id,\n    int32_t plugin_frame_routing_id) {\n  auto it = frame_navigation_helpers_.find(element_instance_id);\n  if (it == frame_navigation_helpers_.end()) {\n    return;\n  }\n  auto* plugin_rfh = content::RenderFrameHost::FromID(render_process_id_,\n                                                      plugin_frame_routing_id);\n  auto* helper = it->second.get();\n  auto* guest_view = helper->GetGuestView();\n  if (!guest_view)\n    return;\n \n  if (plugin_rfh) {\n    DCHECK(\n        guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh));\n    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,\n                                              helper->is_full_page_plugin());\n  } else {\n    guest_view->GetEmbedderFrame()->Send(\n        new ExtensionsGuestViewMsg_DestroyFrameContainer(element_instance_id));\n    guest_view->Destroy(true);\n  }\n  frame_navigation_helpers_.erase(element_instance_id);\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,16,17,18,19,20,21,22,23,24,25,26"}
{"idx": 7920, "func": "static void ctypeof(JF, js_Ast *exp)\n{\n\tif (exp->type == EXP_IDENTIFIER)\n\t\temitlocal(J, F, OP_GETLOCAL, OP_HASVAR, exp);\n\telse\n\t\tcexp(J, F, exp);\n\temit(J, F, OP_TYPEOF);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7574, "func": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vga.vram_ptr + ((s->cirrus_blt_srcaddr & ~7) &\n                                            s->cirrus_addr_mask));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187033, "func": "void DOMStorageContextWrapper::OpenSessionStorage(\n    int process_id,\n    const std::string& namespace_id,\n    mojo::ReportBadMessageCallback bad_message_callback,\n     blink::mojom::SessionStorageNamespaceRequest request) {\n   if (!mojo_session_state_)\n     return;\n  mojo_task_runner_->PostTask(\n       FROM_HERE,\n       base::BindOnce(&SessionStorageContextMojo::OpenSessionStorage,\n                      base::Unretained(mojo_session_state_), process_id,\n                     namespace_id, std::move(bad_message_callback),\n                      std::move(request)));\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187277, "func": "static bool TokenExitsSVG(const CompactHTMLToken& token) {\n  return DeprecatedEqualIgnoringCase(token.Data(),\n                                     SVGNames::foreignObjectTag.LocalName());\n}\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 187073, "func": "void RenderFrameHostImpl::CreateMediaStreamDispatcherHost(\n    MediaStreamManager* media_stream_manager,\n    mojom::MediaStreamDispatcherHostRequest request) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!media_stream_dispatcher_host_) {\n    media_stream_dispatcher_host_.reset(new MediaStreamDispatcherHost(\n        GetProcess()->GetID(), GetRoutingID(), media_stream_manager));\n  }\n  media_stream_dispatcher_host_->BindRequest(std::move(request));\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10"}
{"idx": 8251, "func": "Bool XvMCQueryExtension (Display *dpy, int *event_basep, int *error_basep)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n\n    if (XextHasExtension(info)) {\n        *event_basep = info->codes->first_event;\n        *error_basep = info->codes->first_error;\n        return True;\n    } else {\n        return False;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7821, "func": "  TT_Done_Context( TT_ExecContext  exec )\n  {\n    FT_Memory  memory = exec->memory;\n\n\n    exec->maxPoints   = 0;\n    exec->maxContours = 0;\n\n    FT_FREE( exec->stack );\n    exec->stackSize = 0;\n\n    FT_FREE( exec->callStack );\n    exec->callSize = 0;\n    exec->callTop  = 0;\n\n    FT_FREE( exec->glyphIns );\n    exec->glyphSize = 0;\n\n    exec->size = NULL;\n    exec->face = NULL;\n\n    FT_FREE( exec );\n\n    return TT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8236, "func": "static void v9fs_statfs(void *opaque)\n{\n    int32_t fid;\n    ssize_t retval = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    struct statfs stbuf;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    retval = v9fs_co_statfs(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval = v9fs_fill_statfs(s, pdu, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187086, "func": "   DeviceRequest(\n       int requesting_process_id,\n       int requesting_frame_id,\n       int page_request_id,\n       bool user_gesture,\n       MediaStreamRequestType request_type,\n      const StreamControls& controls,\n      MediaDeviceSaltAndOrigin salt_and_origin,\n       DeviceStoppedCallback device_stopped_cb = DeviceStoppedCallback())\n       : requesting_process_id(requesting_process_id),\n         requesting_frame_id(requesting_frame_id),\n         page_request_id(page_request_id),\n         user_gesture(user_gesture),\n         controls(controls),\n        salt_and_origin(std::move(salt_and_origin)),\n        device_stopped_cb(std::move(device_stopped_cb)),\n        state_(NUM_MEDIA_TYPES, MEDIA_REQUEST_STATE_NOT_REQUESTED),\n        request_type_(request_type),\n        audio_type_(MEDIA_NO_SERVICE),\n        video_type_(MEDIA_NO_SERVICE),\n        target_process_id_(-1),\n        target_frame_id_(-1) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186556, "func": "void ReportRequestHeaders(std::map<std::string, std::string>* request_headers,\n                          const std::string& url,\n                          const std::string& headers) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  EXPECT_FALSE(base::ContainsKey(*request_headers, url));\n  (*request_headers)[url] = headers;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8"}
{"idx": 187007, "func": "void ResourceDispatcherHostImpl::InitializeURLRequest(\n    net::URLRequest* request,\n    const Referrer& referrer,\n    bool is_download,\n     int render_process_host_id,\n     int render_view_routing_id,\n     int render_frame_routing_id,\n     PreviewsState previews_state,\n     ResourceContext* context) {\n   DCHECK(io_thread_task_runner_->BelongsToCurrentThread());\n  DCHECK(!request->is_pending());\n\n  Referrer::SetReferrerForRequest(request, referrer);\n \n   ResourceRequestInfoImpl* info = CreateRequestInfo(\n       render_process_host_id, render_view_routing_id, render_frame_routing_id,\n      previews_state, is_download, context);\n   info->AssociateWithRequest(request);\n }\n", "target": 1, "flaw_line_index": "17"}
{"idx": 187039, "func": "bool ContentSecurityPolicy::AllowPluginTypeForDocument(\n    const Document& document,\n    const String& type,\n    const String& type_attribute,\n    const KURL& url,\n    SecurityViolationReportingPolicy reporting_policy) const {\n  if (document.GetContentSecurityPolicy() &&\n      !document.GetContentSecurityPolicy()->AllowPluginType(\n           type, type_attribute, url, reporting_policy))\n     return false;\n \n  LocalFrame* frame = document.GetFrame();\n  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {\n    ContentSecurityPolicy* parent_csp = frame->Tree()\n                                            .Parent()\n                                            ->GetSecurityContext()\n                                            ->GetContentSecurityPolicy();\n    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,\n                                                   reporting_policy))\n      return false;\n  }\n   return true;\n }\n", "target": 1, "flaw_line_index": "12,13,14,15,16,17,18,19,20,21,22,23,24"}
{"idx": 186407, "func": "void PageInfo::RecordPasswordReuseEvent() {\n  if (!password_protection_service_) {\n     return;\n   }\n \n  if (safe_browsing_status_ == SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE) {\n     safe_browsing::LogWarningAction(\n         safe_browsing::WarningUIType::PAGE_INFO,\n         safe_browsing::WarningAction::SHOWN,\n        safe_browsing::LoginReputationClientRequest::PasswordReuseEvent::\n            SIGN_IN_PASSWORD,\n        password_protection_service_->GetSyncAccountType());\n  } else {\n    safe_browsing::LogWarningAction(\n        safe_browsing::WarningUIType::PAGE_INFO,\n        safe_browsing::WarningAction::SHOWN,\n        safe_browsing::LoginReputationClientRequest::PasswordReuseEvent::\n            ENTERPRISE_PASSWORD,\n        password_protection_service_->GetSyncAccountType());\n  }\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187298, "func": " NotificationsNativeHandler::NotificationsNativeHandler(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetNotificationImageSizes\",\n       base::Bind(&NotificationsNativeHandler::GetNotificationImageSizes,\n                  base::Unretained(this)));\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186764, "func": "void SharedWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   session->AddHandler(std::make_unique<protocol::InspectorHandler>());\n   session->AddHandler(std::make_unique<protocol::NetworkHandler>(GetId()));\n   session->AddHandler(std::make_unique<protocol::SchemaHandler>());\n  session->SetRenderer(GetProcess(), nullptr);\n   if (state_ == WORKER_READY)\n     session->AttachToAgent(EnsureAgent());\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 186923, "func": "htmlInitParserCtxt(htmlParserCtxtPtr ctxt)\n{\n    htmlSAXHandler *sax;\n\n    if (ctxt == NULL) return(-1);\n    memset(ctxt, 0, sizeof(htmlParserCtxt));\n\n    ctxt->dict = xmlDictCreate();\n    if (ctxt->dict == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\treturn(-1);\n    }\n    sax = (htmlSAXHandler *) xmlMalloc(sizeof(htmlSAXHandler));\n    if (sax == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\treturn(-1);\n    }\n    else\n        memset(sax, 0, sizeof(htmlSAXHandler));\n\n    ctxt->inputTab = (htmlParserInputPtr *)\n                      xmlMalloc(5 * sizeof(htmlParserInputPtr));\n    if (ctxt->inputTab == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\tctxt->inputNr = 0;\n\tctxt->inputMax = 0;\n\tctxt->input = NULL;\n\treturn(-1);\n    }\n    ctxt->inputNr = 0;\n    ctxt->inputMax = 5;\n    ctxt->input = NULL;\n    ctxt->version = NULL;\n    ctxt->encoding = NULL;\n    ctxt->standalone = -1;\n    ctxt->instate = XML_PARSER_START;\n\n    ctxt->nodeTab = (htmlNodePtr *) xmlMalloc(10 * sizeof(htmlNodePtr));\n    if (ctxt->nodeTab == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\tctxt->nodeNr = 0;\n\tctxt->nodeMax = 0;\n\tctxt->node = NULL;\n\tctxt->inputNr = 0;\n\tctxt->inputMax = 0;\n\tctxt->input = NULL;\n\treturn(-1);\n    }\n    ctxt->nodeNr = 0;\n    ctxt->nodeMax = 10;\n    ctxt->node = NULL;\n\n    ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));\n    if (ctxt->nameTab == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\tctxt->nameNr = 0;\n\tctxt->nameMax = 0;\n\tctxt->name = NULL;\n\tctxt->nodeNr = 0;\n\tctxt->nodeMax = 0;\n\tctxt->node = NULL;\n\tctxt->inputNr = 0;\n\tctxt->inputMax = 0;\n\tctxt->input = NULL;\n\treturn(-1);\n    }\n    ctxt->nameNr = 0;\n    ctxt->nameMax = 10;\n    ctxt->name = NULL;\n\n    ctxt->nodeInfoTab = NULL;\n    ctxt->nodeInfoNr  = 0;\n    ctxt->nodeInfoMax = 0;\n\n    if (sax == NULL) ctxt->sax = (xmlSAXHandlerPtr) &htmlDefaultSAXHandler;\n    else {\n        ctxt->sax = sax;\n\tmemcpy(sax, &htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));\n    }\n    ctxt->userData = ctxt;\n    ctxt->myDoc = NULL;\n     ctxt->wellFormed = 1;\n     ctxt->replaceEntities = 0;\n     ctxt->linenumbers = xmlLineNumbersDefaultValue;\n     ctxt->html = 1;\n     ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;\n     ctxt->vctxt.userData = ctxt;\n    ctxt->vctxt.error = xmlParserValidityError;\n    ctxt->vctxt.warning = xmlParserValidityWarning;\n    ctxt->record_info = 0;\n    ctxt->validate = 0;\n    ctxt->nbChars = 0;\n    ctxt->checkIndex = 0;\n    ctxt->catalogs = NULL;\n    xmlInitNodeInfoSeq(&ctxt->node_seq);\n    return(0);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7843, "func": "void free_xbzrle_decoded_buf(void)\n{\n    g_free(xbzrle_decoded_buf);\n    xbzrle_decoded_buf = NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186346, "func": "bool ResourcePrefetchPredictor::GetRedirectEndpointsForPreconnect(\n    const url::Origin& entry_origin,\n    const RedirectDataMap& redirect_data,\n    PreconnectPrediction* prediction) const {\n  if (!base::FeatureList::IsEnabled(\n          features::kLoadingPreconnectToRedirectTarget)) {\n    return false;\n  }\n  DCHECK(!prediction || prediction->requests.empty());\n\n  RedirectData data;\n  if (!redirect_data.TryGetData(entry_origin.host(), &data))\n    return false;\n\n  const float kMinRedirectConfidenceToTriggerPrefetch = 0.1f;\n\n  bool at_least_one_redirect_endpoint_added = false;\n  for (const auto& redirect : data.redirect_endpoints()) {\n    if (ComputeRedirectConfidence(redirect) <\n        kMinRedirectConfidenceToTriggerPrefetch) {\n      continue;\n    }\n\n    std::string redirect_scheme =\n        redirect.url_scheme().empty() ? \"https\" : redirect.url_scheme();\n    int redirect_port = redirect.has_url_port() ? redirect.url_port() : 443;\n\n    const url::Origin redirect_origin = url::Origin::CreateFromNormalizedTuple(\n        redirect_scheme, redirect.url(), redirect_port);\n\n    if (redirect_origin == entry_origin) {\n      continue;\n    }\n\n     if (prediction) {\n       prediction->requests.emplace_back(\n          redirect_origin.GetURL(), 1 \n,\n           net::NetworkIsolationKey(redirect_origin, redirect_origin));\n     }\n     at_least_one_redirect_endpoint_added = true;\n  }\n\n  if (prediction && prediction->host.empty() &&\n      at_least_one_redirect_endpoint_added) {\n    prediction->host = entry_origin.host();\n  }\n\n  return at_least_one_redirect_endpoint_added;\n}\n", "target": 1, "flaw_line_index": "46"}
{"idx": 187186, "func": "void Document::DispatchUnloadEvents() {\n  PluginScriptForbiddenScope forbid_plugin_destructor_scripting;\n  if (parser_)\n    parser_->StopParsing();\n\n  if (load_event_progress_ == kLoadEventNotRun)\n    return;\n\n  if (load_event_progress_ <= kUnloadEventInProgress) {\n    Element* current_focused_element = FocusedElement();\n    if (auto* input = ToHTMLInputElementOrNull(current_focused_element))\n      input->EndEditing();\n    if (load_event_progress_ < kPageHideInProgress) {\n      load_event_progress_ = kPageHideInProgress;\n      if (LocalDOMWindow* window = domWindow()) {\n        const TimeTicks pagehide_event_start = CurrentTimeTicks();\n        window->DispatchEvent(\n            PageTransitionEvent::Create(EventTypeNames::pagehide, false), this);\n        const TimeTicks pagehide_event_end = CurrentTimeTicks();\n        DEFINE_STATIC_LOCAL(\n            CustomCountHistogram, pagehide_histogram,\n            (\"DocumentEventTiming.PageHideDuration\", 0, 10000000, 50));\n        pagehide_histogram.Count(\n            (pagehide_event_end - pagehide_event_start).InMicroseconds());\n      }\n      if (!frame_)\n        return;\n\n      mojom::PageVisibilityState visibility_state = GetPageVisibilityState();\n      load_event_progress_ = kUnloadVisibilityChangeInProgress;\n      if (visibility_state != mojom::PageVisibilityState::kHidden) {\n        const TimeTicks pagevisibility_hidden_event_start = CurrentTimeTicks();\n        DispatchEvent(Event::CreateBubble(EventTypeNames::visibilitychange));\n        const TimeTicks pagevisibility_hidden_event_end = CurrentTimeTicks();\n        DEFINE_STATIC_LOCAL(CustomCountHistogram, pagevisibility_histogram,\n                            (\"DocumentEventTiming.PageVibilityHiddenDuration\",\n                             0, 10000000, 50));\n        pagevisibility_histogram.Count((pagevisibility_hidden_event_end -\n                                        pagevisibility_hidden_event_start)\n                                           .InMicroseconds());\n        DispatchEvent(\n            Event::CreateBubble(EventTypeNames::webkitvisibilitychange));\n      }\n      if (!frame_)\n        return;\n\n      frame_->Loader().SaveScrollAnchor();\n\n      DocumentLoader* document_loader =\n          frame_->Loader().GetProvisionalDocumentLoader();\n      load_event_progress_ = kUnloadEventInProgress;\n      Event* unload_event(Event::Create(EventTypeNames::unload));\n      if (document_loader &&\n          document_loader->GetTiming().UnloadEventStart().is_null() &&\n          document_loader->GetTiming().UnloadEventEnd().is_null()) {\n        DocumentLoadTiming& timing = document_loader->GetTiming();\n        DCHECK(!timing.NavigationStart().is_null());\n        const TimeTicks unload_event_start = CurrentTimeTicks();\n        timing.MarkUnloadEventStart(unload_event_start);\n        frame_->DomWindow()->DispatchEvent(unload_event, this);\n        const TimeTicks unload_event_end = CurrentTimeTicks();\n        DEFINE_STATIC_LOCAL(\n            CustomCountHistogram, unload_histogram,\n            (\"DocumentEventTiming.UnloadDuration\", 0, 10000000, 50));\n        unload_histogram.Count(\n            (unload_event_end - unload_event_start).InMicroseconds());\n        timing.MarkUnloadEventEnd(unload_event_end);\n      } else {\n        frame_->DomWindow()->DispatchEvent(unload_event, frame_->GetDocument());\n      }\n    }\n    load_event_progress_ = kUnloadEventHandled;\n  }\n\n  if (!frame_)\n    return;\n\n   bool keep_event_listeners =\n       frame_->Loader().GetProvisionalDocumentLoader() &&\n       frame_->ShouldReuseDefaultView(\n          frame_->Loader().GetProvisionalDocumentLoader()->Url());\n   if (!keep_event_listeners)\n     RemoveAllEventListenersRecursively();\n }\n", "target": 1, "flaw_line_index": "85"}
{"idx": 187299, "func": " PageCaptureCustomBindings::PageCaptureCustomBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"CreateBlob\",\n      base::Bind(&PageCaptureCustomBindings::CreateBlob,\n                 base::Unretained(this)));\n  RouteFunction(\"SendResponseAck\",\n      base::Bind(&PageCaptureCustomBindings::SendResponseAck,\n                 base::Unretained(this)));\n }\n", "target": 1, "flaw_line_index": "3,4,5,6,7,8"}
{"idx": 186734, "func": "void NetworkHandler::GetCookies(Maybe<Array<String>> protocol_urls,\n                                std::unique_ptr<GetCookiesCallback> callback) {\n  if (!host_) {\n    callback->sendFailure(Response::InternalError());\n    return;\n  }\n\n  std::vector<GURL> urls = ComputeCookieURLs(host_, protocol_urls);\n  scoped_refptr<CookieRetriever> retriever =\n      new CookieRetriever(std::move(callback));\n\n  BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(\n           &CookieRetriever::RetrieveCookiesOnIO, retriever,\n          base::Unretained(\n              process_->GetStoragePartition()->GetURLRequestContext()),\n          urls));\n }\n", "target": 1, "flaw_line_index": "16,17,18"}
{"idx": 8234, "func": "static void v9fs_setattr(void *opaque)\n{\n    int err = 0;\n    int32_t fid;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsIattr v9iattr;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"dI\", &fid, &v9iattr);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (v9iattr.valid & P9_ATTR_MODE) {\n        err = v9fs_co_chmod(pdu, &fidp->path, v9iattr.mode);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_ATIME | P9_ATTR_MTIME)) {\n        struct timespec times[2];\n        if (v9iattr.valid & P9_ATTR_ATIME) {\n            if (v9iattr.valid & P9_ATTR_ATIME_SET) {\n                times[0].tv_sec = v9iattr.atime_sec;\n                times[0].tv_nsec = v9iattr.atime_nsec;\n            } else {\n                times[0].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9iattr.valid & P9_ATTR_MTIME) {\n            if (v9iattr.valid & P9_ATTR_MTIME_SET) {\n                times[1].tv_sec = v9iattr.mtime_sec;\n                times[1].tv_nsec = v9iattr.mtime_nsec;\n            } else {\n                times[1].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if ((v9iattr.valid & (P9_ATTR_UID | P9_ATTR_GID)) ||\n        ((v9iattr.valid & P9_ATTR_CTIME)\n         && !((v9iattr.valid & P9_ATTR_MASK) & ~P9_ATTR_CTIME))) {\n        if (!(v9iattr.valid & P9_ATTR_UID)) {\n            v9iattr.uid = -1;\n        }\n        if (!(v9iattr.valid & P9_ATTR_GID)) {\n            v9iattr.gid = -1;\n        }\n        err = v9fs_co_chown(pdu, &fidp->path, v9iattr.uid,\n                            v9iattr.gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_SIZE)) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9iattr.size);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7983, "func": "static void send_ext_audio_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           pixman_image_get_width(vs->vd->server),\n                           pixman_image_get_height(vs->vd->server),\n                           VNC_ENCODING_AUDIO);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8077, "func": "void Gfx::doFunctionShFill(GfxFunctionShading *shading) {\n  double x0, y0, x1, y1;\n  GfxColor colors[4];\n\n  if (out->useShadedFills() &&\n      out->functionShadedFill(state, shading)) {\n    return;\n  }\n\n  shading->getDomain(&x0, &y0, &x1, &y1);\n  shading->getColor(x0, y0, &colors[0]);\n  shading->getColor(x0, y1, &colors[1]);\n  shading->getColor(x1, y0, &colors[2]);\n  shading->getColor(x1, y1, &colors[3]);\n  doFunctionShFill1(shading, x0, y0, x1, y1, colors, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186697, "func": "void RenderViewImpl::DidFocus() {\n  WebFrame* main_frame = webview() ? webview()->MainFrame() : nullptr;\n  bool is_processing_user_gesture =\n      WebUserGestureIndicator::IsProcessingUserGesture(\n          main_frame && main_frame->IsWebLocalFrame()\n              ? main_frame->ToWebLocalFrame()\n              : nullptr);\n   if (is_processing_user_gesture &&\n       !RenderThreadImpl::current()->layout_test_mode()) {\n     Send(new ViewHostMsg_Focus(GetRoutingID()));\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187092, "func": " VideoCaptureManager::~VideoCaptureManager() {\n  DCHECK(controllers_.empty());\n   DCHECK(device_start_request_queue_.empty());\n   if (screenlock_monitor_) {\n     screenlock_monitor_->RemoveObserver(this);\n  }\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187204, "func": "void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n    const std::vector<base::ProcessId>& pids,\n    GetVmRegionsForHeapProfilerCallback callback) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  uint64_t dump_guid = ++next_dump_id_;\n  std::unique_ptr<QueuedVmRegionRequest> request =\n      std::make_unique<QueuedVmRegionRequest>(dump_guid, std::move(callback));\n  in_progress_vm_region_requests_[dump_guid] = std::move(request);\n\n  std::vector<QueuedRequestDispatcher::ClientInfo> clients;\n  for (const auto& kv : clients_) {\n    auto client_identity = kv.second->identity;\n    const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);\n    clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);\n  }\n\n  QueuedVmRegionRequest* request_ptr =\n       in_progress_vm_region_requests_[dump_guid].get();\n   auto os_callback =\n       base::BindRepeating(&CoordinatorImpl::OnOSMemoryDumpForVMRegions,\n                          base::Unretained(this), dump_guid);\n   QueuedRequestDispatcher::SetUpAndDispatchVmRegionRequest(request_ptr, clients,\n                                                            pids, os_callback);\n   FinalizeVmRegionDumpIfAllManagersReplied(dump_guid);\n}\n", "target": 1, "flaw_line_index": "21"}
{"idx": 7575, "func": "static inline void cirrus_cursor_compute_yrange(CirrusVGAState *s)\n{\n    const uint8_t *src;\n    uint32_t content;\n    int y, y_min, y_max;\n\n    src = s->vga.vram_ptr + s->real_vram_size - 16 * 1024;\n    if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE) {\n        src += (s->vga.sr[0x13] & 0x3c) * 256;\n        y_min = 64;\n        y_max = -1;\n        for(y = 0; y < 64; y++) {\n            content = ((uint32_t *)src)[0] |\n                ((uint32_t *)src)[1] |\n                ((uint32_t *)src)[2] |\n                ((uint32_t *)src)[3];\n            if (content) {\n                if (y < y_min)\n                    y_min = y;\n                if (y > y_max)\n                    y_max = y;\n            }\n            src += 16;\n        }\n    } else {\n        src += (s->vga.sr[0x13] & 0x3f) * 256;\n        y_min = 32;\n        y_max = -1;\n        for(y = 0; y < 32; y++) {\n            content = ((uint32_t *)src)[0] |\n                ((uint32_t *)(src + 128))[0];\n            if (content) {\n                if (y < y_min)\n                    y_min = y;\n                if (y > y_max)\n                    y_max = y;\n            }\n            src += 4;\n        }\n    }\n    if (y_min > y_max) {\n        s->last_hw_cursor_y_start = 0;\n        s->last_hw_cursor_y_end = 0;\n    } else {\n        s->last_hw_cursor_y_start = y_min;\n        s->last_hw_cursor_y_end = y_max + 1;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7628, "func": "static int proxy_fstat(FsContext *fs_ctx, int fid_type,\n                       V9fsFidOpenState *fs, struct stat *stbuf)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n    return fstat(fd, stbuf);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8152, "func": "void Gfx::opSetLineJoin(Object args[], int numArgs) {\n  state->setLineJoin(args[0].getInt());\n  out->updateLineJoin(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7668, "func": "static int handle_fstat(FsContext *fs_ctx, int fid_type,\n                        V9fsFidOpenState *fs, struct stat *stbuf)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n    return fstat(fd, stbuf);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186942, "func": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n  DCHECK(delegate_);\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7460, "func": "QByteArray DBusHelperProxy::performAction(const QString &action, const QByteArray &callerID, QByteArray arguments)\n{\n    if (!responder) {\n        return ActionReply::NoResponderReply().serialized();\n    }\n\n    if (!m_currentAction.isEmpty()) {\n        return ActionReply::HelperBusyReply().serialized();\n    }\n         return ActionReply::HelperBusyReply().serialized();\n     }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186518, "func": "CreateDataReductionProxyChromeIOData(\n    Profile* profile,\n    const scoped_refptr<base::SingleThreadTaskRunner>& io_task_runner,\n    const scoped_refptr<base::SingleThreadTaskRunner>& ui_task_runner) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n   DCHECK(profile);\n   DCHECK(profile->GetPrefs());\n \n  data_reduction_proxy::DataReductionProxySettings*\n      data_reduction_proxy_settings =\n          DataReductionProxyChromeSettingsFactory::GetForBrowserContext(\n              profile);\n  bool enabled = data_reduction_proxy_settings &&\n                 data_reduction_proxy_settings->IsDataSaverEnabledByUser();\n \n   std::unique_ptr<data_reduction_proxy::DataReductionProxyIOData>\n       data_reduction_proxy_io_data(\n          new data_reduction_proxy::DataReductionProxyIOData(\n              DataReductionProxyChromeSettings::GetClient(),\n              profile->GetPrefs(), content::GetNetworkConnectionTracker(),\n              io_task_runner, ui_task_runner, enabled, GetUserAgent(),\n              version_info::GetChannelString(chrome::GetChannel())));\n\n  data_reduction_proxy_io_data->set_lofi_decider(\n      std::make_unique<data_reduction_proxy::ContentLoFiDecider>());\n  data_reduction_proxy_io_data->set_resource_type_provider(\n      std::make_unique<data_reduction_proxy::ContentResourceTypeProvider>());\n  data_reduction_proxy_io_data->set_lofi_ui_service(\n      std::make_unique<data_reduction_proxy::ContentLoFiUIService>(\n          ui_task_runner, base::Bind(&OnLoFiResponseReceivedOnUI)));\n\n  return data_reduction_proxy_io_data;\n}\n", "target": 1, "flaw_line_index": "9,10,11,12,13,14"}
{"idx": 187075, "func": "void MediaStreamDispatcherHost::BindRequest(\n     mojom::MediaStreamDispatcherHostRequest request) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  bindings_.AddBinding(this, std::move(request));\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 7696, "func": "static off_t handle_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return telldir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186952, "func": "bool AppCacheDatabase::FindCacheForGroup(int64_t group_id,\n                                         CacheRecord* record) {\n  DCHECK(record);\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, group_id, online_wildcard, update_time, cache_size\"\n       \"  FROM Caches WHERE group_id = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, group_id);\n\n  if (!statement.Step())\n    return false;\n\n  ReadCacheRecord(statement, record);\n  return true;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 187114, "func": " GLboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program) {\n  if (!program || isContextLost())\n     return 0;\n \n   return ContextGL()->IsProgram(program->Object());\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187058, "func": "   void ProcessStateChangesPlanB(WebRtcSetDescriptionObserver::States states) {\n     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kPlanB);\n     std::vector<RTCRtpReceiver*> removed_receivers;\n    for (auto it = handler_->rtp_receivers_.begin();\n         it != handler_->rtp_receivers_.end(); ++it) {\n      if (ReceiverWasRemoved(*(*it), states.transceiver_states))\n        removed_receivers.push_back(it->get());\n    }\n \n     for (auto& transceiver_state : states.transceiver_states) {\n      if (ReceiverWasAdded(transceiver_state)) {\n         handler_->OnAddReceiverPlanB(transceiver_state.MoveReceiverState());\n       }\n     }\n     for (auto* removed_receiver : removed_receivers) {\n      handler_->OnRemoveReceiverPlanB(RTCRtpReceiver::getId(\n          removed_receiver->state().webrtc_receiver().get()));\n     }\n   }\n", "target": 1, "flaw_line_index": "14,20"}
{"idx": 187317, "func": "exsltStrAlignFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n    xmlChar *str, *padding, *alignment, *ret;\n    int str_l, padding_l;\n\n    if ((nargs < 2) || (nargs > 3)) {\n\txmlXPathSetArityError(ctxt);\n\treturn;\n    }\n\n    if (nargs == 3)\n\talignment = xmlXPathPopString(ctxt);\n    else\n\talignment = NULL;\n\n    padding = xmlXPathPopString(ctxt);\n    str = xmlXPathPopString(ctxt);\n\n    str_l = xmlUTF8Strlen (str);\n    padding_l = xmlUTF8Strlen (padding);\n\n    if (str_l == padding_l) {\n\txmlXPathReturnString (ctxt, str);\n\txmlFree(padding);\n\txmlFree(alignment);\n\treturn;\n    }\n\n    if (str_l > padding_l) {\n\tret = xmlUTF8Strndup (str, padding_l);\n    } else {\n\tif (xmlStrEqual(alignment, (const xmlChar *) \"right\")) {\n\t    ret = xmlUTF8Strndup (padding, padding_l - str_l);\n\t    ret = xmlStrcat (ret, str);\n\t} else if (xmlStrEqual(alignment, (const xmlChar *) \"center\")) {\n\t    int left = (padding_l - str_l) / 2;\n\t    int right_start;\n\n\t    ret = xmlUTF8Strndup (padding, left);\n\t    ret = xmlStrcat (ret, str);\n\n\t    right_start = xmlUTF8Strsize (padding, left + str_l);\n\t    ret = xmlStrcat (ret, padding + right_start);\n \t} else {\n \t    int str_s;\n \n\t    str_s = xmlStrlen (str);\n \t    ret = xmlStrdup (str);\n \t    ret = xmlStrcat (ret, padding + str_s);\n \t}\n    }\n\n    xmlXPathReturnString (ctxt, ret);\n\n    xmlFree(str);\n    xmlFree(padding);\n    xmlFree(alignment);\n}\n", "target": 1, "flaw_line_index": "46"}
{"idx": 186710, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u0527\u0529] > h;\"\n                                    \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f] > n; [\u0167\u0442\u04ad] > t;\"\n                                   \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449] > w; [\u043c\u04ce] > m;\"\n                                    \"[\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; \u0493 > f; [\u04ab\u1004] > c;\"\n                                    \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                    \"\u04cf > l;\"\n #endif\n                                   \"\u0503  > d; [\u050d\u100c] > g; \u0d1f > s; \u1042 > j\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187032, "func": "DOMStorageContextWrapper::DOMStorageContextWrapper(\n     service_manager::Connector* connector,\n     const base::FilePath& profile_path,\n     const base::FilePath& local_partition_path,\n    storage::SpecialStoragePolicy* special_storage_policy) {\n  base::FilePath data_path;\n  if (!profile_path.empty())\n    data_path = profile_path.Append(local_partition_path);\n\n  scoped_refptr<base::SequencedTaskRunner> primary_sequence =\n      base::CreateSequencedTaskRunnerWithTraits(\n          {base::MayBlock(), base::TaskPriority::USER_BLOCKING,\n           base::TaskShutdownBehavior::BLOCK_SHUTDOWN});\n  scoped_refptr<base::SequencedTaskRunner> commit_sequence =\n      base::CreateSequencedTaskRunnerWithTraits(\n           {base::MayBlock(), base::TaskPriority::BEST_EFFORT,\n            base::TaskShutdownBehavior::BLOCK_SHUTDOWN});\n \n  legacy_localstorage_path_ =\n      data_path.empty() ? data_path\n                        : data_path.AppendASCII(kLocalStorageDirectory);\n  context_ = new DOMStorageContextImpl(\n      data_path.empty() ? data_path\n                        : data_path.AppendASCII(kSessionStorageDirectory),\n      special_storage_policy,\n      new DOMStorageWorkerPoolTaskRunner(std::move(primary_sequence),\n                                         std::move(commit_sequence)));\n  base::FilePath storage_dir;\n  if (!profile_path.empty())\n    storage_dir = local_partition_path.AppendASCII(kLocalStorageDirectory);\n  mojo_task_runner_ =\n       base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO});\n  mojo_state_ = new LocalStorageContextMojo(\n      mojo_task_runner_, connector, context_->task_runner(),\n      legacy_localstorage_path_, storage_dir, special_storage_policy);\n \n   if (base::FeatureList::IsEnabled(blink::features::kOnionSoupDOMStorage)) {\n    mojo_session_state_ = new SessionStorageContextMojo(\n        mojo_task_runner_, connector,\n #if defined(OS_ANDROID)\n        SessionStorageContextMojo::BackingMode::kClearDiskStateOnOpen,\n#else\n        profile_path.empty()\n            ? SessionStorageContextMojo::BackingMode::kNoDisk\n            : SessionStorageContextMojo::BackingMode::kRestoreDiskState,\n#endif\n         local_partition_path, std::string(kSessionStorageDirectory));\n   }\n \n   memory_pressure_listener_.reset(new base::MemoryPressureListener(\n       base::BindRepeating(&DOMStorageContextWrapper::OnMemoryPressure,\n                           base::Unretained(this))));\n}\n", "target": 1, "flaw_line_index": "19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,40,41"}
{"idx": 187070, "func": "bool PaymentRequest::SatisfiesSkipUIConstraints() const {\n  return base::FeatureList::IsEnabled(features::kWebPaymentsSingleAppUiSkip) &&\n         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&\n         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&\n         state()->available_instruments().size() == 1 &&\n         spec()->stringified_method_data().size() == 1 &&\n         !spec()->request_shipping() && !spec()->request_payer_name() &&\n         !spec()->request_payer_phone() &&\n         !spec()->request_payer_email()\n         && spec()->url_payment_method_identifiers().size() == 1;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12"}
{"idx": 186885, "func": "void BaseRenderingContext2D::setFillStyle(\n    const StringOrCanvasGradientOrCanvasPattern& style) {\n  DCHECK(!style.IsNull());\n  ValidateStateStack();\n  String color_string;\n  CanvasStyle* canvas_style = nullptr;\n  if (style.IsString()) {\n    color_string = style.GetAsString();\n    if (color_string == GetState().UnparsedFillColor())\n      return;\n    Color parsed_color = 0;\n    if (!ParseColorOrCurrentColor(parsed_color, color_string))\n      return;\n    if (GetState().FillStyle()->IsEquivalentRGBA(parsed_color.Rgb())) {\n      ModifiableState().SetUnparsedFillColor(color_string);\n      return;\n    }\n    canvas_style = CanvasStyle::CreateFromRGBA(parsed_color.Rgb());\n  } else if (style.IsCanvasGradient()) {\n    canvas_style = CanvasStyle::CreateFromGradient(style.GetAsCanvasGradient());\n   } else if (style.IsCanvasPattern()) {\n     CanvasPattern* canvas_pattern = style.GetAsCanvasPattern();\n \n    if (OriginClean() && !canvas_pattern->OriginClean()) {\n      SetOriginTainted();\n      ClearResolvedFilters();\n     }\n     if (canvas_pattern->GetPattern()->IsTextureBacked())\n       DisableDeferral(kDisableDeferralReasonUsingTextureBackedPattern);\n    canvas_style = CanvasStyle::CreateFromPattern(canvas_pattern);\n  }\n\n  DCHECK(canvas_style);\n  ModifiableState().SetFillStyle(canvas_style);\n  ModifiableState().SetUnparsedFillColor(color_string);\n  ModifiableState().ClearResolvedFilter();\n}\n", "target": 1, "flaw_line_index": "24,25,26"}
{"idx": 8078, "func": "void Gfx::doFunctionShFill1(GfxFunctionShading *shading,\n\t\t\t    double x0, double y0,\n\t\t\t    double x1, double y1,\n\t\t\t    GfxColor *colors, int depth) {\n  GfxColor fillColor;\n  GfxColor color0M, color1M, colorM0, colorM1, colorMM;\n  GfxColor colors2[4];\n  double *matrix;\n  double xM, yM;\n  int nComps, i, j;\n\n  nComps = shading->getColorSpace()->getNComps();\n  matrix = shading->getMatrix();\n\n  for (i = 0; i < 4; ++i) {\n    for (j = 0; j < nComps; ++j) {\n      if (abs(colors[i].c[j] - colors[(i+1)&3].c[j]) > functionColorDelta) {\n\tbreak;\n      }\n    }\n    if (j < nComps) {\n      break;\n    }\n  }\n\n  xM = 0.5 * (x0 + x1);\n  yM = 0.5 * (y0 + y1);\n\n  if ((i == 4 && depth > 0) || depth == functionMaxDepth) {\n\n    shading->getColor(xM, yM, &fillColor);\n    state->setFillColor(&fillColor);\n    out->updateFillColor(state);\n\n    state->moveTo(x0 * matrix[0] + y0 * matrix[2] + matrix[4],\n\t\t  x0 * matrix[1] + y0 * matrix[3] + matrix[5]);\n    state->lineTo(x1 * matrix[0] + y0 * matrix[2] + matrix[4],\n\t\t  x1 * matrix[1] + y0 * matrix[3] + matrix[5]);\n    state->lineTo(x1 * matrix[0] + y1 * matrix[2] + matrix[4],\n\t\t  x1 * matrix[1] + y1 * matrix[3] + matrix[5]);\n    state->lineTo(x0 * matrix[0] + y1 * matrix[2] + matrix[4],\n\t\t  x0 * matrix[1] + y1 * matrix[3] + matrix[5]);\n    state->closePath();\n    if (!contentIsHidden())\n      out->fill(state);\n    state->clearPath();\n\n  } else {\n\n\n    shading->getColor(x0, yM, &color0M);\n    shading->getColor(x1, yM, &color1M);\n    shading->getColor(xM, y0, &colorM0);\n    shading->getColor(xM, y1, &colorM1);\n    shading->getColor(xM, yM, &colorMM);\n\n    colors2[0] = colors[0];\n    colors2[1] = color0M;\n    colors2[2] = colorM0;\n    colors2[3] = colorMM;\n    doFunctionShFill1(shading, x0, y0, xM, yM, colors2, depth + 1);\n    \n    colors2[0] = color0M;\n    colors2[1] = colors[1];\n    colors2[2] = colorMM;\n    colors2[3] = colorM1;\n    doFunctionShFill1(shading, x0, yM, xM, y1, colors2, depth + 1);\n    \n    colors2[0] = colorM0;\n    colors2[1] = colorMM;\n    colors2[2] = colors[2];\n    colors2[3] = color1M;\n    doFunctionShFill1(shading, xM, y0, x1, yM, colors2, depth + 1);\n\n    colors2[0] = colorMM;\n    colors2[1] = colorM1;\n    colors2[2] = color1M;\n    colors2[3] = colors[3];\n    doFunctionShFill1(shading, xM, yM, x1, y1, colors2, depth + 1);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7563, "func": "static int cirrus_bitblt_cputovideo(CirrusVGAState * s)\n{\n    int w;\n\n    s->cirrus_blt_mode &= ~CIRRUS_BLTMODE_MEMSYSSRC;\n    s->cirrus_srcptr = &s->cirrus_bltbuf[0];\n    s->cirrus_srcptr_end = &s->cirrus_bltbuf[0];\n\n    if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n\tif (s->cirrus_blt_mode & CIRRUS_BLTMODE_COLOREXPAND) {\n\t    s->cirrus_blt_srcpitch = 8;\n\t} else {\n\t    s->cirrus_blt_srcpitch = 8 * 8 * s->cirrus_blt_pixelwidth;\n\t}\n\ts->cirrus_srccounter = s->cirrus_blt_srcpitch;\n    } else {\n\tif (s->cirrus_blt_mode & CIRRUS_BLTMODE_COLOREXPAND) {\n            w = s->cirrus_blt_width / s->cirrus_blt_pixelwidth;\n            if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_DWORDGRANULARITY)\n                s->cirrus_blt_srcpitch = ((w + 31) >> 5);\n            else\n                s->cirrus_blt_srcpitch = ((w + 7) >> 3);\n\t} else {\n\t    s->cirrus_blt_srcpitch = (s->cirrus_blt_width + 3) & ~3;\n\t}\n        s->cirrus_srccounter = s->cirrus_blt_srcpitch * s->cirrus_blt_height;\n    }\n    s->cirrus_srcptr = s->cirrus_bltbuf;\n    s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n    cirrus_update_memory_access(s);\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7979, "func": "static uint16_t read_u16(uint8_t *data, size_t offset)\n{\n    return ((data[offset] & 0xFF) << 8) | (data[offset + 1] & 0xFF);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186955, "func": "bool AppCacheDatabase::FindEntry(int64_t cache_id,\n                                 const GURL& url,\n                                 EntryRecord* record) {\n  DCHECK(record);\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"\n       \"  WHERE cache_id = ? AND url = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, cache_id);\n  statement.BindString(1, url.spec());\n\n  if (!statement.Step())\n    return false;\n\n  ReadEntryRecord(statement, record);\n  DCHECK(record->cache_id == cache_id);\n  DCHECK(record->url == url);\n  return true;\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 186864, "func": "void DocumentModuleScriptFetcher::NotifyFinished(Resource* resource) {\n  ClearResource();\n\n  ScriptResource* script_resource = ToScriptResource(resource);\n\n  HeapVector<Member<ConsoleMessage>> error_messages;\n  if (!WasModuleLoadSuccessful(script_resource, &error_messages)) {\n    Finalize(WTF::nullopt, error_messages);\n    return;\n  }\n\n   ModuleScriptCreationParams params(\n       script_resource->GetResponse().Url(), script_resource->SourceText(),\n       script_resource->GetResourceRequest().GetFetchCredentialsMode(),\n      script_resource->CalculateAccessControlStatus());\n   Finalize(params, error_messages);\n }\n", "target": 1, "flaw_line_index": "15"}
{"idx": 7577, "func": "static void cirrus_cursor_invalidate(VGACommonState *s1)\n{\n    CirrusVGAState *s = container_of(s1, CirrusVGAState, vga);\n    int size;\n\n    if (!(s->vga.sr[0x12] & CIRRUS_CURSOR_SHOW)) {\n        size = 0;\n    } else {\n        if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE)\n            size = 64;\n        else\n            size = 32;\n    }\n    if (s->last_hw_cursor_size != size ||\n        s->last_hw_cursor_x != s->hw_cursor_x ||\n        s->last_hw_cursor_y != s->hw_cursor_y) {\n\n        invalidate_cursor1(s);\n\n        s->last_hw_cursor_size = size;\n        s->last_hw_cursor_x = s->hw_cursor_x;\n        s->last_hw_cursor_y = s->hw_cursor_y;\n        cirrus_cursor_compute_yrange(s);\n        invalidate_cursor1(s);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186401, "func": "InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n                                     InputHandlerProxyClient* client,\n                                     bool force_input_to_main_thread)\n    : client_(client),\n      input_handler_(input_handler),\n      synchronous_input_handler_(nullptr),\n      allow_root_animate_(true),\n#if DCHECK_IS_ON()\n      expect_scroll_update_end_(false),\n#endif\n      gesture_scroll_on_impl_thread_(false),\n      scroll_sequence_ignored_(false),\n      smooth_scroll_enabled_(false),\n      touch_result_(kEventDispositionUndefined),\n      mouse_wheel_result_(kEventDispositionUndefined),\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n          base::FeatureList::IsEnabled(features::kCompositorTouchAction)),\n      force_input_to_main_thread_(force_input_to_main_thread) {\n  DCHECK(client);\n  input_handler_->BindToClient(this);\n  cc::ScrollElasticityHelper* scroll_elasticity_helper =\n      input_handler_->CreateScrollElasticityHelper();\n  if (scroll_elasticity_helper) {\n    scroll_elasticity_controller_.reset(\n        new InputScrollElasticityController(scroll_elasticity_helper));\n  }\n  compositor_event_queue_ = std::make_unique<CompositorThreadEventQueue>();\n  scroll_predictor_ = std::make_unique<ScrollPredictor>(\n      base::FeatureList::IsEnabled(features::kResamplingScrollEvents));\n\n  if (base::FeatureList::IsEnabled(features::kSkipTouchEventFilter) &&\n      GetFieldTrialParamValueByFeature(\n          features::kSkipTouchEventFilter,\n          features::kSkipTouchEventFilterFilteringProcessParamName) ==\n          features::\n              kSkipTouchEventFilterFilteringProcessParamValueBrowserAndRenderer) {\n    skip_touch_filter_discrete_ = true;\n    if (GetFieldTrialParamValueByFeature(\n            features::kSkipTouchEventFilter,\n            features::kSkipTouchEventFilterTypeParamName) ==\n        features::kSkipTouchEventFilterTypeParamValueAll) {\n      skip_touch_filter_all_ = true;\n    }\n  }\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 187315, "func": "exsltFuncFunctionFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n    xmlXPathObjectPtr oldResult, ret;\n    exsltFuncData *data;\n    exsltFuncFunctionData *func;\n    xmlNodePtr paramNode, oldInsert, fake;\n    int oldBase;\n    xsltStackElemPtr params = NULL, param;\n    xsltTransformContextPtr tctxt = xsltXPathGetTransformContext(ctxt);\n    int i, notSet;\n    struct objChain {\n\tstruct objChain *next;\n\txmlXPathObjectPtr obj;\n    };\n    struct objChain\t*savedObjChain = NULL, *savedObj;\n\n    data = (exsltFuncData *) xsltGetExtData (tctxt,\n\t\t\t\t\t     EXSLT_FUNCTIONS_NAMESPACE);\n    oldResult = data->result;\n    data->result = NULL;\n\n     func = (exsltFuncFunctionData*) xmlHashLookup2 (data->funcs,\n \t\t\t\t\t\t    ctxt->context->functionURI,\n \t\t\t\t\t\t    ctxt->context->function);\n \n    if (nargs > func->nargs) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"{%s}%s: called with too many arguments\\n\",\n\t\t\t ctxt->context->functionURI, ctxt->context->function);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    if (func->content != NULL) {\n\tparamNode = func->content->prev;\n    }\n    else\n\tparamNode = NULL;\n    if ((paramNode == NULL) && (func->nargs != 0)) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"exsltFuncFunctionFunction: nargs != 0 and \"\n\t\t\t \"param == NULL\\n\");\n\treturn;\n    }\n    if (tctxt->funcLevel > MAX_FUNC_RECURSION) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"{%s}%s: detected a recursion\\n\",\n\t\t\t ctxt->context->functionURI, ctxt->context->function);\n\tctxt->error = XPATH_MEMORY_ERROR;\n\treturn;\n    }\n    tctxt->funcLevel++;\n\n    oldBase = tctxt->varsBase;\n    tctxt->varsBase = tctxt->varsNr;\n    if (paramNode != NULL) {\n\tfor (i = 0; i < nargs; i++) {\n\t    savedObj = xmlMalloc(sizeof(struct objChain));\n\t    savedObj->next = savedObjChain;\n\t    savedObj->obj = valuePop(ctxt);\n\t    savedObjChain = savedObj;\n\t}\n\n\tfor (i = 1; i <= func->nargs; i++) {\n\t    if (paramNode->prev == NULL)\n\t        break;\n\t    paramNode = paramNode->prev;\n\t}\n\tnotSet = func->nargs - nargs;\n\tfor (; i > 0; i--) {\n\t    param = xsltParseStylesheetCallerParam (tctxt, paramNode);\n\t    if (i > notSet) {\t\n\t\tparam->computed = 1;\n\t\tif (param->value != NULL)\n\t\t    xmlXPathFreeObject(param->value);\n\t\tsavedObj = savedObjChain;\t\n\t\tparam->value = savedObj->obj;\n\t\tsavedObjChain = savedObjChain->next;\n\t\txmlFree(savedObj);\n\t    }\n\t    xsltLocalVariablePush(tctxt, param, -1);\n\t    param->next = params;\n\t    params = param;\n\t    paramNode = paramNode->next;\n\t}\n    }\n    fake = xmlNewDocNode(tctxt->output, NULL,\n\t\t\t (const xmlChar *)\"fake\", NULL);\n    oldInsert = tctxt->insert;\n    tctxt->insert = fake;\n    xsltApplyOneTemplate (tctxt, xmlXPathGetContextNode(ctxt),\n\t\t\t  func->content, NULL, NULL);\n    xsltLocalVariablePop(tctxt, tctxt->varsBase, -2);\n    tctxt->insert = oldInsert;\n    tctxt->varsBase = oldBase;\t\n    if (params != NULL)\n\txsltFreeStackElemList(params);\n\n    if (data->error != 0)\n\tgoto error;\n\n    if (data->result != NULL) {\n\tret = data->result;\n    } else\n\tret = xmlXPathNewCString(\"\");\n\n    data->result = oldResult;\n\n    if (fake->children != NULL) {\n#ifdef LIBXML_DEBUG_ENABLED\n\txmlDebugDumpNode (stderr, fake, 1);\n#endif\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"{%s}%s: cannot write to result tree while \"\n\t\t\t \"executing a function\\n\",\n\t\t\t ctxt->context->functionURI, ctxt->context->function);\n\txmlFreeNode(fake);\n\tgoto error;\n    }\n    xmlFreeNode(fake);\n    valuePush(ctxt, ret);\n\nerror:\n    xsltExtensionInstructionResultFinalize(tctxt);\n    tctxt->funcLevel--;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8144, "func": "void Gfx::opSetFillColorN(Object args[], int numArgs) {\n  GfxColor color;\n  GfxPattern *pattern;\n  int i;\n\n  if (state->getFillColorSpace()->getMode() == csPattern) {\n    if (numArgs > 1) {\n      if (!((GfxPatternColorSpace *)state->getFillColorSpace())->getUnder() ||\n\t  numArgs - 1 != ((GfxPatternColorSpace *)state->getFillColorSpace())\n\t                     ->getUnder()->getNComps()) {\n\terror(getPos(), \"Incorrect number of arguments in 'scn' command\");\n\treturn;\n      }\n      for (i = 0; i < numArgs - 1 && i < gfxColorMaxComps; ++i) {\n\tif (args[i].isNum()) {\n\t  color.c[i] = dblToCol(args[i].getNum());\n\t}\n      }\n      state->setFillColor(&color);\n      out->updateFillColor(state);\n    }\n    if (args[numArgs-1].isName() &&\n\t(pattern = res->lookupPattern(args[numArgs-1].getName(), this))) {\n      state->setFillPattern(pattern);\n    }\n\n  } else {\n    if (numArgs != state->getFillColorSpace()->getNComps()) {\n      error(getPos(), \"Incorrect number of arguments in 'scn' command\");\n      return;\n    }\n    state->setFillPattern(NULL);\n    for (i = 0; i < numArgs && i < gfxColorMaxComps; ++i) {\n      if (args[i].isNum()) {\n\tcolor.c[i] = dblToCol(args[i].getNum());\n      }\n    }\n    state->setFillColor(&color);\n    out->updateFillColor(state);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187266, "func": " void DevToolsAgentHostImpl::ForceAttachClient(DevToolsAgentHostClient* client) {\n   if (SessionByClient(client))\n     return;\n   scoped_refptr<DevToolsAgentHostImpl> protect(this);\n   if (!sessions_.empty())\n    ForceDetachAllClients();\n   DCHECK(sessions_.empty());\n  InnerAttachClient(client);\n }\n", "target": 1, "flaw_line_index": "6,8"}
{"idx": 8002, "func": "long vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n{\n    long ret;\n#ifdef CONFIG_VNC_TLS\n    if (vs->tls.session) {\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n    } else {\n#ifdef CONFIG_VNC_WS\n        if (vs->ws_tls.session) {\n            ret = vnc_client_write_tls(&vs->ws_tls.session, data, datalen);\n        } else\n#endif \n#endif \n        {\n            ret = send(vs->csock, (const void *)data, datalen, 0);\n        }\n#ifdef CONFIG_VNC_TLS\n    }\n#endif \n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, socket_error());\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7842, "func": "uint64_t dup_mig_pages_transferred(void)\n{\n    return acct_info.dup_pages;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186676, "func": "void BackendIO::ExecuteBackendOperation() {\n  switch (operation_) {\n    case OP_INIT:\n      result_ = backend_->SyncInit();\n      break;\n    case OP_OPEN: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncOpenEntry(key_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_CREATE: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncCreateEntry(key_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_DOOM:\n      result_ = backend_->SyncDoomEntry(key_);\n      break;\n    case OP_DOOM_ALL:\n      result_ = backend_->SyncDoomAllEntries();\n      break;\n    case OP_DOOM_BETWEEN:\n      result_ = backend_->SyncDoomEntriesBetween(initial_time_, end_time_);\n      break;\n    case OP_DOOM_SINCE:\n      result_ = backend_->SyncDoomEntriesSince(initial_time_);\n      break;\n    case OP_SIZE_ALL:\n      result_ = backend_->SyncCalculateSizeOfAllEntries();\n      break;\n    case OP_OPEN_NEXT: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncOpenNextEntry(iterator_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_END_ENUMERATION:\n      backend_->SyncEndEnumeration(std::move(scoped_iterator_));\n      result_ = net::OK;\n      break;\n    case OP_ON_EXTERNAL_CACHE_HIT:\n      backend_->SyncOnExternalCacheHit(key_);\n      result_ = net::OK;\n      break;\n    case OP_CLOSE_ENTRY:\n      entry_->Release();\n      result_ = net::OK;\n      break;\n    case OP_DOOM_ENTRY:\n      entry_->DoomImpl();\n      result_ = net::OK;\n      break;\n    case OP_FLUSH_QUEUE:\n      result_ = net::OK;\n      break;\n    case OP_RUN_TASK:\n      task_.Run();\n      result_ = net::OK;\n      break;\n    default:\n      NOTREACHED() << \"Invalid Operation\";\n      result_ = net::ERR_UNEXPECTED;\n   }\n   DCHECK_NE(net::ERR_IO_PENDING, result_);\n   NotifyController();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8187, "func": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n{\n    g_free(s->ctx.fs_root);\n    g_free(s->tag);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186970, "func": "  void Verify_MakeGroupObsolete() {\n    EXPECT_TRUE(delegate()->obsoleted_success_);\n    EXPECT_EQ(group_.get(), delegate()->obsoleted_group_.get());\n    EXPECT_TRUE(group_->is_obsolete());\n    EXPECT_TRUE(storage()->usage_map_.empty());\n\n    AppCacheDatabase::GroupRecord group_record;\n    AppCacheDatabase::CacheRecord cache_record;\n    EXPECT_FALSE(database()->FindGroup(1, &group_record));\n    EXPECT_FALSE(database()->FindCache(1, &cache_record));\n\n    std::vector<AppCacheDatabase::EntryRecord> entry_records;\n    database()->FindEntriesForCache(1, &entry_records);\n    EXPECT_TRUE(entry_records.empty());\n    std::vector<AppCacheDatabase::NamespaceRecord> intercept_records;\n    std::vector<AppCacheDatabase::NamespaceRecord> fallback_records;\n    database()->FindNamespacesForCache(1, &intercept_records,\n                                       &fallback_records);\n    EXPECT_TRUE(fallback_records.empty());\n    std::vector<AppCacheDatabase::OnlineWhiteListRecord> whitelist_records;\n    database()->FindOnlineWhiteListForCache(1, &whitelist_records);\n    EXPECT_TRUE(whitelist_records.empty());\n\n     EXPECT_TRUE(storage()->usage_map_.empty());\n     EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);\n     EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);\n    EXPECT_EQ(-kDefaultEntrySize, mock_quota_manager_proxy_->last_delta_);\n \n     TestFinished();\n   }\n", "target": 1, "flaw_line_index": "30"}
{"idx": 7989, "func": "static const char *vnc_auth_name(VncDisplay *vd) {\n    switch (vd->auth) {\n    case VNC_AUTH_INVALID:\n        return \"invalid\";\n    case VNC_AUTH_NONE:\n        return \"none\";\n    case VNC_AUTH_VNC:\n        return \"vnc\";\n    case VNC_AUTH_RA2:\n        return \"ra2\";\n    case VNC_AUTH_RA2NE:\n        return \"ra2ne\";\n    case VNC_AUTH_TIGHT:\n        return \"tight\";\n    case VNC_AUTH_ULTRA:\n        return \"ultra\";\n    case VNC_AUTH_TLS:\n        return \"tls\";\n    case VNC_AUTH_VENCRYPT:\n#ifdef CONFIG_VNC_TLS\n        switch (vd->subauth) {\n        case VNC_AUTH_VENCRYPT_PLAIN:\n            return \"vencrypt+plain\";\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n            return \"vencrypt+tls+none\";\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n            return \"vencrypt+tls+vnc\";\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n            return \"vencrypt+tls+plain\";\n        case VNC_AUTH_VENCRYPT_X509NONE:\n            return \"vencrypt+x509+none\";\n        case VNC_AUTH_VENCRYPT_X509VNC:\n            return \"vencrypt+x509+vnc\";\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n            return \"vencrypt+x509+plain\";\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n            return \"vencrypt+tls+sasl\";\n        case VNC_AUTH_VENCRYPT_X509SASL:\n            return \"vencrypt+x509+sasl\";\n        default:\n            return \"vencrypt\";\n        }\n#else\n        return \"vencrypt\";\n#endif\n    case VNC_AUTH_SASL:\n        return \"sasl\";\n    }\n    return \"unknown\";\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8196, "func": "static void coroutine_fn v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n    offset = 7;\n    err = pdu_marshal(pdu, offset, \"d\", total);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186733, "func": " void NetworkHandler::GetAllCookies(\n     std::unique_ptr<GetAllCookiesCallback> callback) {\n  if (!process_) {\n     callback->sendFailure(Response::InternalError());\n     return;\n   }\n\n  scoped_refptr<CookieRetriever> retriever =\n      new CookieRetriever(std::move(callback));\n\n  BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(\n           &CookieRetriever::RetrieveAllCookiesOnIO, retriever,\n          base::Unretained(\n              process_->GetStoragePartition()->GetURLRequestContext())));\n }\n", "target": 1, "flaw_line_index": "3,15,16"}
{"idx": 186827, "func": "void ClientDiscardableSharedMemoryManager::AllocateCompletedOnIO(\n     base::SharedMemoryHandle* handle,\n     base::ScopedClosureRunner closure_runner,\n     mojo::ScopedSharedBufferHandle mojo_handle) {\n  size_t memory_size = 0;\n  bool read_only = false;\n   if (!mojo_handle.is_valid())\n     return;\n   auto result = mojo::UnwrapSharedMemoryHandle(std::move(mojo_handle), handle,\n                                               &memory_size, &read_only);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n }\n", "target": 1, "flaw_line_index": "5,6,10"}
{"idx": 8225, "func": "static void v9fs_op_not_supp(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    pdu_complete(pdu, -EOPNOTSUPP);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187280, "func": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n    do {\n      entry = entry->next();\n    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);\n \n     if (!to_doom->InUse())\n       to_doom->Doom();\n  }\n}\n", "target": 1, "flaw_line_index": "10,11,12,13,14"}
{"idx": 187077, "func": "void MediaStreamDispatcherHost::CancelRequest(int page_request_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   media_stream_manager_->CancelRequest(render_process_id_, render_frame_id_,\n                                       page_request_id);\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 186563, "func": " void AcceleratedStaticBitmapImage::Abandon() {\n   texture_holder_->Abandon();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186477, "func": "GURL DecorateFrontendURL(const GURL& base_url) {\n  std::string frontend_url = base_url.spec();\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\") +\n      \"dockSide=undocked\"); \n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))\n     url_string += \"&experiments=true\";\n \n   if (command_line->HasSwitch(switches::kDevToolsFlags)) {\n    std::string flags = command_line->GetSwitchValueASCII(\n                            switches::kDevToolsFlags);\n    flags = net::EscapeQueryParamValue(flags, false);\n    url_string += \"&flags=\" + flags;\n   }\n \n #if defined(DEBUG_DEVTOOLS)\n  url_string += \"&debugFrontend=true\";\n#endif  \n\n  return GURL(url_string);\n}\n", "target": 1, "flaw_line_index": "12,13,14,15"}
{"idx": 186946, "func": " bool AppCache::AddOrModifyEntry(const GURL& url, const AppCacheEntry& entry) {\n   std::pair<EntryMap::iterator, bool> ret =\n       entries_.insert(EntryMap::value_type(url, entry));\n \n  if (!ret.second)\n     ret.first->second.add_types(entry.types());\n  else\n     cache_size_ += entry.response_size();  \n   return ret.second;\n }\n", "target": 1, "flaw_line_index": "6,8"}
{"idx": 186472, "func": " static sk_sp<SkImage> newSkImageFromRaster(const SkImageInfo& info,\n                                            PassRefPtr<Uint8Array> imagePixels,\n                                           size_t imageRowBytes) {\n   SkPixmap pixmap(info, imagePixels->data(), imageRowBytes);\n   return SkImage::MakeFromRaster(pixmap,\n                                  [](const void*, void* pixels) {\n                                   static_cast<Uint8Array*>(pixels)->deref();\n                                 },\n                                 imagePixels.leakRef());\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186612, "func": " base::string16 GetAppForProtocolUsingAssocQuery(const GURL& url) {\n  base::string16 url_scheme = base::ASCIIToUTF16(url.scheme());\n  if (url_scheme.empty())\n     return base::string16();\n \n   wchar_t out_buffer[1024];\n   DWORD buffer_size = arraysize(out_buffer);\n  HRESULT hr = AssocQueryString(ASSOCF_IS_PROTOCOL,\n                                ASSOCSTR_FRIENDLYAPPNAME,\n                                url_scheme.c_str(),\n                                NULL,\n                                out_buffer,\n                                &buffer_size);\n   if (FAILED(hr)) {\n     DLOG(WARNING) << \"AssocQueryString failed!\";\n     return base::string16();\n  }\n  return base::string16(out_buffer);\n }\n", "target": 1, "flaw_line_index": "2,3,4,13,14,15,16,17,18"}
{"idx": 186737, "func": " void NetworkHandler::SetCookie(const std::string& name,\n                               const std::string& value,\n                               Maybe<std::string> url,\n                               Maybe<std::string> domain,\n                               Maybe<std::string> path,\n                               Maybe<bool> secure,\n                               Maybe<bool> http_only,\n                                Maybe<std::string> same_site,\n                                Maybe<double> expires,\n                                std::unique_ptr<SetCookieCallback> callback) {\n  if (!process_) {\n     callback->sendFailure(Response::InternalError());\n     return;\n   }\n\n  if (!url.isJust() && !domain.isJust()) {\n    callback->sendFailure(Response::InvalidParams(\n        \"At least one of the url and domain needs to be specified\"));\n  }\n\n  BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(\n           &SetCookieOnIO,\n          base::Unretained(\n              process_->GetStoragePartition()->GetURLRequestContext()),\n          name, value, url.fromMaybe(\"\"), domain.fromMaybe(\"\"),\n          path.fromMaybe(\"\"), secure.fromMaybe(false),\n          http_only.fromMaybe(false), same_site.fromMaybe(\"\"),\n          expires.fromMaybe(-1),\n           base::BindOnce(&CookieSetOnIO, std::move(callback))));\n }\n", "target": 1, "flaw_line_index": "11,25,26,27,28,29,30"}
{"idx": 186852, "func": "    memory_handle(const media::BitstreamBuffer& input) {\n  base::SharedMemoryHandle input_handle =\n      base::SharedMemory::DuplicateHandle(input.handle());\n  if (!base::SharedMemory::IsHandleValid(input_handle)) {\n     DLOG(ERROR) << \"Failed to duplicate handle of BitstreamBuffer\";\n     return mojo::ScopedSharedBufferHandle();\n   }\n  return mojo::WrapSharedMemoryHandle(input_handle, input.size(),\n                                      true \n);\n }\n", "target": 1, "flaw_line_index": "8,10"}
{"idx": 8285, "func": "Time XRRConfigTimes (XRRScreenConfiguration *config, Time *config_timestamp)\n{\n    *config_timestamp = config->config_timestamp;\n    return config->timestamp;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187152, "func": "gfx::Insets ScrollableShelfView::CalculatePaddingForDisplayCentering() const {\n  const int icons_size = shelf_view_->GetSizeOfAppIcons(\n      shelf_view_->number_of_visible_apps(), false);\n  const gfx::Rect display_bounds =\n      screen_util::GetDisplayBoundsWithShelf(GetWidget()->GetNativeWindow());\n  const int display_size_primary = GetShelf()->PrimaryAxisValue(\n      display_bounds.width(), display_bounds.height());\n  const int gap = (display_size_primary - icons_size) / 2;\n \n   const gfx::Rect screen_bounds = GetBoundsInScreen();\n  const int left_padding = gap - GetShelf()->PrimaryAxisValue(\n                                     screen_bounds.x() - display_bounds.x(),\n                                     screen_bounds.y() - display_bounds.y());\n  const int right_padding =\n       gap - GetShelf()->PrimaryAxisValue(\n                 display_bounds.right() - screen_bounds.right(),\n                 display_bounds.bottom() - screen_bounds.bottom());\n \n  return gfx::Insets(0, left_padding, 0, right_padding);\n }\n", "target": 1, "flaw_line_index": "12,13,14,15,20"}
{"idx": 186891, "func": " void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n  RequestGlobalMemoryDump(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n }\n", "target": 1, "flaw_line_index": "3,5"}
{"idx": 187247, "func": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\",\n                                \"navigation\",\n                                time_origin,\n                                server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}\n", "target": 1, "flaw_line_index": "6,7,8,9"}
{"idx": 187288, "func": "NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()\n     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,\n                                 kInitialMedianInMs),\n       outstanding_recomputation_timer_(\n          base::MakeUnique<base::Timer>(false \n,\n                                         false \n)),\n       tick_clock_(new base::DefaultTickClock()),\n       weak_ptr_factory_(this) {}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187068, "func": "PaymentRequest::PaymentRequest(\n    content::RenderFrameHost* render_frame_host,\n    content::WebContents* web_contents,\n    std::unique_ptr<ContentPaymentRequestDelegate> delegate,\n    PaymentRequestWebContentsManager* manager,\n    PaymentRequestDisplayManager* display_manager,\n     mojo::InterfaceRequest<mojom::PaymentRequest> request,\n     ObserverForTest* observer_for_testing)\n     : web_contents_(web_contents),\n       delegate_(std::move(delegate)),\n       manager_(manager),\n       display_manager_(display_manager),\n      display_handle_(nullptr),\n      binding_(this, std::move(request)),\n      top_level_origin_(url_formatter::FormatUrlForSecurityDisplay(\n          web_contents_->GetLastCommittedURL())),\n      frame_origin_(url_formatter::FormatUrlForSecurityDisplay(\n          render_frame_host->GetLastCommittedURL())),\n      observer_for_testing_(observer_for_testing),\n      journey_logger_(delegate_->IsIncognito(),\n                      ukm::GetSourceIdForWebContentsDocument(web_contents)),\n      weak_ptr_factory_(this) {\n  binding_.set_connection_error_handler(base::BindOnce(\n      &PaymentRequest::OnConnectionTerminated, weak_ptr_factory_.GetWeakPtr()));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7963, "func": "static int find_and_clear_dirty_height(struct VncState *vs,\n                                       int y, int last_x, int x, int height)\n{\n    int h;\n\n    for (h = 1; h < (height - y); h++) {\n        if (!test_bit(last_x, vs->dirty[y + h])) {\n            break;\n        }\n        bitmap_clear(vs->dirty[y + h], last_x, x - last_x);\n    }\n\n    return h;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7626, "func": "static int proxy_close(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return close(fs->fd);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186336, "func": " void PageRequestSummary::UpdateOrAddToOrigins(\n    const GURL& url,\n     const content::mojom::CommonNetworkInfoPtr& network_info) {\n  GURL origin = url.GetOrigin();\n  if (!origin.is_valid())\n     return;\n \n   auto it = origins.find(origin);\n  if (it == origins.end()) {\n    OriginRequestSummary summary;\n    summary.origin = origin;\n    summary.first_occurrence = origins.size();\n    it = origins.insert({origin, summary}).first;\n  }\n\n  it->second.always_access_network |= network_info->always_access_network;\n  it->second.accessed_network |= network_info->network_accessed;\n}\n", "target": 1, "flaw_line_index": "2,4,5"}
{"idx": 186624, "func": " InputImeEventRouter* InputImeEventRouterFactory::GetRouter(Profile* profile) {\n   if (!profile)\n     return nullptr;\n   InputImeEventRouter* router = router_map_[profile];\n   if (!router) {\n    router = new InputImeEventRouter(profile);\n     router_map_[profile] = router;\n   }\n   return router;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8052, "func": "static int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n{\n    int width = pixman_image_get_width(vd->guest.fb);\n    int height = pixman_image_get_height(vd->guest.fb);\n    int x, y;\n    struct timeval res;\n    int has_dirty = 0;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect = vnc_stat_rect(vd, x, y);\n\n            rect->updated = false;\n        }\n    }\n\n    qemu_timersub(tv, &VNC_REFRESH_STATS, &res);\n\n    if (timercmp(&vd->guest.last_freq_check, &res, >)) {\n        return has_dirty;\n    }\n    vd->guest.last_freq_check = *tv;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect= vnc_stat_rect(vd, x, y);\n            int count = ARRAY_SIZE(rect->times);\n            struct timeval min, max;\n\n            if (!timerisset(&rect->times[count - 1])) {\n                continue ;\n            }\n\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(tv, &max, &res);\n\n            if (timercmp(&res, &VNC_REFRESH_LOSSY, >)) {\n                rect->freq = 0;\n                has_dirty += vnc_refresh_lossy_rect(vd, x, y);\n                memset(rect->times, 0, sizeof (rect->times));\n                continue ;\n            }\n\n            min = rect->times[rect->idx];\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(&max, &min, &res);\n\n            rect->freq = res.tv_sec + res.tv_usec / 1000000.;\n            rect->freq /= count;\n            rect->freq = 1. / rect->freq;\n        }\n    }\n    return has_dirty;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186836, "func": "std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n     mojo::ScopedSharedBufferHandle handle) {\n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n  bool read_only_flag = false;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n   if (result != MOJO_RESULT_OK)\n     return nullptr;\n   DCHECK_GT(memory_size, 0u);\n \n   std::unique_ptr<base::SharedMemory> shm =\n      std::make_unique<base::SharedMemory>(memory_handle, read_only_flag);\n   if (!shm->Map(memory_size)) {\n     DLOG(ERROR) << \"Map shared memory failed.\";\n     return nullptr;\n  }\n  return shm;\n}\n", "target": 1, "flaw_line_index": "5,8,14"}
{"idx": 186456, "func": "void RenderFrameImpl::DidAddMessageToConsole(\n    const blink::WebConsoleMessage& message,\n    const blink::WebString& source_name,\n    unsigned source_line,\n    const blink::WebString& stack_trace) {\n  logging::LogSeverity log_severity = logging::LOG_VERBOSE;\n  switch (message.level) {\n    case blink::mojom::ConsoleMessageLevel::kVerbose:\n      log_severity = logging::LOG_VERBOSE;\n      break;\n    case blink::mojom::ConsoleMessageLevel::kInfo:\n      log_severity = logging::LOG_INFO;\n      break;\n    case blink::mojom::ConsoleMessageLevel::kWarning:\n      log_severity = logging::LOG_WARNING;\n      break;\n    case blink::mojom::ConsoleMessageLevel::kError:\n      log_severity = logging::LOG_ERROR;\n      break;\n    default:\n      log_severity = logging::LOG_VERBOSE;\n  }\n\n  if (ShouldReportDetailedMessageForSource(source_name)) {\n    for (auto& observer : observers_) {\n      observer.DetailedConsoleMessageAdded(\n          message.text.Utf16(), source_name.Utf16(), stack_trace.Utf16(),\n          source_line, static_cast<uint32_t>(log_severity));\n     }\n   }\n \n  Send(new FrameHostMsg_DidAddMessageToConsole(\n      routing_id_, static_cast<int32_t>(log_severity), message.text.Utf16(),\n      static_cast<int32_t>(source_line), source_name.Utf16()));\n }\n", "target": 1, "flaw_line_index": "32,33,34"}
{"idx": 7434, "func": "ZEND_API int _zend_ts_hash_add_or_update(TsHashTable *ht, char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = _zend_hash_add_or_update(TS_HASH(ht), arKey, nKeyLength, pData, nDataSize, pDest, flag ZEND_FILE_LINE_RELAY_CC);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186785, "func": " bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitDecode(\n     const scoped_refptr<H264Picture>& pic) {\n   VLOGF(4) << \"Decoding POC \" << pic->pic_order_cnt;\n   scoped_refptr<VaapiDecodeSurface> dec_surface =\n       H264PictureToVaapiDecodeSurface(pic);\n \n  return vaapi_dec_->DecodeSurface(dec_surface);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186960, "func": " void AppCacheDatabase::ReadEntryRecord(\n    const sql::Statement& statement, EntryRecord* record) {\n  record->cache_id = statement.ColumnInt64(0);\n  record->url = GURL(statement.ColumnString(1));\n   record->flags = statement.ColumnInt(2);\n   record->response_id = statement.ColumnInt64(3);\n   record->response_size = statement.ColumnInt64(4);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186944, "func": "void DownloadManagerImpl::CreateNewDownloadItemToStart(\n    std::unique_ptr<download::DownloadCreateInfo> info,\n    const download::DownloadUrlParameters::OnStartedCallback& on_started,\n    download::InProgressDownloadManager::StartDownloadItemCallback callback,\n    uint32_t id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n   download::DownloadItemImpl* download = CreateActiveItem(id, *info);\n   std::move(callback).Run(std::move(info), download,\n                           should_persist_new_download_);\n  for (auto& observer : observers_)\n    observer.OnDownloadCreated(this, download);\n  OnNewDownloadCreated(download);\n \n   OnDownloadStarted(download, on_started);\n }\n", "target": 1, "flaw_line_index": "11,12,13,14,15,16"}
{"idx": 186689, "func": " static void markPointer(Visitor* visitor, HeapObjectHeader* header) {\n  ASSERT(header->checkHeader());\n   const GCInfo* gcInfo = ThreadHeap::gcInfo(header->gcInfoIndex());\n   if (gcInfo->hasVTable() && !vTableInitialized(header->payload())) {\n    visitor->markHeaderNoTracing(header);\n    ASSERT(isUninitializedMemory(header->payload(), header->payloadSize()));\n  } else {\n    visitor->markHeader(header, gcInfo->m_trace);\n  }\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186877, "func": "void PageHandler::PrintToPDF(Maybe<bool> landscape,\n                             Maybe<bool> display_header_footer,\n                             Maybe<bool> print_background,\n                             Maybe<double> scale,\n                             Maybe<double> paper_width,\n                             Maybe<double> paper_height,\n                             Maybe<double> margin_top,\n                             Maybe<double> margin_bottom,\n                             Maybe<double> margin_left,\n                              Maybe<double> margin_right,\n                              Maybe<String> page_ranges,\n                              Maybe<bool> ignore_invalid_page_ranges,\n                              std::unique_ptr<PrintToPDFCallback> callback) {\n   callback->sendFailure(Response::Error(\"PrintToPDF is not implemented\"));\n   return;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7884, "func": "double xbzrle_mig_cache_miss_rate(void)\n{\n    return acct_info.xbzrle_cache_miss_rate;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7597, "func": "static void cirrus_update_bank_ptr(CirrusVGAState * s, unsigned bank_index)\n{\n    unsigned offset;\n    unsigned limit;\n\n    if ((s->vga.gr[0x0b] & 0x01) != 0)\t\n\toffset = s->vga.gr[0x09 + bank_index];\n    else\t\t\t\n\toffset = s->vga.gr[0x09];\n\n    if ((s->vga.gr[0x0b] & 0x20) != 0)\n\toffset <<= 14;\n    else\n\toffset <<= 12;\n\n    if (s->real_vram_size <= offset)\n\tlimit = 0;\n    else\n\tlimit = s->real_vram_size - offset;\n\n    if (((s->vga.gr[0x0b] & 0x01) == 0) && (bank_index != 0)) {\n\tif (limit > 0x8000) {\n\t    offset += 0x8000;\n\t    limit -= 0x8000;\n\t} else {\n\t    limit = 0;\n\t}\n    }\n\n    if (limit > 0) {\n\ts->cirrus_bank_base[bank_index] = offset;\n\ts->cirrus_bank_limit[bank_index] = limit;\n    } else {\n\ts->cirrus_bank_base[bank_index] = 0;\n\ts->cirrus_bank_limit[bank_index] = 0;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187051, "func": " ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(\n     ImageBitmapFactories& factory,\n     base::Optional<IntRect> crop_rect,\n     ScriptState* script_state,\n     const ImageBitmapOptions* options)\n    : loader_(\n           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),\n       factory_(&factory),\n       resolver_(ScriptPromiseResolver::Create(script_state)),\n       crop_rect_(crop_rect),\n       options_(options) {}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187022, "func": "ExtensionsGuestViewMessageFilter::FrameNavigationHelper::GetGuestView() const {\n  return MimeHandlerViewGuest::From(\n             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)\n      ->As<MimeHandlerViewGuest>();\n}\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 7961, "func": "static void do_key_event(VncState *vs, int down, int keycode, int sym)\n{\n    switch(keycode) {\n    case 0x2a:                          \n    case 0x36:                          \n    case 0x1d:                          \n    case 0x9d:                          \n    case 0x38:                          \n    case 0xb8:                          \n        if (down)\n            vs->modifiers_state[keycode] = 1;\n        else\n            vs->modifiers_state[keycode] = 0;\n        break;\n    case 0x02 ... 0x0a: \n        if (down && vs->modifiers_state[0x1d] && vs->modifiers_state[0x38]) {\n            reset_keys(vs);\n            console_select(keycode - 0x02);\n            return;\n        }\n        break;\n    case 0x3a:                        \n    case 0x45:                        \n        if (down)\n            vs->modifiers_state[keycode] ^= 1;\n        break;\n    }\n\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        keycode_is_keypad(vs->vd->kbd_layout, keycode)) {\n        if (keysym_is_numlock(vs->vd->kbd_layout, sym & 0xFFFF)) {\n            if (!vs->modifiers_state[0x45]) {\n                trace_vnc_key_sync_numlock(true);\n                vs->modifiers_state[0x45] = 1;\n                press_key(vs, 0xff7f);\n            }\n        } else {\n            if (vs->modifiers_state[0x45]) {\n                trace_vnc_key_sync_numlock(false);\n                vs->modifiers_state[0x45] = 0;\n                press_key(vs, 0xff7f);\n            }\n        }\n    }\n\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        ((sym >= 'A' && sym <= 'Z') || (sym >= 'a' && sym <= 'z'))) {\n        int uppercase = !!(sym >= 'A' && sym <= 'Z');\n        int shift = !!(vs->modifiers_state[0x2a] | vs->modifiers_state[0x36]);\n        int capslock = !!(vs->modifiers_state[0x3a]);\n        if (capslock) {\n            if (uppercase == shift) {\n                trace_vnc_key_sync_capslock(false);\n                vs->modifiers_state[0x3a] = 0;\n                press_key(vs, 0xffe5);\n            }\n        } else {\n            if (uppercase != shift) {\n                trace_vnc_key_sync_capslock(true);\n                vs->modifiers_state[0x3a] = 1;\n                press_key(vs, 0xffe5);\n            }\n        }\n    }\n\n    if (qemu_console_is_graphic(NULL)) {\n        qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, down);\n    } else {\n        bool numlock = vs->modifiers_state[0x45];\n        bool control = (vs->modifiers_state[0x1d] ||\n                        vs->modifiers_state[0x9d]);\n        if (down) {\n            switch (keycode) {\n            case 0x2a:                          \n            case 0x36:                          \n            case 0x1d:                          \n            case 0x9d:                          \n            case 0x38:                          \n            case 0xb8:                          \n                break;\n            case 0xc8:\n                kbd_put_keysym(QEMU_KEY_UP);\n                break;\n            case 0xd0:\n                kbd_put_keysym(QEMU_KEY_DOWN);\n                break;\n            case 0xcb:\n                kbd_put_keysym(QEMU_KEY_LEFT);\n                break;\n            case 0xcd:\n                kbd_put_keysym(QEMU_KEY_RIGHT);\n                break;\n            case 0xd3:\n                kbd_put_keysym(QEMU_KEY_DELETE);\n                break;\n            case 0xc7:\n                kbd_put_keysym(QEMU_KEY_HOME);\n                break;\n            case 0xcf:\n                kbd_put_keysym(QEMU_KEY_END);\n                break;\n            case 0xc9:\n                kbd_put_keysym(QEMU_KEY_PAGEUP);\n                break;\n            case 0xd1:\n                kbd_put_keysym(QEMU_KEY_PAGEDOWN);\n                break;\n\n            case 0x47:\n                kbd_put_keysym(numlock ? '7' : QEMU_KEY_HOME);\n                break;\n            case 0x48:\n                kbd_put_keysym(numlock ? '8' : QEMU_KEY_UP);\n                break;\n            case 0x49:\n                kbd_put_keysym(numlock ? '9' : QEMU_KEY_PAGEUP);\n                break;\n            case 0x4b:\n                kbd_put_keysym(numlock ? '4' : QEMU_KEY_LEFT);\n                break;\n            case 0x4c:\n                kbd_put_keysym('5');\n                break;\n            case 0x4d:\n                kbd_put_keysym(numlock ? '6' : QEMU_KEY_RIGHT);\n                break;\n            case 0x4f:\n                kbd_put_keysym(numlock ? '1' : QEMU_KEY_END);\n                break;\n            case 0x50:\n                kbd_put_keysym(numlock ? '2' : QEMU_KEY_DOWN);\n                break;\n            case 0x51:\n                kbd_put_keysym(numlock ? '3' : QEMU_KEY_PAGEDOWN);\n                break;\n            case 0x52:\n                kbd_put_keysym('0');\n                break;\n            case 0x53:\n                kbd_put_keysym(numlock ? '.' : QEMU_KEY_DELETE);\n                break;\n\n            case 0xb5:\n                kbd_put_keysym('/');\n                break;\n            case 0x37:\n                kbd_put_keysym('*');\n                break;\n            case 0x4a:\n                kbd_put_keysym('-');\n                break;\n            case 0x4e:\n                kbd_put_keysym('+');\n                break;\n            case 0x9c:\n                kbd_put_keysym('\\n');\n                break;\n\n            default:\n                if (control) {\n                    kbd_put_keysym(sym & 0x1f);\n                } else {\n                    kbd_put_keysym(sym);\n                }\n                break;\n            }\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187156, "func": "   explicit RemoveDownloadsTester(TestingProfile* testing_profile)\n      : download_manager_(new content::MockDownloadManager()),\n        chrome_download_manager_delegate_(testing_profile) {\n     content::BrowserContext::SetDownloadManagerForTesting(\n         testing_profile, base::WrapUnique(download_manager_));\n    EXPECT_EQ(download_manager_,\n              content::BrowserContext::GetDownloadManager(testing_profile));\n    EXPECT_CALL(*download_manager_, GetDelegate())\n        .WillOnce(Return(&chrome_download_manager_delegate_));\n     EXPECT_CALL(*download_manager_, Shutdown());\n   }\n", "target": 1, "flaw_line_index": "2,3,6,7,8,9"}
{"idx": 8044, "func": "void *vnc_server_fb_ptr(VncDisplay *vd, int x, int y)\n{\n    uint8_t *ptr;\n\n    ptr  = (uint8_t *)pixman_image_get_data(vd->server);\n    ptr += y * vnc_server_fb_stride(vd);\n    ptr += x * VNC_SERVER_FB_BYTES;\n    return ptr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7686, "func": "static ssize_t handle_pwritev(FsContext *ctx, V9fsFidOpenState *fs,\n                              const struct iovec *iov,\n                              int iovcnt, off_t offset)\n{\n    ssize_t ret;\n#ifdef CONFIG_PREADV\n    ret = pwritev(fs->fd, iov, iovcnt, offset);\n#else\n    int err = lseek(fs->fd, offset, SEEK_SET);\n    if (err == -1) {\n        return err;\n    } else {\n        ret = writev(fs->fd, iov, iovcnt);\n    }\n#endif\n#ifdef CONFIG_SYNC_FILE_RANGE\n    if (ret > 0 && ctx->export_flags & V9FS_IMMEDIATE_WRITEOUT) {\n        sync_file_range(fs->fd, offset, ret,\n                        SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE);\n    }\n#endif\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186557, "func": "void SetDelegateOnIO(content::ResourceDispatcherHostDelegate* new_delegate) {\n  content::ResourceDispatcherHost::Get()->SetDelegate(new_delegate);\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8089, "func": "void Gfx::execOp(Object *cmd, Object args[], int numArgs) {\n  Operator *op;\n  char *name;\n  Object *argPtr;\n  int i;\n\n  name = cmd->getCmd();\n  if (!(op = findOp(name))) {\n    if (ignoreUndef == 0)\n      error(getPos(), \"Unknown operator '%s'\", name);\n    return;\n  }\n\n  argPtr = args;\n  if (op->numArgs >= 0) {\n    if (numArgs < op->numArgs) {\n      error(getPos(), \"Too few (%d) args to '%s' operator\", numArgs, name);\n      commandAborted = gTrue;\n      return;\n    }\n    if (numArgs > op->numArgs) {\n#if 0\n      error(getPos(), \"Too many (%d) args to '%s' operator\", numArgs, name);\n#endif\n      argPtr += numArgs - op->numArgs;\n      numArgs = op->numArgs;\n    }\n  } else {\n    if (numArgs > -op->numArgs) {\n      error(getPos(), \"Too many (%d) args to '%s' operator\",\n\t    numArgs, name);\n      return;\n    }\n  }\n  for (i = 0; i < numArgs; ++i) {\n    if (!checkArg(&argPtr[i], op->tchk[i])) {\n      error(getPos(), \"Arg #%d to '%s' operator is wrong type (%s)\",\n\t    i, name, argPtr[i].getTypeName());\n      return;\n    }\n  }\n\n  (this->*op->func)(argPtr, numArgs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187171, "func": "  void TestProcessOverflow() {\n    int tab_count = 1;\n    int host_count = 1;\n    WebContents* tab1 = NULL;\n    WebContents* tab2 = NULL;\n    content::RenderProcessHost* rph1 = NULL;\n    content::RenderProcessHost* rph2 = NULL;\n    content::RenderProcessHost* rph3 = NULL;\n\n     const extensions::Extension* extension =\n         LoadExtension(test_data_dir_.AppendASCII(\"options_page\"));\n \n     GURL omnibox(chrome::kChromeUIOmniboxURL);\n     ui_test_utils::NavigateToURL(browser(), omnibox);\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    rph1 = tab1->GetMainFrame()->GetProcess();\n     EXPECT_EQ(omnibox, tab1->GetURL());\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n \n     GURL page1(\"data:text/html,hello world1\");\n \n     ui_test_utils::WindowedTabAddedNotificationObserver observer1(\n        content::NotificationService::AllSources());\n    ::ShowSingletonTab(browser(), page1);\n    observer1.Wait();\n\n    tab_count++;\n    host_count++;\n    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    rph2 = tab1->GetMainFrame()->GetProcess();\n    EXPECT_EQ(tab1->GetURL(), page1);\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_NE(rph1, rph2);\n \n     GURL page2(\"data:text/html,hello world2\");\n     ui_test_utils::WindowedTabAddedNotificationObserver observer2(\n         content::NotificationService::AllSources());\n     ::ShowSingletonTab(browser(), page2);\n     observer2.Wait();\n     tab_count++;\n     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n     EXPECT_EQ(tab2->GetURL(), page2);\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);\n     GURL history(chrome::kChromeUIHistoryURL);\n     ui_test_utils::WindowedTabAddedNotificationObserver observer3(\n         content::NotificationService::AllSources());\n    ::ShowSingletonTab(browser(), history);\n    observer3.Wait();\n    tab_count++;\n    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    EXPECT_EQ(tab2->GetURL(), GURL(history));\n     EXPECT_EQ(host_count, RenderProcessHostCount());\n     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);\n \n     GURL extension_url(\"chrome-extension:\n     ui_test_utils::WindowedTabAddedNotificationObserver observer4(\n         content::NotificationService::AllSources());\n    ::ShowSingletonTab(browser(), extension_url);\n\n    observer4.Wait();\n    tab_count++;\n    host_count++;\n    EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());\n    tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);\n    rph3 = tab1->GetMainFrame()->GetProcess();\n    EXPECT_EQ(tab1->GetURL(), extension_url);\n    EXPECT_EQ(host_count, RenderProcessHostCount());\n    EXPECT_NE(rph1, rph3);\n    EXPECT_NE(rph2, rph3);\n  }\n", "target": 1, "flaw_line_index": "13,22,39,50,51,52,53,54,67"}
{"idx": 186918, "func": "void PushMessagingServiceImpl::DidHandleMessage(\n    const std::string& app_id,\n    const base::Closure& message_handled_closure) {\n  auto in_flight_iterator = in_flight_message_deliveries_.find(app_id);\n  DCHECK(in_flight_iterator != in_flight_message_deliveries_.end());\n\n  in_flight_message_deliveries_.erase(in_flight_iterator);\n\n#if BUILDFLAG(ENABLE_BACKGROUND)\n  if (in_flight_message_deliveries_.empty())\n    in_flight_keep_alive_.reset();\n#endif\n \n   message_handled_closure.Run();\n \n  if (push_messaging_service_observer_)\n    push_messaging_service_observer_->OnMessageHandled();\n }\n", "target": 1, "flaw_line_index": "19"}
{"idx": 8245, "func": "static void v9fs_xattrwalk(void *opaque)\n{\n    int64_t size;\n    V9fsString name;\n    ssize_t err = 0;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrwalk(pdu->tag, pdu->id, fid, newfid, name.data);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    xattr_fidp = alloc_fid(s, newfid);\n    if (xattr_fidp == NULL) {\n        err = -EINVAL;\n        goto out;\n    }\n    v9fs_path_copy(&xattr_fidp->path, &file_fidp->path);\n    if (!v9fs_string_size(&name)) {\n        size = v9fs_co_llistxattr(pdu, &xattr_fidp->path, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.copied_len = -1;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_llistxattr(pdu, &xattr_fidp->path,\n                                     xattr_fidp->fs.xattr.value,\n                                     xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        err = pdu_marshal(pdu, offset, \"q\", size);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    } else {\n        size = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                 &name, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.copied_len = -1;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                    &name, xattr_fidp->fs.xattr.value,\n                                    xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        err = pdu_marshal(pdu, offset, \"q\", size);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    }\n    trace_v9fs_xattrwalk_return(pdu->tag, pdu->id, size);\nout:\n    put_fid(pdu, file_fidp);\n    if (xattr_fidp) {\n        put_fid(pdu, xattr_fidp);\n    }\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187003, "func": "bool DownloadManagerImpl::InterceptDownload(\n    const download::DownloadCreateInfo& info) {\n  WebContents* web_contents = WebContentsImpl::FromRenderFrameHostID(\n      info.render_process_id, info.render_frame_id);\n  if (info.is_new_download &&\n      info.result ==\n          download::DOWNLOAD_INTERRUPT_REASON_SERVER_CROSS_ORIGIN_REDIRECT) {\n    if (web_contents) {\n      std::vector<GURL> url_chain(info.url_chain);\n      GURL url = url_chain.back();\n      url_chain.pop_back();\n      NavigationController::LoadURLParams params(url);\n      params.has_user_gesture = info.has_user_gesture;\n      params.referrer = Referrer(\n           info.referrer_url, Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                                  info.referrer_policy));\n       params.redirect_chain = url_chain;\n       web_contents->GetController().LoadURLWithParams(params);\n     }\n     if (info.request_handle)\n      info.request_handle->CancelRequest(false);\n    return true;\n  }\n  if (!delegate_ ||\n      !delegate_->InterceptDownloadIfApplicable(\n          info.url(), info.mime_type, info.request_origin, web_contents)) {\n    return false;\n  }\n  if (info.request_handle)\n    info.request_handle->CancelRequest(false);\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187000, "func": "DownloadUrlParameters::DownloadUrlParameters(\n    const GURL& url,\n    int render_process_host_id,\n    int render_view_host_routing_id,\n    int render_frame_host_routing_id,\n    const net::NetworkTrafficAnnotationTag& traffic_annotation)\n    : content_initiated_(false),\n      use_if_range_(true),\n      method_(\"GET\"),\n      post_id_(-1),\n      prefer_cache_(false),\n      referrer_policy_(\n          net::URLRequest::\n              CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE),\n       render_process_host_id_(render_process_host_id),\n       render_view_host_routing_id_(render_view_host_routing_id),\n       render_frame_host_routing_id_(render_frame_host_routing_id),\n       url_(url),\n       do_not_prompt_for_login_(false),\n       follow_cross_origin_redirects_(true),\n      fetch_error_body_(false),\n      transient_(false),\n      traffic_annotation_(traffic_annotation),\n      download_source_(DownloadSource::UNKNOWN) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8006, "func": "static void vnc_colordepth(VncState *vs)\n{\n    if (vnc_has_feature(vs, VNC_FEATURE_WMVI)) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1); \n        vnc_framebuffer_update(vs, 0, 0,\n                               pixman_image_get_width(vs->vd->server),\n                               pixman_image_get_height(vs->vd->server),\n                               VNC_ENCODING_WMVi);\n        pixel_format_message(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    } else {\n        set_pixel_conversion(vs);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8001, "func": "void vnc_client_write(void *opaque)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    if (vs->output.offset\n#ifdef CONFIG_VNC_WS\n            || vs->ws_output.offset\n#endif\n            ) {\n        vnc_client_write_locked(opaque);\n    } else if (vs->csock != -1) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n    vnc_unlock_output(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187181, "func": "void DownloadRequestLimiter::TabDownloadState::SetDownloadStatusAndNotifyImpl(\n    DownloadStatus status,\n    ContentSetting setting) {\n  DCHECK((GetSettingFromDownloadStatus(status) == setting) ||\n         (GetDownloadStatusFromSetting(setting) == status))\n      << \"status \" << status << \" and setting \" << setting\n      << \" do not correspond to each other\";\n\n  ContentSetting last_setting = GetSettingFromDownloadStatus(status_);\n  DownloadUiStatus last_ui_status = ui_status_;\n\n  status_ = status;\n  ui_status_ = GetUiStatusFromDownloadStatus(status_, download_seen_);\n\n   if (!web_contents())\n     return;\n \n  if (last_setting == setting && last_ui_status == ui_status_)\n    return;\n\n  content::NotificationService::current()->Notify(\n      chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n      content::Source<content::WebContents>(web_contents()),\n       content::NotificationService::NoDetails());\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186981, "func": "  bool IsAllowed(const scoped_refptr<const Extension>& extension,\n                 const GURL& url,\n                 PermittedFeature feature,\n                 int tab_id) {\n    const PermissionsData* permissions_data = extension->permissions_data();\n     bool script =\n         permissions_data->CanAccessPage(url, tab_id, nullptr) &&\n         permissions_data->CanRunContentScriptOnPage(url, tab_id, nullptr);\n    bool capture = permissions_data->CanCaptureVisiblePage(url, tab_id, NULL);\n     switch (feature) {\n       case PERMITTED_SCRIPT_ONLY:\n         return script && !capture;\n      case PERMITTED_CAPTURE_ONLY:\n        return capture && !script;\n      case PERMITTED_BOTH:\n        return script && capture;\n      case PERMITTED_NONE:\n        return !script && !capture;\n    }\n    NOTREACHED();\n    return false;\n  }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8047, "func": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n{\n#ifdef _VNC_DEBUG\n    static const char *mn[] = {\n        [0]                           = \"undefined\",\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n    };\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n            vs->csock, mn[vs->share_mode], mn[mode]);\n#endif\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n        vs->vd->num_exclusive--;\n    }\n    vs->share_mode = mode;\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n        vs->vd->num_exclusive++;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186378, "func": "void NavigationControllerImpl::RendererDidNavigateToExistingPage(\n    RenderFrameHostImpl* rfh,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,\n    bool is_in_page,\n    bool was_restored,\n    NavigationHandleImpl* handle) {\n  DCHECK(!rfh->GetParent());\n\n\n  NavigationEntryImpl* entry;\n  if (params.intended_as_new_entry) {\n     entry = GetLastCommittedEntry();\n   } else if (params.nav_entry_id) {\n     entry = GetEntryWithUniqueID(params.nav_entry_id);\n\n    if (is_in_page) {\n      NavigationEntryImpl* last_entry = GetLastCommittedEntry();\n      if (entry->GetURL().GetOrigin() == last_entry->GetURL().GetOrigin() &&\n          last_entry->GetSSL().initialized && !entry->GetSSL().initialized &&\n          was_restored) {\n        entry->GetSSL() = last_entry->GetSSL();\n      }\n    } else {\n      entry->GetSSL() = handle->ssl_status();\n    }\n  } else {\n    entry = GetLastCommittedEntry();\n\n    if (!is_in_page)\n      entry->GetSSL() = handle->ssl_status();\n  }\n  DCHECK(entry);\n\n  entry->set_page_type(params.url_is_unreachable ? PAGE_TYPE_ERROR\n                                                 : PAGE_TYPE_NORMAL);\n  entry->SetURL(params.url);\n  entry->SetReferrer(params.referrer);\n  if (entry->update_virtual_url_with_url())\n    UpdateVirtualURLToURL(entry, params.url);\n\n  DCHECK(entry->site_instance() == nullptr ||\n         !entry->GetRedirectChain().empty() ||\n         entry->site_instance() == rfh->GetSiteInstance());\n\n  entry->AddOrUpdateFrameEntry(\n      rfh->frame_tree_node(), params.item_sequence_number,\n      params.document_sequence_number, rfh->GetSiteInstance(), nullptr,\n      params.url, params.referrer, params.redirects, params.page_state,\n      params.method, params.post_id);\n\n  if (ui::PageTransitionIsRedirect(params.transition) && !is_in_page)\n    entry->GetFavicon() = FaviconStatus();\n\n  DiscardNonCommittedEntriesInternal();\n\n  last_committed_entry_index_ = GetIndexOfEntry(entry);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186661, "func": "RenderFrameHostImpl* RenderFrameHostManager::GetFrameHostForNavigation(\n    const NavigationRequest& request) {\n  DCHECK(!request.common_params().url.SchemeIs(url::kJavaScriptScheme))\n      << \"Don't call this method for JavaScript URLs as those create a \"\n         \"temporary  NavigationRequest and we don't want to reset an ongoing \"\n         \"navigation's speculative RFH.\";\n\n  RenderFrameHostImpl* navigation_rfh = nullptr;\n\n  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();\n  scoped_refptr<SiteInstance> dest_site_instance =\n      GetSiteInstanceForNavigationRequest(request);\n\n  bool use_current_rfh = current_site_instance == dest_site_instance;\n\n  bool notify_webui_of_rf_creation = false;\n  if (use_current_rfh) {\n     if (speculative_render_frame_host_) {\n      if (speculative_render_frame_host_->navigation_handle()) {\n         frame_tree_node_->navigator()->DiscardPendingEntryIfNeeded(\n             speculative_render_frame_host_->navigation_handle()\n                 ->pending_nav_entry_id());\n      }\n      DiscardUnusedFrame(UnsetSpeculativeRenderFrameHost());\n    }\n\n    if (frame_tree_node_->IsMainFrame()) {\n      UpdatePendingWebUIOnCurrentFrameHost(request.common_params().url,\n                                           request.bindings());\n    }\n\n    navigation_rfh = render_frame_host_.get();\n\n    DCHECK(!speculative_render_frame_host_);\n  } else {\n\n    if (!speculative_render_frame_host_ ||\n        speculative_render_frame_host_->GetSiteInstance() !=\n            dest_site_instance.get()) {\n      CleanUpNavigation();\n      bool success = CreateSpeculativeRenderFrameHost(current_site_instance,\n                                                      dest_site_instance.get());\n      DCHECK(success);\n    }\n    DCHECK(speculative_render_frame_host_);\n\n    if (frame_tree_node_->IsMainFrame()) {\n      bool changed_web_ui = speculative_render_frame_host_->UpdatePendingWebUI(\n          request.common_params().url, request.bindings());\n      speculative_render_frame_host_->CommitPendingWebUI();\n      DCHECK_EQ(GetNavigatingWebUI(), speculative_render_frame_host_->web_ui());\n      notify_webui_of_rf_creation =\n          changed_web_ui && speculative_render_frame_host_->web_ui();\n    }\n    navigation_rfh = speculative_render_frame_host_.get();\n\n    if (!render_frame_host_->IsRenderFrameLive()) {\n      if (GetRenderFrameProxyHost(dest_site_instance.get())) {\n        navigation_rfh->Send(\n            new FrameMsg_SwapIn(navigation_rfh->GetRoutingID()));\n      }\n      CommitPending();\n\n      if (notify_webui_of_rf_creation && render_frame_host_->web_ui()) {\n        render_frame_host_->web_ui()->RenderFrameCreated(\n            render_frame_host_.get());\n        notify_webui_of_rf_creation = false;\n      }\n    }\n  }\n  DCHECK(navigation_rfh &&\n         (navigation_rfh == render_frame_host_.get() ||\n          navigation_rfh == speculative_render_frame_host_.get()));\n\n  if (!navigation_rfh->IsRenderFrameLive()) {\n    if (!ReinitializeRenderFrame(navigation_rfh))\n      return nullptr;\n\n    notify_webui_of_rf_creation = true;\n\n    if (navigation_rfh == render_frame_host_.get()) {\n      EnsureRenderFrameHostVisibilityConsistent();\n      EnsureRenderFrameHostPageFocusConsistent();\n      delegate_->NotifyMainFrameSwappedFromRenderManager(\n          nullptr, render_frame_host_->render_view_host());\n    }\n  }\n\n  if (notify_webui_of_rf_creation && GetNavigatingWebUI() &&\n      frame_tree_node_->IsMainFrame()) {\n    GetNavigatingWebUI()->RenderFrameCreated(navigation_rfh);\n  }\n\n  return navigation_rfh;\n}\n", "target": 1, "flaw_line_index": "30,31"}
{"idx": 187231, "func": "static int hid_open(int sub_api, struct libusb_device_handle *dev_handle)\n{\n\tstruct libusb_context *ctx = DEVICE_CTX(dev_handle->dev);\n\tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n\tHIDD_ATTRIBUTES hid_attributes;\n\tPHIDP_PREPARSED_DATA preparsed_data = NULL;\n\tHIDP_CAPS capabilities;\n\tHIDP_VALUE_CAPS *value_caps;\n\tHANDLE hid_handle = INVALID_HANDLE_VALUE;\n\tint i, j;\n\tULONG size[3];\n\tconst char* type[3] = {\"input\", \"output\", \"feature\"};\n\tint nb_ids[2];\t\n\tCHECK_HID_AVAILABLE;\n\tif (priv->hid == NULL) {\n\t\tusbi_err(ctx, \"program assertion failed - private HID structure is unitialized\");\n\t\treturn LIBUSB_ERROR_NOT_FOUND;\n\t}\n\tfor (i = 0; i < USB_MAXINTERFACES; i++) {\n\t\tif ( (priv->usb_interface[i].path != NULL)\n\t\t  && (priv->usb_interface[i].apib->id == USB_API_HID) ) {\n\t\t\thid_handle = CreateFileA(priv->usb_interface[i].path, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ,\n\t\t\t\tNULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\t\t\t * http:\n\t\t\tif (hid_handle == INVALID_HANDLE_VALUE) {\n\t\t\t\tusbi_warn(ctx, \"could not open HID device in R/W mode (keyboard or mouse?) - trying without\");\n\t\t\t\thid_handle = CreateFileA(priv->usb_interface[i].path, 0, FILE_SHARE_WRITE | FILE_SHARE_READ,\n\t\t\t\t\tNULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\t\t\t\tif (hid_handle == INVALID_HANDLE_VALUE) {\n\t\t\t\t\tusbi_err(ctx, \"could not open device %s (interface %d): %s\", priv->path, i, windows_error_str(0));\n\t\t\t\t\tswitch(GetLastError()) {\n\t\t\t\t\tcase ERROR_FILE_NOT_FOUND:\t\n\t\t\t\t\t\treturn LIBUSB_ERROR_NO_DEVICE;\n\t\t\t\t\tcase ERROR_ACCESS_DENIED:\n\t\t\t\t\t\treturn LIBUSB_ERROR_ACCESS;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn LIBUSB_ERROR_IO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpriv->usb_interface[i].restricted_functionality = true;\n\t\t\t}\n\t\t\thandle_priv->interface_handle[i].api_handle = hid_handle;\n\t\t}\n\t}\n\thid_attributes.Size = sizeof(hid_attributes);\n\tdo {\n\t\tif (!HidD_GetAttributes(hid_handle, &hid_attributes)) {\n\t\t\tusbi_err(ctx, \"could not gain access to HID top collection (HidD_GetAttributes)\");\n\t\t\tbreak;\n\t\t}\n\t\tpriv->hid->vid = hid_attributes.VendorID;\n\t\tpriv->hid->pid = hid_attributes.ProductID;\n\t\tfor (i=32; HidD_SetNumInputBuffers(hid_handle, i); i*=2);\n\t\tusbi_dbg(\"set maximum input buffer size to %d\", i/2);\n\t\tif (!HidD_GetPreparsedData(hid_handle, &preparsed_data) || !preparsed_data) {\n\t\t\tusbi_err(ctx, \"could not read HID preparsed data (HidD_GetPreparsedData)\");\n\t\t\tbreak;\n\t\t}\n\t\tif (HidP_GetCaps(preparsed_data, &capabilities) != HIDP_STATUS_SUCCESS) {\n\t\t\tusbi_err(ctx, \"could not parse HID capabilities (HidP_GetCaps)\");\n\t\t\tbreak;\n\t\t}\n\t\tsize[0] = capabilities.NumberInputValueCaps;\n\t\tsize[1] = capabilities.NumberOutputValueCaps;\n\t\tsize[2] = capabilities.NumberFeatureValueCaps;\n\t\tfor (j=HidP_Input; j<=HidP_Feature; j++) {\n\t\t\tusbi_dbg(\"%d HID %s report value(s) found\", size[j], type[j]);\n\t\t\tpriv->hid->uses_report_ids[j] = false;\n\t\t\tif (size[j] > 0) {\n\t\t\t\tvalue_caps = (HIDP_VALUE_CAPS*) calloc(size[j], sizeof(HIDP_VALUE_CAPS));\n\t\t\t\tif ( (value_caps != NULL)\n\t\t\t\t  && (HidP_GetValueCaps((HIDP_REPORT_TYPE)j, value_caps, &size[j], preparsed_data) == HIDP_STATUS_SUCCESS)\n\t\t\t\t  && (size[j] >= 1) ) {\n\t\t\t\t\tnb_ids[0] = 0;\n\t\t\t\t\tnb_ids[1] = 0;\n\t\t\t\t\tfor (i=0; i<(int)size[j]; i++) {\n\t\t\t\t\t\tusbi_dbg(\"  Report ID: 0x%02X\", value_caps[i].ReportID);\n\t\t\t\t\t\tif (value_caps[i].ReportID != 0) {\n\t\t\t\t\t\t\tnb_ids[1]++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnb_ids[0]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (nb_ids[1] != 0) {\n\t\t\t\t\t\tif (nb_ids[0] != 0) {\n\t\t\t\t\t\t\tusbi_warn(ctx, \"program assertion failed: zero and nonzero report IDs used for %s\",\n\t\t\t\t\t\t\t\ttype[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpriv->hid->uses_report_ids[j] = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tusbi_warn(ctx, \"  could not process %s report IDs\", type[j]);\n\t\t\t\t}\n\t\t\t\tsafe_free(value_caps);\n\t\t\t}\n\t\t}\n\t\tpriv->hid->input_report_size = capabilities.InputReportByteLength;\n\t\tpriv->hid->output_report_size = capabilities.OutputReportByteLength;\n\t\tpriv->hid->feature_report_size = capabilities.FeatureReportByteLength;\n\t\tpriv->hid->string_index[0] = priv->dev_descriptor.iManufacturer;\n\t\tif (priv->hid->string_index[0] != 0) {\n\t\t\tHidD_GetManufacturerString(hid_handle, priv->hid->string[0],\n\t\t\t\tsizeof(priv->hid->string[0]));\n\t\t} else {\n\t\t\tpriv->hid->string[0][0] = 0;\n\t\t}\n\t\tpriv->hid->string_index[1] = priv->dev_descriptor.iProduct;\n\t\tif (priv->hid->string_index[1] != 0) {\n\t\t\tHidD_GetProductString(hid_handle, priv->hid->string[1],\n\t\t\t\tsizeof(priv->hid->string[1]));\n\t\t} else {\n\t\t\tpriv->hid->string[1][0] = 0;\n\t\t}\n\t\tpriv->hid->string_index[2] = priv->dev_descriptor.iSerialNumber;\n\t\tif (priv->hid->string_index[2] != 0) {\n\t\t\tHidD_GetSerialNumberString(hid_handle, priv->hid->string[2],\n\t\t\t\tsizeof(priv->hid->string[2]));\n\t\t} else {\n\t\t\tpriv->hid->string[2][0] = 0;\n\t\t}\n\t} while(0);\n\tif (preparsed_data) {\n\t\tHidD_FreePreparsedData(preparsed_data);\n\t}\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,24,25,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128"}
{"idx": 7786, "func": "static struct task *h2_timeout_task(struct task *t)\n{\n\tstruct h2c *h2c = t->context;\n\tint expired = tick_is_expired(t->expire, now_ms);\n\n\tif (!expired && h2c)\n\t\treturn t;\n\n\ttask_delete(t);\n\ttask_free(t);\n\n\tif (!h2c) {\n\t\treturn NULL;\n\t}\n\n\th2c->task = NULL;\n\th2c_error(h2c, H2_ERR_NO_ERROR);\n\th2_wake_some_streams(h2c, 0, 0);\n\n\tif (h2c->mbuf->o) {\n\t\th2c->flags |= H2_CF_GOAWAY_FAILED;\n\t}\n\n\th2c->last_sid = h2c->max_id;\n\tif (h2c_send_goaway_error(h2c, NULL) <= 0)\n\t\th2c->flags |= H2_CF_GOAWAY_FAILED;\n\n\tif (h2c->mbuf->o && !(h2c->flags & H2_CF_GOAWAY_FAILED) && conn_xprt_ready(h2c->conn))\n\t\th2c->conn->xprt->snd_buf(h2c->conn, h2c->mbuf, 0);\n\n\tif (eb_is_empty(&h2c->streams_by_id))\n\t\th2_release(h2c->conn);\n\n\treturn NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186647, "func": "void ExtensionApiTest::SetUpOnMainThread() {\n  ExtensionBrowserTest::SetUpOnMainThread();\n  DCHECK(!test_config_.get()) << \"Previous test did not clear config state.\";\n  test_config_.reset(new base::DictionaryValue());\n  test_config_->SetString(kTestDataDirectory,\n                           net::FilePathToFileURL(test_data_dir_).spec());\n   test_config_->SetBoolean(kBrowserSideNavigationEnabled,\n                            content::IsBrowserSideNavigationEnabled());\n   extensions::TestGetConfigFunction::set_test_config_state(\n       test_config_.get());\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7857, "func": "void pci_register_soundhw(const char *name, const char *descr,\n                          int (*init_pci)(PCIBus *bus))\n{\n    assert(soundhw_count < ARRAY_SIZE(soundhw) - 1);\n    soundhw[soundhw_count].name = name;\n    soundhw[soundhw_count].descr = descr;\n    soundhw[soundhw_count].isa = 0;\n    soundhw[soundhw_count].init.init_pci = init_pci;\n    soundhw_count++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186772, "func": "void AudioNode::Dispose() {\n  DCHECK(IsMainThread());\n#if DEBUG_AUDIONODE_REFERENCES\n  fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(),\n          this, Handler().GetNodeType(), handler_.get());\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n  if (context()->HasRealtimeConstraint()) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n  } else {\n    if (context()->ContextState() == BaseAudioContext::kRunning) {\n      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n          std::move(handler_));\n    }\n   }\n }\n", "target": 1, "flaw_line_index": "9,10,11,12,13,14,17,18,19"}
{"idx": 186868, "func": "  void InitSkBitmapDataForTransfer(const SkBitmap& bitmap) {\n    const SkImageInfo& info = bitmap.info();\n    color_type = info.colorType();\n    alpha_type = info.alphaType();\n    width = info.width();\n    height = info.height();\n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 186974, "func": "void AppCacheUpdateJob::HandleUrlFetchCompleted(URLFetcher* fetcher,\n                                                int net_error) {\n  DCHECK(internal_state_ == DOWNLOADING);\n\n  UpdateURLLoaderRequest* request = fetcher->request();\n  const GURL& url = request->GetURL();\n  pending_url_fetches_.erase(url);\n  NotifyAllProgress(url);\n  ++url_fetches_completed_;\n\n  int response_code = net_error == net::OK ? request->GetResponseCode()\n                                           : fetcher->redirect_response_code();\n\n  AppCacheEntry& entry = url_file_list_.find(url)->second;\n\n  if (response_code / 100 == 2) {\n     DCHECK(fetcher->response_writer());\n     entry.set_response_id(fetcher->response_writer()->response_id());\n    entry.set_response_size(fetcher->response_writer()->amount_written());\n     if (!inprogress_cache_->AddOrModifyEntry(url, entry))\n       duplicate_response_ids_.push_back(entry.response_id());\n \n\n  } else {\n    VLOG(1) << \"Request error: \" << net_error\n            << \" response code: \" << response_code;\n    if (entry.IsExplicit() || entry.IsFallback() || entry.IsIntercept()) {\n       if (response_code == 304 && fetcher->existing_entry().has_response_id()) {\n         entry.set_response_id(fetcher->existing_entry().response_id());\n        entry.set_response_size(fetcher->existing_entry().response_size());\n         inprogress_cache_->AddOrModifyEntry(url, entry);\n       } else {\n         const char kFormatString[] = \"Resource fetch failed (%d) %s\";\n        std::string message = FormatUrlErrorMessage(\n            kFormatString, url, fetcher->result(), response_code);\n        ResultType result = fetcher->result();\n        bool is_cross_origin = url.GetOrigin() != manifest_url_.GetOrigin();\n        switch (result) {\n          case DISKCACHE_ERROR:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR,\n                    GURL(), 0, is_cross_origin),\n                result, url);\n            break;\n          case NETWORK_ERROR:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,\n                    url, 0, is_cross_origin),\n                result, url);\n            break;\n          default:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,\n                    url, response_code, is_cross_origin),\n                result, url);\n            break;\n        }\n        return;\n      }\n    } else if (response_code == 404 || response_code == 410) {\n    } else if (update_type_ == UPGRADE_ATTEMPT &&\n               fetcher->existing_entry().has_response_id()) {\n       entry.set_response_id(fetcher->existing_entry().response_id());\n      entry.set_response_size(fetcher->existing_entry().response_size());\n       inprogress_cache_->AddOrModifyEntry(url, entry);\n     }\n   }\n\n  DCHECK(internal_state_ != CACHE_FAILURE);\n  FetchUrls();\n  MaybeCompleteUpdate();\n}\n", "target": 1, "flaw_line_index": "20,41"}
{"idx": 187321, "func": "xsltResolveSASCallback(xsltAttrElemPtr values, xsltStylesheetPtr style,\n \t               const xmlChar *name, const xmlChar *ns,\n\t\t       ATTRIBUTE_UNUSED const xmlChar *ignored) {\n     xsltAttrElemPtr tmp;\n     xsltAttrElemPtr refs;\n \n     tmp = values;\n     while (tmp != NULL) {\n \tif (tmp->set != NULL) {\n\t    if ((xmlStrEqual(name, tmp->set)) && (xmlStrEqual(ns, tmp->ns))) {\n\t\txsltGenericError(xsltGenericErrorContext,\n     \"xsl:attribute-set : use-attribute-sets recursion detected on %s\\n\",\n                                 name);\n\t    } else {\n#ifdef WITH_XSLT_DEBUG_ATTRIBUTES\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t\"Importing attribute list %s\\n\", tmp->set);\n#endif\n\n\t\trefs = xsltGetSAS(style, tmp->set, tmp->ns);\n\t\tif (refs == NULL) {\n\t\t    xsltGenericError(xsltGenericErrorContext,\n     \"xsl:attribute-set : use-attribute-sets %s reference missing %s\\n\",\n\t\t\t\t     name, tmp->set);\n\t\t} else {\n\t\t    xsltResolveSASCallback(refs, style, name, ns, NULL);\n\t\t    xsltMergeAttrElemList(style, values, refs);\n\t\t    tmp->set = NULL;\n\t\t    tmp->ns = NULL;\n\t\t}\n\t    }\n\t}\n\ttmp = tmp->next;\n     }\n }\n", "target": 1, "flaw_line_index": "3,26"}
{"idx": 186973, "func": "void AppCacheUpdateJob::HandleMasterEntryFetchCompleted(URLFetcher* fetcher,\n                                                        int net_error) {\n  DCHECK(internal_state_ == NO_UPDATE || internal_state_ == DOWNLOADING);\n\n\n  UpdateURLLoaderRequest* request = fetcher->request();\n  const GURL& url = request->GetURL();\n  master_entry_fetches_.erase(url);\n  ++master_entries_completed_;\n\n  int response_code = net_error == net::OK ? request->GetResponseCode() : -1;\n\n  auto found = pending_master_entries_.find(url);\n  DCHECK(found != pending_master_entries_.end());\n  PendingHosts& hosts = found->second;\n\n  if (response_code / 100 == 2) {\n     AppCache* cache = inprogress_cache_.get() ? inprogress_cache_.get()\n                                               : group_->newest_complete_cache();\n     DCHECK(fetcher->response_writer());\n    AppCacheEntry master_entry(AppCacheEntry::MASTER,\n                               fetcher->response_writer()->response_id(),\n                               fetcher->response_writer()->amount_written());\n     if (cache->AddOrModifyEntry(url, master_entry))\n       added_master_entries_.push_back(url);\n     else\n      duplicate_response_ids_.push_back(master_entry.response_id());\n\n    if (!inprogress_cache_.get()) {\n      DCHECK(cache == group_->newest_complete_cache());\n      for (AppCacheHost* host : hosts)\n        host->AssociateCompleteCache(cache);\n    }\n  } else {\n    HostNotifier host_notifier;\n    for (AppCacheHost* host : hosts) {\n      host_notifier.AddHost(host);\n\n      if (inprogress_cache_.get())\n        host->AssociateNoCache(GURL());\n\n      host->RemoveObserver(this);\n    }\n    hosts.clear();\n\n    failed_master_entries_.insert(url);\n\n    const char kFormatString[] = \"Manifest fetch failed (%d) %s\";\n    std::string message = FormatUrlErrorMessage(\n        kFormatString, request->GetURL(), fetcher->result(), response_code);\n    host_notifier.SendErrorNotifications(blink::mojom::AppCacheErrorDetails(\n        message, blink::mojom::AppCacheErrorReason::APPCACHE_MANIFEST_ERROR,\n        request->GetURL(), response_code, false \n));\n\n    if (inprogress_cache_.get()) {\n      pending_master_entries_.erase(found);\n      --master_entries_completed_;\n\n      if (update_type_ == CACHE_ATTEMPT && pending_master_entries_.empty()) {\n        HandleCacheFailure(\n            blink::mojom::AppCacheErrorDetails(\n                message,\n                blink::mojom::AppCacheErrorReason::APPCACHE_MANIFEST_ERROR,\n                request->GetURL(), response_code, false \n),\n            fetcher->result(), GURL());\n        return;\n      }\n    }\n  }\n\n  DCHECK(internal_state_ != CACHE_FAILURE);\n  FetchMasterEntries();\n  MaybeCompleteUpdate();\n}\n", "target": 1, "flaw_line_index": "27,28,29"}
{"idx": 7582, "func": "static void cirrus_init_common(CirrusVGAState *s, Object *owner,\n                               int device_id, int is_pci,\n                               MemoryRegion *system_memory,\n                               MemoryRegion *system_io)\n{\n    int i;\n    static int inited;\n\n    if (!inited) {\n        inited = 1;\n        for(i = 0;i < 256; i++)\n            rop_to_index[i] = CIRRUS_ROP_NOP_INDEX; \n        rop_to_index[CIRRUS_ROP_0] = 0;\n        rop_to_index[CIRRUS_ROP_SRC_AND_DST] = 1;\n        rop_to_index[CIRRUS_ROP_NOP] = 2;\n        rop_to_index[CIRRUS_ROP_SRC_AND_NOTDST] = 3;\n        rop_to_index[CIRRUS_ROP_NOTDST] = 4;\n        rop_to_index[CIRRUS_ROP_SRC] = 5;\n        rop_to_index[CIRRUS_ROP_1] = 6;\n        rop_to_index[CIRRUS_ROP_NOTSRC_AND_DST] = 7;\n        rop_to_index[CIRRUS_ROP_SRC_XOR_DST] = 8;\n        rop_to_index[CIRRUS_ROP_SRC_OR_DST] = 9;\n        rop_to_index[CIRRUS_ROP_NOTSRC_OR_NOTDST] = 10;\n        rop_to_index[CIRRUS_ROP_SRC_NOTXOR_DST] = 11;\n        rop_to_index[CIRRUS_ROP_SRC_OR_NOTDST] = 12;\n        rop_to_index[CIRRUS_ROP_NOTSRC] = 13;\n        rop_to_index[CIRRUS_ROP_NOTSRC_OR_DST] = 14;\n        rop_to_index[CIRRUS_ROP_NOTSRC_AND_NOTDST] = 15;\n        s->device_id = device_id;\n        if (is_pci)\n            s->bustype = CIRRUS_BUSTYPE_PCI;\n        else\n            s->bustype = CIRRUS_BUSTYPE_ISA;\n    }\n\n    memory_region_init_io(&s->cirrus_vga_io, owner, &cirrus_vga_io_ops, s,\n                          \"cirrus-io\", 0x30);\n    memory_region_set_flush_coalesced(&s->cirrus_vga_io);\n    memory_region_add_subregion(system_io, 0x3b0, &s->cirrus_vga_io);\n\n    memory_region_init(&s->low_mem_container, owner,\n                       \"cirrus-lowmem-container\",\n                       0x20000);\n\n    memory_region_init_io(&s->low_mem, owner, &cirrus_vga_mem_ops, s,\n                          \"cirrus-low-memory\", 0x20000);\n    memory_region_add_subregion(&s->low_mem_container, 0, &s->low_mem);\n    for (i = 0; i < 2; ++i) {\n        static const char *names[] = { \"vga.bank0\", \"vga.bank1\" };\n        MemoryRegion *bank = &s->cirrus_bank[i];\n        memory_region_init_alias(bank, owner, names[i], &s->vga.vram,\n                                 0, 0x8000);\n        memory_region_set_enabled(bank, false);\n        memory_region_add_subregion_overlap(&s->low_mem_container, i * 0x8000,\n                                            bank, 1);\n    }\n    memory_region_add_subregion_overlap(system_memory,\n                                        isa_mem_base + 0x000a0000,\n                                        &s->low_mem_container,\n                                        1);\n    memory_region_set_coalescing(&s->low_mem);\n\n    memory_region_init_io(&s->cirrus_linear_io, owner, &cirrus_linear_io_ops, s,\n                          \"cirrus-linear-io\", s->vga.vram_size_mb\n                                              * 1024 * 1024);\n    memory_region_set_flush_coalesced(&s->cirrus_linear_io);\n\n    memory_region_init_io(&s->cirrus_linear_bitblt_io, owner,\n                          &cirrus_linear_bitblt_io_ops,\n                          s,\n                          \"cirrus-bitblt-mmio\",\n                          0x400000);\n    memory_region_set_flush_coalesced(&s->cirrus_linear_bitblt_io);\n\n    memory_region_init_io(&s->cirrus_mmio_io, owner, &cirrus_mmio_io_ops, s,\n                          \"cirrus-mmio\", CIRRUS_PNPMMIO_SIZE);\n    memory_region_set_flush_coalesced(&s->cirrus_mmio_io);\n\n    s->real_vram_size =\n        (s->device_id == CIRRUS_ID_CLGD5446) ? 4096 * 1024 : 2048 * 1024;\n\n    s->cirrus_addr_mask = s->real_vram_size - 1;\n    s->linear_mmio_mask = s->real_vram_size - 256;\n\n    s->vga.get_bpp = cirrus_get_bpp;\n    s->vga.get_offsets = cirrus_get_offsets;\n    s->vga.get_resolution = cirrus_get_resolution;\n    s->vga.cursor_invalidate = cirrus_cursor_invalidate;\n    s->vga.cursor_draw_line = cirrus_cursor_draw_line;\n\n    qemu_register_reset(cirrus_reset, s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8260, "func": "XRecordAllocRange(void)\n{\n    return (XRecordRange*)Xcalloc(1, sizeof(XRecordRange));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7681, "func": "static int handle_open(FsContext *ctx, V9fsPath *fs_path,\n                       int flags, V9fsFidOpenState *fs)\n{\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fs->fd = open_by_handle(data->mountfd, fs_path->data, flags);\n    return fs->fd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8137, "func": "void Gfx::opSetCacheDevice(Object args[], int numArgs) {\n  out->type3D1(state, args[0].getNum(), args[1].getNum(),\n\t       args[2].getNum(), args[3].getNum(),\n\t       args[4].getNum(), args[5].getNum());\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8018, "func": "void vnc_display_open(DisplayState *ds, const char *display, Error **errp)\n{\n    VncDisplay *vs = vnc_display;\n    const char *options;\n    int password = 0;\n    int reverse = 0;\n#ifdef CONFIG_VNC_TLS\n    int tls = 0, x509 = 0;\n#endif\n#ifdef CONFIG_VNC_SASL\n    int sasl = 0;\n    int saslErr;\n#endif\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n    int acl = 0;\n#endif\n    int lock_key_sync = 1;\n\n    if (!vnc_display) {\n        error_setg(errp, \"VNC display not active\");\n        return;\n    }\n    vnc_display_close(ds);\n    if (strcmp(display, \"none\") == 0)\n        return;\n\n    vs->display = g_strdup(display);\n    vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n\n    options = display;\n    while ((options = strchr(options, ','))) {\n        options++;\n        if (strncmp(options, \"password\", 8) == 0) {\n            if (fips_get_state()) {\n                error_setg(errp,\n                           \"VNC password auth disabled due to FIPS mode, \"\n                           \"consider using the VeNCrypt or SASL authentication \"\n                           \"methods as an alternative\");\n                goto fail;\n            }\n            password = 1; \n        } else if (strncmp(options, \"reverse\", 7) == 0) {\n            reverse = 1;\n        } else if (strncmp(options, \"no-lock-key-sync\", 16) == 0) {\n            lock_key_sync = 0;\n#ifdef CONFIG_VNC_SASL\n        } else if (strncmp(options, \"sasl\", 4) == 0) {\n            sasl = 1; \n#endif\n#ifdef CONFIG_VNC_WS\n        } else if (strncmp(options, \"websocket\", 9) == 0) {\n            char *start, *end;\n            vs->websocket = 1;\n\n            start = strchr(options, '=');\n            end = strchr(options, ',');\n            if (start && (!end || (start < end))) {\n                int len = end ? end-(start+1) : strlen(start+1);\n                if (len < 6) {\n                    char  *host = NULL, *port = NULL, *host_end = NULL;\n                    port = g_strndup(start + 1, len);\n\n                    end = strchr(display, ',');\n                    host_end = g_strrstr_len(display, end - display, \":\");\n\n                    if (host_end) {\n                        host = g_strndup(display, host_end - display + 1);\n                    } else {\n                        host = g_strndup(\":\", 1);\n                    }\n                    vs->ws_display = g_strconcat(host, port, NULL);\n                    g_free(host);\n                    g_free(port);\n                }\n            }\n#endif \n#ifdef CONFIG_VNC_TLS\n        } else if (strncmp(options, \"tls\", 3) == 0) {\n            tls = 1; \n        } else if (strncmp(options, \"x509\", 4) == 0) {\n            char *start, *end;\n            x509 = 1; \n            if (strncmp(options, \"x509verify\", 10) == 0)\n                vs->tls.x509verify = 1; \n\n            start = strchr(options, '=');\n            end = strchr(options, ',');\n            if (start && (!end || (start < end))) {\n                int len = end ? end-(start+1) : strlen(start+1);\n                char *path = g_strndup(start + 1, len);\n\n                VNC_DEBUG(\"Trying certificate path '%s'\\n\", path);\n                if (vnc_tls_set_x509_creds_dir(vs, path) < 0) {\n                    error_setg(errp, \"Failed to find x509 certificates/keys in %s\", path);\n                    g_free(path);\n                    goto fail;\n                }\n                g_free(path);\n            } else {\n                error_setg(errp, \"No certificate path provided\");\n                goto fail;\n            }\n#endif\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n        } else if (strncmp(options, \"acl\", 3) == 0) {\n            acl = 1;\n#endif\n        } else if (strncmp(options, \"lossy\", 5) == 0) {\n#ifdef CONFIG_VNC_JPEG\n            vs->lossy = true;\n#endif\n        } else if (strncmp(options, \"non-adaptive\", 12) == 0) {\n            vs->non_adaptive = true;\n        } else if (strncmp(options, \"share=\", 6) == 0) {\n            if (strncmp(options+6, \"ignore\", 6) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_IGNORE;\n            } else if (strncmp(options+6, \"allow-exclusive\", 15) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n            } else if (strncmp(options+6, \"force-shared\", 12) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n            } else {\n                error_setg(errp, \"unknown vnc share= option\");\n                goto fail;\n            }\n        }\n    }\n\n    if (!vs->lossy) {\n        vs->non_adaptive = true;\n    }\n\n#ifdef CONFIG_VNC_TLS\n    if (acl && x509 && vs->tls.x509verify) {\n        if (!(vs->tls.acl = qemu_acl_init(\"vnc.x509dname\"))) {\n            fprintf(stderr, \"Failed to create x509 dname ACL\\n\");\n            exit(1);\n        }\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (acl && sasl) {\n        if (!(vs->sasl.acl = qemu_acl_init(\"vnc.username\"))) {\n            fprintf(stderr, \"Failed to create username ACL\\n\");\n            exit(1);\n        }\n    }\n#endif\n\n    if (password) {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n            }\n        } else {\n#endif \n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n            vs->auth = VNC_AUTH_VNC;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif \n#ifdef CONFIG_VNC_SASL\n    } else if (sasl) {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n            }\n        } else {\n#endif \n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n            vs->auth = VNC_AUTH_SASL;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif \n#endif \n    } else {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n            }\n        } else {\n#endif\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n            vs->auth = VNC_AUTH_NONE;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif\n    }\n\n#ifdef CONFIG_VNC_SASL\n    if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {\n        error_setg(errp, \"Failed to initialize SASL auth: %s\",\n                   sasl_errstring(saslErr, NULL, NULL));\n        goto fail;\n    }\n#endif\n    vs->lock_key_sync = lock_key_sync;\n\n    if (reverse) {\n        int csock;\n        vs->lsock = -1;\n#ifdef CONFIG_VNC_WS\n        vs->lwebsock = -1;\n#endif\n        if (strncmp(display, \"unix:\", 5) == 0) {\n            csock = unix_connect(display+5, errp);\n        } else {\n            csock = inet_connect(display, errp);\n        }\n        if (csock < 0) {\n            goto fail;\n        }\n        vnc_connect(vs, csock, false, false);\n    } else {\n        char *dpy;\n        dpy = g_malloc(256);\n        if (strncmp(display, \"unix:\", 5) == 0) {\n            pstrcpy(dpy, 256, \"unix:\");\n            vs->lsock = unix_listen(display+5, dpy+5, 256-5, errp);\n        } else {\n            vs->lsock = inet_listen(display, dpy, 256,\n                                    SOCK_STREAM, 5900, errp);\n            if (vs->lsock < 0) {\n                g_free(dpy);\n                goto fail;\n            }\n#ifdef CONFIG_VNC_WS\n            if (vs->websocket) {\n                if (vs->ws_display) {\n                    vs->lwebsock = inet_listen(vs->ws_display, NULL, 256,\n                        SOCK_STREAM, 0, errp);\n                } else {\n                    vs->lwebsock = inet_listen(vs->display, NULL, 256,\n                        SOCK_STREAM, 5700, errp);\n                }\n\n                if (vs->lwebsock < 0) {\n                    if (vs->lsock) {\n                        close(vs->lsock);\n                        vs->lsock = -1;\n                    }\n                    g_free(dpy);\n                    goto fail;\n                }\n            }\n#endif \n        }\n        g_free(vs->display);\n        vs->display = dpy;\n        qemu_set_fd_handler2(vs->lsock, NULL,\n                vnc_listen_regular_read, NULL, vs);\n#ifdef CONFIG_VNC_WS\n        if (vs->websocket) {\n            qemu_set_fd_handler2(vs->lwebsock, NULL,\n                    vnc_listen_websocket_read, NULL, vs);\n        }\n#endif \n    }\n    return;\n\nfail:\n    g_free(vs->display);\n    vs->display = NULL;\n#ifdef CONFIG_VNC_WS\n    g_free(vs->ws_display);\n    vs->ws_display = NULL;\n#endif \n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8083, "func": "void Gfx::doPatternStroke() {\n  GfxPattern *pattern;\n\n  if (!out->needNonText()) {\n    return;\n  }\n\n  if (!(pattern = state->getStrokePattern())) {\n    return;\n  }\n  switch (pattern->getType()) {\n  case 1:\n    doTilingPatternFill((GfxTilingPattern *)pattern, gTrue, gFalse);\n    break;\n  case 2:\n    doShadingPatternFill((GfxShadingPattern *)pattern, gTrue, gFalse);\n    break;\n  default:\n    error(getPos(), \"Unimplemented pattern type (%d) in stroke\",\n\t  pattern->getType());\n    break;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7766, "func": "static inline __maybe_unused uint64_t h2_get_n64(const struct buffer *b, int o)\n{\n\treturn readv_n64(b_ptr(b, o), b_end(b) - b_ptr(b, o), b->data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186869, "func": "  bool InitSkBitmapFromData(SkBitmap* bitmap,\n                            const char* pixels,\n                            size_t pixels_size) const {\n    if (!bitmap->tryAllocPixels(\n            SkImageInfo::Make(width, height, color_type, alpha_type)))\n      return false;\n    if (pixels_size != bitmap->computeByteSize())\n      return false;\n    memcpy(bitmap->getPixels(), pixels, pixels_size);\n    return true;\n   }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10"}
{"idx": 186567, "func": "bool AcceleratedStaticBitmapImage::CopyToTexture(\n    gpu::gles2::GLES2Interface* dest_gl,\n    GLenum dest_target,\n    GLuint dest_texture_id,\n    bool unpack_premultiply_alpha,\n     bool unpack_flip_y,\n     const IntPoint& dest_point,\n     const IntRect& source_sub_rectangle) {\n  CheckThread();\n   if (!IsValid())\n     return false;\n  DCHECK(texture_holder_->IsCrossThread() ||\n         dest_gl != ContextProviderWrapper()->ContextProvider()->ContextGL());\n\n  EnsureMailbox(kUnverifiedSyncToken, GL_NEAREST);\n\n  dest_gl->WaitSyncTokenCHROMIUM(\n      texture_holder_->GetSyncToken().GetConstData());\n  GLuint source_texture_id = dest_gl->CreateAndConsumeTextureCHROMIUM(\n      texture_holder_->GetMailbox().name);\n  dest_gl->CopySubTextureCHROMIUM(\n      source_texture_id, 0, dest_target, dest_texture_id, 0, dest_point.X(),\n      dest_point.Y(), source_sub_rectangle.X(), source_sub_rectangle.Y(),\n      source_sub_rectangle.Width(), source_sub_rectangle.Height(),\n      unpack_flip_y ? GL_FALSE : GL_TRUE, GL_FALSE,\n      unpack_premultiply_alpha ? GL_FALSE : GL_TRUE);\n  dest_gl->DeleteTextures(1, &source_texture_id);\n\n  gpu::SyncToken sync_token;\n  dest_gl->GenUnverifiedSyncTokenCHROMIUM(sync_token.GetData());\n  texture_holder_->UpdateSyncToken(sync_token);\n\n  return true;\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 7496, "func": "iter_first_in_series (DBusMessageDataIter *iter)\n{\n  int i;\n\n  i = iter->depth;\n  while (i < _DBUS_MESSAGE_DATA_MAX_NESTING)\n    {\n      if (iter->sequence_nos[i] != 0)\n        return FALSE;\n      ++i;\n    }\n  return TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186958, "func": "bool AppCacheDatabase::InsertEntry(const EntryRecord* record) {\n  if (!LazyOpen(kCreateIfNeeded))\n     return false;\n \n   static const char kSql[] =\n      \"INSERT INTO Entries (cache_id, url, flags, response_id, response_size)\"\n      \"  VALUES(?, ?, ?, ?, ?)\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n   statement.BindInt64(0, record->cache_id);\n   statement.BindString(1, record->url.spec());\n   statement.BindInt(2, record->flags);\n   statement.BindInt64(3, record->response_id);\n   statement.BindInt64(4, record->response_size);\n \n   return statement.Run();\n }\n", "target": 1, "flaw_line_index": "6,7"}
{"idx": 186471, "func": " static sk_sp<SkImage> flipSkImageVertically(SkImage* input,\n                                             AlphaDisposition alphaOp) {\n  size_t width = static_cast<size_t>(input->width());\n  size_t height = static_cast<size_t>(input->height());\n   SkImageInfo info = SkImageInfo::MakeN32(input->width(), input->height(),\n                                           (alphaOp == PremultiplyAlpha)\n                                               ? kPremul_SkAlphaType\n                                               : kUnpremul_SkAlphaType);\n  size_t imageRowBytes = width * info.bytesPerPixel();\n   RefPtr<Uint8Array> imagePixels = copySkImageData(input, info);\n   if (!imagePixels)\n     return nullptr;\n  for (size_t i = 0; i < height / 2; i++) {\n    size_t topFirstElement = i * imageRowBytes;\n    size_t topLastElement = (i + 1) * imageRowBytes;\n    size_t bottomFirstElement = (height - 1 - i) * imageRowBytes;\n     std::swap_ranges(imagePixels->data() + topFirstElement,\n                      imagePixels->data() + topLastElement,\n                      imagePixels->data() + bottomFirstElement);\n  }\n  return newSkImageFromRaster(info, std::move(imagePixels), imageRowBytes);\n}\n", "target": 1, "flaw_line_index": "3,4,9,13,14,15,16"}
{"idx": 7455, "func": "ZEND_API void zend_ts_hash_reverse_apply(TsHashTable *ht, apply_func_t apply_func TSRMLS_DC)\n{\n\tbegin_write(ht);\n\tzend_hash_reverse_apply(TS_HASH(ht), apply_func TSRMLS_CC);\n\tend_write(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187271, "func": "void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {\n   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);\n   if (IsAttached())\n     RevokePolicy();\n  ForceDetachAllClients();\n   frame_host_ = nullptr;\n   agent_ptr_.reset();\n   SetFrameTreeNode(nullptr);\n  Release();\n}\n", "target": 1, "flaw_line_index": "5"}
{"idx": 7666, "func": "static int handle_close(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return close(fs->fd);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186743, "func": "Response ServiceWorkerHandler::DeliverPushMessage(\n    const std::string& origin,\n    const std::string& registration_id,\n     const std::string& data) {\n   if (!enabled_)\n     return CreateDomainNotEnabledErrorResponse();\n  if (!process_)\n     return CreateContextErrorResponse();\n   int64_t id = 0;\n   if (!base::StringToInt64(registration_id, &id))\n     return CreateInvalidVersionIdErrorResponse();\n   PushEventPayload payload;\n   if (data.size() > 0)\n     payload.setData(data);\n  BrowserContext::DeliverPushMessage(process_->GetBrowserContext(),\n                                     GURL(origin), id, payload,\n                                     base::Bind(&PushDeliveryNoOp));\n   return Response::OK();\n }\n", "target": 1, "flaw_line_index": "7,15,16,17"}
{"idx": 7996, "func": "int vnc_client_io_error(VncState *vs, int ret, int last_errno)\n{\n    if (ret == 0 || ret == -1) {\n        if (ret == -1) {\n            switch (last_errno) {\n                case EINTR:\n                case EAGAIN:\n#ifdef _WIN32\n                case WSAEWOULDBLOCK:\n#endif\n                    return 0;\n                default:\n                    break;\n            }\n        }\n\n        VNC_DEBUG(\"Closing down client sock: ret %d, errno %d\\n\",\n                  ret, ret < 0 ? last_errno : 0);\n        vnc_disconnect_start(vs);\n\n        return 0;\n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7798, "func": "static int h2c_handle_priority(struct h2c *h2c)\n{\n\tint error;\n\n\tif (h2c->dsi == 0) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->dfl != 5) {\n\t\terror = H2_ERR_FRAME_SIZE_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->dbuf->i < h2c->dfl)\n\t\treturn 0;\n\n\tif (h2_get_n32(h2c->dbuf, 0) == h2c->dsi) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\treturn 1;\n\n conn_err:\n\th2c_error(h2c, error);\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7608, "func": "static void cirrus_vga_register_types(void)\n{\n    type_register_static(&isa_cirrus_vga_info);\n    type_register_static(&cirrus_vga_info);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187227, "func": "static void hid_close(int sub_api, struct libusb_device_handle *dev_handle)\n{\n\tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n\tHANDLE file_handle;\n\tint i;\n\tif (!api_hid_available)\n\t\treturn;\n\tfor (i = 0; i < USB_MAXINTERFACES; i++) {\n\t\tif (priv->usb_interface[i].apib->id == USB_API_HID) {\n\t\t\tfile_handle = handle_priv->interface_handle[i].api_handle;\n\t\t\tif ( (file_handle != 0) && (file_handle != INVALID_HANDLE_VALUE)) {\n\t\t\t\tCloseHandle(file_handle);\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17"}
{"idx": 186884, "func": "void BaseRenderingContext2D::drawImage(ScriptState* script_state,\n                                       CanvasImageSource* image_source,\n                                       double sx,\n                                       double sy,\n                                       double sw,\n                                       double sh,\n                                       double dx,\n                                       double dy,\n                                       double dw,\n                                       double dh,\n                                       ExceptionState& exception_state) {\n  if (!DrawingCanvas())\n    return;\n\n  double start_time = 0;\n  Optional<CustomCountHistogram> timer;\n  if (!IsPaint2D()) {\n    start_time = WTF::MonotonicallyIncreasingTime();\n    if (GetImageBuffer() && GetImageBuffer()->IsAccelerated()) {\n      if (image_source->IsVideoElement()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_video_gpu,\n            (\"Blink.Canvas.DrawImage.Video.GPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_video_gpu);\n      } else if (image_source->IsCanvasElement()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_canvas_gpu,\n            (\"Blink.Canvas.DrawImage.Canvas.GPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_canvas_gpu);\n      } else if (image_source->IsSVGSource()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_svggpu,\n            (\"Blink.Canvas.DrawImage.SVG.GPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_svggpu);\n      } else if (image_source->IsImageBitmap()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_image_bitmap_gpu,\n            (\"Blink.Canvas.DrawImage.ImageBitmap.GPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_image_bitmap_gpu);\n      } else if (image_source->IsOffscreenCanvas()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_offscreencanvas_gpu,\n            (\"Blink.Canvas.DrawImage.OffscreenCanvas.GPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_offscreencanvas_gpu);\n      } else {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_others_gpu,\n            (\"Blink.Canvas.DrawImage.Others.GPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_others_gpu);\n      }\n    } else {\n      if (image_source->IsVideoElement()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_video_cpu,\n            (\"Blink.Canvas.DrawImage.Video.CPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_video_cpu);\n      } else if (image_source->IsCanvasElement()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_canvas_cpu,\n            (\"Blink.Canvas.DrawImage.Canvas.CPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_canvas_cpu);\n      } else if (image_source->IsSVGSource()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_svgcpu,\n            (\"Blink.Canvas.DrawImage.SVG.CPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_svgcpu);\n      } else if (image_source->IsImageBitmap()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_image_bitmap_cpu,\n            (\"Blink.Canvas.DrawImage.ImageBitmap.CPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_image_bitmap_cpu);\n      } else if (image_source->IsOffscreenCanvas()) {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_offscreencanvas_cpu,\n            (\"Blink.Canvas.DrawImage.OffscreenCanvas.CPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_offscreencanvas_cpu);\n      } else {\n        DEFINE_THREAD_SAFE_STATIC_LOCAL(\n            CustomCountHistogram, scoped_us_counter_others_cpu,\n            (\"Blink.Canvas.DrawImage.Others.CPU\", 0, 10000000, 50));\n        timer.emplace(scoped_us_counter_others_cpu);\n      }\n    }\n  }\n\n  scoped_refptr<Image> image;\n  FloatSize default_object_size(Width(), Height());\n  SourceImageStatus source_image_status = kInvalidSourceImageStatus;\n  if (!image_source->IsVideoElement()) {\n    AccelerationHint hint =\n        (HasImageBuffer() && GetImageBuffer()->IsAccelerated())\n            ? kPreferAcceleration\n            : kPreferNoAcceleration;\n    image = image_source->GetSourceImageForCanvas(&source_image_status, hint,\n                                                  kSnapshotReasonDrawImage,\n                                                  default_object_size);\n    if (source_image_status == kUndecodableSourceImageStatus) {\n      exception_state.ThrowDOMException(\n          kInvalidStateError,\n          \"The HTMLImageElement provided is in the 'broken' state.\");\n    }\n    if (!image || !image->width() || !image->height())\n      return;\n  } else {\n    if (!static_cast<HTMLVideoElement*>(image_source)->HasAvailableVideoFrame())\n      return;\n  }\n\n  if (!std::isfinite(dx) || !std::isfinite(dy) || !std::isfinite(dw) ||\n      !std::isfinite(dh) || !std::isfinite(sx) || !std::isfinite(sy) ||\n      !std::isfinite(sw) || !std::isfinite(sh) || !dw || !dh || !sw || !sh)\n    return;\n\n  FloatRect src_rect = NormalizeRect(FloatRect(sx, sy, sw, sh));\n  FloatRect dst_rect = NormalizeRect(FloatRect(dx, dy, dw, dh));\n  FloatSize image_size = image_source->ElementSize(default_object_size);\n\n  ClipRectsToImageRect(FloatRect(FloatPoint(), image_size), &src_rect,\n                       &dst_rect);\n\n  image_source->AdjustDrawRects(&src_rect, &dst_rect);\n\n  if (src_rect.IsEmpty())\n    return;\n\n  DisableDeferralReason reason = kDisableDeferralReasonUnknown;\n  if (ShouldDisableDeferral(image_source, &reason))\n    DisableDeferral(reason);\n  else if (image->IsTextureBacked())\n    DisableDeferral(kDisableDeferralDrawImageWithTextureBackedSourceImage);\n\n  ValidateStateStack();\n\n  WillDrawImage(image_source);\n\n  ValidateStateStack();\n\n  ImageBuffer* buffer = GetImageBuffer();\n  if (buffer && buffer->IsAccelerated() && !image_source->IsAccelerated()) {\n    float src_area = src_rect.Width() * src_rect.Height();\n    if (src_area >\n        CanvasHeuristicParameters::kDrawImageTextureUploadHardSizeLimit) {\n      this->DisableAcceleration();\n    } else if (src_area > CanvasHeuristicParameters::\n                              kDrawImageTextureUploadSoftSizeLimit) {\n      SkRect bounds = dst_rect;\n      SkMatrix ctm = DrawingCanvas()->getTotalMatrix();\n      ctm.mapRect(&bounds);\n      float dst_area = dst_rect.Width() * dst_rect.Height();\n      if (src_area >\n          dst_area * CanvasHeuristicParameters::\n                         kDrawImageTextureUploadSoftSizeLimitScaleThreshold) {\n        this->DisableAcceleration();\n      }\n    }\n  }\n \n   ValidateStateStack();\n \n  if (OriginClean() &&\n      WouldTaintOrigin(image_source, ExecutionContext::From(script_state))) {\n    SetOriginTainted();\n    ClearResolvedFilters();\n  }\n \n   Draw(\n       [this, &image_source, &image, &src_rect, dst_rect](\n          PaintCanvas* c, const PaintFlags* flags)  \n      {\n        DrawImageInternal(c, image_source, image.get(), src_rect, dst_rect,\n                          flags);\n      },\n      [this, &dst_rect](const SkIRect& clip_bounds)  \n      { return RectContainsTransformedRect(dst_rect, clip_bounds); },\n      dst_rect, CanvasRenderingContext2DState::kImagePaintType,\n      image_source->IsOpaque()\n          ? CanvasRenderingContext2DState::kOpaqueImage\n          : CanvasRenderingContext2DState::kNonOpaqueImage);\n\n  ValidateStateStack();\n\n  if (!IsPaint2D()) {\n    DCHECK(start_time);\n    timer->Count((WTF::MonotonicallyIncreasingTime() - start_time) *\n                 WTF::Time::kMicrosecondsPerSecond);\n  }\n}\n", "target": 1, "flaw_line_index": "163,164,165,166,167"}
{"idx": 7463, "func": "void DBusHelperProxy::stopAction(const QString &action, const QString &helperID)\n{\n    QDBusMessage message;\n    message = QDBusMessage::createMethodCall(helperID, QLatin1String(\"/\"), QLatin1String(\"org.kde.kf5auth\"), QLatin1String(\"stopAction\"));\n\n    QList<QVariant> args;\n    args << action;\n    message.setArguments(args);\n\n    m_busConnection.asyncCall(message);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7769, "func": "static int h2_parse_initial_window_size(char **args, int section_type, struct proxy *curpx,\n                                        struct proxy *defpx, const char *file, int line,\n                                        char **err)\n{\n\tif (too_many_args(1, args, err, NULL))\n\t\treturn -1;\n\n\th2_settings_initial_window_size = atoi(args[1]);\n\tif (h2_settings_initial_window_size < 0) {\n\t\tmemprintf(err, \"'%s' expects a positive numeric value.\", args[0]);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186879, "func": "HeadlessPrintManager::GetPrintParamsFromSettings(\n    const HeadlessPrintSettings& settings) {\n  printing::PrintSettings print_settings;\n  print_settings.set_dpi(printing::kPointsPerInch);\n  print_settings.set_should_print_backgrounds(\n      settings.should_print_backgrounds);\n  print_settings.set_scale_factor(settings.scale);\n  print_settings.SetOrientation(settings.landscape);\n\n  print_settings.set_display_header_footer(settings.display_header_footer);\n  if (print_settings.display_header_footer()) {\n    url::Replacements<char> url_sanitizer;\n    url_sanitizer.ClearUsername();\n    url_sanitizer.ClearPassword();\n    std::string url = printing_rfh_->GetLastCommittedURL()\n                          .ReplaceComponents(url_sanitizer)\n                          .spec();\n    print_settings.set_url(base::UTF8ToUTF16(url));\n  }\n\n  print_settings.set_margin_type(printing::CUSTOM_MARGINS);\n  print_settings.SetCustomMargins(settings.margins_in_points);\n\n  gfx::Rect printable_area_device_units(settings.paper_size_in_points);\n  print_settings.SetPrinterPrintableArea(settings.paper_size_in_points,\n                                         printable_area_device_units, true);\n\n  auto print_params = std::make_unique<PrintMsg_PrintPages_Params>();\n   printing::RenderParamsFromPrintSettings(print_settings,\n                                           &print_params->params);\n   print_params->params.document_cookie = printing::PrintSettings::NewCookie();\n   return print_params;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7596, "func": "static void cirrus_reset(void *opaque)\n{\n    CirrusVGAState *s = opaque;\n\n    vga_common_reset(&s->vga);\n    unmap_linear_vram(s);\n    s->vga.sr[0x06] = 0x0f;\n    if (s->device_id == CIRRUS_ID_CLGD5446) {\n        s->vga.sr[0x1F] = 0x2d;\t\t\n        s->vga.gr[0x18] = 0x0f;             \n        s->vga.sr[0x0f] = 0x98;\n        s->vga.sr[0x17] = 0x20;\n        s->vga.sr[0x15] = 0x04; \n    } else {\n        s->vga.sr[0x1F] = 0x22;\t\t\n        s->vga.sr[0x0F] = CIRRUS_MEMSIZE_2M;\n        s->vga.sr[0x17] = s->bustype;\n        s->vga.sr[0x15] = 0x03; \n    }\n    s->vga.cr[0x27] = s->device_id;\n\n    s->cirrus_hidden_dac_lockindex = 5;\n    s->cirrus_hidden_dac_data = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7972, "func": "static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n{\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n    int i, j, pwlen;\n    unsigned char key[8];\n    time_t now = time(NULL);\n\n    if (!vs->vd->password) {\n        VNC_DEBUG(\"No password configured on server\");\n        goto reject;\n    }\n    if (vs->vd->expires < now) {\n        VNC_DEBUG(\"Password is expired\");\n        goto reject;\n    }\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n    pwlen = strlen(vs->vd->password);\n    for (i=0; i<sizeof(key); i++)\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n    deskey(key, EN0);\n    for (j = 0; j < VNC_AUTH_CHALLENGE_SIZE; j += 8)\n        des(response+j, response+j);\n\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n        VNC_DEBUG(\"Client challenge response did not match\\n\");\n        goto reject;\n    } else {\n        VNC_DEBUG(\"Accepting VNC challenge response\\n\");\n        vnc_write_u32(vs, 0); \n        vnc_flush(vs);\n\n        start_client_init(vs);\n    }\n    return 0;\n\nreject:\n    vnc_write_u32(vs, 1); \n    if (vs->minor >= 8) {\n        static const char err[] = \"Authentication failed\";\n        vnc_write_u32(vs, sizeof(err));\n        vnc_write(vs, err, sizeof(err));\n    }\n    vnc_flush(vs);\n    vnc_client_error(vs);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8192, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n                           uint64_t off, uint32_t max_count)\n{\n    ssize_t err;\n    size_t offset = 7;\n    int read_count;\n    int64_t xattr_len;\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n    xattr_len = fidp->fs.xattr.len;\n    read_count = xattr_len - off;\n    if (read_count > max_count) {\n        read_count = max_count;\n    } else if (read_count < 0) {\n        read_count = 0;\n    }\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n    if (err < 0) {\n        return err;\n    }\n    offset += err;\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n                    ((char *)fidp->fs.xattr.value) + off,\n                    read_count);\n    if (err < 0) {\n        return err;\n    }\n    offset += err;\n    return offset;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187153, "func": " float ScrollableShelfView::CalculatePageScrollingOffset(bool forward) const {\n  float offset = space_for_icons_ - kArrowButtonGroupWidth -\n                  ShelfConfig::Get()->button_size() - GetAppIconEndPadding();\n   if (layout_strategy_ == kShowRightArrowButton)\n     offset -= (kArrowButtonGroupWidth - GetAppIconEndPadding());\n  DCHECK_GT(offset, 0);\n\n  if (!forward)\n    offset = -offset;\n\n  return offset;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187197, "func": "void Navigate(NavigateParams* params) {\n  Browser* source_browser = params->browser;\n  if (source_browser)\n    params->initiating_profile = source_browser->profile();\n  DCHECK(params->initiating_profile);\n\n  if (!AdjustNavigateParamsForURL(params))\n    return;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  const extensions::Extension* extension =\n    extensions::ExtensionRegistry::Get(params->initiating_profile)->\n        enabled_extensions().GetExtensionOrAppByURL(params->url);\n  if (extension && extension->is_platform_app())\n     params->url = GURL(chrome::kExtensionInvalidRequestURL);\n #endif\n \n  if (params->disposition == WindowOpenDisposition::NEW_POPUP &&\n      source_browser && source_browser->window()) {\n    params->disposition =\n        source_browser->window()->GetDispositionForPopupBounds(\n            params->window_bounds);\n  }\n  if (source_browser && source_browser->is_app() &&\n      params->disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB) {\n    params->disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;\n  }\n\n  if (!params->source_contents && params->browser) {\n    params->source_contents =\n        params->browser->tab_strip_model()->GetActiveWebContents();\n  }\n\n  WebContents* contents_to_navigate_or_insert =\n      params->contents_to_insert.get();\n  if (params->switch_to_singleton_tab) {\n    DCHECK_EQ(params->disposition, WindowOpenDisposition::SINGLETON_TAB);\n    contents_to_navigate_or_insert = params->switch_to_singleton_tab;\n  }\n  int singleton_index;\n  std::tie(params->browser, singleton_index) =\n      GetBrowserAndTabForDisposition(*params);\n  if (!params->browser)\n    return;\n  if (singleton_index != -1) {\n    contents_to_navigate_or_insert =\n        params->browser->tab_strip_model()->GetWebContentsAt(singleton_index);\n  }\n#if defined(OS_CHROMEOS)\n  if (source_browser && source_browser != params->browser) {\n    MultiUserWindowManager* manager = MultiUserWindowManager::GetInstance();\n    if (manager) {\n      aura::Window* src_window = source_browser->window()->GetNativeWindow();\n      aura::Window* new_window = params->browser->window()->GetNativeWindow();\n      const AccountId& src_account_id =\n          manager->GetUserPresentingWindow(src_window);\n      if (src_account_id != manager->GetUserPresentingWindow(new_window)) {\n        manager->ShowWindowForUser(new_window, src_account_id);\n      }\n    }\n  }\n#endif\n\n\n  if (GetSourceProfile(params) != params->browser->profile()) {\n    params->opener = nullptr;\n    params->source_contents = nullptr;\n    params->source_site_instance = nullptr;\n    params->referrer = content::Referrer();\n  }\n\n  ScopedBrowserShower shower(params, &contents_to_navigate_or_insert);\n\n  std::unique_ptr<WebContents> contents_to_insert =\n      std::move(params->contents_to_insert);\n\n  NormalizeDisposition(params);\n\n  if (params->window_action == NavigateParams::NO_ACTION &&\n      source_browser != params->browser &&\n      params->browser->tab_strip_model()->empty()) {\n    params->window_action = NavigateParams::SHOW_WINDOW;\n  }\n\n  if (params->window_action == NavigateParams::SHOW_WINDOW &&\n      params->disposition == WindowOpenDisposition::NEW_POPUP &&\n      params->user_gesture == false) {\n    params->window_action = NavigateParams::SHOW_WINDOW_INACTIVE;\n  }\n\n  bool user_initiated =\n      params->transition & ui::PAGE_TRANSITION_FROM_ADDRESS_BAR ||\n      ui::PageTransitionCoreTypeIs(params->transition,\n                                   ui::PAGE_TRANSITION_TYPED) ||\n      ui::PageTransitionCoreTypeIs(params->transition,\n                                   ui::PAGE_TRANSITION_AUTO_BOOKMARK) ||\n      ui::PageTransitionCoreTypeIs(params->transition,\n                                   ui::PAGE_TRANSITION_GENERATED) ||\n      ui::PageTransitionCoreTypeIs(params->transition,\n                                   ui::PAGE_TRANSITION_AUTO_TOPLEVEL) ||\n      ui::PageTransitionCoreTypeIs(params->transition,\n                                   ui::PAGE_TRANSITION_RELOAD) ||\n      ui::PageTransitionCoreTypeIs(params->transition,\n                                   ui::PAGE_TRANSITION_KEYWORD);\n\n  bool swapped_in_prerender = false;\n\n  if (!contents_to_navigate_or_insert) {\n    DCHECK(!params->url.is_empty());\n    if (params->disposition != WindowOpenDisposition::CURRENT_TAB) {\n      contents_to_insert = CreateTargetContents(*params, params->url);\n      contents_to_navigate_or_insert = contents_to_insert.get();\n    } else {\n      DCHECK(params->source_contents);\n      contents_to_navigate_or_insert = params->source_contents;\n\n      prerender::PrerenderManager::Params prerender_params(\n          params, params->source_contents);\n\n      swapped_in_prerender = SwapInPrerender(params->url, &prerender_params);\n      if (swapped_in_prerender)\n        contents_to_navigate_or_insert = prerender_params.replaced_contents;\n    }\n\n    if (user_initiated)\n      contents_to_navigate_or_insert->NavigatedByUser();\n\n    if (!swapped_in_prerender) {\n      if (!HandleNonNavigationAboutURL(params->url)) {\n\n        LoadURLInContents(contents_to_navigate_or_insert, params->url, params);\n      }\n    }\n  } else {\n  }\n\n  if (params->source_contents &&\n      (params->disposition == WindowOpenDisposition::NEW_FOREGROUND_TAB ||\n       params->disposition == WindowOpenDisposition::NEW_WINDOW) &&\n      (params->tabstrip_add_types & TabStripModel::ADD_INHERIT_OPENER))\n    params->source_contents->Focus();\n\n  if (params->source_contents == contents_to_navigate_or_insert ||\n      (swapped_in_prerender &&\n       params->disposition == WindowOpenDisposition::CURRENT_TAB)) {\n    params->browser->UpdateUIForNavigationInTab(\n        contents_to_navigate_or_insert, params->transition,\n        params->window_action, user_initiated);\n  } else if (singleton_index == -1) {\n    if (params->tabstrip_index != -1)\n      params->tabstrip_add_types |= TabStripModel::ADD_FORCE_INDEX;\n\n    DCHECK(contents_to_insert);\n    params->browser->tab_strip_model()->AddWebContents(\n        std::move(contents_to_insert), params->tabstrip_index,\n        params->transition, params->tabstrip_add_types);\n  }\n\n  if (singleton_index >= 0) {\n    if (params->disposition == WindowOpenDisposition::SWITCH_TO_TAB &&\n        params->browser != source_browser)\n      params->window_action = NavigateParams::SHOW_WINDOW;\n\n    if (contents_to_navigate_or_insert->IsCrashed()) {\n      contents_to_navigate_or_insert->GetController().Reload(\n          content::ReloadType::NORMAL, true);\n    } else if (params->path_behavior == NavigateParams::IGNORE_AND_NAVIGATE &&\n               contents_to_navigate_or_insert->GetURL() != params->url) {\n      LoadURLInContents(contents_to_navigate_or_insert, params->url, params);\n    }\n\n    if (params->source_contents != contents_to_navigate_or_insert) {\n      params->browser->tab_strip_model()->ActivateTabAt(singleton_index,\n                                                        user_initiated);\n      if (params->disposition == WindowOpenDisposition::SWITCH_TO_TAB) {\n        if (params->source_contents->GetController().CanGoBack() ||\n            (params->source_contents->GetLastCommittedURL().spec() !=\n                 chrome::kChromeUINewTabURL &&\n             params->source_contents->GetLastCommittedURL().spec() !=\n                 chrome::kChromeSearchLocalNtpUrl &&\n             params->source_contents->GetLastCommittedURL().spec() !=\n                 url::kAboutBlankURL))\n          params->source_contents->Focus();\n        else\n          params->source_contents->Close();\n      }\n    }\n  }\n\n  if (params->disposition != WindowOpenDisposition::CURRENT_TAB) {\n    content::NotificationService::current()->Notify(\n        chrome::NOTIFICATION_TAB_ADDED,\n        content::Source<content::WebContentsDelegate>(params->browser),\n        content::Details<WebContents>(contents_to_navigate_or_insert));\n  }\n\n  params->navigated_or_inserted_contents = contents_to_navigate_or_insert;\n}\n", "target": 1, "flaw_line_index": "19,20,21,22,23,24,25"}
{"idx": 8084, "func": "void Gfx::doRadialShFill(GfxRadialShading *shading) {\n  double xMin, yMin, xMax, yMax;\n  double x0, y0, r0, x1, y1, r1, t0, t1;\n  int nComps;\n  GfxColor colorA, colorB;\n  double xa, ya, xb, yb, ra, rb;\n  double ta, tb, sa, sb;\n  double sz, xz, yz, sMin, sMax;\n  GBool enclosed;\n  int ia, ib, k, n;\n  double *ctm;\n  double theta, alpha, angle, t;\n  GBool needExtend = gTrue;\n\n  shading->getCoords(&x0, &y0, &r0, &x1, &y1, &r1);\n  t0 = shading->getDomain0();\n  t1 = shading->getDomain1();\n  nComps = shading->getColorSpace()->getNComps();\n\n  if (x0 == x1 && y0 == y1) {\n    enclosed = gTrue;\n    theta = 0; \n    sz = 0; \n  } else if (r0 == r1) {\n    enclosed = gFalse;\n    theta = 0;\n    sz = 0; \n  } else {\n    sz = -r0 / (r1 - r0);\n    xz = x0 + sz * (x1 - x0);\n    yz = y0 + sz * (y1 - y0);\n    enclosed = (xz - x0) * (xz - x0) + (yz - y0) * (yz - y0) <= r0 * r0;\n    theta = asin(r0 / sqrt((x0 - xz) * (x0 - xz) + (y0 - yz) * (y0 - yz)));\n    if (r0 > r1) {\n      theta = -theta;\n    }\n  }\n  if (enclosed) {\n    alpha = 0;\n  } else {\n    alpha = atan2(y1 - y0, x1 - x0);\n  }\n\n  state->getUserClipBBox(&xMin, &yMin, &xMax, &yMax);\n  if (enclosed) {\n    sMin = 0;\n    sMax = 1;\n  } else {\n    sMin = 1;\n    sMax = 0;\n    if ((x1 + r1) - (x0 + r0) != 0) {\n      sa = (xMin - (x0 + r0)) / ((x1 + r1) - (x0 + r0));\n      if (sa < sMin) {\n\tsMin = sa;\n      } else if (sa > sMax) {\n\tsMax = sa;\n      }\n    }\n    if ((x1 - r1) - (x0 - r0) != 0) {\n      sa = (xMax - (x0 - r0)) / ((x1 - r1) - (x0 - r0));\n      if (sa < sMin) {\n\tsMin = sa;\n      } else if (sa > sMax) {\n\tsMax = sa;\n      }\n    }\n    if ((y1 + r1) - (y0 + r0) != 0) {\n      sa = (yMin - (y0 + r0)) / ((y1 + r1) - (y0 + r0));\n      if (sa < sMin) {\n\tsMin = sa;\n      } else if (sa > sMax) {\n\tsMax = sa;\n      }\n    }\n    if ((y1 - r1) - (y0 - r0) != 0) {\n      sa = (yMax - (y0 - r0)) / ((y1 - r1) - (y0 - r0));\n      if (sa < sMin) {\n\tsMin = sa;\n      } else if (sa > sMax) {\n\tsMax = sa;\n      }\n    }\n    if (r0 < r1) {\n      if (sMin < sz) {\n\tsMin = sz;\n      }\n    } else if (r0 > r1) {\n      if (sMax > sz) {\n\tsMax = sz;\n      }\n    }\n    if (!shading->getExtend0() && sMin < 0) {\n      sMin = 0;\n    }\n    if (!shading->getExtend1() && sMax > 1) {\n      sMax = 1;\n    }\n  }\n\n  if (out->useShadedFills() &&\n      out->radialShadedFill(state, shading, sMin, sMax)) {\n    return;\n  }\n\n  ctm = state->getCTM();\n  t = fabs(ctm[0]);\n  if (fabs(ctm[1]) > t) {\n    t = fabs(ctm[1]);\n  }\n  if (fabs(ctm[2]) > t) {\n    t = fabs(ctm[2]);\n  }\n  if (fabs(ctm[3]) > t) {\n    t = fabs(ctm[3]);\n  }\n  if (r0 > r1) {\n    t *= r0;\n  } else {\n    t *= r1;\n  }\n  if (t < 1) {\n    n = 3;\n  } else {\n    n = (int)(M_PI / acos(1 - 0.1 / t));\n    if (n < 3) {\n      n = 3;\n    } else if (n > 200) {\n      n = 200;\n    }\n  }\n\n  ia = 0;\n  sa = sMin;\n  ta = t0 + sa * (t1 - t0);\n  xa = x0 + sa * (x1 - x0);\n  ya = y0 + sa * (y1 - y0);\n  ra = r0 + sa * (r1 - r0);\n  if (ta < t0) {\n    shading->getColor(t0, &colorA);\n  } else if (ta > t1) {\n    shading->getColor(t1, &colorA);\n  } else {\n    shading->getColor(ta, &colorA);\n  }\n\n  needExtend = !out->radialShadedSupportExtend(state, shading);\n\n  while (ia < radialMaxSplits) {\n\n    ib = radialMaxSplits;\n    sb = sMax;\n    tb = t0 + sb * (t1 - t0);\n    if (tb < t0) {\n      shading->getColor(t0, &colorB);\n    } else if (tb > t1) {\n      shading->getColor(t1, &colorB);\n    } else {\n      shading->getColor(tb, &colorB);\n    }\n    while (ib - ia > 1) {\n      if (isSameGfxColor(colorB, colorA, nComps, radialColorDelta) && ib < radialMaxSplits) {\n\tGfxColor colorC;\n\tint ic = (ia + ib) / 2;\n\tdouble sc = sMin + ((double)ic / (double)radialMaxSplits) * (sMax - sMin);\n\tdouble tc = t0 + sc * (t1 - t0);\n\tif (tc < t0) {\n\t  shading->getColor(t0, &colorC);\n\t} else if (tc > t1) {\n\t  shading->getColor(t1, &colorC);\n\t} else {\n\t  shading->getColor(tc, &colorC);\n\t}\n\tif (isSameGfxColor(colorC, colorA, nComps, radialColorDelta))\n\t  break;\n      }\n      ib = (ia + ib) / 2;\n      sb = sMin + ((double)ib / (double)radialMaxSplits) * (sMax - sMin);\n      tb = t0 + sb * (t1 - t0);\n      if (tb < t0) {\n\tshading->getColor(t0, &colorB);\n      } else if (tb > t1) {\n\tshading->getColor(t1, &colorB);\n      } else {\n\tshading->getColor(tb, &colorB);\n      }\n    }\n\n    xb = x0 + sb * (x1 - x0);\n    yb = y0 + sb * (y1 - y0);\n    rb = r0 + sb * (r1 - r0);\n\n    for (k = 0; k < nComps; ++k) {\n      colorA.c[k] = (colorA.c[k] + colorB.c[k]) / 2;\n    }\n    state->setFillColor(&colorA);\n    if (out->useFillColorStop())\n      out->updateFillColorStop(state, (sa - sMin)/(sMax - sMin));\n    else\n      out->updateFillColor(state);\n\n    if (needExtend) {\n      if (enclosed) {\n        state->moveTo(xa + ra, ya);\n        for (k = 1; k < n; ++k) {\n\t  angle = ((double)k / (double)n) * 2 * M_PI;\n\t  state->lineTo(xa + ra * cos(angle), ya + ra * sin(angle));\n        }\n        state->closePath();\n\n        state->moveTo(xb + rb, yb);\n        for (k = 1; k < n; ++k) {\n\t  angle = -((double)k / (double)n) * 2 * M_PI;\n\t  state->lineTo(xb + rb * cos(angle), yb + rb * sin(angle));\n        }\n        state->closePath();\n      } else {\n        state->moveTo(xa + ra * cos(alpha + theta + 0.5 * M_PI),\n\t\t      ya + ra * sin(alpha + theta + 0.5 * M_PI));\n        for (k = 0; k < n; ++k) {\n\t  angle = alpha + theta + 0.5 * M_PI\n\t\t  - ((double)k / (double)n) * (2 * theta + M_PI);\n\t  state->lineTo(xb + rb * cos(angle), yb + rb * sin(angle));\n        }\n\tfor (k = 0; k < n; ++k) {\n\t  angle = alpha - theta - 0.5 * M_PI\n\t\t  + ((double)k / (double)n) * (2 * theta - M_PI);\n\t  state->lineTo(xa + ra * cos(angle), ya + ra * sin(angle));\n\t}\n\tstate->closePath();\n\n\tstate->moveTo(xa + ra * cos(alpha + theta + 0.5 * M_PI),\n\t\t      ya + ra * sin(alpha + theta + 0.5 * M_PI));\n\tfor (k = 0; k < n; ++k) {\n\t  angle = alpha + theta + 0.5 * M_PI\n\t\t  + ((double)k / (double)n) * (-2 * theta + M_PI);\n\t  state->lineTo(xb + rb * cos(angle), yb + rb * sin(angle));\n\t}\n\tfor (k = 0; k < n; ++k) {\n\t  angle = alpha - theta - 0.5 * M_PI\n\t\t  + ((double)k / (double)n) * (2 * theta + M_PI);\n\t  state->lineTo(xa + ra * cos(angle), ya + ra * sin(angle));\n\t}\n\tstate->closePath();\n      }\n    }\n\n    if (!out->useFillColorStop()) {\n      if (!contentIsHidden())\n        out->fill(state);\n      state->clearPath();\n    }\n\n    ia = ib;\n    sa = sb;\n    ta = tb;\n    xa = xb;\n    ya = yb;\n    ra = rb;\n    colorA = colorB;\n  }\n\n  if (out->useFillColorStop()) {\n    state->setFillColor(&colorA);\n    out->updateFillColorStop(state, (sb - sMin)/(sMax - sMin));\n\n    state->moveTo(xMin, yMin);\n    state->lineTo(xMin, yMax);\n    state->lineTo(xMax, yMax);\n    state->lineTo(xMax, yMin);\n    state->closePath();\n\n    if (!contentIsHidden())\n      out->fill(state);\n    state->clearPath();\n  }\n\n  if (!needExtend)\n    return;\n\n  if (enclosed) {\n    if ((shading->getExtend0() && r0 <= r1) ||\n\t(shading->getExtend1() && r1 < r0)) {\n      if (r0 <= r1) {\n\tta = t0;\n\tra = r0;\n\txa = x0;\n\tya = y0;\n      } else {\n\tta = t1;\n\tra = r1;\n\txa = x1;\n\tya = y1;\n      }\n      shading->getColor(ta, &colorA);\n      state->setFillColor(&colorA);\n      out->updateFillColor(state);\n      state->moveTo(xa + ra, ya);\n      for (k = 1; k < n; ++k) {\n\tangle = ((double)k / (double)n) * 2 * M_PI;\n\tstate->lineTo(xa + ra * cos(angle), ya + ra * sin(angle));\n      }\n      state->closePath();\n      if (!contentIsHidden())\n        out->fill(state);\n      state->clearPath();\n    }\n\n    if ((shading->getExtend0() && r0 > r1) ||\n\t(shading->getExtend1() && r1 >= r0)) {\n      if (r0 > r1) {\n\tta = t0;\n\tra = r0;\n\txa = x0;\n\tya = y0;\n      } else {\n\tta = t1;\n\tra = r1;\n\txa = x1;\n\tya = y1;\n      }\n      shading->getColor(ta, &colorA);\n      state->setFillColor(&colorA);\n      out->updateFillColor(state);\n      state->moveTo(xMin, yMin);\n      state->lineTo(xMin, yMax);\n      state->lineTo(xMax, yMax);\n      state->lineTo(xMax, yMin);\n      state->closePath();\n      state->moveTo(xa + ra, ya);\n      for (k = 1; k < n; ++k) {\n\tangle = ((double)k / (double)n) * 2 * M_PI;\n\tstate->lineTo(xa + ra * cos(angle), ya + ra * sin(angle));\n      }\n      state->closePath();\n      if (!contentIsHidden())\n        out->fill(state);\n      state->clearPath();\n    }\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186633, "func": "void FrameFetchContext::AddResourceTiming(const ResourceTimingInfo& info) {\n  if (!document_)\n    return;\n  LocalFrame* frame = document_->GetFrame();\n  if (!frame)\n    return;\n\n  if (info.IsMainResource()) {\n    DCHECK(frame->Owner());\n     frame->Owner()->AddResourceTiming(info);\n    frame->DidSendResourceTimingInfoToParent();\n     return;\n   }\n \n  DOMWindowPerformance::performance(*document_->domWindow())\n      ->GenerateAndAddResourceTiming(info);\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 8197, "func": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\n    }\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8289, "func": "Time XRRTimes (Display *dpy, int screen, Time *config_timestamp)\n{\n  XRRScreenConfiguration *config;\n  XExtDisplayInfo *info = XRRFindDisplay(dpy);\n  Time ts;\n\n  LockDisplay(dpy);\n  if ((config = _XRRValidateCache(dpy, info, screen))) {\n      *config_timestamp = config->config_timestamp;\n      ts = config->timestamp;\n      UnlockDisplay(dpy);\n      return ts;\n    } else {\n      UnlockDisplay(dpy);\n\treturn CurrentTime;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8015, "func": "static void vnc_display_close(DisplayState *ds)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs)\n        return;\n    g_free(vs->display);\n    vs->display = NULL;\n    if (vs->lsock != -1) {\n        qemu_set_fd_handler2(vs->lsock, NULL, NULL, NULL, NULL);\n        close(vs->lsock);\n        vs->lsock = -1;\n    }\n#ifdef CONFIG_VNC_WS\n    g_free(vs->ws_display);\n    vs->ws_display = NULL;\n    if (vs->lwebsock != -1) {\n        qemu_set_fd_handler2(vs->lwebsock, NULL, NULL, NULL, NULL);\n        close(vs->lwebsock);\n        vs->lwebsock = -1;\n    }\n#endif \n    vs->auth = VNC_AUTH_INVALID;\n#ifdef CONFIG_VNC_TLS\n    vs->subauth = VNC_AUTH_INVALID;\n    vs->tls.x509verify = 0;\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186968, "func": "  void StoreExistingGroupExistingCache() {\n\n     MakeCacheAndGroup(kManifestUrl, 1, 1, true);\n    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);\n \n     base::Time now = base::Time::Now();\n    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::MASTER, 1, 100));\n     cache_->set_update_time(now);\n \n     PushNextTask(base::BindOnce(\n        &AppCacheStorageImplTest::Verify_StoreExistingGroupExistingCache,\n        base::Unretained(this), now));\n\n    EXPECT_EQ(cache_.get(), group_->newest_complete_cache());\n    storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());\n    EXPECT_FALSE(delegate()->stored_group_success_);\n  }\n", "target": 1, "flaw_line_index": "9,13"}
{"idx": 186773, "func": "void VaapiVideoDecodeAccelerator::Cleanup() {\n  DCHECK(task_runner_->BelongsToCurrentThread());\n\n  base::AutoLock auto_lock(lock_);\n  if (state_ == kUninitialized || state_ == kDestroying)\n    return;\n\n  VLOGF(2) << \"Destroying VAVDA\";\n  state_ = kDestroying;\n\n   client_ptr_factory_.reset();\n   weak_this_factory_.InvalidateWeakPtrs();\n \n  input_ready_.Signal();\n  surfaces_available_.Signal();\n  {\n    base::AutoUnlock auto_unlock(lock_);\n    decoder_thread_.Stop();\n  }\n\n  state_ = kUninitialized;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8231, "func": "static void v9fs_rename(void *opaque)\n{\n    int32_t fid;\n    ssize_t err = 0;\n    size_t offset = 7;\n    V9fsString name;\n    int32_t newdirfid;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newdirfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EISDIR;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out;\n    }\n    v9fs_path_write_lock(s);\n    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);\n    v9fs_path_unlock(s);\n    if (!err) {\n        err = offset;\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187289, "func": "void NetworkThrottleManagerImpl::SetTickClockForTesting(\n     std::unique_ptr<base::TickClock> tick_clock) {\n   tick_clock_ = std::move(tick_clock);\n   DCHECK(!outstanding_recomputation_timer_->IsRunning());\n  outstanding_recomputation_timer_ = base::MakeUnique<base::Timer>(\n       false \n,\n       tick_clock_.get());\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 7997, "func": "void vnc_client_read(void *opaque)\n{\n    VncState *vs = opaque;\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn && vs->sasl.runSSF)\n        ret = vnc_client_read_sasl(vs);\n    else\n#endif \n#ifdef CONFIG_VNC_WS\n        if (vs->encode_ws) {\n            ret = vnc_client_read_ws(vs);\n            if (ret == -1) {\n                vnc_disconnect_start(vs);\n                return;\n            } else if (ret == -2) {\n                vnc_client_error(vs);\n                return;\n            }\n        } else\n#endif \n        {\n        ret = vnc_client_read_plain(vs);\n        }\n    if (!ret) {\n        if (vs->csock == -1)\n            vnc_disconnect_finish(vs);\n        return;\n    }\n\n    while (vs->read_handler && vs->input.offset >= vs->read_handler_expect) {\n        size_t len = vs->read_handler_expect;\n        int ret;\n\n        ret = vs->read_handler(vs, vs->input.buffer, len);\n        if (vs->csock == -1) {\n            vnc_disconnect_finish(vs);\n            return;\n        }\n\n        if (!ret) {\n            buffer_advance(&vs->input, len);\n        } else {\n            vs->read_handler_expect = ret;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186911, "func": "void RenderThreadImpl::Init(\n    const scoped_refptr<base::SingleThreadTaskRunner>& resource_task_queue) {\n  TRACE_EVENT0(\"startup\", \"RenderThreadImpl::Init\");\n\n  base::trace_event::TraceLog::GetInstance()->SetThreadSortIndex(\n      base::PlatformThread::CurrentId(),\n      kTraceEventRendererMainThreadSortIndex);\n\n#if BUILDFLAG(USE_EXTERNAL_POPUP_MENU)\n  blink::WebView::SetUseExternalPopupMenus(true);\n#endif\n\n  lazy_tls.Pointer()->Set(this);\n\n  ChildProcess::current()->set_main_thread(this);\n\n  metrics::InitializeSingleSampleMetricsFactory(\n      base::BindRepeating(&CreateSingleSampleMetricsProvider,\n                          message_loop()->task_runner(), GetConnector()));\n\n  gpu_ = ui::Gpu::Create(\n      GetConnector(),\n      IsRunningInMash() ? ui::mojom::kServiceName : mojom::kBrowserServiceName,\n      GetIOTaskRunner());\n\n  viz::mojom::SharedBitmapAllocationNotifierPtr\n      shared_bitmap_allocation_notifier_ptr;\n  GetConnector()->BindInterface(\n      mojom::kBrowserServiceName,\n      mojo::MakeRequest(&shared_bitmap_allocation_notifier_ptr));\n  shared_bitmap_manager_ = std::make_unique<viz::ClientSharedBitmapManager>(\n      viz::mojom::ThreadSafeSharedBitmapAllocationNotifierPtr::Create(\n          shared_bitmap_allocation_notifier_ptr.PassInterface(),\n          GetChannel()->ipc_task_runner_refptr()));\n\n  notification_dispatcher_ =\n      new NotificationDispatcher(thread_safe_sender());\n  AddFilter(notification_dispatcher_->GetFilter());\n\n  resource_dispatcher_.reset(new ResourceDispatcher(\n      this, message_loop()->task_runner()));\n  resource_message_filter_ =\n      new ChildResourceMessageFilter(resource_dispatcher_.get());\n  AddFilter(resource_message_filter_.get());\n  quota_message_filter_ =\n      new QuotaMessageFilter(thread_safe_sender());\n  quota_dispatcher_.reset(new QuotaDispatcher(thread_safe_sender(),\n                                              quota_message_filter_.get()));\n\n  AddFilter(quota_message_filter_->GetFilter());\n\n  auto registry = std::make_unique<service_manager::BinderRegistry>();\n  BlinkInterfaceRegistryImpl interface_registry(registry->GetWeakPtr());\n\n  InitializeWebKit(resource_task_queue, &interface_registry);\n  blink_initialized_time_ = base::TimeTicks::Now();\n\n  webkit_shared_timer_suspended_ = false;\n  widget_count_ = 0;\n  hidden_widget_count_ = 0;\n  idle_notification_delay_in_ms_ = kInitialIdleHandlerDelayMs;\n  idle_notifications_to_skip_ = 0;\n\n  appcache_dispatcher_.reset(\n      new AppCacheDispatcher(Get(), new AppCacheFrontendImpl()));\n  dom_storage_dispatcher_.reset(new DomStorageDispatcher());\n  main_thread_indexed_db_dispatcher_.reset(new IndexedDBDispatcher());\n  main_thread_cache_storage_dispatcher_.reset(\n      new CacheStorageDispatcher(thread_safe_sender()));\n  file_system_dispatcher_.reset(new FileSystemDispatcher());\n\n  resource_dispatch_throttler_.reset(new ResourceDispatchThrottler(\n      static_cast<RenderThread*>(this), renderer_scheduler_.get(),\n      base::TimeDelta::FromSecondsD(kThrottledResourceRequestFlushPeriodS),\n      kMaxResourceRequestsPerFlushWhenThrottled));\n  resource_dispatcher_->set_message_sender(resource_dispatch_throttler_.get());\n\n  blob_message_filter_ = new BlobMessageFilter(GetFileThreadTaskRunner());\n  AddFilter(blob_message_filter_.get());\n  vc_manager_.reset(new VideoCaptureImplManager());\n\n  browser_plugin_manager_.reset(new BrowserPluginManager());\n  AddObserver(browser_plugin_manager_.get());\n\n#if BUILDFLAG(ENABLE_WEBRTC)\n  peer_connection_tracker_.reset(new PeerConnectionTracker());\n  AddObserver(peer_connection_tracker_.get());\n\n  p2p_socket_dispatcher_ = new P2PSocketDispatcher(GetIOTaskRunner().get());\n  AddFilter(p2p_socket_dispatcher_.get());\n\n  peer_connection_factory_.reset(\n      new PeerConnectionDependencyFactory(p2p_socket_dispatcher_.get()));\n\n  aec_dump_message_filter_ = new AecDumpMessageFilter(\n      GetIOTaskRunner(), message_loop()->task_runner());\n\n  AddFilter(aec_dump_message_filter_.get());\n\n#endif  \n\n  audio_input_message_filter_ = new AudioInputMessageFilter(GetIOTaskRunner());\n  AddFilter(audio_input_message_filter_.get());\n\n  scoped_refptr<AudioMessageFilter> audio_message_filter;\n  if (!base::FeatureList::IsEnabled(\n          features::kUseMojoAudioOutputStreamFactory)) {\n    audio_message_filter =\n        base::MakeRefCounted<AudioMessageFilter>(GetIOTaskRunner());\n    AddFilter(audio_message_filter.get());\n  }\n\n  audio_ipc_factory_.emplace(std::move(audio_message_filter),\n                             GetIOTaskRunner());\n\n  midi_message_filter_ = new MidiMessageFilter(GetIOTaskRunner());\n  AddFilter(midi_message_filter_.get());\n\n  AddFilter((new CacheStorageMessageFilter(thread_safe_sender()))->GetFilter());\n\n  AddFilter((new ServiceWorkerContextMessageFilter())->GetFilter());\n\n\n#if defined(USE_AURA)\n  if (IsRunningInMash()) {\n    CreateRenderWidgetWindowTreeClientFactory(GetServiceManagerConnection());\n  }\n#endif\n\n  registry->AddInterface(base::Bind(&SharedWorkerFactoryImpl::Create),\n                         base::ThreadTaskRunnerHandle::Get());\n  GetServiceManagerConnection()->AddConnectionFilter(\n      std::make_unique<SimpleConnectionFilter>(std::move(registry)));\n\n  {\n    auto registry_with_source_info =\n        std::make_unique<service_manager::BinderRegistryWithArgs<\n            const service_manager::BindSourceInfo&>>();\n    registry_with_source_info->AddInterface(\n        base::Bind(&CreateFrameFactory), base::ThreadTaskRunnerHandle::Get());\n    GetServiceManagerConnection()->AddConnectionFilter(\n        std::make_unique<SimpleConnectionFilterWithSourceInfo>(\n            std::move(registry_with_source_info)));\n  }\n\n  GetContentClient()->renderer()->RenderThreadStarted();\n\n  StartServiceManagerConnection();\n\n  GetAssociatedInterfaceRegistry()->AddInterface(\n      base::Bind(&RenderThreadImpl::OnRendererInterfaceRequest,\n                 base::Unretained(this)));\n\n  InitSkiaEventTracer();\n  base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(\n      skia::SkiaMemoryDumpProvider::GetInstance(), \"Skia\", nullptr);\n\n  const base::CommandLine& command_line =\n      *base::CommandLine::ForCurrentProcess();\n\n#if defined(ENABLE_IPC_FUZZER)\n  if (command_line.HasSwitch(switches::kIpcDumpDirectory)) {\n    base::FilePath dump_directory =\n        command_line.GetSwitchValuePath(switches::kIpcDumpDirectory);\n    IPC::ChannelProxy::OutgoingMessageFilter* filter =\n        LoadExternalIPCDumper(dump_directory);\n    GetChannel()->set_outgoing_message_filter(filter);\n  }\n#endif\n\n  cc::SetClientNameForMetrics(\"Renderer\");\n\n  is_threaded_animation_enabled_ =\n      !command_line.HasSwitch(cc::switches::kDisableThreadedAnimation);\n\n  is_zero_copy_enabled_ = command_line.HasSwitch(switches::kEnableZeroCopy);\n  is_partial_raster_enabled_ =\n      !command_line.HasSwitch(switches::kDisablePartialRaster);\n  is_gpu_memory_buffer_compositor_resources_enabled_ = command_line.HasSwitch(\n      switches::kEnableGpuMemoryBufferCompositorResources);\n\n#if defined(OS_MACOSX)\n  is_elastic_overscroll_enabled_ = true;\n#else\n  is_elastic_overscroll_enabled_ = false;\n#endif\n\n  std::string image_texture_target_string =\n      command_line.GetSwitchValueASCII(switches::kContentImageTextureTarget);\n  buffer_to_texture_target_map_ =\n      viz::StringToBufferToTextureTargetMap(image_texture_target_string);\n\n  if (command_line.HasSwitch(switches::kDisableLCDText)) {\n    is_lcd_text_enabled_ = false;\n  } else if (command_line.HasSwitch(switches::kEnableLCDText)) {\n    is_lcd_text_enabled_ = true;\n  } else {\n#if defined(OS_ANDROID)\n    is_lcd_text_enabled_ = false;\n#else\n    is_lcd_text_enabled_ = true;\n#endif\n  }\n\n  if (command_line.HasSwitch(switches::kDisableGpuCompositing))\n    is_gpu_compositing_disabled_ = true;\n\n  is_gpu_rasterization_forced_ =\n      command_line.HasSwitch(switches::kForceGpuRasterization);\n  is_async_worker_context_enabled_ =\n      command_line.HasSwitch(switches::kEnableGpuAsyncWorkerContext);\n\n  if (command_line.HasSwitch(switches::kGpuRasterizationMSAASampleCount)) {\n    std::string string_value = command_line.GetSwitchValueASCII(\n        switches::kGpuRasterizationMSAASampleCount);\n    bool parsed_msaa_sample_count =\n        base::StringToInt(string_value, &gpu_rasterization_msaa_sample_count_);\n    DCHECK(parsed_msaa_sample_count) << string_value;\n    DCHECK_GE(gpu_rasterization_msaa_sample_count_, 0);\n  } else {\n    gpu_rasterization_msaa_sample_count_ = -1;\n  }\n\n  if (command_line.HasSwitch(switches::kDisableDistanceFieldText)) {\n    is_distance_field_text_enabled_ = false;\n  } else if (command_line.HasSwitch(switches::kEnableDistanceFieldText)) {\n    is_distance_field_text_enabled_ = true;\n  } else {\n    is_distance_field_text_enabled_ = false;\n  }\n\n  WebRuntimeFeatures::EnableCompositorImageAnimations(\n      command_line.HasSwitch(switches::kEnableCompositorImageAnimations));\n\n  media::InitializeMediaLibrary();\n\n#if defined(OS_ANDROID)\n  if (!command_line.HasSwitch(switches::kDisableAcceleratedVideoDecode) &&\n      media::MediaCodecUtil::IsMediaCodecAvailable()) {\n    media::EnablePlatformDecoderSupport();\n  }\n#endif\n\n  memory_pressure_listener_.reset(new base::MemoryPressureListener(\n      base::Bind(&RenderThreadImpl::OnMemoryPressure, base::Unretained(this)),\n      base::Bind(&RenderThreadImpl::OnSyncMemoryPressure,\n                 base::Unretained(this))));\n\n  if (base::FeatureList::IsEnabled(features::kMemoryCoordinator)) {\n    base::MemoryPressureListener::SetNotificationsSuppressed(true);\n\n    mojom::MemoryCoordinatorHandlePtr parent_coordinator;\n    GetConnector()->BindInterface(mojom::kBrowserServiceName,\n                                  mojo::MakeRequest(&parent_coordinator));\n    memory_coordinator_ = CreateChildMemoryCoordinator(\n        std::move(parent_coordinator), this);\n  }\n\n  int num_raster_threads = 0;\n  std::string string_value =\n      command_line.GetSwitchValueASCII(switches::kNumRasterThreads);\n  bool parsed_num_raster_threads =\n      base::StringToInt(string_value, &num_raster_threads);\n  DCHECK(parsed_num_raster_threads) << string_value;\n  DCHECK_GT(num_raster_threads, 0);\n\n  categorized_worker_pool_->Start(num_raster_threads);\n\n  discardable_memory::mojom::DiscardableSharedMemoryManagerPtr manager_ptr;\n  if (IsRunningInMash()) {\n#if defined(USE_AURA)\n    GetServiceManagerConnection()->GetConnector()->BindInterface(\n        ui::mojom::kServiceName, &manager_ptr);\n#else\n    NOTREACHED();\n#endif\n  } else {\n    ChildThread::Get()->GetConnector()->BindInterface(\n        mojom::kBrowserServiceName, mojo::MakeRequest(&manager_ptr));\n  }\n\n  discardable_shared_memory_manager_ = std::make_unique<\n      discardable_memory::ClientDiscardableSharedMemoryManager>(\n      std::move(manager_ptr), GetIOTaskRunner());\n\n  base::DiscardableMemoryAllocator::SetInstance(\n      discardable_shared_memory_manager_.get());\n\n  GetConnector()->BindInterface(mojom::kBrowserServiceName,\n                                mojo::MakeRequest(&storage_partition_service_));\n\n#if defined(OS_LINUX)\n  ChildProcess::current()->SetIOThreadPriority(base::ThreadPriority::DISPLAY);\n  ChildThreadImpl::current()->SetThreadPriority(\n      categorized_worker_pool_->background_worker_thread_id(),\n      base::ThreadPriority::BACKGROUND);\n#endif\n\n  process_foregrounded_count_ = 0;\n  needs_to_record_first_active_paint_ = false;\n  was_backgrounded_time_ = base::TimeTicks::Min();\n\n  base::MemoryCoordinatorClientRegistry::GetInstance()->Register(this);\n\n   if (!command_line.HasSwitch(switches::kSingleProcess))\n     base::SequencedWorkerPool::EnableForProcess();\n \n  EVP_set_buggy_rsa_parser(\n      base::FeatureList::IsEnabled(features::kBuggyRSAParser));\n   GetConnector()->BindInterface(mojom::kBrowserServiceName,\n                                 mojo::MakeRequest(&frame_sink_provider_));\n \n  if (!is_gpu_compositing_disabled_) {\n    GetConnector()->BindInterface(\n        mojom::kBrowserServiceName,\n        mojo::MakeRequest(&compositing_mode_reporter_));\n\n    viz::mojom::CompositingModeWatcherPtr watcher_ptr;\n    compositing_mode_watcher_binding_.Bind(mojo::MakeRequest(&watcher_ptr));\n    compositing_mode_reporter_->AddCompositingModeWatcher(\n        std::move(watcher_ptr));\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186841, "func": "void MojoAudioOutputIPC::StreamCreated(\n    mojo::ScopedSharedBufferHandle shared_memory,\n    mojo::ScopedHandle socket) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  DCHECK(delegate_);\n  DCHECK(socket.is_valid());\n  DCHECK(shared_memory.is_valid());\n\n  base::PlatformFile socket_handle;\n  auto result = mojo::UnwrapPlatformFile(std::move(socket), &socket_handle);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n \n   base::SharedMemoryHandle memory_handle;\n  bool read_only = false;\n   size_t memory_length = 0;\n   result = mojo::UnwrapSharedMemoryHandle(\n      std::move(shared_memory), &memory_handle, &memory_length, &read_only);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n  DCHECK(!read_only);\n \n   delegate_->OnStreamCreated(memory_handle, socket_handle);\n }\n", "target": 1, "flaw_line_index": "14,17,19"}
{"idx": 8125, "func": "void Gfx::opEndText(Object args[], int numArgs) {\n  GBool needFill = out->deviceHasTextClip(state);\n  out->endTextObject(state);\n  drawText = gFalse;\n  if (textHaveCSPattern) {\n    if (needFill) {\n      doPatternFill(gTrue);\n    }\n    out->restoreState(state);\n  }\n  textHaveCSPattern = gFalse;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7559, "func": "PHPAPI void var_replace(php_unserialize_data_t *var_hashx, zval *ozval, zval **nzval)\n{\n\tlong i;\n\tvar_entries *var_hash = (*var_hashx)->first;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_replace(%ld): %d\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_PP(nzval));\n#endif\n\t\n\twhile (var_hash) {\n\t\tfor (i = 0; i < var_hash->used_slots; i++) {\n\t\t\tif (var_hash->data[i] == ozval) {\n\t\t\t\tvar_hash->data[i] = *nzval;\n\t\t\t}\n\t\t}\n\t\tvar_hash = var_hash->next;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187098, "func": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (!ShouldAllowSession(session))\n    return false;\n\n   protocol::EmulationHandler* emulation_handler =\n       new protocol::EmulationHandler();\n   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n   session->AddHandler(base::WrapUnique(emulation_handler));\n   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(\n      GetId(),\n      frame_tree_node_ ? frame_tree_node_->devtools_frame_token()\n                       : base::UnguessableToken(),\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::TargetHandler(\n      session->client()->MayAttachToBrowser()\n          ? protocol::TargetHandler::AccessMode::kRegular\n          : protocol::TargetHandler::AccessMode::kAutoAttachOnly,\n      GetId(), GetRendererChannel(), session->GetRootSession())));\n  session->AddHandler(base::WrapUnique(new protocol::PageHandler(\n      emulation_handler, session->client()->MayAffectLocalFiles())));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n  if (!frame_tree_node_ || !frame_tree_node_->parent()) {\n    session->AddHandler(base::WrapUnique(\n        new protocol::TracingHandler(frame_tree_node_, GetIOContext())));\n  }\n\n  if (sessions().empty()) {\n    bool use_video_capture_api = true;\n#ifdef OS_ANDROID\n    if (!CompositorImpl::IsInitialized())\n      use_video_capture_api = false;\n#endif\n    if (!use_video_capture_api)\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 187169, "func": " bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (data_source_)\n     return data_source_->HasSingleOrigin();\n   return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186688, "func": "HeapObjectHeader* NormalPage::findHeaderFromAddress(Address address) {\n  if (address < payload())\n    return nullptr;\n  if (!m_objectStartBitMapComputed)\n    populateObjectStartBitMap();\n  size_t objectOffset = address - payload();\n  size_t objectStartNumber = objectOffset / allocationGranularity;\n  size_t mapIndex = objectStartNumber / 8;\n  ASSERT(mapIndex < objectStartBitMapSize);\n  size_t bit = objectStartNumber & 7;\n  uint8_t byte = m_objectStartBitMap[mapIndex] & ((1 << (bit + 1)) - 1);\n  while (!byte) {\n    ASSERT(mapIndex > 0);\n    byte = m_objectStartBitMap[--mapIndex];\n  }\n  int leadingZeroes = numberOfLeadingZeroes(byte);\n  objectStartNumber = (mapIndex * 8) + 7 - leadingZeroes;\n  objectOffset = objectStartNumber * allocationGranularity;\n  Address objectAddress = objectOffset + payload();\n   HeapObjectHeader* header = reinterpret_cast<HeapObjectHeader*>(objectAddress);\n   if (header->isFree())\n     return nullptr;\n  ASSERT(header->checkHeader());\n   return header;\n }\n", "target": 1, "flaw_line_index": "23"}
{"idx": 187069, "func": " void PaymentRequest::Retry(mojom::PaymentValidationErrorsPtr errors) {\n  if (!client_.is_bound() || !binding_.is_bound()) {\n    DLOG(ERROR) << \"Attempted Retry(), but binding(s) missing.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n  if (!display_handle_) {\n    DLOG(ERROR) << \"Attempted Retry(), but display_handle_ is nullptr.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n   std::string error;\n   if (!PaymentsValidators::IsValidPaymentValidationErrorsFormat(errors,\n                                                                 &error)) {\n    DLOG(ERROR) << error;\n     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);\n     OnConnectionTerminated();\n     return;\n  }\n\n  spec()->Retry(std::move(errors));\n   display_handle_->Retry();\n }\n", "target": 1, "flaw_line_index": "2,3,8,9,17"}
{"idx": 186866, "func": "AccessControlStatus ScriptResource::CalculateAccessControlStatus() const {\n  if (GetCORSStatus() == CORSStatus::kServiceWorkerOpaque)\n    return kOpaqueResource;\n \n  if (IsSameOriginOrCORSSuccessful())\n     return kSharableCrossOrigin;\n \n   return kNotSharableCrossOrigin;\n}\n", "target": 1, "flaw_line_index": "2,3,5"}
{"idx": 7554, "func": "static char *unserialize_str(const unsigned char **p, size_t *len, size_t maxlen)\n{\n\tsize_t i, j;\n\tchar *str = safe_emalloc(*len, 1, 1);\n\tunsigned char *end = *(unsigned char **)p+maxlen;\n\n\tif (end < *p) {\n\t\tefree(str);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < *len; i++) {\n\t\tif (*p >= end) {\n\t\t\tefree(str);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (**p != '\\\\') {\n\t\t\tstr[i] = (char)**p;\n\t\t} else {\n\t\t\tunsigned char ch = 0;\n\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t(*p)++;\n\t\t\t\tif (**p >= '0' && **p <= '9') {\n\t\t\t\t\tch = (ch << 4) + (**p -'0');\n\t\t\t\t} else if (**p >= 'a' && **p <= 'f') {\n\t\t\t\t\tch = (ch << 4) + (**p -'a'+10);\n\t\t\t\t} else if (**p >= 'A' && **p <= 'F') {\n\t\t\t\t\tch = (ch << 4) + (**p -'A'+10);\n\t\t\t\t} else {\n\t\t\t\t\tefree(str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr[i] = (char)ch;\n\t\t}\n\t\t(*p)++;\n\t}\n\tstr[i] = 0;\n\t*len = i;\n\treturn str;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186924, "func": " htmlParseElementInternal(htmlParserCtxtPtr ctxt) {\n     const xmlChar *name;\n     const htmlElemDesc * info;\n    htmlParserNodeInfo node_info = { 0, };\n     int failed;\n \n     if ((ctxt == NULL) || (ctxt->input == NULL)) {\n\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t     \"htmlParseElementInternal: context error\\n\", NULL, NULL);\n\treturn;\n    }\n\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n\n    if (ctxt->record_info) {\n        node_info.begin_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n\tnode_info.begin_line = ctxt->input->line;\n    }\n\n    failed = htmlParseStartTag(ctxt);\n    name = ctxt->name;\n    if ((failed == -1) || (name == NULL)) {\n\tif (CUR == '>')\n\t    NEXT;\n        return;\n    }\n\n    info = htmlTagLookup(name);\n    if (info == NULL) {\n\thtmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n\t             \"Tag %s invalid\\n\", name, NULL);\n    }\n\n    if ((CUR == '/') && (NXT(1) == '>')) {\n        SKIP(2);\n\tif ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n\t    ctxt->sax->endElement(ctxt->userData, name);\n\thtmlnamePop(ctxt);\n\treturn;\n    }\n\n    if (CUR == '>') {\n        NEXT;\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n\t             \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n\n\tif (xmlStrEqual(name, ctxt->name)) {\n\t    nodePop(ctxt);\n\t    htmlnamePop(ctxt);\n\t}\n\n        if (ctxt->record_info)\n            htmlNodeInfoPush(ctxt, &node_info);\n        htmlParserFinishElementParsing(ctxt);\n\treturn;\n    }\n\n    if ((info != NULL) && (info->empty)) {\n\tif ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n\t    ctxt->sax->endElement(ctxt->userData, name);\n\thtmlnamePop(ctxt);\n\treturn;\n    }\n\n    if (ctxt->record_info)\n        htmlNodeInfoPush(ctxt, &node_info);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186588, "func": " bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,\n                                                           const GURL& url) {\n   if (!url.is_valid())\n    return false;  \n\n  if (url == kAboutSrcDocURL)\n    return false;\n \n  if (CanCommitURL(child_id, url))\n     return true;\n \n  {\n    base::AutoLock lock(lock_);\n    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,\n                          url.scheme())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 8178, "func": "void Gfx::pushMarkedContent() {\n  MarkedContentStack *mc = new MarkedContentStack();\n  mc->ocSuppressed = gFalse;\n  mc->next = mcStack;\n  mcStack = mc;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7440, "func": "ZEND_API int zend_ts_hash_add_empty_element(TsHashTable *ht, char *arKey, uint nKeyLength)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_add_empty_element(TS_HASH(ht), arKey, nKeyLength);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7758, "func": "static int h2_buf_available(void *target)\n{\n\tstruct h2c *h2c = target;\n\n\tif ((h2c->flags & H2_CF_DEM_DALLOC) && b_alloc_margin(&h2c->dbuf, 0)) {\n\t\th2c->flags &= ~H2_CF_DEM_DALLOC;\n\t\tif (h2_recv_allowed(h2c))\n\t\t\tconn_xprt_want_recv(h2c->conn);\n\t\treturn 1;\n\t}\n\n\tif ((h2c->flags & H2_CF_MUX_MALLOC) && b_alloc_margin(&h2c->mbuf, 0)) {\n\t\th2c->flags &= ~H2_CF_MUX_MALLOC;\n\t\tif (!(h2c->flags & H2_CF_MUX_BLOCK_ANY))\n\t\t\tconn_xprt_want_send(h2c->conn);\n\n\t\tif (h2c->flags & H2_CF_DEM_MROOM) {\n\t\t\th2c->flags &= ~H2_CF_DEM_MROOM;\n\t\t\tif (h2_recv_allowed(h2c))\n\t\t\t\tconn_xprt_want_recv(h2c->conn);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7749, "func": "  ft_var_load_avar( TT_Face  face )\n  {\n    FT_Stream       stream = FT_FACE_STREAM(face);\n    FT_Memory       memory = stream->memory;\n    GX_Blend        blend  = face->blend;\n    GX_AVarSegment  segment;\n    FT_Error        error = TT_Err_Ok;\n    FT_ULong        version;\n    FT_Long         axisCount;\n    FT_Int          i, j;\n    FT_ULong        table_len;\n\n    FT_UNUSED( error );\n\n\n    blend->avar_checked = TRUE;\n    if ( (error = face->goto_table( face, TTAG_avar, stream, &table_len )) != 0 )\n      return;\n\n    if ( FT_FRAME_ENTER( table_len ) )\n      return;\n\n    version   = FT_GET_LONG();\n    axisCount = FT_GET_LONG();\n\n    if ( version != 0x00010000L                       ||\n         axisCount != (FT_Long)blend->mmvar->num_axis )\n      goto Exit;\n\n    if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )\n      goto Exit;\n\n    segment = &blend->avar_segment[0];\n    for ( i = 0; i < axisCount; ++i, ++segment )\n    {\n      segment->pairCount = FT_GET_USHORT();\n      if ( FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )\n      {\n\n        for ( j = i - 1; j >= 0; --j )\n          FT_FREE( blend->avar_segment[j].correspondence );\n\n        FT_FREE( blend->avar_segment );\n        blend->avar_segment = NULL;\n        goto Exit;\n      }\n\n      for ( j = 0; j < segment->pairCount; ++j )\n      {\n        segment->correspondence[j].fromCoord =\n          FT_GET_SHORT() << 2;    \n        segment->correspondence[j].toCoord =\n          FT_GET_SHORT()<<2;    \n      }\n    }\n\n  Exit:\n    FT_FRAME_EXIT();\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8255, "func": "Status _xvmc_destroy_context (\n    Display *dpy,\n    XvMCContext *context\n)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcDestroyContextReq  *req;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (DestroyContext, req);\n    req->context_id = context->context_id;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return Success;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7862, "func": "uint64_t ram_bytes_total(void)\n{\n    RAMBlock *block;\n    uint64_t total = 0;\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next)\n        total += block->length;\n\n    return total;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7482, "func": "ssize_t pt_getxattr(FsContext *ctx, const char *path, const char *name,\n                    void *value, size_t size)\n{\n    return local_getxattr_nofollow(ctx, path, name, value, size);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187134, "func": " void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n                                                float source_sample_rate) {\n   if (number_of_channels != source_number_of_channels_ ||\n       source_sample_rate != source_sample_rate_) {\n     if (!number_of_channels ||\n        number_of_channels > BaseAudioContext::MaxNumberOfChannels() ||\n        !AudioUtilities::IsValidAudioBufferSampleRate(source_sample_rate)) {\n      DLOG(ERROR) << \"setFormat(\" << number_of_channels << \", \"\n                  << source_sample_rate << \") - unhandled format change\";\n       Locker<MediaElementAudioSourceHandler> locker(*this);\n       source_number_of_channels_ = 0;\n       source_sample_rate_ = 0;\n       return;\n     }\n \n     Locker<MediaElementAudioSourceHandler> locker(*this);\n \n     source_number_of_channels_ = number_of_channels;\n     source_sample_rate_ = source_sample_rate;\n \n    if (source_sample_rate != Context()->sampleRate()) {\n      double scale_factor = source_sample_rate / Context()->sampleRate();\n      multi_channel_resampler_ = std::make_unique<MultiChannelResampler>(\n          scale_factor, number_of_channels);\n    } else {\n      multi_channel_resampler_.reset();\n    }\n\n    {\n      BaseAudioContext::GraphAutoLocker context_locker(Context());\n\n      Output(0).SetNumberOfChannels(number_of_channels);\n    }\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7788, "func": "static int h2_wake(struct connection *conn)\n{\n\tstruct h2c *h2c = conn->mux_ctx;\n\tstruct session *sess = conn->owner;\n\n\tif (h2c->dbuf->i && !(h2c->flags & H2_CF_DEM_BLOCK_ANY)) {\n\t\th2_process_demux(h2c);\n\n\t\tif (h2c->st0 >= H2_CS_ERROR || conn->flags & CO_FL_ERROR)\n\t\t\th2c->dbuf->i = 0;\n\n\t\tif (h2c->dbuf->i != h2c->dbuf->size)\n\t\t\th2c->flags &= ~H2_CF_DEM_DFULL;\n\t}\n\n\tif (sess && unlikely(sess->fe->state == PR_STSTOPPED)) {\n\t\tif (!(h2c->flags & (H2_CF_GOAWAY_SENT|H2_CF_GOAWAY_FAILED))) {\n\t\t\tif (h2c->last_sid < 0)\n\t\t\t\th2c->last_sid = (1U << 31) - 1;\n\t\t\th2c_send_goaway_error(h2c, NULL);\n\t\t}\n\t}\n\n\tif (!(h2c->flags & H2_CF_WAIT_FOR_HS) &&\n\t    (conn->flags & (CO_FL_EARLY_SSL_HS | CO_FL_HANDSHAKE | CO_FL_EARLY_DATA)) == CO_FL_EARLY_DATA) {\n\t\tstruct eb32_node *node;\n\t\tstruct h2s *h2s;\n\n\t\th2c->flags |= H2_CF_WAIT_FOR_HS;\n\t\tnode = eb32_lookup_ge(&h2c->streams_by_id, 1);\n\n\t\twhile (node) {\n\t\t\th2s = container_of(node, struct h2s, by_id);\n\t\t\tif (h2s->cs->flags & CS_FL_WAIT_FOR_HS)\n\t\t\t\th2s->cs->data_cb->wake(h2s->cs);\n\t\t\tnode = eb32_next(node);\n\t\t}\n\t}\n\n\tif (conn->flags & CO_FL_ERROR || conn_xprt_read0_pending(conn) ||\n\t    h2c->st0 == H2_CS_ERROR2 || h2c->flags & H2_CF_GOAWAY_FAILED ||\n\t    (eb_is_empty(&h2c->streams_by_id) && h2c->last_sid >= 0 &&\n\t     h2c->max_id >= h2c->last_sid)) {\n\t\th2_wake_some_streams(h2c, 0, 0);\n\n\t\tif (eb_is_empty(&h2c->streams_by_id)) {\n\t\t\th2_release(conn);\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\t__conn_xprt_stop_recv(conn);\n\t\t\t__conn_xprt_stop_send(conn);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!h2c->dbuf->i)\n\t\th2_release_buf(h2c, &h2c->dbuf);\n\n\tif (!h2_recv_allowed(h2c)) {\n\t\t__conn_xprt_stop_recv(conn);\n\t}\n\telse {\n\t\t__conn_xprt_want_recv(conn);\n\t}\n\n\tif (!(conn->flags & CO_FL_SOCK_WR_SH) &&\n\t    (h2c->st0 == H2_CS_ERROR ||\n\t     h2c->mbuf->o ||\n\t     (h2c->mws > 0 && !LIST_ISEMPTY(&h2c->fctl_list)) ||\n\t     (!(h2c->flags & H2_CF_MUX_BLOCK_ANY) && !LIST_ISEMPTY(&h2c->send_list)))) {\n\t\t__conn_xprt_want_send(conn);\n\t}\n\telse {\n\t\th2_release_buf(h2c, &h2c->mbuf);\n\t\t__conn_xprt_stop_send(conn);\n\t}\n\n\tif (h2c->task) {\n\t\tif (eb_is_empty(&h2c->streams_by_id) || h2c->mbuf->o) {\n\t\t\th2c->task->expire = tick_add(now_ms, h2c->last_sid < 0 ? h2c->timeout : h2c->shut_timeout);\n\t\t\ttask_queue(h2c->task);\n\t\t}\n\t\telse\n\t\t\th2c->task->expire = TICK_ETERNITY;\n\t}\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186844, "func": " mojo::ScopedSharedBufferHandle GamepadProvider::GetSharedBufferHandle() {\n  base::SharedMemoryHandle handle = base::SharedMemory::DuplicateHandle(\n      gamepad_shared_buffer_->shared_memory()->handle());\n  return mojo::WrapSharedMemoryHandle(handle, sizeof(GamepadHardwareBuffer),\n                                      true \n);\n }\n", "target": 1, "flaw_line_index": "4,6,7,8"}
{"idx": 7707, "func": "static void pdu_push_and_notify(V9fsPDU *pdu)\n{\n    virtio_9p_push_and_notify(pdu);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8033, "func": "static void vnc_mouse_set(DisplayChangeListener *dcl,\n                          int x, int y, int visible)\n{\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7426, "func": "ZEND_API void zend_ts_hash_merge(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, int overwrite)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge(TS_HASH(target), TS_HASH(source), pCopyConstructor, overwrite);\n\tend_write(target);\n\tend_read(source);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7397, "func": "getvalue(struct magic_set *ms, struct magic *m, const char **p, int action)\n{\n\tswitch (m->type) {\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\t*p = getstr(ms, m, *p, action == FILE_COMPILE);\n\t\tif (*p == NULL) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"cannot get string from `%s'\",\n\t\t\t\t    m->value.s);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n#ifdef HAVE_STRTOF\n\t\t\tm->value.f = strtof(*p, &ep);\n#else\n\t\t\tm->value.f = (float)strtod(*p, &ep);\n#endif\n\t\t\t*p = ep;\n\t\t}\n\t\treturn 0;\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n\t\t\tm->value.d = strtod(*p, &ep);\n\t\t\t*p = ep;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n\t\t\tm->value.q = file_signextend(ms, m,\n\t\t\t    (uint64_t)strtoull(*p, &ep, 0));\n\t\t\t*p = ep;\n\t\t\teatsize(p);\n\t\t}\n\t\treturn 0;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8288, "func": "XRRScreenSize *XRRSizes(Display *dpy, int screen, int *nsizes)\n{\n  XRRScreenConfiguration *config;\n  XExtDisplayInfo *info = XRRFindDisplay(dpy);\n  XRRScreenSize *sizes;\n\n  LockDisplay(dpy);\n  if ((config = _XRRValidateCache(dpy, info, screen))) {\n    *nsizes = config->nsizes;\n    sizes = config->sizes;\n    UnlockDisplay(dpy);\n    return sizes;\n    }\n  else {\n    UnlockDisplay(dpy);\n    *nsizes = 0;\n    return NULL;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8266, "func": "XRecordQueryVersion(Display *dpy, int *cmajor_return, int *cminor_return)\n{\n    XExtDisplayInfo *info = find_display (dpy);\n    register xRecordQueryVersionReq   \t*req;\n    xRecordQueryVersionReply \t\trep;\n\n    XRecordCheckExtension (dpy, info, False);\n\n    LockDisplay(dpy);\n    GetReq(RecordQueryVersion, req);\n    req->reqType = info->codes->major_opcode;\n    req->recordReqType = X_RecordQueryVersion;\n    req->majorVersion = RECORD_MAJOR_VERSION;\n    req->minorVersion = RECORD_MINOR_VERSION;\n    if (!_XReply(dpy,(xReply *)&rep, 0, True)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn False;\n    }\n    UnlockDisplay(dpy);\n    SyncHandle();\n    *cmajor_return = rep.majorVersion;\n    *cminor_return = rep.minorVersion;\n    return ((rep.majorVersion == RECORD_MAJOR_VERSION) &&\n\t    (rep.minorVersion >= RECORD_LOWEST_MINOR_VERSION));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187314, "func": "exsltFuncFunctionComp (xsltStylesheetPtr style, xmlNodePtr inst) {\n    xmlChar *name, *prefix;\n    xmlNsPtr ns;\n    xmlHashTablePtr data;\n    exsltFuncFunctionData *func;\n\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n\n    {\n\txmlChar *qname;\n\n\tqname = xmlGetProp(inst, (const xmlChar *) \"name\");\n\tname = xmlSplitQName2 (qname, &prefix);\n\txmlFree(qname);\n    }\n    if ((name == NULL) || (prefix == NULL)) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"func:function: not a QName\\n\");\n\tif (name != NULL)\n\t    xmlFree(name);\n\treturn;\n    }\n    ns = xmlSearchNs (inst->doc, inst, prefix);\n    if (ns == NULL) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"func:function: undeclared prefix %s\\n\",\n\t\t\t prefix);\n\txmlFree(name);\n\txmlFree(prefix);\n\treturn;\n    }\n    xmlFree(prefix);\n\n    xsltParseTemplateContent(style, inst);\n\n     func = exsltFuncNewFunctionData();\n     func->content = inst->children;\n     while (IS_XSLT_ELEM(func->content) &&\n \t   IS_XSLT_NAME(func->content, \"param\")) {\n\tfunc->content = func->content->next;\n\tfunc->nargs++;\n    }\n\n#ifdef XSLT_REFACTORED\n    data = (xmlHashTablePtr)\n\txsltStyleStylesheetLevelGetExtData(style,\n\t    EXSLT_FUNCTIONS_NAMESPACE);\n#else\n    data = (xmlHashTablePtr)\n\txsltStyleGetExtData (style, EXSLT_FUNCTIONS_NAMESPACE);\n#endif\n    if (data == NULL) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"exsltFuncFunctionComp: no stylesheet data\\n\");\n\txmlFree(name);\n\treturn;\n    }\n\n    if (xmlHashAddEntry2 (data, ns->href, name, func) < 0) {\n\txsltTransformError(NULL, style, inst,\n\t    \"Failed to register function {%s}%s\\n\",\n\t\t\t ns->href, name);\n\tstyle->errors++;\n    } else {\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"exsltFuncFunctionComp: register {%s}%s\\n\",\n\t\t\t ns->href, name);\n    }\n    xmlFree(name);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8131, "func": "void Gfx::opMoveSetShowText(Object args[], int numArgs) {\n  double tx, ty;\n\n  if (!state->getFont()) {\n    error(getPos(), \"No font in move/set/show\");\n    return;\n  }\n  if (fontChanged) {\n    out->updateFont(state);\n    fontChanged = gFalse;\n  }\n  state->setWordSpace(args[0].getNum());\n  state->setCharSpace(args[1].getNum());\n  tx = state->getLineX();\n  ty = state->getLineY() - state->getLeading();\n  state->textMoveTo(tx, ty);\n  out->updateWordSpace(state);\n  out->updateCharSpace(state);\n  out->updateTextPos(state);\n  out->beginStringOp(state);\n  doShowText(args[2].getString());\n  out->endStringOp(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7719, "func": "static void coroutine_fn v9fs_fs_ro(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    pdu_complete(pdu, -EROFS);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187072, "func": "void PaymentRequest::UpdateWith(mojom::PaymentDetailsPtr details) {\n   std::string error;\n   if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {\n    LOG(ERROR) << error;\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (details->shipping_address_errors &&\n       !PaymentsValidators::IsValidAddressErrorsFormat(\n           details->shipping_address_errors, &error)) {\n    DLOG(ERROR) << error;\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (!details->total) {\n    LOG(ERROR) << \"Missing total\";\n     OnConnectionTerminated();\n     return;\n   }\n\n  spec_->UpdateWith(std::move(details));\n }\n", "target": 1, "flaw_line_index": "4,12,18"}
{"idx": 7439, "func": "ZEND_API ulong zend_ts_get_hash_value(TsHashTable *ht, char *arKey, uint nKeyLength)\n{\n\tulong retval;\n\n\tbegin_read(ht);\n\tretval = zend_get_hash_value(arKey, nKeyLength);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186838, "func": "void BrowserChildProcessHostImpl::ShareMetricsAllocatorToProcess() {\n  if (metrics_allocator_) {\n    HistogramController::GetInstance()->SetHistogramMemory<ChildProcessHost>(\n         GetHost(),\n         mojo::WrapSharedMemoryHandle(\n             metrics_allocator_->shared_memory()->handle().Duplicate(),\n            metrics_allocator_->shared_memory()->mapped_size(), false));\n   } else {\n     HistogramController::GetInstance()->SetHistogramMemory<ChildProcessHost>(\n         GetHost(), mojo::ScopedSharedBufferHandle());\n  }\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 7604, "func": "static int cirrus_vga_read_cr(CirrusVGAState * s, unsigned reg_index)\n{\n    switch (reg_index) {\n    case 0x00:\t\t\t\n    case 0x01:\t\t\t\n    case 0x02:\t\t\t\n    case 0x03:\t\t\t\n    case 0x04:\t\t\t\n    case 0x05:\t\t\t\n    case 0x06:\t\t\t\n    case 0x07:\t\t\t\n    case 0x08:\t\t\t\n    case 0x09:\t\t\t\n    case 0x0a:\t\t\t\n    case 0x0b:\t\t\t\n    case 0x0c:\t\t\t\n    case 0x0d:\t\t\t\n    case 0x0e:\t\t\t\n    case 0x0f:\t\t\t\n    case 0x10:\t\t\t\n    case 0x11:\t\t\t\n    case 0x12:\t\t\t\n    case 0x13:\t\t\t\n    case 0x14:\t\t\t\n    case 0x15:\t\t\t\n    case 0x16:\t\t\t\n    case 0x17:\t\t\t\n    case 0x18:\t\t\t\n\treturn s->vga.cr[s->vga.cr_index];\n    case 0x24:\t\t\t\n        return (s->vga.ar_flip_flop << 7);\n    case 0x19:\t\t\t\n    case 0x1a:\t\t\t\n    case 0x1b:\t\t\t\n    case 0x1c:\t\t\t\n    case 0x1d:\t\t\t\n    case 0x22:\t\t\t\n    case 0x25:\t\t\t\n    case 0x27:\t\t\t\n\treturn s->vga.cr[s->vga.cr_index];\n    case 0x26:\t\t\t\n\treturn s->vga.ar_index & 0x3f;\n\tbreak;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: inport cr_index %02x\\n\", reg_index);\n#endif\n\treturn 0xff;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7714, "func": "static void coroutine_fn v9fs_create(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsQID qid;\n    int32_t perm;\n    int8_t mode;\n    V9fsPath path;\n    struct stat stbuf;\n    V9fsString name;\n    V9fsString extension;\n    int iounit;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_path_init(&path);\n    v9fs_string_init(&name);\n    v9fs_string_init(&extension);\n    err = pdu_unmarshal(pdu, offset, \"dsdbs\", &fid, &name,\n                        &perm, &mode, &extension);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_create(pdu->tag, pdu->id, fid, name.data, perm, mode);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (perm & P9_STAT_MODE_DIR) {\n        err = v9fs_co_mkdir(pdu, fidp, &name, perm & 0777,\n                            fidp->uid, -1, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n        err = v9fs_co_opendir(pdu, fidp);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_DIR;\n    } else if (perm & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_symlink(pdu, fidp, &name,\n                              extension.data, -1 , &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else if (perm & P9_STAT_MODE_LINK) {\n        int32_t ofid = atoi(extension.data);\n        V9fsFidState *ofidp = get_fid(pdu, ofid);\n        if (ofidp == NULL) {\n            err = -EINVAL;\n            goto out;\n        }\n        err = v9fs_co_link(pdu, ofidp, fidp, &name);\n        put_fid(pdu, ofidp);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            fidp->fid_type = P9_FID_NONE;\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n        err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n        if (err < 0) {\n            fidp->fid_type = P9_FID_NONE;\n            goto out;\n        }\n    } else if (perm & P9_STAT_MODE_DEVICE) {\n        char ctype;\n        uint32_t major, minor;\n        mode_t nmode = 0;\n\n        if (sscanf(extension.data, \"%c %u %u\", &ctype, &major, &minor) != 3) {\n            err = -errno;\n            goto out;\n        }\n\n        switch (ctype) {\n        case 'c':\n            nmode = S_IFCHR;\n            break;\n        case 'b':\n            nmode = S_IFBLK;\n            break;\n        default:\n            err = -EIO;\n            goto out;\n        }\n\n        nmode |= perm & 0777;\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n                            makedev(major, minor), nmode, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else if (perm & P9_STAT_MODE_NAMED_PIPE) {\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n                            0, S_IFIFO | (perm & 0777), &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else if (perm & P9_STAT_MODE_SOCKET) {\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n                            0, S_IFSOCK | (perm & 0777), &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else {\n        err = v9fs_co_open2(pdu, fidp, &name, -1,\n                            omode_to_uflags(mode)|O_CREAT, perm, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_FILE;\n        fidp->open_flags = omode_to_uflags(mode);\n        if (fidp->open_flags & O_EXCL) {\n            fidp->flags |= FID_NON_RECLAIMABLE;\n        }\n    }\n    iounit = get_iounit(pdu, &fidp->path);\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_create_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path, iounit);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n   pdu_complete(pdu, err);\n   v9fs_string_free(&name);\n   v9fs_string_free(&extension);\n   v9fs_path_free(&path);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186324, "func": "bool CheckClientDownloadRequest::ShouldUploadForDlpScan() {\n  if (!base::FeatureList::IsEnabled(kDeepScanningOfDownloads))\n    return false;\n\n  int check_content_compliance = g_browser_process->local_state()->GetInteger(\n      prefs::kCheckContentCompliance);\n  if (check_content_compliance !=\n          CheckContentComplianceValues::CHECK_DOWNLOADS &&\n      check_content_compliance !=\n           CheckContentComplianceValues::CHECK_UPLOADS_AND_DOWNLOADS)\n     return false;\n \n  if (policy::BrowserDMTokenStorage::Get()->RetrieveDMToken().empty())\n     return false;\n \n   const base::ListValue* domains = g_browser_process->local_state()->GetList(\n      prefs::kURLsToCheckComplianceOfDownloadedContent);\n  url_matcher::URLMatcher matcher;\n  policy::url_util::AddAllowFilters(&matcher, domains);\n  return !matcher.MatchURL(item_->GetURL()).empty();\n}\n", "target": 1, "flaw_line_index": "13,14"}
{"idx": 7951, "func": "void buffer_advance(Buffer *buf, size_t len)\n{\n    memmove(buf->buffer, buf->buffer + len,\n            (buf->offset - len));\n    buf->offset -= len;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186398, "func": "  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187274, "func": "void SharedWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   session->AddHandler(std::make_unique<protocol::InspectorHandler>());\n   session->AddHandler(std::make_unique<protocol::NetworkHandler>(GetId()));\n   session->AddHandler(std::make_unique<protocol::SchemaHandler>());\n   session->SetRenderer(worker_host_ ? worker_host_->process_id() : -1, nullptr);\n   if (state_ == WORKER_READY)\n     session->AttachToAgent(EnsureAgent());\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187281, "func": "bool NavigationControllerImpl::RendererDidNavigate(\n    RenderFrameHostImpl* rfh,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,\n    LoadCommittedDetails* details,\n    bool is_navigation_within_page,\n    NavigationHandleImpl* navigation_handle) {\n  is_initial_navigation_ = false;\n\n  bool overriding_user_agent_changed = false;\n  if (GetLastCommittedEntry()) {\n    details->previous_url = GetLastCommittedEntry()->GetURL();\n    details->previous_entry_index = GetLastCommittedEntryIndex();\n    if (pending_entry_ &&\n        pending_entry_->GetIsOverridingUserAgent() !=\n            GetLastCommittedEntry()->GetIsOverridingUserAgent())\n      overriding_user_agent_changed = true;\n  } else {\n    details->previous_url = GURL();\n    details->previous_entry_index = -1;\n  }\n\n  bool was_restored = false;\n  DCHECK(pending_entry_index_ == -1 || pending_entry_->site_instance() ||\n         pending_entry_->restore_type() != RestoreType::NONE);\n  if (pending_entry_ && pending_entry_->restore_type() != RestoreType::NONE) {\n    pending_entry_->set_restore_type(RestoreType::NONE);\n    was_restored = true;\n  }\n\n  details->did_replace_entry = params.should_replace_current_entry;\n\n  details->type = ClassifyNavigation(rfh, params);\n\n  details->is_same_document = is_navigation_within_page;\n\n  if (PendingEntryMatchesHandle(navigation_handle)) {\n    if (pending_entry_->reload_type() != ReloadType::NONE) {\n      last_committed_reload_type_ = pending_entry_->reload_type();\n      last_committed_reload_time_ =\n          time_smoother_.GetSmoothedTime(get_timestamp_callback_.Run());\n    } else if (!pending_entry_->is_renderer_initiated() ||\n               params.gesture == NavigationGestureUser) {\n      last_committed_reload_type_ = ReloadType::NONE;\n      last_committed_reload_time_ = base::Time();\n    }\n  }\n\n  switch (details->type) {\n    case NAVIGATION_TYPE_NEW_PAGE:\n      RendererDidNavigateToNewPage(rfh, params, details->is_same_document,\n                                   details->did_replace_entry,\n                                   navigation_handle);\n      break;\n    case NAVIGATION_TYPE_EXISTING_PAGE:\n      details->did_replace_entry = details->is_same_document;\n      RendererDidNavigateToExistingPage(rfh, params, details->is_same_document,\n                                        was_restored, navigation_handle);\n      break;\n    case NAVIGATION_TYPE_SAME_PAGE:\n      RendererDidNavigateToSamePage(rfh, params, navigation_handle);\n      break;\n    case NAVIGATION_TYPE_NEW_SUBFRAME:\n      RendererDidNavigateNewSubframe(rfh, params, details->is_same_document,\n                                     details->did_replace_entry);\n      break;\n    case NAVIGATION_TYPE_AUTO_SUBFRAME:\n      if (!RendererDidNavigateAutoSubframe(rfh, params)) {\n        NotifyEntryChanged(GetLastCommittedEntry());\n        return false;\n      }\n      break;\n    case NAVIGATION_TYPE_NAV_IGNORE:\n      if (pending_entry_) {\n        DiscardNonCommittedEntries();\n        delegate_->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n      }\n      return false;\n    default:\n      NOTREACHED();\n  }\n\n  base::Time timestamp =\n      time_smoother_.GetSmoothedTime(get_timestamp_callback_.Run());\n  DVLOG(1) << \"Navigation finished at (smoothed) timestamp \"\n           << timestamp.ToInternalValue();\n\n  DiscardNonCommittedEntriesInternal();\n\n  DCHECK(params.page_state.IsValid()) << \"Shouldn't see an empty PageState.\";\n  NavigationEntryImpl* active_entry = GetLastCommittedEntry();\n   active_entry->SetTimestamp(timestamp);\n   active_entry->SetHttpStatusCode(params.http_status_code);\n \n   FrameNavigationEntry* frame_entry =\n       active_entry->GetFrameEntry(rfh->frame_tree_node());\n  if (frame_entry) {\n    frame_entry->SetPageState(params.page_state);\n    frame_entry->set_redirect_chain(params.redirects);\n  }\n\n  if (!rfh->GetParent() &&\n      IsBlockedNavigation(navigation_handle->GetNetErrorCode())) {\n    DCHECK(params.url_is_unreachable);\n    active_entry->SetURL(GURL(url::kAboutBlankURL));\n    active_entry->SetVirtualURL(params.url);\n    if (frame_entry) {\n      frame_entry->SetPageState(\n          PageState::CreateFromURL(active_entry->GetURL()));\n    }\n  }\n\n  size_t redirect_chain_size = 0;\n  for (size_t i = 0; i < params.redirects.size(); ++i) {\n    redirect_chain_size += params.redirects[i].spec().length();\n  }\n  UMA_HISTOGRAM_COUNTS(\"Navigation.RedirectChainSize\", redirect_chain_size);\n\n  active_entry->ResetForCommit(frame_entry);\n\n  if (!rfh->GetParent())\n    CHECK_EQ(active_entry->site_instance(), rfh->GetSiteInstance());\n\n  active_entry->SetBindings(rfh->GetEnabledBindings());\n\n  details->entry = active_entry;\n  details->is_main_frame = !rfh->GetParent();\n  details->http_status_code = params.http_status_code;\n\n  NotifyNavigationEntryCommitted(details);\n\n  if (active_entry->GetURL().SchemeIs(url::kHttpsScheme) && !rfh->GetParent() &&\n      navigation_handle->GetNetErrorCode() == net::OK) {\n    UMA_HISTOGRAM_BOOLEAN(\"Navigation.SecureSchemeHasSSLStatus\",\n                          !!active_entry->GetSSL().certificate);\n  }\n\n  if (overriding_user_agent_changed)\n    delegate_->UpdateOverridingUserAgent();\n\n  int nav_entry_id = active_entry->GetUniqueID();\n  for (FrameTreeNode* node : delegate_->GetFrameTree()->Nodes())\n    node->current_frame_host()->set_nav_entry_id(nav_entry_id);\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187313, "func": "exsltDateCreateDate (exsltDateType type)\n{\n    exsltDateValPtr ret;\n\n    ret = (exsltDateValPtr) xmlMalloc(sizeof(exsltDateVal));\n    if (ret == NULL) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"exsltDateCreateDate: out of memory\\n\");\n\treturn (NULL);\n     }\n     memset (ret, 0, sizeof(exsltDateVal));\n \n     if (type != EXSLT_UNKNOWN)\n         ret->type = type;\n \n    return ret;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7924, "func": "static void emit(JF, int value)\n{\n\temitraw(J, F, value);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7764, "func": "static inline __maybe_unused int h2_get_frame_hdr(struct buffer *b, struct h2_fh *h)\n{\n\tint ret;\n\n\tret = h2_peek_frame_hdr(b, h);\n\tif (ret > 0)\n\t\th2_skip_frame_hdr(b);\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8242, "func": "static void v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_stat_init(&v9stat);\n    err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_wstat(pdu->tag, pdu->id, fid,\n                     v9stat.mode, v9stat.atime, v9stat.mtime);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (donttouch_stat(&v9stat)) {\n        err = v9fs_co_fsync(pdu, fidp, 0);\n        goto out;\n    }\n    if (v9stat.mode != -1) {\n        uint32_t v9_mode;\n        err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        v9_mode = stat_to_v9mode(&stbuf);\n        if ((v9stat.mode & P9_STAT_MODE_TYPE_BITS) !=\n            (v9_mode & P9_STAT_MODE_TYPE_BITS)) {\n            err = -EIO;\n            goto out;\n        }\n        err = v9fs_co_chmod(pdu, &fidp->path,\n                            v9mode_to_mode(v9stat.mode,\n                                           &v9stat.extension));\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.mtime != -1 || v9stat.atime != -1) {\n        struct timespec times[2];\n        if (v9stat.atime != -1) {\n            times[0].tv_sec = v9stat.atime;\n            times[0].tv_nsec = 0;\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9stat.mtime != -1) {\n            times[1].tv_sec = v9stat.mtime;\n            times[1].tv_nsec = 0;\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.n_gid != -1 || v9stat.n_uid != -1) {\n        err = v9fs_co_chown(pdu, &fidp->path, v9stat.n_uid, v9stat.n_gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.name.size != 0) {\n        err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.length != -1) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9stat.length);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    v9fs_stat_free(&v9stat);\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186463, "func": "LayoutUnit NGColumnLayoutAlgorithm::CalculateBalancedColumnBlockSize(\n    const LogicalSize& column_size,\n    int column_count) {\n  NGConstraintSpace space = CreateConstraintSpaceForBalancing(column_size);\n  NGFragmentGeometry fragment_geometry =\n      CalculateInitialFragmentGeometry(space, Node());\n  NGBlockLayoutAlgorithm balancing_algorithm(\n       {Node(), fragment_geometry, space});\n   scoped_refptr<const NGLayoutResult> result = balancing_algorithm.Layout();\n \n  LayoutUnit single_strip_block_size =\n      NGFragment(space.GetWritingMode(), result->PhysicalFragment())\n          .BlockSize();\n \n  LayoutUnit block_size = LayoutUnit::FromFloatCeil(\n      single_strip_block_size.ToFloat() / static_cast<float>(column_count));\n\n  return ConstrainColumnBlockSize(block_size);\n}\n", "target": 1, "flaw_line_index": "17,18,19,20"}
{"idx": 7822, "func": "  TT_Goto_CodeRange( TT_ExecContext  exec,\n                     FT_Int          range,\n                     FT_Long         IP )\n  {\n    TT_CodeRange*  coderange;\n\n\n    FT_ASSERT( range >= 1 && range <= 3 );\n\n    coderange = &exec->codeRangeTable[range - 1];\n\n    FT_ASSERT( coderange->base != NULL );\n\n    FT_ASSERT( (FT_ULong)IP <= coderange->size );\n\n    exec->code     = coderange->base;\n    exec->codeSize = coderange->size;\n    exec->IP       = IP;\n    exec->curRange = range;\n\n    return TT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8014, "func": "void vnc_display_add_client(DisplayState *ds, int csock, bool skipauth)\n{\n    VncDisplay *vs = vnc_display;\n\n    vnc_connect(vs, csock, skipauth, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7660, "func": "static int v9fs_receive_response(V9fsProxy *proxy, int type,\n                                 int *status, void *response)\n{\n    int retval;\n    ProxyHeader header;\n    struct iovec *reply = &proxy->in_iovec;\n\n    *status = 0;\n    reply->iov_len = 0;\n    retval = socket_read(proxy->sockfd, reply->iov_base, PROXY_HDR_SZ);\n    if (retval < 0) {\n        return retval;\n    }\n    reply->iov_len = PROXY_HDR_SZ;\n    proxy_unmarshal(reply, 0, \"dd\", &header.type, &header.size);\n    if (header.size > PROXY_MAX_IO_SZ) {\n        int count;\n        while (header.size > 0) {\n            count = MIN(PROXY_MAX_IO_SZ, header.size);\n            count = socket_read(proxy->sockfd, reply->iov_base, count);\n            if (count < 0) {\n                return count;\n            }\n            header.size -= count;\n        }\n        *status = -ENOBUFS;\n        return 0;\n    }\n\n    retval = socket_read(proxy->sockfd,\n                         reply->iov_base + PROXY_HDR_SZ, header.size);\n    if (retval < 0) {\n        return retval;\n    }\n    reply->iov_len += header.size;\n    if (header.type == T_ERROR) {\n        int ret;\n        ret = proxy_unmarshal(reply, PROXY_HDR_SZ, \"d\", status);\n        if (ret < 0) {\n            *status = ret;\n        }\n        return 0;\n    }\n\n    switch (type) {\n    case T_LSTAT: {\n        ProxyStat prstat;\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ,\n                                 \"qqqdddqqqqqqqqqq\", &prstat.st_dev,\n                                 &prstat.st_ino, &prstat.st_nlink,\n                                 &prstat.st_mode, &prstat.st_uid,\n                                 &prstat.st_gid, &prstat.st_rdev,\n                                 &prstat.st_size, &prstat.st_blksize,\n                                 &prstat.st_blocks,\n                                 &prstat.st_atim_sec, &prstat.st_atim_nsec,\n                                 &prstat.st_mtim_sec, &prstat.st_mtim_nsec,\n                                 &prstat.st_ctim_sec, &prstat.st_ctim_nsec);\n        prstat_to_stat(response, &prstat);\n        break;\n    }\n    case T_STATFS: {\n        ProxyStatFS prstfs;\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ,\n                                 \"qqqqqqqqqqq\", &prstfs.f_type,\n                                 &prstfs.f_bsize, &prstfs.f_blocks,\n                                 &prstfs.f_bfree, &prstfs.f_bavail,\n                                 &prstfs.f_files, &prstfs.f_ffree,\n                                 &prstfs.f_fsid[0], &prstfs.f_fsid[1],\n                                 &prstfs.f_namelen, &prstfs.f_frsize);\n        prstatfs_to_statfs(response, &prstfs);\n        break;\n    }\n    case T_READLINK: {\n        V9fsString target;\n        v9fs_string_init(&target);\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ, \"s\", &target);\n        strcpy(response, target.data);\n        v9fs_string_free(&target);\n        break;\n    }\n    case T_LGETXATTR:\n    case T_LLISTXATTR: {\n        V9fsString xattr;\n        v9fs_string_init(&xattr);\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ, \"s\", &xattr);\n        memcpy(response, xattr.data, xattr.size);\n        v9fs_string_free(&xattr);\n        break;\n    }\n    case T_GETVERSION:\n        proxy_unmarshal(reply, PROXY_HDR_SZ, \"q\", response);\n        break;\n    default:\n        return -1;\n    }\n    if (retval < 0) {\n        *status  = retval;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7524, "func": "  tt_slot_init( FT_GlyphSlot  slot )\n  {\n    return FT_GlyphLoader_CreateExtra( slot->internal->loader );\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8303, "func": "XFixesCreateRegionFromBitmap (Display *dpy, Pixmap bitmap)\n{\n    XFixesExtDisplayInfo\t\t*info = XFixesFindDisplay (dpy);\n    xXFixesCreateRegionFromBitmapReq\t*req;\n    XserverRegion\t\t\tregion;\n\n    XFixesCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (XFixesCreateRegionFromBitmap, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesCreateRegionFromBitmap;\n    region = req->region = XAllocID (dpy);\n    req->bitmap = bitmap;\n    UnlockDisplay (dpy);\n    SyncHandle();\n    return region;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7484, "func": "int pt_removexattr(FsContext *ctx, const char *path, const char *name)\n{\n    return local_removexattr_nofollow(ctx, path, name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186889, "func": "void GLManager::InitializeWithWorkaroundsImpl(\n    const GLManager::Options& options,\n    const GpuDriverBugWorkarounds& workarounds) {\n  const SharedMemoryLimits limits;\n  const base::CommandLine& command_line =\n      *base::CommandLine::ForCurrentProcess();\n  DCHECK(!command_line.HasSwitch(switches::kDisableGLExtensions));\n   InitializeGpuPreferencesForTestingFromCommandLine(command_line,\n                                                     &gpu_preferences_);\n \n   if (options.share_mailbox_manager) {\n     mailbox_manager_ = options.share_mailbox_manager->mailbox_manager();\n   } else if (options.share_group_manager) {\n    mailbox_manager_ = options.share_group_manager->mailbox_manager();\n  } else {\n    mailbox_manager_ = &owned_mailbox_manager_;\n  }\n\n  gl::GLShareGroup* share_group = NULL;\n  if (options.share_group_manager) {\n    share_group = options.share_group_manager->share_group();\n  } else if (options.share_mailbox_manager) {\n    share_group = options.share_mailbox_manager->share_group();\n  }\n\n  gles2::ContextGroup* context_group = NULL;\n  scoped_refptr<gles2::ShareGroup> client_share_group;\n  if (options.share_group_manager) {\n    context_group = options.share_group_manager->decoder_->GetContextGroup();\n    client_share_group =\n      options.share_group_manager->gles2_implementation()->share_group();\n  }\n\n  gl::GLContext* real_gl_context = NULL;\n  if (options.virtual_manager &&\n      !gpu_preferences_.use_passthrough_cmd_decoder) {\n    real_gl_context = options.virtual_manager->context();\n  }\n\n  share_group_ = share_group ? share_group : new gl::GLShareGroup;\n\n  ContextCreationAttribs attribs;\n  attribs.red_size = 8;\n  attribs.green_size = 8;\n  attribs.blue_size = 8;\n  attribs.alpha_size = 8;\n  attribs.depth_size = 16;\n  attribs.stencil_size = 8;\n  attribs.context_type = options.context_type;\n  attribs.samples = options.multisampled ? 4 : 0;\n  attribs.sample_buffers = options.multisampled ? 1 : 0;\n  attribs.alpha_size = options.backbuffer_alpha ? 8 : 0;\n  attribs.should_use_native_gmb_for_backbuffer =\n      options.image_factory != nullptr;\n  attribs.offscreen_framebuffer_size = options.size;\n  attribs.buffer_preserved = options.preserve_backbuffer;\n  attribs.bind_generates_resource = options.bind_generates_resource;\n  translator_cache_ =\n      std::make_unique<gles2::ShaderTranslatorCache>(gpu_preferences_);\n\n  if (!context_group) {\n    scoped_refptr<gles2::FeatureInfo> feature_info =\n        new gles2::FeatureInfo(workarounds);\n    context_group = new gles2::ContextGroup(\n        gpu_preferences_, true, mailbox_manager_, nullptr \n,\n        translator_cache_.get(), &completeness_cache_, feature_info,\n        options.bind_generates_resource, &image_manager_, options.image_factory,\n        nullptr \n, GpuFeatureInfo(),\n        &discardable_manager_);\n  }\n\n  command_buffer_.reset(new CommandBufferCheckLostContext(\n      context_group->transfer_buffer_manager(), options.sync_point_manager,\n      options.context_lost_allowed));\n\n  decoder_.reset(::gpu::gles2::GLES2Decoder::Create(\n      command_buffer_.get(), command_buffer_->service(), &outputter_,\n      context_group));\n  if (options.force_shader_name_hashing) {\n    decoder_->SetForceShaderNameHashingForTest(true);\n  }\n\n  command_buffer_->set_handler(decoder_.get());\n\n  surface_ = gl::init::CreateOffscreenGLSurface(gfx::Size());\n  ASSERT_TRUE(surface_.get() != NULL) << \"could not create offscreen surface\";\n\n  if (base_context_) {\n    context_ = scoped_refptr<gl::GLContext>(new gpu::GLContextVirtual(\n        share_group_.get(), base_context_->get(), decoder_->AsWeakPtr()));\n    ASSERT_TRUE(context_->Initialize(\n        surface_.get(), GenerateGLContextAttribs(attribs, context_group)));\n  } else {\n    if (real_gl_context) {\n      context_ = scoped_refptr<gl::GLContext>(new gpu::GLContextVirtual(\n          share_group_.get(), real_gl_context, decoder_->AsWeakPtr()));\n      ASSERT_TRUE(context_->Initialize(\n          surface_.get(), GenerateGLContextAttribs(attribs, context_group)));\n    } else {\n      context_ = gl::init::CreateGLContext(\n          share_group_.get(), surface_.get(),\n          GenerateGLContextAttribs(attribs, context_group));\n      g_gpu_feature_info.ApplyToGLContext(context_.get());\n    }\n  }\n  ASSERT_TRUE(context_.get() != NULL) << \"could not create GL context\";\n\n  ASSERT_TRUE(context_->MakeCurrent(surface_.get()));\n\n  auto result =\n      decoder_->Initialize(surface_.get(), context_.get(), true,\n                           ::gpu::gles2::DisallowedFeatures(), attribs);\n  if (result != gpu::ContextResult::kSuccess)\n    return;\n  capabilities_ = decoder_->GetCapabilities();\n\n  gles2_helper_.reset(new gles2::GLES2CmdHelper(command_buffer_.get()));\n  ASSERT_EQ(gles2_helper_->Initialize(limits.command_buffer_size),\n            gpu::ContextResult::kSuccess);\n\n  transfer_buffer_.reset(new TransferBuffer(gles2_helper_.get()));\n\n  const bool support_client_side_arrays = true;\n  gles2_implementation_.reset(new gles2::GLES2Implementation(\n      gles2_helper_.get(), std::move(client_share_group),\n      transfer_buffer_.get(), options.bind_generates_resource,\n      options.lose_context_when_out_of_memory, support_client_side_arrays,\n      this));\n\n  ASSERT_EQ(gles2_implementation_->Initialize(limits),\n            gpu::ContextResult::kSuccess)\n      << \"Could not init GLES2Implementation\";\n\n  MakeCurrent();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187213, "func": "static int _hid_get_device_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n{\n\tstruct libusb_device_descriptor d;\n\td.bLength = LIBUSB_DT_DEVICE_SIZE;\n\td.bDescriptorType = LIBUSB_DT_DEVICE;\n\td.bcdUSB = 0x0200; \n\td.bDeviceClass = 0;\n\td.bDeviceSubClass = 0;\n\td.bDeviceProtocol = 0;\n\td.bMaxPacketSize0 = 64; \n\td.idVendor = (uint16_t)dev->vid;\n\td.idProduct = (uint16_t)dev->pid;\n\td.bcdDevice = 0x0100;\n\td.iManufacturer = dev->string_index[0];\n\td.iProduct = dev->string_index[1];\n\td.iSerialNumber = dev->string_index[2];\n\td.bNumConfigurations = 1;\n\tif (*size > LIBUSB_DT_DEVICE_SIZE)\n\t\t*size = LIBUSB_DT_DEVICE_SIZE;\n\tmemcpy(data, &d, *size);\n\treturn LIBUSB_COMPLETED;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22"}
{"idx": 187294, "func": "void FileBrowserHandlerCustomBindings::GetEntryURL(\n     const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 1);\n  CHECK(args[0]->IsObject());\n  const blink::WebURL& url =\n      blink::WebDOMFileSystem::createFileSystemURL(args[0]);\n  args.GetReturnValue().Set(v8_helpers::ToV8StringUnsafe(\n      args.GetIsolate(), url.string().utf8().c_str()));\n }\n", "target": 1, "flaw_line_index": "3,4,5,6,7,8"}
{"idx": 186899, "func": "void ManifestUmaUtil::FetchFailed(FetchFailureReason reason) {\n  ManifestFetchResultType fetch_result_type = MANIFEST_FETCH_RESULT_TYPE_COUNT;\n  switch (reason) {\n     case FETCH_EMPTY_URL:\n       fetch_result_type = MANIFEST_FETCH_ERROR_EMPTY_URL;\n       break;\n     case FETCH_UNSPECIFIED_REASON:\n       fetch_result_type = MANIFEST_FETCH_ERROR_UNSPECIFIED;\n       break;\n  }\n  DCHECK_NE(fetch_result_type, MANIFEST_FETCH_RESULT_TYPE_COUNT);\n\n  UMA_HISTOGRAM_ENUMERATION(kUMANameFetchResult,\n                            fetch_result_type,\n                            MANIFEST_FETCH_RESULT_TYPE_COUNT);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186395, "func": "   void LoadURL() {\n    WebContents* contents = shell()->web_contents();\n    WebPreferences prefs =\n        contents->GetRenderViewHost()->GetWebkitPreferences();\n    prefs.mock_scrollbars_enabled = true;\n    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n    observer.WaitForHitTestData();\n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7461, "func": "void DBusHelperProxy::remoteSignalReceived(int t, const QString &action, QByteArray blob)\n{\n    SignalType type = static_cast<SignalType>(t);\n    QDataStream stream(&blob, QIODevice::ReadOnly);\n\n    if (type == ActionStarted) {\n        emit actionStarted(action);\n    } else if (type == ActionPerformed) {\n        ActionReply reply = ActionReply::deserialize(blob);\n\n        m_actionsInProgress.removeOne(action);\n        emit actionPerformed(action, reply);\n    } else if (type == DebugMessage) {\n        int level;\n        QString message;\n\n        stream >> level >> message;\n\n        debugMessageReceived(level, message);\n    } else if (type == ProgressStepIndicator) {\n        int step;\n        stream >> step;\n\n        emit progressStep(action, step);\n    } else if (type == ProgressStepData) {\n        QVariantMap data;\n        stream >> data;\n\n        emit progressStep(action, data);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8042, "func": "int vnc_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int n = 0;\n\n    switch(vs->vnc_encoding) {\n        case VNC_ENCODING_ZLIB:\n            n = vnc_zlib_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_HEXTILE);\n            n = vnc_hextile_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT:\n            n = vnc_tight_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT_PNG:\n            n = vnc_tight_png_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZRLE:\n            n = vnc_zrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            n = vnc_zywrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        default:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_RAW);\n            n = vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n            break;\n    }\n    return n;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186549, "func": "void DiceTurnSyncOnHelper::AbortAndDelete() {\n   if (signin_aborted_mode_ == SigninAbortedMode::REMOVE_ACCOUNT) {\n    token_service_->RevokeCredentials(account_info_.account_id);\n   }\n   delete this;\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 186756, "func": " Response StorageHandler::UntrackIndexedDBForOrigin(const std::string& origin) {\n  if (!process_)\n     return Response::InternalError();\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid())\n    return Response::InvalidParams(origin + \" is not a valid URL\");\n\n  GetIndexedDBObserver()->TaskRunner()->PostTask(\n      FROM_HERE, base::BindOnce(&IndexedDBObserver::UntrackOriginOnIDBThread,\n                                base::Unretained(GetIndexedDBObserver()),\n                                url::Origin::Create(origin_url)));\n  return Response::OK();\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186358, "func": " bool IDNToUnicodeOneComponent(const base::char16* comp,\n                               size_t comp_len,\n                               base::string16* out) {\n   DCHECK(out);\n   if (comp_len == 0)\n    return false;\n\n  static const base::char16 kIdnPrefix[] = {'x', 'n', '-', '-'};\n  if ((comp_len > arraysize(kIdnPrefix)) &&\n      !memcmp(comp, kIdnPrefix, sizeof(kIdnPrefix))) {\n    UIDNA* uidna = g_uidna.Get().value;\n    DCHECK(uidna != NULL);\n    size_t original_length = out->length();\n    int32_t output_length = 64;\n    UIDNAInfo info = UIDNA_INFO_INITIALIZER;\n    UErrorCode status;\n    do {\n      out->resize(original_length + output_length);\n      status = U_ZERO_ERROR;\n      output_length = uidna_labelToUnicode(\n          uidna, comp, static_cast<int32_t>(comp_len), &(*out)[original_length],\n          output_length, &info, &status);\n    } while ((status == U_BUFFER_OVERFLOW_ERROR && info.errors == 0));\n\n    if (U_SUCCESS(status) && info.errors == 0) {\n       out->resize(original_length + output_length);\n       if (IsIDNComponentSafe(\n          base::StringPiece16(out->data() + original_length,\n                              base::checked_cast<size_t>(output_length))))\n         return true;\n     }\n \n    out->resize(original_length);\n  }\n\n  out->append(comp, comp_len);\n  return false;\n}\n", "target": 1, "flaw_line_index": "34,35"}
{"idx": 7402, "func": "ZEND_API zval *_zend_ts_hash_add_or_update(TsHashTable *ht, zend_string *key, zval *pData, int flag ZEND_FILE_LINE_DC)\n{\n\tzval *retval;\n\n\tbegin_write(ht);\n\tretval = _zend_hash_add_or_update(TS_HASH(ht), key, pData, flag ZEND_FILE_LINE_RELAY_CC);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8249, "func": "XvImageFormatValues * XvMCListSubpictureTypes (\n  Display * dpy,\n  XvPortID port,\n  int surface_type_id,\n  int *count_return\n)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcListSubpictureTypesReply rep;\n    xvmcListSubpictureTypesReq  *req;\n    XvImageFormatValues *ret = NULL;\n\n\n    *count_return = 0;\n\n    XvMCCheckExtension (dpy, info, NULL);\n\n\n    LockDisplay (dpy);\n    XvMCGetReq (ListSubpictureTypes, req);\n    req->port = port;\n    req->surface_type_id = surface_type_id;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n        return NULL;\n    }\n\n    if(rep.num > 0) {\n        if (rep.num < (INT_MAX / sizeof(XvImageFormatValues)))\n            ret = Xmalloc(rep.num * sizeof(XvImageFormatValues));\n\n        if(ret) {\n            xvImageFormatInfo Info;\n            int i;\n\n            *count_return = rep.num;\n\n            for(i = 0; i < rep.num; i++) {\n              _XRead(dpy, (char*)(&Info), sz_xvImageFormatInfo);\n              ret[i].id = Info.id;\n              ret[i].type = Info.type;\n              ret[i].byte_order = Info.byte_order;\n              memcpy(&(ret[i].guid[0]), &(Info.guid[0]), 16);\n              ret[i].bits_per_pixel = Info.bpp;\n              ret[i].format = Info.format;\n              ret[i].num_planes = Info.num_planes;\n              ret[i].depth = Info.depth;\n              ret[i].red_mask = Info.red_mask;\n              ret[i].green_mask = Info.green_mask;\n              ret[i].blue_mask = Info.blue_mask;\n              ret[i].y_sample_bits = Info.y_sample_bits;\n              ret[i].u_sample_bits = Info.u_sample_bits;\n              ret[i].v_sample_bits = Info.v_sample_bits;\n              ret[i].horz_y_period = Info.horz_y_period;\n              ret[i].horz_u_period = Info.horz_u_period;\n              ret[i].horz_v_period = Info.horz_v_period;\n              ret[i].vert_y_period = Info.vert_y_period;\n              ret[i].vert_u_period = Info.vert_u_period;\n              ret[i].vert_v_period = Info.vert_v_period;\n              memcpy(&(ret[i].component_order[0]), &(Info.comp_order[0]), 32);\n              ret[i].scanline_order = Info.scanline_order;\n            }\n        } else\n\t   _XEatDataWords(dpy, rep.length);\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7542, "func": "localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)\n{\n  if (!tz)\n    return gmtime_r (t, tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);\n          if (revert_tz (old_tz) && abbr_saved)\n            return tm;\n        }\n      return NULL;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8070, "func": "GBool Gfx::checkArg(Object *arg, TchkType type) {\n  switch (type) {\n  case tchkBool:   return arg->isBool();\n  case tchkInt:    return arg->isInt();\n  case tchkNum:    return arg->isNum();\n  case tchkString: return arg->isString();\n  case tchkName:   return arg->isName();\n  case tchkArray:  return arg->isArray();\n  case tchkProps:  return arg->isDict() || arg->isName();\n  case tchkSCN:    return arg->isNum() || arg->isName();\n  case tchkNone:   return gFalse;\n  }\n  return gFalse;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7573, "func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (blit_is_unsafe(s))\n        return 0;\n\n    cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->vga.start_addr,\n            s->cirrus_blt_srcaddr - s->vga.start_addr,\n            s->cirrus_blt_width, s->cirrus_blt_height);\n\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7872, "func": "static uint64_t ram_save_pending(QEMUFile *f, void *opaque, uint64_t max_size)\n{\n    uint64_t remaining_size;\n\n    remaining_size = ram_save_remaining() * TARGET_PAGE_SIZE;\n\n    if (remaining_size < max_size) {\n        qemu_mutex_lock_iothread();\n        migration_bitmap_sync();\n        qemu_mutex_unlock_iothread();\n        remaining_size = ram_save_remaining() * TARGET_PAGE_SIZE;\n    }\n    return remaining_size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186521, "func": " void DataReductionProxySettings::InitDataReductionProxySettings(\n     PrefService* prefs,\n    DataReductionProxyIOData* io_data,\n    std::unique_ptr<DataReductionProxyService> data_reduction_proxy_service) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  DCHECK(prefs);\n  DCHECK(io_data);\n  DCHECK(io_data->config());\n  DCHECK(data_reduction_proxy_service);\n  prefs_ = prefs;\n   config_ = io_data->config();\n   data_reduction_proxy_service_ = std::move(data_reduction_proxy_service);\n   data_reduction_proxy_service_->AddObserver(this);\n  InitPrefMembers();\n   RecordDataReductionInit();\n \n #if defined(OS_ANDROID)\n  if (spdy_proxy_auth_enabled_.GetValue()) {\n     data_reduction_proxy_service_->compression_stats()\n         ->SetDataUsageReportingEnabled(true);\n   }\n#endif  \n\n  for (auto& observer : observers_)\n    observer.OnSettingsInitialized();\n}\n", "target": 1, "flaw_line_index": "14,18"}
{"idx": 186978, "func": "std::unique_ptr<SymmetricKey>* GetPaddingKey() {\n   static base::NoDestructor<std::unique_ptr<SymmetricKey>> s_padding_key([] {\n     return SymmetricKey::GenerateRandomKey(kPaddingKeyAlgorithm, 128);\n   }());\n  return s_padding_key.get();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187016, "func": "  explicit CancelAndIgnoreNavigationForPluginFrameThrottle(\n      NavigationHandle* handle)\n      : NavigationThrottle(handle) {}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 186835, "func": "void PdfCompositorClient::Composite(\n    service_manager::Connector* connector,\n    base::SharedMemoryHandle handle,\n    size_t data_size,\n    mojom::PdfCompositor::CompositePdfCallback callback,\n    scoped_refptr<base::SequencedTaskRunner> callback_task_runner) {\n  DCHECK(data_size);\n\n   if (!compositor_)\n     Connect(connector);\n \n  mojo::ScopedSharedBufferHandle buffer_handle =\n      mojo::WrapSharedMemoryHandle(handle, data_size, true);\n \n   compositor_->CompositePdf(\n       std::move(buffer_handle),\n      base::BindOnce(&OnCompositePdf, base::Passed(&compositor_),\n                     std::move(callback), callback_task_runner));\n}\n", "target": 1, "flaw_line_index": "12,13"}
{"idx": 8299, "func": "XRRSetProviderOffloadSink(Display *dpy, XID provider,\n\t\t\t  XID sink_provider)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRSetProviderOffloadSinkReq *req;\n\n    RRCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (RRSetProviderOffloadSink, req);\n    req->reqType = info->codes->major_opcode;\n    req->randrReqType = X_RRSetProviderOffloadSink;\n    req->provider = provider;\n    req->sink_provider = sink_provider;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186763, "func": "void ServiceWorkerDevToolsAgentHost::WorkerRestarted(int worker_process_id,\n                                                     int worker_route_id) {\n  DCHECK_EQ(WORKER_TERMINATED, state_);\n   state_ = WORKER_NOT_READY;\n   worker_process_id_ = worker_process_id;\n   worker_route_id_ = worker_route_id;\n  RenderProcessHost* host = RenderProcessHost::FromID(worker_process_id_);\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(host, nullptr);\n }\n", "target": 1, "flaw_line_index": "7,9"}
{"idx": 187030, "func": "  SiteInstance* parent_site_instance() const {\n    return parent_site_instance_.get();\n  }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 7498, "func": "iter_next (DBusMessageDataIter *iter)\n{\n  iter->sequence_nos[iter->depth] += 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8267, "func": "XRecordUnregisterClients(Display *dpy, XRecordContext context,\n\t\t\t XRecordClientSpec *clients, int nclients)\n{\n    XExtDisplayInfo *info = find_display (dpy);\n    register xRecordUnregisterClientsReq \t*req;\n    int\t\t\tclen = 4 * nclients;\n\n    XRecordCheckExtension (dpy, info, 0);\n    LockDisplay(dpy);\n    GetReq(RecordUnregisterClients, req);\n\n    req->reqType = info->codes->major_opcode;\n    req->recordReqType = X_RecordUnregisterClients;\n    req->context = context;\n    req->length += nclients;\n    req->nClients = nclients;\n\n    Data32(dpy, (long *)clients, clen);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186927, "func": "void WebContentsImpl::CreateNewWindow(\n    RenderFrameHost* opener,\n    int32_t render_view_route_id,\n    int32_t main_frame_route_id,\n    int32_t main_frame_widget_route_id,\n    const mojom::CreateNewWindowParams& params,\n    SessionStorageNamespace* session_storage_namespace) {\n  DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),\n            (main_frame_route_id == MSG_ROUTING_NONE));\n  DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),\n            (main_frame_widget_route_id == MSG_ROUTING_NONE));\n  DCHECK(opener);\n\n  int render_process_id = opener->GetProcess()->GetID();\n  SiteInstance* source_site_instance = opener->GetSiteInstance();\n\n  DCHECK(!RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id));\n\n  bool is_guest = BrowserPluginGuest::IsGuest(this);\n\n  DCHECK(!params.opener_suppressed || render_view_route_id == MSG_ROUTING_NONE);\n\n  scoped_refptr<SiteInstance> site_instance =\n      params.opener_suppressed && !is_guest\n          ? SiteInstance::CreateForURL(GetBrowserContext(), params.target_url)\n          : source_site_instance;\n\n  const std::string& partition_id =\n      GetContentClient()->browser()->\n          GetStoragePartitionIdForSite(GetBrowserContext(),\n                                       site_instance->GetSiteURL());\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      GetBrowserContext(), site_instance.get());\n  DOMStorageContextWrapper* dom_storage_context =\n      static_cast<DOMStorageContextWrapper*>(partition->GetDOMStorageContext());\n  SessionStorageNamespaceImpl* session_storage_namespace_impl =\n      static_cast<SessionStorageNamespaceImpl*>(session_storage_namespace);\n  CHECK(session_storage_namespace_impl->IsFromContext(dom_storage_context));\n\n  if (delegate_ &&\n      !delegate_->ShouldCreateWebContents(\n          this, opener, source_site_instance, render_view_route_id,\n          main_frame_route_id, main_frame_widget_route_id,\n          params.window_container_type, opener->GetLastCommittedURL(),\n          params.frame_name, params.target_url, partition_id,\n          session_storage_namespace)) {\n    RenderFrameHostImpl* rfh =\n        RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id);\n    if (rfh) {\n      DCHECK(rfh->IsRenderFrameLive());\n      rfh->Init();\n    }\n    return;\n  }\n\n  CreateParams create_params(GetBrowserContext(), site_instance.get());\n  create_params.routing_id = render_view_route_id;\n  create_params.main_frame_routing_id = main_frame_route_id;\n  create_params.main_frame_widget_routing_id = main_frame_widget_route_id;\n  create_params.main_frame_name = params.frame_name;\n  create_params.opener_render_process_id = render_process_id;\n  create_params.opener_render_frame_id = opener->GetRoutingID();\n  create_params.opener_suppressed = params.opener_suppressed;\n  if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB)\n    create_params.initially_hidden = true;\n  create_params.renderer_initiated_creation =\n      main_frame_route_id != MSG_ROUTING_NONE;\n\n  WebContentsImpl* new_contents = NULL;\n  if (!is_guest) {\n    create_params.context = view_->GetNativeView();\n    create_params.initial_size = GetContainerBounds().size();\n    new_contents = static_cast<WebContentsImpl*>(\n        WebContents::Create(create_params));\n  }  else {\n    new_contents = GetBrowserPluginGuest()->CreateNewGuestWindow(create_params);\n  }\n  new_contents->GetController().SetSessionStorageNamespace(\n      partition_id,\n      session_storage_namespace);\n\n  if (!params.frame_name.empty())\n    new_contents->GetRenderManager()->CreateProxiesForNewNamedFrame();\n\n  if (!params.opener_suppressed) {\n    if (!is_guest) {\n      WebContentsView* new_view = new_contents->view_.get();\n\n      new_view->CreateViewForWidget(\n          new_contents->GetRenderViewHost()->GetWidget(), false);\n    }\n    DCHECK_NE(MSG_ROUTING_NONE, main_frame_widget_route_id);\n    pending_contents_[std::make_pair(\n        render_process_id, main_frame_widget_route_id)] = new_contents;\n    AddDestructionObserver(new_contents);\n  }\n\n  if (delegate_) {\n    delegate_->WebContentsCreated(this, render_process_id,\n                                  opener->GetRoutingID(), params.frame_name,\n                                  params.target_url, new_contents);\n  }\n\n  if (opener) {\n    for (auto& observer : observers_) {\n      observer.DidOpenRequestedURL(new_contents, opener, params.target_url,\n                                   params.referrer, params.disposition,\n                                   ui::PAGE_TRANSITION_LINK,\n                                   false,  \n                                   true);  \n     }\n   }\n \n   if (params.opener_suppressed) {\n    bool was_blocked = false;\n    if (delegate_) {\n      gfx::Rect initial_rect;\n      base::WeakPtr<WebContentsImpl> weak_new_contents =\n          new_contents->weak_factory_.GetWeakPtr();\n\n      delegate_->AddNewContents(\n          this, new_contents, params.disposition, initial_rect,\n          params.user_gesture, &was_blocked);\n\n      if (!weak_new_contents)\n        return;  \n    }\n    if (!was_blocked) {\n      OpenURLParams open_params(params.target_url, params.referrer,\n                                WindowOpenDisposition::CURRENT_TAB,\n                                ui::PAGE_TRANSITION_LINK,\n                                true \n);\n      open_params.user_gesture = params.user_gesture;\n\n      if (delegate_ && !is_guest &&\n          !delegate_->ShouldResumeRequestsForCreatedWindow()) {\n        new_contents->delayed_open_url_params_.reset(\n            new OpenURLParams(open_params));\n      } else {\n        new_contents->OpenURL(open_params);\n      }\n    }\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8104, "func": "GBool GfxResources::lookupXObject(char *name, Object *obj) {\n  GfxResources *resPtr;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->xObjDict.isDict()) {\n      if (!resPtr->xObjDict.dictLookup(name, obj)->isNull())\n\treturn gTrue;\n      obj->free();\n    }\n  }\n  error(-1, \"XObject '%s' is unknown\", name);\n  return gFalse;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7561, "func": "static inline void cirrus_bitblt_bgcol(CirrusVGAState *s)\n{\n    unsigned int color;\n    switch (s->cirrus_blt_pixelwidth) {\n    case 1:\n        s->cirrus_blt_bgcol = s->cirrus_shadow_gr0;\n        break;\n    case 2:\n        color = s->cirrus_shadow_gr0 | (s->vga.gr[0x10] << 8);\n        s->cirrus_blt_bgcol = le16_to_cpu(color);\n        break;\n    case 3:\n        s->cirrus_blt_bgcol = s->cirrus_shadow_gr0 |\n            (s->vga.gr[0x10] << 8) | (s->vga.gr[0x12] << 16);\n        break;\n    default:\n    case 4:\n        color = s->cirrus_shadow_gr0 | (s->vga.gr[0x10] << 8) |\n            (s->vga.gr[0x12] << 16) | (s->vga.gr[0x14] << 24);\n        s->cirrus_blt_bgcol = le32_to_cpu(color);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7886, "func": "uint64_t xbzrle_mig_pages_overflow(void)\n{\n    return acct_info.xbzrle_overflows;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8274, "func": "XRenderExtAddDisplay (XRenderExtInfo *extinfo,\n                      Display        *dpy,\n                      char           *ext_name)\n{\n    XRenderExtDisplayInfo *dpyinfo;\n\n    dpyinfo = (XRenderExtDisplayInfo *) Xmalloc (sizeof (XRenderExtDisplayInfo));\n    if (!dpyinfo) return NULL;\n    dpyinfo->display = dpy;\n    dpyinfo->info = NULL;\n\n    if (XRenderHasDepths (dpy))\n\tdpyinfo->codes = XInitExtension (dpy, ext_name);\n    else\n\tdpyinfo->codes = NULL;\n\n    if (dpyinfo->codes) {\n        XESetCloseDisplay (dpy, dpyinfo->codes->extension,\n                           XRenderCloseDisplay);\n    } else {\n\tXExtCodes *codes = XAddExtension(dpy);\n\tif (!codes) {\n\t    XFree(dpyinfo);\n\t    return NULL;\n\t}\n        XESetCloseDisplay (dpy, codes->extension, XRenderCloseDisplay);\n    }\n\n    _XLockMutex(_Xglobal_lock);\n    dpyinfo->next = extinfo->head;\n    extinfo->head = dpyinfo;\n    extinfo->cur = dpyinfo;\n    extinfo->ndisplays++;\n    _XUnlockMutex(_Xglobal_lock);\n    return dpyinfo;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186423, "func": "GURL DevToolsWindow::GetDevToolsURL(Profile* profile,\n                                    const GURL& base_url,\n                                    bool shared_worker_frontend,\n                                    bool v8_only_frontend,\n                                    const std::string& remote_frontend,\n                                    bool can_dock,\n                                    const std::string& panel) {\n  if (base_url.SchemeIs(\"data\"))\n    return base_url;\n\n  std::string frontend_url(\n      !remote_frontend.empty() ?\n          remote_frontend :\n          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));\n  if (shared_worker_frontend)\n    url_string += \"&isSharedWorker=true\";\n  if (v8_only_frontend)\n    url_string += \"&v8only=true\";\n  if (remote_frontend.size()) {\n    url_string += \"&remoteFrontend=true\";\n  } else {\n    url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();\n  }\n  if (can_dock)\n     url_string += \"&can_dock=true\";\n   if (panel.size())\n     url_string += \"&panel=\" + panel;\n  return DevToolsUI::SanitizeFrontendURL(GURL(url_string));\n }\n", "target": 1, "flaw_line_index": "33"}
{"idx": 7913, "func": "static js_Ast *continuetarget(JF, js_Ast *node, const char *label)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\tbreak;\n\t\tif (isloop(node->type)) {\n\t\t\tif (!label)\n\t\t\t\treturn node;\n\t\t\telse if (matchlabel(node->parent, label))\n\t\t\t\treturn node;\n\t\t}\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186579, "func": "void RendererSchedulerImpl::OnShutdownTaskQueue(\n    const scoped_refptr<MainThreadTaskQueue>& task_queue) {\n  if (main_thread_only().was_shutdown)\n    return;\n\n  if (task_queue_throttler_)\n    task_queue_throttler_->ShutdownTaskQueue(task_queue.get());\n\n  if (task_runners_.erase(task_queue)) {\n    switch (task_queue->queue_class()) {\n       case MainThreadTaskQueue::QueueClass::kTimer:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().timer_task_cost_estimator);\n       case MainThreadTaskQueue::QueueClass::kLoading:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().loading_task_cost_estimator);\n       default:\n         break;\n     }\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186809, "func": "  void CreateFusionSensor(\n      std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm) {\n    auto callback =\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n                                 std::move(fusion_algorithm), callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n", "target": 1, "flaw_line_index": "7,8"}
{"idx": 187031, "func": " ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\n  base::PostTaskWithTraits(\n      FROM_HERE, BrowserThread::UI,\n      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\n }\n", "target": 1, "flaw_line_index": "3,4,5,6,7,8"}
{"idx": 186677, "func": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n    entry = entry->next();\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 186379, "func": "void NavigationControllerImpl::RendererDidNavigateToNewPage(\n    RenderFrameHostImpl* rfh,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,\n    bool is_in_page,\n    bool replace_entry,\n    NavigationHandleImpl* handle) {\n  std::unique_ptr<NavigationEntryImpl> new_entry;\n  bool update_virtual_url = false;\n\n  if (is_in_page && GetLastCommittedEntry()) {\n    FrameNavigationEntry* frame_entry = new FrameNavigationEntry(\n        params.frame_unique_name, params.item_sequence_number,\n        params.document_sequence_number, rfh->GetSiteInstance(), nullptr,\n        params.url, params.referrer, params.method, params.post_id);\n    new_entry = GetLastCommittedEntry()->CloneAndReplace(\n        frame_entry, true, rfh->frame_tree_node(),\n        delegate_->GetFrameTree()->root());\n\n     CHECK(frame_entry->HasOneRef());\n \n     update_virtual_url = new_entry->update_virtual_url_with_url();\n   }\n \n  if (!new_entry &&\n      PendingEntryMatchesHandle(handle) && pending_entry_index_ == -1 &&\n      (!pending_entry_->site_instance() ||\n       pending_entry_->site_instance() == rfh->GetSiteInstance())) {\n    new_entry = pending_entry_->Clone();\n\n    update_virtual_url = new_entry->update_virtual_url_with_url();\n    new_entry->GetSSL() = handle->ssl_status();\n  }\n\n  if (!new_entry) {\n    new_entry = base::WrapUnique(new NavigationEntryImpl);\n\n    GURL url = params.url;\n    bool needs_update = false;\n    BrowserURLHandlerImpl::GetInstance()->RewriteURLIfNecessary(\n        &url, browser_context_, &needs_update);\n    new_entry->set_update_virtual_url_with_url(needs_update);\n\n    update_virtual_url = needs_update;\n    new_entry->GetSSL() = handle->ssl_status();\n  }\n\n  new_entry->set_page_type(params.url_is_unreachable ? PAGE_TYPE_ERROR\n                                                     : PAGE_TYPE_NORMAL);\n  new_entry->SetURL(params.url);\n  if (update_virtual_url)\n    UpdateVirtualURLToURL(new_entry.get(), params.url);\n  new_entry->SetReferrer(params.referrer);\n  new_entry->SetTransitionType(params.transition);\n  new_entry->set_site_instance(\n      static_cast<SiteInstanceImpl*>(rfh->GetSiteInstance()));\n  new_entry->SetOriginalRequestURL(params.original_request_url);\n  new_entry->SetIsOverridingUserAgent(params.is_overriding_user_agent);\n\n  FrameNavigationEntry* frame_entry =\n      new_entry->GetFrameEntry(rfh->frame_tree_node());\n  frame_entry->set_frame_unique_name(params.frame_unique_name);\n  frame_entry->set_item_sequence_number(params.item_sequence_number);\n  frame_entry->set_document_sequence_number(params.document_sequence_number);\n  frame_entry->set_method(params.method);\n  frame_entry->set_post_id(params.post_id);\n\n  if (is_in_page && GetLastCommittedEntry()) {\n    new_entry->SetTitle(GetLastCommittedEntry()->GetTitle());\n    new_entry->GetFavicon() = GetLastCommittedEntry()->GetFavicon();\n  }\n\n  DCHECK(!params.history_list_was_cleared || !replace_entry);\n  if (params.history_list_was_cleared) {\n    DiscardNonCommittedEntriesInternal();\n    entries_.clear();\n    last_committed_entry_index_ = -1;\n  }\n\n  InsertOrReplaceEntry(std::move(new_entry), replace_entry);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186639, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n           \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525] > n; \u0153 > ce;\"\n           \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n          \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u10d5\u1012] > 3; [\u0e1a\u0e9a] > u\"),\n      UTRANS_FORWARD, parse_error, status));\n  DCHECK(U_SUCCESS(status))\n      << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186600, "func": "bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n  return url_data()->has_opaque_data();\n }\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 186672, "func": "void WebUIExtension::Send(gin::Arguments* args) {\n  blink::WebLocalFrame* frame;\n  RenderFrame* render_frame;\n  if (!ShouldRespondToRequest(&frame, &render_frame))\n    return;\n\n  std::string message;\n  if (!args->GetNext(&message)) {\n    args->ThrowError();\n    return;\n  }\n\n  if (base::EndsWith(message, \"RequiringGesture\",\n                     base::CompareCase::SENSITIVE) &&\n      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {\n    NOTREACHED();\n    return;\n  }\n\n  std::unique_ptr<base::ListValue> content;\n  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {\n    content.reset(new base::ListValue());\n  } else {\n    v8::Local<v8::Object> obj;\n    if (!args->GetNext(&obj)) {\n      args->ThrowError();\n      return;\n    }\n\n     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(\n         obj, frame->MainWorldScriptContext()));\n     DCHECK(content);\n   }\n \n  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),\n                                                frame->GetDocument().Url(),\n                                                message, *content));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7641, "func": "static int proxy_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n{\n    V9fsString fullname;\n\n    v9fs_string_init(&fullname);\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    fs->fd = v9fs_request(fs_ctx->private, T_CREATE, NULL, &fullname, flags,\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n    v9fs_string_free(&fullname);\n    if (fs->fd < 0) {\n        errno = -fs->fd;\n        fs->fd = -1;\n    }\n    return fs->fd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7435, "func": "ZEND_API int _zend_ts_hash_index_update_or_next_insert(TsHashTable *ht, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = _zend_hash_index_update_or_next_insert(TS_HASH(ht), h, pData, nDataSize, pDest, flag ZEND_FILE_LINE_RELAY_CC);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187251, "func": "WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(\n    int window_id,\n    std::string* error) {\n  Browser* browser = NULL;\n  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))\n    return nullptr;\n\n  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();\n  if (!contents) {\n    *error = \"No active web contents to capture\";\n    return nullptr;\n   }\n \n   if (!extension()->permissions_data()->CanCaptureVisiblePage(\n           SessionTabHelper::IdForTab(contents).id(), error)) {\n     return nullptr;\n   }\n  return contents;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8022, "func": "static void vnc_dpy_cursor_define(DisplayChangeListener *dcl,\n                                  QEMUCursor *c)\n{\n    VncDisplay *vd = vnc_display;\n    VncState *vs;\n\n    cursor_put(vd->cursor);\n    g_free(vd->cursor_mask);\n\n    vd->cursor = c;\n    cursor_get(vd->cursor);\n    vd->cursor_msize = cursor_get_mono_bpl(c) * c->height;\n    vd->cursor_mask = g_malloc0(vd->cursor_msize);\n    cursor_get_mono_mask(c, 0, vd->cursor_mask);\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_cursor_define(vs);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8283, "func": "Rotation XRRConfigRotations(XRRScreenConfiguration *config, Rotation *current_rotation)\n{\n  *current_rotation = config->current_rotation;\n  return config->rotations;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186376, "func": "void ClientControlledShellSurface::OnBoundsChangeEvent(\n    ash::WindowStateType current_state,\n    ash::WindowStateType requested_state,\n     int64_t display_id,\n     const gfx::Rect& window_bounds,\n     int bounds_change) {\n  if (!geometry().IsEmpty() && !window_bounds.IsEmpty() &&\n      (!widget_->IsMinimized() ||\n       requested_state != ash::WindowStateType::kMinimized) &&\n      bounds_changed_callback_) {\n    ash::NonClientFrameViewAsh* frame_view = GetFrameView();\n\n    const bool becoming_snapped =\n        requested_state == ash::WindowStateType::kLeftSnapped ||\n        requested_state == ash::WindowStateType::kRightSnapped;\n    const bool is_tablet_mode =\n        WMHelper::GetInstance()->IsTabletModeWindowManagerEnabled();\n    gfx::Rect client_bounds =\n        becoming_snapped && is_tablet_mode\n            ? window_bounds\n            : frame_view->GetClientBoundsForWindowBounds(window_bounds);\n    gfx::Size current_size = frame_view->GetBoundsForClientView().size();\n    bool is_resize = client_bounds.size() != current_size &&\n                     !widget_->IsMaximized() && !widget_->IsFullscreen();\n\n    bounds_changed_callback_.Run(current_state, requested_state, display_id,\n                                 client_bounds, is_resize, bounds_change);\n\n    auto* window_state = GetWindowState();\n    if (server_reparent_window_ &&\n        window_state->GetDisplay().id() != display_id) {\n      ScopedSetBoundsLocally scoped_set_bounds(this);\n      int container_id = window_state->window()->parent()->id();\n      aura::Window* new_parent =\n          ash::Shell::GetRootWindowControllerWithDisplayId(display_id)\n              ->GetContainer(container_id);\n      new_parent->AddChild(window_state->window());\n    }\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8029, "func": "static void vnc_led_state_change(VncState *vs)\n{\n    int ledstate = 0;\n\n    if (!vnc_has_feature(vs, VNC_FEATURE_LED_STATE)) {\n        return;\n    }\n\n    ledstate = current_led_state(vs);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0, 1, 1, VNC_ENCODING_LED_STATE);\n    vnc_write_u8(vs, ledstate);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186890, "func": "void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n  memory_instrumentation::MemoryInstrumentation::GetInstance()\n      ->GetVmRegionsForHeapProfiler(base::Bind(\n          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n          weak_factory_.GetWeakPtr(), keep_small_allocations,\n          strip_path_from_mapped_files, base::Passed(&callback)));\n }\n", "target": 1, "flaw_line_index": "7,8,9,10,11"}
{"idx": 8269, "func": "static XPointer alloc_mem_cache(void)\n{\n    struct mem_cache_str *cache;\n\n    cache = (struct mem_cache_str *) Xmalloc(sizeof(struct mem_cache_str));\n    if (cache) {\n\tcache->display_closed = False;\n\tcache->inter_data = NULL;\n\tcache->inter_data_count = 0;\n\tcache->reply_buffers = NULL;\n    }\n    return (XPointer) cache;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8203, "func": "static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8304, "func": "XFixesCreateRegionFromGC (Display *dpy, GC gc)\n{\n    XFixesExtDisplayInfo\t\t*info = XFixesFindDisplay (dpy);\n    xXFixesCreateRegionFromGCReq\t*req;\n    XserverRegion\t\t\tregion;\n\n    XFixesCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (XFixesCreateRegionFromGC, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesCreateRegionFromGC;\n    region = req->region = XAllocID (dpy);\n    req->gc = gc->gid;\n    UnlockDisplay (dpy);\n    SyncHandle();\n    return region;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7986, "func": "void start_auth_vnc(VncState *vs)\n{\n    make_challenge(vs);\n    vnc_write(vs, vs->challenge, sizeof(vs->challenge));\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_client_auth_vnc, sizeof(vs->challenge));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7878, "func": "void select_soundhw(const char *optarg)\n{\n    struct soundhw *c;\n\n    if (is_help_option(optarg)) {\n    show_valid_cards:\n\n        if (soundhw_count) {\n             printf(\"Valid sound card names (comma separated):\\n\");\n             for (c = soundhw; c->name; ++c) {\n                 printf (\"%-11s %s\\n\", c->name, c->descr);\n             }\n             printf(\"\\n-soundhw all will enable all of the above\\n\");\n        } else {\n             printf(\"Machine has no user-selectable audio hardware \"\n                    \"(it may or may not have always-present audio hardware).\\n\");\n        }\n        exit(!is_help_option(optarg));\n    }\n    else {\n        size_t l;\n        const char *p;\n        char *e;\n        int bad_card = 0;\n\n        if (!strcmp(optarg, \"all\")) {\n            for (c = soundhw; c->name; ++c) {\n                c->enabled = 1;\n            }\n            return;\n        }\n\n        p = optarg;\n        while (*p) {\n            e = strchr(p, ',');\n            l = !e ? strlen(p) : (size_t) (e - p);\n\n            for (c = soundhw; c->name; ++c) {\n                if (!strncmp(c->name, p, l) && !c->name[l]) {\n                    c->enabled = 1;\n                    break;\n                }\n            }\n\n            if (!c->name) {\n                if (l > 80) {\n                    error_report(\"Unknown sound card name (too big to show)\");\n                }\n                else {\n                    error_report(\"Unknown sound card name `%.*s'\",\n                                 (int) l, p);\n                }\n                bad_card = 1;\n            }\n            p += l + (e != NULL);\n        }\n\n        if (bad_card) {\n            goto show_valid_cards;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186880, "func": "void DoCanonicalizeRef(const CHAR* spec,\n                       const Component& ref,\n                       CanonOutput* output,\n                       Component* out_ref) {\n  if (ref.len < 0) {\n    *out_ref = Component();\n    return;\n  }\n\n  output->push_back('#');\n  out_ref->begin = output->length();\n\n  int end = ref.end();\n  for (int i = ref.begin; i < end; i++) {\n    if (spec[i] == 0) {\n      continue;\n    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {\n      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);\n    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n      unsigned code_point;\n      ReadUTFChar(spec, &i, end, &code_point);\n      AppendUTF8Value(code_point, output);\n     }\n   }\n \n  out_ref->len = output->length() - out_ref->begin;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186920, "func": "void ScriptProcessorHandler::Process(size_t frames_to_process) {\n\n  AudioBus* input_bus = Input(0).Bus();\n  AudioBus* output_bus = Output(0).Bus();\n\n  unsigned double_buffer_index = this->DoubleBufferIndex();\n  bool is_double_buffer_index_good =\n      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&\n      double_buffer_index < output_buffers_.size();\n  DCHECK(is_double_buffer_index_good);\n  if (!is_double_buffer_index_good)\n    return;\n\n  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();\n  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();\n\n  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();\n  bool buffers_are_good =\n      output_buffer && BufferSize() == output_buffer->length() &&\n      buffer_read_write_index_ + frames_to_process <= BufferSize();\n\n  if (internal_input_bus_->NumberOfChannels())\n    buffers_are_good = buffers_are_good && input_buffer &&\n                       BufferSize() == input_buffer->length();\n\n  DCHECK(buffers_are_good);\n  if (!buffers_are_good)\n    return;\n\n  bool is_frames_to_process_good = frames_to_process &&\n                                   BufferSize() >= frames_to_process &&\n                                   !(BufferSize() % frames_to_process);\n  DCHECK(is_frames_to_process_good);\n  if (!is_frames_to_process_good)\n    return;\n\n  unsigned number_of_output_channels = output_bus->NumberOfChannels();\n\n  bool channels_are_good =\n      (number_of_input_channels == number_of_input_channels_) &&\n      (number_of_output_channels == number_of_output_channels_);\n  DCHECK(channels_are_good);\n  if (!channels_are_good)\n    return;\n\n  for (unsigned i = 0; i < number_of_input_channels; ++i)\n    internal_input_bus_->SetChannelMemory(\n        i,\n        input_buffer->getChannelData(i).View()->Data() +\n            buffer_read_write_index_,\n        frames_to_process);\n\n  if (number_of_input_channels)\n    internal_input_bus_->CopyFrom(*input_bus);\n\n  for (unsigned i = 0; i < number_of_output_channels; ++i) {\n    memcpy(output_bus->Channel(i)->MutableData(),\n           output_buffer->getChannelData(i).View()->Data() +\n               buffer_read_write_index_,\n           sizeof(float) * frames_to_process);\n  }\n\n  buffer_read_write_index_ =\n      (buffer_read_write_index_ + frames_to_process) % BufferSize();\n\n  if (!buffer_read_write_index_) {\n    MutexTryLocker try_locker(process_event_lock_);\n    if (!try_locker.Locked()) {\n      output_buffer->Zero();\n    } else if (Context()->GetExecutionContext()) {\n      if (Context()->HasRealtimeConstraint()) {\n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(BLINK_FROM_HERE,\n                       CrossThreadBind(\n                           &ScriptProcessorHandler::FireProcessEvent,\n                           CrossThreadUnretained(this), double_buffer_index_));\n       } else {\n        std::unique_ptr<WaitableEvent> waitable_event =\n            WTF::MakeUnique<WaitableEvent>();\n \n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(BLINK_FROM_HERE,\n                       CrossThreadBind(\n                           &ScriptProcessorHandler::\n                               FireProcessEventForOfflineAudioContext,\n                           CrossThreadUnretained(this), double_buffer_index_,\n                           CrossThreadUnretained(waitable_event.get())));\n \n        waitable_event->Wait();\n      }\n    }\n\n    SwapBuffers();\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7823, "func": "  TT_Load_Context( TT_ExecContext  exec,\n                   TT_Face         face,\n                   TT_Size         size )\n  {\n    FT_Int          i;\n    FT_ULong        tmp;\n    TT_MaxProfile*  maxp;\n    FT_Error        error;\n\n\n    exec->face = face;\n    maxp       = &face->max_profile;\n    exec->size = size;\n\n    if ( size )\n    {\n      exec->numFDefs   = size->num_function_defs;\n      exec->maxFDefs   = size->max_function_defs;\n      exec->numIDefs   = size->num_instruction_defs;\n      exec->maxIDefs   = size->max_instruction_defs;\n      exec->FDefs      = size->function_defs;\n      exec->IDefs      = size->instruction_defs;\n      exec->tt_metrics = size->ttmetrics;\n      exec->metrics    = size->metrics;\n\n      exec->maxFunc    = size->max_func;\n      exec->maxIns     = size->max_ins;\n\n      for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )\n        exec->codeRangeTable[i] = size->codeRangeTable[i];\n\n      exec->GS = size->GS;\n\n      exec->cvtSize = size->cvt_size;\n      exec->cvt     = size->cvt;\n\n      exec->storeSize = size->storage_size;\n      exec->storage   = size->storage;\n\n      exec->twilight  = size->twilight;\n    }\n\n    tmp = exec->stackSize;\n    error = Update_Max( exec->memory,\n                        &tmp,\n                        sizeof ( FT_F26Dot6 ),\n                        (void*)&exec->stack,\n                        maxp->maxStackElements + 32 );\n    exec->stackSize = (FT_UInt)tmp;\n    if ( error )\n      return error;\n\n    tmp = exec->glyphSize;\n    error = Update_Max( exec->memory,\n                        &tmp,\n                        sizeof ( FT_Byte ),\n                        (void*)&exec->glyphIns,\n                        maxp->maxSizeOfInstructions );\n    exec->glyphSize = (FT_UShort)tmp;\n    if ( error )\n      return error;\n\n    exec->pts.n_points   = 0;\n    exec->pts.n_contours = 0;\n\n    exec->zp1 = exec->pts;\n    exec->zp2 = exec->pts;\n    exec->zp0 = exec->pts;\n\n    exec->instruction_trap = FALSE;\n\n    return TT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7565, "func": "static inline void cirrus_bitblt_fgcol(CirrusVGAState *s)\n{\n    unsigned int color;\n    switch (s->cirrus_blt_pixelwidth) {\n    case 1:\n        s->cirrus_blt_fgcol = s->cirrus_shadow_gr1;\n        break;\n    case 2:\n        color = s->cirrus_shadow_gr1 | (s->vga.gr[0x11] << 8);\n        s->cirrus_blt_fgcol = le16_to_cpu(color);\n        break;\n    case 3:\n        s->cirrus_blt_fgcol = s->cirrus_shadow_gr1 |\n            (s->vga.gr[0x11] << 8) | (s->vga.gr[0x13] << 16);\n        break;\n    default:\n    case 4:\n        color = s->cirrus_shadow_gr1 | (s->vga.gr[0x11] << 8) |\n            (s->vga.gr[0x13] << 16) | (s->vga.gr[0x15] << 24);\n        s->cirrus_blt_fgcol = le32_to_cpu(color);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187226, "func": "static int hid_clear_halt(int sub_api, struct libusb_device_handle *dev_handle, unsigned char endpoint)\n{\n\tstruct libusb_context *ctx = DEVICE_CTX(dev_handle->dev);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n\tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n\tHANDLE hid_handle;\n\tint current_interface;\n\tCHECK_HID_AVAILABLE;\n\tcurrent_interface = interface_by_endpoint(priv, handle_priv, endpoint);\n\tif (current_interface < 0) {\n\t\tusbi_err(ctx, \"unable to match endpoint to an open interface - cannot clear\");\n\t\treturn LIBUSB_ERROR_NOT_FOUND;\n\t}\n\tusbi_dbg(\"matched endpoint %02X with interface %d\", endpoint, current_interface);\n\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\tif (!HidD_FlushQueue(hid_handle)) {\n\t\tusbi_err(ctx, \"Flushing of HID queue failed: %s\", windows_error_str(0));\n\t\treturn LIBUSB_ERROR_NO_DEVICE;\n\t}\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22"}
{"idx": 187295, "func": " void FileBrowserHandlerCustomBindings::GetExternalFileEntry(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n #if defined(OS_CHROMEOS)\n     CHECK(args.Length() == 1);\n     CHECK(args[0]->IsObject());\n    v8::Local<v8::Object> file_def = args[0]->ToObject();\n    std::string file_system_name(\n        *v8::String::Utf8Value(file_def->Get(\n            v8::String::NewFromUtf8(args.GetIsolate(), \"fileSystemName\"))));\n    GURL file_system_root(\n        *v8::String::Utf8Value(file_def->Get(\n            v8::String::NewFromUtf8(args.GetIsolate(), \"fileSystemRoot\"))));\n    std::string file_full_path(\n        *v8::String::Utf8Value(file_def->Get(\n            v8::String::NewFromUtf8(args.GetIsolate(), \"fileFullPath\"))));\n    bool is_directory = file_def->Get(v8::String::NewFromUtf8(\n        args.GetIsolate(), \"fileIsDirectory\"))->ToBoolean()->Value();\n    blink::WebDOMFileSystem::EntryType entry_type =\n         is_directory ? blink::WebDOMFileSystem::EntryTypeDirectory\n                      : blink::WebDOMFileSystem::EntryTypeFile;\n     blink::WebLocalFrame* webframe =\n        blink::WebLocalFrame::frameForContext(context()->v8_context());\n     args.GetReturnValue().Set(\n         blink::WebDOMFileSystem::create(\n             webframe,\n            blink::WebFileSystemTypeExternal,\n            blink::WebString::fromUTF8(file_system_name),\n            file_system_root)\n            .createV8Entry(blink::WebString::fromUTF8(file_full_path),\n                           entry_type,\n                           args.Holder(),\n                           args.GetIsolate()));\n #endif\n }\n", "target": 1, "flaw_line_index": "2,2,2,22"}
{"idx": 186560, "func": " bool IsValidURL(const GURL& url, PortPermission port_permission) {\n   return url.is_valid() && url.SchemeIsHTTPOrHTTPS() &&\n         (url.port().empty() || (port_permission == ALLOW_NON_STANDARD_PORTS));\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7609, "func": "static void cirrus_vga_write_cr(CirrusVGAState * s, int reg_value)\n{\n    switch (s->vga.cr_index) {\n    case 0x00:\t\t\t\n    case 0x01:\t\t\t\n    case 0x02:\t\t\t\n    case 0x03:\t\t\t\n    case 0x04:\t\t\t\n    case 0x05:\t\t\t\n    case 0x06:\t\t\t\n    case 0x07:\t\t\t\n    case 0x08:\t\t\t\n    case 0x09:\t\t\t\n    case 0x0a:\t\t\t\n    case 0x0b:\t\t\t\n    case 0x0c:\t\t\t\n    case 0x0d:\t\t\t\n    case 0x0e:\t\t\t\n    case 0x0f:\t\t\t\n    case 0x10:\t\t\t\n    case 0x11:\t\t\t\n    case 0x12:\t\t\t\n    case 0x13:\t\t\t\n    case 0x14:\t\t\t\n    case 0x15:\t\t\t\n    case 0x16:\t\t\t\n    case 0x17:\t\t\t\n    case 0x18:\t\t\t\n\tif ((s->vga.cr[0x11] & 0x80) && s->vga.cr_index <= 7) {\n\t    if (s->vga.cr_index == 7)\n\t\ts->vga.cr[7] = (s->vga.cr[7] & ~0x10) | (reg_value & 0x10);\n\t    return;\n\t}\n\ts->vga.cr[s->vga.cr_index] = reg_value;\n\tswitch(s->vga.cr_index) {\n\tcase 0x00:\n\tcase 0x04:\n\tcase 0x05:\n\tcase 0x06:\n\tcase 0x07:\n\tcase 0x11:\n\tcase 0x17:\n\t    s->vga.update_retrace_info(&s->vga);\n\t    break;\n\t}\n        break;\n    case 0x19:\t\t\t\n    case 0x1a:\t\t\t\n    case 0x1b:\t\t\t\n    case 0x1c:\t\t\t\n    case 0x1d:\t\t\t\n\ts->vga.cr[s->vga.cr_index] = reg_value;\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: handled outport cr_index %02x, cr_value %02x\\n\",\n\t       s->vga.cr_index, reg_value);\n#endif\n\tbreak;\n    case 0x22:\t\t\t\n    case 0x24:\t\t\t\n    case 0x26:\t\t\t\n    case 0x27:\t\t\t\n\tbreak;\n    case 0x25:\t\t\t\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: outport cr_index %02x, cr_value %02x\\n\",\n               s->vga.cr_index, reg_value);\n#endif\n\tbreak;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7569, "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n{\n    cirrus_fill_t rop_func;\n\n    if (blit_is_unsafe(s)) {\n        return 0;\n    }\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n             s->cirrus_blt_dstpitch,\n             s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t     s->cirrus_blt_height);\n    cirrus_bitblt_reset(s);\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186391, "func": " SecureProxyChecker::SecureProxyChecker(\n     scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory)\n    : url_loader_factory_(std::move(url_loader_factory)) {}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8185, "func": "static int coroutine_fn v9fs_complete_rename(V9fsPDU *pdu, V9fsFidState *fidp,\n                                             int32_t newdirfid,\n                                             V9fsString *name)\n{\n    char *end;\n    int err = 0;\n    V9fsPath new_path;\n    V9fsFidState *tfidp;\n    V9fsState *s = pdu->s;\n    V9fsFidState *dirfidp = NULL;\n    char *old_name, *new_name;\n\n    v9fs_path_init(&new_path);\n    if (newdirfid != -1) {\n        dirfidp = get_fid(pdu, newdirfid);\n        if (dirfidp == NULL) {\n            err = -ENOENT;\n            goto out_nofid;\n        }\n        BUG_ON(dirfidp->fid_type != P9_FID_NONE);\n        v9fs_co_name_to_path(pdu, &dirfidp->path, name->data, &new_path);\n    } else {\n        old_name = fidp->path.data;\n        end = strrchr(old_name, '/');\n        if (end) {\n            end++;\n        } else {\n            end = old_name;\n        }\n        new_name = g_malloc0(end - old_name + name->size + 1);\n        strncat(new_name, old_name, end - old_name);\n        strncat(new_name + (end - old_name), name->data, name->size);\n        v9fs_co_name_to_path(pdu, NULL, new_name, &new_path);\n        g_free(new_name);\n    }\n    err = v9fs_co_rename(pdu, &fidp->path, &new_path);\n    if (err < 0) {\n        goto out;\n    }\n    for (tfidp = s->fid_list; tfidp; tfidp = tfidp->next) {\n        if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {\n            v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));\n        }\n    }\nout:\n    if (dirfidp) {\n        put_fid(pdu, dirfidp);\n    }\n    v9fs_path_free(&new_path);\nout_nofid:\n    return err;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187088, "func": " std::string MediaStreamManager::MakeMediaAccessRequest(\n     int render_process_id,\n     int render_frame_id,\n     int page_request_id,\n     const StreamControls& controls,\n     const url::Origin& security_origin,\n     MediaAccessRequestCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   DeviceRequest* request = new DeviceRequest(\n      render_process_id, render_frame_id, page_request_id,\n       false \n, MEDIA_DEVICE_ACCESS, controls,\n       MediaDeviceSaltAndOrigin{std::string() \n,\n                                std::string() \n,\n                               security_origin});\n\n  const std::string& label = AddRequest(request);\n\n  request->media_access_request_cb = std::move(callback);\n  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},\n                           base::BindOnce(&MediaStreamManager::SetUpRequest,\n                                          base::Unretained(this), label));\n  return label;\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 7425, "func": "ZEND_API zval *zend_ts_hash_index_find(TsHashTable *ht, zend_ulong h)\n{\n\tzval *retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_index_find(TS_HASH(ht), h);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7856, "func": "uint64_t norm_mig_pages_transferred(void)\n{\n    return acct_info.norm_pages;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186986, "func": "  AccessType GetExtensionAccess(const Extension* extension,\n                                const GURL& url,\n                                 int tab_id) {\n     bool allowed_script = IsAllowedScript(extension, url, tab_id);\n     bool allowed_capture = extension->permissions_data()->CanCaptureVisiblePage(\n        url, tab_id, nullptr);\n \n     if (allowed_script && allowed_capture)\n       return ALLOWED_SCRIPT_AND_CAPTURE;\n    if (allowed_script)\n      return ALLOWED_SCRIPT_ONLY;\n    if (allowed_capture)\n      return ALLOWED_CAPTURE_ONLY;\n    return DISALLOWED;\n  }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8158, "func": "void Gfx::opSetStrokeColorN(Object args[], int numArgs) {\n  GfxColor color;\n  GfxPattern *pattern;\n  int i;\n\n  if (state->getStrokeColorSpace()->getMode() == csPattern) {\n    if (numArgs > 1) {\n      if (!((GfxPatternColorSpace *)state->getStrokeColorSpace())\n\t       ->getUnder() ||\n\t  numArgs - 1 != ((GfxPatternColorSpace *)state->getStrokeColorSpace())\n\t                     ->getUnder()->getNComps()) {\n\terror(getPos(), \"Incorrect number of arguments in 'SCN' command\");\n\treturn;\n      }\n      for (i = 0; i < numArgs - 1 && i < gfxColorMaxComps; ++i) {\n\tif (args[i].isNum()) {\n\t  color.c[i] = dblToCol(args[i].getNum());\n\t}\n      }\n      state->setStrokeColor(&color);\n      out->updateStrokeColor(state);\n    }\n    if (args[numArgs-1].isName() &&\n\t(pattern = res->lookupPattern(args[numArgs-1].getName(), this))) {\n      state->setStrokePattern(pattern);\n    }\n\n  } else {\n    if (numArgs != state->getStrokeColorSpace()->getNComps()) {\n      error(getPos(), \"Incorrect number of arguments in 'SCN' command\");\n      return;\n    }\n    state->setStrokePattern(NULL);\n    for (i = 0; i < numArgs && i < gfxColorMaxComps; ++i) {\n      if (args[i].isNum()) {\n\tcolor.c[i] = dblToCol(args[i].getNum());\n      }\n    }\n    state->setStrokeColor(&color);\n    out->updateStrokeColor(state);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186742, "func": "void SecurityHandler::SetRenderer(RenderProcessHost* process_host,\n                                   RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n   if (enabled_ && host_)\n    AttachToRenderFrameHost();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7847, "func": "static int load_xbzrle(QEMUFile *f, ram_addr_t addr, void *host)\n{\n    unsigned int xh_len;\n    int xh_flags;\n\n    if (!xbzrle_decoded_buf) {\n        xbzrle_decoded_buf = g_malloc(TARGET_PAGE_SIZE);\n    }\n\n    xh_flags = qemu_get_byte(f);\n    xh_len = qemu_get_be16(f);\n\n    if (xh_flags != ENCODING_FLAG_XBZRLE) {\n        error_report(\"Failed to load XBZRLE page - wrong compression!\");\n        return -1;\n    }\n\n    if (xh_len > TARGET_PAGE_SIZE) {\n        error_report(\"Failed to load XBZRLE page - len overflow!\");\n        return -1;\n    }\n    qemu_get_buffer(f, xbzrle_decoded_buf, xh_len);\n\n    if (xbzrle_decode_buffer(xbzrle_decoded_buf, xh_len, host,\n                             TARGET_PAGE_SIZE) == -1) {\n        error_report(\"Failed to load XBZRLE page - decode error!\");\n        return -1;\n    }\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187124, "func": "  void ProcessBackingStore(HeapObjectHeader* header) {\n     EXPECT_TRUE(header->IsValid());\n     EXPECT_TRUE(header->IsMarked());\n     header->Unmark();\n    ThreadHeap::GcInfo(header->GcInfoIndex())->trace_(this, header->Payload());\n   }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 186847, "func": "bool SharedMemoryHandleProvider::InitFromMojoHandle(\n    mojo::ScopedSharedBufferHandle buffer_handle) {\n#if DCHECK_IS_ON()\n  DCHECK_EQ(map_ref_count_, 0);\n#endif\n   DCHECK(!shared_memory_);\n \n   base::SharedMemoryHandle memory_handle;\n  const MojoResult result =\n      mojo::UnwrapSharedMemoryHandle(std::move(buffer_handle), &memory_handle,\n                                     &mapped_size_, &read_only_flag_);\n   if (result != MOJO_RESULT_OK)\n     return false;\n   shared_memory_.emplace(memory_handle, read_only_flag_);\n   return true;\n }\n", "target": 1, "flaw_line_index": "9,10,11"}
{"idx": 7479, "func": "ssize_t notsup_listxattr(FsContext *ctx, const char *path, char *name,\n                         void *value, size_t size)\n{\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7743, "func": "static void coroutine_fn virtfs_co_reset(void *opaque)\n{\n    VirtfsCoResetData *data = opaque;\n\n    virtfs_reset(&data->pdu);\n    data->done = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7431, "func": "ZEND_API void zend_ts_hash_reverse_apply(TsHashTable *ht, apply_func_t apply_func)\n{\n\tbegin_write(ht);\n\tzend_hash_reverse_apply(TS_HASH(ht), apply_func);\n\tend_write(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187001, "func": "download::DownloadInterruptReason DownloadManagerImpl::BeginDownloadRequest(\n    std::unique_ptr<net::URLRequest> url_request,\n    ResourceContext* resource_context,\n    download::DownloadUrlParameters* params) {\n  if (ResourceDispatcherHostImpl::Get()->is_shutdown())\n    return download::DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN;\n\n  ResourceDispatcherHostImpl::Get()->InitializeURLRequest(\n      url_request.get(),\n      Referrer(params->referrer(),\n               Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                    params->referrer_policy())),\n       true,  \n       params->render_process_host_id(), params->render_view_host_routing_id(),\n      params->render_frame_host_routing_id(), PREVIEWS_OFF, resource_context);\n \n  url_request->set_first_party_url_policy(\n      net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);\n\n  const GURL& url = url_request->original_url();\n\n  const net::URLRequestContext* request_context = url_request->context();\n  if (!request_context->job_factory()->IsHandledProtocol(url.scheme())) {\n    DVLOG(1) << \"Download request for unsupported protocol: \"\n             << url.possibly_invalid_spec();\n    return download::DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST;\n  }\n\n  std::unique_ptr<ResourceHandler> handler(\n      DownloadResourceHandler::CreateForNewRequest(\n          url_request.get(), params->request_origin(),\n          params->download_source(), params->follow_cross_origin_redirects()));\n\n  ResourceDispatcherHostImpl::Get()->BeginURLRequest(\n      std::move(url_request), std::move(handler), true,  \n      params->content_initiated(), params->do_not_prompt_for_login(),\n      resource_context);\n  return download::DOWNLOAD_INTERRUPT_REASON_NONE;\n}\n", "target": 1, "flaw_line_index": "17"}
{"idx": 8166, "func": "void Gfx::opSetWordSpacing(Object args[], int numArgs) {\n  state->setWordSpace(args[0].getNum());\n  out->updateWordSpace(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186447, "func": "bool ResourceFetcher::StartLoad(Resource* resource) {\n  DCHECK(resource);\n  DCHECK(resource->StillNeedsLoad());\n\n  ResourceRequest request(resource->GetResourceRequest());\n  ResourceLoader* loader = nullptr;\n\n  {\n    Resource::RevalidationStartForbiddenScope\n        revalidation_start_forbidden_scope(resource);\n    ScriptForbiddenIfMainThreadScope script_forbidden_scope;\n\n    if (!Context().ShouldLoadNewResource(resource->GetType()) &&\n        IsMainThread()) {\n      GetMemoryCache()->Remove(resource);\n      return false;\n    }\n\n    ResourceResponse response;\n\n    blink::probe::PlatformSendRequest probe(&Context(), resource->Identifier(),\n                                            request, response,\n                                             resource->Options().initiator_info);\n \n     Context().DispatchWillSendRequest(resource->Identifier(), request, response,\n                                       resource->Options().initiator_info);\n \n    SecurityOrigin* source_origin = Context().GetSecurityOrigin();\n    if (source_origin && source_origin->HasSuborigin())\n      request.SetServiceWorkerMode(WebURLRequest::ServiceWorkerMode::kNone);\n\n    resource->SetResourceRequest(request);\n\n    loader = ResourceLoader::Create(this, scheduler_, resource);\n    if (resource->ShouldBlockLoadEvent())\n      loaders_.insert(loader);\n    else\n      non_blocking_loaders_.insert(loader);\n\n    StorePerformanceTimingInitiatorInformation(resource);\n    resource->SetFetcherSecurityOrigin(source_origin);\n\n    Resource::ProhibitAddRemoveClientInScope\n        prohibit_add_remove_client_in_scope(resource);\n\n    resource->NotifyStartLoad();\n  }\n\n  loader->Start();\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186789, "func": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitSlice(\n    const H264PPS* pps,\n    const H264SliceHeader* slice_hdr,\n    const H264Picture::Vector& ref_pic_list0,\n    const H264Picture::Vector& ref_pic_list1,\n     const scoped_refptr<H264Picture>& pic,\n     const uint8_t* data,\n     size_t size) {\n   VASliceParameterBufferH264 slice_param;\n   memset(&slice_param, 0, sizeof(slice_param));\n \n  slice_param.slice_data_size = slice_hdr->nalu_size;\n  slice_param.slice_data_offset = 0;\n  slice_param.slice_data_flag = VA_SLICE_DATA_FLAG_ALL;\n  slice_param.slice_data_bit_offset = slice_hdr->header_bit_size;\n\n#define SHDRToSP(a) slice_param.a = slice_hdr->a\n  SHDRToSP(first_mb_in_slice);\n  slice_param.slice_type = slice_hdr->slice_type % 5;\n  SHDRToSP(direct_spatial_mv_pred_flag);\n\n  SHDRToSP(num_ref_idx_l0_active_minus1);\n  SHDRToSP(num_ref_idx_l1_active_minus1);\n  SHDRToSP(cabac_init_idc);\n  SHDRToSP(slice_qp_delta);\n  SHDRToSP(disable_deblocking_filter_idc);\n  SHDRToSP(slice_alpha_c0_offset_div2);\n  SHDRToSP(slice_beta_offset_div2);\n\n  if (((slice_hdr->IsPSlice() || slice_hdr->IsSPSlice()) &&\n       pps->weighted_pred_flag) ||\n      (slice_hdr->IsBSlice() && pps->weighted_bipred_idc == 1)) {\n    SHDRToSP(luma_log2_weight_denom);\n    SHDRToSP(chroma_log2_weight_denom);\n\n    SHDRToSP(luma_weight_l0_flag);\n    SHDRToSP(luma_weight_l1_flag);\n\n    SHDRToSP(chroma_weight_l0_flag);\n    SHDRToSP(chroma_weight_l1_flag);\n\n    for (int i = 0; i <= slice_param.num_ref_idx_l0_active_minus1; ++i) {\n      slice_param.luma_weight_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_weight[i];\n      slice_param.luma_offset_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_offset[i];\n\n      for (int j = 0; j < 2; ++j) {\n        slice_param.chroma_weight_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_weight[i][j];\n        slice_param.chroma_offset_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_offset[i][j];\n      }\n    }\n\n    if (slice_hdr->IsBSlice()) {\n      for (int i = 0; i <= slice_param.num_ref_idx_l1_active_minus1; ++i) {\n        slice_param.luma_weight_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_weight[i];\n        slice_param.luma_offset_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_offset[i];\n\n        for (int j = 0; j < 2; ++j) {\n          slice_param.chroma_weight_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_weight[i][j];\n          slice_param.chroma_offset_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_offset[i][j];\n        }\n      }\n    }\n  }\n\n  static_assert(\n      arraysize(slice_param.RefPicList0) == arraysize(slice_param.RefPicList1),\n      \"Invalid RefPicList sizes\");\n\n  for (size_t i = 0; i < arraysize(slice_param.RefPicList0); ++i) {\n    InitVAPicture(&slice_param.RefPicList0[i]);\n    InitVAPicture(&slice_param.RefPicList1[i]);\n  }\n\n  for (size_t i = 0;\n       i < ref_pic_list0.size() && i < arraysize(slice_param.RefPicList0);\n       ++i) {\n    if (ref_pic_list0[i])\n      FillVAPicture(&slice_param.RefPicList0[i], ref_pic_list0[i]);\n  }\n  for (size_t i = 0;\n       i < ref_pic_list1.size() && i < arraysize(slice_param.RefPicList1);\n       ++i) {\n    if (ref_pic_list1[i])\n      FillVAPicture(&slice_param.RefPicList1[i], ref_pic_list1[i]);\n  }\n\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceParameterBufferType,\n                                    sizeof(slice_param), &slice_param))\n    return false;\n\n  void* non_const_ptr = const_cast<uint8_t*>(data);\n  return vaapi_wrapper_->SubmitBuffer(VASliceDataBufferType, size,\n                                      non_const_ptr);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186510, "func": " void SendTabToSelfInfoBarDelegate::OpenTab() {\n  NOTIMPLEMENTED();\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8227, "func": "static void v9fs_readdir(void *opaque)\n{\n    int32_t fid;\n    V9fsFidState *fidp;\n    ssize_t retval = 0;\n    size_t offset = 7;\n    uint64_t initial_offset;\n    int32_t count;\n    uint32_t max_count;\n    V9fsPDU *pdu = opaque;\n\n    retval = pdu_unmarshal(pdu, offset, \"dqd\", &fid,\n                           &initial_offset, &max_count);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -EINVAL;\n        goto out_nofid;\n    }\n    if (!fidp->fs.dir.stream) {\n        retval = -EINVAL;\n        goto out;\n    }\n    if (initial_offset == 0) {\n        v9fs_co_rewinddir(pdu, fidp);\n    } else {\n        v9fs_co_seekdir(pdu, fidp, initial_offset);\n    }\n    count = v9fs_do_readdir(pdu, fidp, max_count);\n    if (count < 0) {\n        retval = count;\n        goto out;\n    }\n    retval = pdu_marshal(pdu, offset, \"d\", count);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += count + offset;\n    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7643, "func": "static ssize_t proxy_preadv(FsContext *ctx, V9fsFidOpenState *fs,\n                            const struct iovec *iov,\n                            int iovcnt, off_t offset)\n{\n    ssize_t ret;\n#ifdef CONFIG_PREADV\n    ret = preadv(fs->fd, iov, iovcnt, offset);\n#else\n    ret = lseek(fs->fd, offset, SEEK_SET);\n    if (ret >= 0) {\n        ret = readv(fs->fd, iov, iovcnt);\n    }\n#endif\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7850, "func": "ram_addr_t migration_bitmap_find_and_reset_dirty(MemoryRegion *mr,\n                                                 ram_addr_t start)\n{\n    unsigned long base = mr->ram_addr >> TARGET_PAGE_BITS;\n    unsigned long nr = base + (start >> TARGET_PAGE_BITS);\n    uint64_t mr_size = TARGET_PAGE_ALIGN(memory_region_size(mr));\n    unsigned long size = base + (mr_size >> TARGET_PAGE_BITS);\n\n    unsigned long next;\n\n    if (ram_bulk_stage && nr > base) {\n        next = nr + 1;\n    } else {\n        next = find_next_bit(migration_bitmap, size, nr);\n    }\n\n    if (next < size) {\n        clear_bit(next, migration_bitmap);\n        migration_dirty_pages--;\n    }\n    return (next - base) << TARGET_PAGE_BITS;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186548, "func": "void PeopleHandler::HandleSignout(const base::ListValue* args) {\n  bool delete_profile = false;\n  args->GetBoolean(0, &delete_profile);\n\n  if (!signin_util::IsUserSignoutAllowedForProfile(profile_)) {\n    DCHECK(delete_profile);\n  } else {\n    SigninManager* signin_manager =\n        SigninManagerFactory::GetForProfile(profile_);\n    if (signin_manager->IsAuthenticated()) {\n      if (GetSyncService())\n        ProfileSyncService::SyncEvent(ProfileSyncService::STOP_FROM_OPTIONS);\n\n      signin_metrics::SignoutDelete delete_metric =\n          delete_profile ? signin_metrics::SignoutDelete::DELETED\n                         : signin_metrics::SignoutDelete::KEEPING;\n      signin_manager->SignOutAndRemoveAllAccounts(\n          signin_metrics::USER_CLICKED_SIGNOUT_SETTINGS, delete_metric);\n    } else {\n       DCHECK(!delete_profile)\n           << \"Deleting the profile should only be offered the user is syncing.\";\n       ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)\n          ->RevokeAllCredentials();\n     }\n   }\n \n  if (delete_profile) {\n    webui::DeleteProfileAtPath(profile_->GetPath(),\n                               ProfileMetrics::DELETE_PROFILE_SETTINGS);\n  }\n}\n", "target": 1, "flaw_line_index": "24"}
{"idx": 8163, "func": "void Gfx::opSetTextMatrix(Object args[], int numArgs) {\n  state->setTextMat(args[0].getNum(), args[1].getNum(),\n\t\t    args[2].getNum(), args[3].getNum(),\n\t\t    args[4].getNum(), args[5].getNum());\n  state->textMoveTo(0, 0);\n  out->updateTextMat(state);\n  out->updateTextPos(state);\n  fontChanged = gTrue;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186670, "func": "void XSSAuditor::Init(Document* document,\n                      XSSAuditorDelegate* auditor_delegate) {\n  DCHECK(IsMainThread());\n  if (state_ != kUninitialized)\n    return;\n  state_ = kFilteringTokens;\n\n  if (Settings* settings = document->GetSettings())\n    is_enabled_ = settings->GetXSSAuditorEnabled();\n\n  if (!is_enabled_)\n    return;\n\n  document_url_ = document->Url().Copy();\n\n  if (!document->GetFrame()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document_url_.IsEmpty()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document_url_.ProtocolIsData()) {\n    is_enabled_ = false;\n    return;\n  }\n\n  if (document->Encoding().IsValid())\n    encoding_ = document->Encoding();\n\n  if (DocumentLoader* document_loader =\n          document->GetFrame()->Loader().GetDocumentLoader()) {\n    const AtomicString& header_value =\n        document_loader->GetResponse().HttpHeaderField(\n            HTTPNames::X_XSS_Protection);\n    String error_details;\n    unsigned error_position = 0;\n    String report_url;\n    KURL xss_protection_report_url;\n\n    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(\n        header_value, error_details, error_position, report_url);\n\n    if (xss_protection_header == kAllowReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);\n    else if (xss_protection_header == kFilterReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);\n    else if (xss_protection_header == kBlockReflectedXSS)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);\n    else if (xss_protection_header == kReflectedXSSInvalid)\n      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);\n\n    did_send_valid_xss_protection_header_ =\n        xss_protection_header != kReflectedXSSUnset &&\n        xss_protection_header != kReflectedXSSInvalid;\n    if ((xss_protection_header == kFilterReflectedXSS ||\n          xss_protection_header == kBlockReflectedXSS) &&\n         !report_url.IsEmpty()) {\n       xss_protection_report_url = document->CompleteURL(report_url);\n       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),\n                                               xss_protection_report_url)) {\n         error_details = \"insecure reporting URL for secure page\";\n        xss_protection_header = kReflectedXSSInvalid;\n        xss_protection_report_url = KURL();\n      }\n    }\n    if (xss_protection_header == kReflectedXSSInvalid) {\n      document->AddConsoleMessage(ConsoleMessage::Create(\n          kSecurityMessageSource, kErrorMessageLevel,\n          \"Error parsing header X-XSS-Protection: \" + header_value + \": \" +\n              error_details + \" at character position \" +\n              String::Format(\"%u\", error_position) +\n              \". The default protections will be applied.\"));\n    }\n\n    xss_protection_ = xss_protection_header;\n    if (xss_protection_ == kReflectedXSSInvalid ||\n        xss_protection_ == kReflectedXSSUnset) {\n      xss_protection_ = kBlockReflectedXSS;\n    }\n\n    if (auditor_delegate)\n      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());\n\n    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();\n    if (http_body && !http_body->IsEmpty())\n      http_body_as_string_ = http_body->FlattenToString();\n  }\n\n  SetEncoding(encoding_);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7571, "func": "static int cirrus_bitblt_videotocpu(CirrusVGAState * s)\n{\n#ifdef DEBUG_BITBLT\n    printf(\"cirrus: bitblt (video to cpu) is not implemented yet\\n\");\n#endif\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7800, "func": "static int h2c_handle_settings(struct h2c *h2c)\n{\n\tunsigned int offset;\n\tint error;\n\n\tif (h2c->dff & H2_F_SETTINGS_ACK) {\n\t\tif (h2c->dfl) {\n\t\t\terror = H2_ERR_FRAME_SIZE_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (h2c->dsi != 0) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto fail;\n\t}\n\n\tif (h2c->dfl % 6) {\n\t\terror = H2_ERR_FRAME_SIZE_ERROR;\n\t\tgoto fail;\n\t}\n\n\tif (h2c->dfl > global.tune.bufsize) {\n\t\terror = H2_ERR_FRAME_SIZE_ERROR;\n\t\tgoto fail;\n\t}\n\n\tif (h2c->dbuf->i < h2c->dfl)\n\t\treturn 0;\n\n\tfor (offset = 0; offset < h2c->dfl; offset += 6) {\n\t\tuint16_t type = h2_get_n16(h2c->dbuf, offset);\n\t\tint32_t  arg  = h2_get_n32(h2c->dbuf, offset + 2);\n\n\t\tswitch (type) {\n\t\tcase H2_SETTINGS_INITIAL_WINDOW_SIZE:\n\t\t\tif (arg < 0) { \n\t\t\t\terror = H2_ERR_FLOW_CONTROL_ERROR;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\th2c_update_all_ws(h2c, arg - h2c->miw);\n\t\t\th2c->miw = arg;\n\t\t\tbreak;\n\t\tcase H2_SETTINGS_MAX_FRAME_SIZE:\n\t\t\tif (arg < 16384 || arg > 16777215) { \n\t\t\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\th2c->mfs = arg;\n\t\t\tbreak;\n\t\tcase H2_SETTINGS_ENABLE_PUSH:\n\t\t\tif (arg < 0 || arg > 1) { \n\t\t\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\th2c->st0 = H2_CS_FRAME_A;\n\treturn 1;\n fail:\n\th2c_error(h2c, error);\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186674, "func": "BackendImpl::BackendImpl(\n    const base::FilePath& path,\n    uint32_t mask,\n    const scoped_refptr<base::SingleThreadTaskRunner>& cache_thread,\n    net::NetLog* net_log)\n    : background_queue_(this, FallbackToInternalIfNull(cache_thread)),\n      path_(path),\n      block_files_(path),\n      mask_(mask),\n      max_size_(0),\n      up_ticks_(0),\n      cache_type_(net::DISK_CACHE),\n      uma_report_(0),\n      user_flags_(kMask),\n      init_(false),\n      restarted_(false),\n      unit_test_(false),\n      read_only_(false),\n      disabled_(false),\n       new_eviction_(false),\n       first_timer_(true),\n       user_load_(false),\n       net_log_(net_log),\n       done_(base::WaitableEvent::ResetPolicy::MANUAL,\n             base::WaitableEvent::InitialState::NOT_SIGNALED),\n      ptr_factory_(this) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7739, "func": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_stat_init(&v9stat);\n    err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_wstat(pdu->tag, pdu->id, fid,\n                     v9stat.mode, v9stat.atime, v9stat.mtime);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (donttouch_stat(&v9stat)) {\n        err = v9fs_co_fsync(pdu, fidp, 0);\n        goto out;\n    }\n    if (v9stat.mode != -1) {\n        uint32_t v9_mode;\n        err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        v9_mode = stat_to_v9mode(&stbuf);\n        if ((v9stat.mode & P9_STAT_MODE_TYPE_BITS) !=\n            (v9_mode & P9_STAT_MODE_TYPE_BITS)) {\n            err = -EIO;\n            goto out;\n        }\n        err = v9fs_co_chmod(pdu, &fidp->path,\n                            v9mode_to_mode(v9stat.mode,\n                                           &v9stat.extension));\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.mtime != -1 || v9stat.atime != -1) {\n        struct timespec times[2];\n        if (v9stat.atime != -1) {\n            times[0].tv_sec = v9stat.atime;\n            times[0].tv_nsec = 0;\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9stat.mtime != -1) {\n            times[1].tv_sec = v9stat.mtime;\n            times[1].tv_nsec = 0;\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.n_gid != -1 || v9stat.n_uid != -1) {\n        err = v9fs_co_chown(pdu, &fidp->path, v9stat.n_uid, v9stat.n_gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.name.size != 0) {\n        err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.length != -1) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9stat.length);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    v9fs_stat_free(&v9stat);\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8252, "func": "Status XvMCQueryVersion (Display *dpy, int *major, int *minor)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcQueryVersionReply rep;\n    xvmcQueryVersionReq  *req;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (QueryVersion, req);\n    if (!_XReply (dpy, (xReply *) &rep, 0, xTrue)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n        return BadImplementation;\n    }\n    *major = rep.major;\n    *minor = rep.minor;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return Success;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187074, "func": "void RenderFrameHostImpl::RegisterMojoInterfaces() {\n#if !defined(OS_ANDROID)\n  registry_->AddInterface(base::Bind(&InstalledAppProviderImplDefault::Create));\n#endif  \n\n  PermissionControllerImpl* permission_controller =\n      PermissionControllerImpl::FromBrowserContext(\n          GetProcess()->GetBrowserContext());\n  if (delegate_) {\n    auto* geolocation_context = delegate_->GetGeolocationContext();\n    if (geolocation_context) {\n      geolocation_service_.reset(new GeolocationServiceImpl(\n          geolocation_context, permission_controller, this));\n      registry_->AddInterface(\n          base::Bind(&GeolocationServiceImpl::Bind,\n                     base::Unretained(geolocation_service_.get())));\n    }\n  }\n\n  registry_->AddInterface<device::mojom::WakeLock>(base::Bind(\n      &RenderFrameHostImpl::BindWakeLockRequest, base::Unretained(this)));\n\n#if defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebNfc)) {\n    registry_->AddInterface<device::mojom::NFC>(base::Bind(\n        &RenderFrameHostImpl::BindNFCRequest, base::Unretained(this)));\n  }\n#endif\n\n  if (!permission_service_context_)\n    permission_service_context_.reset(new PermissionServiceContext(this));\n\n  registry_->AddInterface(\n      base::Bind(&PermissionServiceContext::CreateService,\n                 base::Unretained(permission_service_context_.get())));\n\n  registry_->AddInterface(\n      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::Bind(&MediaSessionServiceImpl::Create, base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(\n      base::IgnoreResult(&RenderFrameHostImpl::CreateWebBluetoothService),\n      base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateWebUsbService, base::Unretained(this)));\n\n  registry_->AddInterface<media::mojom::InterfaceFactory>(\n      base::Bind(&RenderFrameHostImpl::BindMediaInterfaceFactoryRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateWebSocket, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateDedicatedWorkerHostFactory,\n      base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&SharedWorkerConnectorImpl::Create,\n                                     process_->GetID(), routing_id_));\n\n  registry_->AddInterface(base::BindRepeating(&device::GamepadMonitor::Create));\n\n  registry_->AddInterface<device::mojom::VRService>(base::Bind(\n      &WebvrServiceProvider::BindWebvrService, base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::BindRepeating(&RenderFrameHostImpl::CreateAudioInputStreamFactory,\n                          base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::BindRepeating(&RenderFrameHostImpl::CreateAudioOutputStreamFactory,\n                          base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::Bind(&CreateFrameResourceCoordinator, base::Unretained(this)));\n\n  if (BrowserMainLoop::GetInstance()) {\n    MediaStreamManager* media_stream_manager =\n        BrowserMainLoop::GetInstance()->media_stream_manager();\n    registry_->AddInterface(\n        base::Bind(&MediaDevicesDispatcherHost::Create, GetProcess()->GetID(),\n                   GetRoutingID(), base::Unretained(media_stream_manager)),\n         base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n \n     registry_->AddInterface(\n        base::BindRepeating(\n            &RenderFrameHostImpl::CreateMediaStreamDispatcherHost,\n            base::Unretained(this), base::Unretained(media_stream_manager)),\n         base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n   }\n \n#if BUILDFLAG(ENABLE_MEDIA_REMOTING)\n  registry_->AddInterface(base::Bind(&RemoterFactoryImpl::Bind,\n                                     GetProcess()->GetID(), GetRoutingID()));\n#endif  \n\n  registry_->AddInterface(base::BindRepeating(\n      &KeyboardLockServiceImpl::CreateMojoService, base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&ImageCaptureImpl::Create));\n\n#if !defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebAuth)) {\n    registry_->AddInterface(\n        base::Bind(&RenderFrameHostImpl::BindAuthenticatorRequest,\n                   base::Unretained(this)));\n    if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n            switches::kEnableWebAuthTestingAPI)) {\n      auto* environment_singleton =\n          ScopedVirtualAuthenticatorEnvironment::GetInstance();\n      registry_->AddInterface(base::BindRepeating(\n          &ScopedVirtualAuthenticatorEnvironment::AddBinding,\n          base::Unretained(environment_singleton)));\n    }\n  }\n#endif  \n\n  sensor_provider_proxy_.reset(\n      new SensorProviderProxyImpl(permission_controller, this));\n  registry_->AddInterface(\n      base::Bind(&SensorProviderProxyImpl::Bind,\n                 base::Unretained(sensor_provider_proxy_.get())));\n\n  media::VideoDecodePerfHistory::SaveCallback save_stats_cb;\n  if (GetSiteInstance()->GetBrowserContext()->GetVideoDecodePerfHistory()) {\n    save_stats_cb = GetSiteInstance()\n                        ->GetBrowserContext()\n                        ->GetVideoDecodePerfHistory()\n                        ->GetSaveCallback();\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &media::MediaMetricsProvider::Create, frame_tree_node_->IsMainFrame(),\n      base::BindRepeating(\n          &RenderFrameHostDelegate::GetUkmSourceIdForLastCommittedSource,\n          base::Unretained(delegate_)),\n      std::move(save_stats_cb)));\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          cc::switches::kEnableGpuBenchmarking)) {\n    registry_->AddInterface(\n        base::Bind(&InputInjectorImpl::Create, weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &QuotaDispatcherHost::CreateForFrame, GetProcess(), routing_id_));\n\n  registry_->AddInterface(\n      base::BindRepeating(SpeechRecognitionDispatcherHost::Create,\n                          GetProcess()->GetID(), routing_id_),\n      base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n\n  file_system_manager_.reset(new FileSystemManagerImpl(\n      GetProcess()->GetID(), routing_id_,\n      GetProcess()->GetStoragePartition()->GetFileSystemContext(),\n      ChromeBlobStorageContext::GetFor(GetProcess()->GetBrowserContext())));\n  registry_->AddInterface(\n      base::BindRepeating(&FileSystemManagerImpl::BindRequest,\n                          base::Unretained(file_system_manager_.get())),\n      base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n\n  if (Portal::IsEnabled()) {\n    registry_->AddInterface(base::BindRepeating(IgnoreResult(&Portal::Create),\n                                                base::Unretained(this)));\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &BackgroundFetchServiceImpl::CreateForFrame, GetProcess(), routing_id_));\n\n  registry_->AddInterface(base::BindRepeating(&ContactsManagerImpl::Create));\n\n  registry_->AddInterface(\n      base::BindRepeating(&FileChooserImpl::Create, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(&AudioContextManagerImpl::Create,\n                                              base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(&WakeLockServiceImpl::Create,\n                                              base::Unretained(this)));\n}\n", "target": 1, "flaw_line_index": "101,102,103"}
{"idx": 7398, "func": "hextoint(int c)\n{\n\tif (!isascii((unsigned char) c))\n\t\treturn -1;\n\tif (isdigit((unsigned char) c))\n\t\treturn c - '0';\n\tif ((c >= 'a') && (c <= 'f'))\n\t\treturn c + 10 - 'a';\n\tif (( c>= 'A') && (c <= 'F'))\n\t\treturn c + 10 - 'A';\n\treturn -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7722, "func": "static void v9fs_init_qiov_from_pdu(QEMUIOVector *qiov, V9fsPDU *pdu,\n                                    size_t skip, size_t size,\n                                    bool is_write)\n{\n    QEMUIOVector elem;\n    struct iovec *iov;\n    unsigned int niov;\n\n    virtio_init_iov_from_pdu(pdu, &iov, &niov, is_write);\n\n    qemu_iovec_init_external(&elem, iov, niov);\n    qemu_iovec_init(qiov, niov);\n    qemu_iovec_concat(qiov, &elem, skip, size);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7451, "func": "ZEND_API int zend_ts_hash_index_exists(TsHashTable *ht, ulong h)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_index_exists(TS_HASH(ht), h);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7453, "func": "ZEND_API void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge_ex(TS_HASH(target), TS_HASH(source), pCopyConstructor, size, pMergeSource, pParam);\n\tend_write(target);\n\tend_read(source);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186976, "func": "void AppCacheUpdateJob::OnResponseInfoLoaded(\n    AppCacheResponseInfo* response_info,\n    int64_t response_id) {\n  const net::HttpResponseInfo* http_info =\n      response_info ? &response_info->http_response_info() : nullptr;\n\n  if (internal_state_ == FETCH_MANIFEST) {\n    if (http_info)\n      manifest_fetcher_->set_existing_response_headers(\n          http_info->headers.get());\n    manifest_fetcher_->Start();\n    return;\n  }\n\n  auto found = loading_responses_.find(response_id);\n  DCHECK(found != loading_responses_.end());\n  const GURL& url = found->second;\n\n  if (!http_info) {\n    LoadFromNewestCacheFailed(url, nullptr);  \n  } else if (!CanUseExistingResource(http_info)) {\n    LoadFromNewestCacheFailed(url, response_info);\n  } else {\n    DCHECK(group_->newest_complete_cache());\n    AppCacheEntry* copy_me = group_->newest_complete_cache()->GetEntry(url);\n    DCHECK(copy_me);\n    DCHECK_EQ(copy_me->response_id(), response_id);\n\n    auto it = url_file_list_.find(url);\n     DCHECK(it != url_file_list_.end());\n     AppCacheEntry& entry = it->second;\n     entry.set_response_id(response_id);\n    entry.set_response_size(copy_me->response_size());\n     inprogress_cache_->AddOrModifyEntry(url, entry);\n     NotifyAllProgress(url);\n     ++url_fetches_completed_;\n  }\n\n  loading_responses_.erase(found);\n  MaybeCompleteUpdate();\n}\n", "target": 1, "flaw_line_index": "34"}
{"idx": 7572, "func": "static int cirrus_bitblt_videotovideo(CirrusVGAState * s)\n{\n    int ret;\n\n    if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n\tret = cirrus_bitblt_videotovideo_patterncopy(s);\n    } else {\n\tret = cirrus_bitblt_videotovideo_copy(s);\n    }\n    if (ret)\n\tcirrus_bitblt_reset(s);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7602, "func": "static uint64_t cirrus_vga_mem_read(void *opaque,\n                                    hwaddr addr,\n                                    uint32_t size)\n{\n    CirrusVGAState *s = opaque;\n    unsigned bank_index;\n    unsigned bank_offset;\n    uint32_t val;\n\n    if ((s->vga.sr[0x07] & 0x01) == 0) {\n        return vga_mem_readb(&s->vga, addr);\n    }\n\n    if (addr < 0x10000) {\n\tbank_index = addr >> 15;\n\tbank_offset = addr & 0x7fff;\n\tif (bank_offset < s->cirrus_bank_limit[bank_index]) {\n\t    bank_offset += s->cirrus_bank_base[bank_index];\n\t    if ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\t\tbank_offset <<= 4;\n\t    } else if (s->vga.gr[0x0B] & 0x02) {\n\t\tbank_offset <<= 3;\n\t    }\n\t    bank_offset &= s->cirrus_addr_mask;\n\t    val = *(s->vga.vram_ptr + bank_offset);\n\t} else\n\t    val = 0xff;\n    } else if (addr >= 0x18000 && addr < 0x18100) {\n\tval = 0xff;\n\tif ((s->vga.sr[0x17] & 0x44) == 0x04) {\n\t    val = cirrus_mmio_blt_read(s, addr & 0xff);\n\t}\n    } else {\n\tval = 0xff;\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: mem_readb \" TARGET_FMT_plx \"\\n\", addr);\n#endif\n    }\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187136, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186488, "func": "TabGroupHeader::TabGroupHeader(const base::string16& group_title) {\n   constexpr gfx::Insets kPlaceholderInsets = gfx::Insets(4, 27);\n   SetBorder(views::CreateEmptyBorder(kPlaceholderInsets));\n\n  views::FlexLayout* layout =\n      SetLayoutManager(std::make_unique<views::FlexLayout>());\n  layout->SetOrientation(views::LayoutOrientation::kHorizontal)\n      .SetCollapseMargins(true)\n       .SetMainAxisAlignment(views::LayoutAlignment::kStart)\n       .SetCrossAxisAlignment(views::LayoutAlignment::kCenter);\n \n  auto title = std::make_unique<views::Label>(group_title);\n   title->SetHorizontalAlignment(gfx::ALIGN_TO_HEAD);\n   title->SetElideBehavior(gfx::FADE_TAIL);\n  auto* title_ptr = AddChildView(std::move(title));\n  layout->SetFlexForView(title_ptr,\n                          views::FlexSpecification::ForSizeRule(\n                              views::MinimumFlexSizeRule::kScaleToZero,\n                              views::MaximumFlexSizeRule::kUnbounded));\n\n  auto group_menu_button = views::CreateVectorImageButton(\n nullptr);\n  views::SetImageFromVectorIcon(group_menu_button.get(), kBrowserToolsIcon);\n  AddChildView(std::move(group_menu_button));\n}\n", "target": 1, "flaw_line_index": "13,16,17"}
{"idx": 186769, "func": "void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,\n                                      UpdateFromElementBehavior update_behavior,\n                                      const KURL& url,\n                                      ReferrerPolicy referrer_policy,\n                                      UpdateType update_type) {\n  pending_task_.reset();\n  std::unique_ptr<IncrementLoadEventDelayCount> load_delay_counter;\n  load_delay_counter.swap(delay_until_do_update_from_element_);\n\n  Document& document = element_->GetDocument();\n  if (!document.IsActive())\n    return;\n\n  AtomicString image_source_url = element_->ImageSourceURL();\n  ImageResourceContent* new_image_content = nullptr;\n  if (!url.IsNull() && !url.IsEmpty()) {\n    ResourceLoaderOptions resource_loader_options;\n    resource_loader_options.initiator_info.name = GetElement()->localName();\n    ResourceRequest resource_request(url);\n    if (update_behavior == kUpdateForcedReload) {\n      resource_request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);\n      resource_request.SetPreviewsState(WebURLRequest::kPreviewsNoTransform);\n    }\n\n    if (referrer_policy != kReferrerPolicyDefault) {\n      resource_request.SetHTTPReferrer(SecurityPolicy::GenerateReferrer(\n           referrer_policy, url, document.OutgoingReferrer()));\n     }\n \n     if (IsHTMLPictureElement(GetElement()->parentNode()) ||\n        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull())\n       resource_request.SetRequestContext(\n           WebURLRequest::kRequestContextImageSet);\n \n     bool page_is_being_dismissed =\n         document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;\n    if (page_is_being_dismissed) {\n      resource_request.SetHTTPHeaderField(HTTPNames::Cache_Control,\n                                          \"max-age=0\");\n      resource_request.SetKeepalive(true);\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextPing);\n    }\n\n    FetchParameters params(resource_request, resource_loader_options);\n    ConfigureRequest(params, bypass_behavior, *element_,\n                     document.GetClientHintsPreferences());\n\n    if (update_behavior != kUpdateForcedReload && document.GetFrame())\n      document.GetFrame()->MaybeAllowImagePlaceholder(params);\n\n    new_image_content = ImageResourceContent::Fetch(params, document.Fetcher());\n\n    if (page_is_being_dismissed)\n      new_image_content = nullptr;\n\n    ClearFailedLoadURL();\n  } else {\n    if (!image_source_url.IsNull()) {\n      DispatchErrorEvent();\n    }\n    NoImageResourceToLoad();\n  }\n\n  ImageResourceContent* old_image_content = image_content_.Get();\n  if (old_image_content != new_image_content)\n    RejectPendingDecodes(update_type);\n\n  if (update_behavior == kUpdateSizeChanged && element_->GetLayoutObject() &&\n      element_->GetLayoutObject()->IsImage() &&\n      new_image_content == old_image_content) {\n    ToLayoutImage(element_->GetLayoutObject())->IntrinsicSizeChanged();\n  } else {\n    if (pending_load_event_.IsActive())\n      pending_load_event_.Cancel();\n\n    if (pending_error_event_.IsActive() && new_image_content)\n      pending_error_event_.Cancel();\n\n    UpdateImageState(new_image_content);\n\n    UpdateLayoutObject();\n    if (new_image_content) {\n      new_image_content->AddObserver(this);\n    }\n    if (old_image_content) {\n      old_image_content->RemoveObserver(this);\n    }\n  }\n\n  if (LayoutImageResource* image_resource = GetLayoutImageResource())\n    image_resource->ResetAnimation();\n}\n", "target": 1, "flaw_line_index": "42"}
{"idx": 7471, "func": "static ssize_t flistxattrat_nofollow(int dirfd, const char *filename,\n                                     char *list, size_t size)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = llistxattr(proc_path, list, size);\n    g_free(proc_path);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186335, "func": " void PageRequestSummary::UpdateOrAddToOrigins(\n     const content::mojom::ResourceLoadInfo& resource_load_info) {\n  for (const auto& redirect_info : resource_load_info.redirect_info_chain)\n    UpdateOrAddToOrigins(redirect_info->url, redirect_info->network_info);\n  UpdateOrAddToOrigins(resource_load_info.url, resource_load_info.network_info);\n }\n", "target": 1, "flaw_line_index": "3,4,5"}
{"idx": 7429, "func": "ZEND_API int zend_ts_hash_num_elements(TsHashTable *ht)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_num_elements(TS_HASH(ht));\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186825, "func": " void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  if (!sensor_reader) {\n    callback.Run(nullptr);\n    return;\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n      type, std::move(mapping), this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }\n", "target": 1, "flaw_line_index": "3,13"}
{"idx": 8028, "func": "static void vnc_jobs_bh(void *opaque)\n{\n    VncState *vs = opaque;\n\n    vnc_jobs_consume_buffer(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7490, "func": "generate_from_message (DBusString            *data,\n                       DBusValidity          *expected_validity,\n                       DBusMessage           *message)\n{\n  dbus_message_set_serial (message, 1);\n  dbus_message_lock (message);\n\n  *expected_validity = DBUS_VALID;\n  \n  if (!_dbus_string_move (&message->header.data, 0,\n                          data, 0))\n    _dbus_assert_not_reached (\"oom\");\n\n  if (!_dbus_string_copy (&message->body, 0,\n                          data, _dbus_string_get_length (data)))\n    _dbus_assert_not_reached (\"oom\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8138, "func": "void Gfx::opSetCharSpacing(Object args[], int numArgs) {\n  state->setCharSpace(args[0].getNum());\n  out->updateCharSpace(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7840, "func": "void do_smbios_option(QemuOpts *opts)\n{\n#ifdef TARGET_I386\n    smbios_entry_add(opts);\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187176, "func": "void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(\n    const base::CommandLine& command_line) {\n  bool enableExperimentalWebPlatformFeatures = command_line.HasSwitch(\n      switches::kEnableExperimentalWebPlatformFeatures);\n  if (enableExperimentalWebPlatformFeatures)\n    WebRuntimeFeatures::EnableExperimentalFeatures(true);\n\n  SetRuntimeFeatureDefaultsForPlatform();\n\n\n  WebRuntimeFeatures::EnableOriginTrials(\n      base::FeatureList::IsEnabled(features::kOriginTrials));\n\n  if (!base::FeatureList::IsEnabled(features::kWebUsb))\n    WebRuntimeFeatures::EnableWebUsb(false);\n\n  WebRuntimeFeatures::EnableBlinkHeapIncrementalMarking(\n      base::FeatureList::IsEnabled(features::kBlinkHeapIncrementalMarking));\n\n  WebRuntimeFeatures::EnableBlinkHeapUnifiedGarbageCollection(\n      base::FeatureList::IsEnabled(\n          features::kBlinkHeapUnifiedGarbageCollection));\n\n  if (base::FeatureList::IsEnabled(features::kBloatedRendererDetection))\n    WebRuntimeFeatures::EnableBloatedRendererDetection(true);\n\n  if (command_line.HasSwitch(switches::kDisableDatabases))\n    WebRuntimeFeatures::EnableDatabase(false);\n\n  if (command_line.HasSwitch(switches::kDisableNotifications)) {\n    WebRuntimeFeatures::EnableNotifications(false);\n\n    WebRuntimeFeatures::EnablePushMessaging(false);\n  }\n\n  if (!base::FeatureList::IsEnabled(features::kNotificationContentImage))\n    WebRuntimeFeatures::EnableNotificationContentImage(false);\n\n  WebRuntimeFeatures::EnableSharedArrayBuffer(\n      base::FeatureList::IsEnabled(features::kSharedArrayBuffer) ||\n      base::FeatureList::IsEnabled(features::kWebAssemblyThreads));\n\n  if (command_line.HasSwitch(switches::kDisableSharedWorkers))\n    WebRuntimeFeatures::EnableSharedWorker(false);\n\n  if (command_line.HasSwitch(switches::kDisableSpeechAPI))\n    WebRuntimeFeatures::EnableScriptedSpeech(false);\n\n  if (command_line.HasSwitch(switches::kDisableFileSystem))\n    WebRuntimeFeatures::EnableFileSystem(false);\n\n  if (!command_line.HasSwitch(switches::kDisableAcceleratedJpegDecoding))\n    WebRuntimeFeatures::EnableDecodeToYUV(true);\n\n#if defined(SUPPORT_WEBGL2_COMPUTE_CONTEXT)\n  if (command_line.HasSwitch(switches::kEnableWebGL2ComputeContext)) {\n    WebRuntimeFeatures::EnableWebGL2ComputeContext(true);\n  }\n#endif\n\n  if (command_line.HasSwitch(switches::kEnableWebGLDraftExtensions))\n    WebRuntimeFeatures::EnableWebGLDraftExtensions(true);\n\n  if (command_line.HasSwitch(switches::kEnableAutomation) ||\n      command_line.HasSwitch(switches::kHeadless)) {\n    WebRuntimeFeatures::EnableAutomationControlled(true);\n  }\n\n#if defined(OS_MACOSX)\n  const bool enable_canvas_2d_image_chromium =\n      command_line.HasSwitch(\n          switches::kEnableGpuMemoryBufferCompositorResources) &&\n      !command_line.HasSwitch(switches::kDisable2dCanvasImageChromium) &&\n      !command_line.HasSwitch(switches::kDisableGpu) &&\n      base::FeatureList::IsEnabled(features::kCanvas2DImageChromium);\n#else\n  constexpr bool enable_canvas_2d_image_chromium = false;\n#endif\n  WebRuntimeFeatures::EnableCanvas2dImageChromium(\n      enable_canvas_2d_image_chromium);\n\n#if defined(OS_MACOSX)\n  const bool enable_web_gl_image_chromium =\n      command_line.HasSwitch(\n          switches::kEnableGpuMemoryBufferCompositorResources) &&\n      !command_line.HasSwitch(switches::kDisableWebGLImageChromium) &&\n      !command_line.HasSwitch(switches::kDisableGpu) &&\n      base::FeatureList::IsEnabled(features::kWebGLImageChromium);\n#else\n  const bool enable_web_gl_image_chromium =\n      command_line.HasSwitch(switches::kEnableWebGLImageChromium);\n#endif\n  WebRuntimeFeatures::EnableWebGLImageChromium(enable_web_gl_image_chromium);\n\n  if (command_line.HasSwitch(switches::kForceOverlayFullscreenVideo))\n    WebRuntimeFeatures::ForceOverlayFullscreenVideo(true);\n\n  if (ui::IsOverlayScrollbarEnabled())\n    WebRuntimeFeatures::EnableOverlayScrollbars(true);\n\n  if (command_line.HasSwitch(switches::kEnablePreciseMemoryInfo))\n    WebRuntimeFeatures::EnablePreciseMemoryInfo(true);\n\n  if (command_line.HasSwitch(switches::kEnablePrintBrowser))\n    WebRuntimeFeatures::EnablePrintBrowser(true);\n\n  if (command_line.HasSwitch(switches::kEnableNetworkInformationDownlinkMax) ||\n      enableExperimentalWebPlatformFeatures) {\n    WebRuntimeFeatures::EnableNetInfoDownlinkMax(true);\n  }\n\n  if (command_line.HasSwitch(switches::kReducedReferrerGranularity))\n    WebRuntimeFeatures::EnableReducedReferrerGranularity(true);\n\n  if (command_line.HasSwitch(switches::kDisablePermissionsAPI))\n    WebRuntimeFeatures::EnablePermissionsAPI(false);\n\n  if (command_line.HasSwitch(switches::kDisableV8IdleTasks))\n    WebRuntimeFeatures::EnableV8IdleTasks(false);\n  else\n    WebRuntimeFeatures::EnableV8IdleTasks(true);\n\n  if (command_line.HasSwitch(switches::kEnableUnsafeWebGPU))\n    WebRuntimeFeatures::EnableWebGPU(true);\n\n  if (command_line.HasSwitch(switches::kEnableWebVR))\n    WebRuntimeFeatures::EnableWebVR(true);\n\n  if (base::FeatureList::IsEnabled(features::kWebXr))\n    WebRuntimeFeatures::EnableWebXR(true);\n\n  if (base::FeatureList::IsEnabled(features::kWebXrGamepadSupport))\n    WebRuntimeFeatures::EnableWebXRGamepadSupport(true);\n\n  if (base::FeatureList::IsEnabled(features::kWebXrHitTest))\n    WebRuntimeFeatures::EnableWebXRHitTest(true);\n\n  if (command_line.HasSwitch(switches::kDisablePresentationAPI))\n    WebRuntimeFeatures::EnablePresentationAPI(false);\n\n  if (command_line.HasSwitch(switches::kDisableRemotePlaybackAPI))\n    WebRuntimeFeatures::EnableRemotePlaybackAPI(false);\n\n  WebRuntimeFeatures::EnableSecMetadata(\n      base::FeatureList::IsEnabled(features::kSecMetadata) ||\n      enableExperimentalWebPlatformFeatures);\n\n  WebRuntimeFeatures::EnableUserActivationV2(\n      base::FeatureList::IsEnabled(features::kUserActivationV2));\n\n  if (base::FeatureList::IsEnabled(features::kScrollAnchorSerialization))\n    WebRuntimeFeatures::EnableScrollAnchorSerialization(true);\n\n  if (command_line.HasSwitch(switches::kEnableBlinkGenPropertyTrees))\n    WebRuntimeFeatures::EnableFeatureFromString(\"BlinkGenPropertyTrees\", true);\n\n  if (command_line.HasSwitch(switches::kEnableSlimmingPaintV2))\n    WebRuntimeFeatures::EnableFeatureFromString(\"SlimmingPaintV2\", true);\n\n  WebRuntimeFeatures::EnablePassiveDocumentEventListeners(\n      base::FeatureList::IsEnabled(features::kPassiveDocumentEventListeners));\n\n  WebRuntimeFeatures::EnablePassiveDocumentWheelEventListeners(\n      base::FeatureList::IsEnabled(\n          features::kPassiveDocumentWheelEventListeners));\n\n  WebRuntimeFeatures::EnableFeatureFromString(\n      \"FontCacheScaling\",\n      base::FeatureList::IsEnabled(features::kFontCacheScaling));\n\n  WebRuntimeFeatures::EnableFeatureFromString(\n      \"FontSrcLocalMatching\",\n      base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));\n\n  WebRuntimeFeatures::EnableFeatureFromString(\n      \"FramebustingNeedsSameOriginOrUserGesture\",\n      base::FeatureList::IsEnabled(\n          features::kFramebustingNeedsSameOriginOrUserGesture));\n\n  if (command_line.HasSwitch(switches::kDisableBackgroundTimerThrottling))\n    WebRuntimeFeatures::EnableTimerThrottlingForBackgroundTabs(false);\n\n  WebRuntimeFeatures::EnableExpensiveBackgroundTimerThrottling(\n      base::FeatureList::IsEnabled(\n          features::kExpensiveBackgroundTimerThrottling));\n\n  if (base::FeatureList::IsEnabled(features::kHeapCompaction))\n    WebRuntimeFeatures::EnableHeapCompaction(true);\n\n  WebRuntimeFeatures::EnableRenderingPipelineThrottling(\n      base::FeatureList::IsEnabled(features::kRenderingPipelineThrottling));\n\n  WebRuntimeFeatures::EnableTimerThrottlingForHiddenFrames(\n      base::FeatureList::IsEnabled(features::kTimerThrottlingForHiddenFrames));\n\n  if (base::FeatureList::IsEnabled(\n          features::kSendBeaconThrowForBlobWithNonSimpleType))\n    WebRuntimeFeatures::EnableSendBeaconThrowForBlobWithNonSimpleType(true);\n\n#if defined(OS_ANDROID)\n  if (command_line.HasSwitch(switches::kDisableMediaSessionAPI))\n    WebRuntimeFeatures::EnableMediaSession(false);\n#endif\n\n  WebRuntimeFeatures::EnablePaymentRequest(\n      base::FeatureList::IsEnabled(features::kWebPayments));\n\n  if (base::FeatureList::IsEnabled(features::kServiceWorkerPaymentApps))\n    WebRuntimeFeatures::EnablePaymentApp(true);\n\n  WebRuntimeFeatures::EnableNetworkService(\n      base::FeatureList::IsEnabled(network::features::kNetworkService));\n\n  if (base::FeatureList::IsEnabled(features::kGamepadExtensions))\n    WebRuntimeFeatures::EnableGamepadExtensions(true);\n\n  if (base::FeatureList::IsEnabled(features::kGamepadVibration))\n    WebRuntimeFeatures::EnableGamepadVibration(true);\n\n  if (base::FeatureList::IsEnabled(features::kCompositeOpaqueFixedPosition))\n    WebRuntimeFeatures::EnableFeatureFromString(\"CompositeOpaqueFixedPosition\",\n                                                true);\n\n  if (!base::FeatureList::IsEnabled(features::kCompositeOpaqueScrollers))\n    WebRuntimeFeatures::EnableFeatureFromString(\"CompositeOpaqueScrollers\",\n                                                false);\n  if (base::FeatureList::IsEnabled(features::kCompositorTouchAction))\n    WebRuntimeFeatures::EnableCompositorTouchAction(true);\n\n  if (base::FeatureList::IsEnabled(features::kCSSFragmentIdentifiers))\n    WebRuntimeFeatures::EnableCSSFragmentIdentifiers(true);\n\n  if (!base::FeatureList::IsEnabled(features::kGenericSensor))\n    WebRuntimeFeatures::EnableGenericSensor(false);\n\n  if (base::FeatureList::IsEnabled(features::kGenericSensorExtraClasses))\n    WebRuntimeFeatures::EnableGenericSensorExtraClasses(true);\n\n  if (base::FeatureList::IsEnabled(network::features::kOutOfBlinkCORS))\n    WebRuntimeFeatures::EnableOutOfBlinkCORS(true);\n\n  WebRuntimeFeatures::EnableMediaCastOverlayButton(\n      base::FeatureList::IsEnabled(media::kMediaCastOverlayButton));\n\n  if (!base::FeatureList::IsEnabled(features::kBlockCredentialedSubresources)) {\n    WebRuntimeFeatures::EnableFeatureFromString(\"BlockCredentialedSubresources\",\n                                                false);\n  }\n\n  if (base::FeatureList::IsEnabled(features::kRasterInducingScroll))\n    WebRuntimeFeatures::EnableRasterInducingScroll(true);\n\n  WebRuntimeFeatures::EnableFeatureFromString(\n      \"AllowContentInitiatedDataUrlNavigations\",\n      base::FeatureList::IsEnabled(\n          features::kAllowContentInitiatedDataUrlNavigations));\n\n#if defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebNfc))\n    WebRuntimeFeatures::EnableWebNfc(true);\n#endif\n\n  WebRuntimeFeatures::EnableWebAuth(\n      base::FeatureList::IsEnabled(features::kWebAuth));\n\n  WebRuntimeFeatures::EnableWebAuthGetTransports(\n      base::FeatureList::IsEnabled(features::kWebAuthGetTransports) ||\n      enableExperimentalWebPlatformFeatures);\n\n  WebRuntimeFeatures::EnableClientPlaceholdersForServerLoFi(\n      base::GetFieldTrialParamValue(\"PreviewsClientLoFi\",\n                                    \"replace_server_placeholders\") != \"false\");\n\n  WebRuntimeFeatures::EnableResourceLoadScheduler(\n      base::FeatureList::IsEnabled(features::kResourceLoadScheduler));\n\n  if (base::FeatureList::IsEnabled(features::kLayeredAPI))\n    WebRuntimeFeatures::EnableLayeredAPI(true);\n\n  if (base::FeatureList::IsEnabled(blink::features::kLayoutNG))\n    WebRuntimeFeatures::EnableLayoutNG(true);\n\n  WebRuntimeFeatures::EnableLazyInitializeMediaControls(\n      base::FeatureList::IsEnabled(features::kLazyInitializeMediaControls));\n\n  WebRuntimeFeatures::EnableMediaEngagementBypassAutoplayPolicies(\n      base::FeatureList::IsEnabled(\n          media::kMediaEngagementBypassAutoplayPolicies));\n\n  WebRuntimeFeatures::EnableOverflowIconsForMediaControls(\n      base::FeatureList::IsEnabled(media::kOverflowIconsForMediaControls));\n\n  WebRuntimeFeatures::EnableAllowActivationDelegationAttr(\n      base::FeatureList::IsEnabled(features::kAllowActivationDelegationAttr));\n\n  WebRuntimeFeatures::EnableModernMediaControls(\n      base::FeatureList::IsEnabled(media::kUseModernMediaControls));\n\n  WebRuntimeFeatures::EnableWorkStealingInScriptRunner(\n      base::FeatureList::IsEnabled(features::kWorkStealingInScriptRunner));\n\n  WebRuntimeFeatures::EnableScheduledScriptStreaming(\n      base::FeatureList::IsEnabled(features::kScheduledScriptStreaming));\n\n  WebRuntimeFeatures::EnableMergeBlockingNonBlockingPools(\n      base::FeatureList::IsEnabled(base::kMergeBlockingNonBlockingPools));\n\n  if (base::FeatureList::IsEnabled(features::kLazyFrameLoading))\n    WebRuntimeFeatures::EnableLazyFrameLoading(true);\n  if (base::FeatureList::IsEnabled(features::kLazyFrameVisibleLoadTimeMetrics))\n    WebRuntimeFeatures::EnableLazyFrameVisibleLoadTimeMetrics(true);\n  if (base::FeatureList::IsEnabled(features::kLazyImageLoading))\n    WebRuntimeFeatures::EnableLazyImageLoading(true);\n  if (base::FeatureList::IsEnabled(features::kLazyImageVisibleLoadTimeMetrics))\n    WebRuntimeFeatures::EnableLazyImageVisibleLoadTimeMetrics(true);\n\n   WebRuntimeFeatures::EnableV8ContextSnapshot(\n       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));\n \n  WebRuntimeFeatures::EnableRequireCSSExtensionForFile(\n      base::FeatureList::IsEnabled(features::kRequireCSSExtensionForFile));\n   WebRuntimeFeatures::EnablePictureInPicture(\n       base::FeatureList::IsEnabled(media::kPictureInPicture));\n \n  WebRuntimeFeatures::EnableCacheInlineScriptCode(\n      base::FeatureList::IsEnabled(features::kCacheInlineScriptCode));\n\n  WebRuntimeFeatures::EnableIsolatedCodeCache(\n      base::FeatureList::IsEnabled(net::features::kIsolatedCodeCache));\n\n  if (base::FeatureList::IsEnabled(features::kSignedHTTPExchange)) {\n    WebRuntimeFeatures::EnableSignedHTTPExchange(true);\n    WebRuntimeFeatures::EnablePreloadImageSrcSetEnabled(true);\n  }\n\n  WebRuntimeFeatures::EnableNestedWorkers(\n      base::FeatureList::IsEnabled(blink::features::kNestedWorkers));\n\n  if (base::FeatureList::IsEnabled(\n          features::kExperimentalProductivityFeatures)) {\n    WebRuntimeFeatures::EnableExperimentalProductivityFeatures(true);\n  }\n\n  if (base::FeatureList::IsEnabled(features::kPageLifecycle))\n    WebRuntimeFeatures::EnablePageLifecycle(true);\n\n#if defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kDisplayCutoutAPI) &&\n      base::android::BuildInfo::GetInstance()->sdk_int() >=\n          base::android::SDK_VERSION_P) {\n    WebRuntimeFeatures::EnableDisplayCutoutAPI(true);\n  }\n#endif\n\n  if (command_line.HasSwitch(switches::kEnableAccessibilityObjectModel))\n    WebRuntimeFeatures::EnableAccessibilityObjectModel(true);\n\n  if (base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI))\n    WebRuntimeFeatures::EnableFeatureFromString(\"WritableFiles\", true);\n\n\n  if (command_line.HasSwitch(\n          switches::kDisableOriginTrialControlledBlinkFeatures)) {\n    WebRuntimeFeatures::EnableOriginTrialControlledFeatures(false);\n  }\n\n  WebRuntimeFeatures::EnableAutoplayIgnoresWebAudio(\n      base::FeatureList::IsEnabled(media::kAutoplayIgnoreWebAudio));\n\n#if defined(OS_ANDROID)\n  WebRuntimeFeatures::EnableMediaControlsExpandGesture(\n      base::FeatureList::IsEnabled(media::kMediaControlsExpandGesture));\n#endif\n\n  for (const std::string& feature :\n       FeaturesFromSwitch(command_line, switches::kEnableBlinkFeatures)) {\n    WebRuntimeFeatures::EnableFeatureFromString(feature, true);\n  }\n  for (const std::string& feature :\n       FeaturesFromSwitch(command_line, switches::kDisableBlinkFeatures)) {\n    WebRuntimeFeatures::EnableFeatureFromString(feature, false);\n  }\n\n  WebRuntimeFeatures::EnablePortals(\n      base::FeatureList::IsEnabled(blink::features::kPortals));\n\n  if (!base::FeatureList::IsEnabled(features::kBackgroundFetch))\n    WebRuntimeFeatures::EnableBackgroundFetch(false);\n\n  WebRuntimeFeatures::EnableBackgroundFetchUploads(\n      base::FeatureList::IsEnabled(features::kBackgroundFetchUploads));\n\n  WebRuntimeFeatures::EnableNoHoverAfterLayoutChange(\n      base::FeatureList::IsEnabled(features::kNoHoverAfterLayoutChange));\n\n  WebRuntimeFeatures::EnableJankTracking(\n      base::FeatureList::IsEnabled(blink::features::kJankTracking) ||\n      enableExperimentalWebPlatformFeatures);\n\n  WebRuntimeFeatures::EnableNoHoverDuringScroll(\n      base::FeatureList::IsEnabled(features::kNoHoverDuringScroll));\n}\n", "target": 1, "flaw_line_index": "323,324"}
{"idx": 186349, "func": " PreconnectRequest::PreconnectRequest(\n    const GURL& origin,\n     int num_sockets,\n     const net::NetworkIsolationKey& network_isolation_key)\n     : origin(origin),\n      num_sockets(num_sockets),\n      network_isolation_key(network_isolation_key) {\n  DCHECK_GE(num_sockets, 0);\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186967, "func": "  void StoreExistingGroup() {\n    PushNextTask(\n        base::BindOnce(&AppCacheStorageImplTest::Verify_StoreExistingGroup,\n                       base::Unretained(this)));\n\n     MakeCacheAndGroup(kManifestUrl, 1, 1, true);\n    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);\n \n     cache2_ = new AppCache(storage(), 2);\n    cache2_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::MASTER, 1,\n                                               kDefaultEntrySize + 100));\n \n     storage()->StoreGroupAndNewestCache(group_.get(), cache2_.get(),\n                                        delegate());\n    EXPECT_FALSE(delegate()->stored_group_success_);\n  }\n", "target": 1, "flaw_line_index": "10,14,15"}
{"idx": 187199, "func": "WindowOpenDisposition TestBrowserWindow::GetDispositionForPopupBounds(\n    const gfx::Rect& bounds) {\n  return WindowOpenDisposition::NEW_POPUP;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 8021, "func": "static void vnc_dpy_copy(DisplayChangeListener *dcl,\n                         int src_x, int src_y,\n                         int dst_x, int dst_y, int w, int h)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    uint8_t *src_row;\n    uint8_t *dst_row;\n    int i, x, y, pitch, inc, w_lim, s;\n    int cmp_bytes;\n\n    vnc_refresh_server_surface(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vs->force_update = 1;\n            vnc_update_client(vs, 1, true);\n        }\n    }\n\n    pitch = vnc_server_fb_stride(vd);\n    src_row = vnc_server_fb_ptr(vd, src_x, src_y);\n    dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);\n    y = dst_y;\n    inc = 1;\n    if (dst_y > src_y) {\n        src_row += pitch * (h-1);\n        dst_row += pitch * (h-1);\n        pitch = -pitch;\n        y = dst_y + h - 1;\n        inc = -1;\n    }\n    w_lim = w - (VNC_DIRTY_PIXELS_PER_BIT - (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n    if (w_lim < 0) {\n        w_lim = w;\n    } else {\n        w_lim = w - (w_lim % VNC_DIRTY_PIXELS_PER_BIT);\n    }\n    for (i = 0; i < h; i++) {\n        for (x = 0; x <= w_lim;\n                x += s, src_row += cmp_bytes, dst_row += cmp_bytes) {\n            if (x == w_lim) {\n                if ((s = w - w_lim) == 0)\n                    break;\n            } else if (!x) {\n                s = (VNC_DIRTY_PIXELS_PER_BIT -\n                    (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n                s = MIN(s, w_lim);\n            } else {\n                s = VNC_DIRTY_PIXELS_PER_BIT;\n            }\n            cmp_bytes = s * VNC_SERVER_FB_BYTES;\n            if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n                continue;\n            memmove(dst_row, src_row, cmp_bytes);\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n                    set_bit(((x + dst_x) / VNC_DIRTY_PIXELS_PER_BIT),\n                            vs->dirty[y]);\n                }\n            }\n        }\n        src_row += pitch - w * VNC_SERVER_FB_BYTES;\n        dst_row += pitch - w * VNC_SERVER_FB_BYTES;\n        y += inc;\n    }\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8190, "func": "static void coroutine_fn v9fs_walk(void *opaque)\n{\n    int name_idx;\n    V9fsQID *qids = NULL;\n    int i, err = 0;\n    V9fsPath dpath, path;\n    uint16_t nwnames;\n    struct stat stbuf;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsString *wnames = NULL;\n    V9fsFidState *fidp;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsQID qid;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n    offset += err;\n\n    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);\n\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        wnames = g_malloc0(sizeof(wnames[0]) * nwnames);\n        qids   = g_malloc0(sizeof(qids[0]) * nwnames);\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        goto out;\n    }\n\n    v9fs_path_copy(&dpath, &fidp->path);\n    v9fs_path_copy(&path, &fidp->path);\n    for (name_idx = 0; name_idx < nwnames; name_idx++) {\n        if (not_same_qid(&pdu->s->root_qid, &qid) ||\n            strcmp(\"..\", wnames[name_idx].data)) {\n            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,\n                                       &path);\n            if (err < 0) {\n                goto out;\n            }\n\n            err = v9fs_co_lstat(pdu, &path, &stbuf);\n            if (err < 0) {\n                goto out;\n            }\n            stat_to_qid(&stbuf, &qid);\n            v9fs_path_copy(&dpath, &path);\n        }\n        memcpy(&qids[name_idx], &qid, sizeof(qid));\n    }\n    if (fid == newfid) {\n        BUG_ON(fidp->fid_type != P9_FID_NONE);\n        v9fs_path_copy(&fidp->path, &path);\n    } else {\n        newfidp = alloc_fid(s, newfid);\n        if (newfidp == NULL) {\n            err = -EINVAL;\n            goto out;\n        }\n        newfidp->uid = fidp->uid;\n        v9fs_path_copy(&newfidp->path, &path);\n    }\n    err = v9fs_walk_marshal(pdu, nwnames, qids);\n    trace_v9fs_walk_return(pdu->tag, pdu->id, nwnames, qids);\nout:\n    put_fid(pdu, fidp);\n    if (newfidp) {\n        put_fid(pdu, newfidp);\n    }\n    v9fs_path_free(&dpath);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        for (name_idx = 0; name_idx < nwnames; name_idx++) {\n            v9fs_string_free(&wnames[name_idx]);\n        }\n        g_free(wnames);\n        g_free(qids);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187010, "func": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n \n  operations_.emplace(id, std::move(operation));\n   return id;\n }\n", "target": 1, "flaw_line_index": "5,6,8"}
{"idx": 8264, "func": "XRecordGetContext(Display *dpy, XRecordContext context,\n\t\t  XRecordState **state_return)\n{\n    XExtDisplayInfo \t*info = find_display (dpy);\n    register \t\txRecordGetContextReq   \t*req;\n    xRecordGetContextReply \trep;\n    unsigned int\tcount, i, rn;\n    xRecordRange   \txrange;\n    xRecordClientInfo   xclient_inf;\n    XRecordState\t*ret;\n\n    XRecordCheckExtension (dpy, info, 0);\n    LockDisplay(dpy);\n    GetReq(RecordGetContext, req);\n    req->reqType = info->codes->major_opcode;\n    req->recordReqType = X_RecordGetContext;\n    req->context = context;\n    if (!_XReply(dpy,(xReply *)&rep, 0, False)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn 0;\n    }\n    count = rep.nClients;\n\n    ret = (XRecordState*)Xmalloc(sizeof(XRecordState));\n    if (!ret) {\n\t_XEatDataWords (dpy, rep.length);\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn 0;\n    }\n\n    ret->enabled = rep.enabled;\n    ret->datum_flags = rep.elementHeader;\n    ret->nclients = count;\n\n    if (count)\n    {\n\tXRecordClientInfo\t**client_inf = NULL;\n\tXRecordClientInfo\t*client_inf_str = NULL;\n\n\tif (count < (INT_MAX / sizeof(XRecordClientInfo))) {\n\t    client_inf = Xcalloc(count, sizeof(XRecordClientInfo *));\n\t    if (client_inf != NULL)\n\t\tclient_inf_str = Xmalloc(count * sizeof(XRecordClientInfo));\n\t}\n\tret->client_info = client_inf;\n        if (!client_inf || !client_inf_str)\n        {\n\t   free(client_inf);\n\t   _XEatDataWords (dpy, rep.length);\n\t   UnlockDisplay(dpy);\n\t   XRecordFreeState(ret);\n\t   SyncHandle();\n\t   return 0;\n        }\n        for(i = 0; i < count; i++)\n        {\n\t    client_inf[i] = &(client_inf_str[i]);\n            _XRead(dpy, (char *)&xclient_inf, (long)sizeof(xRecordClientInfo));\n            client_inf_str[i].client = xclient_inf.clientResource;\n            client_inf_str[i].nranges = xclient_inf.nRanges;\n\n\t    if (xclient_inf.nRanges)\n\t    {\n\t\tXRecordRange\t*ranges = NULL;\n\n\t\tif (xclient_inf.nRanges < (INT_MAX / sizeof(XRecordRange))) {\n\t\t    client_inf_str[i].ranges =\n\t\t\tXcalloc(xclient_inf.nRanges, sizeof(XRecordRange *));\n\t\t    if (client_inf_str[i].ranges != NULL)\n\t\t\tranges =\n\t\t\t    Xmalloc(xclient_inf.nRanges * sizeof(XRecordRange));\n\t\t}\n\t\telse\n\t\t    client_inf_str[i].ranges = NULL;\n\n\t\tif (!client_inf_str[i].ranges || !ranges) {\n\t\t    UnlockDisplay(dpy);\n\t\t    XRecordFreeState(ret);\n\t\t    SyncHandle();\n\t\t    return 0;\n\t\t}\n\t\tfor (rn=0; rn<xclient_inf.nRanges; rn++) {\n\t\t    client_inf_str[i].ranges[rn] = &(ranges[rn]);\n\t\t    _XRead(dpy, (char *)&xrange, (long)sizeof(xRecordRange));\n\t\t    WireToLibRange(&xrange, &(ranges[rn]));\n\t\t}\n\t    } else {\n\t\tclient_inf_str[i].ranges = NULL;\n\t    }\n        }\n    } else {\n\tret->client_info = NULL;\n    }\n\n    *state_return = ret;\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7773, "func": "static int h2_rcv_buf(struct conn_stream *cs, struct buffer *buf, int count)\n{\n\tstruct h2s *h2s = cs->ctx;\n\tstruct h2c *h2c = h2s->h2c;\n\tint ret = 0;\n\n\tif (h2c->st0 != H2_CS_FRAME_P)\n\t\treturn 0; \n\n\tif (h2c->dsi != h2s->id)\n\t\treturn 0; \n\n\tif (!h2c->dbuf->size)\n\t\treturn 0; \n\n\tswitch (h2c->dft) {\n\tcase H2_FT_HEADERS:\n\t\tret = h2_frt_decode_headers(h2s, buf, count);\n\t\tbreak;\n\n\tcase H2_FT_DATA:\n\t\tret = h2_frt_transfer_data(h2s, buf, count);\n\t\tbreak;\n\n\tdefault:\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187137, "func": " bool CSSStyleSheet::CanAccessRules() const {\n   if (enable_rule_access_for_inspector_)\n     return true;\n   if (is_inline_stylesheet_)\n     return true;\n   KURL base_url = contents_->BaseURL();\n  if (base_url.IsEmpty())\n    return true;\n  Document* document = OwnerDocument();\n  if (!document)\n    return true;\n  if (document->GetSecurityOrigin()->CanReadContent(base_url))\n    return true;\n  if (allow_rule_access_from_origin_ &&\n      document->GetSecurityOrigin()->CanAccess(\n          allow_rule_access_from_origin_.get())) {\n    return true;\n  }\n  return false;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7615, "func": "static inline void invalidate_cursor1(CirrusVGAState *s)\n{\n    if (s->last_hw_cursor_size) {\n        vga_invalidate_scanlines(&s->vga,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8223, "func": "static void v9fs_mkdir(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    size_t offset = 7;\n    int32_t fid;\n    struct stat stbuf;\n    V9fsQID qid;\n    V9fsString name;\n    V9fsFidState *fidp;\n    gid_t gid;\n    int mode;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdd\", &fid, &name, &mode, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mkdir(pdu->tag, pdu->id, fid, name.data, mode, gid);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mkdir(pdu, fidp, &name, mode, fidp->uid, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mkdir_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7718, "func": "static void v9fs_flush(void *opaque)\n{\n    ssize_t err;\n    int16_t tag;\n    size_t offset = 7;\n    V9fsPDU *cancel_pdu;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"w\", &tag);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    trace_v9fs_flush(pdu->tag, pdu->id, tag);\n\n    QLIST_FOREACH(cancel_pdu, &s->active_list, next) {\n        if (cancel_pdu->tag == tag) {\n            break;\n        }\n    }\n    if (cancel_pdu) {\n        cancel_pdu->cancelled = 1;\n        qemu_co_queue_wait(&cancel_pdu->complete);\n        cancel_pdu->cancelled = 0;\n        pdu_free(cancel_pdu);\n    }\n    pdu_complete(pdu, 7);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7553, "func": "static inline size_t parse_uiv(const unsigned char *p)\n{\n\tunsigned char cursor;\n\tsize_t result = 0;\n\n\tif (*p == '+') {\n\t\tp++;\n\t}\n\t\n\twhile (1) {\n\t\tcursor = *p;\n\t\tif (cursor >= '0' && cursor <= '9') {\n\t\t\tresult = result * 10 + (size_t)(cursor - (unsigned char)'0');\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn result;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186490, "func": "TabStyle::TabColors GM2TabStyle::CalculateColors() const {\n  const ui::ThemeProvider* theme_provider = tab_->GetThemeProvider();\n\n  constexpr float kMinimumActiveContrastRatio = 6.05f;\n  constexpr float kMinimumInactiveContrastRatio = 4.61f;\n  constexpr float kMinimumHoveredContrastRatio = 5.02f;\n  constexpr float kMinimumPressedContrastRatio = 4.41f;\n\n  float expected_opacity = 0.0f;\n  if (tab_->IsActive()) {\n    expected_opacity = 1.0f;\n  } else if (tab_->IsSelected()) {\n    expected_opacity = kSelectedTabOpacity;\n  } else if (tab_->mouse_hovered()) {\n     expected_opacity = GetHoverOpacity();\n   }\n   const SkColor bg_color = color_utils::AlphaBlend(\n      tab_->controller()->GetTabBackgroundColor(TAB_ACTIVE),\n      tab_->controller()->GetTabBackgroundColor(TAB_INACTIVE),\n       expected_opacity);\n \n   SkColor title_color = tab_->controller()->GetTabForegroundColor(\n      expected_opacity > 0.5f ? TAB_ACTIVE : TAB_INACTIVE, bg_color);\n  title_color = color_utils::GetColorWithMinimumContrast(title_color, bg_color);\n\n  const SkColor base_hovered_color = theme_provider->GetColor(\n      ThemeProperties::COLOR_TAB_CLOSE_BUTTON_BACKGROUND_HOVER);\n  const SkColor base_pressed_color = theme_provider->GetColor(\n      ThemeProperties::COLOR_TAB_CLOSE_BUTTON_BACKGROUND_PRESSED);\n\n  const auto get_color_for_contrast_ratio = [](SkColor fg_color,\n                                               SkColor bg_color,\n                                               float contrast_ratio) {\n    const SkAlpha blend_alpha = color_utils::GetBlendValueWithMinimumContrast(\n        bg_color, fg_color, bg_color, contrast_ratio);\n    return color_utils::AlphaBlend(fg_color, bg_color, blend_alpha);\n  };\n\n  const SkColor generated_icon_color = get_color_for_contrast_ratio(\n      title_color, bg_color,\n      tab_->IsActive() ? kMinimumActiveContrastRatio\n                       : kMinimumInactiveContrastRatio);\n  const SkColor generated_hovered_color = get_color_for_contrast_ratio(\n      base_hovered_color, bg_color, kMinimumHoveredContrastRatio);\n  const SkColor generated_pressed_color = get_color_for_contrast_ratio(\n      base_pressed_color, bg_color, kMinimumPressedContrastRatio);\n\n  const SkColor generated_hovered_icon_color =\n      color_utils::GetColorWithMinimumContrast(title_color,\n                                               generated_hovered_color);\n  const SkColor generated_pressed_icon_color =\n      color_utils::GetColorWithMinimumContrast(title_color,\n                                               generated_pressed_color);\n\n  return {bg_color,\n          title_color,\n          generated_icon_color,\n          generated_hovered_icon_color,\n          generated_pressed_icon_color,\n          generated_hovered_color,\n          generated_pressed_color};\n}\n", "target": 1, "flaw_line_index": "27,28"}
{"idx": 7532, "func": "  sfnt_load_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES\n    FT_Error      psnames_error;\n#endif\n    FT_Bool       has_outline;\n    FT_Bool       is_apple_sbit;\n    FT_Bool       is_apple_sbix;\n    FT_Bool       ignore_typographic_family    = FALSE;\n    FT_Bool       ignore_typographic_subfamily = FALSE;\n\n    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n\n    FT_UNUSED( face_instance_index );\n\n\n\n    {\n      FT_Int  i;\n\n\n      for ( i = 0; i < num_params; i++ )\n      {\n        if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_FAMILY )\n          ignore_typographic_family = TRUE;\n        else if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_SUBFAMILY )\n          ignore_typographic_subfamily = TRUE;\n      }\n    }\n\n\n\n    FT_TRACE2(( \"sfnt_load_face: %08p\\n\\n\", face ));\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n    has_outline = FT_BOOL( face->root.internal->incremental_interface ||\n                           tt_face_lookup_table( face, TTAG_glyf )    ||\n                           tt_face_lookup_table( face, TTAG_CFF )     ||\n                           tt_face_lookup_table( face, TTAG_CFF2 )    );\n#else\n    has_outline = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) ||\n                           tt_face_lookup_table( face, TTAG_CFF )  ||\n                           tt_face_lookup_table( face, TTAG_CFF2 ) );\n#endif\n\n    is_apple_sbit = 0;\n    is_apple_sbix = !face->goto_table( face, TTAG_sbix, stream, 0 );\n\n    if ( is_apple_sbix )\n      has_outline = FALSE;\n\n    if ( !has_outline && sfnt->load_bhed )\n    {\n      LOAD_( bhed );\n      is_apple_sbit = FT_BOOL( !error );\n    }\n\n    if ( !is_apple_sbit || is_apple_sbix )\n    {\n      LOAD_( head );\n      if ( error )\n        goto Exit;\n    }\n\n    if ( face->header.Units_Per_EM == 0 )\n    {\n      error = FT_THROW( Invalid_Table );\n\n      goto Exit;\n    }\n\n    LOAD_( maxp );\n    LOAD_( cmap );\n\n    LOAD_( name );\n    LOAD_( post );\n\n#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES\n    psnames_error = error;\n#endif\n\n    if ( !is_apple_sbit )\n    {\n      LOADM_( hhea, 0 );\n      if ( !error )\n      {\n        LOADM_( hmtx, 0 );\n        if ( FT_ERR_EQ( error, Table_Missing ) )\n        {\n          error = FT_THROW( Hmtx_Table_Missing );\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n          if ( face->root.internal->incremental_interface          &&\n               face->root.internal->incremental_interface->funcs->\n                 get_glyph_metrics                                 )\n          {\n            face->horizontal.number_Of_HMetrics = 0;\n            error                               = FT_Err_Ok;\n          }\n#endif\n        }\n      }\n      else if ( FT_ERR_EQ( error, Table_Missing ) )\n      {\n        if ( face->format_tag == TTAG_true )\n        {\n          FT_TRACE2(( \"This is an SFNT Mac font.\\n\" ));\n\n          has_outline = 0;\n          error       = FT_Err_Ok;\n        }\n        else\n        {\n          error = FT_THROW( Horiz_Header_Missing );\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n          if ( face->root.internal->incremental_interface          &&\n               face->root.internal->incremental_interface->funcs->\n                 get_glyph_metrics                                 )\n          {\n            face->horizontal.number_Of_HMetrics = 0;\n            error                               = FT_Err_Ok;\n          }\n#endif\n\n        }\n      }\n\n      if ( error )\n        goto Exit;\n\n      LOADM_( hhea, 1 );\n      if ( !error )\n      {\n        LOADM_( hmtx, 1 );\n        if ( !error )\n          face->vertical_info = 1;\n      }\n\n      if ( error && FT_ERR_NEQ( error, Table_Missing ) )\n        goto Exit;\n\n      LOAD_( os2 );\n      if ( error )\n      {\n        face->os2.version = 0xFFFFU;\n      }\n    }\n\n\n    if ( sfnt->load_eblc )\n      LOAD_( eblc );\n\n    LOAD_( pclt );\n    LOAD_( gasp );\n    LOAD_( kern );\n\n    face->root.num_glyphs = face->max_profile.numGlyphs;\n\n\n    face->root.family_name = NULL;\n    face->root.style_name  = NULL;\n    if ( face->os2.version != 0xFFFFU && face->os2.fsSelection & 256 )\n    {\n      if ( !ignore_typographic_family )\n        GET_NAME( TYPOGRAPHIC_FAMILY, &face->root.family_name );\n      if ( !face->root.family_name )\n        GET_NAME( FONT_FAMILY, &face->root.family_name );\n\n      if ( !ignore_typographic_subfamily )\n        GET_NAME( TYPOGRAPHIC_SUBFAMILY, &face->root.style_name );\n      if ( !face->root.style_name )\n        GET_NAME( FONT_SUBFAMILY, &face->root.style_name );\n    }\n    else\n    {\n      GET_NAME( WWS_FAMILY, &face->root.family_name );\n      if ( !face->root.family_name && !ignore_typographic_family )\n        GET_NAME( TYPOGRAPHIC_FAMILY, &face->root.family_name );\n      if ( !face->root.family_name )\n        GET_NAME( FONT_FAMILY, &face->root.family_name );\n\n      GET_NAME( WWS_SUBFAMILY, &face->root.style_name );\n      if ( !face->root.style_name && !ignore_typographic_subfamily )\n        GET_NAME( TYPOGRAPHIC_SUBFAMILY, &face->root.style_name );\n      if ( !face->root.style_name )\n        GET_NAME( FONT_SUBFAMILY, &face->root.style_name );\n    }\n\n    {\n      FT_Face  root  = &face->root;\n      FT_Long  flags = root->face_flags;\n\n\n      if ( face->sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||\n           face->sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX )\n        flags |= FT_FACE_FLAG_COLOR;      \n\n      if ( has_outline == TRUE )\n        flags |= FT_FACE_FLAG_SCALABLE;   \n\n      flags |= FT_FACE_FLAG_SFNT       |  \n               FT_FACE_FLAG_HORIZONTAL;   \n\n#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES\n      if ( !psnames_error                             &&\n           face->postscript.FormatType != 0x00030000L )\n        flags |= FT_FACE_FLAG_GLYPH_NAMES;\n#endif\n\n      if ( face->postscript.isFixedPitch )\n        flags |= FT_FACE_FLAG_FIXED_WIDTH;\n\n      if ( face->vertical_info )\n        flags |= FT_FACE_FLAG_VERTICAL;\n\n      if ( TT_FACE_HAS_KERNING( face ) )\n        flags |= FT_FACE_FLAG_KERNING;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n      if ( face->variation_support & TT_FACE_FLAG_VAR_FVAR )\n      {\n        if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &&\n             tt_face_lookup_table( face, TTAG_gvar ) != 0 )\n          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n        if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )\n          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n      }\n#endif\n\n      root->face_flags = flags;\n\n\n      flags = 0;\n      if ( has_outline == TRUE && face->os2.version != 0xFFFFU )\n      {\n\n        if ( face->os2.fsSelection & 512 )       \n          flags |= FT_STYLE_FLAG_ITALIC;\n        else if ( face->os2.fsSelection & 1 )    \n          flags |= FT_STYLE_FLAG_ITALIC;\n\n        if ( face->os2.fsSelection & 32 )        \n          flags |= FT_STYLE_FLAG_BOLD;\n      }\n      else\n      {\n\n        if ( face->header.Mac_Style & 1 )\n          flags |= FT_STYLE_FLAG_BOLD;\n\n        if ( face->header.Mac_Style & 2 )\n          flags |= FT_STYLE_FLAG_ITALIC;\n      }\n\n      root->style_flags |= flags;\n\n\n      tt_face_build_cmaps( face );  \n\n\n      {\n        FT_Int  m;\n\n\n        for ( m = 0; m < root->num_charmaps; m++ )\n        {\n          FT_CharMap  charmap = root->charmaps[m];\n\n\n          charmap->encoding = sfnt_find_encoding( charmap->platform_id,\n                                                  charmap->encoding_id );\n\n#if 0\n          if ( !root->charmap                           &&\n               charmap->encoding == FT_ENCODING_UNICODE )\n          {\n            root->charmap = charmap;\n          }\n#endif\n        }\n      }\n\n#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS\n\n      {\n        FT_UInt  count;\n\n\n        count = face->sbit_num_strikes;\n\n        if ( count > 0 )\n        {\n          FT_Memory        memory   = face->root.stream->memory;\n          FT_UShort        em_size  = face->header.Units_Per_EM;\n          FT_Short         avgwidth = face->os2.xAvgCharWidth;\n          FT_Size_Metrics  metrics;\n\n          FT_UInt*  sbit_strike_map = NULL;\n          FT_UInt   strike_idx, bsize_idx;\n\n\n          if ( em_size == 0 || face->os2.version == 0xFFFFU )\n          {\n            avgwidth = 1;\n            em_size = 1;\n          }\n\n          if ( FT_NEW_ARRAY( root->available_sizes, count ) ||\n               FT_NEW_ARRAY( sbit_strike_map, count ) )\n            goto Exit;\n\n          bsize_idx = 0;\n          for ( strike_idx = 0; strike_idx < count; strike_idx++ )\n          {\n            FT_Bitmap_Size*  bsize = root->available_sizes + bsize_idx;\n\n\n            error = sfnt->load_strike_metrics( face, strike_idx, &metrics );\n            if ( error )\n              continue;\n\n            bsize->height = (FT_Short)( metrics.height >> 6 );\n            bsize->width  = (FT_Short)(\n              ( avgwidth * metrics.x_ppem + em_size / 2 ) / em_size );\n\n            bsize->x_ppem = metrics.x_ppem << 6;\n            bsize->y_ppem = metrics.y_ppem << 6;\n\n            bsize->size   = metrics.y_ppem << 6;\n\n            if ( bsize->x_ppem && bsize->y_ppem )\n              sbit_strike_map[bsize_idx++] = strike_idx;\n          }\n\n          (void)FT_RENEW_ARRAY( sbit_strike_map, count, bsize_idx );\n\n          if ( bsize_idx )\n          {\n            face->sbit_strike_map = sbit_strike_map;\n\n            root->face_flags     |= FT_FACE_FLAG_FIXED_SIZES;\n            root->num_fixed_sizes = (FT_Int)bsize_idx;\n          }\n        }\n      }\n\n#endif \n\n      if ( !FT_HAS_FIXED_SIZES( root ) && !FT_IS_SCALABLE( root ) )\n        root->face_flags |= FT_FACE_FLAG_SCALABLE;\n\n\n      if ( FT_IS_SCALABLE( root ) )\n      {\n        root->bbox.xMin    = face->header.xMin;\n        root->bbox.yMin    = face->header.yMin;\n        root->bbox.xMax    = face->header.xMax;\n        root->bbox.yMax    = face->header.yMax;\n        root->units_per_EM = face->header.Units_Per_EM;\n\n\n\n\n        root->ascender  = face->horizontal.Ascender;\n        root->descender = face->horizontal.Descender;\n\n        root->height = root->ascender - root->descender +\n                       face->horizontal.Line_Gap;\n\n        if ( !( root->ascender || root->descender ) )\n        {\n          if ( face->os2.version != 0xFFFFU )\n          {\n            if ( face->os2.sTypoAscender || face->os2.sTypoDescender )\n            {\n              root->ascender  = face->os2.sTypoAscender;\n              root->descender = face->os2.sTypoDescender;\n\n              root->height = root->ascender - root->descender +\n                             face->os2.sTypoLineGap;\n            }\n            else\n            {\n              root->ascender  =  (FT_Short)face->os2.usWinAscent;\n              root->descender = -(FT_Short)face->os2.usWinDescent;\n\n              root->height = root->ascender - root->descender;\n            }\n          }\n        }\n\n        root->max_advance_width  =\n          (FT_Short)face->horizontal.advance_Width_Max;\n        root->max_advance_height =\n          (FT_Short)( face->vertical_info ? face->vertical.advance_Height_Max\n                                          : root->height );\n\n        /* See http:\n        root->underline_position  = face->postscript.underlinePosition -\n                                    face->postscript.underlineThickness / 2;\n        root->underline_thickness = face->postscript.underlineThickness;\n      }\n\n    }\n\n  Exit:\n    FT_TRACE2(( \"sfnt_load_face: done\\n\" ));\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186915, "func": "void CompileFromResponseCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  ExceptionState exception_state(args.GetIsolate(),\n                                 ExceptionState::kExecutionContext,\n                                  \"WebAssembly\", \"compile\");\n   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);\n \n  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n   if (!ExecutionContext::From(script_state)) {\n     V8SetReturnValue(args, ScriptPromise().V8Value());\n     return;\n  }\n\n  if (args.Length() < 1 || !args[0]->IsObject() ||\n      !V8Response::hasInstance(args[0], args.GetIsolate())) {\n    V8SetReturnValue(\n        args,\n         ScriptPromise::Reject(\n             script_state, V8ThrowException::CreateTypeError(\n                               script_state->GetIsolate(),\n                              \"An argument must be provided, which must be a\"\n                               \"Response or Promise<Response> object\"))\n             .V8Value());\n     return;\n  }\n\n  Response* response = V8Response::ToImpl(v8::Local<v8::Object>::Cast(args[0]));\n  if (response->MimeType() != \"application/wasm\") {\n    V8SetReturnValue(\n        args,\n        ScriptPromise::Reject(\n            script_state,\n            V8ThrowException::CreateTypeError(\n                script_state->GetIsolate(),\n                \"Incorrect response MIME type. Expected 'application/wasm'.\"))\n            .V8Value());\n    return;\n  }\n  v8::Local<v8::Value> promise;\n  if (response->IsBodyLocked() || response->bodyUsed()) {\n    promise = ScriptPromise::Reject(script_state,\n                                    V8ThrowException::CreateTypeError(\n                                        script_state->GetIsolate(),\n                                        \"Cannot compile WebAssembly.Module \"\n                                        \"from an already read Response\"))\n                  .V8Value();\n  } else {\n    if (response->BodyBuffer()) {\n      FetchDataLoaderAsWasmModule* loader =\n          new FetchDataLoaderAsWasmModule(script_state);\n\n      promise = loader->GetPromise();\n      response->BodyBuffer()->StartLoading(loader, new WasmDataLoaderClient());\n    } else {\n      promise = ScriptPromise::Reject(script_state,\n                                      V8ThrowException::CreateTypeError(\n                                          script_state->GetIsolate(),\n                                          \"Response object has a null body.\"))\n                    .V8Value();\n    }\n  }\n  V8SetReturnValue(args, promise);\n}\n", "target": 1, "flaw_line_index": "8,21"}
{"idx": 7489, "func": "_dbus_validate_signature_with_reason (const DBusString *type_str,\n                                      int               type_pos,\n                                      int               len)\n{\n  const unsigned char *p;\n  const unsigned char *end;\n  int last;\n  int struct_depth;\n  int array_depth;\n  int dict_entry_depth;\n  DBusValidity result;\n\n  int element_count;\n  DBusList *element_count_stack;\n\n  result = DBUS_VALID;\n  element_count_stack = NULL;\n\n  if (!_dbus_list_append (&element_count_stack, _DBUS_INT_TO_POINTER (0)))\n    {\n      result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n      goto out;\n    }\n\n  _dbus_assert (type_str != NULL);\n  _dbus_assert (type_pos < _DBUS_INT32_MAX - len);\n  _dbus_assert (len >= 0);\n  _dbus_assert (type_pos >= 0);\n\n  if (len > DBUS_MAXIMUM_SIGNATURE_LENGTH)\n    {\n      result = DBUS_INVALID_SIGNATURE_TOO_LONG;\n      goto out;\n    }\n\n  p = _dbus_string_get_const_data_len (type_str, type_pos, 0);\n\n  end = _dbus_string_get_const_data_len (type_str, type_pos + len, 0);\n  struct_depth = 0;\n  array_depth = 0;\n  dict_entry_depth = 0;\n  last = DBUS_TYPE_INVALID;\n\n  while (p != end)\n    {\n      switch (*p)\n        {\n        case DBUS_TYPE_BYTE:\n        case DBUS_TYPE_BOOLEAN:\n        case DBUS_TYPE_INT16:\n        case DBUS_TYPE_UINT16:\n        case DBUS_TYPE_INT32:\n        case DBUS_TYPE_UINT32:\n        case DBUS_TYPE_UNIX_FD:\n        case DBUS_TYPE_INT64:\n        case DBUS_TYPE_UINT64:\n        case DBUS_TYPE_DOUBLE:\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n        case DBUS_TYPE_VARIANT:\n          break;\n\n        case DBUS_TYPE_ARRAY:\n          array_depth += 1;\n          if (array_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_ARRAY_RECURSION;\n              goto out;\n            }\n          break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n          struct_depth += 1;\n\n          if (struct_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_STRUCT_RECURSION;\n              goto out;\n            }\n          \n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_STRUCT_END_CHAR:\n          if (struct_depth == 0)\n            {\n              result = DBUS_INVALID_STRUCT_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n\n          if (last == DBUS_STRUCT_BEGIN_CHAR)\n            {\n              result = DBUS_INVALID_STRUCT_HAS_NO_FIELDS;\n              goto out;\n            }\n\n          _dbus_list_pop_last (&element_count_stack);\n\n          struct_depth -= 1;\n          break;\n\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n          if (last != DBUS_TYPE_ARRAY)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY;\n              goto out;\n            }\n            \n          dict_entry_depth += 1;\n\n          if (dict_entry_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_DICT_ENTRY_RECURSION;\n              goto out;\n            }\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_DICT_ENTRY_END_CHAR:\n          if (dict_entry_depth == 0)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n            \n          dict_entry_depth -= 1;\n\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          if (element_count != 2)\n            {\n              if (element_count == 0)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_NO_FIELDS;\n              else if (element_count == 1)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_ONLY_ONE_FIELD;\n              else\n                result = DBUS_INVALID_DICT_ENTRY_HAS_TOO_MANY_FIELDS;\n              \n              goto out;\n            }\n          break;\n          \n        case DBUS_TYPE_STRUCT:     \n        case DBUS_TYPE_DICT_ENTRY: \n        default:\n          result = DBUS_INVALID_UNKNOWN_TYPECODE;\n\t  goto out;\n        }\n\n      if (*p != DBUS_TYPE_ARRAY && \n          *p != DBUS_DICT_ENTRY_BEGIN_CHAR && \n\t  *p != DBUS_STRUCT_BEGIN_CHAR) \n        {\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          ++element_count;\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (element_count)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n        }\n      \n      if (array_depth > 0)\n        {\n          if (*p == DBUS_TYPE_ARRAY && p != end)\n            {\n\t       const char *p1;\n\t       p1 = p + 1;\n               if (*p1 == DBUS_STRUCT_END_CHAR ||\n                   *p1 == DBUS_DICT_ENTRY_END_CHAR)\n                 {\n                   result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n                   goto out;\n                 }\n            }\n          else\n\t    {\n              array_depth = 0;\n\t    }\n        }\n\n      if (last == DBUS_DICT_ENTRY_BEGIN_CHAR)\n        {\n          if (!(_dbus_type_is_valid (*p) && dbus_type_is_basic (*p)))\n            {\n              result = DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE;\n              goto out;\n            }\n        }\n\n      last = *p;\n      ++p;\n    }\n\n\n  if (array_depth > 0)\n    {\n      result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n      goto out;\n    }\n    \n  if (struct_depth > 0)\n    {\n       result = DBUS_INVALID_STRUCT_STARTED_BUT_NOT_ENDED;\n       goto out;\n    }\n    \n  if (dict_entry_depth > 0)\n    {\n      result =  DBUS_INVALID_DICT_ENTRY_STARTED_BUT_NOT_ENDED;\n      goto out;\n    }\n    \n  _dbus_assert (last != DBUS_TYPE_ARRAY);\n  _dbus_assert (last != DBUS_STRUCT_BEGIN_CHAR);\n  _dbus_assert (last != DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n  result = DBUS_VALID;\n\nout:\n  _dbus_list_clear (&element_count_stack);\n   return result;\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186596, "func": "void NavigationRequest::OnStartChecksComplete(\n    NavigationThrottle::ThrottleCheckResult result) {\n  DCHECK(result.action() != NavigationThrottle::DEFER);\n  DCHECK(result.action() != NavigationThrottle::BLOCK_RESPONSE);\n\n  if (on_start_checks_complete_closure_)\n    on_start_checks_complete_closure_.Run();\n  if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE ||\n      result.action() == NavigationThrottle::CANCEL ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE) {\n#if DCHECK_IS_ON()\n    if (result.action() == NavigationThrottle::BLOCK_REQUEST) {\n      DCHECK(result.net_error_code() == net::ERR_BLOCKED_BY_CLIENT ||\n             result.net_error_code() == net::ERR_BLOCKED_BY_ADMINISTRATOR);\n    }\n    else if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE) {\n      DCHECK_EQ(result.net_error_code(), net::ERR_ABORTED);\n    }\n#endif\n\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&NavigationRequest::OnRequestFailedInternal,\n                       weak_factory_.GetWeakPtr(), false,\n                       result.net_error_code(), base::nullopt, true,\n                       result.error_page_content()));\n\n    return;\n  }\n\n  DCHECK_NE(AssociatedSiteInstanceType::NONE, associated_site_instance_type_);\n  RenderFrameHostImpl* navigating_frame_host =\n      associated_site_instance_type_ == AssociatedSiteInstanceType::SPECULATIVE\n          ? frame_tree_node_->render_manager()->speculative_frame_host()\n          : frame_tree_node_->current_frame_host();\n  DCHECK(navigating_frame_host);\n\n  navigation_handle_->SetExpectedProcess(navigating_frame_host->GetProcess());\n\n  BrowserContext* browser_context =\n      frame_tree_node_->navigator()->GetController()->GetBrowserContext();\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      browser_context, navigating_frame_host->GetSiteInstance());\n  DCHECK(partition);\n\n  bool can_create_service_worker =\n      (frame_tree_node_->pending_frame_policy().sandbox_flags &\n       blink::WebSandboxFlags::kOrigin) != blink::WebSandboxFlags::kOrigin;\n  request_params_.should_create_service_worker = can_create_service_worker;\n  if (can_create_service_worker) {\n    ServiceWorkerContextWrapper* service_worker_context =\n        static_cast<ServiceWorkerContextWrapper*>(\n            partition->GetServiceWorkerContext());\n    navigation_handle_->InitServiceWorkerHandle(service_worker_context);\n  }\n\n  if (IsSchemeSupportedForAppCache(common_params_.url)) {\n    if (navigating_frame_host->GetRenderViewHost()\n            ->GetWebkitPreferences()\n            .application_cache_enabled) {\n      navigation_handle_->InitAppCacheHandle(\n          static_cast<ChromeAppCacheService*>(partition->GetAppCacheService()));\n    }\n  }\n\n  request_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  GURL base_url;\n#if defined(OS_ANDROID)\n  NavigationEntry* last_committed_entry =\n      frame_tree_node_->navigator()->GetController()->GetLastCommittedEntry();\n  if (last_committed_entry)\n    base_url = last_committed_entry->GetBaseURLForDataURL();\n#endif\n  const GURL& top_document_url =\n       !base_url.is_empty()\n           ? base_url\n           : frame_tree_node_->frame_tree()->root()->current_url();\n   const GURL& site_for_cookies =\n      frame_tree_node_->IsMainFrame() ? common_params_.url : top_document_url;\n   bool parent_is_main_frame = !frame_tree_node_->parent()\n                                   ? false\n                                   : frame_tree_node_->parent()->IsMainFrame();\n\n  std::unique_ptr<NavigationUIData> navigation_ui_data;\n  if (navigation_handle_->GetNavigationUIData())\n    navigation_ui_data = navigation_handle_->GetNavigationUIData()->Clone();\n\n  bool is_for_guests_only =\n      navigation_handle_->GetStartingSiteInstance()->GetSiteURL().\n          SchemeIs(kGuestScheme);\n\n  bool report_raw_headers = false;\n  RenderFrameDevToolsAgentHost::ApplyOverrides(\n      frame_tree_node_, begin_params_.get(), &report_raw_headers);\n  RenderFrameDevToolsAgentHost::OnNavigationRequestWillBeSent(*this);\n\n  loader_ = NavigationURLLoader::Create(\n      browser_context->GetResourceContext(), partition,\n      std::make_unique<NavigationRequestInfo>(\n          common_params_, begin_params_.Clone(), site_for_cookies,\n          frame_tree_node_->IsMainFrame(), parent_is_main_frame,\n          IsSecureFrame(frame_tree_node_->parent()),\n          frame_tree_node_->frame_tree_node_id(), is_for_guests_only,\n          report_raw_headers,\n          navigating_frame_host->GetVisibilityState() ==\n              blink::mojom::PageVisibilityState::kPrerender,\n          blob_url_loader_factory_ ? blob_url_loader_factory_->Clone()\n                                   : nullptr),\n      std::move(navigation_ui_data),\n      navigation_handle_->service_worker_handle(),\n      navigation_handle_->appcache_handle(), this);\n}\n", "target": 1, "flaw_line_index": "97,98,99,101"}
{"idx": 7531, "func": "  sfnt_done_face( TT_Face  face )\n  {\n    FT_Memory     memory;\n    SFNT_Service  sfnt;\n\n\n    if ( !face )\n      return;\n\n    memory = face->root.memory;\n    sfnt   = (SFNT_Service)face->sfnt;\n\n    if ( sfnt )\n    {\n      if ( sfnt->free_psnames )\n        sfnt->free_psnames( face );\n\n      if ( sfnt->free_eblc )\n        sfnt->free_eblc( face );\n    }\n\n#ifdef TT_CONFIG_OPTION_BDF\n    tt_face_free_bdf_props( face );\n#endif\n\n    tt_face_done_kern( face );\n\n    FT_FREE( face->ttc_header.offsets );\n    face->ttc_header.count = 0;\n\n    FT_FREE( face->dir_tables );\n    face->num_tables = 0;\n\n    {\n      FT_Stream  stream = FT_FACE_STREAM( face );\n\n\n      FT_FRAME_RELEASE( face->cmap_table );\n      face->cmap_size = 0;\n    }\n\n    face->horz_metrics_size = 0;\n    face->vert_metrics_size = 0;\n\n    if ( face->vertical_info )\n    {\n      FT_FREE( face->vertical.long_metrics  );\n      FT_FREE( face->vertical.short_metrics );\n      face->vertical_info = 0;\n    }\n\n    FT_FREE( face->gasp.gaspRanges );\n    face->gasp.numRanges = 0;\n\n    if ( sfnt )\n      sfnt->free_name( face );\n\n    FT_FREE( face->root.family_name );\n    FT_FREE( face->root.style_name );\n\n    FT_FREE( face->root.available_sizes );\n    FT_FREE( face->sbit_strike_map );\n    face->root.num_fixed_sizes = 0;\n\n    FT_FREE( face->postscript_name );\n\n    face->sfnt = NULL;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8292, "func": "XRRFreeMonitors(XRRMonitorInfo *monitors)\n{\n    Xfree(monitors);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187035, "func": "std::unique_ptr<StoragePartitionImpl> StoragePartitionImpl::Create(\n    BrowserContext* context,\n    bool in_memory,\n    const base::FilePath& relative_partition_path,\n    const std::string& partition_domain) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||\n         !BrowserThread::IsThreadInitialized(BrowserThread::UI));\n\n  base::FilePath partition_path =\n      context->GetPath().Append(relative_partition_path);\n\n  std::unique_ptr<StoragePartitionImpl> partition =\n      base::WrapUnique(new StoragePartitionImpl(\n          context, partition_path, context->GetSpecialStoragePolicy()));\n\n  partition->is_in_memory_ = in_memory;\n  partition->relative_partition_path_ = relative_partition_path;\n\n  partition->quota_manager_ = new storage::QuotaManager(\n      in_memory, partition_path,\n      base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}).get(),\n      context->GetSpecialStoragePolicy(),\n      base::BindRepeating(&StoragePartitionImpl::GetQuotaSettings,\n                          partition->weak_factory_.GetWeakPtr()));\n  scoped_refptr<storage::QuotaManagerProxy> quota_manager_proxy =\n      partition->quota_manager_->proxy();\n\n  partition->filesystem_context_ = CreateFileSystemContext(\n      context, partition_path, in_memory, quota_manager_proxy.get());\n\n  partition->database_tracker_ = base::MakeRefCounted<storage::DatabaseTracker>(\n       partition_path, in_memory, context->GetSpecialStoragePolicy(),\n       quota_manager_proxy.get());\n \n  partition->dom_storage_context_ = new DOMStorageContextWrapper(\n       BrowserContext::GetConnectorFor(context),\n       in_memory ? base::FilePath() : context->GetPath(),\n       relative_partition_path, context->GetSpecialStoragePolicy());\n\n  partition->lock_manager_ = new LockManager();\n\n  base::FilePath path = in_memory ? base::FilePath() : partition_path;\n  partition->indexed_db_context_ = new IndexedDBContextImpl(\n      path, context->GetSpecialStoragePolicy(), quota_manager_proxy,\n      indexed_db::GetDefaultLevelDBFactory());\n\n  partition->cache_storage_context_ = new CacheStorageContextImpl(context);\n  partition->cache_storage_context_->Init(path, quota_manager_proxy);\n\n  partition->service_worker_context_ = new ServiceWorkerContextWrapper(context);\n  partition->service_worker_context_->set_storage_partition(partition.get());\n\n  partition->appcache_service_ =\n      base::MakeRefCounted<ChromeAppCacheService>(quota_manager_proxy.get());\n\n  partition->shared_worker_service_ = std::make_unique<SharedWorkerServiceImpl>(\n      partition.get(), partition->service_worker_context_,\n      partition->appcache_service_);\n\n  partition->push_messaging_context_ =\n      new PushMessagingContext(context, partition->service_worker_context_);\n\n#if !defined(OS_ANDROID)\n  partition->host_zoom_level_context_ = new HostZoomLevelContext(\n      context->CreateZoomLevelDelegate(partition_path));\n#endif  \n\n  partition->platform_notification_context_ =\n      new PlatformNotificationContextImpl(path, context,\n                                          partition->service_worker_context_);\n  partition->platform_notification_context_->Initialize();\n\n  partition->background_fetch_context_ =\n      base::MakeRefCounted<BackgroundFetchContext>(\n          context, partition->service_worker_context_,\n          partition->cache_storage_context_, quota_manager_proxy);\n\n  partition->background_sync_context_ =\n      base::MakeRefCounted<BackgroundSyncContext>();\n  partition->background_sync_context_->Init(partition->service_worker_context_);\n\n  partition->payment_app_context_ = new PaymentAppContextImpl();\n  partition->payment_app_context_->Init(partition->service_worker_context_);\n\n  partition->broadcast_channel_provider_ = new BroadcastChannelProvider();\n\n  partition->bluetooth_allowed_devices_map_ = new BluetoothAllowedDevicesMap();\n\n  scoped_refptr<ChromeBlobStorageContext> blob_context =\n      ChromeBlobStorageContext::GetFor(context);\n\n  partition->url_loader_factory_getter_ = new URLLoaderFactoryGetter();\n  partition->url_loader_factory_getter_->Initialize(partition.get());\n\n  partition->service_worker_context_->Init(\n      path, quota_manager_proxy.get(), context->GetSpecialStoragePolicy(),\n      blob_context.get(), partition->url_loader_factory_getter_.get());\n\n  partition->blob_registry_ =\n      BlobRegistryWrapper::Create(blob_context, partition->filesystem_context_);\n\n  partition->appcache_service_->set_url_loader_factory_getter(\n      partition->url_loader_factory_getter_.get());\n\n  partition->prefetch_url_loader_service_ =\n      base::MakeRefCounted<PrefetchURLLoaderService>();\n\n  partition->cookie_store_context_ = base::MakeRefCounted<CookieStoreContext>();\n  partition->cookie_store_context_->Initialize(\n      partition->service_worker_context_, base::DoNothing());\n\n  if (base::FeatureList::IsEnabled(net::features::kIsolatedCodeCache)) {\n    GeneratedCodeCacheSettings settings =\n        GetContentClient()->browser()->GetGeneratedCodeCacheSettings(context);\n\n    if (!in_memory && settings.enabled()) {\n      partition->generated_code_cache_context_ =\n          base::MakeRefCounted<GeneratedCodeCacheContext>();\n\n      base::FilePath code_cache_path;\n      if (partition_domain.empty()) {\n        code_cache_path = settings.path().AppendASCII(\"Code Cache\");\n      } else {\n        code_cache_path = settings.path()\n                              .Append(relative_partition_path)\n                              .AppendASCII(\"Code Cache\");\n      }\n      DCHECK_GE(settings.size_in_bytes(), 0);\n      partition->GetGeneratedCodeCacheContext()->Initialize(\n          code_cache_path, settings.size_in_bytes());\n    }\n  }\n\n  return partition;\n}\n", "target": 1, "flaw_line_index": "43"}
{"idx": 186685, "func": "bool NormalPageArena::coalesce() {\n  if (m_promptlyFreedSize < 1024 * 1024)\n    return false;\n\n  if (getThreadState()->sweepForbidden())\n    return false;\n\n  ASSERT(!hasCurrentAllocationArea());\n  TRACE_EVENT0(\"blink_gc\", \"BaseArena::coalesce\");\n\n  m_freeList.clear();\n  size_t freedSize = 0;\n  for (NormalPage* page = static_cast<NormalPage*>(m_firstPage); page;\n       page = static_cast<NormalPage*>(page->next())) {\n    Address startOfGap = page->payload();\n    for (Address headerAddress = startOfGap;\n         headerAddress < page->payloadEnd();) {\n      HeapObjectHeader* header =\n          reinterpret_cast<HeapObjectHeader*>(headerAddress);\n      size_t size = header->size();\n      ASSERT(size > 0);\n      ASSERT(size < blinkPagePayloadSize());\n\n      if (header->isPromptlyFreed()) {\n        ASSERT(size >= sizeof(HeapObjectHeader));\n        SET_MEMORY_INACCESSIBLE(headerAddress, sizeof(HeapObjectHeader));\n        CHECK_MEMORY_INACCESSIBLE(headerAddress, size);\n        freedSize += size;\n        headerAddress += size;\n        continue;\n      }\n      if (header->isFree()) {\n        SET_MEMORY_INACCESSIBLE(headerAddress, size < sizeof(FreeListEntry)\n                                                   ? size\n                                                   : sizeof(FreeListEntry));\n        CHECK_MEMORY_INACCESSIBLE(headerAddress, size);\n         headerAddress += size;\n         continue;\n       }\n      ASSERT(header->checkHeader());\n       if (startOfGap != headerAddress)\n         addToFreeList(startOfGap, headerAddress - startOfGap);\n \n      headerAddress += size;\n      startOfGap = headerAddress;\n    }\n\n    if (startOfGap != page->payloadEnd())\n      addToFreeList(startOfGap, page->payloadEnd() - startOfGap);\n  }\n  getThreadState()->decreaseAllocatedObjectSize(freedSize);\n  ASSERT(m_promptlyFreedSize == freedSize);\n  m_promptlyFreedSize = 0;\n  return true;\n}\n", "target": 1, "flaw_line_index": "55"}
{"idx": 186707, "func": "bool IsIDNComponentSafe(base::StringPiece16 label, bool is_tld_ascii) {\n  return g_idn_spoof_checker.Get().SafeToDisplayAsUnicode(label, is_tld_ascii);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7781, "func": "static void h2_show_fd(struct chunk *msg, struct connection *conn)\n{\n\tstruct h2c *h2c = conn->mux_ctx;\n\tstruct h2s *h2s;\n\tstruct eb32_node *node;\n\tint fctl_cnt = 0;\n\tint send_cnt = 0;\n\tint tree_cnt = 0;\n\tint orph_cnt = 0;\n\n\tif (!h2c)\n\t\treturn;\n\n\tlist_for_each_entry(h2s, &h2c->fctl_list, list)\n\t\tfctl_cnt++;\n\n\tlist_for_each_entry(h2s, &h2c->send_list, list)\n\t\tsend_cnt++;\n\n\tnode = eb32_first(&h2c->streams_by_id);\n\twhile (node) {\n\t\th2s = container_of(node, struct h2s, by_id);\n\t\ttree_cnt++;\n\t\tif (!h2s->cs)\n\t\t\torph_cnt++;\n\t\tnode = eb32_next(node);\n\t}\n\n\tchunk_appendf(msg, \" st0=%d flg=0x%08x fctl_cnt=%d send_cnt=%d tree_cnt=%d orph_cnt=%d\",\n\t\t      h2c->st0, h2c->flags, fctl_cnt, send_cnt, tree_cnt, orph_cnt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187219, "func": "static int _hid_wcslen(WCHAR *str)\n{\n\tint i = 0;\n\twhile (str[i] && (str[i] != 0x409)) {\n\t\ti++;\n\t}\n\treturn i;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8"}
{"idx": 7466, "func": "  t1_decoder_done( T1_Decoder  decoder )\n  {\n    t1_builder_done( &decoder->builder );\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7547, "func": "static inline int finish_nested_data(UNSERIALIZE_PARAMETER)\n{\n\tif (*((*p)++) == '}')\n", "target": 0, "flaw_line_index": ""}
{"idx": 7770, "func": "static int h2_parse_max_concurrent_streams(char **args, int section_type, struct proxy *curpx,\n                                           struct proxy *defpx, const char *file, int line,\n                                           char **err)\n{\n\tif (too_many_args(1, args, err, NULL))\n\t\treturn -1;\n\n\th2_settings_max_concurrent_streams = atoi(args[1]);\n\tif (h2_settings_max_concurrent_streams < 0) {\n\t\tmemprintf(err, \"'%s' expects a positive numeric value.\", args[0]);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186774, "func": " VaapiVideoDecodeAccelerator::VaapiH264Accelerator::CreateH264Picture() {\n   scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n   if (!va_surface)\n     return nullptr;\n\n  return new VaapiH264Picture(std::move(va_surface));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8038, "func": "static void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n\n    graphic_hw_update(NULL);\n\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n    }\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7809, "func": "static inline struct h2s *h2c_st_by_id(struct h2c *h2c, int id)\n{\n\tstruct eb32_node *node;\n\n\tif (id > h2c->max_id)\n\t\treturn (struct h2s *)h2_idle_stream;\n\n\tnode = eb32_lookup(&h2c->streams_by_id, id);\n\tif (!node)\n\t\treturn (struct h2s *)h2_closed_stream;\n\n\treturn container_of(node, struct h2s, by_id);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187104, "func": " void ChromeContentBrowserClient::OpenURL(\n    content::BrowserContext* browser_context,\n     const content::OpenURLParams& params,\n    const base::Callback<void(content::WebContents*)>& callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n \n #if defined(OS_ANDROID)\n   ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,\n                                               callback);\n#else\n  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),\n                            params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav_params.user_gesture = params.user_gesture;\n\n  Navigate(&nav_params);\n  callback.Run(nav_params.navigated_or_inserted_contents);\n#endif\n}\n", "target": 1, "flaw_line_index": "2,4"}
{"idx": 187265, "func": "void DevToolsAgentHost::DetachAllClients() {\n  if (!g_devtools_instances.IsCreated())\n    return;\n\n   DevToolsMap copy = g_devtools_instances.Get();\n   for (DevToolsMap::iterator it(copy.begin()); it != copy.end(); ++it) {\n     DevToolsAgentHostImpl* agent_host = it->second;\n    agent_host->ForceDetachAllClients();\n   }\n }\n", "target": 1, "flaw_line_index": "10"}
{"idx": 7445, "func": "ZEND_API void zend_ts_hash_copy_to_hash(HashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, void *tmp, uint size)\n{\n\tbegin_read(source);\n\tzend_hash_copy(target, TS_HASH(source), pCopyConstructor, tmp, size);\n\tend_read(source);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187082, "func": " MediaStreamDispatcherHost::~MediaStreamDispatcherHost() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  bindings_.CloseAllBindings();\n   CancelAllRequests();\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186586, "func": "bool SQLiteDatabase::Open(const String& filename) {\n  Close();\n\n  open_error_ = SQLiteFileSystem::OpenDatabase(filename, &db_);\n  if (open_error_ != SQLITE_OK) {\n    open_error_message_ =\n        db_ ? sqlite3_errmsg(db_) : \"sqlite_open returned null\";\n    DLOG(ERROR) << \"SQLite database failed to load from \" << filename\n                << \"\\nCause - \" << open_error_message_.data();\n    sqlite3_close(db_);\n    db_ = nullptr;\n    return false;\n  }\n\n  open_error_ = sqlite3_extended_result_codes(db_, 1);\n  if (open_error_ != SQLITE_OK) {\n    open_error_message_ = sqlite3_errmsg(db_);\n    DLOG(ERROR) << \"SQLite database error when enabling extended errors - \"\n                << open_error_message_.data();\n    sqlite3_close(db_);\n    db_ = nullptr;\n     return false;\n   }\n \n   if (IsOpen())\n     opening_thread_ = CurrentThread();\n   else\n    open_error_message_ = \"sqlite_open returned null\";\n\n  if (!SQLiteStatement(*this, \"PRAGMA temp_store = MEMORY;\").ExecuteCommand())\n    DLOG(ERROR) << \"SQLite database could not set temp_store to memory\";\n\n  if (!SQLiteStatement(*this, \"PRAGMA foreign_keys = OFF;\").ExecuteCommand())\n    DLOG(ERROR) << \"SQLite database could not turn off foreign_keys\";\n\n  return IsOpen();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8217, "func": "static void v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            goto out;\n        default:\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187179, "func": "void DownloadRequestLimiter::TabDownloadState::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->IsInMainFrame())\n    return;\n\n   if (status_ == ALLOW_ONE_DOWNLOAD ||\n       (status_ == PROMPT_BEFORE_DOWNLOAD &&\n       !navigation_handle->IsRendererInitiated())) {\n    NotifyCallbacks(false);\n    host_->Remove(this, web_contents());\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186570, "func": "void AcceleratedStaticBitmapImage::Draw(cc::PaintCanvas* canvas,\n                                        const cc::PaintFlags& flags,\n                                        const FloatRect& dst_rect,\n                                        const FloatRect& src_rect,\n                                         RespectImageOrientationEnum,\n                                         ImageClampingMode image_clamping_mode,\n                                         ImageDecodingMode decode_mode) {\n   auto paint_image = PaintImageForCurrentFrame();\n   if (!paint_image)\n     return;\n  auto paint_image_decoding_mode = ToPaintImageDecodingMode(decode_mode);\n  if (paint_image.decoding_mode() != paint_image_decoding_mode) {\n    paint_image = PaintImageBuilder::WithCopy(std::move(paint_image))\n                      .set_decoding_mode(paint_image_decoding_mode)\n                      .TakePaintImage();\n  }\n  StaticBitmapImage::DrawHelper(canvas, flags, dst_rect, src_rect,\n                                image_clamping_mode, paint_image);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7469, "func": "  t1_lookup_glyph_by_stdcharcode( T1_Decoder  decoder,\n                                  FT_Int      charcode )\n  {\n    FT_UInt             n;\n    const FT_String*    glyph_name;\n    FT_Service_PsCMaps  psnames = decoder->psnames;\n\n\n    if ( charcode < 0 || charcode > 255 )\n      return -1;\n\n    glyph_name = psnames->adobe_std_strings(\n                   psnames->adobe_std_encoding[charcode]);\n\n    for ( n = 0; n < decoder->num_glyphs; n++ )\n    {\n      FT_String*  name = (FT_String*)decoder->glyph_names[n];\n\n\n      if ( name                               &&\n           name[0] == glyph_name[0]           &&\n           ft_strcmp( name, glyph_name ) == 0 )\n        return (FT_Int)n;\n    }\n\n    return -1;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7945, "func": "static js_Function *newfun(js_State *J, js_Ast *name, js_Ast *params, js_Ast *body, int script)\n{\n\tjs_Function *F = js_malloc(J, sizeof *F);\n\tmemset(F, 0, sizeof *F);\n\tF->gcmark = 0;\n\tF->gcnext = J->gcfun;\n\tJ->gcfun = F;\n\t++J->gccounter;\n\n\tF->filename = js_intern(J, J->filename);\n\tF->line = name ? name->line : params ? params->line : body ? body->line : 1;\n\tF->script = script;\n\tF->name = name ? name->string : \"\";\n\n\tcfunbody(J, F, name, params, body);\n\n\treturn F;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7969, "func": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n{\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n        [INPUT_BUTTON_LEFT]       = 0x01,\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n    };\n    QemuConsole *con = vs->vd->dcl.con;\n    int width = pixman_image_get_width(vs->vd->server);\n    int height = pixman_image_get_height(vs->vd->server);\n\n    if (vs->last_bmask != button_mask) {\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n        vs->last_bmask = button_mask;\n    }\n\n    if (vs->absolute) {\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n    } else {\n        if (vs->last_x != -1) {\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n        }\n        vs->last_x = x;\n        vs->last_y = y;\n    }\n    qemu_input_event_sync();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7499, "func": "iter_recurse (DBusMessageDataIter *iter)\n{\n  iter->depth += 1;\n  _dbus_assert (iter->depth < _DBUS_MESSAGE_DATA_MAX_NESTING);\n  _dbus_assert (iter->sequence_nos[iter->depth] >= 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186551, "func": "void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {\n  if (event->type() != ui::ET_GESTURE_TAP)\n    return;\n\n  hide_controls_timer_.Reset();\n\n  if (!GetControlsScrimLayer()->visible()) {\n    UpdateControlsVisibility(true);\n    return;\n  }\n\n  if (GetCloseControlsBounds().Contains(event->location())) {\n    controller_->Close(true \n,\n                       true \n);\n    event->SetHandled();\n  } else if (GetPlayPauseControlsBounds().Contains(event->location())) {\n     TogglePlayPause();\n     event->SetHandled();\n   }\n  views::Widget::OnGestureEvent(event);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186410, "func": "  base::string16 GetCertificateButtonTitle() const {\n    PageInfoBubbleView* page_info_bubble_view =\n        static_cast<PageInfoBubbleView*>(\n            PageInfoBubbleView::GetPageInfoBubble());\n    return page_info_bubble_view->certificate_button_->title()->text();\n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 8075, "func": "void Gfx::doForm(Object *str) {\n  Dict *dict;\n  GBool transpGroup, isolated, knockout;\n  GfxColorSpace *blendingColorSpace;\n  Object matrixObj, bboxObj;\n  double m[6], bbox[4];\n  Object resObj;\n  Dict *resDict;\n  Object obj1, obj2, obj3;\n  int i;\n\n  if (formDepth > 20) {\n    return;\n  }\n\n  dict = str->streamGetDict();\n\n  dict->lookup(\"FormType\", &obj1);\n  if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {\n    error(getPos(), \"Unknown form type\");\n  }\n  obj1.free();\n\n  dict->lookup(\"BBox\", &bboxObj);\n  if (!bboxObj.isArray()) {\n    bboxObj.free();\n    error(getPos(), \"Bad form bounding box\");\n    return;\n  }\n  for (i = 0; i < 4; ++i) {\n    bboxObj.arrayGet(i, &obj1);\n    bbox[i] = obj1.getNum();\n    obj1.free();\n  }\n  bboxObj.free();\n\n  dict->lookup(\"Matrix\", &matrixObj);\n  if (matrixObj.isArray()) {\n    for (i = 0; i < 6; ++i) {\n      matrixObj.arrayGet(i, &obj1);\n      m[i] = obj1.getNum();\n      obj1.free();\n    }\n  } else {\n    m[0] = 1; m[1] = 0;\n    m[2] = 0; m[3] = 1;\n    m[4] = 0; m[5] = 0;\n  }\n  matrixObj.free();\n\n  dict->lookup(\"Resources\", &resObj);\n  resDict = resObj.isDict() ? resObj.getDict() : (Dict *)NULL;\n\n  transpGroup = isolated = knockout = gFalse;\n  blendingColorSpace = NULL;\n  if (dict->lookup(\"Group\", &obj1)->isDict()) {\n    if (obj1.dictLookup(\"S\", &obj2)->isName(\"Transparency\")) {\n      transpGroup = gTrue;\n      if (!obj1.dictLookup(\"CS\", &obj3)->isNull()) {\n\tblendingColorSpace = GfxColorSpace::parse(&obj3, this);\n      }\n      obj3.free();\n      if (obj1.dictLookup(\"I\", &obj3)->isBool()) {\n\tisolated = obj3.getBool();\n      }\n      obj3.free();\n      if (obj1.dictLookup(\"K\", &obj3)->isBool()) {\n\tknockout = obj3.getBool();\n      }\n      obj3.free();\n    }\n    obj2.free();\n  }\n  obj1.free();\n\n  ++formDepth;\n  doForm1(str, resDict, m, bbox,\n\t  transpGroup, gFalse, blendingColorSpace, isolated, knockout);\n  --formDepth;\n\n  if (blendingColorSpace) {\n    delete blendingColorSpace;\n  }\n  resObj.free();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7801, "func": "static int h2c_handle_window_update(struct h2c *h2c, struct h2s *h2s)\n{\n\tint32_t inc;\n\tint error;\n\n\tif (h2c->dfl != 4) {\n\t\terror = H2_ERR_FRAME_SIZE_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->dbuf->i < h2c->dfl)\n\t\treturn 0;\n\n\tinc = h2_get_n32(h2c->dbuf, 0);\n\n\tif (h2c->dsi != 0) {\n\n\t\tif (h2s->st == H2_SS_CLOSED)\n\t\t\treturn 1;\n\n\t\tif (!inc) {\n\t\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\tif (h2s->mws >= 0 && h2s->mws + inc < 0) {\n\t\t\terror = H2_ERR_FLOW_CONTROL_ERROR;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\th2s->mws += inc;\n\t\tif (h2s->mws > 0 && (h2s->flags & H2_SF_BLK_SFCTL)) {\n\t\t\th2s->flags &= ~H2_SF_BLK_SFCTL;\n\t\t\tif (h2s->cs && LIST_ISEMPTY(&h2s->list) &&\n\t\t\t    (h2s->cs->flags & CS_FL_DATA_WR_ENA)) {\n\t\t\t\tLIST_ADDQ(&h2c->send_list, &h2s->list);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (!inc) {\n\t\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\t\tgoto conn_err;\n\t\t}\n\n\t\tif (h2c->mws >= 0 && h2c->mws + inc < 0) {\n\t\t\terror = H2_ERR_FLOW_CONTROL_ERROR;\n\t\t\tgoto conn_err;\n\t\t}\n\n\t\th2c->mws += inc;\n\t}\n\n\treturn 1;\n\n conn_err:\n\th2c_error(h2c, error);\n\treturn 0;\n\n strm_err:\n\tif (h2s) {\n\t\th2s_error(h2s, error);\n\t\th2c->st0 = H2_CS_FRAME_E;\n\t}\n\telse\n\t\th2c_error(h2c, error);\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8016, "func": "void vnc_display_init(DisplayState *ds)\n{\n    VncDisplay *vs = g_malloc0(sizeof(*vs));\n\n    vnc_display = vs;\n\n    vs->lsock = -1;\n#ifdef CONFIG_VNC_WS\n    vs->lwebsock = -1;\n#endif\n\n    QTAILQ_INIT(&vs->clients);\n    vs->expires = TIME_MAX;\n\n    if (keyboard_layout) {\n        trace_vnc_key_map_init(keyboard_layout);\n        vs->kbd_layout = init_keyboard_layout(name2keysym, keyboard_layout);\n    } else {\n        vs->kbd_layout = init_keyboard_layout(name2keysym, \"en-us\");\n    }\n\n    if (!vs->kbd_layout)\n        exit(1);\n\n    qemu_mutex_init(&vs->mutex);\n    vnc_start_worker_thread();\n\n    vs->dcl.ops = &dcl_ops;\n    register_displaychangelistener(&vs->dcl);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7807, "func": "static int h2c_send_window_update(struct h2c *h2c, int sid, uint32_t increment)\n{\n\tstruct buffer *res;\n\tchar str[13];\n\tint ret = -1;\n\n\tif (h2c_mux_busy(h2c, NULL)) {\n\t\th2c->flags |= H2_CF_DEM_MBUSY;\n\t\treturn 0;\n\t}\n\n\tres = h2_get_buf(h2c, &h2c->mbuf);\n\tif (!res) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\treturn 0;\n\t}\n\n\tmemcpy(str, \"\\x00\\x00\\x04\\x08\\x00\", 5);\n\twrite_n32(str + 5, sid);\n\twrite_n32(str + 9, increment);\n\n\tret = bo_istput(res, ist2(str, 13));\n\n\tif (unlikely(ret <= 0)) {\n\t\tif (!ret) {\n\t\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7442, "func": "ZEND_API void zend_ts_hash_apply_with_arguments(TsHashTable *ht TSRMLS_DC, apply_func_args_t apply_func, int num_args, ...)\n{\n\tva_list args;\n\n\tva_start(args, num_args);\n\tbegin_write(ht);\n\tzend_hash_apply_with_arguments(TS_HASH(ht) TSRMLS_CC, apply_func, num_args, args);\n\tend_write(ht);\n\tva_end(args);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8123, "func": "void Gfx::opEndMarkedContent(Object args[], int numArgs) {\n  if (mcStack)\n    popMarkedContent();\n  out->endMarkedContent(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186725, "func": "void InspectorHandler::SetRenderer(RenderProcessHost* process_host,\n                                    RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187261, "func": "bool DebuggerAttachFunction::RunAsync() {\n  std::unique_ptr<Attach::Params> params(Attach::Params::Create(*args_));\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n\n  CopyDebuggee(&debuggee_, params->target);\n  if (!InitAgentHost())\n    return false;\n\n  if (!DevToolsAgentHost::IsSupportedProtocolVersion(\n          params->required_version)) {\n    error_ = ErrorUtils::FormatErrorMessage(\n        keys::kProtocolVersionNotSupportedError,\n        params->required_version);\n    return false;\n  }\n\n  if (FindClientHost()) {\n    FormatErrorMessage(keys::kAlreadyAttachedError);\n     return false;\n   }\n \n  new ExtensionDevToolsClientHost(GetProfile(), agent_host_.get(),\n                                  extension()->id(), extension()->name(),\n                                  debuggee_);\n   SendResponse(true);\n   return true;\n }\n", "target": 1, "flaw_line_index": "22,23,24"}
{"idx": 7674, "func": "static ssize_t handle_llistxattr(FsContext *ctx, V9fsPath *fs_path,\n                                 void *value, size_t size)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = flistxattr(fd, value, size);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8145, "func": "void Gfx::opSetFillColorSpace(Object args[], int numArgs) {\n  Object obj;\n  GfxColorSpace *colorSpace;\n  GfxColor color;\n\n  res->lookupColorSpace(args[0].getName(), &obj);\n  if (obj.isNull()) {\n    colorSpace = GfxColorSpace::parse(&args[0], this);\n  } else {\n    colorSpace = GfxColorSpace::parse(&obj, this);\n  }\n  obj.free();\n  if (colorSpace) {\n    if (textHaveCSPattern && drawText) {\n      GBool needFill = out->deviceHasTextClip(state);\n      out->endTextObject(state);\n      if (needFill) {\n        doPatternFill(gTrue);\n      }\n      out->restoreState(state);\n    }\n    state->setFillPattern(NULL);\n    state->setFillColorSpace(colorSpace);\n    out->updateFillColorSpace(state);\n    colorSpace->getDefaultColor(&color);\n    state->setFillColor(&color);\n    out->updateFillColor(state);\n    if (textHaveCSPattern) {\n      out->beginTextObject(state);\n      out->updateRender(state);\n      out->updateTextMat(state);\n      out->updateTextPos(state);\n      textHaveCSPattern = colorSpace->getMode() == csPattern;\n    } else if (drawText && out->supportTextCSPattern(state)) {\n      out->beginTextObject(state);\n      textHaveCSPattern = gTrue;\n    }\n  } else {\n    error(getPos(), \"Bad color space (fill)\");\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186350, "func": "bool ResourcePrefetchPredictor::PredictPreconnectOrigins(\n    const GURL& url,\n    PreconnectPrediction* prediction) const {\n  DCHECK(!prediction || prediction->requests.empty());\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (initialization_state_ != INITIALIZED)\n    return false;\n\n  url::Origin url_origin = url::Origin::Create(url);\n  url::Origin redirect_origin;\n  bool has_any_prediction = GetRedirectEndpointsForPreconnect(\n      url_origin, *host_redirect_data_, prediction);\n  if (!GetRedirectOrigin(url_origin, *host_redirect_data_, &redirect_origin)) {\n    return has_any_prediction;\n  }\n\n  OriginData data;\n  if (!origin_data_->TryGetData(redirect_origin.host(), &data)) {\n    return has_any_prediction;\n  }\n\n  if (prediction) {\n    prediction->host = redirect_origin.host();\n    prediction->is_redirected = (redirect_origin != url_origin);\n  }\n\n  net::NetworkIsolationKey network_isolation_key(redirect_origin,\n                                                 redirect_origin);\n\n  for (const OriginStat& origin : data.origins()) {\n    float confidence = static_cast<float>(origin.number_of_hits()) /\n                       (origin.number_of_hits() + origin.number_of_misses());\n    if (confidence < kMinOriginConfidenceToTriggerPreresolve)\n      continue;\n\n     has_any_prediction = true;\n     if (prediction) {\n       if (confidence > kMinOriginConfidenceToTriggerPreconnect) {\n        prediction->requests.emplace_back(GURL(origin.origin()), 1,\n                                          network_isolation_key);\n       } else {\n        prediction->requests.emplace_back(GURL(origin.origin()), 0,\n                                          network_isolation_key);\n       }\n     }\n   }\n\n  return has_any_prediction;\n}\n", "target": 1, "flaw_line_index": "43,44,46,47"}
{"idx": 7556, "func": "PHPAPI void var_destroy(php_unserialize_data_t *var_hashx)\n{\n\tvoid *next;\n\tlong i;\n\tvar_entries *var_hash = (*var_hashx)->first;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_destroy(%ld)\\n\", var_hash?var_hash->used_slots:-1L);\n#endif\n\t\n\twhile (var_hash) {\n\t\tnext = var_hash->next;\n\t\tefree(var_hash);\n\t\tvar_hash = next;\n\t}\n\n\tvar_hash = (*var_hashx)->first_dtor;\n\t\n\twhile (var_hash) {\n\t\tfor (i = 0; i < var_hash->used_slots; i++) {\n\t\t\tzval_ptr_dtor(&var_hash->data[i]);\n\t\t}\n\t\tnext = var_hash->next;\n\t\tefree(var_hash);\n\t\tvar_hash = next;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186746, "func": "void ServiceWorkerHandler::SetRenderer(RenderProcessHost* process_host,\n                                        RenderFrameHostImpl* frame_host) {\n  process_ = process_host;\n   if (!process_host) {\n     ClearForceUpdate();\n     context_ = nullptr;\n     return;\n   }\n  StoragePartition* partition = process_host->GetStoragePartition();\n  DCHECK(partition);\n   context_ = static_cast<ServiceWorkerContextWrapper*>(\n      partition->GetServiceWorkerContext());\n }\n", "target": 1, "flaw_line_index": "3,10,11,13"}
{"idx": 8140, "func": "void Gfx::opSetDash(Object args[], int numArgs) {\n  Array *a;\n  int length;\n  Object obj;\n  double *dash;\n  int i;\n\n  a = args[0].getArray();\n  length = a->getLength();\n  if (length == 0) {\n    dash = NULL;\n  } else {\n    dash = (double *)gmallocn(length, sizeof(double));\n    for (i = 0; i < length; ++i) {\n      dash[i] = a->get(i, &obj)->getNum();\n      obj.free();\n    }\n  }\n  state->setLineDash(dash, length, args[1].getNum());\n  out->updateLineDash(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8020, "func": "int vnc_display_pw_expire(DisplayState *ds, time_t expires)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs) {\n        return -EINVAL;\n    }\n\n    vs->expires = expires;\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186846, "func": "SharedMemoryHandleProvider::GetHandleForInterProcessTransit(bool read_only) {\n  if (read_only_flag_ && !read_only) {\n     NOTREACHED();\n     return mojo::ScopedSharedBufferHandle();\n   }\n   return mojo::WrapSharedMemoryHandle(\n       base::SharedMemory::DuplicateHandle(shared_memory_->handle()),\n      mapped_size_, read_only);\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 7774, "func": "static void h2_recv(struct connection *conn)\n{\n\tstruct h2c *h2c = conn->mux_ctx;\n\tstruct buffer *buf;\n\tint max;\n\n\tif (!h2_recv_allowed(h2c))\n\t\treturn;\n\n\tbuf = h2_get_buf(h2c, &h2c->dbuf);\n\tif (!buf) {\n\t\th2c->flags |= H2_CF_DEM_DALLOC;\n\t\treturn;\n\t}\n\n\tmax = buf->size - buf->i;\n\tif (max)\n\t\tconn->xprt->rcv_buf(conn, buf, max);\n\n\tif (!buf->i) {\n\t\th2_release_buf(h2c, &h2c->dbuf);\n\t\treturn;\n\t}\n\n\tif (buf->i == buf->size)\n\t\th2c->flags |= H2_CF_DEM_DFULL;\n\treturn;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8009, "func": "static void vnc_copy(VncState *vs, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); \n    vnc_framebuffer_update(vs, dst_x, dst_y, w, h, VNC_ENCODING_COPYRECT);\n    vnc_write_u16(vs, src_x);\n    vnc_write_u16(vs, src_y);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7503, "func": "simple_error (void)\n{\n  DBusMessage *message;\n  message =  dbus_message_new (DBUS_MESSAGE_TYPE_ERROR);\n  if (message == NULL)\n    _dbus_assert_not_reached (\"oom\");\n\n  if (!dbus_message_set_error_name (message, \"foo.bar\"))\n    _dbus_assert_not_reached (\"oom\");\n  \n  set_reply_serial (message);\n  \n   return message;\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 187273, "func": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   if (state_ == WORKER_READY) {\n     if (sessions().size() == 1) {\n       BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                              base::BindOnce(&SetDevToolsAttachedOnIO,\n                                             context_weak_, version_id_, true));\n    }\n    session->SetRenderer(worker_process_id_, nullptr);\n    session->AttachToAgent(agent_ptr_);\n  }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7715, "func": "static int coroutine_fn v9fs_do_readdir_with_stat(V9fsPDU *pdu,\n                                                  V9fsFidState *fidp,\n                                                  uint32_t max_count)\n{\n    V9fsPath path;\n    V9fsStat v9stat;\n    int len, err = 0;\n    int32_t count = 0;\n    struct stat stbuf;\n    off_t saved_dir_pos;\n    struct dirent *dent;\n\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n    if (saved_dir_pos < 0) {\n        return saved_dir_pos;\n    }\n\n    while (1) {\n        v9fs_path_init(&path);\n\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n        if (err || !dent) {\n            break;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);\n        if (err < 0) {\n            break;\n        }\n        err = v9fs_co_lstat(pdu, &path, &stbuf);\n        if (err < 0) {\n            break;\n        }\n        err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);\n        if (err < 0) {\n            break;\n        }\n        len = pdu_marshal(pdu, 11 + count, \"S\", &v9stat);\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n        if ((len != (v9stat.size + 2)) || ((count + len) > max_count)) {\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_stat_free(&v9stat);\n            v9fs_path_free(&path);\n            return count;\n        }\n        count += len;\n        v9fs_stat_free(&v9stat);\n        v9fs_path_free(&path);\n        saved_dir_pos = dent->d_off;\n    }\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n    v9fs_path_free(&path);\n    if (err < 0) {\n        return err;\n    }\n    return count;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187119, "func": "void GCInfoTable::Init() {\n  CHECK(!g_gc_info_table);\n   Resize();\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187235, "func": "static int hid_submit_bulk_transfer(int sub_api, struct usbi_transfer *itransfer) {\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n\tstruct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);\n\tstruct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);\n\tstruct winfd wfd;\n\tHANDLE hid_handle;\n\tbool direction_in, ret;\n\tint current_interface, length;\n\tDWORD size;\n\tint r = LIBUSB_SUCCESS;\n\tCHECK_HID_AVAILABLE;\n\ttransfer_priv->pollable_fd = INVALID_WINFD;\n\ttransfer_priv->hid_dest = NULL;\n\tsafe_free(transfer_priv->hid_buffer);\n\tcurrent_interface = interface_by_endpoint(priv, handle_priv, transfer->endpoint);\n\tif (current_interface < 0) {\n\t\tusbi_err(ctx, \"unable to match endpoint to an open interface - cancelling transfer\");\n\t\treturn LIBUSB_ERROR_NOT_FOUND;\n\t}\n\tusbi_dbg(\"matched endpoint %02X with interface %d\", transfer->endpoint, current_interface);\n\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\tdirection_in = transfer->endpoint & LIBUSB_ENDPOINT_IN;\n\twfd = usbi_create_fd(hid_handle, direction_in?RW_READ:RW_WRITE, NULL, NULL);\n\tif (wfd.fd < 0) {\n\t\treturn LIBUSB_ERROR_NO_MEM;\n\t}\n\tif ( ((direction_in) && (!priv->hid->uses_report_ids[0]))\n\t  || ((!direction_in) && (!priv->hid->uses_report_ids[1])) ) {\n\t\tlength = transfer->length+1;\n\t} else {\n\t\tlength = transfer->length;\n\t}\n\ttransfer_priv->hid_buffer = (uint8_t*)calloc(length+1, 1);\n\tif (transfer_priv->hid_buffer == NULL) {\n\t\treturn LIBUSB_ERROR_NO_MEM;\n\t}\n\ttransfer_priv->hid_expected_size = length;\n\tif (direction_in) {\n\t\ttransfer_priv->hid_dest = transfer->buffer;\n\t\tusbi_dbg(\"reading %d bytes (report ID: 0x00)\", length);\n\t\tret = ReadFile(wfd.handle, transfer_priv->hid_buffer, length+1, &size, wfd.overlapped);\n\t} else {\n\t\tif (!priv->hid->uses_report_ids[1]) {\n\t\t\tmemcpy(transfer_priv->hid_buffer+1, transfer->buffer, transfer->length);\n\t\t} else {\n\t\t\tmemcpy(transfer_priv->hid_buffer, transfer->buffer, transfer->length);\n\t\t}\n\t\tusbi_dbg(\"writing %d bytes (report ID: 0x%02X)\", length, transfer_priv->hid_buffer[0]);\n\t\tret = WriteFile(wfd.handle, transfer_priv->hid_buffer, length, &size, wfd.overlapped);\n\t}\n\tif (!ret) {\n\t\tif (GetLastError() != ERROR_IO_PENDING) {\n\t\t\tusbi_err(ctx, \"HID transfer failed: %s\", windows_error_str(0));\n\t\t\tusbi_free_fd(&wfd);\n\t\t\tsafe_free(transfer_priv->hid_buffer);\n\t\t\treturn LIBUSB_ERROR_IO;\n\t\t}\n\t} else {\n\t\tif (!direction_in) {\n\t\t\tsafe_free(transfer_priv->hid_buffer);\n\t\t}\n\t\tif (size == 0) {\n\t\t\tusbi_err(ctx, \"program assertion failed - no data was transferred\");\n\t\t\tsize = 1;\n\t\t}\n\t\tif (size > (size_t)length) {\n\t\t\tusbi_err(ctx, \"OVERFLOW!\");\n\t\t\tr = LIBUSB_ERROR_OVERFLOW;\n\t\t}\n\t\twfd.overlapped->Internal = STATUS_COMPLETED_SYNCHRONOUSLY;\n\t\twfd.overlapped->InternalHigh = size;\n\t}\n\ttransfer_priv->pollable_fd = wfd;\n\ttransfer_priv->interface_number = (uint8_t)current_interface;\n\treturn r;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79"}
{"idx": 7987, "func": "void start_client_init(VncState *vs)\n{\n    vnc_read_when(vs, protocol_client_init, 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7497, "func": "iter_get_sequence (DBusMessageDataIter *iter)\n{\n  _dbus_assert (iter->sequence_nos[iter->depth] >= 0);\n  return iter->sequence_nos[iter->depth];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187080, "func": " MediaStreamDispatcherHost::MediaStreamDispatcherHost(\n     int render_process_id,\n     int render_frame_id,\n     MediaStreamManager* media_stream_manager)\n     : render_process_id_(render_process_id),\n       render_frame_id_(render_frame_id),\n       media_stream_manager_(media_stream_manager),\n       salt_and_origin_callback_(\n           base::BindRepeating(&GetMediaDeviceSaltAndOrigin)),\n       weak_factory_(this) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  bindings_.set_connection_error_handler(\n      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,\n                 weak_factory_.GetWeakPtr()));\n }\n", "target": 1, "flaw_line_index": "12,13,14"}
{"idx": 186996, "func": "ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(\n    const ChildProcessLauncherHelper::Process& process,\n    bool known_dead) {\n  ChildProcessTerminationInfo info;\n   if (!java_peer_avaiable_on_client_thread_)\n     return info;\n \n  Java_ChildProcessLauncherHelperImpl_getTerminationInfo(\n       AttachCurrentThread(), java_peer_, reinterpret_cast<intptr_t>(&info));\n \n   base::android::ApplicationState app_state =\n      base::android::ApplicationStatusListener::GetState();\n  bool app_foreground =\n      app_state == base::android::APPLICATION_STATE_HAS_RUNNING_ACTIVITIES ||\n      app_state == base::android::APPLICATION_STATE_HAS_PAUSED_ACTIVITIES;\n\n  if (app_foreground &&\n      (info.binding_state == base::android::ChildBindingState::MODERATE ||\n       info.binding_state == base::android::ChildBindingState::STRONG)) {\n    info.status = base::TERMINATION_STATUS_OOM_PROTECTED;\n  } else {\n    info.status = base::TERMINATION_STATUS_NORMAL_TERMINATION;\n  }\n  return info;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 7414, "func": "ZEND_API void zend_ts_hash_apply_with_arguments(TsHashTable *ht, apply_func_args_t apply_func, int num_args, ...)\n{\n\tva_list args;\n\n\tva_start(args, num_args);\n\tbegin_write(ht);\n\tzend_hash_apply_with_arguments(TS_HASH(ht), apply_func, num_args, args);\n\tend_write(ht);\n\tva_end(args);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7625, "func": "static int proxy_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n{\n    int retval;\n    retval = v9fs_request(fs_ctx->private, T_CHOWN, NULL, fs_path,\n                          credp->fc_uid, credp->fc_gid);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187168, "func": "DataPipeProducerDispatcher::Deserialize(const void* data,\n                                        size_t num_bytes,\n                                        const ports::PortName* ports,\n                                        size_t num_ports,\n                                        PlatformHandle* handles,\n                                        size_t num_handles) {\n  if (num_ports != 1 || num_handles != 1 ||\n      num_bytes != sizeof(SerializedState)) {\n    return nullptr;\n  }\n \n   const SerializedState* state = static_cast<const SerializedState*>(data);\n   if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||\n      state->options.capacity_num_bytes < state->options.element_num_bytes) {\n     return nullptr;\n   }\n \n  NodeController* node_controller = Core::Get()->GetNodeController();\n  ports::PortRef port;\n  if (node_controller->node()->GetPort(ports[0], &port) != ports::OK)\n    return nullptr;\n\n  auto region_handle = CreateSharedMemoryRegionHandleFromPlatformHandles(\n      std::move(handles[0]), PlatformHandle());\n  auto region = base::subtle::PlatformSharedMemoryRegion::Take(\n      std::move(region_handle),\n      base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe,\n      state->options.capacity_num_bytes,\n      base::UnguessableToken::Deserialize(state->buffer_guid_high,\n                                          state->buffer_guid_low));\n  auto ring_buffer =\n      base::UnsafeSharedMemoryRegion::Deserialize(std::move(region));\n  if (!ring_buffer.IsValid()) {\n    DLOG(ERROR) << \"Failed to deserialize shared buffer handle.\";\n    return nullptr;\n  }\n\n  scoped_refptr<DataPipeProducerDispatcher> dispatcher =\n      new DataPipeProducerDispatcher(node_controller, port,\n                                     std::move(ring_buffer), state->options,\n                                     state->pipe_id);\n\n  {\n    base::AutoLock lock(dispatcher->lock_);\n    dispatcher->write_offset_ = state->write_offset;\n    dispatcher->available_capacity_ = state->available_capacity;\n     dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;\n     if (!dispatcher->InitializeNoLock())\n       return nullptr;\n     dispatcher->UpdateSignalsStateNoLock();\n   }\n \n  return dispatcher;\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 186898, "func": " void ManifestManager::FetchManifest() {\n   manifest_url_ = render_frame()->GetWebFrame()->GetDocument().ManifestURL();\n \n   if (manifest_url_.is_empty()) {\n    ManifestUmaUtil::FetchFailed(ManifestUmaUtil::FETCH_EMPTY_URL);\n    ResolveCallbacks(ResolveStateFailure);\n    return;\n  }\n\n  fetcher_.reset(new ManifestFetcher(manifest_url_));\n  fetcher_->Start(\n      render_frame()->GetWebFrame(),\n      render_frame()->GetWebFrame()->GetDocument().ManifestUseCredentials(),\n      base::Bind(&ManifestManager::OnManifestFetchComplete,\n                 base::Unretained(this),\n                 render_frame()->GetWebFrame()->GetDocument().Url()));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186470, "func": " bool dstBufferSizeHasOverflow(ParsedOptions options) {\n  CheckedNumeric<size_t> totalBytes = options.cropRect.width();\n   totalBytes *= options.cropRect.height();\n   totalBytes *= options.bytesPerPixel;\n   if (!totalBytes.IsValid())\n    return true;\n\n  if (!options.shouldScaleInput)\n    return false;\n  totalBytes = options.resizeWidth;\n  totalBytes *= options.resizeHeight;\n  totalBytes *= options.bytesPerPixel;\n  if (!totalBytes.IsValid())\n    return true;\n\n  return false;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186365, "func": "scoped_refptr<VideoFrame> CloneVideoFrameWithLayout(\n    const VideoFrame* const src_frame,\n    const VideoFrameLayout& dst_layout) {\n  LOG_ASSERT(src_frame->IsMappable());\n  LOG_ASSERT(src_frame->format() == dst_layout.format());\n  auto dst_frame = VideoFrame::CreateFrameWithLayout(\n      dst_layout, src_frame->visible_rect(), src_frame->natural_size(),\n      src_frame->timestamp(), false \n);\n  if (!dst_frame) {\n    LOG(ERROR) << \"Failed to create VideoFrame\";\n    return nullptr;\n  }\n\n  const size_t num_planes = VideoFrame::NumPlanes(dst_layout.format());\n   LOG_ASSERT(dst_layout.planes().size() == num_planes);\n   LOG_ASSERT(src_frame->layout().planes().size() == num_planes);\n   for (size_t i = 0; i < num_planes; ++i) {\n     libyuv::CopyPlane(\n         src_frame->data(i), src_frame->layout().planes()[i].stride,\n         dst_frame->data(i), dst_frame->layout().planes()[i].stride,\n        VideoFrame::Columns(i, dst_frame->format(),\n                            dst_frame->natural_size().width()),\n        VideoFrame::Rows(i, dst_frame->format(),\n                         dst_frame->natural_size().height()));\n   }\n \n   return dst_frame;\n}\n", "target": 1, "flaw_line_index": "24,25,26,27"}
{"idx": 8147, "func": "void Gfx::opSetFillRGBColor(Object args[], int numArgs) {\n  GfxColor color;\n  int i;\n\n  if (textHaveCSPattern && drawText) {\n    GBool needFill = out->deviceHasTextClip(state);\n    out->endTextObject(state);\n    if (needFill) {\n      doPatternFill(gTrue);\n    }\n    out->restoreState(state);\n  }\n  state->setFillPattern(NULL);\n  state->setFillColorSpace(new GfxDeviceRGBColorSpace());\n  out->updateFillColorSpace(state);\n  for (i = 0; i < 3; ++i) {\n    color.c[i] = dblToCol(args[i].getNum());\n  }\n  state->setFillColor(&color);\n  out->updateFillColor(state);\n  if (textHaveCSPattern) {\n    out->beginTextObject(state);\n    out->updateRender(state);\n    out->updateTextMat(state);\n    out->updateTextPos(state);\n    textHaveCSPattern = gFalse;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186334, "func": "void UrlFetcherDownloader::StartURLFetch(const GURL& url) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n\n  if (download_dir_.empty()) {\n    Result result;\n    result.error = -1;\n\n    DownloadMetrics download_metrics;\n    download_metrics.url = url;\n    download_metrics.downloader = DownloadMetrics::kUrlFetcher;\n    download_metrics.error = -1;\n    download_metrics.downloaded_bytes = -1;\n    download_metrics.total_bytes = -1;\n    download_metrics.download_time_ms = 0;\n\n    main_task_runner()->PostTask(\n        FROM_HERE, base::BindOnce(&UrlFetcherDownloader::OnDownloadComplete,\n                                  base::Unretained(this), false, result,\n                                  download_metrics));\n     return;\n   }\n \n  const auto file_path = download_dir_.AppendASCII(url.ExtractFileName());\n   network_fetcher_ = network_fetcher_factory_->Create();\n   network_fetcher_->DownloadToFile(\n      url, file_path,\n       base::BindOnce(&UrlFetcherDownloader::OnResponseStarted,\n                      base::Unretained(this)),\n       base::BindRepeating(&UrlFetcherDownloader::OnDownloadProgress,\n                           base::Unretained(this)),\n       base::BindOnce(&UrlFetcherDownloader::OnNetworkFetcherComplete,\n                     base::Unretained(this), file_path));\n \n   download_start_time_ = base::TimeTicks::Now();\n }\n", "target": 1, "flaw_line_index": "23,26,32"}
{"idx": 7752, "func": "  tt_done_blend( FT_Memory  memory,\n                 GX_Blend   blend )\n  {\n    if ( blend != NULL )\n    {\n      FT_UInt  i;\n\n\n      FT_FREE( blend->normalizedcoords );\n      FT_FREE( blend->mmvar );\n\n      if ( blend->avar_segment != NULL )\n      {\n        for ( i = 0; i < blend->num_axis; ++i )\n          FT_FREE( blend->avar_segment[i].correspondence );\n        FT_FREE( blend->avar_segment );\n      }\n\n      FT_FREE( blend->tuplecoords );\n      FT_FREE( blend->glyphoffsets );\n      FT_FREE( blend );\n    }\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186862, "func": " ScopedSharedBufferHandle WrapSharedMemoryHandle(\n     const base::SharedMemoryHandle& memory_handle,\n     size_t size,\n    bool read_only) {\n   if (!memory_handle.IsValid())\n     return ScopedSharedBufferHandle();\n   MojoPlatformHandle platform_handle;\n  platform_handle.struct_size = sizeof(MojoPlatformHandle);\n  platform_handle.type = kPlatformSharedBufferHandleType;\n#if defined(OS_MACOSX) && !defined(OS_IOS)\n  platform_handle.value =\n      static_cast<uint64_t>(memory_handle.GetMemoryObject());\n#else\n  platform_handle.value =\n      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());\n#endif\n \n   MojoPlatformSharedBufferHandleFlags flags =\n       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;\n  if (read_only)\n    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n \n   MojoSharedBufferGuid guid;\n   guid.high = memory_handle.GetGUID().GetHighForSerialization();\n  guid.low = memory_handle.GetGUID().GetLowForSerialization();\n  MojoHandle mojo_handle;\n  MojoResult result = MojoWrapPlatformSharedBufferHandle(\n      &platform_handle, size, &guid, flags, &mojo_handle);\n  CHECK_EQ(result, MOJO_RESULT_OK);\n\n   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));\n }\n", "target": 1, "flaw_line_index": "4,20,21"}
{"idx": 8194, "func": "static void coroutine_fn v9fs_xattrwalk(void *opaque)\n{\n    int64_t size;\n    V9fsString name;\n    ssize_t err = 0;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrwalk(pdu->tag, pdu->id, fid, newfid, name.data);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    xattr_fidp = alloc_fid(s, newfid);\n    if (xattr_fidp == NULL) {\n        err = -EINVAL;\n        goto out;\n    }\n    v9fs_path_copy(&xattr_fidp->path, &file_fidp->path);\n    if (!v9fs_string_size(&name)) {\n        size = v9fs_co_llistxattr(pdu, &xattr_fidp->path, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.copied_len = -1;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_llistxattr(pdu, &xattr_fidp->path,\n                                     xattr_fidp->fs.xattr.value,\n                                     xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        err = pdu_marshal(pdu, offset, \"q\", size);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    } else {\n        size = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                 &name, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.copied_len = -1;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                    &name, xattr_fidp->fs.xattr.value,\n                                    xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        err = pdu_marshal(pdu, offset, \"q\", size);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    }\n    trace_v9fs_xattrwalk_return(pdu->tag, pdu->id, size);\nout:\n    put_fid(pdu, file_fidp);\n    if (xattr_fidp) {\n        put_fid(pdu, xattr_fidp);\n    }\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186367, "func": " void TabletModeWindowManager::ArrangeWindowsForClamshellMode(\n    base::flat_map<aura::Window*, WindowStateType> windows_in_splitview) {\n   int divider_position = CalculateCarryOverDividerPostion(windows_in_splitview);\n \n   while (window_state_map_.size()) {\n     aura::Window* window = window_state_map_.begin()->first;\n    ForgetWindow(window, \nfalse);\n   }\n \n   if (IsClamshellSplitViewModeEnabled()) {\n    DoSplitViewTransition(windows_in_splitview, divider_position);\n  }\n}\n", "target": 1, "flaw_line_index": "2,8"}
{"idx": 8036, "func": "void vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n{\n    vs->read_handler = func;\n    vs->read_handler_expect = expecting;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7988, "func": "static void vnc_abort_display_jobs(VncDisplay *vd)\n{\n    VncState *vs;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = true;\n        vnc_unlock_output(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_jobs_join(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = false;\n        vnc_unlock_output(vs);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186709, "func": " void ServerWrapper::OnHttpRequest(int connection_id,\n                                   const net::HttpServerRequestInfo& info) {\n   server_->SetSendBufferSize(connection_id, kSendBufferSizeForDevTools);\n \n   if (base::StartsWith(info.path, \"/json\", base::CompareCase::SENSITIVE)) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::BindOnce(&DevToolsHttpHandler::OnJsonRequest,\n                                           handler_, connection_id, info));\n    return;\n  }\n\n  if (info.path.empty() || info.path == \"/\") {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnDiscoveryPageRequest, handler_,\n                       connection_id));\n    return;\n  }\n\n  if (!base::StartsWith(info.path, \"/devtools/\",\n                        base::CompareCase::SENSITIVE)) {\n    server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  std::string filename = PathWithoutParams(info.path.substr(10));\n  std::string mime_type = GetMimeType(filename);\n\n  if (!debug_frontend_dir_.empty()) {\n    base::FilePath path = debug_frontend_dir_.AppendASCII(filename);\n    std::string data;\n    base::ReadFileToString(path, &data);\n    server_->Send200(connection_id, data, mime_type,\n                     kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  if (bundles_resources_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnFrontendResourceRequest,\n                       handler_, connection_id, filename));\n    return;\n  }\n  server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7635, "func": "static int proxy_lsetxattr(FsContext *ctx, V9fsPath *fs_path, const char *name,\n                           void *value, size_t size, int flags)\n{\n    int retval;\n    V9fsString xname, xvalue;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n\n    v9fs_string_init(&xvalue);\n    xvalue.size = size;\n    xvalue.data = g_malloc(size);\n    memcpy(xvalue.data, value, size);\n\n    retval = v9fs_request(ctx->private, T_LSETXATTR, value, fs_path, &xname,\n                          &xvalue, size, flags);\n    v9fs_string_free(&xname);\n    v9fs_string_free(&xvalue);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186351, "func": "ScrollAnchor::ExamineResult ScrollAnchor::Examine(\n    const LayoutObject* candidate) const {\n  if (candidate == ScrollerLayoutBox(scroller_))\n    return ExamineResult(kContinue);\n\n  if (candidate->StyleRef().OverflowAnchor() == EOverflowAnchor::kNone)\n    return ExamineResult(kSkip);\n\n  if (candidate->IsLayoutInline())\n    return ExamineResult(kContinue);\n\n  if (candidate->IsAnonymous())\n    return ExamineResult(kContinue);\n\n  if (!candidate->IsText() && !candidate->IsBox())\n    return ExamineResult(kSkip);\n\n  if (!CandidateMayMoveWithScroller(candidate, scroller_))\n    return ExamineResult(kSkip);\n\n  LayoutRect candidate_rect = RelativeBounds(candidate, scroller_);\n   LayoutRect visible_rect =\n       ScrollerLayoutBox(scroller_)->OverflowClipRect(LayoutPoint());\n \n   bool occupies_space =\n       candidate_rect.Width() > 0 && candidate_rect.Height() > 0;\n   if (occupies_space && visible_rect.Intersects(candidate_rect)) {\n    return ExamineResult(\n        visible_rect.Contains(candidate_rect) ? kReturn : kConstrain,\n        CornerToAnchor(scroller_));\n  } else {\n    return ExamineResult(kSkip);\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7877, "func": "static int save_xbzrle_page(QEMUFile *f, uint8_t **current_data,\n                            ram_addr_t current_addr, RAMBlock *block,\n                            ram_addr_t offset, int cont, bool last_stage)\n{\n    int encoded_len = 0, bytes_sent = -1;\n    uint8_t *prev_cached_page;\n\n    if (!cache_is_cached(XBZRLE.cache, current_addr)) {\n        acct_info.xbzrle_cache_miss++;\n        if (!last_stage) {\n            if (cache_insert(XBZRLE.cache, current_addr, *current_data) == -1) {\n                return -1;\n            } else {\n                *current_data = get_cached_data(XBZRLE.cache, current_addr);\n            }\n        }\n        return -1;\n    }\n\n    prev_cached_page = get_cached_data(XBZRLE.cache, current_addr);\n\n    memcpy(XBZRLE.current_buf, *current_data, TARGET_PAGE_SIZE);\n\n    encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,\n                                       TARGET_PAGE_SIZE, XBZRLE.encoded_buf,\n                                       TARGET_PAGE_SIZE);\n    if (encoded_len == 0) {\n        DPRINTF(\"Skipping unmodified page\\n\");\n        return 0;\n    } else if (encoded_len == -1) {\n        DPRINTF(\"Overflow\\n\");\n        acct_info.xbzrle_overflows++;\n        if (!last_stage) {\n            memcpy(prev_cached_page, *current_data, TARGET_PAGE_SIZE);\n            *current_data = prev_cached_page;\n        }\n        return -1;\n    }\n\n    if (!last_stage) {\n        memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);\n    }\n\n    bytes_sent = save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_XBZRLE);\n    qemu_put_byte(f, ENCODING_FLAG_XBZRLE);\n    qemu_put_be16(f, encoded_len);\n    qemu_put_buffer(f, XBZRLE.encoded_buf, encoded_len);\n    bytes_sent += encoded_len + 1 + 2;\n    acct_info.xbzrle_pages++;\n    acct_info.xbzrle_bytes += bytes_sent;\n\n    return bytes_sent;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187220, "func": "static int auto_claim(struct libusb_transfer *transfer, int *interface_number, int api_type)\n{\n\tstruct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(\n\t\ttransfer->dev_handle);\n\tstruct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);\n\tint current_interface = *interface_number;\n\tint r = LIBUSB_SUCCESS;\n \n \tswitch(api_type) {\n \tcase USB_API_WINUSBX:\n\tcase USB_API_HID:\n \t\tbreak;\n \tdefault:\n \t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\n\tusbi_mutex_lock(&autoclaim_lock);\n\tif (current_interface < 0)\t\n\t{\n\t\tfor (current_interface=0; current_interface<USB_MAXINTERFACES; current_interface++) {\n\t\t\tif ( (priv->usb_interface[current_interface].apib->id == api_type)\n\t\t\t  && (libusb_claim_interface(transfer->dev_handle, current_interface) == LIBUSB_SUCCESS) ) {\n\t\t\t\tusbi_dbg(\"auto-claimed interface %d for control request\", current_interface);\n\t\t\t\tif (handle_priv->autoclaim_count[current_interface] != 0) {\n\t\t\t\t\tusbi_warn(ctx, \"program assertion failed - autoclaim_count was nonzero\");\n\t\t\t\t}\n\t\t\t\thandle_priv->autoclaim_count[current_interface]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (current_interface == USB_MAXINTERFACES) {\n\t\t\tusbi_err(ctx, \"could not auto-claim any interface\");\n\t\t\tr = LIBUSB_ERROR_NOT_FOUND;\n\t\t}\n\t} else {\n\t\tif (handle_priv->autoclaim_count[current_interface] != 0) {\n\t\t\thandle_priv->autoclaim_count[current_interface]++;\n\t\t}\n\t}\n\tusbi_mutex_unlock(&autoclaim_lock);\n\n\t*interface_number = current_interface;\n\treturn r;\n\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 7647, "func": "static int proxy_remove(FsContext *ctx, const char *path)\n{\n    int retval;\n    V9fsString name;\n    v9fs_string_init(&name);\n    v9fs_string_sprintf(&name, \"%s\", path);\n    retval = v9fs_request(ctx->private, T_REMOVE, NULL, &name);\n    v9fs_string_free(&name);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8247, "func": "static int ehci_init_transfer(EHCIPacket *p)\n{\n    uint32_t cpage, offset, bytes, plen;\n    dma_addr_t page;\n\n    cpage  = get_field(p->qtd.token, QTD_TOKEN_CPAGE);\n    bytes  = get_field(p->qtd.token, QTD_TOKEN_TBYTES);\n    offset = p->qtd.bufptr[0] & ~QTD_BUFPTR_MASK;\n    qemu_sglist_init(&p->sgl, p->queue->ehci->device, 5, p->queue->ehci->as);\n\n    while (bytes > 0) {\n        if (cpage > 4) {\n            fprintf(stderr, \"cpage out of range (%d)\\n\", cpage);\n            return -1;\n        }\n\n        page  = p->qtd.bufptr[cpage] & QTD_BUFPTR_MASK;\n        page += offset;\n        plen  = bytes;\n        if (plen > 4096 - offset) {\n            plen = 4096 - offset;\n            offset = 0;\n            cpage++;\n        }\n\n        qemu_sglist_add(&p->sgl, page, plen);\n        bytes -= plen;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186850, "func": "void MojoVideoEncodeAccelerator::Encode(const scoped_refptr<VideoFrame>& frame,\n                                        bool force_keyframe) {\n  DVLOG(2) << __func__ << \" tstamp=\" << frame->timestamp();\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK_EQ(PIXEL_FORMAT_I420, frame->format());\n  DCHECK_EQ(VideoFrame::STORAGE_SHMEM, frame->storage_type());\n  DCHECK(frame->shared_memory_handle().IsValid());\n\n  const size_t allocation_size = frame->shared_memory_handle().GetSize();\n \n  mojo::ScopedSharedBufferHandle handle =\n      mojo::WrapSharedMemoryHandle(frame->shared_memory_handle().Duplicate(),\n                                   allocation_size, true \n);\n \n   const size_t y_offset = frame->shared_memory_offset();\n   const size_t u_offset = y_offset + frame->data(VideoFrame::kUPlane) -\n                          frame->data(VideoFrame::kYPlane);\n  const size_t v_offset = y_offset + frame->data(VideoFrame::kVPlane) -\n                          frame->data(VideoFrame::kYPlane);\n  scoped_refptr<MojoSharedBufferVideoFrame> mojo_frame =\n      MojoSharedBufferVideoFrame::Create(\n          frame->format(), frame->coded_size(), frame->visible_rect(),\n          frame->natural_size(), std::move(handle), allocation_size, y_offset,\n          u_offset, v_offset, frame->stride(VideoFrame::kYPlane),\n          frame->stride(VideoFrame::kUPlane),\n          frame->stride(VideoFrame::kVPlane), frame->timestamp());\n\n  DCHECK(vea_.is_bound());\n  vea_->Encode(mojo_frame, force_keyframe,\n               base::Bind(&KeepVideoFrameAlive, frame));\n}\n", "target": 1, "flaw_line_index": "16,17,18"}
{"idx": 7592, "func": "static uint64_t cirrus_mmio_read(void *opaque, hwaddr addr,\n                                 unsigned size)\n{\n    CirrusVGAState *s = opaque;\n\n    if (addr >= 0x100) {\n        return cirrus_mmio_blt_read(s, addr - 0x100);\n    } else {\n        return cirrus_vga_ioport_read(s, addr + 0x10, size);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186420, "func": "DevToolsUIBindings::DevToolsUIBindings(content::WebContents* web_contents)\n    : profile_(Profile::FromBrowserContext(web_contents->GetBrowserContext())),\n      android_bridge_(DevToolsAndroidBridge::Factory::GetForProfile(profile_)),\n      web_contents_(web_contents),\n      delegate_(new DefaultBindingsDelegate(web_contents_)),\n      devices_updates_enabled_(false),\n      frontend_loaded_(false),\n      reloading_(false),\n      weak_factory_(this) {\n  g_instances.Get().push_back(this);\n  frontend_contents_observer_.reset(new FrontendWebContentsObserver(this));\n  web_contents_->GetMutableRendererPrefs()->can_accept_load_drops = false;\n\n  file_helper_.reset(new DevToolsFileHelper(web_contents_, profile_, this));\n  file_system_indexer_ = new DevToolsFileSystemIndexer();\n  extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n      web_contents_);\n\n   embedder_message_dispatcher_.reset(\n       DevToolsEmbedderMessageDispatcher::CreateForDevToolsFrontend(this));\n  frontend_host_.reset(content::DevToolsFrontendHost::Create(\n      web_contents_->GetMainFrame(),\n      base::Bind(&DevToolsUIBindings::HandleMessageFromDevToolsFrontend,\n                 base::Unretained(this))));\n }\n", "target": 1, "flaw_line_index": "22,23,24,25"}
{"idx": 187254, "func": "  AccessType GetExtensionAccess(const Extension* extension,\n                                 const GURL& url,\n                                 int tab_id) {\n     bool allowed_script = IsAllowedScript(extension, url, tab_id);\n    bool allowed_capture =\n        extension->permissions_data()->CanCaptureVisiblePage(tab_id, nullptr);\n \n     if (allowed_script && allowed_capture)\n       return ALLOWED_SCRIPT_AND_CAPTURE;\n    if (allowed_script)\n      return ALLOWED_SCRIPT_ONLY;\n    if (allowed_capture)\n      return ALLOWED_CAPTURE_ONLY;\n    return DISALLOWED;\n  }\n", "target": 1, "flaw_line_index": "5,6"}
{"idx": 187211, "func": "static int _hid_get_config_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n{\n\tchar num_endpoints = 0;\n\tsize_t config_total_len = 0;\n\tchar tmp[HID_MAX_CONFIG_DESC_SIZE];\n\tstruct libusb_config_descriptor *cd;\n\tstruct libusb_interface_descriptor *id;\n\tstruct libusb_hid_descriptor *hd;\n\tstruct libusb_endpoint_descriptor *ed;\n\tsize_t tmp_size;\n\tif (dev->input_report_size)\n\t\tnum_endpoints++;\n\tif (dev->output_report_size)\n\t\tnum_endpoints++;\n\tconfig_total_len = LIBUSB_DT_CONFIG_SIZE + LIBUSB_DT_INTERFACE_SIZE\n\t\t+ LIBUSB_DT_HID_SIZE + num_endpoints * LIBUSB_DT_ENDPOINT_SIZE;\n\tcd = (struct libusb_config_descriptor *)tmp;\n\tid = (struct libusb_interface_descriptor *)(tmp + LIBUSB_DT_CONFIG_SIZE);\n\thd = (struct libusb_hid_descriptor *)(tmp + LIBUSB_DT_CONFIG_SIZE\n\t\t+ LIBUSB_DT_INTERFACE_SIZE);\n\ted = (struct libusb_endpoint_descriptor *)(tmp + LIBUSB_DT_CONFIG_SIZE\n\t\t+ LIBUSB_DT_INTERFACE_SIZE\n\t\t+ LIBUSB_DT_HID_SIZE);\n\tcd->bLength = LIBUSB_DT_CONFIG_SIZE;\n\tcd->bDescriptorType = LIBUSB_DT_CONFIG;\n\tcd->wTotalLength = (uint16_t) config_total_len;\n\tcd->bNumInterfaces = 1;\n\tcd->bConfigurationValue = 1;\n\tcd->iConfiguration = 0;\n\tcd->bmAttributes = 1 << 7; \n\tcd->MaxPower = 50;\n\tid->bLength = LIBUSB_DT_INTERFACE_SIZE;\n\tid->bDescriptorType = LIBUSB_DT_INTERFACE;\n\tid->bInterfaceNumber = 0;\n\tid->bAlternateSetting = 0;\n\tid->bNumEndpoints = num_endpoints;\n\tid->bInterfaceClass = 3;\n\tid->bInterfaceSubClass = 0;\n\tid->bInterfaceProtocol = 0;\n\tid->iInterface = 0;\n\ttmp_size = LIBUSB_DT_HID_SIZE;\n\t_hid_get_hid_descriptor(dev, hd, &tmp_size);\n\tif (dev->input_report_size) {\n\t\ted->bLength = LIBUSB_DT_ENDPOINT_SIZE;\n\t\ted->bDescriptorType = LIBUSB_DT_ENDPOINT;\n\t\ted->bEndpointAddress = HID_IN_EP;\n\t\ted->bmAttributes = 3;\n\t\ted->wMaxPacketSize = dev->input_report_size - 1;\n\t\ted->bInterval = 10;\n\t\ted = (struct libusb_endpoint_descriptor *)((char*)ed + LIBUSB_DT_ENDPOINT_SIZE);\n\t}\n\tif (dev->output_report_size) {\n\t\ted->bLength = LIBUSB_DT_ENDPOINT_SIZE;\n\t\ted->bDescriptorType = LIBUSB_DT_ENDPOINT;\n\t\ted->bEndpointAddress = HID_OUT_EP;\n\t\ted->bmAttributes = 3;\n\t\ted->wMaxPacketSize = dev->output_report_size - 1;\n\t\ted->bInterval = 10;\n\t}\n\tif (*size > config_total_len)\n\t\t*size = config_total_len;\n\tmemcpy(data, tmp, *size);\n\treturn LIBUSB_COMPLETED;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64"}
{"idx": 7919, "func": "static void ctryfinally(JF, js_Ast *trystm, js_Ast *finallystm)\n{\n\tint L1;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tcstm(J, F, finallystm); \n\t\temit(J, F, OP_THROW); \n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tcstm(J, F, finallystm);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186770, "func": " bool NavigateToUrlWithEdge(const base::string16& url) {\n   base::string16 protocol_url = L\"microsoft-edge:\" + url;\n   SHELLEXECUTEINFO info = { sizeof(info) };\n  info.fMask = SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n   info.lpVerb = L\"open\";\n   info.lpFile = protocol_url.c_str();\n   info.nShow = SW_SHOWNORMAL;\n  if (::ShellExecuteEx(&info))\n    return true;\n  PLOG(ERROR) << \"Failed to launch Edge for uninstall survey\";\n  return false;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8080, "func": "void Gfx::doImage(Object *ref, Stream *str, GBool inlineImg) {\n  Dict *dict, *maskDict;\n  int width, height;\n  int bits, maskBits;\n  GBool interpolate;\n  StreamColorSpaceMode csMode;\n  GBool mask;\n  GBool invert;\n  GfxColorSpace *colorSpace, *maskColorSpace;\n  GfxImageColorMap *colorMap, *maskColorMap;\n  Object maskObj, smaskObj;\n  GBool haveColorKeyMask, haveExplicitMask, haveSoftMask;\n  int maskColors[2*gfxColorMaxComps];\n  int maskWidth, maskHeight;\n  GBool maskInvert;\n  GBool maskInterpolate;\n  Stream *maskStr;\n  Object obj1, obj2;\n  int i;\n\n  bits = 0;\n  csMode = streamCSNone;\n  str->getImageParams(&bits, &csMode);\n\n  dict = str->getDict();\n\n  dict->lookup(\"Width\", &obj1);\n  if (obj1.isNull()) {\n    obj1.free();\n    dict->lookup(\"W\", &obj1);\n  }\n  if (obj1.isInt())\n    width = obj1.getInt();\n  else if (obj1.isReal())\n    width = (int)obj1.getReal();\n  else\n    goto err2;\n  obj1.free();\n  dict->lookup(\"Height\", &obj1);\n  if (obj1.isNull()) {\n    obj1.free();\n    dict->lookup(\"H\", &obj1);\n  }\n  if (obj1.isInt())\n    height = obj1.getInt();\n  else if (obj1.isReal())\n    height = (int)obj1.getReal();\n  else\n    goto err2;\n  obj1.free();\n\n  if (width < 1 || height < 1)\n    goto err1;\n\n  dict->lookup(\"Interpolate\", &obj1);\n  if (obj1.isNull()) {\n    obj1.free();\n    dict->lookup(\"I\", &obj1);\n  }\n  if (obj1.isBool())\n    interpolate = obj1.getBool();\n  else\n    interpolate = gFalse;\n  obj1.free();\n  maskInterpolate = gFalse;\n\n  dict->lookup(\"ImageMask\", &obj1);\n  if (obj1.isNull()) {\n    obj1.free();\n    dict->lookup(\"IM\", &obj1);\n  }\n  mask = gFalse;\n  if (obj1.isBool())\n    mask = obj1.getBool();\n  else if (!obj1.isNull())\n    goto err2;\n  obj1.free();\n\n  if (bits == 0) {\n    dict->lookup(\"BitsPerComponent\", &obj1);\n    if (obj1.isNull()) {\n      obj1.free();\n      dict->lookup(\"BPC\", &obj1);\n    }\n    if (obj1.isInt()) {\n      bits = obj1.getInt();\n    } else if (mask) {\n      bits = 1;\n    } else {\n      goto err2;\n    }\n    obj1.free();\n  }\n\n  if (mask) {\n\n    if (bits != 1)\n      goto err1;\n    invert = gFalse;\n    dict->lookup(\"Decode\", &obj1);\n    if (obj1.isNull()) {\n      obj1.free();\n      dict->lookup(\"D\", &obj1);\n    }\n    if (obj1.isArray()) {\n      obj1.arrayGet(0, &obj2);\n      if (obj2.isNum() && obj2.getNum() >= 0.9)\n\tinvert = gTrue;\n      obj2.free();\n    } else if (!obj1.isNull()) {\n      goto err2;\n    }\n    obj1.free();\n\n    if (!contentIsHidden()) {\n\tout->drawImageMask(state, ref, str, width, height, invert, interpolate, inlineImg);\n      if (out->fillMaskCSPattern(state)) {\n        maskHaveCSPattern = gTrue;\n        doPatternFill(gTrue);\n        out->endMaskClip(state);\n        maskHaveCSPattern = gFalse;\n      }\n    }\n  } else {\n\n    dict->lookup(\"ColorSpace\", &obj1);\n    if (obj1.isNull()) {\n      obj1.free();\n      dict->lookup(\"CS\", &obj1);\n    }\n    if (obj1.isName() && inlineImg) {\n      res->lookupColorSpace(obj1.getName(), &obj2);\n      if (!obj2.isNull()) {\n\tobj1.free();\n\tobj1 = obj2;\n      } else {\n\tobj2.free();\n      }\n    }\n    if (!obj1.isNull()) {\n      colorSpace = GfxColorSpace::parse(&obj1, this);\n    } else if (csMode == streamCSDeviceGray) {\n      colorSpace = new GfxDeviceGrayColorSpace();\n    } else if (csMode == streamCSDeviceRGB) {\n      colorSpace = new GfxDeviceRGBColorSpace();\n    } else if (csMode == streamCSDeviceCMYK) {\n      colorSpace = new GfxDeviceCMYKColorSpace();\n    } else {\n      colorSpace = NULL;\n    }\n    obj1.free();\n    if (!colorSpace) {\n      goto err1;\n    }\n    dict->lookup(\"Decode\", &obj1);\n    if (obj1.isNull()) {\n      obj1.free();\n      dict->lookup(\"D\", &obj1);\n    }\n    colorMap = new GfxImageColorMap(bits, &obj1, colorSpace);\n    obj1.free();\n    if (!colorMap->isOk()) {\n      delete colorMap;\n      goto err1;\n    }\n\n    haveColorKeyMask = haveExplicitMask = haveSoftMask = gFalse;\n    maskStr = NULL; \n    maskWidth = maskHeight = 0; \n    maskInvert = gFalse; \n    maskColorMap = NULL; \n    dict->lookup(\"Mask\", &maskObj);\n    dict->lookup(\"SMask\", &smaskObj);\n    if (smaskObj.isStream()) {\n      if (inlineImg) {\n\tgoto err1;\n      }\n      maskStr = smaskObj.getStream();\n      maskDict = smaskObj.streamGetDict();\n      maskDict->lookup(\"Width\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"W\", &obj1);\n      }\n      if (!obj1.isInt()) {\n\tgoto err2;\n      }\n      maskWidth = obj1.getInt();\n      obj1.free();\n      maskDict->lookup(\"Height\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"H\", &obj1);\n      }\n      if (!obj1.isInt()) {\n\tgoto err2;\n      }\n      maskHeight = obj1.getInt();\n      obj1.free();\n      maskDict->lookup(\"Interpolate\", &obj1);\n      if (obj1.isNull()) {\n        obj1.free();\n        maskDict->lookup(\"I\", &obj1);\n      }\n      if (obj1.isBool())\n        maskInterpolate = obj1.getBool();\n      else\n        maskInterpolate = gFalse;\n      obj1.free();\n      maskDict->lookup(\"BitsPerComponent\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"BPC\", &obj1);\n      }\n      if (!obj1.isInt()) {\n\tgoto err2;\n      }\n      maskBits = obj1.getInt();\n      obj1.free();\n      maskDict->lookup(\"ColorSpace\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"CS\", &obj1);\n      }\n      if (obj1.isName()) {\n\tres->lookupColorSpace(obj1.getName(), &obj2);\n\tif (!obj2.isNull()) {\n\t  obj1.free();\n\t  obj1 = obj2;\n\t} else {\n\t  obj2.free();\n\t}\n      }\n      maskColorSpace = GfxColorSpace::parse(&obj1, this);\n      obj1.free();\n      if (!maskColorSpace || maskColorSpace->getMode() != csDeviceGray) {\n\tgoto err1;\n      }\n      maskDict->lookup(\"Decode\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"D\", &obj1);\n      }\n      maskColorMap = new GfxImageColorMap(maskBits, &obj1, maskColorSpace);\n      obj1.free();\n      if (!maskColorMap->isOk()) {\n\tdelete maskColorMap;\n\tgoto err1;\n      }\n      haveSoftMask = gTrue;\n    } else if (maskObj.isArray()) {\n      for (i = 0;\n\t   i < maskObj.arrayGetLength() && i < 2*gfxColorMaxComps;\n\t   ++i) {\n\tmaskObj.arrayGet(i, &obj1);\n\tif (obj1.isInt()) {\n\t  maskColors[i] = obj1.getInt();\n\t} else if (obj1.isReal()) {\n\t  error(-1, \"Mask entry should be an integer but it's a real, trying to use it\");\n\t  maskColors[i] = (int) obj1.getReal();\n\t} else {\n\t  error(-1, \"Mask entry should be an integer but it's of type %d\", obj1.getType());\n\t  obj1.free();\n\t  goto err1;\n\t}\n\tobj1.free();\n      }\n      haveColorKeyMask = gTrue;\n    } else if (maskObj.isStream()) {\n      if (inlineImg) {\n\tgoto err1;\n      }\n      maskStr = maskObj.getStream();\n      maskDict = maskObj.streamGetDict();\n      maskDict->lookup(\"Width\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"W\", &obj1);\n      }\n      if (!obj1.isInt()) {\n\tgoto err2;\n      }\n      maskWidth = obj1.getInt();\n      obj1.free();\n      maskDict->lookup(\"Height\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"H\", &obj1);\n      }\n      if (!obj1.isInt()) {\n\tgoto err2;\n      }\n      maskHeight = obj1.getInt();\n      obj1.free();\n      maskDict->lookup(\"Interpolate\", &obj1);\n      if (obj1.isNull()) {\n        obj1.free();\n\tmaskDict->lookup(\"I\", &obj1);\n      }\n      if (obj1.isBool())\n        maskInterpolate = obj1.getBool();\n      else\n        maskInterpolate = gFalse;\n      obj1.free();\n      maskDict->lookup(\"ImageMask\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"IM\", &obj1);\n      }\n      if (!obj1.isBool() || !obj1.getBool()) {\n\tgoto err2;\n      }\n      obj1.free();\n      maskInvert = gFalse;\n      maskDict->lookup(\"Decode\", &obj1);\n      if (obj1.isNull()) {\n\tobj1.free();\n\tmaskDict->lookup(\"D\", &obj1);\n      }\n      if (obj1.isArray()) {\n\tobj1.arrayGet(0, &obj2);\n\tif (obj2.isNum() && obj2.getNum() >= 0.9) {\n\t  maskInvert = gTrue;\n\t}\n\tobj2.free();\n      } else if (!obj1.isNull()) {\n\tgoto err2;\n      }\n      obj1.free();\n      haveExplicitMask = gTrue;\n    }\n\n    if (haveSoftMask) {\n      if (!contentIsHidden()) {\n        out->drawSoftMaskedImage(state, ref, str, width, height, colorMap, interpolate,\n\t\t\t\t maskStr, maskWidth, maskHeight, maskColorMap, maskInterpolate);\n      }\n      delete maskColorMap;\n    } else if (haveExplicitMask && !contentIsHidden ()) {\n      out->drawMaskedImage(state, ref, str, width, height, colorMap, interpolate,\n\t\t\t   maskStr, maskWidth, maskHeight, maskInvert, maskInterpolate);\n    } else if (!contentIsHidden()) {\n      out->drawImage(state, ref, str, width, height, colorMap, interpolate,\n\t\t     haveColorKeyMask ? maskColors : (int *)NULL, inlineImg);\n    }\n    delete colorMap;\n\n    maskObj.free();\n    smaskObj.free();\n  }\n\n  if ((i = width * height) > 1000) {\n    i = 1000;\n  }\n  updateLevel += i;\n\n  return;\n\n err2:\n  obj1.free();\n err1:\n  error(getPos(), \"Bad image parameters\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8182, "func": "void Gfx::saveState() {\n  out->saveState(state);\n  state = state->save();\n  stackHeight++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7516, "func": "  tt_glyphzone_new( FT_Memory     memory,\n                    FT_UShort     maxPoints,\n                    FT_Short      maxContours,\n                    TT_GlyphZone  zone )\n  {\n    FT_Error  error;\n\n\n    FT_ZERO( zone );\n    zone->memory = memory;\n\n    if ( FT_NEW_ARRAY( zone->org,      maxPoints   ) ||\n         FT_NEW_ARRAY( zone->cur,      maxPoints   ) ||\n         FT_NEW_ARRAY( zone->orus,     maxPoints   ) ||\n         FT_NEW_ARRAY( zone->tags,     maxPoints   ) ||\n         FT_NEW_ARRAY( zone->contours, maxContours ) )\n    {\n      tt_glyphzone_done( zone );\n    }\n    else\n    {\n      zone->max_points   = maxPoints;\n      zone->max_contours = maxContours;\n    }\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186389, "func": "DataReductionProxyIOData::DataReductionProxyIOData(\n    Client client,\n    PrefService* prefs,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,\n    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,\n    bool enabled,\n    const std::string& user_agent,\n    const std::string& channel)\n    : client_(client),\n      network_connection_tracker_(network_connection_tracker),\n      io_task_runner_(io_task_runner),\n      ui_task_runner_(ui_task_runner),\n      enabled_(enabled),\n      channel_(channel),\n      effective_connection_type_(net::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {\n  DCHECK(io_task_runner_);\n  DCHECK(ui_task_runner_);\n  configurator_.reset(new DataReductionProxyConfigurator());\n  configurator_->SetConfigUpdatedCallback(base::BindRepeating(\n      &DataReductionProxyIOData::OnProxyConfigUpdated, base::Unretained(this)));\n  DataReductionProxyMutableConfigValues* raw_mutable_config = nullptr;\n    std::unique_ptr<DataReductionProxyMutableConfigValues> mutable_config =\n        std::make_unique<DataReductionProxyMutableConfigValues>();\n    raw_mutable_config = mutable_config.get();\n    config_.reset(new DataReductionProxyConfig(\n        io_task_runner, ui_task_runner, network_connection_tracker_,\n        std::move(mutable_config), configurator_.get()));\n    request_options_.reset(\n        new DataReductionProxyRequestOptions(client_, config_.get()));\n    request_options_->Init();\n    request_options_->SetUpdateHeaderCallback(base::BindRepeating(\n        &DataReductionProxyIOData::UpdateProxyRequestHeaders,\n        base::Unretained(this)));\n\n    config_client_.reset(new DataReductionProxyConfigServiceClient(\n        GetBackoffPolicy(), request_options_.get(), raw_mutable_config,\n        config_.get(), this, network_connection_tracker_,\n        base::BindRepeating(&DataReductionProxyIOData::StoreSerializedConfig,\n                            base::Unretained(this))));\n \n     network_properties_manager_.reset(new NetworkPropertiesManager(\n         base::DefaultClock::GetInstance(), prefs, ui_task_runner_));\n}\n", "target": 1, "flaw_line_index": "42,43,44,45"}
{"idx": 7617, "func": "static void isa_cirrus_vga_realizefn(DeviceState *dev, Error **errp)\n{\n    ISADevice *isadev = ISA_DEVICE(dev);\n    ISACirrusVGAState *d = ISA_CIRRUS_VGA(dev);\n    VGACommonState *s = &d->cirrus_vga.vga;\n\n    if (s->vram_size_mb != 4 && s->vram_size_mb != 8 &&\n        s->vram_size_mb != 16) {\n        error_setg(errp, \"Invalid cirrus_vga ram size '%u'\",\n                   s->vram_size_mb);\n        return;\n    }\n    vga_common_init(s, OBJECT(dev), true);\n    cirrus_init_common(&d->cirrus_vga, OBJECT(dev), CIRRUS_ID_CLGD5430, 0,\n                       isa_address_space(isadev),\n                       isa_address_space_io(isadev));\n    s->con = graphic_console_init(dev, 0, s->hw_ops, s);\n    rom_add_vga(VGABIOS_CIRRUS_FILENAME);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186632, "func": "void WebLocalFrameImpl::SetCommittedFirstRealLoad() {\n   DCHECK(GetFrame());\n   GetFrame()->Loader().StateMachine()->AdvanceTo(\n       FrameLoaderStateMachine::kCommittedMultipleRealLoads);\n  GetFrame()->DidSendResourceTimingInfoToParent();\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 7566, "func": "static void cirrus_bitblt_fill_nop(CirrusVGAState *s,\n                                   uint8_t *dst,\n                                   int dstpitch, int bltwidth,int bltheight)\n{\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8017, "func": "char *vnc_display_local_addr(DisplayState *ds)\n{\n    VncDisplay *vs = vnc_display;\n    \n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186502, "func": "error::Error GLES2DecoderPassthroughImpl::DoEndQueryEXT(GLenum target,\n                                                        uint32_t submit_count) {\n  if (IsEmulatedQueryTarget(target)) {\n    auto active_query_iter = active_queries_.find(target);\n    if (active_query_iter == active_queries_.end()) {\n      InsertError(GL_INVALID_OPERATION, \"No active query on target.\");\n      return error::kNoError;\n    }\n    if (target == GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM &&\n        !pending_read_pixels_.empty()) {\n      GLuint query_service_id = active_query_iter->second.service_id;\n      pending_read_pixels_.back().waiting_async_pack_queries.insert(\n          query_service_id);\n    }\n  } else {\n    CheckErrorCallbackState();\n\n    api()->glEndQueryFn(target);\n\n    if (CheckErrorCallbackState()) {\n      return error::kNoError;\n    }\n  }\n\n  DCHECK(active_queries_.find(target) != active_queries_.end());\n  ActiveQuery active_query = std::move(active_queries_[target]);\n  active_queries_.erase(target);\n\n  PendingQuery pending_query;\n  pending_query.target = target;\n  pending_query.service_id = active_query.service_id;\n  pending_query.shm = std::move(active_query.shm);\n  pending_query.sync = active_query.sync;\n  pending_query.submit_count = submit_count;\n  switch (target) {\n    case GL_COMMANDS_COMPLETED_CHROMIUM:\n      pending_query.commands_completed_fence = gl::GLFence::Create();\n      break;\n\n    case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n      pending_query.buffer_shadow_update_fence = gl::GLFence::Create();\n      pending_query.buffer_shadow_updates = std::move(buffer_shadow_updates_);\n       buffer_shadow_updates_.clear();\n       break;\n \n     default:\n       break;\n   }\n  pending_queries_.push_back(std::move(pending_query));\n  return ProcessQueries(false);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186568, "func": " void AcceleratedStaticBitmapImage::CreateImageFromMailboxIfNeeded() {\n   if (texture_holder_->IsSkiaTextureHolder())\n     return;\n   texture_holder_ =\n      std::make_unique<SkiaTextureHolder>(std::move(texture_holder_));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186875, "func": "void PrintMsg_Print_Params::Reset() {\n  page_size = gfx::Size();\n  content_size = gfx::Size();\n  printable_area = gfx::Rect();\n  margin_top = 0;\n  margin_left = 0;\n  dpi = 0;\n  scale_factor = 1.0f;\n  rasterize_pdf = false;\n  document_cookie = 0;\n  selection_only = false;\n  supports_alpha_blend = false;\n  preview_ui_id = -1;\n  preview_request_id = 0;\n  is_first_request = false;\n  print_scaling_option = blink::kWebPrintScalingOptionSourceSize;\n  print_to_pdf = false;\n   display_header_footer = false;\n   title = base::string16();\n   url = base::string16();\n   should_print_backgrounds = false;\n   printed_doc_type = printing::SkiaDocumentType::PDF;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186606, "func": "void UrlData::set_has_opaque_data(bool has_opaque_data) {\n  if (has_opaque_data_)\n     return;\n  has_opaque_data_ = has_opaque_data;\n }\n", "target": 1, "flaw_line_index": "2,4"}
{"idx": 7520, "func": "  tt_size_init_bytecode( FT_Size  ftsize,\n                         FT_Bool  pedantic )\n  {\n    FT_Error   error;\n    TT_Size    size = (TT_Size)ftsize;\n    TT_Face    face = (TT_Face)ftsize->face;\n    FT_Memory  memory = face->root.memory;\n\n    FT_UShort       n_twilight;\n    TT_MaxProfile*  maxp = &face->max_profile;\n\n\n    FT_FREE( size->function_defs );\n    FT_FREE( size->instruction_defs );\n    FT_FREE( size->cvt );\n    FT_FREE( size->storage );\n\n    if ( size->context )\n      TT_Done_Context( size->context );\n    tt_glyphzone_done( &size->twilight );\n\n    size->bytecode_ready = -1;\n    size->cvt_ready      = -1;\n\n    size->context = TT_New_Context( (TT_Driver)face->root.driver );\n\n    size->max_function_defs    = maxp->maxFunctionDefs;\n    size->max_instruction_defs = maxp->maxInstructionDefs;\n\n    size->num_function_defs    = 0;\n    size->num_instruction_defs = 0;\n\n    size->max_func = 0;\n    size->max_ins  = 0;\n\n    size->cvt_size     = face->cvt_size;\n    size->storage_size = maxp->maxStorage;\n\n    {\n      TT_Size_Metrics*  metrics = &size->ttmetrics;\n\n\n      metrics->rotated   = FALSE;\n      metrics->stretched = FALSE;\n\n      metrics->compensations[0] = 0;   \n      metrics->compensations[1] = 0;   \n      metrics->compensations[2] = 0;   \n      metrics->compensations[3] = 0;   \n    }\n\n    if ( FT_NEW_ARRAY( size->function_defs,    size->max_function_defs    ) ||\n         FT_NEW_ARRAY( size->instruction_defs, size->max_instruction_defs ) ||\n         FT_NEW_ARRAY( size->cvt,              size->cvt_size             ) ||\n         FT_NEW_ARRAY( size->storage,          size->storage_size         ) )\n      goto Exit;\n\n    n_twilight = maxp->maxTwilightPoints;\n\n    n_twilight += 4;\n\n    error = tt_glyphzone_new( memory, n_twilight, 0, &size->twilight );\n    if ( error )\n      goto Exit;\n\n    size->twilight.n_points = n_twilight;\n\n    size->GS = tt_default_graphics_state;\n\n    {\n      FT_Library  library = face->root.driver->root.library;\n\n\n      face->interpreter = (TT_Interpreter)\n                            library->debug_hooks[FT_DEBUG_HOOK_TRUETYPE];\n      if ( !face->interpreter )\n        face->interpreter = (TT_Interpreter)TT_RunIns;\n    }\n\n\n    error = tt_size_run_fpgm( size, pedantic );\n    return error;\n\n  Exit:\n    if ( error )\n      tt_size_done_bytecode( ftsize );\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7958, "func": "static void client_cut_text(VncState *vs, size_t len, uint8_t *text)\n{\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186616, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u10d5\u1012] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187237, "func": "static int set_composite_interface(struct libusb_context* ctx, struct libusb_device* dev,\n\t\t\t\t\t\t\tchar* dev_interface_path, char* device_id, int api, int sub_api)\n{\n\tunsigned i;\n\tstruct windows_device_priv *priv = _device_priv(dev);\n\tint interface_number;\n\n\tif (priv->apib->id != USB_API_COMPOSITE) {\n\t\tusbi_err(ctx, \"program assertion failed: '%s' is not composite\", device_id);\n\t\treturn LIBUSB_ERROR_NO_DEVICE;\n\t}\n\n\tinterface_number = 0;\n\tfor (i=0; device_id[i] != 0; ) {\n\t\tif ( (device_id[i++] == 'M') && (device_id[i++] == 'I')\n\t\t  && (device_id[i++] == '_') ) {\n\t\t\tinterface_number = (device_id[i++] - '0')*10;\n\t\t\tinterface_number += device_id[i] - '0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (device_id[i] == 0) {\n\t\tusbi_warn(ctx, \"failure to read interface number for %s. Using default value %d\",\n\t\t\tdevice_id, interface_number);\n \t}\n \n \tif (priv->usb_interface[interface_number].path != NULL) {\n\t\tif (api == USB_API_HID) {\n\t\t\tusbi_dbg(\"interface[%d] already set - ignoring HID collection: %s\",\n\t\t\t\tinterface_number, device_id);\n\t\t\treturn LIBUSB_ERROR_ACCESS;\n\t\t}\n \t}\n \n \tusbi_dbg(\"interface[%d] = %s\", interface_number, dev_interface_path);\n \tpriv->usb_interface[interface_number].path = dev_interface_path;\n \tpriv->usb_interface[interface_number].apib = &usb_api_backend[api];\n \tpriv->usb_interface[interface_number].sub_api = sub_api;\n\tif ((api == USB_API_HID) && (priv->hid == NULL)) {\n\t\tpriv->hid = (struct hid_device_priv*) calloc(1, sizeof(struct hid_device_priv));\n\t\tif (priv->hid == NULL)\n\t\t\treturn LIBUSB_ERROR_NO_MEM;\n\t}\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "32,33,34,35,36,37,38,46,47"}
{"idx": 187209, "func": " void FileReaderLoader::OnCalculatedSize(uint64_t total_size,\n                                         uint64_t expected_content_size) {\n   OnStartLoading(expected_content_size);\n   if (expected_content_size == 0) {\n     received_all_data_ = true;\n     return;\n  }\n\n  if (IsSyncLoad()) {\n    OnDataPipeReadable(MOJO_RESULT_OK);\n  } else {\n    handle_watcher_.Watch(\n        consumer_handle_.get(), MOJO_HANDLE_SIGNAL_READABLE,\n        WTF::BindRepeating(&FileReaderLoader::OnDataPipeReadable,\n                           WTF::Unretained(this)));\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186926, "func": " xmlBufCreateStatic(void *mem, size_t size) {\n     xmlBufPtr ret;\n \n    if ((mem == NULL) || (size == 0))\n         return(NULL);\n \n     ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));\n    if (ret == NULL) {\n\txmlBufMemoryError(NULL, \"creating buffer\");\n        return(NULL);\n    }\n    if (size < INT_MAX) {\n        ret->compat_use = size;\n        ret->compat_size = size;\n    } else {\n        ret->compat_use = INT_MAX;\n        ret->compat_size = INT_MAX;\n    }\n    ret->use = size;\n    ret->size = size;\n    ret->alloc = XML_BUFFER_ALLOC_IMMUTABLE;\n    ret->content = (xmlChar *) mem;\n    ret->error = 0;\n    ret->buffer = NULL;\n    return(ret);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8230, "func": "static void v9fs_remove(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_remove(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out_err;\n    }\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_remove(pdu, &fidp->path);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    clunk_fid(pdu->s, fidp->fid);\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8063, "func": "FoFiType1 *FoFiType1::make(char *fileA, int lenA) {\n  return new FoFiType1(fileA, lenA, gFalse);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7688, "func": "static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n                               char *buf, size_t bufsz)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = readlinkat(fd, \"\", buf, bufsz);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8003, "func": "static void vnc_client_write_locked(void *opaque)\n{\n    VncState *vs = opaque;\n\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        !vs->sasl.waitWriteSSF) {\n        vnc_client_write_sasl(vs);\n    } else\n#endif \n    {\n#ifdef CONFIG_VNC_WS\n        if (vs->encode_ws) {\n            vnc_client_write_ws(vs);\n        } else\n#endif \n        {\n            vnc_client_write_plain(vs);\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7936, "func": "static int isloop(enum js_AstType T)\n{\n\treturn T == STM_DO || T == STM_WHILE ||\n\t\tT == STM_FOR || T == STM_FOR_VAR ||\n\t\tT == STM_FOR_IN || T == STM_FOR_IN_VAR;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7417, "func": "ZEND_API void zend_ts_hash_copy(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_copy(TS_HASH(target), TS_HASH(source), pCopyConstructor);\n\tend_write(target);\n\tend_read(source);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8032, "func": "static void vnc_listen_websocket_read(void *opaque)\n{\n    vnc_listen_read(opaque, true);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186931, "func": " void DelegatedFrameHost::ClearDelegatedFrame() {\n   EvictDelegatedFrame();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7889, "func": "static int addfunction(JF, js_Function *value)\n{\n\tif (F->funlen >= F->funcap) {\n\t\tF->funcap = F->funcap ? F->funcap * 2 : 16;\n\t\tF->funtab = js_realloc(J, F->funtab, F->funcap * sizeof *F->funtab);\n\t}\n\tF->funtab[F->funlen] = value;\n\treturn F->funlen++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7861, "func": "uint64_t ram_bytes_remaining(void)\n{\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186837, "func": "uint32_t ClientSharedBitmapManager::NotifyAllocatedSharedBitmap(\n    base::SharedMemory* memory,\n    const SharedBitmapId& id) {\n  base::SharedMemoryHandle handle_to_send =\n      base::SharedMemory::DuplicateHandle(memory->handle());\n  if (!base::SharedMemory::IsHandleValid(handle_to_send)) {\n    LOG(ERROR) << \"Failed to duplicate shared memory handle for bitmap.\";\n    return 0;\n   }\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n      handle_to_send, memory->mapped_size(), true \n);\n \n   {\n     base::AutoLock lock(lock_);\n    (*shared_bitmap_allocation_notifier_)\n        ->DidAllocateSharedBitmap(std::move(buffer_handle), id);\n    return ++last_sequence_number_;\n  }\n}\n", "target": 1, "flaw_line_index": "13"}
{"idx": 7612, "func": "static void cirrus_vga_write_sr(CirrusVGAState * s, uint32_t val)\n{\n    switch (s->vga.sr_index) {\n    case 0x00:\t\t\t\n    case 0x01:\t\t\t\n    case 0x02:\t\t\t\n    case 0x03:\t\t\t\n    case 0x04:\t\t\t\n\ts->vga.sr[s->vga.sr_index] = val & sr_mask[s->vga.sr_index];\n\tif (s->vga.sr_index == 1)\n            s->vga.update_retrace_info(&s->vga);\n        break;\n    case 0x06:\t\t\t\n\tval &= 0x17;\n\tif (val == 0x12) {\n\t    s->vga.sr[s->vga.sr_index] = 0x12;\n\t} else {\n\t    s->vga.sr[s->vga.sr_index] = 0x0f;\n\t}\n\tbreak;\n    case 0x10:\n    case 0x30:\n    case 0x50:\n    case 0x70:\t\t\t\n    case 0x90:\n    case 0xb0:\n    case 0xd0:\n    case 0xf0:\t\t\t\n\ts->vga.sr[0x10] = val;\n\ts->hw_cursor_x = (val << 3) | (s->vga.sr_index >> 5);\n\tbreak;\n    case 0x11:\n    case 0x31:\n    case 0x51:\n    case 0x71:\t\t\t\n    case 0x91:\n    case 0xb1:\n    case 0xd1:\n    case 0xf1:\t\t\t\n\ts->vga.sr[0x11] = val;\n\ts->hw_cursor_y = (val << 3) | (s->vga.sr_index >> 5);\n\tbreak;\n    case 0x07:\t\t\t\n    cirrus_update_memory_access(s);\n    case 0x08:\t\t\t\n    case 0x09:\t\t\t\n    case 0x0a:\t\t\t\n    case 0x0b:\t\t\t\n    case 0x0c:\t\t\t\n    case 0x0d:\t\t\t\n    case 0x0e:\t\t\t\n    case 0x0f:\t\t\t\n    case 0x12:\t\t\t\n    case 0x13:\t\t\t\n    case 0x14:\t\t\t\n    case 0x15:\t\t\t\n    case 0x16:\t\t\t\n    case 0x18:\t\t\t\n    case 0x19:\t\t\t\n    case 0x1a:\t\t\t\n    case 0x1b:\t\t\t\n    case 0x1c:\t\t\t\n    case 0x1d:\t\t\t\n    case 0x1e:\t\t\t\n    case 0x1f:\t\t\t\n\ts->vga.sr[s->vga.sr_index] = val;\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: handled outport sr_index %02x, sr_value %02x\\n\",\n\t       s->vga.sr_index, val);\n#endif\n\tbreak;\n    case 0x17:\t\t\t\n\ts->vga.sr[s->vga.sr_index] = (s->vga.sr[s->vga.sr_index] & 0x38)\n                                   | (val & 0xc7);\n        cirrus_update_memory_access(s);\n        break;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: outport sr_index %02x, sr_value %02x\\n\",\n               s->vga.sr_index, val);\n#endif\n\tbreak;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7747, "func": "  TT_Vary_Get_Glyph_Deltas( TT_Face      face,\n                            FT_UInt      glyph_index,\n                            FT_Vector*  *deltas,\n                            FT_UInt      n_points )\n  {\n    FT_Stream   stream = face->root.stream;\n    FT_Memory   memory = stream->memory;\n    GX_Blend    blend  = face->blend;\n    FT_Vector*  delta_xy;\n\n    FT_Error    error;\n    FT_ULong    glyph_start;\n    FT_UInt     tupleCount;\n    FT_ULong    offsetToData;\n    FT_ULong    here;\n    FT_UInt     i, j;\n    FT_Fixed*   tuple_coords    = NULL;\n    FT_Fixed*   im_start_coords = NULL;\n    FT_Fixed*   im_end_coords   = NULL;\n    FT_UInt     point_count, spoint_count = 0;\n    FT_UShort*  sharedpoints = NULL;\n    FT_UShort*  localpoints  = NULL;\n    FT_UShort*  points;\n    FT_Short    *deltas_x, *deltas_y;\n\n\n    if ( !face->doblend || blend == NULL )\n      return TT_Err_Invalid_Argument;\n\n    if ( FT_NEW_ARRAY( delta_xy, n_points ) )\n      goto Exit;\n    *deltas = delta_xy;\n\n    if ( glyph_index >= blend->gv_glyphcnt      ||\n         blend->glyphoffsets[glyph_index] ==\n           blend->glyphoffsets[glyph_index + 1] )\n      return TT_Err_Ok;               \n\n    if ( FT_STREAM_SEEK( blend->glyphoffsets[glyph_index] )   ||\n         FT_FRAME_ENTER( blend->glyphoffsets[glyph_index + 1] -\n                           blend->glyphoffsets[glyph_index] ) )\n      goto Fail1;\n\n    glyph_start = FT_Stream_FTell( stream );\n\n\n    if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||\n         FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||\n         FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )\n      goto Fail2;\n\n    tupleCount   = FT_GET_USHORT();\n    offsetToData = glyph_start + FT_GET_USHORT();\n\n    if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )\n    {\n      here = FT_Stream_FTell( stream );\n\n      FT_Stream_SeekSet( stream, offsetToData );\n\n      sharedpoints = ft_var_readpackedpoints( stream, &spoint_count );\n      offsetToData = FT_Stream_FTell( stream );\n\n      FT_Stream_SeekSet( stream, here );\n    }\n\n    for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); ++i )\n    {\n      FT_UInt   tupleDataSize;\n      FT_UInt   tupleIndex;\n      FT_Fixed  apply;\n\n\n      tupleDataSize = FT_GET_USHORT();\n      tupleIndex    = FT_GET_USHORT();\n\n      if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )\n      {\n        for ( j = 0; j < blend->num_axis; ++j )\n          tuple_coords[j] = FT_GET_SHORT() << 2;  \n      }\n      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )\n      {\n        error = TT_Err_Invalid_Table;\n        goto Fail3;\n      }\n      else\n      {\n        FT_MEM_COPY(\n          tuple_coords,\n          &blend->tuplecoords[(tupleIndex & 0xFFF) * blend->num_axis],\n          blend->num_axis * sizeof ( FT_Fixed ) );\n      }\n\n      if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )\n      {\n        for ( j = 0; j < blend->num_axis; ++j )\n          im_start_coords[j] = FT_GET_SHORT() << 2;\n        for ( j = 0; j < blend->num_axis; ++j )\n          im_end_coords[j] = FT_GET_SHORT() << 2;\n      }\n\n      apply = ft_var_apply_tuple( blend,\n                                  (FT_UShort)tupleIndex,\n                                  tuple_coords,\n                                  im_start_coords,\n                                  im_end_coords );\n\n      if ( apply == 0 )              \n      {\n        offsetToData += tupleDataSize;\n        continue;\n      }\n\n      here = FT_Stream_FTell( stream );\n\n      if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )\n      {\n        FT_Stream_SeekSet( stream, offsetToData );\n\n        localpoints = ft_var_readpackedpoints( stream, &point_count );\n        points      = localpoints;\n      }\n      else\n      {\n        points      = sharedpoints;\n        point_count = spoint_count;\n      }\n\n      deltas_x = ft_var_readpackeddeltas( stream,\n                                          point_count == 0 ? n_points\n                                                           : point_count );\n      deltas_y = ft_var_readpackeddeltas( stream,\n                                          point_count == 0 ? n_points\n                                                           : point_count );\n\n      if ( points == NULL || deltas_y == NULL || deltas_x == NULL )\n        ; \n\n      else if ( points == ALL_POINTS )\n      {\n        for ( j = 0; j < n_points; ++j )\n        {\n          delta_xy[j].x += FT_MulFix( deltas_x[j], apply );\n          delta_xy[j].y += FT_MulFix( deltas_y[j], apply );\n        }\n      }\n\n      else\n      {\n        for ( j = 0; j < point_count; ++j )\n        {\n          delta_xy[localpoints[j]].x += FT_MulFix( deltas_x[j], apply );\n          delta_xy[localpoints[j]].y += FT_MulFix( deltas_y[j], apply );\n        }\n      }\n\n      if ( localpoints != ALL_POINTS )\n        FT_FREE( localpoints );\n      FT_FREE( deltas_x );\n      FT_FREE( deltas_y );\n\n      offsetToData += tupleDataSize;\n\n      FT_Stream_SeekSet( stream, here );\n    }\n\n  Fail3:\n    FT_FREE( tuple_coords );\n    FT_FREE( im_start_coords );\n    FT_FREE( im_end_coords );\n\n  Fail2:\n    FT_FRAME_EXIT();\n\n  Fail1:\n    if ( error )\n    {\n      FT_FREE( delta_xy );\n      *deltas = NULL;\n    }\n\n  Exit:\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186399, "func": "void InputHandlerProxy::DispatchSingleInputEvent(\n    std::unique_ptr<EventWithCallback> event_with_callback,\n    const base::TimeTicks now) {\n  const ui::LatencyInfo& original_latency_info =\n      event_with_callback->latency_info();\n  ui::LatencyInfo monitored_latency_info = original_latency_info;\n  std::unique_ptr<cc::SwapPromiseMonitor> latency_info_swap_promise_monitor =\n      input_handler_->CreateLatencyInfoSwapPromiseMonitor(\n          &monitored_latency_info);\n \n   current_overscroll_params_.reset();\n \n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n      FALLTHROUGH;\n    case blink::WebGestureEvent::kGesturePinchBegin:\n    case blink::WebGestureEvent::kGestureScrollUpdate:\n    case blink::WebGestureEvent::kGesturePinchUpdate:\n      has_ongoing_compositor_scroll_or_pinch_ = disposition == DID_HANDLE;\n      break;\n\n    case blink::WebGestureEvent::kGestureScrollEnd:\n    case blink::WebGestureEvent::kGesturePinchEnd:\n      has_ongoing_compositor_scroll_or_pinch_ = false;\n      break;\n    default:\n      break;\n  }\n\n  switch (type) {\n    case blink::WebGestureEvent::kGestureScrollBegin:\n      momentum_scroll_jank_tracker_ =\n          std::make_unique<MomentumScrollJankTracker>();\n      break;\n    case blink::WebGestureEvent::kGestureScrollUpdate:\n      if (momentum_scroll_jank_tracker_) {\n        momentum_scroll_jank_tracker_->OnDispatchedInputEvent(\n            event_with_callback.get(), now);\n      }\n      break;\n    case blink::WebGestureEvent::kGestureScrollEnd:\n      momentum_scroll_jank_tracker_.reset();\n      break;\n    default:\n      break;\n  }\n\n  event_with_callback->RunCallbacks(disposition, monitored_latency_info,\n                                     std::move(current_overscroll_params_));\n }\n", "target": 1, "flaw_line_index": "16"}
{"idx": 7480, "func": "int notsup_removexattr(FsContext *ctx, const char *path, const char *name)\n{\n    errno = ENOTSUP;\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187042, "func": "void FrameLoader::StartNavigation(const FrameLoadRequest& passed_request,\n                                  WebFrameLoadType frame_load_type,\n                                  NavigationPolicy policy) {\n  CHECK(!IsBackForwardLoadType(frame_load_type));\n  DCHECK(passed_request.TriggeringEventInfo() !=\n         WebTriggeringEventInfo::kUnknown);\n\n  DCHECK(frame_->GetDocument());\n  if (HTMLFrameOwnerElement* element = frame_->DeprecatedLocalOwner())\n    element->CancelPendingLazyLoad();\n\n  if (in_stop_all_loaders_)\n    return;\n\n  FrameLoadRequest request(passed_request);\n  ResourceRequest& resource_request = request.GetResourceRequest();\n  const KURL& url = resource_request.Url();\n  Document* origin_document = request.OriginDocument();\n\n  resource_request.SetHasUserGesture(\n      LocalFrame::HasTransientUserActivation(frame_));\n\n  if (!PrepareRequestForThisFrame(request))\n    return;\n\n  Frame* target_frame =\n      request.Form() ? nullptr\n                     : frame_->FindFrameForNavigation(\n                           AtomicString(request.FrameName()), *frame_, url);\n\n  bool should_navigate_target_frame = policy == kNavigationPolicyCurrentTab;\n\n  if (target_frame && target_frame != frame_ && should_navigate_target_frame) {\n    if (target_frame->IsLocalFrame() &&\n        !ToLocalFrame(target_frame)->IsNavigationAllowed()) {\n      return;\n    }\n\n    bool was_in_same_page = target_frame->GetPage() == frame_->GetPage();\n\n    request.SetFrameName(\"_self\");\n    target_frame->Navigate(request, frame_load_type);\n    Page* page = target_frame->GetPage();\n    if (!was_in_same_page && page)\n      page->GetChromeClient().Focus(frame_);\n    return;\n  }\n\n  SetReferrerForFrameRequest(request);\n\n  if (!target_frame && !request.FrameName().IsEmpty()) {\n    if (policy == kNavigationPolicyDownload) {\n      Client()->DownloadURL(resource_request,\n                            DownloadCrossOriginRedirects::kFollow);\n      return;  \n    } else if (should_navigate_target_frame) {\n      resource_request.SetFrameType(\n          network::mojom::RequestContextFrameType::kAuxiliary);\n      CreateWindowForRequest(request, *frame_);\n      return;  \n    }\n  }\n\n  if (!frame_->IsNavigationAllowed() ||\n      frame_->GetDocument()->PageDismissalEventBeingDispatched() !=\n          Document::kNoDismissal) {\n    return;\n  }\n\n  frame_load_type = DetermineFrameLoadType(resource_request, origin_document,\n                                           KURL(), frame_load_type);\n\n  bool same_document_navigation =\n      policy == kNavigationPolicyCurrentTab &&\n      ShouldPerformFragmentNavigation(\n          request.Form(), resource_request.HttpMethod(), frame_load_type, url);\n\n  if (same_document_navigation) {\n    CommitSameDocumentNavigation(\n        url, frame_load_type, nullptr, request.ClientRedirect(),\n        origin_document,\n        request.TriggeringEventInfo() != WebTriggeringEventInfo::kNotFromEvent,\n        nullptr \n);\n    return;\n  }\n\n  WebNavigationType navigation_type = DetermineNavigationType(\n      frame_load_type, resource_request.HttpBody() || request.Form(),\n      request.TriggeringEventInfo() != WebTriggeringEventInfo::kNotFromEvent);\n  resource_request.SetRequestContext(\n      DetermineRequestContextFromNavigationType(navigation_type));\n  resource_request.SetFrameType(\n      frame_->IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel\n                            : network::mojom::RequestContextFrameType::kNested);\n\n  mojom::blink::NavigationInitiatorPtr navigation_initiator;\n  if (origin_document && origin_document->GetContentSecurityPolicy()\n                             ->ExperimentalFeaturesEnabled()) {\n    WebContentSecurityPolicyList initiator_csp =\n        origin_document->GetContentSecurityPolicy()\n            ->ExposeForNavigationalChecks();\n    resource_request.SetInitiatorCSP(initiator_csp);\n    auto request = mojo::MakeRequest(&navigation_initiator);\n     origin_document->BindNavigationInitiatorRequest(std::move(request));\n   }\n \n   RecordLatestRequiredCSP();\n\n\n\n  ModifyRequestForCSP(resource_request, origin_document);\n\n  DCHECK(Client()->HasWebView());\n  if (url.PotentiallyDanglingMarkup() && url.ProtocolIsInHTTPFamily()) {\n    Deprecation::CountDeprecation(\n        frame_, WebFeature::kCanRequestURLHTTPContainingNewline);\n    return;\n  }\n\n  bool has_transient_activation =\n      LocalFrame::HasTransientUserActivation(frame_);\n  if (frame_->IsMainFrame() && origin_document &&\n      frame_->GetPage() == origin_document->GetPage()) {\n    LocalFrame::ConsumeTransientUserActivation(frame_);\n  }\n\n  Client()->BeginNavigation(\n      resource_request, origin_document, nullptr \n,\n      navigation_type, policy, has_transient_activation, frame_load_type,\n      request.ClientRedirect() == ClientRedirectPolicy::kClientRedirect,\n      request.TriggeringEventInfo(), request.Form(),\n      request.ShouldCheckMainWorldContentSecurityPolicy(),\n      request.GetBlobURLToken(), request.GetInputStartTime(),\n      request.HrefTranslate().GetString(), std::move(navigation_initiator));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186396, "func": "  void RunScrollbarButtonLatencyTest() {\n#if !defined(OS_ANDROID)\n    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n        scrollbar_forward_button.y, 0);\n    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n    RunUntilInputProcessed(GetWidgetHost());\n    FetchHistogramsFromChildProcesses();\n    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n        1, \"Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"));\n    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n        1,\n        \"Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"));\n    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n        1,\n        \"Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"));\n    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n        1, \"Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"));\n    std::string thread_name =\n        DoesScrollbarScrollOnMainThread() ? \"Main\" : \"Impl\";\n    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n        1,\n        \"Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\" + thread_name));\n    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n        1, \"Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\" +\n               thread_name));\n#endif  \n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34"}
{"idx": 187093, "func": "   void OpenSession() {\n     const int render_process_id = 1;\n     const int render_frame_id = 1;\n     const int page_request_id = 1;\n     const url::Origin security_origin =\n         url::Origin::Create(GURL(\"http:\n\n    ASSERT_TRUE(opened_device_label_.empty());\n\n    MediaDeviceInfoArray video_devices;\n    {\n      base::RunLoop run_loop;\n      MediaDevicesManager::BoolDeviceTypes devices_to_enumerate;\n      devices_to_enumerate[MEDIA_DEVICE_TYPE_VIDEO_INPUT] = true;\n      media_stream_manager_->media_devices_manager()->EnumerateDevices(\n          devices_to_enumerate,\n          base::BindOnce(&VideoInputDevicesEnumerated, run_loop.QuitClosure(),\n                         browser_context_.GetMediaDeviceIDSalt(),\n                         security_origin, &video_devices));\n      run_loop.Run();\n    }\n    ASSERT_FALSE(video_devices.empty());\n\n     {\n       base::RunLoop run_loop;\n       media_stream_manager_->OpenDevice(\n          render_process_id, render_frame_id, page_request_id,\n           video_devices[0].device_id, MEDIA_DEVICE_VIDEO_CAPTURE,\n           MediaDeviceSaltAndOrigin{browser_context_.GetMediaDeviceIDSalt(),\n                                    browser_context_.GetMediaDeviceIDSalt(),\n                                   security_origin},\n          base::BindOnce(&VideoCaptureTest::OnDeviceOpened,\n                         base::Unretained(this), run_loop.QuitClosure()),\n          MediaStreamManager::DeviceStoppedCallback());\n      run_loop.Run();\n    }\n    ASSERT_NE(MediaStreamDevice::kNoId, opened_session_id_);\n  }\n", "target": 1, "flaw_line_index": "29"}
{"idx": 186750, "func": " void StorageHandler::GetUsageAndQuota(\n     const String& origin,\n     std::unique_ptr<GetUsageAndQuotaCallback> callback) {\n  if (!process_)\n     return callback->sendFailure(Response::InternalError());\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid()) {\n    return callback->sendFailure(\n         Response::Error(origin + \" is not a valid URL\"));\n   }\n \n  storage::QuotaManager* manager =\n      process_->GetStoragePartition()->GetQuotaManager();\n   BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(&GetUsageAndQuotaOnIOThread, base::RetainedRef(manager),\n                      origin_url, base::Passed(std::move(callback))));\n }\n", "target": 1, "flaw_line_index": "4,13,14"}
{"idx": 186354, "func": "void SaveCardBubbleControllerImpl::ShowBubbleForUpload(\n    const CreditCard& card,\n     std::unique_ptr<base::DictionaryValue> legal_message,\n     bool should_cvc_be_requested,\n     const base::Closure& save_card_callback) {\n   is_uploading_ = true;\n   is_reshow_ = false;\n   should_cvc_be_requested_ = should_cvc_be_requested;\n  AutofillMetrics::LogSaveCardPromptMetric(\n      AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,\n      is_reshow_,\n      pref_service_->GetInteger(\n          prefs::kAutofillAcceptSaveCreditCardPromptState));\n\n  if (!LegalMessageLine::Parse(*legal_message, &legal_message_lines_)) {\n    AutofillMetrics::LogSaveCardPromptMetric(\n        AutofillMetrics::SAVE_CARD_PROMPT_END_INVALID_LEGAL_MESSAGE,\n        is_uploading_, is_reshow_,\n        pref_service_->GetInteger(\n            prefs::kAutofillAcceptSaveCreditCardPromptState));\n    return;\n  }\n\n  card_ = card;\n  save_card_callback_ = save_card_callback;\n  ShowBubble();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7588, "func": "static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\t\t\t\t\t      unsigned mode,\n\t\t\t\t\t      unsigned offset,\n\t\t\t\t\t      uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (offset &= s->cirrus_addr_mask);\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t    *(dst + 1) = s->vga.gr[0x11];\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t    *(dst + 1) = s->vga.gr[0x10];\n\t}\n\tval <<= 1;\n\tdst += 2;\n    }\n    memory_region_set_dirty(&s->vga.vram, offset, 16);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7851, "func": "static inline bool migration_bitmap_set_dirty(ram_addr_t addr)\n{\n    bool ret;\n    int nr = addr >> TARGET_PAGE_BITS;\n\n    ret = test_and_set_bit(nr, migration_bitmap);\n\n    if (!ret) {\n        migration_dirty_pages++;\n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186759, "func": "void RenderFrameDevToolsAgentHost::UpdateFrameHost(\n    RenderFrameHostImpl* frame_host) {\n  if (frame_host == frame_host_) {\n    if (frame_host && !render_frame_alive_) {\n      render_frame_alive_ = true;\n      MaybeReattachToRenderFrame();\n    }\n    return;\n  }\n\n  if (frame_host && !ShouldCreateDevToolsForHost(frame_host)) {\n    DestroyOnRenderFrameGone();\n    return;\n  }\n\n  if (IsAttached())\n    RevokePolicy();\n  frame_host_ = frame_host;\n  agent_ptr_.reset();\n  render_frame_alive_ = true;\n   if (IsAttached()) {\n     GrantPolicy();\n     for (DevToolsSession* session : sessions()) {\n      session->SetRenderer(frame_host ? frame_host->GetProcess() : nullptr,\n                            frame_host);\n     }\n     MaybeReattachToRenderFrame();\n  }\n}\n", "target": 1, "flaw_line_index": "25"}
{"idx": 186634, "func": "bool FrameFetchContext::UpdateTimingInfoForIFrameNavigation(\n    ResourceTimingInfo* info) {\n  if (IsDetached())\n    return false;\n\n  if (!GetFrame()->Owner())\n    return false;\n   if (!GetFrame()->should_send_resource_timing_info_to_parent())\n     return false;\n  if (MasterDocumentLoader()->LoadType() == WebFrameLoadType::kBackForward)\n     return false;\n   return true;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7760, "func": "static int h2_frt_decode_headers(struct h2s *h2s, struct buffer *buf, int count)\n{\n\tstruct h2c *h2c = h2s->h2c;\n\tconst uint8_t *hdrs = (uint8_t *)h2c->dbuf->p;\n\tstruct chunk *tmp = get_trash_chunk();\n\tstruct http_hdr list[MAX_HTTP_HDR * 2];\n\tstruct chunk *copy = NULL;\n\tint flen = h2c->dfl;\n\tint outlen = 0;\n\tint wrap;\n\tint try;\n\n\tif (!h2c->dfl) {\n\t\th2s_error(h2s, H2_ERR_PROTOCOL_ERROR); \n\t\th2c->st0 = H2_CS_FRAME_E;\n\t\treturn 0;\n\t}\n\n\tif (h2c->dbuf->i < h2c->dfl && h2c->dbuf->i < h2c->dbuf->size)\n\t\treturn 0; \n\n\twrap = h2c->dbuf->data + h2c->dbuf->size - h2c->dbuf->p;\n\tif (wrap < h2c->dfl) {\n\t\tcopy = alloc_trash_chunk();\n\t\tif (!copy) {\n\t\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(copy->str, h2c->dbuf->p, wrap);\n\t\tmemcpy(copy->str + wrap, h2c->dbuf->data, h2c->dfl - wrap);\n\t\thdrs = (uint8_t *)copy->str;\n\t}\n\n\tif (h2c->dff & H2_F_HEADERS_PADDED) {\n\t\th2c->dpl = *hdrs;\n\t\tif (h2c->dpl >= flen) {\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t\tflen -= h2c->dpl + 1;\n\t\thdrs += 1; \n\t}\n\n\tif (h2c->dff & H2_F_HEADERS_PRIORITY) {\n\t\tif (read_n32(hdrs) == h2s->id) {\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\n\t\thdrs += 5; \n\t\tflen -= 5;\n\t}\n\n\tif (!(h2c->dff & H2_F_HEADERS_END_HEADERS)) {\n\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\tgoto fail;\n\t}\n\n\tif (unlikely(buf->o)) {\n\t\tgoto fail;\n\t}\n\n\tif (unlikely(buffer_space_wraps(buf))) {\n\t\tbuffer_slow_realign(buf);\n\t}\n\n\ttry = buf->data + buf->size - (buf->p + buf->i);\n\n\tif (try <= 0) {\n\t\ttry = buf->p - (buf->data + buf->o);\n\t\tif (try <= 0)\n\t\t\tgoto fail;\n\t}\n\tif (try > count)\n\t\ttry = count;\n\n\toutlen = hpack_decode_frame(h2c->ddht, hdrs, flen, list,\n\t                            sizeof(list)/sizeof(list[0]), tmp);\n\tif (outlen < 0) {\n\t\th2c_error(h2c, H2_ERR_COMPRESSION_ERROR);\n\t\tgoto fail;\n\t}\n\n\toutlen = h2_make_h1_request(list, bi_end(buf), try);\n\n\tif (outlen < 0) {\n\t\th2c_error(h2c, H2_ERR_COMPRESSION_ERROR);\n\t\tgoto fail;\n\t}\n\n\tbi_del(h2c->dbuf, h2c->dfl);\n\th2c->st0 = H2_CS_FRAME_H;\n\tbuf->i += outlen;\n\n\tif (h2c->dff & H2_F_HEADERS_END_STREAM) {\n\t\th2s->cs->flags |= CS_FL_EOS;\n\t\th2s->flags |= H2_SF_ES_RCVD;\n\t}\n\n leave:\n\tfree_trash_chunk(copy);\n\treturn outlen;\n fail:\n\toutlen = 0;\n\tgoto leave;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186439, "func": "void InspectorTraceEvents::WillSendRequest(\n    ExecutionContext*,\n    unsigned long identifier,\n     DocumentLoader* loader,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n    const FetchInitiatorInfo&) {\n   LocalFrame* frame = loader ? loader->GetFrame() : nullptr;\n   TRACE_EVENT_INSTANT1(\n       \"devtools.timeline\", \"ResourceSendRequest\", TRACE_EVENT_SCOPE_THREAD,\n      \"data\", InspectorSendRequestEvent::Data(identifier, frame, request));\n  probe::AsyncTaskScheduled(frame ? frame->GetDocument() : nullptr,\n                            \"SendRequest\", AsyncId(identifier));\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 186525, "func": "bool DataReductionProxySettings::IsDataSaverEnabledByUser() const {\n   if (params::ShouldForceEnableDataReductionProxy())\n     return true;\n \n  if (spdy_proxy_auth_enabled_.GetPrefName().empty())\n    return false;\n  return spdy_proxy_auth_enabled_.GetValue();\n }\n", "target": 1, "flaw_line_index": "4,5,6"}
{"idx": 186747, "func": "void StorageHandler::ClearDataForOrigin(\n     const std::string& origin,\n     const std::string& storage_types,\n     std::unique_ptr<ClearDataForOriginCallback> callback) {\n  if (!process_)\n     return callback->sendFailure(Response::InternalError());\n \n  StoragePartition* partition = process_->GetStoragePartition();\n   std::vector<std::string> types = base::SplitString(\n       storage_types, \",\", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n   std::unordered_set<std::string> set(types.begin(), types.end());\n  uint32_t remove_mask = 0;\n  if (set.count(Storage::StorageTypeEnum::Appcache))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_APPCACHE;\n  if (set.count(Storage::StorageTypeEnum::Cookies))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_COOKIES;\n  if (set.count(Storage::StorageTypeEnum::File_systems))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS;\n  if (set.count(Storage::StorageTypeEnum::Indexeddb))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_INDEXEDDB;\n  if (set.count(Storage::StorageTypeEnum::Local_storage))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE;\n  if (set.count(Storage::StorageTypeEnum::Shader_cache))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_SHADER_CACHE;\n  if (set.count(Storage::StorageTypeEnum::Websql))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_WEBSQL;\n  if (set.count(Storage::StorageTypeEnum::Service_workers))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_SERVICE_WORKERS;\n  if (set.count(Storage::StorageTypeEnum::Cache_storage))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_CACHE_STORAGE;\n  if (set.count(Storage::StorageTypeEnum::All))\n    remove_mask |= StoragePartition::REMOVE_DATA_MASK_ALL;\n\n  if (!remove_mask) {\n    return callback->sendFailure(\n         Response::InvalidParams(\"No valid storage type specified\"));\n   }\n \n  partition->ClearData(remove_mask,\n                       StoragePartition::QUOTA_MANAGED_STORAGE_MASK_ALL,\n                       GURL(origin), StoragePartition::OriginMatcherFunction(),\n                       base::Time(), base::Time::Max(),\n                       base::BindOnce(&ClearDataForOriginCallback::sendSuccess,\n                                      std::move(callback)));\n }\n", "target": 1, "flaw_line_index": "5,8,39,40,41,42,43,44"}
{"idx": 7400, "func": "load_1(struct magic_set *ms, int action, const char *fn, int *errs,\n   struct magic_entry_set *mset)\n{\n\tchar buffer[BUFSIZ + 1];\n\tchar *line = NULL;\n\tsize_t len;\n\tsize_t lineno = 0;\n\tstruct magic_entry me;\n\n\tphp_stream *stream;\n\n\tTSRMLS_FETCH();\n\n\tms->file = fn;\n\tstream = php_stream_open_wrapper((char *)fn, \"rb\", REPORT_ERRORS, NULL);\n\n\tif (stream == NULL) {\n\t\tif (errno != ENOENT)\n\t\t\tfile_error(ms, errno, \"cannot read magic file `%s'\",\n\t\t\t\t   fn);\n\t\t(*errs)++;\n\t\treturn;\n\t}\n\n\tmemset(&me, 0, sizeof(me));\n\tfor (ms->line = 1; (line = php_stream_get_line(stream, buffer , BUFSIZ, &len)) != NULL; ms->line++) {\n\t\tif (len == 0) \n\t\t\tcontinue;\n\t\tif (line[len - 1] == '\\n') {\n\t\t\tlineno++;\n\t\t\tline[len - 1] = '\\0'; \n\t\t}\n\t\tswitch (line[0]) {\n\t\tcase '\\0':\t\n\t\tcase '#':\t\n\t\t\tcontinue;\n\t\tcase '!':\n\t\t\tif (line[1] == ':') {\n\t\t\t\tsize_t i;\n\n\t\t\t\tfor (i = 0; bang[i].name != NULL; i++) {\n\t\t\t\t\tif ((size_t)(len - 2) > bang[i].len &&\n\t\t\t\t\t    memcmp(bang[i].name, line + 2,\n\t\t\t\t\t    bang[i].len) == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (bang[i].name == NULL) {\n\t\t\t\t\tfile_error(ms, 0,\n\t\t\t\t\t    \"Unknown !: entry `%s'\", line);\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (me.mp == NULL) {\n\t\t\t\t\tfile_error(ms, 0,\n\t\t\t\t\t    \"No current entry for :!%s type\",\n\t\t\t\t\t\tbang[i].name);\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((*bang[i].fun)(ms, &me,\n\t\t\t\t    line + bang[i].len + 2) != 0) {\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tdefault:\n\t\tagain:\n\t\t\tswitch (parse(ms, &me, line, lineno, action)) {\n\t\t\tcase 0:\n\t\t\t\tcontinue;\n\t\t\tcase 1:\n\t\t\t\t(void)addentry(ms, &me, mset);\n\t\t\t\tgoto again;\n\t\t\tdefault:\n\t\t\t\t(*errs)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (me.mp)\n\t\t(void)addentry(ms, &me, mset);\n\tphp_stream_close(stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186504, "func": "WebGLRenderingContextBase::WebGLRenderingContextBase(\n    CanvasRenderingContextHost* host,\n    scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n    std::unique_ptr<WebGraphicsContext3DProvider> context_provider,\n    bool using_gpu_compositing,\n    const CanvasContextCreationAttributesCore& requested_attributes,\n    Platform::ContextType context_type)\n    : CanvasRenderingContext(host, requested_attributes),\n      context_group_(MakeGarbageCollected<WebGLContextGroup>()),\n      dispatch_context_lost_event_timer_(\n          task_runner,\n          this,\n          &WebGLRenderingContextBase::DispatchContextLostEvent),\n      restore_timer_(task_runner,\n                     this,\n                      &WebGLRenderingContextBase::MaybeRestoreContext),\n       task_runner_(task_runner),\n       num_gl_errors_to_console_allowed_(kMaxGLErrorsAllowedToConsole),\n      context_type_(context_type) {\n   DCHECK(context_provider);\n \n  xr_compatible_ = requested_attributes.xr_compatible;\n\n  context_group_->AddContext(this);\n\n  max_viewport_dims_[0] = max_viewport_dims_[1] = 0;\n  context_provider->ContextGL()->GetIntegerv(GL_MAX_VIEWPORT_DIMS,\n                                             max_viewport_dims_);\n  InitializeWebGLContextLimits(context_provider.get());\n\n  scoped_refptr<DrawingBuffer> buffer;\n  buffer =\n      CreateDrawingBuffer(std::move(context_provider), using_gpu_compositing);\n  if (!buffer) {\n    context_lost_mode_ = kSyntheticLostContext;\n    return;\n  }\n\n  drawing_buffer_ = std::move(buffer);\n  GetDrawingBuffer()->Bind(GL_FRAMEBUFFER);\n  SetupFlags();\n\n  String disabled_webgl_extensions(GetDrawingBuffer()\n                                       ->ContextProvider()\n                                       ->GetGpuFeatureInfo()\n                                       .disabled_webgl_extensions.c_str());\n  Vector<String> disabled_extension_list;\n  disabled_webgl_extensions.Split(' ', disabled_extension_list);\n  for (const auto& entry : disabled_extension_list) {\n    disabled_extensions_.insert(entry);\n  }\n\n#define ADD_VALUES_TO_SET(set, values)              \\\n  for (size_t i = 0; i < base::size(values); ++i) { \\\n    set.insert(values[i]);                          \\\n  }\n\n  ADD_VALUES_TO_SET(supported_internal_formats_, kSupportedFormatsES2);\n  ADD_VALUES_TO_SET(supported_tex_image_source_internal_formats_,\n                    kSupportedFormatsES2);\n  ADD_VALUES_TO_SET(supported_internal_formats_copy_tex_image_,\n                    kSupportedFormatsES2);\n  ADD_VALUES_TO_SET(supported_formats_, kSupportedFormatsES2);\n  ADD_VALUES_TO_SET(supported_tex_image_source_formats_, kSupportedFormatsES2);\n  ADD_VALUES_TO_SET(supported_types_, kSupportedTypesES2);\n  ADD_VALUES_TO_SET(supported_tex_image_source_types_, kSupportedTypesES2);\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 186977, "func": " std::unique_ptr<SymmetricKey> CopyDefaultPaddingKey() {\n  return SymmetricKey::Import(kPaddingKeyAlgorithm, (*GetPaddingKey())->key());\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186611, "func": " bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n    return false;\n  }\n  if (!MediaElement()->HasSingleSecurityOrigin()) {\n    return true;\n  }\n  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10"}
{"idx": 7811, "func": "static void h2c_update_all_ws(struct h2c *h2c, int diff)\n{\n\tstruct h2s *h2s;\n\tstruct eb32_node *node;\n\n\tif (!diff)\n\t\treturn;\n\n\tnode = eb32_first(&h2c->streams_by_id);\n\twhile (node) {\n\t\th2s = container_of(node, struct h2s, by_id);\n\t\th2s->mws += diff;\n\t\tnode = eb32_next(node);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8065, "func": "FoFiType1::~FoFiType1() {\n  int i;\n\n  if (name) {\n    gfree(name);\n  }\n  if (encoding && encoding != fofiType1StandardEncoding) {\n    for (i = 0; i < 256; ++i) {\n      gfree(encoding[i]);\n    }\n    gfree(encoding);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186327, "func": "std::unique_ptr<PrefService> CreatePrefService() {\n  auto pref_registry = base::MakeRefCounted<user_prefs::PrefRegistrySyncable>();\n \n   metrics::MetricsService::RegisterPrefs(pref_registry.get());\n   variations::VariationsService::RegisterPrefs(pref_registry.get());\n \n   AwBrowserProcess::RegisterNetworkContextLocalStatePrefs(pref_registry.get());\n \n  PrefServiceFactory pref_service_factory;\n\n  std::set<std::string> persistent_prefs;\n  for (const char* const pref_name : kPersistentPrefsWhitelist)\n    persistent_prefs.insert(pref_name);\n\n  pref_service_factory.set_user_prefs(base::MakeRefCounted<SegregatedPrefStore>(\n      base::MakeRefCounted<InMemoryPrefStore>(),\n      base::MakeRefCounted<JsonPrefStore>(GetPrefStorePath()), persistent_prefs,\n      mojo::Remote<::prefs::mojom::TrackedPreferenceValidationDelegate>()));\n\n  pref_service_factory.set_read_error_callback(\n      base::BindRepeating(&HandleReadError));\n\n   return pref_service_factory.Create(pref_registry);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8095, "func": "void Gfx::gouraudFillTriangle(double x0, double y0, GfxColor *color0,\n\t\t\t      double x1, double y1, GfxColor *color1,\n\t\t\t      double x2, double y2, GfxColor *color2,\n\t\t\t      int nComps, int depth) {\n  double x01, y01, x12, y12, x20, y20;\n  GfxColor color01, color12, color20;\n  int i;\n\n  for (i = 0; i < nComps; ++i) {\n    if (abs(color0->c[i] - color1->c[i]) > gouraudColorDelta ||\n\tabs(color1->c[i] - color2->c[i]) > gouraudColorDelta) {\n      break;\n    }\n  }\n  if (i == nComps || depth == gouraudMaxDepth) {\n    state->setFillColor(color0);\n    out->updateFillColor(state);\n    state->moveTo(x0, y0);\n    state->lineTo(x1, y1);\n    state->lineTo(x2, y2);\n    state->closePath();\n    if (!contentIsHidden())\n      out->fill(state);\n    state->clearPath();\n  } else {\n    x01 = 0.5 * (x0 + x1);\n    y01 = 0.5 * (y0 + y1);\n    x12 = 0.5 * (x1 + x2);\n    y12 = 0.5 * (y1 + y2);\n    x20 = 0.5 * (x2 + x0);\n    y20 = 0.5 * (y2 + y0);\n    for (i = 0; i < nComps; ++i) {\n      color01.c[i] = (color0->c[i] + color1->c[i]) / 2;\n      color12.c[i] = (color1->c[i] + color2->c[i]) / 2;\n      color20.c[i] = (color2->c[i] + color0->c[i]) / 2;\n    }\n    gouraudFillTriangle(x0, y0, color0, x01, y01, &color01,\n\t\t\tx20, y20, &color20, nComps, depth + 1);\n    gouraudFillTriangle(x01, y01, &color01, x1, y1, color1,\n\t\t\tx12, y12, &color12, nComps, depth + 1);\n    gouraudFillTriangle(x01, y01, &color01, x12, y12, &color12,\n\t\t\tx20, y20, &color20, nComps, depth + 1);\n    gouraudFillTriangle(x20, y20, &color20, x12, y12, &color12,\n\t\t\tx2, y2, color2, nComps, depth + 1);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187234, "func": "static int hid_set_interface_altsetting(int sub_api, struct libusb_device_handle *dev_handle, int iface, int altsetting)\n{\n\tstruct libusb_context *ctx = DEVICE_CTX(dev_handle->dev);\n\tCHECK_HID_AVAILABLE;\n\tif (altsetting > 255) {\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tif (altsetting != 0) {\n\t\tusbi_err(ctx, \"set interface altsetting not supported for altsetting >0\");\n\t\treturn LIBUSB_ERROR_NOT_SUPPORTED;\n\t}\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13"}
{"idx": 7708, "func": "void pdu_submit(V9fsPDU *pdu)\n{\n    Coroutine *co;\n    CoroutineEntry *handler;\n    V9fsState *s = pdu->s;\n\n    if (pdu->id >= ARRAY_SIZE(pdu_co_handlers) ||\n        (pdu_co_handlers[pdu->id] == NULL)) {\n        handler = v9fs_op_not_supp;\n    } else {\n        handler = pdu_co_handlers[pdu->id];\n    }\n\n    if (is_ro_export(&s->ctx) && !is_read_only_op(pdu)) {\n        handler = v9fs_fs_ro;\n    }\n    co = qemu_coroutine_create(handler, pdu);\n    qemu_coroutine_enter(co);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7765, "func": "static inline __maybe_unused uint32_t h2_get_n32(const struct buffer *b, int o)\n{\n\treturn readv_n32(b_ptr(b, o), b_end(b) - b_ptr(b, o), b->data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8062, "func": "FoFiType1 *FoFiType1::load(char *fileName) {\n  char *fileA;\n  int lenA;\n\n  if (!(fileA = FoFiBase::readFile(fileName, &lenA))) {\n    return NULL;\n  }\n  return new FoFiType1(fileA, lenA, gTrue);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8263, "func": "XRecordFreeState(XRecordState *state)\n{\n    int i;\n\n    for(i=0; i<state->nclients; i++) {\n\tif (state->client_info[i]->ranges) {\n\t    if (state->client_info[i]->ranges[0])\n\t\tXfree(state->client_info[i]->ranges[0]);\n\t    Xfree(state->client_info[i]->ranges);\n\t}\n    }\n    if (state->client_info) {\n\tif (state->client_info[0])\n\t    Xfree(state->client_info[0]);\n\tXfree(state->client_info);\n    }\n    Xfree(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186938, "func": "std::set<std::string> GetDistinctHosts(const URLPatternSet& host_patterns,\n                                       bool include_rcd,\n                                       bool exclude_file_scheme) {\n  typedef base::StringPairs HostVector;\n  HostVector hosts_best_rcd;\n  for (const URLPattern& pattern : host_patterns) {\n    if (exclude_file_scheme && pattern.scheme() == url::kFileScheme)\n       continue;\n \n     std::string host = pattern.host();\n \n     if (pattern.match_subdomains())\n      host = \"*.\" + host;\n\n\n    std::string rcd;\n    size_t reg_len =\n        net::registry_controlled_domains::PermissiveGetHostRegistryLength(\n            host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,\n            net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);\n    if (reg_len && reg_len != std::string::npos) {\n      if (include_rcd)  \n        rcd = host.substr(host.size() - reg_len);\n      host = host.substr(0, host.size() - reg_len);\n    }\n\n    HostVector::iterator it = hosts_best_rcd.begin();\n    for (; it != hosts_best_rcd.end(); ++it) {\n      if (it->first == host)\n        break;\n    }\n    if (it != hosts_best_rcd.end()) {\n      if (include_rcd && RcdBetterThan(rcd, it->second))\n        it->second = rcd;\n    } else {  \n      hosts_best_rcd.push_back(std::make_pair(host, rcd));\n    }\n  }\n\n  std::set<std::string> distinct_hosts;\n  for (const auto& host_rcd : hosts_best_rcd)\n    distinct_hosts.insert(host_rcd.first + host_rcd.second);\n  return distinct_hosts;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186897, "func": " void ManifestChangeNotifier::DidChangeManifest() {\n   if (weak_factory_.HasWeakPtrs())\n     return;\n \n  if (!render_frame()->GetWebFrame()->IsLoading()) {\n    render_frame()\n        ->GetTaskRunner(blink::TaskType::kUnspecedLoading)\n        ->PostTask(FROM_HERE,\n                   base::BindOnce(&ManifestChangeNotifier::ReportManifestChange,\n                                  weak_factory_.GetWeakPtr()));\n    return;\n  }\n  ReportManifestChange();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7826, "func": "  TT_New_Context( TT_Driver  driver )\n  {\n    TT_ExecContext  exec;\n    FT_Memory       memory;\n\n\n    memory = driver->root.root.memory;\n    exec   = driver->context;\n\n    if ( !driver->context )\n    {\n      FT_Error  error;\n\n\n      if ( FT_NEW( exec ) )\n        goto Fail;\n\n      error = Init_Context( exec, memory );\n      if ( error )\n        goto Fail;\n\n      driver->context = exec;\n    }\n\n    return driver->context;\n\n  Fail:\n    return NULL;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186448, "func": "bool ResourceLoader::WillFollowRedirect(\n    const WebURL& new_url,\n    const WebURL& new_site_for_cookies,\n    const WebString& new_referrer,\n    WebReferrerPolicy new_referrer_policy,\n    const WebString& new_method,\n    const WebURLResponse& passed_redirect_response,\n    bool& report_raw_headers) {\n  DCHECK(!passed_redirect_response.IsNull());\n\n  if (is_cache_aware_loading_activated_) {\n    HandleError(\n        ResourceError::CacheMissError(resource_->LastResourceRequest().Url()));\n    return false;\n  }\n\n  const ResourceRequest& last_request = resource_->LastResourceRequest();\n  ResourceRequest new_request(new_url);\n  new_request.SetSiteForCookies(new_site_for_cookies);\n  new_request.SetDownloadToFile(last_request.DownloadToFile());\n  new_request.SetUseStreamOnResponse(last_request.UseStreamOnResponse());\n  new_request.SetRequestContext(last_request.GetRequestContext());\n  new_request.SetFrameType(last_request.GetFrameType());\n  new_request.SetServiceWorkerMode(\n      passed_redirect_response.WasFetchedViaServiceWorker()\n          ? WebURLRequest::ServiceWorkerMode::kAll\n          : WebURLRequest::ServiceWorkerMode::kNone);\n  new_request.SetShouldResetAppCache(last_request.ShouldResetAppCache());\n  new_request.SetFetchRequestMode(last_request.GetFetchRequestMode());\n  new_request.SetFetchCredentialsMode(last_request.GetFetchCredentialsMode());\n  new_request.SetKeepalive(last_request.GetKeepalive());\n  String referrer =\n      new_referrer.IsEmpty() ? Referrer::NoReferrer() : String(new_referrer);\n  new_request.SetHTTPReferrer(\n      Referrer(referrer, static_cast<ReferrerPolicy>(new_referrer_policy)));\n  new_request.SetPriority(last_request.Priority());\n  new_request.SetHTTPMethod(new_method);\n  if (new_request.HttpMethod() == last_request.HttpMethod())\n    new_request.SetHTTPBody(last_request.HttpBody());\n  new_request.SetCheckForBrowserSideNavigation(\n      last_request.CheckForBrowserSideNavigation());\n\n  Resource::Type resource_type = resource_->GetType();\n\n  const ResourceRequest& initial_request = resource_->GetResourceRequest();\n  WebURLRequest::RequestContext request_context =\n      initial_request.GetRequestContext();\n  WebURLRequest::FrameType frame_type = initial_request.GetFrameType();\n  WebURLRequest::FetchRequestMode fetch_request_mode =\n      initial_request.GetFetchRequestMode();\n  WebURLRequest::FetchCredentialsMode fetch_credentials_mode =\n      initial_request.GetFetchCredentialsMode();\n\n  const ResourceLoaderOptions& options = resource_->Options();\n\n  const ResourceResponse& redirect_response(\n      passed_redirect_response.ToResourceResponse());\n\n  new_request.SetRedirectStatus(\n      ResourceRequest::RedirectStatus::kFollowedRedirect);\n\n  if (!IsManualRedirectFetchRequest(initial_request)) {\n    bool unused_preload = resource_->IsUnusedPreload();\n\n    SecurityViolationReportingPolicy reporting_policy =\n        unused_preload ? SecurityViolationReportingPolicy::kSuppressReporting\n                       : SecurityViolationReportingPolicy::kReport;\n\n    Context().CheckCSPForRequest(\n        request_context, new_url, options, reporting_policy,\n        ResourceRequest::RedirectStatus::kFollowedRedirect);\n\n    ResourceRequestBlockedReason blocked_reason = Context().CanRequest(\n        resource_type, new_request, new_url, options, reporting_policy,\n        FetchParameters::kUseDefaultOriginRestrictionForType,\n        ResourceRequest::RedirectStatus::kFollowedRedirect);\n    if (blocked_reason != ResourceRequestBlockedReason::kNone) {\n      CancelForRedirectAccessCheckError(new_url, blocked_reason);\n      return false;\n    }\n\n    if (options.cors_handling_by_resource_fetcher ==\n            kEnableCORSHandlingByResourceFetcher &&\n        fetch_request_mode == WebURLRequest::kFetchRequestModeCORS) {\n      RefPtr<SecurityOrigin> source_origin = options.security_origin;\n      if (!source_origin.get())\n        source_origin = Context().GetSecurityOrigin();\n      WebSecurityOrigin source_web_origin(source_origin.get());\n      WrappedResourceRequest new_request_wrapper(new_request);\n      WebString cors_error_msg;\n      if (!WebCORS::HandleRedirect(\n              source_web_origin, new_request_wrapper, redirect_response.Url(),\n              redirect_response.HttpStatusCode(),\n              redirect_response.HttpHeaderFields(), fetch_credentials_mode,\n              resource_->MutableOptions(), cors_error_msg)) {\n        resource_->SetCORSStatus(CORSStatus::kFailed);\n\n        if (!unused_preload) {\n          Context().AddErrorConsoleMessage(cors_error_msg,\n                                           FetchContext::kJSSource);\n        }\n\n        CancelForRedirectAccessCheckError(new_url,\n                                          ResourceRequestBlockedReason::kOther);\n        return false;\n      }\n\n      source_origin = source_web_origin;\n    }\n    if (resource_type == Resource::kImage &&\n        fetcher_->ShouldDeferImageLoad(new_url)) {\n      CancelForRedirectAccessCheckError(new_url,\n                                        ResourceRequestBlockedReason::kOther);\n      return false;\n    }\n  }\n\n  bool cross_origin =\n      !SecurityOrigin::AreSameSchemeHostPort(redirect_response.Url(), new_url);\n  fetcher_->RecordResourceTimingOnRedirect(resource_.Get(), redirect_response,\n                                           cross_origin);\n\n  if (options.cors_handling_by_resource_fetcher ==\n          kEnableCORSHandlingByResourceFetcher &&\n      fetch_request_mode == WebURLRequest::kFetchRequestModeCORS) {\n    bool allow_stored_credentials = false;\n    switch (fetch_credentials_mode) {\n      case WebURLRequest::kFetchCredentialsModeOmit:\n        break;\n      case WebURLRequest::kFetchCredentialsModeSameOrigin:\n        allow_stored_credentials = !options.cors_flag;\n        break;\n      case WebURLRequest::kFetchCredentialsModeInclude:\n      case WebURLRequest::kFetchCredentialsModePassword:\n        allow_stored_credentials = true;\n        break;\n    }\n    new_request.SetAllowStoredCredentials(allow_stored_credentials);\n  }\n\n\n   Context().PrepareRequest(new_request,\n                            FetchContext::RedirectType::kForRedirect);\n   Context().DispatchWillSendRequest(resource_->Identifier(), new_request,\n                                    redirect_response, options.initiator_info);\n \n  DCHECK(KURL(new_site_for_cookies) == new_request.SiteForCookies());\n\n  DCHECK_EQ(new_request.GetRequestContext(), request_context);\n  DCHECK_EQ(new_request.GetFrameType(), frame_type);\n  DCHECK_EQ(new_request.GetFetchRequestMode(), fetch_request_mode);\n  DCHECK_EQ(new_request.GetFetchCredentialsMode(), fetch_credentials_mode);\n\n  if (new_request.Url() != KURL(new_url)) {\n    CancelForRedirectAccessCheckError(new_request.Url(),\n                                      ResourceRequestBlockedReason::kOther);\n    return false;\n  }\n\n  if (!resource_->WillFollowRedirect(new_request, redirect_response)) {\n    CancelForRedirectAccessCheckError(new_request.Url(),\n                                      ResourceRequestBlockedReason::kOther);\n    return false;\n  }\n\n  report_raw_headers = new_request.ReportRawHeaders();\n\n  return true;\n}\n", "target": 1, "flaw_line_index": "157"}
{"idx": 186422, "func": " void DevToolsUIBindings::RecordEnumeratedHistogram(const std::string& name,\n                                                    int sample,\n                                                    int boundary_value) {\n   if (!(boundary_value >= 0 && boundary_value <= 100 && sample >= 0 &&\n         sample < boundary_value)) {\n    frontend_host_->BadMessageRecieved();\n    return;\n  }\n  if (name == kDevToolsActionTakenHistogram)\n    UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);\n  else if (name == kDevToolsPanelShownHistogram)\n    UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);\n  else\n    frontend_host_->BadMessageRecieved();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7994, "func": "static void vnc_client_cache_auth(VncState *client)\n{\n    if (!client->info) {\n        return;\n    }\n\n#ifdef CONFIG_VNC_TLS\n    if (client->tls.session &&\n        client->tls.dname) {\n        client->info->has_x509_dname = true;\n        client->info->x509_dname = g_strdup(client->tls.dname);\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn &&\n        client->sasl.username) {\n        client->info->has_sasl_username = true;\n        client->info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8297, "func": "_XRRHasOutputPrimary (int major, int minor)\n{\n    return major > 1 || (major == 1 && minor >= 3);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8149, "func": "void Gfx::opSetFont(Object args[], int numArgs) {\n  GfxFont *font;\n\n  if (!(font = res->lookupFont(args[0].getName()))) {\n    state->setFont(NULL, args[1].getNum());\n    fontChanged = gTrue;\n    return;\n  }\n  if (printCommands) {\n    printf(\"  font: tag=%s name='%s' %g\\n\",\n\t   font->getTag()->getCString(),\n\t   font->getName() ? font->getName()->getCString() : \"???\",\n\t   args[1].getNum());\n    fflush(stdout);\n  }\n\n  font->incRefCnt();\n  state->setFont(font, args[1].getNum());\n  fontChanged = gTrue;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186964, "func": "  void MakeCacheAndGroup(const GURL& manifest_url,\n                         int64_t group_id,\n                         int64_t cache_id,\n                          bool add_to_database) {\n     AppCacheEntry default_entry(AppCacheEntry::EXPLICIT,\n                                 cache_id + kDefaultEntryIdOffset,\n                                kDefaultEntrySize);\n     group_ = new AppCacheGroup(storage(), manifest_url, group_id);\n     cache_ = new AppCache(storage(), cache_id);\n     cache_->AddEntry(kDefaultEntryUrl, default_entry);\n    cache_->set_complete(true);\n    group_->AddCache(cache_.get());\n    url::Origin manifest_origin(url::Origin::Create(manifest_url));\n    if (add_to_database) {\n      AppCacheDatabase::GroupRecord group_record;\n      group_record.group_id = group_id;\n      group_record.manifest_url = manifest_url;\n      group_record.origin = manifest_origin;\n      EXPECT_TRUE(database()->InsertGroup(&group_record));\n      AppCacheDatabase::CacheRecord cache_record;\n      cache_record.cache_id = cache_id;\n      cache_record.group_id = group_id;\n       cache_record.online_wildcard = false;\n       cache_record.update_time = kZeroTime;\n       cache_record.cache_size = kDefaultEntrySize;\n       EXPECT_TRUE(database()->InsertCache(&cache_record));\n       AppCacheDatabase::EntryRecord entry_record;\n       entry_record.cache_id = cache_id;\n       entry_record.url = kDefaultEntryUrl;\n       entry_record.flags = default_entry.types();\n       entry_record.response_id = default_entry.response_id();\n       entry_record.response_size = default_entry.response_size();\n       EXPECT_TRUE(database()->InsertEntry(&entry_record));\n \n      storage()->usage_map_[manifest_origin] = default_entry.response_size();\n     }\n   }\n", "target": 1, "flaw_line_index": "7,35"}
{"idx": 187275, "func": "void CredentialManagerImpl::OnProvisionalSaveComplete() {\n  DCHECK(form_manager_);\n  DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage());\n  const autofill::PasswordForm& form = form_manager_->pending_credentials();\n\n  if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {\n    form_manager_->Save();\n    return;\n  }\n\n  if (!form.federation_origin.unique()) {\n    for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) {\n      if (match->username_value == form.username_value &&\n          match->federation_origin.IsSameOriginWith(form.federation_origin)) {\n        form_manager_->Update(*match);\n        return;\n      }\n    }\n  } else if (!form_manager_->IsNewLogin()) {\n    form_manager_->Update(*form_manager_->preferred_match());\n     return;\n   }\n \n  client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187221, "func": "static void composite_close(int sub_api, struct libusb_device_handle *dev_handle)\n{\n \tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n \tuint8_t i;\n \tbool available[SUB_API_MAX];\n\tbool has_hid = false;\n \n \tfor (i = 0; i<SUB_API_MAX; i++) {\n \t\tavailable[i] = false;\n\t}\n\n\tfor (i=0; i<USB_MAXINTERFACES; i++) {\n \t\tif ( (priv->usb_interface[i].apib->id == USB_API_WINUSBX)\n \t\t  && (priv->usb_interface[i].sub_api != SUB_API_NOTSET) ) {\n \t\t\tavailable[priv->usb_interface[i].sub_api] = true;\n\t\t} else if (priv->usb_interface[i].apib->id == USB_API_HID) {\n\t\t\thas_hid = true;\n \t\t}\n \t}\n \n\tfor (i=0; i<SUB_API_MAX; i++) {\n\t\tif (available[i]) {\n \t\t\tusb_api_backend[USB_API_WINUSBX].close(i, dev_handle);\n \t\t}\n \t}\n\tif (has_hid) {\n\t\tusb_api_backend[USB_API_HID].close(sub_api, dev_handle);\n\t}\n }\n", "target": 1, "flaw_line_index": "6,16,17,26,27,28"}
{"idx": 7745, "func": "  TT_Set_MM_Blend( TT_Face    face,\n                   FT_UInt    num_coords,\n                   FT_Fixed*  coords )\n  {\n    FT_Error    error = TT_Err_Ok;\n    GX_Blend    blend;\n    FT_MM_Var*  mmvar;\n    FT_UInt     i;\n    FT_Memory   memory = face->root.memory;\n\n    enum\n    {\n      mcvt_retain,\n      mcvt_modify,\n      mcvt_load\n\n    } manageCvt;\n\n\n    face->doblend = FALSE;\n\n    if ( face->blend == NULL )\n    {\n      if ( (error = TT_Get_MM_Var( face, NULL)) != 0 )\n        goto Exit;\n    }\n\n    blend = face->blend;\n    mmvar = blend->mmvar;\n\n    if ( num_coords != mmvar->num_axis )\n    {\n      error = TT_Err_Invalid_Argument;\n      goto Exit;\n    }\n\n    for ( i = 0; i < num_coords; ++i )\n      if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )\n      {\n        error = TT_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n    if ( blend->glyphoffsets == NULL )\n      if ( (error = ft_var_load_gvar( face )) != 0 )\n        goto Exit;\n\n    if ( blend->normalizedcoords == NULL )\n    {\n      if ( FT_NEW_ARRAY( blend->normalizedcoords, num_coords ) )\n        goto Exit;\n\n      manageCvt = mcvt_modify;\n\n    }\n    else\n    {\n      manageCvt = mcvt_retain;\n      for ( i = 0; i < num_coords; ++i )\n      {\n        if ( blend->normalizedcoords[i] != coords[i] )\n        {\n          manageCvt = mcvt_load;\n          break;\n        }\n      }\n\n    }\n\n    blend->num_axis = num_coords;\n    FT_MEM_COPY( blend->normalizedcoords,\n                 coords,\n                 num_coords * sizeof ( FT_Fixed ) );\n\n    face->doblend = TRUE;\n\n    if ( face->cvt != NULL )\n    {\n      switch ( manageCvt )\n      {\n      case mcvt_load:\n        FT_FREE( face->cvt );\n        face->cvt = NULL;\n\n        tt_face_load_cvt( face, face->root.stream );\n        break;\n\n      case mcvt_modify:\n        tt_face_vary_cvt( face, face->root.stream );\n        break;\n\n      case mcvt_retain:\n        break;\n      }\n    }\n\n  Exit:\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186855, "func": "  void Initialized(mojo::ScopedSharedBufferHandle shared_buffer,\n                   mojo::ScopedHandle socket_handle,\n                   bool initially_muted) {\n    ASSERT_TRUE(shared_buffer.is_valid());\n    ASSERT_TRUE(socket_handle.is_valid());\n\n    base::PlatformFile fd;\n    mojo::UnwrapPlatformFile(std::move(socket_handle), &fd);\n    socket_ = std::make_unique<base::CancelableSyncSocket>(fd);\n    EXPECT_NE(socket_->handle(), base::CancelableSyncSocket::kInvalidHandle);\n \n     size_t memory_length;\n     base::SharedMemoryHandle shmem_handle;\n    bool read_only;\n     EXPECT_EQ(\n         mojo::UnwrapSharedMemoryHandle(std::move(shared_buffer), &shmem_handle,\n                                       &memory_length, &read_only),\n         MOJO_RESULT_OK);\n    EXPECT_TRUE(read_only);\n    buffer_ = std::make_unique<base::SharedMemory>(shmem_handle, read_only);\n \n     GotNotification(initially_muted);\n   }\n", "target": 1, "flaw_line_index": "14,17,19,20"}
{"idx": 7713, "func": "static int coroutine_fn v9fs_complete_renameat(V9fsPDU *pdu, int32_t olddirfid,\n                                               V9fsString *old_name,\n                                               int32_t newdirfid,\n                                               V9fsString *new_name)\n{\n    int err = 0;\n    V9fsState *s = pdu->s;\n    V9fsFidState *newdirfidp = NULL, *olddirfidp = NULL;\n\n    olddirfidp = get_fid(pdu, olddirfid);\n    if (olddirfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    if (newdirfid != -1) {\n        newdirfidp = get_fid(pdu, newdirfid);\n        if (newdirfidp == NULL) {\n            err = -ENOENT;\n            goto out;\n        }\n    } else {\n        newdirfidp = get_fid(pdu, olddirfid);\n    }\n\n    err = v9fs_co_renameat(pdu, &olddirfidp->path, old_name,\n                           &newdirfidp->path, new_name);\n    if (err < 0) {\n        goto out;\n    }\n    if (s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT) {\n        v9fs_fix_fid_paths(pdu, &olddirfidp->path, old_name,\n                           &newdirfidp->path, new_name);\n    }\nout:\n    if (olddirfidp) {\n        put_fid(pdu, olddirfidp);\n    }\n    if (newdirfidp) {\n        put_fid(pdu, newdirfidp);\n    }\n    return err;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186400, "func": "void InputHandlerProxy::InjectScrollbarGestureScroll(\n    const WebInputEvent::Type type,\n    const blink::WebFloatPoint& position_in_widget,\n    const cc::InputHandlerPointerResult& pointer_result,\n    const LatencyInfo& latency_info,\n    const base::TimeTicks original_timestamp) {\n  gfx::Vector2dF scroll_delta(pointer_result.scroll_offset.x(),\n                              pointer_result.scroll_offset.y());\n  std::unique_ptr<WebGestureEvent> synthetic_gesture_event =\n      GenerateInjectedScrollGesture(\n          type, original_timestamp, blink::WebGestureDevice::kScrollbar,\n          position_in_widget, scroll_delta,\n          pointer_result.scroll_units);\n\n  WebScopedInputEvent web_scoped_gesture_event(\n      synthetic_gesture_event.release());\n\n  LatencyInfo scrollbar_latency_info(latency_info);\n  scrollbar_latency_info.set_source_event_type(ui::SourceEventType::SCROLLBAR);\n\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n    last_injected_gesture_was_begin_ = true;\n  } else {\n    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n          (last_injected_gesture_was_begin_)\n              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n          original_timestamp, 1);\n    }\n    last_injected_gesture_was_begin_ = false;\n  }\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,\n          original_timestamp, original_timestamp, nullptr);\n\n  bool needs_animate_input = compositor_event_queue_->empty();\n  compositor_event_queue_->Queue(std::move(gesture_event_with_callback_update),\n                                 original_timestamp);\n\n  if (needs_animate_input)\n    input_handler_->SetNeedsAnimateInput();\n}\n", "target": 1, "flaw_line_index": "31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46"}
{"idx": 7418, "func": "ZEND_API void zend_ts_hash_copy_to_hash(HashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor)\n{\n\tbegin_read(source);\n\tzend_hash_copy(target, TS_HASH(source), pCopyConstructor);\n\tend_read(source);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186540, "func": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n      current_entry_.reset(provisional_entry_.release());\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 7751, "func": "  ft_var_readpackeddeltas( FT_Stream  stream,\n                           FT_Offset  delta_cnt )\n  {\n    FT_Short  *deltas = NULL;\n    FT_UInt    runcnt;\n    FT_Offset  i;\n    FT_UInt    j;\n    FT_Memory  memory = stream->memory;\n    FT_Error   error  = TT_Err_Ok;\n\n    FT_UNUSED( error );\n\n\n    if ( FT_NEW_ARRAY( deltas, delta_cnt ) )\n      return NULL;\n\n    i = 0;\n    while ( i < delta_cnt )\n    {\n      runcnt = FT_GET_BYTE();\n      if ( runcnt & GX_DT_DELTAS_ARE_ZERO )\n      {\n        for ( j = 0;\n              j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;\n              ++j )\n          deltas[i++] = 0;\n      }\n      else if ( runcnt & GX_DT_DELTAS_ARE_WORDS )\n      {\n        for ( j = 0;\n              j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;\n              ++j )\n          deltas[i++] = FT_GET_SHORT();\n      }\n      else\n      {\n        for ( j = 0;\n              j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;\n              ++j )\n          deltas[i++] = FT_GET_CHAR();\n      }\n\n      if ( j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) )\n      {\n        FT_FREE( deltas );\n        return NULL;\n      }\n    }\n\n    return deltas;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7990, "func": "static VncBasicInfo *vnc_basic_info_get(struct sockaddr_storage *sa,\n                                        socklen_t salen)\n{\n    VncBasicInfo *info;\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    int err;\n\n    if ((err = getnameinfo((struct sockaddr *)sa, salen,\n                           host, sizeof(host),\n                           serv, sizeof(serv),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        VNC_DEBUG(\"Cannot resolve address %d: %s\\n\",\n                  err, gai_strerror(err));\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(VncBasicInfo));\n    info->host = g_strdup(host);\n    info->service = g_strdup(serv);\n    info->family = inet_netfamily(sa->ss_family);\n    return info;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8027, "func": "void vnc_init_state(VncState *vs)\n{\n    vs->initialized = true;\n    VncDisplay *vd = vs->vd;\n\n    vs->last_x = -1;\n    vs->last_y = -1;\n\n    vs->as.freq = 44100;\n    vs->as.nchannels = 2;\n    vs->as.fmt = AUD_FMT_S16;\n    vs->as.endianness = 0;\n\n    qemu_mutex_init(&vs->output_mutex);\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n    QTAILQ_INSERT_HEAD(&vd->clients, vs, next);\n\n    graphic_hw_update(NULL);\n\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n    vnc_flush(vs);\n    vnc_read_when(vs, protocol_version, 12);\n    reset_keys(vs);\n    if (vs->vd->lock_key_sync)\n        vs->led = qemu_add_led_event_handler(kbd_leds, vs);\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187040, "func": "void DocumentLoader::DidInstallNewDocument(\n    Document* document,\n    const ContentSecurityPolicy* previous_csp) {\n   document->SetReadyState(Document::kLoading);\n   if (content_security_policy_) {\n    document->InitContentSecurityPolicy(content_security_policy_.Release(),\n                                        nullptr, previous_csp);\n   }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n    document->SetStateForNewFormElements(history_item_->GetDocumentState());\n\n  DCHECK(document->GetFrame());\n  document->GetFrame()->GetClientHintsPreferences().UpdateFrom(\n      client_hints_preferences_);\n\n  Settings* settings = document->GetSettings();\n  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());\n  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());\n\n  const AtomicString& dns_prefetch_control =\n      response_.HttpHeaderField(http_names::kXDNSPrefetchControl);\n  if (!dns_prefetch_control.IsEmpty())\n    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);\n\n  String header_content_language =\n      response_.HttpHeaderField(http_names::kContentLanguage);\n  if (!header_content_language.IsEmpty()) {\n    wtf_size_t comma_index = header_content_language.find(',');\n    header_content_language.Truncate(comma_index);\n    header_content_language =\n        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);\n    if (!header_content_language.IsEmpty())\n      document->SetContentLanguage(AtomicString(header_content_language));\n  }\n\n  String referrer_policy_header =\n      response_.HttpHeaderField(http_names::kReferrerPolicy);\n  if (!referrer_policy_header.IsNull()) {\n    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);\n    document->ParseAndSetReferrerPolicy(referrer_policy_header);\n  }\n\n  if (response_.IsSignedExchangeInnerResponse())\n    UseCounter::Count(*document, WebFeature::kSignedExchangeInnerResponse);\n\n  GetLocalFrameClient().DidCreateNewDocument();\n}\n", "target": 1, "flaw_line_index": "2,3,6,7"}
{"idx": 7867, "func": "void ram_mig_init(void)\n{\n    qemu_mutex_init(&XBZRLE.lock);\n    register_savevm_live(NULL, \"ram\", 0, 4, &savevm_ram_handlers, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186524, "func": " bool DataReductionProxySettings::IsDataReductionProxyManaged() {\n  return spdy_proxy_auth_enabled_.IsManaged();\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8219, "func": "static void v9fs_lcreate(void *opaque)\n{\n    int32_t dfid, flags, mode;\n    gid_t gid;\n    ssize_t err = 0;\n    ssize_t offset = 7;\n    V9fsString name;\n    V9fsFidState *fidp;\n    struct stat stbuf;\n    V9fsQID qid;\n    int32_t iounit;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsddd\", &dfid,\n                        &name, &flags, &mode, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_lcreate(pdu->tag, pdu->id, dfid, flags, mode, gid);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, dfid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    flags = get_dotl_openflags(pdu->s, flags);\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n                        flags | O_CREAT, mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    fidp->fid_type = P9_FID_FILE;\n    fidp->open_flags = flags;\n    if (flags & O_EXCL) {\n        fidp->flags |= FID_NON_RECLAIMABLE;\n    }\n    iounit =  get_iounit(pdu, &fidp->path);\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path, iounit);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186580, "func": " MediaRecorderHandler::~MediaRecorderHandler() {\n   DCHECK(main_render_thread_checker_.CalledOnValidThread());\n  if (client_)\n     client_->WriteData(\n         nullptr, 0u, true,\n         (TimeTicks::Now() - TimeTicks::UnixEpoch()).InMillisecondsF());\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8071, "func": "GBool Gfx::contentIsHidden() {\n  MarkedContentStack *mc = mcStack;\n  bool hidden = mc && mc->ocSuppressed;\n  while (!hidden && mc && mc->next) {\n    mc = mc->next;\n    hidden = mc->ocSuppressed;\n  }\n  return hidden;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7836, "func": "void audio_init(void)\n{\n    struct soundhw *c;\n    ISABus *isa_bus = (ISABus *) object_resolve_path_type(\"\", TYPE_ISA_BUS, NULL);\n    PCIBus *pci_bus = (PCIBus *) object_resolve_path_type(\"\", TYPE_PCI_BUS, NULL);\n\n    for (c = soundhw; c->name; ++c) {\n        if (c->enabled) {\n            if (c->isa) {\n                if (!isa_bus) {\n                    error_report(\"ISA bus not available for %s\", c->name);\n                    exit(1);\n                }\n                c->init.init_isa(isa_bus);\n            } else {\n                if (!pci_bus) {\n                    error_report(\"PCI bus not available for %s\", c->name);\n                    exit(1);\n                }\n                c->init.init_pci(pci_bus);\n            }\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7858, "func": "int qemu_read_default_config_files(bool userconfig)\n{\n    int ret;\n    struct defconfig_file *f;\n\n    for (f = default_config_files; f->filename; f++) {\n        if (!userconfig && f->userconfig) {\n            continue;\n        }\n        ret = qemu_read_config_file(f->filename);\n        if (ret < 0 && ret != -ENOENT) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186917, "func": "void QuicClientPromisedInfo::OnPromiseHeaders(const SpdyHeaderBlock& headers) {\n   SpdyHeaderBlock::const_iterator it = headers.find(kHttp2MethodHeader);\n  DCHECK(it != headers.end());\n   if (!(it->second == \"GET\" || it->second == \"HEAD\")) {\n     QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid method \"\n                   << it->second;\n    Reset(QUIC_INVALID_PROMISE_METHOD);\n    return;\n  }\n  if (!SpdyUtils::UrlIsValid(headers)) {\n    QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid URL \"\n                  << url_;\n    Reset(QUIC_INVALID_PROMISE_URL);\n    return;\n  }\n  if (!session_->IsAuthorized(SpdyUtils::GetHostNameFromHeaderBlock(headers))) {\n    Reset(QUIC_UNAUTHORIZED_PROMISE_URL);\n    return;\n  }\n  request_headers_.reset(new SpdyHeaderBlock(headers.Clone()));\n}\n", "target": 1, "flaw_line_index": "5"}
{"idx": 186338, "func": "void LoadingStatsCollector::CleanupAbandonedStats() {\n   base::TimeTicks time_now = base::TimeTicks::Now();\n   for (auto it = preconnect_stats_.begin(); it != preconnect_stats_.end();) {\n     if (time_now - it->second->start_time > max_stats_age_) {\n      ReportPreconnectAccuracy(*it->second,\n                               std::map<GURL, OriginRequestSummary>());\n       it = preconnect_stats_.erase(it);\n     } else {\n       ++it;\n    }\n  }\n}\n", "target": 1, "flaw_line_index": "5,6"}
{"idx": 7954, "func": "uint8_t *buffer_end(Buffer *buffer)\n{\n    return buffer->buffer + buffer->offset;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7750, "func": "  ft_var_load_gvar( TT_Face  face )\n  {\n    FT_Stream     stream = FT_FACE_STREAM(face);\n    FT_Memory     memory = stream->memory;\n    GX_Blend      blend  = face->blend;\n    FT_Error      error;\n    FT_UInt       i, j;\n    FT_ULong      table_len;\n    FT_ULong      gvar_start;\n    FT_ULong      offsetToData;\n    GX_GVar_Head  gvar_head;\n\n    static const FT_Frame_Field  gvar_fields[] =\n    {\n\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  GX_GVar_Head\n\n      FT_FRAME_START( 20 ),\n        FT_FRAME_LONG  ( version ),\n        FT_FRAME_USHORT( axisCount ),\n        FT_FRAME_USHORT( globalCoordCount ),\n        FT_FRAME_ULONG ( offsetToCoord ),\n        FT_FRAME_USHORT( glyphCount ),\n        FT_FRAME_USHORT( flags ),\n        FT_FRAME_ULONG ( offsetToData ),\n      FT_FRAME_END\n    };\n\n    if ( (error = face->goto_table( face, TTAG_gvar, stream, &table_len )) != 0 )\n      goto Exit;\n\n    gvar_start = FT_STREAM_POS( );\n    if ( FT_STREAM_READ_FIELDS( gvar_fields, &gvar_head ) )\n      goto Exit;\n\n    blend->tuplecount  = gvar_head.globalCoordCount;\n    blend->gv_glyphcnt = gvar_head.glyphCount;\n    offsetToData       = gvar_start + gvar_head.offsetToData;\n\n    if ( gvar_head.version   != (FT_Long)0x00010000L              ||\n         gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )\n    {\n      error = TT_Err_Invalid_Table;\n      goto Exit;\n    }\n\n    if ( FT_NEW_ARRAY( blend->glyphoffsets, blend->gv_glyphcnt + 1 ) )\n      goto Exit;\n\n    if ( gvar_head.flags & 1 )\n    {\n      if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 4L ) )\n        goto Exit;\n\n      for ( i = 0; i <= blend->gv_glyphcnt; ++i )\n        blend->glyphoffsets[i] = offsetToData + FT_GET_LONG();\n\n      FT_FRAME_EXIT();\n    }\n    else\n    {\n      if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 2L ) )\n        goto Exit;\n\n      for ( i = 0; i <= blend->gv_glyphcnt; ++i )\n        blend->glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;\n\n      FT_FRAME_EXIT();\n    }\n\n    if ( blend->tuplecount != 0 )\n    {\n      if ( FT_NEW_ARRAY( blend->tuplecoords,\n                         gvar_head.axisCount * blend->tuplecount ) )\n        goto Exit;\n\n      if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )       ||\n           FT_FRAME_ENTER( blend->tuplecount * gvar_head.axisCount * 2L )                   )\n        goto Exit;\n\n      for ( i = 0; i < blend->tuplecount; ++i )\n        for ( j = 0 ; j < (FT_UInt)gvar_head.axisCount; ++j )\n          blend->tuplecoords[i * gvar_head.axisCount + j] =\n            FT_GET_SHORT() << 2;                \n\n      FT_FRAME_EXIT();\n    }\n\n  Exit:\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7778, "func": "static void h2_send(struct connection *conn)\n{\n\tstruct h2c *h2c = conn->mux_ctx;\n\tint done;\n\n\tif (conn->flags & CO_FL_ERROR)\n\t\treturn;\n\n\tif (conn->flags & (CO_FL_HANDSHAKE|CO_FL_WAIT_L4_CONN|CO_FL_WAIT_L6_CONN)) {\n\t\treturn;\n\t}\n\n\n\tdone = 0;\n\twhile (!done) {\n\t\tunsigned int flags = 0;\n\n\t\twhile (((h2c->flags & (H2_CF_MUX_MFULL|H2_CF_MUX_MALLOC)) == 0) && !done)\n\t\t\tdone = h2_process_mux(h2c);\n\n\t\tif (conn->flags & CO_FL_ERROR)\n\t\t\tbreak;\n\n\t\tif (h2c->flags & (H2_CF_MUX_MFULL | H2_CF_DEM_MBUSY | H2_CF_DEM_MROOM))\n\t\t\tflags |= CO_SFL_MSG_MORE;\n\n\t\tif (h2c->mbuf->o && conn->xprt->snd_buf(conn, h2c->mbuf, flags) <= 0)\n\t\t\tbreak;\n\n\t\th2c->flags &= ~(H2_CF_MUX_MFULL | H2_CF_DEM_MROOM);\n\t}\n\n\tif (conn->flags & CO_FL_SOCK_WR_SH) {\n\t\th2c->mbuf->o = 0;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186768, "func": "void SharedWorkerDevToolsAgentHost::WorkerRestarted(\n    SharedWorkerHost* worker_host) {\n  DCHECK_EQ(WORKER_TERMINATED, state_);\n  DCHECK(!worker_host_);\n   state_ = WORKER_NOT_READY;\n   worker_host_ = worker_host;\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(GetProcess(), nullptr);\n }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 8177, "func": "void Gfx::popStateGuard() {\n    while (stackHeight > bottomGuard() && state->hasSaves())\n\trestoreState();\n    stateGuards.pop_back();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186605, "func": "UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n    : url_(url),\n      have_data_origin_(false),\n      cors_mode_(cors_mode),\n      url_index_(url_index),\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8025, "func": "void vnc_flush(VncState *vs)\n{\n    vnc_lock_output(vs);\n    if (vs->csock != -1 && (vs->output.offset\n#ifdef CONFIG_VNC_WS\n                || vs->ws_output.offset\n#endif\n                )) {\n        vnc_client_write_locked(vs);\n    }\n    vnc_unlock_output(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7464, "func": "void DBusHelperProxy::stopAction(const QString &action)\n{\n    Q_UNUSED(action)\n    m_stopRequest = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8103, "func": "GfxShading *GfxResources::lookupShading(char *name, Gfx *gfx) {\n  GfxResources *resPtr;\n  GfxShading *shading;\n  Object obj;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->shadingDict.isDict()) {\n      if (!resPtr->shadingDict.dictLookup(name, &obj)->isNull()) {\n\tshading = GfxShading::parse(&obj, gfx);\n\tobj.free();\n\treturn shading;\n      }\n      obj.free();\n    }\n  }\n  error(-1, \"Unknown shading '%s'\", name);\n  return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7693, "func": "static void handle_seekdir(FsContext *ctx, V9fsFidOpenState *fs, off_t off)\n{\n    seekdir(fs->dir.stream, off);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186757, "func": "void TargetHandler::SetRenderer(RenderProcessHost* process_host,\n                                 RenderFrameHostImpl* frame_host) {\n   auto_attacher_.SetRenderFrameHost(frame_host);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8011, "func": "static void vnc_desktop_resize(VncState *vs)\n{\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == pixman_image_get_width(vs->vd->server) &&\n        vs->client_height == pixman_image_get_height(vs->vd->server)) {\n        return;\n    }\n    vs->client_width = pixman_image_get_width(vs->vd->server);\n    vs->client_height = pixman_image_get_height(vs->vd->server);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); \n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186956, "func": " int64_t AppCacheDatabase::GetOriginUsage(const url::Origin& origin) {\n  std::vector<CacheRecord> records;\n  if (!FindCachesForOrigin(origin, &records))\n     return 0;\n \n   int64_t origin_usage = 0;\n  for (const auto& record : records)\n    origin_usage += record.cache_size;\n   return origin_usage;\n }\n", "target": 1, "flaw_line_index": "2,3,7,8"}
{"idx": 186337, "func": " bool AddInitialUrlToPreconnectPrediction(const GURL& initial_url,\n                                          PreconnectPrediction* prediction) {\n  GURL initial_origin = initial_url.GetOrigin();\n  static const int kMinSockets = 2;\n\n  if (!prediction->requests.empty() &&\n       prediction->requests.front().origin == initial_origin) {\n     prediction->requests.front().num_sockets =\n         std::max(prediction->requests.front().num_sockets, kMinSockets);\n  } else if (initial_origin.is_valid() &&\n             initial_origin.SchemeIsHTTPOrHTTPS()) {\n    url::Origin origin = url::Origin::Create(initial_origin);\n    prediction->requests.emplace(prediction->requests.begin(), initial_origin,\n                                 kMinSockets,\n                                 net::NetworkIsolationKey(origin, origin));\n   }\n \n   return !prediction->requests.empty();\n}\n", "target": 1, "flaw_line_index": "3,14,15,16,17,18,19"}
{"idx": 7853, "func": "static void migration_bitmap_sync_range(ram_addr_t start, ram_addr_t length)\n{\n    ram_addr_t addr;\n    unsigned long page = BIT_WORD(start >> TARGET_PAGE_BITS);\n\n    if (((page * BITS_PER_LONG) << TARGET_PAGE_BITS) == start) {\n        int k;\n        int nr = BITS_TO_LONGS(length >> TARGET_PAGE_BITS);\n        unsigned long *src = ram_list.dirty_memory[DIRTY_MEMORY_MIGRATION];\n\n        for (k = page; k < page + nr; k++) {\n            if (src[k]) {\n                unsigned long new_dirty;\n                new_dirty = ~migration_bitmap[k];\n                migration_bitmap[k] |= src[k];\n                new_dirty &= src[k];\n                migration_dirty_pages += ctpopl(new_dirty);\n                src[k] = 0;\n            }\n        }\n    } else {\n        for (addr = 0; addr < length; addr += TARGET_PAGE_SIZE) {\n            if (cpu_physical_memory_get_dirty(start + addr,\n                                              TARGET_PAGE_SIZE,\n                                              DIRTY_MEMORY_MIGRATION)) {\n                cpu_physical_memory_reset_dirty(start + addr,\n                                                TARGET_PAGE_SIZE,\n                                                DIRTY_MEMORY_MIGRATION);\n                migration_bitmap_set_dirty(start + addr);\n            }\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7859, "func": "int qemu_uuid_parse(const char *str, uint8_t *uuid)\n{\n    int ret;\n\n    if (strlen(str) != 36) {\n        return -1;\n    }\n\n    ret = sscanf(str, UUID_FMT, &uuid[0], &uuid[1], &uuid[2], &uuid[3],\n                 &uuid[4], &uuid[5], &uuid[6], &uuid[7], &uuid[8], &uuid[9],\n                 &uuid[10], &uuid[11], &uuid[12], &uuid[13], &uuid[14],\n                 &uuid[15]);\n\n    if (ret != 16) {\n        return -1;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7828, "func": "  TT_Save_Context( TT_ExecContext  exec,\n                   TT_Size         size )\n  {\n    FT_Int  i;\n\n\n    size->num_function_defs    = exec->numFDefs;\n    size->num_instruction_defs = exec->numIDefs;\n\n    size->max_func = exec->maxFunc;\n    size->max_ins  = exec->maxIns;\n\n    for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )\n      size->codeRangeTable[i] = exec->codeRangeTable[i];\n\n    return TT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7687, "func": "static struct dirent *handle_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return readdir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7727, "func": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186441, "func": " void FrameFetchContext::DispatchDidBlockRequest(\n     const ResourceRequest& resource_request,\n     const FetchInitiatorInfo& fetch_initiator_info,\n    ResourceRequestBlockedReason blocked_reason) const {\n   if (IsDetached())\n     return;\n   probe::didBlockRequest(GetFrame()->GetDocument(), resource_request,\n                          MasterDocumentLoader(), fetch_initiator_info,\n                         blocked_reason);\n }\n", "target": 1, "flaw_line_index": "4,9"}
{"idx": 7759, "func": "static void h2_detach(struct conn_stream *cs)\n{\n\tstruct h2s *h2s = cs->ctx;\n\tstruct h2c *h2c;\n\n\tcs->ctx = NULL;\n\tif (!h2s)\n\t\treturn;\n\n\th2c = h2s->h2c;\n\th2s->cs = NULL;\n\n\tif (!(cs->conn->flags & CO_FL_ERROR) &&\n\t    (h2s->flags & (H2_SF_BLK_MBUSY | H2_SF_BLK_MROOM | H2_SF_BLK_MFCTL)))\n\t\treturn;\n\n\tif ((h2c->flags & H2_CF_DEM_BLOCK_ANY && h2s->id == h2c->dsi) ||\n\t    (h2c->flags & H2_CF_MUX_BLOCK_ANY && h2s->id == h2c->msi)) {\n\t\th2c->flags &= ~H2_CF_DEM_BLOCK_ANY;\n\t\th2c->flags &= ~H2_CF_MUX_BLOCK_ANY;\n\t\tconn_xprt_want_recv(cs->conn);\n\t\tconn_xprt_want_send(cs->conn);\n\t}\n\n\th2s_destroy(h2s);\n\n\tif (eb_is_empty(&h2c->streams_by_id) &&     \n\t    ((h2c->conn->flags & CO_FL_ERROR) ||    \n\t     (h2c->flags & H2_CF_GOAWAY_FAILED) ||\n\t     (!h2c->mbuf->o &&  \n\t      (conn_xprt_read0_pending(h2c->conn) ||\n\t       (h2c->last_sid >= 0 && h2c->max_id >= h2c->last_sid))))) {\n\t\th2_release(h2c->conn);\n\t}\n\telse if (h2c->task) {\n\t\tif (eb_is_empty(&h2c->streams_by_id) || h2c->mbuf->o) {\n\t\t\th2c->task->expire = tick_add(now_ms, h2c->last_sid < 0 ? h2c->timeout : h2c->shut_timeout);\n\t\t\ttask_queue(h2c->task);\n\t\t}\n\t\telse\n\t\t\th2c->task->expire = TICK_ETERNITY;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8200, "func": "static int fid_to_qid(V9fsPDU *pdu, V9fsFidState *fidp, V9fsQID *qidp)\n{\n    struct stat stbuf;\n    int err;\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        return err;\n    }\n    stat_to_qid(&stbuf, qidp);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8057, "func": "void vnc_write_u32(VncState *vs, uint32_t value)\n{\n    uint8_t buf[4];\n\n    buf[0] = (value >> 24) & 0xFF;\n    buf[1] = (value >> 16) & 0xFF;\n    buf[2] = (value >>  8) & 0xFF;\n    buf[3] = value & 0xFF;\n\n    vnc_write(vs, buf, 4);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7864, "func": "static int ram_find_and_save_block(QEMUFile *f, bool last_stage)\n{\n    RAMBlock *block = last_seen_block;\n    ram_addr_t offset = last_offset;\n    bool complete_round = false;\n    int bytes_sent = 0;\n    MemoryRegion *mr;\n\n    if (!block)\n        block = QTAILQ_FIRST(&ram_list.blocks);\n\n    while (true) {\n        mr = block->mr;\n        offset = migration_bitmap_find_and_reset_dirty(mr, offset);\n        if (complete_round && block == last_seen_block &&\n            offset >= last_offset) {\n            break;\n        }\n        if (offset >= block->length) {\n            offset = 0;\n            block = QTAILQ_NEXT(block, next);\n            if (!block) {\n                block = QTAILQ_FIRST(&ram_list.blocks);\n                complete_round = true;\n                ram_bulk_stage = false;\n            }\n        } else {\n            bytes_sent = ram_save_page(f, block, offset, last_stage);\n\n            if (bytes_sent > 0) {\n                last_sent_block = block;\n                break;\n            }\n        }\n    }\n    last_seen_block = block;\n    last_offset = offset;\n\n    return bytes_sent;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7642, "func": "static int proxy_parse_opts(QemuOpts *opts, struct FsDriverEntry *fs)\n{\n    const char *socket = qemu_opt_get(opts, \"socket\");\n    const char *sock_fd = qemu_opt_get(opts, \"sock_fd\");\n\n    if (!socket && !sock_fd) {\n        error_report(\"Must specify either socket or sock_fd\");\n        return -1;\n    }\n    if (socket && sock_fd) {\n        error_report(\"Both socket and sock_fd options specified\");\n        return -1;\n    }\n    if (socket) {\n        fs->path = g_strdup(socket);\n        fs->export_flags = V9FS_PROXY_SOCK_NAME;\n    } else {\n        fs->path = g_strdup(sock_fd);\n        fs->export_flags = V9FS_PROXY_SOCK_FD;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7549, "func": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t\treturn 0;\n\t}\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187142, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n           \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n           \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n          \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1] > 3\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186371, "func": "void TabletModeWindowState::LeaveTabletMode(wm::WindowState* window_state) {\n   EnterAnimationType animation_type =\n      window_state->IsSnapped() || IsTopWindow(window_state->window())\n           ? DEFAULT\n           : IMMEDIATE;\n   if (old_state_->GetType() == window_state->GetStateType() &&\n      !window_state->IsNormalStateType()) {\n    animation_type = IMMEDIATE;\n  }\n  old_state_->set_enter_animation_type(animation_type);\n  std::unique_ptr<wm::WindowState::State> our_reference =\n      window_state->SetStateObject(std::move(old_state_));\n}\n", "target": 1, "flaw_line_index": "2,3,4,6"}
{"idx": 186417, "func": "ScriptPromise Bluetooth::requestLEScan(ScriptState* script_state,\n                                       const BluetoothLEScanOptions* options,\n                                       ExceptionState& exception_state) {\n  ExecutionContext* context = ExecutionContext::From(script_state);\n  DCHECK(context);\n\n  context->AddConsoleMessage(ConsoleMessage::Create(\n      mojom::ConsoleMessageSource::kJavaScript,\n      mojom::ConsoleMessageLevel::kInfo,\n      \"Web Bluetooth Scanning is experimental on this platform. See \"\n      \"https:\n      \"implementation-status.md\"));\n\n  CHECK(context->IsSecureContext());\n\n  auto& doc = *To<Document>(context);\n  auto* frame = doc.GetFrame();\n  if (!frame) {\n    return ScriptPromise::Reject(\n        script_state, V8ThrowException::CreateTypeError(\n                          script_state->GetIsolate(), \"Document not active\"));\n  }\n\n  if (!LocalFrame::HasTransientUserActivation(frame)) {\n    return ScriptPromise::RejectWithDOMException(\n        script_state,\n        MakeGarbageCollected<DOMException>(\n            DOMExceptionCode::kSecurityError,\n             \"Must be handling a user gesture to show a permission request.\"));\n   }\n \n  if (!service_) {\n    frame->GetInterfaceProvider().GetInterface(mojo::MakeRequest(\n        &service_, context->GetTaskRunner(TaskType::kMiscPlatformAPI)));\n  }\n \n   auto scan_options = mojom::blink::WebBluetoothRequestLEScanOptions::New();\n   ConvertRequestLEScanOptions(options, scan_options, exception_state);\n\n  if (exception_state.HadException())\n    return ScriptPromise();\n\n  Platform::Current()->RecordRapporURL(\"Bluetooth.APIUsage.Origin\", doc.Url());\n\n  auto* resolver = MakeGarbageCollected<ScriptPromiseResolver>(script_state);\n  ScriptPromise promise = resolver->Promise();\n\n  mojom::blink::WebBluetoothScanClientAssociatedPtrInfo client;\n  mojo::BindingId id = client_bindings_.AddBinding(\n      this, mojo::MakeRequest(&client),\n      context->GetTaskRunner(TaskType::kMiscPlatformAPI));\n\n  service_->RequestScanningStart(\n      std::move(client), std::move(scan_options),\n      WTF::Bind(&Bluetooth::RequestScanningCallback, WrapPersistent(this),\n                WrapPersistent(resolver), id));\n\n  return promise;\n}\n", "target": 1, "flaw_line_index": "36,37,38,39,40"}
{"idx": 8256, "func": "Status _xvmc_destroy_subpicture(\n    Display *dpy,\n    XvMCSubpicture *subpicture\n)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcDestroySubpictureReq  *req;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (DestroySubpicture, req);\n    req->subpicture_id = subpicture->subpicture_id;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return Success;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187065, "func": " void PaymentRequest::Complete(mojom::PaymentComplete result) {\n  if (!client_.is_bound())\n     return;\n \n  if (result == mojom::PaymentComplete::FAIL) {\n    delegate_->ShowErrorMessage();\n  } else {\n    DCHECK(!has_recorded_completion_);\n    journey_logger_.SetCompleted();\n    has_recorded_completion_ = true;\n\n    delegate_->GetPrefService()->SetBoolean(kPaymentsFirstTransactionCompleted,\n                                            true);\n    client_->OnComplete();\n    state_->RecordUseStats();\n  }\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186393, "func": " void WarmupURLFetcher::FetchWarmupURLNow(\n     const DataReductionProxyServer& proxy_server) {\n   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n \n   UMA_HISTOGRAM_EXACT_LINEAR(\"DataReductionProxy.WarmupURL.FetchInitiated\", 1,\n                              2);\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\"data_reduction_proxy_warmup\", R\"(\n          semantics {\n            sender: \"Data Reduction Proxy\"\n            description:\n              \"Sends a request to the Data Reduction Proxy server to warm up \"\n              \"the connection to the proxy.\"\n            trigger:\n              \"A network change while the data reduction proxy is enabled will \"\n              \"trigger this request.\"\n            data: \"A specific URL, not related to user data.\"\n            destination: GOOGLE_OWNED_SERVICE\n          }\n          policy {\n            cookies_allowed: NO\n            setting:\n              \"Users can control Data Saver on Android via the 'Data Saver' \"\n              \"setting. Data Saver is not available on iOS, and on desktop it \"\n              \"is enabled by installing the Data Saver extension.\"\n            policy_exception_justification: \"Not implemented.\"\n          })\");\n\n  GURL warmup_url_with_query_params;\n  GetWarmupURLWithQueryParam(&warmup_url_with_query_params);\n\n  url_loader_.reset();\n  fetch_timeout_timer_.Stop();\n  is_fetch_in_flight_ = true;\n\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n  resource_request->url = warmup_url_with_query_params;\n  resource_request->load_flags = net::LOAD_BYPASS_CACHE;\n\n  resource_request->render_frame_id = MSG_ROUTING_CONTROL;\n\n  url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),\n                                                 traffic_annotation);\n  static const int kMaxRetries = 5;\n  url_loader_->SetRetryOptions(\n      kMaxRetries, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE);\n  url_loader_->SetAllowHttpErrorResults(true);\n\n  fetch_timeout_timer_.Start(FROM_HERE, GetFetchTimeout(), this,\n                             &WarmupURLFetcher::OnFetchTimeout);\n\n  url_loader_->SetOnResponseStartedCallback(base::BindOnce(\n      &WarmupURLFetcher::OnURLLoadResponseStarted, base::Unretained(this)));\n  url_loader_->SetOnRedirectCallback(base::BindRepeating(\n      &WarmupURLFetcher::OnURLLoaderRedirect, base::Unretained(this)));\n\n  url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(\n      GetNetworkServiceURLLoaderFactory(proxy_server),\n      base::BindOnce(&WarmupURLFetcher::OnURLLoadComplete,\n                     base::Unretained(this)));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187083, "func": "   std::unique_ptr<FakeMediaStreamUIProxy> CreateMockUI(bool expect_started) {\n     std::unique_ptr<MockMediaStreamUIProxy> fake_ui =\n         std::make_unique<MockMediaStreamUIProxy>();\n     if (expect_started)\n       EXPECT_CALL(*fake_ui, MockOnStarted(_));\n     return fake_ui;\n  }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8068, "func": "static void bubbleSort(double array[])\n{\n  for (int j = 0; j < 3; ++j) {\n    int kk = j;\n    for (int k = j + 1; k < 4; ++k) {\n      if (array[k] < array[kk]) {\n        kk = k;\n      }\n    }\n    double tmp = array[j];\n    array[j] = array[kk];\n    array[kk] = tmp;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8034, "func": "static void vnc_qmp_event(VncState *vs, QAPIEvent event)\n{\n    VncServerInfo *si;\n\n    if (!vs->info) {\n        return;\n    }\n    g_assert(vs->info->base);\n\n    si = vnc_server_info_get();\n    if (!si) {\n        return;\n    }\n\n    switch (event) {\n    case QAPI_EVENT_VNC_CONNECTED:\n        qapi_event_send_vnc_connected(si, vs->info->base, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_INITIALIZED:\n        qapi_event_send_vnc_initialized(si, vs->info, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_DISCONNECTED:\n        qapi_event_send_vnc_disconnected(si, vs->info, &error_abort);\n        break;\n    default:\n        break;\n    }\n\n    qapi_free_VncServerInfo(si);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186429, "func": "GURL DevToolsUI::SanitizeFrontendURL(const GURL& url) {\n  return ::SanitizeFrontendURL(url, content::kChromeDevToolsScheme,\n      chrome::kChromeUIDevToolsHost, SanitizeFrontendPath(url.path()), true);\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 7839, "func": "void do_acpitable_option(const QemuOpts *opts)\n{\n#ifdef TARGET_I386\n    Error *err = NULL;\n\n    acpi_table_add(opts, &err);\n    if (err) {\n        error_report(\"Wrong acpi table provided: %s\",\n                     error_get_pretty(err));\n        error_free(err);\n        exit(1);\n    }\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187263, "func": "void BrowserDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   session->SetBrowserOnly(true);\n   session->AddHandler(\n       base::WrapUnique(new protocol::TargetHandler(true \n)));\n   if (only_discovery_)\n    return;\n \n   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::SystemInfoHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::TetheringHandler(\n      socket_callback_, tethering_task_runner_)));\n  session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n       protocol::TracingHandler::Browser,\n       FrameTreeNode::kFrameTreeNodeInvalidId,\n       GetIOContext())));\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 8117, "func": "void Gfx::opCurveTo2(Object args[], int numArgs) {\n  double x1, y1, x2, y2, x3, y3;\n\n  if (!state->isCurPt()) {\n    error(getPos(), \"No current point in curveto2\");\n    return;\n  }\n  x1 = args[0].getNum();\n  y1 = args[1].getNum();\n  x2 = args[2].getNum();\n  y2 = args[3].getNum();\n  x3 = x2;\n  y3 = y2;\n  state->curveTo(x1, y1, x2, y2, x3, y3);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8295, "func": "XRRGetOutputPrimary(Display *dpy, Window window)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRGetOutputPrimaryReq  *req;\n    xRRGetOutputPrimaryReply rep;\n    int\t\t\t    major_version, minor_version;\n\n    RRCheckExtension (dpy, info, 0);\n\n    if (!XRRQueryVersion (dpy, &major_version, &minor_version) ||\n\t!_XRRHasOutputPrimary (major_version, minor_version))\n\treturn None;\n\n    LockDisplay(dpy);\n    GetReq (RRGetOutputPrimary, req);\n    req->reqType\t= info->codes->major_opcode;\n    req->randrReqType\t= X_RRGetOutputPrimary;\n    req->window\t\t= window;\n\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n\trep.output = None;\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n\n    return rep.output;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7548, "func": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\t\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\t\n\tif (ce->serialize == NULL || ce->unserialize == zend_user_unserialize || (ZEND_INTERNAL_CLASS != ce->type && ce->create_object == NULL)) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n\t}\n\n\treturn elements;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186779, "func": " bool VaapiVideoDecodeAccelerator::VaapiVP9Accelerator::GetFrameContext(\n     const scoped_refptr<VP9Picture>& pic,\n     Vp9FrameContext* frame_ctx) {\n   NOTIMPLEMENTED() << \"Frame context update not supported\";\n   return false;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7598, "func": "static void cirrus_update_memory_access(CirrusVGAState *s)\n{\n    unsigned mode;\n\n    memory_region_transaction_begin();\n    if ((s->vga.sr[0x17] & 0x44) == 0x44) {\n        goto generic_io;\n    } else if (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n        goto generic_io;\n    } else {\n\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n            goto generic_io;\n\t} else if (s->vga.gr[0x0B] & 0x02) {\n            goto generic_io;\n        }\n\n\tmode = s->vga.gr[0x05] & 0x7;\n\tif (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {\n            map_linear_vram(s);\n        } else {\n        generic_io:\n            unmap_linear_vram(s);\n        }\n    }\n    memory_region_transaction_commit();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7841, "func": "uint64_t dup_mig_bytes_transferred(void)\n{\n    return acct_info.dup_pages * TARGET_PAGE_SIZE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7922, "func": "static void cvardecs(JF, js_Ast *node)\n{\n\tif (isfun(node->type))\n\t\treturn; \n\n\tif (node->type == EXP_VAR) {\n\t\tif (F->lightweight)\n\t\t\taddlocal(J, F, node->a, 1);\n\t\telse\n\t\t\temitstring(J, F, OP_DEFVAR, node->a->string);\n\t}\n\n\tif (node->a) cvardecs(J, F, node->a);\n\tif (node->b) cvardecs(J, F, node->b);\n\tif (node->c) cvardecs(J, F, node->c);\n\tif (node->d) cvardecs(J, F, node->d);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187002, "func": "void DownloadManagerImpl::DownloadUrl(\n    std::unique_ptr<download::DownloadUrlParameters> params,\n    std::unique_ptr<storage::BlobDataHandle> blob_data_handle,\n    scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory) {\n  if (params->post_id() >= 0) {\n    DCHECK(params->prefer_cache());\n    DCHECK_EQ(\"POST\", params->method());\n  }\n\n  download::RecordDownloadCountWithSource(\n      download::DownloadCountTypes::DOWNLOAD_TRIGGERED_COUNT,\n       params->download_source());\n   auto* rfh = RenderFrameHost::FromID(params->render_process_host_id(),\n                                       params->render_frame_host_routing_id());\n   BeginDownloadInternal(std::move(params), std::move(blob_data_handle),\n                         std::move(blob_url_loader_factory), true,\n                         rfh ? rfh->GetSiteInstance()->GetSiteURL() : GURL());\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7652, "func": "static int proxy_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n{\n    int retval;\n    retval = v9fs_request(s->private, T_STATFS, stbuf, fs_path);\n    if (retval < 0) {\n        errno = -retval;\n        return -1;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186532, "func": "void TestGamepadMinimumDataImpl(WebXrVrBrowserTestBase* t) {\n  WebXrControllerInputMock my_mock;\n\n  unsigned int controller_index =\n      my_mock.CreateAndConnectMinimalGamepad(t->GetPrimaryAxisType());\n\n  t->LoadUrlAndAwaitInitialization(\n       t->GetFileUrlForHtmlTestFile(\"test_webxr_gamepad_support\"));\n   t->EnterSessionWithUserGestureOrFail();\n \n   my_mock.TogglePrimaryTrigger(controller_index);\n  my_mock.SetAxes(controller_index, device::XrButtonId::kAxisPrimary, 0.5,\n                  -0.5);\n  my_mock.ToggleButtonTouches(controller_index,\n                              device::XrButtonId::kAxisPrimary);\n\n  t->PollJavaScriptBooleanOrFail(\"isMappingEqualTo('xr-standard')\",\n                                 WebXrVrBrowserTestBase::kPollTimeoutShort);\n  t->PollJavaScriptBooleanOrFail(\"isButtonPressedEqualTo(0, true)\",\n                                 WebXrVrBrowserTestBase::kPollTimeoutShort);\n  t->PollJavaScriptBooleanOrFail(\"areAxesValuesEqualTo(0, 0.5, -0.5)\",\n                                 WebXrVrBrowserTestBase::kPollTimeoutShort);\n  t->RunJavaScriptOrFail(\"done()\");\n  t->EndTest();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186876, "func": "void PrintRenderFrameHelper::PrintHeaderAndFooter(\n    blink::WebCanvas* canvas,\n    int page_number,\n    int total_pages,\n    const blink::WebLocalFrame& source_frame,\n    float webkit_scale_factor,\n    const PageSizeMargins& page_layout,\n    const PrintMsg_Print_Params& params) {\n  cc::PaintCanvasAutoRestore auto_restore(canvas, true);\n  canvas->scale(1 / webkit_scale_factor, 1 / webkit_scale_factor);\n\n  blink::WebSize page_size(page_layout.margin_left + page_layout.margin_right +\n                               page_layout.content_width,\n                           page_layout.margin_top + page_layout.margin_bottom +\n                               page_layout.content_height);\n\n  blink::WebView* web_view = blink::WebView::Create(\n      nullptr, blink::mojom::PageVisibilityState::kVisible);\n  web_view->GetSettings()->SetJavaScriptEnabled(true);\n\n  class HeaderAndFooterClient final : public blink::WebFrameClient {\n   public:\n    void BindToFrame(blink::WebLocalFrame* frame) override { frame_ = frame; }\n    void FrameDetached(DetachType detach_type) override {\n      frame_->FrameWidget()->Close();\n      frame_->Close();\n      frame_ = nullptr;\n    }\n\n   private:\n    blink::WebLocalFrame* frame_;\n  };\n  HeaderAndFooterClient frame_client;\n  blink::WebLocalFrame* frame = blink::WebLocalFrame::CreateMainFrame(\n      web_view, &frame_client, nullptr, nullptr);\n  blink::WebWidgetClient web_widget_client;\n  blink::WebFrameWidget::Create(&web_widget_client, frame);\n\n  base::Value html(base::UTF8ToUTF16(\n      ui::ResourceBundle::GetSharedInstance().GetRawDataResource(\n          IDR_PRINT_PREVIEW_PAGE)));\n  ExecuteScript(frame, kPageLoadScriptFormat, html);\n\n  auto options = base::MakeUnique<base::DictionaryValue>();\n  options->SetDouble(kSettingHeaderFooterDate, base::Time::Now().ToJsTime());\n  options->SetDouble(\"width\", page_size.width);\n  options->SetDouble(\"height\", page_size.height);\n  options->SetDouble(\"topMargin\", page_layout.margin_top);\n  options->SetDouble(\"bottomMargin\", page_layout.margin_bottom);\n  options->SetInteger(\"pageNumber\", page_number);\n  options->SetInteger(\"totalPages\", total_pages);\n   options->SetString(\"url\", params.url);\n   base::string16 title = source_frame.GetDocument().Title().Utf16();\n   options->SetString(\"title\", title.empty() ? params.title : title);\n \n   ExecuteScript(frame, kPageSetupScriptFormat, *options);\n \n  blink::WebPrintParams webkit_params(page_size);\n  webkit_params.printer_dpi = GetDPI(&params);\n\n  frame->PrintBegin(webkit_params);\n  frame->PrintPage(0, canvas);\n  frame->PrintEnd();\n\n  web_view->Close();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186357, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_MODERATELY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"),\n                      status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(UNICODE_STRING_SIMPLE(\n       \"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb\\\\u30fc]\"), status);\n   kana_letters_exceptions_.freeze();\n \n   DCHECK(U_SUCCESS(status));\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187253, "func": "  ExtensionScriptAndCaptureVisibleTest()\n      : http_url(\"http:\n        http_url_with_path(\"http:\n        https_url(\"https:\n        example_com(\"https:\n        test_example_com(\"https:\n        sample_example_com(\"https:\n        file_url(\"file:\n        favicon_url(\"chrome:\n        extension_url(\"chrome-extension:\n                       crx_file::id_util::GenerateIdForPath(\n                           base::FilePath(FILE_PATH_LITERAL(\"foo\")))),\n         settings_url(\"chrome:\n        about_url(\"about:flags\") {\n     urls_.insert(http_url);\n     urls_.insert(http_url_with_path);\n     urls_.insert(https_url);\n    urls_.insert(example_com);\n    urls_.insert(test_example_com);\n    urls_.insert(sample_example_com);\n    urls_.insert(file_url);\n     urls_.insert(favicon_url);\n     urls_.insert(extension_url);\n     urls_.insert(settings_url);\n    urls_.insert(about_url);\n     PermissionsData::SetPolicyDelegate(NULL);\n   }\n", "target": 1, "flaw_line_index": "14,25"}
{"idx": 186998, "func": "static bool CheckDts(const uint8_t* buffer, int buffer_size) {\n  RCHECK(buffer_size > 11);\n\n  int offset = 0;\n  while (offset + 11 < buffer_size) {\n    BitReader reader(buffer + offset, 11);\n\n    RCHECK(ReadBits(&reader, 32) == 0x7ffe8001);\n\n    reader.SkipBits(1 + 5);\n\n    RCHECK(ReadBits(&reader, 1) == 0);  \n\n    RCHECK(ReadBits(&reader, 7) >= 5);\n\n    int frame_size = ReadBits(&reader, 14);\n    RCHECK(frame_size >= 95);\n\n     reader.SkipBits(6);\n \n    RCHECK(kSamplingFrequencyValid[ReadBits(&reader, 4)]);\n \n     RCHECK(ReadBits(&reader, 5) <= 25);\n\n    RCHECK(ReadBits(&reader, 1) == 0);\n\n     reader.SkipBits(1 + 1 + 1 + 1);\n \n    RCHECK(kExtAudioIdValid[ReadBits(&reader, 3)]);\n \n     reader.SkipBits(1 + 1);\n\n    RCHECK(ReadBits(&reader, 2) != 3);\n\n    offset += frame_size + 1;\n  }\n  return true;\n}\n", "target": 1, "flaw_line_index": "30"}
{"idx": 186807, "func": " PlatformSensorFusion::PlatformSensorFusion(\n    mojo::ScopedSharedBufferMapping mapping,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n    : PlatformSensor(fusion_algorithm->fused_type(),\n                     std::move(mapping),\n                     provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {\n  for (const auto& pair : source_sensors_)\n    pair.second->AddClient(this);\n\n  fusion_algorithm_->set_fusion_sensor(this);\n\n  if (std::any_of(source_sensors_.begin(), source_sensors_.end(),\n                  [](const SourcesMapEntry& pair) {\n                    return pair.second->GetReportingMode() ==\n                           mojom::ReportingMode::ON_CHANGE;\n                  })) {\n    reporting_mode_ = mojom::ReportingMode::ON_CHANGE;\n  }\n}\n", "target": 1, "flaw_line_index": "2,6,7,8"}
{"idx": 186843, "func": "   void SimulateOnBufferCreated(int buffer_id, const base::SharedMemory& shm) {\n    auto handle = base::SharedMemory::DuplicateHandle(shm.handle());\n     video_capture_impl_->OnBufferCreated(\n        buffer_id, mojo::WrapSharedMemoryHandle(handle, shm.mapped_size(),\n                                                true \n));\n   }\n", "target": 1, "flaw_line_index": "2,4,6"}
{"idx": 187276, "func": "HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n    const CompactHTMLToken& token,\n    HTMLTokenizer* tokenizer) {\n  SimulatedToken simulated_token = kOtherToken;\n\n  if (token.GetType() == HTMLToken::kStartTag) {\n    const String& tag_name = token.Data();\n    if (ThreadSafeMatch(tag_name, SVGNames::svgTag))\n      namespace_stack_.push_back(SVG);\n    if (ThreadSafeMatch(tag_name, MathMLNames::mathTag))\n       namespace_stack_.push_back(kMathML);\n     if (InForeignContent() && TokenExitsForeignContent(token))\n       namespace_stack_.pop_back();\n    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||\n        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))\n       namespace_stack_.push_back(HTML);\n    if (!InForeignContent()) {\n       if (ThreadSafeMatch(tag_name, textareaTag) ||\n          ThreadSafeMatch(tag_name, titleTag)) {\n        tokenizer->SetState(HTMLTokenizer::kRCDATAState);\n      } else if (ThreadSafeMatch(tag_name, scriptTag)) {\n        tokenizer->SetState(HTMLTokenizer::kScriptDataState);\n        simulated_token = kScriptStart;\n      } else if (ThreadSafeMatch(tag_name, linkTag)) {\n        simulated_token = kLink;\n      } else if (!in_select_insertion_mode_) {\n        if (ThreadSafeMatch(tag_name, plaintextTag) &&\n            !in_select_insertion_mode_) {\n          tokenizer->SetState(HTMLTokenizer::kPLAINTEXTState);\n        } else if (ThreadSafeMatch(tag_name, styleTag) ||\n                   ThreadSafeMatch(tag_name, iframeTag) ||\n                   ThreadSafeMatch(tag_name, xmpTag) ||\n                   (ThreadSafeMatch(tag_name, noembedTag) &&\n                    options_.plugins_enabled) ||\n                   ThreadSafeMatch(tag_name, noframesTag) ||\n                   (ThreadSafeMatch(tag_name, noscriptTag) &&\n                    options_.script_enabled)) {\n          tokenizer->SetState(HTMLTokenizer::kRAWTEXTState);\n        }\n      }\n\n      if (ThreadSafeMatch(tag_name, selectTag)) {\n        in_select_insertion_mode_ = true;\n      } else if (in_select_insertion_mode_ && TokenExitsInSelect(token)) {\n        in_select_insertion_mode_ = false;\n      }\n    }\n  }\n\n  if (token.GetType() == HTMLToken::kEndTag ||\n      (token.GetType() == HTMLToken::kStartTag && token.SelfClosing() &&\n       InForeignContent())) {\n    const String& tag_name = token.Data();\n    if ((namespace_stack_.back() == SVG &&\n          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||\n         (namespace_stack_.back() == kMathML &&\n          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||\n        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&\n         TokenExitsSVG(token)) ||\n         (namespace_stack_.Contains(kMathML) &&\n          namespace_stack_.back() == HTML && TokenExitsMath(token))) {\n       namespace_stack_.pop_back();\n    }\n    if (ThreadSafeMatch(tag_name, scriptTag)) {\n      if (!InForeignContent())\n        tokenizer->SetState(HTMLTokenizer::kDataState);\n      return kScriptEnd;\n    } else if (ThreadSafeMatch(tag_name, selectTag)) {\n      in_select_insertion_mode_ = false;\n    }\n    if (ThreadSafeMatch(tag_name, styleTag))\n      simulated_token = kStyleEnd;\n  }\n\n  tokenizer->SetForceNullCharacterReplacement(InForeignContent());\n  tokenizer->SetShouldAllowCDATA(InForeignContent());\n   return simulated_token;\n }\n", "target": 1, "flaw_line_index": "14,15,17,69,70"}
{"idx": 8296, "func": "XRRSetOutputPrimary(Display *dpy, Window window, RROutput output)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRSetOutputPrimaryReq  *req;\n    int\t\t\t    major_version, minor_version;\n\n    RRSimpleCheckExtension (dpy, info);\n\n    if (!XRRQueryVersion (dpy, &major_version, &minor_version) ||\n\t!_XRRHasOutputPrimary (major_version, minor_version))\n\treturn;\n\n    LockDisplay(dpy);\n    GetReq (RRSetOutputPrimary, req);\n    req->reqType       = info->codes->major_opcode;\n    req->randrReqType  = X_RRSetOutputPrimary;\n    req->window        = window;\n    req->output\t       = output;\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187215, "func": "static int _hid_get_report(struct hid_device_priv* dev, HANDLE hid_handle, int id, void *data,\n\t\t\t\t\t\t   struct windows_transfer_priv *tp, size_t *size, OVERLAPPED* overlapped,\n\t\t\t\t\t\t   int report_type)\n{\n\tuint8_t *buf;\n\tDWORD ioctl_code, read_size, expected_size = (DWORD)*size;\n\tint r = LIBUSB_SUCCESS;\n\tif (tp->hid_buffer != NULL) {\n\t\tusbi_dbg(\"program assertion failed: hid_buffer is not NULL\");\n\t}\n\tif ((*size == 0) || (*size > MAX_HID_REPORT_SIZE)) {\n\t\tusbi_dbg(\"invalid size (%d)\", *size);\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tswitch (report_type) {\n\t\tcase HID_REPORT_TYPE_INPUT:\n\t\t\tioctl_code = IOCTL_HID_GET_INPUT_REPORT;\n\t\t\tbreak;\n\t\tcase HID_REPORT_TYPE_FEATURE:\n\t\t\tioctl_code = IOCTL_HID_GET_FEATURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusbi_dbg(\"unknown HID report type %d\", report_type);\n\t\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tbuf = (uint8_t*)calloc(expected_size+1, 1);\n\tif (buf == NULL) {\n\t\treturn LIBUSB_ERROR_NO_MEM;\n\t}\n\tbuf[0] = (uint8_t)id;\t\n\tusbi_dbg(\"report ID: 0x%02X\", buf[0]);\n\ttp->hid_expected_size = expected_size;\n\tread_size = expected_size;\n\tif (!DeviceIoControl(hid_handle, ioctl_code, buf, expected_size+1,\n\t\tbuf, expected_size+1, &read_size, overlapped)) {\n\t\tif (GetLastError() != ERROR_IO_PENDING) {\n\t\t\tusbi_dbg(\"Failed to Read HID Report: %s\", windows_error_str(0));\n\t\t\tsafe_free(buf);\n\t\t\treturn LIBUSB_ERROR_IO;\n\t\t}\n\t\ttp->hid_buffer = buf;\n\t\ttp->hid_dest = (uint8_t*)data; \n\t\treturn LIBUSB_SUCCESS;\n\t}\n\tif (read_size == 0) {\n\t\tusbi_warn(NULL, \"program assertion failed - read completed synchronously, but no data was read\");\n\t\t*size = 0;\n\t} else {\n\t\tif (buf[0] != id) {\n\t\t\tusbi_warn(NULL, \"mismatched report ID (data is %02X, parameter is %02X)\", buf[0], id);\n\t\t}\n\t\tif ((size_t)read_size > expected_size) {\n\t\t\tr = LIBUSB_ERROR_OVERFLOW;\n\t\t\tusbi_dbg(\"OVERFLOW!\");\n\t\t} else {\n\t\t\tr = LIBUSB_COMPLETED;\n\t\t}\n\t\t*size = MIN((size_t)read_size, *size);\n\t\tif (id == 0) {\n\t\t\tmemcpy(data, buf+1, *size);\n\t\t} else {\n\t\t\tmemcpy(data, buf, *size);\n\t\t}\n\t}\n\tsafe_free(buf);\n\treturn r;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68"}
{"idx": 7581, "func": "static void cirrus_get_resolution(VGACommonState *s, int *pwidth, int *pheight)\n{\n    int width, height;\n\n    width = (s->cr[0x01] + 1) * 8;\n    height = s->cr[0x12] |\n        ((s->cr[0x07] & 0x02) << 7) |\n        ((s->cr[0x07] & 0x40) << 3);\n    height = (height + 1);\n    if (s->cr[0x1a] & 0x01)\n        height = height * 2;\n    *pwidth = width;\n    *pheight = height;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186930, "func": "DOMWindow* CreateWindow(const String& url_string,\n                        const AtomicString& frame_name,\n                        const String& window_features_string,\n                        LocalDOMWindow& calling_window,\n                        LocalFrame& first_frame,\n                        LocalFrame& opener_frame,\n                        ExceptionState& exception_state) {\n  LocalFrame* active_frame = calling_window.GetFrame();\n  DCHECK(active_frame);\n\n  KURL completed_url = url_string.IsEmpty()\n                           ? KURL(kParsedURLString, g_empty_string)\n                           : first_frame.GetDocument()->CompleteURL(url_string);\n  if (!completed_url.IsEmpty() && !completed_url.IsValid()) {\n    UseCounter::Count(active_frame, WebFeature::kWindowOpenWithInvalidURL);\n    exception_state.ThrowDOMException(\n        kSyntaxError, \"Unable to open a window with invalid URL '\" +\n                          completed_url.GetString() + \"'.\\n\");\n     return nullptr;\n   }\n \n   WebWindowFeatures window_features =\n       GetWindowFeaturesFromString(window_features_string);\n \n  FrameLoadRequest frame_request(calling_window.document(),\n                                 ResourceRequest(completed_url), frame_name);\n  frame_request.SetShouldSetOpener(window_features.noopener ? kNeverSetOpener\n                                                            : kMaybeSetOpener);\n  frame_request.GetResourceRequest().SetFrameType(\n      WebURLRequest::kFrameTypeAuxiliary);\n  frame_request.GetResourceRequest().SetRequestorOrigin(\n      SecurityOrigin::Create(active_frame->GetDocument()->Url()));\n\n  frame_request.GetResourceRequest().SetHTTPReferrer(\n      SecurityPolicy::GenerateReferrer(\n          active_frame->GetDocument()->GetReferrerPolicy(), completed_url,\n          active_frame->GetDocument()->OutgoingReferrer()));\n\n  bool has_user_gesture = UserGestureIndicator::ProcessingUserGesture();\n\n  bool created;\n  Frame* new_frame = CreateWindowHelper(\n      opener_frame, *active_frame, opener_frame, frame_request, window_features,\n      kNavigationPolicyIgnore, created);\n  if (!new_frame)\n    return nullptr;\n  if (new_frame->DomWindow()->IsInsecureScriptAccess(calling_window,\n                                                     completed_url))\n    return window_features.noopener ? nullptr : new_frame->DomWindow();\n\n  if (created) {\n    FrameLoadRequest request(calling_window.document(),\n                             ResourceRequest(completed_url));\n    request.GetResourceRequest().SetHasUserGesture(has_user_gesture);\n    new_frame->Navigate(request);\n  } else if (!url_string.IsEmpty()) {\n    new_frame->Navigate(*calling_window.document(), completed_url, false,\n                        has_user_gesture ? UserGestureStatus::kActive\n                                         : UserGestureStatus::kNone);\n  }\n  return window_features.noopener ? nullptr : new_frame->DomWindow();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8133, "func": "void Gfx::opMoveTo(Object args[], int numArgs) {\n  state->moveTo(args[0].getNum(), args[1].getNum());\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8107, "func": "void Gfx::opBeginImage(Object args[], int numArgs) {\n  Stream *str;\n  int c1, c2;\n\n  str = buildImageStream();\n\n  if (str) {\n    doImage(NULL, str, gTrue);\n  \n    c1 = str->getUndecodedStream()->getChar();\n    c2 = str->getUndecodedStream()->getChar();\n    while (!(c1 == 'E' && c2 == 'I') && c2 != EOF) {\n      c1 = c2;\n      c2 = str->getUndecodedStream()->getChar();\n    }\n    delete str;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8226, "func": "static void v9fs_open(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int32_t mode;\n    V9fsQID qid;\n    int iounit = 0;\n    ssize_t err = 0;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    if (s->proto_version == V9FS_PROTO_2000L) {\n        err = pdu_unmarshal(pdu, offset, \"dd\", &fid, &mode);\n    } else {\n        uint8_t modebyte;\n        err = pdu_unmarshal(pdu, offset, \"db\", &fid, &modebyte);\n        mode = modebyte;\n    }\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_open(pdu->tag, pdu->id, fid, mode);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    if (S_ISDIR(stbuf.st_mode)) {\n        err = v9fs_co_opendir(pdu, fidp);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_DIR;\n        err = pdu_marshal(pdu, offset, \"Qd\", &qid, 0);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    } else {\n        if (s->proto_version == V9FS_PROTO_2000L) {\n            flags = get_dotl_openflags(s, mode);\n        } else {\n            flags = omode_to_uflags(mode);\n        }\n        if (is_ro_export(&s->ctx)) {\n            if (mode & O_WRONLY || mode & O_RDWR ||\n                mode & O_APPEND || mode & O_TRUNC) {\n                err = -EROFS;\n                goto out;\n            }\n        }\n        err = v9fs_co_open(pdu, fidp, flags);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_FILE;\n        fidp->open_flags = flags;\n        if (flags & O_EXCL) {\n            fidp->flags |= FID_NON_RECLAIMABLE;\n        }\n        iounit = get_iounit(pdu, &fidp->path);\n        err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    }\n    trace_v9fs_open_return(pdu->tag, pdu->id,\n                           qid.type, qid.version, qid.path, iounit);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186575, "func": " AcceleratedStaticBitmapImage::~AcceleratedStaticBitmapImage() {\n   if (original_skia_image_) {\n     std::unique_ptr<gpu::SyncToken> sync_token =\n         base::WrapUnique(new gpu::SyncToken(texture_holder_->GetSyncToken()));\n    if (original_skia_image_thread_id_ !=\n        Platform::Current()->CurrentThread()->ThreadId()) {\n       PostCrossThreadTask(\n           *original_skia_image_task_runner_, FROM_HERE,\n           CrossThreadBind(\n              &DestroySkImageOnOriginalThread, std::move(original_skia_image_),\n              std::move(original_skia_image_context_provider_wrapper_),\n              WTF::Passed(std::move(sync_token))));\n    } else {\n      DestroySkImageOnOriginalThread(\n          std::move(original_skia_image_),\n          std::move(original_skia_image_context_provider_wrapper_),\n          std::move(sync_token));\n    }\n  }\n }\n", "target": 1, "flaw_line_index": "8,9"}
{"idx": 186982, "func": "bool PageCaptureSaveAsMHTMLFunction::RunAsync() {\n  params_ = SaveAsMHTML::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params_.get());\n\n  AddRef();  \n\n#if defined(OS_CHROMEOS)\n  if (profiles::ArePublicSessionRestrictionsEnabled()) {\n    WebContents* web_contents = GetWebContents();\n    if (!web_contents) {\n      ReturnFailure(kTabClosedError);\n      return true;\n    }\n    auto callback =\n        base::Bind(&PageCaptureSaveAsMHTMLFunction::ResolvePermissionRequest,\n                   base::Unretained(this));\n    permission_helper::HandlePermissionRequest(\n        *extension(), {APIPermission::kPageCapture}, web_contents, callback,\n        permission_helper::PromptFactory());\n    return true;\n   }\n #endif\n \n   base::PostTaskWithTraits(\n       FROM_HERE, kCreateTemporaryFileTaskTraits,\n       base::BindOnce(&PageCaptureSaveAsMHTMLFunction::CreateTemporaryFile,\n                      this));\n   return true;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186537, "func": "Compositor::Compositor(const viz::FrameSinkId& frame_sink_id,\n                       ui::ContextFactory* context_factory,\n                       ui::ContextFactoryPrivate* context_factory_private,\n                       scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n                       bool enable_surface_synchronization,\n                       bool enable_pixel_canvas,\n                       bool external_begin_frames_enabled,\n                       bool force_software_compositor,\n                       const char* trace_environment_name)\n    : context_factory_(context_factory),\n      context_factory_private_(context_factory_private),\n      frame_sink_id_(frame_sink_id),\n      task_runner_(task_runner),\n      vsync_manager_(new CompositorVSyncManager()),\n      external_begin_frames_enabled_(external_begin_frames_enabled),\n      force_software_compositor_(force_software_compositor),\n      layer_animator_collection_(this),\n      is_pixel_canvas_(enable_pixel_canvas),\n      lock_manager_(task_runner),\n      trace_environment_name_(trace_environment_name\n                                  ? trace_environment_name\n                                  : kDefaultTraceEnvironmentName),\n      context_creation_weak_ptr_factory_(this) {\n  if (context_factory_private) {\n     auto* host_frame_sink_manager =\n         context_factory_private_->GetHostFrameSinkManager();\n     host_frame_sink_manager->RegisterFrameSinkId(\n        frame_sink_id_, this, viz::ReportFirstSurfaceActivation::kYes);\n     host_frame_sink_manager->SetFrameSinkDebugLabel(frame_sink_id_,\n                                                     \"Compositor\");\n   }\n  root_web_layer_ = cc::Layer::Create();\n\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n\n  cc::LayerTreeSettings settings;\n\n  settings.layers_always_allowed_lcd_text = true;\n  settings.use_occlusion_for_tile_prioritization = true;\n  refresh_rate_ = context_factory_->GetRefreshRate();\n  settings.main_frame_before_activation_enabled = false;\n  settings.delegated_sync_points_required =\n      context_factory_->SyncTokensRequiredForDisplayCompositor();\n\n  settings.enable_edge_anti_aliasing = false;\n\n  if (command_line->HasSwitch(switches::kLimitFps)) {\n    std::string fps_str =\n        command_line->GetSwitchValueASCII(switches::kLimitFps);\n    double fps;\n    if (base::StringToDouble(fps_str, &fps) && fps > 0) {\n      forced_refresh_rate_ = fps;\n    }\n  }\n\n  if (command_line->HasSwitch(cc::switches::kUIShowCompositedLayerBorders)) {\n    std::string layer_borders_string = command_line->GetSwitchValueASCII(\n        cc::switches::kUIShowCompositedLayerBorders);\n    std::vector<base::StringPiece> entries = base::SplitStringPiece(\n        layer_borders_string, \",\", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);\n    if (entries.empty()) {\n      settings.initial_debug_state.show_debug_borders.set();\n    } else {\n      for (const auto& entry : entries) {\n        const struct {\n          const char* name;\n          cc::DebugBorderType type;\n        } kBorders[] = {{cc::switches::kCompositedRenderPassBorders,\n                         cc::DebugBorderType::RENDERPASS},\n                        {cc::switches::kCompositedSurfaceBorders,\n                         cc::DebugBorderType::SURFACE},\n                        {cc::switches::kCompositedLayerBorders,\n                         cc::DebugBorderType::LAYER}};\n        for (const auto& border : kBorders) {\n          if (border.name == entry) {\n            settings.initial_debug_state.show_debug_borders.set(border.type);\n            break;\n          }\n        }\n      }\n    }\n  }\n  settings.initial_debug_state.show_fps_counter =\n      command_line->HasSwitch(cc::switches::kUIShowFPSCounter);\n  settings.initial_debug_state.show_layer_animation_bounds_rects =\n      command_line->HasSwitch(cc::switches::kUIShowLayerAnimationBounds);\n  settings.initial_debug_state.show_paint_rects =\n      command_line->HasSwitch(switches::kUIShowPaintRects);\n  settings.initial_debug_state.show_property_changed_rects =\n      command_line->HasSwitch(cc::switches::kUIShowPropertyChangedRects);\n  settings.initial_debug_state.show_surface_damage_rects =\n      command_line->HasSwitch(cc::switches::kUIShowSurfaceDamageRects);\n  settings.initial_debug_state.show_screen_space_rects =\n      command_line->HasSwitch(cc::switches::kUIShowScreenSpaceRects);\n\n  settings.initial_debug_state.SetRecordRenderingStats(\n      command_line->HasSwitch(cc::switches::kEnableGpuBenchmarking));\n  settings.enable_surface_synchronization = enable_surface_synchronization;\n  settings.build_hit_test_data = features::IsVizHitTestingSurfaceLayerEnabled();\n\n  settings.use_zero_copy = IsUIZeroCopyEnabled();\n\n  settings.use_layer_lists =\n      command_line->HasSwitch(cc::switches::kUIEnableLayerLists);\n\n  settings.use_partial_raster = !settings.use_zero_copy;\n\n  settings.use_rgba_4444 =\n      command_line->HasSwitch(switches::kUIEnableRGBA4444Textures);\n\n#if defined(OS_MACOSX)\n  settings.resource_settings.use_gpu_memory_buffer_resources =\n      settings.use_zero_copy;\n  settings.enable_elastic_overscroll = true;\n#endif\n\n  settings.memory_policy.bytes_limit_when_visible = 512 * 1024 * 1024;\n  settings.memory_policy.priority_cutoff_when_visible =\n      gpu::MemoryAllocation::CUTOFF_ALLOW_NICE_TO_HAVE;\n\n  settings.disallow_non_exact_resource_reuse =\n      command_line->HasSwitch(switches::kDisallowNonExactResourceReuse);\n\n  if (command_line->HasSwitch(switches::kRunAllCompositorStagesBeforeDraw)) {\n    settings.wait_for_all_pipeline_stages_before_draw = true;\n    settings.enable_latency_recovery = false;\n  }\n\n  settings.always_request_presentation_time =\n      command_line->HasSwitch(cc::switches::kAlwaysRequestPresentationTime);\n\n  animation_host_ = cc::AnimationHost::CreateMainInstance();\n\n  cc::LayerTreeHost::InitParams params;\n  params.client = this;\n  params.task_graph_runner = context_factory_->GetTaskGraphRunner();\n  params.settings = &settings;\n  params.main_task_runner = task_runner_;\n  params.mutator_host = animation_host_.get();\n  host_ = cc::LayerTreeHost::CreateSingleThreaded(this, std::move(params));\n\n  if (base::FeatureList::IsEnabled(features::kUiCompositorScrollWithLayers) &&\n      host_->GetInputHandler()) {\n    scroll_input_handler_.reset(\n        new ScrollInputHandler(host_->GetInputHandler()));\n  }\n\n  animation_timeline_ =\n      cc::AnimationTimeline::Create(cc::AnimationIdProvider::NextTimelineId());\n  animation_host_->AddAnimationTimeline(animation_timeline_.get());\n\n  host_->SetHasGpuRasterizationTrigger(features::IsUiGpuRasterizationEnabled());\n  host_->SetRootLayer(root_web_layer_);\n  host_->SetVisible(true);\n\n  if (command_line->HasSwitch(switches::kUISlowAnimations)) {\n    slow_animations_ = std::make_unique<ScopedAnimationDurationScaleMode>(\n        ScopedAnimationDurationScaleMode::SLOW_DURATION);\n  }\n}\n", "target": 1, "flaw_line_index": "28"}
{"idx": 186873, "func": "bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n                                        VAProfileJPEGBaseline, error_uma_cb);\n  if (!vaapi_wrapper_) {\n    VLOGF(1) << \"Failed initializing VAAPI\";\n    return false;\n  }\n  return true;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9"}
{"idx": 186637, "func": "void WebContentsImpl::CreateNewWindow(\n    RenderFrameHost* opener,\n    int32_t render_view_route_id,\n    int32_t main_frame_route_id,\n    int32_t main_frame_widget_route_id,\n    const mojom::CreateNewWindowParams& params,\n    SessionStorageNamespace* session_storage_namespace) {\n  DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),\n            (main_frame_route_id == MSG_ROUTING_NONE));\n  DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),\n            (main_frame_widget_route_id == MSG_ROUTING_NONE));\n  DCHECK(opener);\n\n  int render_process_id = opener->GetProcess()->GetID();\n  SiteInstance* source_site_instance = opener->GetSiteInstance();\n\n  DCHECK(!RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id));\n\n  bool is_guest = BrowserPluginGuest::IsGuest(this);\n\n  DCHECK(!params.opener_suppressed || render_view_route_id == MSG_ROUTING_NONE);\n\n  scoped_refptr<SiteInstance> site_instance =\n      params.opener_suppressed && !is_guest\n          ? SiteInstance::CreateForURL(GetBrowserContext(), params.target_url)\n          : source_site_instance;\n\n  const std::string& partition_id =\n      GetContentClient()->browser()->\n          GetStoragePartitionIdForSite(GetBrowserContext(),\n                                       site_instance->GetSiteURL());\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      GetBrowserContext(), site_instance.get());\n  DOMStorageContextWrapper* dom_storage_context =\n      static_cast<DOMStorageContextWrapper*>(partition->GetDOMStorageContext());\n  SessionStorageNamespaceImpl* session_storage_namespace_impl =\n      static_cast<SessionStorageNamespaceImpl*>(session_storage_namespace);\n  CHECK(session_storage_namespace_impl->IsFromContext(dom_storage_context));\n\n  if (delegate_ &&\n      !delegate_->ShouldCreateWebContents(\n          this, opener, source_site_instance, render_view_route_id,\n          main_frame_route_id, main_frame_widget_route_id,\n          params.window_container_type, opener->GetLastCommittedURL(),\n          params.frame_name, params.target_url, partition_id,\n          session_storage_namespace)) {\n    RenderFrameHostImpl* rfh =\n        RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id);\n    if (rfh) {\n      DCHECK(rfh->IsRenderFrameLive());\n      rfh->Init();\n    }\n    return;\n  }\n\n  CreateParams create_params(GetBrowserContext(), site_instance.get());\n  create_params.routing_id = render_view_route_id;\n  create_params.main_frame_routing_id = main_frame_route_id;\n  create_params.main_frame_widget_routing_id = main_frame_widget_route_id;\n  create_params.main_frame_name = params.frame_name;\n  create_params.opener_render_process_id = render_process_id;\n  create_params.opener_render_frame_id = opener->GetRoutingID();\n  create_params.opener_suppressed = params.opener_suppressed;\n  if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB)\n    create_params.initially_hidden = true;\n  create_params.renderer_initiated_creation =\n      main_frame_route_id != MSG_ROUTING_NONE;\n\n  std::unique_ptr<WebContents> new_contents;\n  if (!is_guest) {\n    create_params.context = view_->GetNativeView();\n    create_params.initial_size = GetContainerBounds().size();\n    new_contents = WebContents::Create(create_params);\n  }  else {\n    new_contents = base::WrapUnique(\n        GetBrowserPluginGuest()->CreateNewGuestWindow(create_params));\n  }\n  WebContentsImpl* raw_new_contents =\n      static_cast<WebContentsImpl*>(new_contents.get());\n  raw_new_contents->GetController().SetSessionStorageNamespace(\n      partition_id, session_storage_namespace);\n\n  if (!params.frame_name.empty())\n    raw_new_contents->GetRenderManager()->CreateProxiesForNewNamedFrame();\n\n  if (!params.opener_suppressed) {\n    if (!is_guest) {\n      WebContentsView* new_view = raw_new_contents->view_.get();\n\n      new_view->CreateViewForWidget(\n          new_contents->GetRenderViewHost()->GetWidget(), false);\n    }\n    DCHECK_NE(MSG_ROUTING_NONE, main_frame_widget_route_id);\n    pending_contents_[std::make_pair(render_process_id,\n                                     main_frame_widget_route_id)] =\n        std::move(new_contents);\n    AddDestructionObserver(raw_new_contents);\n  }\n\n  if (delegate_) {\n    delegate_->WebContentsCreated(this, render_process_id,\n                                  opener->GetRoutingID(), params.frame_name,\n                                  params.target_url, raw_new_contents);\n  }\n\n  if (opener) {\n    for (auto& observer : observers_) {\n      observer.DidOpenRequestedURL(raw_new_contents, opener, params.target_url,\n                                   params.referrer, params.disposition,\n                                   ui::PAGE_TRANSITION_LINK,\n                                   false,  \n                                   true);  \n    }\n  }\n \n  if (IsFullscreenForCurrentTab())\n    ExitFullscreen(true);\n \n   if (params.opener_suppressed) {\n    bool was_blocked = false;\n\n    base::WeakPtr<WebContentsImpl> weak_new_contents =\n        raw_new_contents->weak_factory_.GetWeakPtr();\n    if (delegate_) {\n      gfx::Rect initial_rect;\n\n      delegate_->AddNewContents(this, std::move(new_contents),\n                                params.disposition, initial_rect,\n                                params.mimic_user_gesture, &was_blocked);\n      if (!weak_new_contents)\n        return;  \n    }\n\n    if (!was_blocked) {\n      OpenURLParams open_params(params.target_url, params.referrer,\n                                WindowOpenDisposition::CURRENT_TAB,\n                                ui::PAGE_TRANSITION_LINK,\n                                true \n);\n      open_params.user_gesture = params.mimic_user_gesture;\n\n      if (delegate_ && !is_guest &&\n          !delegate_->ShouldResumeRequestsForCreatedWindow()) {\n        DCHECK(weak_new_contents);\n        weak_new_contents->delayed_open_url_params_.reset(\n            new OpenURLParams(open_params));\n      } else {\n        weak_new_contents->OpenURL(open_params);\n      }\n    }\n  }\n}\n", "target": 1, "flaw_line_index": "153"}
{"idx": 8164, "func": "void Gfx::opSetTextRender(Object args[], int numArgs) {\n  state->setRender(args[0].getInt());\n  if (args[0].getInt() == 7) {\n    textHaveCSPattern = gFalse;\n  }\n  out->updateRender(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7599, "func": "static void cirrus_vga_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->init = pci_cirrus_vga_initfn;\n    k->romfile = VGABIOS_CIRRUS_FILENAME;\n    k->vendor_id = PCI_VENDOR_ID_CIRRUS;\n    k->device_id = CIRRUS_ID_CLGD5446;\n    k->class_id = PCI_CLASS_DISPLAY_VGA;\n    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);\n    dc->desc = \"Cirrus CLGD 54xx VGA\";\n    dc->vmsd = &vmstate_pci_cirrus_vga;\n    dc->props = pci_vga_cirrus_properties;\n    dc->hotpluggable = false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7412, "func": "ZEND_API void zend_ts_hash_apply(TsHashTable *ht, apply_func_t apply_func)\n{\n\tbegin_write(ht);\n\tzend_hash_apply(TS_HASH(ht), apply_func);\n\tend_write(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7494, "func": "generate_trivial (DBusMessageDataIter   *iter,\n                  DBusString            *data,\n                  DBusValidity          *expected_validity)\n{\n  return generate_outer (iter, data, expected_validity,\n                         generate_trivial_inner);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8159, "func": "void Gfx::opSetStrokeColorSpace(Object args[], int numArgs) {\n  Object obj;\n  GfxColorSpace *colorSpace;\n  GfxColor color;\n\n  state->setStrokePattern(NULL);\n  res->lookupColorSpace(args[0].getName(), &obj);\n  if (obj.isNull()) {\n    colorSpace = GfxColorSpace::parse(&args[0], this);\n  } else {\n    colorSpace = GfxColorSpace::parse(&obj, this);\n  }\n  obj.free();\n  if (colorSpace) {\n    state->setStrokeColorSpace(colorSpace);\n    out->updateStrokeColorSpace(state);\n    colorSpace->getDefaultColor(&color);\n    state->setStrokeColor(&color);\n    out->updateStrokeColor(state);\n  } else {\n    error(getPos(), \"Bad color space (stroke)\");\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186775, "func": " VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::CreateVP8Picture() {\n   scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n   if (!va_surface)\n     return nullptr;\n\n  return new VaapiVP8Picture(std::move(va_surface));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186614, "func": " base::string16 GetApplicationNameForProtocol(const GURL& url) {\n  base::string16 application_name;\n   if (base::win::GetVersion() >= base::win::VERSION_WIN8) {\n    application_name = GetAppForProtocolUsingAssocQuery(url);\n     if (!application_name.empty())\n       return application_name;\n   }\n\n  return GetAppForProtocolUsingRegistry(url);\n}\n", "target": 1, "flaw_line_index": "2,5"}
{"idx": 187297, "func": "MediaGalleriesCustomBindings::MediaGalleriesCustomBindings(\n     ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetMediaFileSystemObject\",\n       base::Bind(&MediaGalleriesCustomBindings::GetMediaFileSystemObject,\n                  base::Unretained(this)));\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 186805, "func": "   static void CreateSensorFusion(\n      mojo::ScopedSharedBufferMapping mapping,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n  }\n", "target": 1, "flaw_line_index": "2,6"}
{"idx": 8262, "func": "XRecordFreeData(XRecordInterceptData *data)\n{\n    struct intercept_queue *iq = (struct intercept_queue *)data;\n    struct reply_buffer *rbp = NULL;\n    struct mem_cache_str *cache = iq->cache;\n\n    if (data->data) {\n\n\tfor (rbp = cache->reply_buffers; rbp; rbp = rbp->next) {\n\t    if (data->data >= rbp->buf\n\t\t&& data->data < rbp->buf + rbp->nbytes)\n\t    {\n\t\tassert(rbp->ref_count > 0);\n\t\trbp->ref_count--;\n\t\tbreak;\n\t    }\n\t}\n\tassert(rbp);\n    }\n    if (cache->display_closed == False) {\n\tiq->next = cache->inter_data;\n\tcache->inter_data = iq;\n    } else {\n\tif (rbp && rbp->ref_count == 0) {\n\t    struct reply_buffer *rbp2, **rbp_next_p;\n\n\t    for (rbp_next_p = &cache->reply_buffers; *rbp_next_p; ) {\n\t\trbp2 = *rbp_next_p;\n\t\tif (rbp == rbp2) {\n\t\t    *rbp_next_p = rbp2->next;\n\t\t    break;\n\t\t} else {\n\t\t    rbp_next_p = &rbp2->next;\n\t\t}\n\t    }\n\t    XFree(rbp->buf);\n\t    XFree(rbp);\n\t}\n\n\tXFree(iq);\n\tcache->inter_data_count--;\n\n\tif (cache->reply_buffers == NULL  &&  cache->inter_data_count == 0) {\n\t    XFree(cache); \n\t}\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8214, "func": "static int v9fs_do_readdir_with_stat(V9fsPDU *pdu,\n                                     V9fsFidState *fidp, uint32_t max_count)\n{\n    V9fsPath path;\n    V9fsStat v9stat;\n    int len, err = 0;\n    int32_t count = 0;\n    struct stat stbuf;\n    off_t saved_dir_pos;\n    struct dirent *dent;\n\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n    if (saved_dir_pos < 0) {\n        return saved_dir_pos;\n    }\n\n    while (1) {\n        v9fs_path_init(&path);\n\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n        if (err || !dent) {\n            break;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);\n        if (err < 0) {\n            break;\n        }\n        err = v9fs_co_lstat(pdu, &path, &stbuf);\n        if (err < 0) {\n            break;\n        }\n        err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);\n        if (err < 0) {\n            break;\n        }\n        len = pdu_marshal(pdu, 11 + count, \"S\", &v9stat);\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n        if ((len != (v9stat.size + 2)) || ((count + len) > max_count)) {\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_stat_free(&v9stat);\n            v9fs_path_free(&path);\n            return count;\n        }\n        count += len;\n        v9fs_stat_free(&v9stat);\n        v9fs_path_free(&path);\n        saved_dir_pos = dent->d_off;\n    }\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n    v9fs_path_free(&path);\n    if (err < 0) {\n        return err;\n    }\n    return count;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186629, "func": "void InstallablePaymentAppCrawler::OnPaymentMethodManifestParsed(\n    const GURL& method_manifest_url,\n    const std::vector<GURL>& default_applications,\n    const std::vector<url::Origin>& supported_origins,\n    bool all_origins_supported) {\n  number_of_payment_method_manifest_to_parse_--;\n\n  if (web_contents() == nullptr)\n    return;\n  content::PermissionManager* permission_manager =\n      web_contents()->GetBrowserContext()->GetPermissionManager();\n  if (permission_manager == nullptr)\n    return;\n\n  for (const auto& url : default_applications) {\n    if (downloaded_web_app_manifests_.find(url) !=\n        downloaded_web_app_manifests_.end()) {\n       continue;\n     }\n \n     if (permission_manager->GetPermissionStatus(\n             content::PermissionType::PAYMENT_HANDLER, url.GetOrigin(),\n             url.GetOrigin()) != blink::mojom::PermissionStatus::GRANTED) {\n      continue;\n    }\n\n    number_of_web_app_manifest_to_download_++;\n    downloaded_web_app_manifests_.insert(url);\n    downloader_->DownloadWebAppManifest(\n        url,\n        base::BindOnce(\n            &InstallablePaymentAppCrawler::OnPaymentWebAppManifestDownloaded,\n            weak_ptr_factory_.GetWeakPtr(), method_manifest_url, url));\n  }\n\n  FinishCrawlingPaymentAppsIfReady();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8171, "func": "void Gfx::opTextMove(Object args[], int numArgs) {\n  double tx, ty;\n\n  tx = state->getLineX() + args[0].getNum();\n  ty = state->getLineY() + args[1].getNum();\n  state->textMoveTo(tx, ty);\n  out->updateTextPos(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187123, "func": " void HeapObjectHeader::Finalize(Address object, size_t object_size) {\n   HeapAllocHooks::FreeHookIfEnabled(object);\n  const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());\n   if (gc_info->HasFinalizer())\n     gc_info->finalize_(object);\n \n  ASAN_RETIRE_CONTAINER_ANNOTATION(object, object_size);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7580, "func": "static void cirrus_get_offsets(VGACommonState *s1,\n                               uint32_t *pline_offset,\n                               uint32_t *pstart_addr,\n                               uint32_t *pline_compare)\n{\n    CirrusVGAState * s = container_of(s1, CirrusVGAState, vga);\n    uint32_t start_addr, line_offset, line_compare;\n\n    line_offset = s->vga.cr[0x13]\n\t| ((s->vga.cr[0x1b] & 0x10) << 4);\n    line_offset <<= 3;\n    *pline_offset = line_offset;\n\n    start_addr = (s->vga.cr[0x0c] << 8)\n\t| s->vga.cr[0x0d]\n\t| ((s->vga.cr[0x1b] & 0x01) << 16)\n\t| ((s->vga.cr[0x1b] & 0x0c) << 15)\n\t| ((s->vga.cr[0x1d] & 0x80) << 12);\n    *pstart_addr = start_addr;\n\n    line_compare = s->vga.cr[0x18] |\n        ((s->vga.cr[0x07] & 0x10) << 4) |\n        ((s->vga.cr[0x09] & 0x40) << 3);\n    *pline_compare = line_compare;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8270, "func": "static struct reply_buffer *alloc_reply_buffer(\n    XExtDisplayInfo *info,\n    int nbytes)\n{\n    struct mem_cache_str *cache = (struct mem_cache_str *)info->data;\n    struct reply_buffer *rbp;\n    struct reply_buffer *saved_rb = NULL;\n    for (rbp = cache->reply_buffers; rbp; rbp = rbp->next) {\n\tif (rbp->ref_count == 0) {\n\t    if (rbp->nbytes >= nbytes)\n\t\treturn rbp;\n\t    else\n\t\tsaved_rb = rbp;\n\t}\n    }\n    if (saved_rb) {\n\tsaved_rb->buf = (unsigned char *)Xrealloc(saved_rb->buf, nbytes);\n\tif (!saved_rb->buf) {\n\t    saved_rb->nbytes = 0;\n\t    return NULL;\n\t}\n\tsaved_rb->nbytes = nbytes;\n\treturn saved_rb;\n    }\n\n    rbp = (struct reply_buffer *)Xmalloc(sizeof(struct reply_buffer));\n    if (!rbp)\n\treturn NULL;\n    rbp->buf = (unsigned char *)Xmalloc(nbytes);\n    if (!rbp->buf) {\n\tXfree(rbp);\n\treturn NULL;\n    }\n    rbp->nbytes = nbytes;\n    rbp->ref_count = 0;\n    rbp->next = cache->reply_buffers;\n    cache->reply_buffers = rbp;\n    return rbp;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187174, "func": "GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n                                 const GURL& real_url) {\n  if (real_url.SchemeIs(kGuestScheme))\n    return real_url;\n\n  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);\n  url::Origin origin = url::Origin::Create(url);\n\n  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();\n  url::Origin isolated_origin;\n  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))\n    return isolated_origin.GetURL();\n\n  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {\n    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(\n        origin.host(),\n        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);\n    std::string site = origin.scheme();\n    site += url::kStandardSchemeSeparator;\n    site += domain.empty() ? origin.host() : domain;\n    return GURL(site);\n  }\n\n  if (!origin.unique()) {\n    DCHECK(!origin.scheme().empty());\n     return GURL(origin.scheme() + \":\");\n   } else if (url.has_scheme()) {\n    if (url.SchemeIsBlob()) {\n       if (url.has_ref()) {\n         GURL::Replacements replacements;\n         replacements.ClearRef();\n        url = url.ReplaceComponents(replacements);\n      }\n      return url;\n    }\n\n    DCHECK(!url.scheme().empty());\n    return GURL(url.scheme() + \":\");\n  }\n\n  DCHECK(!url.is_valid()) << url;\n  return GURL();\n}\n", "target": 1, "flaw_line_index": "44"}
{"idx": 8222, "func": "static int v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)\n{\n    int err;\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp, head_fid;\n\n    head_fid.next = s->fid_list;\n    for (fidp = s->fid_list; fidp; fidp = fidp->next) {\n        if (fidp->path.size != path->size) {\n            continue;\n        }\n        if (!memcmp(fidp->path.data, path->data, path->size)) {\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n            err = v9fs_reopen_fid(pdu, fidp);\n            if (err < 0) {\n                return -1;\n            }\n            if (err == 0) {\n                fidp = &head_fid;\n            }\n        }\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186565, "func": " AcceleratedStaticBitmapImage::AcceleratedStaticBitmapImage(\n    const gpu::Mailbox& mailbox,\n    const gpu::SyncToken& sync_token,\n    unsigned texture_id,\n    base::WeakPtr<WebGraphicsContext3DProviderWrapper>&&\n        context_provider_wrapper,\n    IntSize mailbox_size)\n    : paint_image_content_id_(cc::PaintImage::GetNextContentId()) {\n   texture_holder_ = std::make_unique<MailboxTextureHolder>(\n       mailbox, sync_token, texture_id, std::move(context_provider_wrapper),\n       mailbox_size);\n  thread_checker_.DetachFromThread();\n }\n", "target": 1, "flaw_line_index": "12"}
{"idx": 7900, "func": "static void cassignop(JF, js_Ast *exp, int opcode)\n{\n\tjs_Ast *lhs = exp->a;\n\tjs_Ast *rhs = exp->b;\n\tcassignop1(J, F, lhs);\n\tcexp(J, F, rhs);\n\temit(J, F, opcode);\n\tcassignop2(J, F, lhs, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8183, "func": "Gfx::~Gfx() {\n  while (stateGuards.size()) {\n    popStateGuard();\n  }\n  while (state->hasSaves()) {\n    error(-1, \"Found state under last state guard. Popping.\");\n    restoreState();\n  }\n  if (!subPage) {\n    out->endPage();\n  }\n  while (res) {\n    popResources();\n  }\n  if (state) {\n    delete state;\n  }\n  while (mcStack) {\n    popMarkedContent();\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186517, "func": "void RegisterOptimizationHintsComponent(ComponentUpdateService* cus,\n                                        PrefService* profile_prefs) {\n  if (!previews::params::IsOptimizationHintsEnabled()) {\n     return;\n   }\n \n  bool data_saver_enabled =\n      base::CommandLine::ForCurrentProcess()->HasSwitch(\n          data_reduction_proxy::switches::kEnableDataReductionProxy) ||\n      (profile_prefs && profile_prefs->GetBoolean(\n                            data_reduction_proxy::prefs::kDataSaverEnabled));\n  if (!data_saver_enabled)\n     return;\n   auto installer = base::MakeRefCounted<ComponentInstaller>(\n       std::make_unique<OptimizationHintsComponentInstallerPolicy>());\n   installer->Register(cus, base::OnceClosure());\n}\n", "target": 1, "flaw_line_index": "7,8,9,10,11,12"}
{"idx": 186566, "func": "void AcceleratedStaticBitmapImage::CheckThread() {\n  if (detach_thread_at_next_check_) {\n    thread_checker_.DetachFromThread();\n    detach_thread_at_next_check_ = false;\n  }\n  CHECK(thread_checker_.CalledOnValidThread());\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 7700, "func": "static int handle_utimensat(FsContext *ctx, V9fsPath *fs_path,\n                            const struct timespec *buf)\n{\n    int ret;\n#ifdef CONFIG_UTIMENSAT\n    int fd;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = futimens(fd, buf);\n    close(fd);\n#else\n    ret = -1;\n    errno = ENOSYS;\n#endif\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187036, "func": "void Document::InitContentSecurityPolicy(\n    ContentSecurityPolicy* csp,\n    const ContentSecurityPolicy* policy_to_inherit,\n    const ContentSecurityPolicy* previous_document_csp) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n \n  if (policy_to_inherit) {\n     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  } else {\n    if (frame_) {\n       Frame* inherit_from = frame_->Tree().Parent()\n                                 ? frame_->Tree().Parent()\n                                 : frame_->Client()->Opener();\n       if (inherit_from && frame_ != inherit_from) {\n         DCHECK(inherit_from->GetSecurityContext() &&\n                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n        policy_to_inherit =\n            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       }\n     }\n    if (!policy_to_inherit)\n      policy_to_inherit = previous_document_csp;\n    if (policy_to_inherit &&\n        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n         url_.ProtocolIs(\"blob\") || url_.ProtocolIs(\"filesystem\")))\n      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  }\n  if (policy_to_inherit && IsPluginDocument())\n    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n }\n", "target": 1, "flaw_line_index": "2,3,4,9,10,11,12,13,14,15,16,17,18,20,21,28,29,32,33"}
{"idx": 186796, "func": "FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n                                       mojo::ScopedSharedBufferMapping mapping,\n                                       PlatformSensorProvider* provider)\n    : PlatformSensor(type, std::move(mapping), provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n            SensorReading reading;\n            if (GetType() == mojom::SensorType::AMBIENT_LIGHT) {\n              reading.als.value = configuration.frequency();\n              UpdateSharedBufferAndNotifyClients(reading);\n            }\n            return true;\n          }));\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 7403, "func": "ZEND_API zval *_zend_ts_hash_index_add_or_update(TsHashTable *ht, zend_ulong h, zval *pData, int flag ZEND_FILE_LINE_DC)\n{\n\tzval *retval;\n\n\tbegin_write(ht);\n\tretval = _zend_hash_index_add_or_update(TS_HASH(ht), h, pData, flag ZEND_FILE_LINE_RELAY_CC);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7734, "func": "static void coroutine_fn v9fs_stat(void *opaque)\n{\n    int32_t fid;\n    V9fsStat v9stat;\n    ssize_t err = 0;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n    if (err < 0) {\n        v9fs_stat_free(&v9stat);\n        goto out;\n    }\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n    err += offset;\n    v9fs_stat_free(&v9stat);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7508, "func": "  tt_check_trickyness( FT_Face  face )\n  {\n    if ( !face )\n      return FALSE;\n\n    if ( face->family_name                               &&\n         tt_check_trickyness_family( face->family_name ) )\n      return TRUE;\n\n    if ( tt_check_trickyness_sfnt_ids( (TT_Face)face ) )\n      return TRUE;\n\n    return FALSE;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8079, "func": "void Gfx::doGouraudTriangleShFill(GfxGouraudTriangleShading *shading) {\n  double x0, y0, x1, y1, x2, y2;\n  GfxColor color0, color1, color2;\n  int i;\n\n  for (i = 0; i < shading->getNTriangles(); ++i) {\n    shading->getTriangle(i, &x0, &y0, &color0,\n\t\t\t &x1, &y1, &color1,\n\t\t\t &x2, &y2, &color2);\n    gouraudFillTriangle(x0, y0, &color0, x1, y1, &color1, x2, y2, &color2,\n\t\t\tshading->getColorSpace()->getNComps(), 0);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7875, "func": "static void reset_ram_globals(void)\n{\n    last_seen_block = NULL;\n    last_sent_block = NULL;\n    last_offset = 0;\n    last_version = ram_list.version;\n    ram_bulk_stage = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186724, "func": "void InputHandler::SetRenderer(RenderProcessHost* process_host,\n                                RenderFrameHostImpl* frame_host) {\n   if (frame_host == host_)\n     return;\n  ClearInputState();\n  if (host_) {\n    host_->GetRenderWidgetHost()->RemoveInputEventObserver(this);\n    if (ignore_input_events_)\n      host_->GetRenderWidgetHost()->SetIgnoreInputEvents(false);\n  }\n  host_ = frame_host;\n  if (host_) {\n    host_->GetRenderWidgetHost()->AddInputEventObserver(this);\n    if (ignore_input_events_)\n      host_->GetRenderWidgetHost()->SetIgnoreInputEvents(true);\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186711, "func": "  void SetState(MediaStreamType stream_type, MediaRequestState new_state) {\n    if (stream_type == NUM_MEDIA_TYPES) {\n      for (int i = MEDIA_NO_SERVICE + 1; i < NUM_MEDIA_TYPES; ++i) {\n        state_[static_cast<MediaStreamType>(i)] = new_state;\n      }\n    } else {\n      state_[stream_type] = new_state;\n    }\n\n    MediaObserver* media_observer =\n        GetContentClient()->browser()->GetMediaObserver();\n     if (!media_observer)\n       return;\n \n    media_observer->OnMediaRequestStateChanged(\n        target_process_id_, target_frame_id_, page_request_id,\n        security_origin.GetURL(), stream_type, new_state);\n   }\n", "target": 1, "flaw_line_index": "15,16,17"}
{"idx": 186384, "func": "void DataReductionProxyConfig::InitializeOnIOThread(\n    scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,\n    WarmupURLFetcher::CreateCustomProxyConfigCallback\n        create_custom_proxy_config_callback,\n    NetworkPropertiesManager* manager,\n    const std::string& user_agent) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n   network_properties_manager_ = manager;\n   network_properties_manager_->ResetWarmupURLFetchMetrics();\n \n  secure_proxy_checker_.reset(new SecureProxyChecker(url_loader_factory));\n  warmup_url_fetcher_.reset(new WarmupURLFetcher(\n      create_custom_proxy_config_callback,\n      base::BindRepeating(\n          &DataReductionProxyConfig::HandleWarmupFetcherResponse,\n          base::Unretained(this)),\n      base::BindRepeating(&DataReductionProxyConfig::GetHttpRttEstimate,\n                          base::Unretained(this)),\n      ui_task_runner_, user_agent));\n \n   AddDefaultProxyBypassRules();\n \n  network_connection_tracker_->AddNetworkConnectionObserver(this);\n  network_connection_tracker_->GetConnectionType(\n      &connection_type_,\n      base::BindOnce(&DataReductionProxyConfig::OnConnectionChanged,\n                     weak_factory_.GetWeakPtr()));\n}\n", "target": 1, "flaw_line_index": "11,12,13,14,15,16,17,18,19"}
{"idx": 7893, "func": "static int addstring(JF, const char *value)\n{\n\tint i;\n\tfor (i = 0; i < F->strlen; ++i)\n\t\tif (!strcmp(F->strtab[i], value))\n\t\t\treturn i;\n\tif (F->strlen >= F->strcap) {\n\t\tF->strcap = F->strcap ? F->strcap * 2 : 16;\n\t\tF->strtab = js_realloc(J, F->strtab, F->strcap * sizeof *F->strtab);\n\t}\n\tF->strtab[F->strlen] = value;\n\treturn F->strlen++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186932, "func": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n            R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n            R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n             R\"([^\\p{scx=arab}][\\u064b-\\u0655\\u0670]|)\"\n            R\"([^\\p{scx=hebr}]\\u05b4)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7725, "func": "static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)\n{\n    int err;\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp, head_fid;\n\n    head_fid.next = s->fid_list;\n    for (fidp = s->fid_list; fidp; fidp = fidp->next) {\n        if (fidp->path.size != path->size) {\n            continue;\n        }\n        if (!memcmp(fidp->path.data, path->data, path->size)) {\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n            err = v9fs_reopen_fid(pdu, fidp);\n            if (err < 0) {\n                return -1;\n            }\n            if (err == 0) {\n                fidp = &head_fid;\n            }\n        }\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186578, "func": "UnacceleratedStaticBitmapImage::UnacceleratedStaticBitmapImage(\n     sk_sp<SkImage> image) {\n   CHECK(image);\n   DCHECK(!image->isLazyGenerated());\n   paint_image_ =\n       CreatePaintImageBuilder()\n           .set_image(std::move(image), cc::PaintImage::GetNextContentId())\n          .TakePaintImage();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186482, "func": "EnumTraits<media::mojom::VideoCaptureError, media::VideoCaptureError>::ToMojom(\n    media::VideoCaptureError input) {\n  switch (input) {\n    case media::VideoCaptureError::kNone:\n      return media::mojom::VideoCaptureError::kNone;\n    case media::VideoCaptureError::\n        kVideoCaptureControllerInvalidOrUnsupportedVideoCaptureParametersRequested:\n      return media::mojom::VideoCaptureError::\n          kVideoCaptureControllerInvalidOrUnsupportedVideoCaptureParametersRequested;\n    case media::VideoCaptureError::kVideoCaptureControllerIsAlreadyInErrorState:\n      return media::mojom::VideoCaptureError::\n          kVideoCaptureControllerIsAlreadyInErrorState;\n    case media::VideoCaptureError::kVideoCaptureManagerDeviceConnectionLost:\n      return media::mojom::VideoCaptureError::\n          kVideoCaptureManagerDeviceConnectionLost;\n    case media::VideoCaptureError::\n        kFrameSinkVideoCaptureDeviceAleradyEndedOnFatalError:\n      return media::mojom::VideoCaptureError::\n          kFrameSinkVideoCaptureDeviceAleradyEndedOnFatalError;\n    case media::VideoCaptureError::\n        kFrameSinkVideoCaptureDeviceEncounteredFatalError:\n      return media::mojom::VideoCaptureError::\n          kFrameSinkVideoCaptureDeviceEncounteredFatalError;\n    case media::VideoCaptureError::kV4L2FailedToOpenV4L2DeviceDriverFile:\n      return media::mojom::VideoCaptureError::\n          kV4L2FailedToOpenV4L2DeviceDriverFile;\n    case media::VideoCaptureError::kV4L2ThisIsNotAV4L2VideoCaptureDevice:\n      return media::mojom::VideoCaptureError::\n          kV4L2ThisIsNotAV4L2VideoCaptureDevice;\n    case media::VideoCaptureError::kV4L2FailedToFindASupportedCameraFormat:\n      return media::mojom::VideoCaptureError::\n          kV4L2FailedToFindASupportedCameraFormat;\n    case media::VideoCaptureError::kV4L2FailedToSetVideoCaptureFormat:\n      return media::mojom::VideoCaptureError::\n          kV4L2FailedToSetVideoCaptureFormat;\n    case media::VideoCaptureError::kV4L2UnsupportedPixelFormat:\n      return media::mojom::VideoCaptureError::kV4L2UnsupportedPixelFormat;\n    case media::VideoCaptureError::kV4L2FailedToSetCameraFramerate:\n      return media::mojom::VideoCaptureError::kV4L2FailedToSetCameraFramerate;\n    case media::VideoCaptureError::kV4L2ErrorRequestingMmapBuffers:\n      return media::mojom::VideoCaptureError::kV4L2ErrorRequestingMmapBuffers;\n    case media::VideoCaptureError::kV4L2AllocateBufferFailed:\n      return media::mojom::VideoCaptureError::kV4L2AllocateBufferFailed;\n    case media::VideoCaptureError::kV4L2VidiocStreamonFailed:\n      return media::mojom::VideoCaptureError::kV4L2VidiocStreamonFailed;\n    case media::VideoCaptureError::kV4L2VidiocStreamoffFailed:\n      return media::mojom::VideoCaptureError::kV4L2VidiocStreamoffFailed;\n    case media::VideoCaptureError::kV4L2FailedToVidiocReqbufsWithCount0:\n      return media::mojom::VideoCaptureError::\n          kV4L2FailedToVidiocReqbufsWithCount0;\n    case media::VideoCaptureError::kV4L2PollFailed:\n      return media::mojom::VideoCaptureError::kV4L2PollFailed;\n    case media::VideoCaptureError::\n        kV4L2MultipleContinuousTimeoutsWhileReadPolling:\n      return media::mojom::VideoCaptureError::\n          kV4L2MultipleContinuousTimeoutsWhileReadPolling;\n    case media::VideoCaptureError::kV4L2FailedToDequeueCaptureBuffer:\n      return media::mojom::VideoCaptureError::kV4L2FailedToDequeueCaptureBuffer;\n    case media::VideoCaptureError::kV4L2FailedToEnqueueCaptureBuffer:\n      return media::mojom::VideoCaptureError::kV4L2FailedToEnqueueCaptureBuffer;\n    case media::VideoCaptureError::\n        kSingleClientVideoCaptureHostLostConnectionToDevice:\n      return media::mojom::VideoCaptureError::\n          kSingleClientVideoCaptureHostLostConnectionToDevice;\n    case media::VideoCaptureError::kSingleClientVideoCaptureDeviceLaunchAborted:\n      return media::mojom::VideoCaptureError::\n          kSingleClientVideoCaptureDeviceLaunchAborted;\n    case media::VideoCaptureError::\n        kDesktopCaptureDeviceWebrtcDesktopCapturerHasFailed:\n      return media::mojom::VideoCaptureError::\n          kDesktopCaptureDeviceWebrtcDesktopCapturerHasFailed;\n    case media::VideoCaptureError::kFileVideoCaptureDeviceCouldNotOpenVideoFile:\n      return media::mojom::VideoCaptureError::\n          kFileVideoCaptureDeviceCouldNotOpenVideoFile;\n    case media::VideoCaptureError::\n        kDeviceCaptureLinuxFailedToCreateVideoCaptureDelegate:\n      return media::mojom::VideoCaptureError::\n          kDeviceCaptureLinuxFailedToCreateVideoCaptureDelegate;\n    case media::VideoCaptureError::\n        kErrorFakeDeviceIntentionallyEmittingErrorEvent:\n      return media::mojom::VideoCaptureError::\n          kErrorFakeDeviceIntentionallyEmittingErrorEvent;\n    case media::VideoCaptureError::kDeviceClientTooManyFramesDroppedY16:\n      return media::mojom::VideoCaptureError::\n          kDeviceClientTooManyFramesDroppedY16;\n    case media::VideoCaptureError::\n        kDeviceMediaToMojoAdapterEncounteredUnsupportedBufferType:\n      return media::mojom::VideoCaptureError::\n          kDeviceMediaToMojoAdapterEncounteredUnsupportedBufferType;\n    case media::VideoCaptureError::\n        kVideoCaptureManagerProcessDeviceStartQueueDeviceInfoNotFound:\n      return media::mojom::VideoCaptureError::\n          kVideoCaptureManagerProcessDeviceStartQueueDeviceInfoNotFound;\n    case media::VideoCaptureError::\n        kInProcessDeviceLauncherFailedToCreateDeviceInstance:\n      return media::mojom::VideoCaptureError::\n          kInProcessDeviceLauncherFailedToCreateDeviceInstance;\n    case media::VideoCaptureError::\n        kServiceDeviceLauncherLostConnectionToDeviceFactoryDuringDeviceStart:\n      return media::mojom::VideoCaptureError::\n          kServiceDeviceLauncherLostConnectionToDeviceFactoryDuringDeviceStart;\n    case media::VideoCaptureError::\n        kServiceDeviceLauncherServiceRespondedWithDeviceNotFound:\n      return media::mojom::VideoCaptureError::\n          kServiceDeviceLauncherServiceRespondedWithDeviceNotFound;\n    case media::VideoCaptureError::\n        kServiceDeviceLauncherConnectionLostWhileWaitingForCallback:\n      return media::mojom::VideoCaptureError::\n          kServiceDeviceLauncherConnectionLostWhileWaitingForCallback;\n    case media::VideoCaptureError::kIntentionalErrorRaisedByUnitTest:\n      return media::mojom::VideoCaptureError::kIntentionalErrorRaisedByUnitTest;\n    case media::VideoCaptureError::kCrosHalV3FailedToStartDeviceThread:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3FailedToStartDeviceThread;\n    case media::VideoCaptureError::kCrosHalV3DeviceDelegateMojoConnectionError:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateMojoConnectionError;\n    case media::VideoCaptureError::\n        kCrosHalV3DeviceDelegateFailedToGetCameraInfo:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateFailedToGetCameraInfo;\n    case media::VideoCaptureError::\n        kCrosHalV3DeviceDelegateMissingSensorOrientationInfo:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateMissingSensorOrientationInfo;\n    case media::VideoCaptureError::\n        kCrosHalV3DeviceDelegateFailedToOpenCameraDevice:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateFailedToOpenCameraDevice;\n    case media::VideoCaptureError::\n        kCrosHalV3DeviceDelegateFailedToInitializeCameraDevice:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateFailedToInitializeCameraDevice;\n    case media::VideoCaptureError::\n        kCrosHalV3DeviceDelegateFailedToConfigureStreams:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateFailedToConfigureStreams;\n    case media::VideoCaptureError::\n        kCrosHalV3DeviceDelegateWrongNumberOfStreamsConfigured:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateWrongNumberOfStreamsConfigured;\n    case media::VideoCaptureError::\n        kCrosHalV3DeviceDelegateFailedToGetDefaultRequestSettings:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateFailedToGetDefaultRequestSettings;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerHalRequestedTooManyBuffers:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerHalRequestedTooManyBuffers;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerFailedToCreateGpuMemoryBuffer:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerFailedToCreateGpuMemoryBuffer;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerFailedToMapGpuMemoryBuffer:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerFailedToMapGpuMemoryBuffer;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerUnsupportedVideoPixelFormat:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerUnsupportedVideoPixelFormat;\n    case media::VideoCaptureError::kCrosHalV3BufferManagerFailedToDupFd:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerFailedToDupFd;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerFailedToWrapGpuMemoryHandle:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerFailedToWrapGpuMemoryHandle;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerFailedToRegisterBuffer:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerFailedToRegisterBuffer;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerProcessCaptureRequestFailed:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerProcessCaptureRequestFailed;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerInvalidPendingResultId:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerInvalidPendingResultId;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerReceivedDuplicatedPartialMetadata:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerReceivedDuplicatedPartialMetadata;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerIncorrectNumberOfOutputBuffersReceived:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerIncorrectNumberOfOutputBuffersReceived;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerInvalidTypeOfOutputBuffersReceived:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerInvalidTypeOfOutputBuffersReceived;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerReceivedMultipleResultBuffersForFrame:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerReceivedMultipleResultBuffersForFrame;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerUnknownStreamInCamera3NotifyMsg:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerUnknownStreamInCamera3NotifyMsg;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerReceivedInvalidShutterTime:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerReceivedInvalidShutterTime;\n    case media::VideoCaptureError::kCrosHalV3BufferManagerFatalDeviceError:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerFatalDeviceError;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerReceivedFrameIsOutOfOrder:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerReceivedFrameIsOutOfOrder;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerFailedToUnwrapReleaseFenceFd:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerFailedToUnwrapReleaseFenceFd;\n    case media::VideoCaptureError::\n        kCrosHalV3BufferManagerSyncWaitOnReleaseFenceTimedOut:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerSyncWaitOnReleaseFenceTimedOut;\n    case media::VideoCaptureError::kCrosHalV3BufferManagerInvalidJpegBlob:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3BufferManagerInvalidJpegBlob;\n    case media::VideoCaptureError::kAndroidFailedToAllocate:\n      return media::mojom::VideoCaptureError::kAndroidFailedToAllocate;\n    case media::VideoCaptureError::kAndroidFailedToStartCapture:\n      return media::mojom::VideoCaptureError::kAndroidFailedToStartCapture;\n    case media::VideoCaptureError::kAndroidFailedToStopCapture:\n      return media::mojom::VideoCaptureError::kAndroidFailedToStopCapture;\n    case media::VideoCaptureError::kAndroidApi1CameraErrorCallbackReceived:\n      return media::mojom::VideoCaptureError::\n          kAndroidApi1CameraErrorCallbackReceived;\n    case media::VideoCaptureError::kAndroidApi2CameraDeviceErrorReceived:\n      return media::mojom::VideoCaptureError::\n          kAndroidApi2CameraDeviceErrorReceived;\n    case media::VideoCaptureError::kAndroidApi2CaptureSessionConfigureFailed:\n      return media::mojom::VideoCaptureError::\n          kAndroidApi2CaptureSessionConfigureFailed;\n    case media::VideoCaptureError::kAndroidApi2ImageReaderUnexpectedImageFormat:\n      return media::mojom::VideoCaptureError::\n          kAndroidApi2ImageReaderUnexpectedImageFormat;\n    case media::VideoCaptureError::\n        kAndroidApi2ImageReaderSizeDidNotMatchImageSize:\n      return media::mojom::VideoCaptureError::\n          kAndroidApi2ImageReaderSizeDidNotMatchImageSize;\n    case media::VideoCaptureError::kAndroidApi2ErrorRestartingPreview:\n      return media::mojom::VideoCaptureError::\n          kAndroidApi2ErrorRestartingPreview;\n    case media::VideoCaptureError::kAndroidScreenCaptureUnsupportedFormat:\n      return media::mojom::VideoCaptureError::\n          kAndroidScreenCaptureUnsupportedFormat;\n    case media::VideoCaptureError::\n        kAndroidScreenCaptureFailedToStartCaptureMachine:\n      return media::mojom::VideoCaptureError::\n          kAndroidScreenCaptureFailedToStartCaptureMachine;\n    case media::VideoCaptureError::\n        kAndroidScreenCaptureTheUserDeniedScreenCapture:\n      return media::mojom::VideoCaptureError::\n          kAndroidScreenCaptureTheUserDeniedScreenCapture;\n    case media::VideoCaptureError::\n        kAndroidScreenCaptureFailedToStartScreenCapture:\n      return media::mojom::VideoCaptureError::\n          kAndroidScreenCaptureFailedToStartScreenCapture;\n    case media::VideoCaptureError::kWinDirectShowCantGetCaptureFormatSettings:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowCantGetCaptureFormatSettings;\n    case media::VideoCaptureError::\n        kWinDirectShowFailedToGetNumberOfCapabilities:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowFailedToGetNumberOfCapabilities;\n    case media::VideoCaptureError::\n        kWinDirectShowFailedToGetCaptureDeviceCapabilities:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowFailedToGetCaptureDeviceCapabilities;\n    case media::VideoCaptureError::\n        kWinDirectShowFailedToSetCaptureDeviceOutputFormat:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowFailedToSetCaptureDeviceOutputFormat;\n    case media::VideoCaptureError::kWinDirectShowFailedToConnectTheCaptureGraph:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowFailedToConnectTheCaptureGraph;\n    case media::VideoCaptureError::kWinDirectShowFailedToPauseTheCaptureDevice:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowFailedToPauseTheCaptureDevice;\n    case media::VideoCaptureError::kWinDirectShowFailedToStartTheCaptureDevice:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowFailedToStartTheCaptureDevice;\n    case media::VideoCaptureError::kWinDirectShowFailedToStopTheCaptureGraph:\n      return media::mojom::VideoCaptureError::\n          kWinDirectShowFailedToStopTheCaptureGraph;\n    case media::VideoCaptureError::kWinMediaFoundationEngineIsNull:\n      return media::mojom::VideoCaptureError::kWinMediaFoundationEngineIsNull;\n    case media::VideoCaptureError::kWinMediaFoundationEngineGetSourceFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationEngineGetSourceFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationFillPhotoCapabilitiesFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationFillPhotoCapabilitiesFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationFillVideoCapabilitiesFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationFillVideoCapabilitiesFailed;\n    case media::VideoCaptureError::kWinMediaFoundationNoVideoCapabilityFound:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationNoVideoCapabilityFound;\n    case media::VideoCaptureError::\n        kWinMediaFoundationGetAvailableDeviceMediaTypeFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationGetAvailableDeviceMediaTypeFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationSetCurrentDeviceMediaTypeFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationSetCurrentDeviceMediaTypeFailed;\n    case media::VideoCaptureError::kWinMediaFoundationEngineGetSinkFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationEngineGetSinkFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationSinkQueryCapturePreviewInterfaceFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationSinkQueryCapturePreviewInterfaceFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationSinkRemoveAllStreamsFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationSinkRemoveAllStreamsFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationCreateSinkVideoMediaTypeFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationCreateSinkVideoMediaTypeFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationConvertToVideoSinkMediaTypeFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationConvertToVideoSinkMediaTypeFailed;\n    case media::VideoCaptureError::kWinMediaFoundationSinkAddStreamFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationSinkAddStreamFailed;\n    case media::VideoCaptureError::\n        kWinMediaFoundationSinkSetSampleCallbackFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationSinkSetSampleCallbackFailed;\n    case media::VideoCaptureError::kWinMediaFoundationEngineStartPreviewFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationEngineStartPreviewFailed;\n    case media::VideoCaptureError::kWinMediaFoundationGetMediaEventStatusFailed:\n      return media::mojom::VideoCaptureError::\n          kWinMediaFoundationGetMediaEventStatusFailed;\n    case media::VideoCaptureError::kMacSetCaptureDeviceFailed:\n      return media::mojom::VideoCaptureError::kMacSetCaptureDeviceFailed;\n    case media::VideoCaptureError::kMacCouldNotStartCaptureDevice:\n      return media::mojom::VideoCaptureError::kMacCouldNotStartCaptureDevice;\n    case media::VideoCaptureError::kMacReceivedFrameWithUnexpectedResolution:\n      return media::mojom::VideoCaptureError::\n          kMacReceivedFrameWithUnexpectedResolution;\n    case media::VideoCaptureError::kMacUpdateCaptureResolutionFailed:\n      return media::mojom::VideoCaptureError::kMacUpdateCaptureResolutionFailed;\n    case media::VideoCaptureError::kMacDeckLinkDeviceIdNotFoundInTheSystem:\n      return media::mojom::VideoCaptureError::\n          kMacDeckLinkDeviceIdNotFoundInTheSystem;\n    case media::VideoCaptureError::kMacDeckLinkErrorQueryingInputInterface:\n      return media::mojom::VideoCaptureError::\n          kMacDeckLinkErrorQueryingInputInterface;\n    case media::VideoCaptureError::kMacDeckLinkErrorCreatingDisplayModeIterator:\n      return media::mojom::VideoCaptureError::\n          kMacDeckLinkErrorCreatingDisplayModeIterator;\n    case media::VideoCaptureError::kMacDeckLinkCouldNotFindADisplayMode:\n      return media::mojom::VideoCaptureError::\n          kMacDeckLinkCouldNotFindADisplayMode;\n    case media::VideoCaptureError::\n        kMacDeckLinkCouldNotSelectTheVideoFormatWeLike:\n      return media::mojom::VideoCaptureError::\n          kMacDeckLinkCouldNotSelectTheVideoFormatWeLike;\n    case media::VideoCaptureError::kMacDeckLinkCouldNotStartCapturing:\n      return media::mojom::VideoCaptureError::\n          kMacDeckLinkCouldNotStartCapturing;\n    case media::VideoCaptureError::kMacDeckLinkUnsupportedPixelFormat:\n      return media::mojom::VideoCaptureError::\n          kMacDeckLinkUnsupportedPixelFormat;\n    case media::VideoCaptureError::\n        kMacAvFoundationReceivedAVCaptureSessionRuntimeErrorNotification:\n      return media::mojom::VideoCaptureError::\n          kMacAvFoundationReceivedAVCaptureSessionRuntimeErrorNotification;\n     case media::VideoCaptureError::kAndroidApi2ErrorConfiguringCamera:\n       return media::mojom::VideoCaptureError::\n           kAndroidApi2ErrorConfiguringCamera;\n    case media::VideoCaptureError::kCrosHalV3DeviceDelegateFailedToFlush:\n      return media::mojom::VideoCaptureError::\n          kCrosHalV3DeviceDelegateFailedToFlush;\n   }\n   NOTREACHED();\n   return media::mojom::VideoCaptureError::kNone;\n}\n", "target": 1, "flaw_line_index": "384,385,386"}
{"idx": 186562, "func": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n   Process();\n \n   if (link_)\n    link_->OwnerInserted();\n\n  return kInsertionDone;\n}\n", "target": 1, "flaw_line_index": "15"}
{"idx": 186713, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u0527\u0529] > h;\"\n                                   \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f] > n; [\u0167\u0442\u04ad] > t;\"\n                                    \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1f] > w; [\u043c\u04ce] > m;\"\n                                   \"[\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; \u0493 > f; [\u04ab\u1004] > c;\"\n                                    \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                    \"\u04cf > l;\"\n #endif\n                                   \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23] > s; \u1042 > j\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8060, "func": "char **FoFiType1::getEncoding() {\n  if (!parsed) {\n    parse();\n  }\n  return encoding;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7882, "func": "static void xbzrle_cache_zero_page(ram_addr_t current_addr)\n{\n    if (ram_bulk_stage || !migrate_use_xbzrle()) {\n        return;\n    }\n\n    cache_insert(XBZRLE.cache, current_addr, ZERO_TARGET_PAGE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7896, "func": "static int cargs(JF, js_Ast *list)\n{\n\tint n = 0;\n\twhile (list) {\n\t\tcexp(J, F, list->a);\n\t\tlist = list->b;\n\t\t++n;\n\t}\n\treturn n;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186760, "func": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (state_ == WORKER_READY) {\n    if (sessions().size() == 1) {\n      BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                               base::BindOnce(&SetDevToolsAttachedOnIO,\n                                              context_weak_, version_id_, true));\n     }\n    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),\n                         nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n}\n", "target": 1, "flaw_line_index": "8,9,10,11"}
{"idx": 186694, "func": "bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (!render_frame_created_)\n    return false;\n\n  ScopedActiveURL scoped_active_url(this);\n\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_RenderProcessGone, OnRenderProcessGone)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n\n  if (handled)\n    return true;\n\n  if (delegate_->OnMessageReceived(this, msg))\n    return true;\n\n  RenderFrameProxyHost* proxy =\n      frame_tree_node_->render_manager()->GetProxyToParent();\n  if (proxy && proxy->cross_process_frame_connector() &&\n      proxy->cross_process_frame_connector()->OnMessageReceived(msg))\n    return true;\n\n  handled = true;\n  IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAddMessageToConsole,\n                        OnDidAddMessageToConsole)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoad,\n                        OnDidStartProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateState, OnUpdateState)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DocumentOnLoadCompleted,\n                        OnDocumentOnLoadCompleted)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_VisualStateResponse,\n                        OnVisualStateResponse)\n    IPC_MESSAGE_HANDLER_DELAY_REPLY(FrameHostMsg_RunJavaScriptDialog,\n                                    OnRunJavaScriptDialog)\n    IPC_MESSAGE_HANDLER_DELAY_REPLY(FrameHostMsg_RunBeforeUnloadConfirm,\n                                    OnRunBeforeUnloadConfirm)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_RunFileChooser, OnRunFileChooser)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAccessInitialDocument,\n                        OnDidAccessInitialDocument)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeOpener, OnDidChangeOpener)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAddContentSecurityPolicies,\n                        OnDidAddContentSecurityPolicies)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeFramePolicy,\n                        OnDidChangeFramePolicy)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeFrameOwnerProperties,\n                        OnDidChangeFrameOwnerProperties)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateTitle, OnUpdateTitle)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidBlockFramebust, OnDidBlockFramebust)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_AbortNavigation, OnAbortNavigation)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DispatchLoad, OnDispatchLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ForwardResourceTimingToParent,\n                        OnForwardResourceTimingToParent)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_TextSurroundingSelectionResponse,\n                        OnTextSurroundingSelectionResponse)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_Events, OnAccessibilityEvents)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_LocationChanges,\n                        OnAccessibilityLocationChanges)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_FindInPageResult,\n                        OnAccessibilityFindInPageResult)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_ChildFrameHitTestResult,\n                        OnAccessibilityChildFrameHitTestResult)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_SnapshotResponse,\n                        OnAccessibilitySnapshotResponse)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ToggleFullscreen, OnToggleFullscreen)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SuddenTerminationDisablerChanged,\n                        OnSuddenTerminationDisablerChanged)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeLoadProgress,\n                        OnDidChangeLoadProgress)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SerializeAsMHTMLResponse,\n                        OnSerializeAsMHTMLResponse)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SelectionChanged, OnSelectionChanged)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FocusedNodeChanged, OnFocusedNodeChanged)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SetHasReceivedUserGesture,\n                        OnSetHasReceivedUserGesture)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SetHasReceivedUserGestureBeforeNavigation,\n                         OnSetHasReceivedUserGestureBeforeNavigation)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_ScrollRectToVisibleInParentFrame,\n                         OnScrollRectToVisibleInParentFrame)\n #if BUILDFLAG(USE_EXTERNAL_POPUP_MENU)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_ShowPopup, OnShowPopup)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_HidePopup, OnHidePopup)\n#endif\n    IPC_MESSAGE_HANDLER(FrameHostMsg_RequestOverlayRoutingToken,\n                        OnRequestOverlayRoutingToken)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ShowCreatedWindow, OnShowCreatedWindow)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_StreamHandleConsumed,\n                        OnStreamHandleConsumed)\n  IPC_END_MESSAGE_MAP()\n\n  return handled;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186985, "func": "  void ClearActiveTab() {\n    active_tab_->permissions_data()->ClearTabSpecificPermissions(kTabId);\n   }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7976, "func": "VncInfo *qmp_query_vnc(Error **errp)\n{\n    VncInfo *info = g_malloc0(sizeof(*info));\n\n    if (vnc_display == NULL || vnc_display->display == NULL) {\n        info->enabled = false;\n    } else {\n        VncClientInfoList *cur_item = NULL;\n        struct sockaddr_storage sa;\n        socklen_t salen = sizeof(sa);\n        char host[NI_MAXHOST];\n        char serv[NI_MAXSERV];\n        VncState *client;\n\n        info->enabled = true;\n\n        info->has_clients = true;\n\n        QTAILQ_FOREACH(client, &vnc_display->clients, next) {\n            VncClientInfoList *cinfo = g_malloc0(sizeof(*info));\n            cinfo->value = qmp_query_vnc_client(client);\n\n            if (!cur_item) {\n                info->clients = cur_item = cinfo;\n            } else {\n                cur_item->next = cinfo;\n                cur_item = cinfo;\n            }\n        }\n\n        if (vnc_display->lsock == -1) {\n            return info;\n        }\n\n        if (getsockname(vnc_display->lsock, (struct sockaddr *)&sa,\n                        &salen) == -1) {\n            error_set(errp, QERR_UNDEFINED_ERROR);\n            goto out_error;\n        }\n\n        if (getnameinfo((struct sockaddr *)&sa, salen,\n                        host, sizeof(host),\n                        serv, sizeof(serv),\n                        NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n            error_set(errp, QERR_UNDEFINED_ERROR);\n            goto out_error;\n        }\n\n        info->has_host = true;\n        info->host = g_strdup(host);\n\n        info->has_service = true;\n        info->service = g_strdup(serv);\n\n        info->has_family = true;\n        info->family = inet_netfamily(sa.ss_family);\n\n        info->has_auth = true;\n        info->auth = g_strdup(vnc_auth_name(vnc_display));\n    }\n\n    return info;\n\nout_error:\n    qapi_free_VncInfo(info);\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7558, "func": "PHPAPI void var_push_dtor_no_addref(php_unserialize_data_t *var_hashx, zval **rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last_dtor;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push_dtor_no_addref(%ld): %d (%d)\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_PP(rval), Z_REFCOUNT_PP(rval));\n#endif\n\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\n\t\tif (!(*var_hashx)->first_dtor) {\n\t\t\t(*var_hashx)->first_dtor = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last_dtor)->next = var_hash;\n\t\t}\n\n\t\t(*var_hashx)->last_dtor = var_hash;\n\t}\n\n\tvar_hash->data[var_hash->used_slots++] = *rval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186961, "func": " bool AppCacheDatabase::UpgradeSchema() {\n  return DeleteExistingAndCreateNewDatabase();\n }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8091, "func": "Operator *Gfx::findOp(char *name) {\n  int a, b, m, cmp;\n\n  a = -1;\n  b = numOps;\n  while (b - a > 1) {\n    m = (a + b) / 2;\n    cmp = strcmp(opTab[m].name, name);\n    if (cmp < 0)\n      a = m;\n    else if (cmp > 0)\n      b = m;\n    else\n      a = b = m;\n  }\n  if (cmp != 0)\n    return NULL;\n  return &opTab[a];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7568, "func": "static void cirrus_bitblt_rop_nop(CirrusVGAState *s,\n                                  uint8_t *dst,const uint8_t *src,\n                                  int dstpitch,int srcpitch,\n                                  int bltwidth,int bltheight)\n{\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186501, "func": "error::Error GLES2DecoderPassthroughImpl::DoBeginQueryEXT(\n    GLenum target,\n    GLuint id,\n    int32_t sync_shm_id,\n    uint32_t sync_shm_offset) {\n  GLuint service_id = GetQueryServiceID(id, &query_id_map_);\n  QueryInfo* query_info = &query_info_map_[service_id];\n\n  scoped_refptr<gpu::Buffer> buffer = GetSharedMemoryBuffer(sync_shm_id);\n  if (!buffer)\n    return error::kInvalidArguments;\n  QuerySync* sync = static_cast<QuerySync*>(\n      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));\n   if (!sync)\n     return error::kOutOfBounds;\n \n   if (IsEmulatedQueryTarget(target)) {\n     if (active_queries_.find(target) != active_queries_.end()) {\n       InsertError(GL_INVALID_OPERATION, \"Query already active on target.\");\n      return error::kNoError;\n    }\n\n    if (id == 0) {\n      InsertError(GL_INVALID_OPERATION, \"Query id is 0.\");\n      return error::kNoError;\n    }\n\n    if (query_info->type != GL_NONE && query_info->type != target) {\n      InsertError(GL_INVALID_OPERATION,\n                  \"Query type does not match the target.\");\n      return error::kNoError;\n    }\n  } else {\n    CheckErrorCallbackState();\n\n    api()->glBeginQueryFn(target, service_id);\n\n    if (CheckErrorCallbackState()) {\n      return error::kNoError;\n    }\n  }\n\n  query_info->type = target;\n\n  RemovePendingQuery(service_id);\n\n  ActiveQuery query;\n  query.service_id = service_id;\n  query.shm = std::move(buffer);\n  query.sync = sync;\n  active_queries_[target] = std::move(query);\n\n  return error::kNoError;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7584, "func": "static uint64_t cirrus_linear_bitblt_read(void *opaque,\n                                          hwaddr addr,\n                                          unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    (void)s;\n    ret = 0xff;\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7616, "func": "static void isa_cirrus_vga_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    dc->vmsd  = &vmstate_cirrus_vga;\n    dc->realize = isa_cirrus_vga_realizefn;\n    dc->props = isa_cirrus_vga_properties;\n    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7790, "func": "static int h2c_ack_settings(struct h2c *h2c)\n{\n\tstruct buffer *res;\n\tchar str[9];\n\tint ret = -1;\n\n\tif (h2c_mux_busy(h2c, NULL)) {\n\t\th2c->flags |= H2_CF_DEM_MBUSY;\n\t\treturn 0;\n\t}\n\n\tres = h2_get_buf(h2c, &h2c->mbuf);\n\tif (!res) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\treturn 0;\n\t}\n\n\tmemcpy(str,\n\t       \"\\x00\\x00\\x00\"     \n\t       \"\\x04\" \"\\x01\"      \n\t       \"\\x00\\x00\\x00\\x00\" \n, 9);\n\n\tret = bo_istput(res, ist2(str, 9));\n\tif (unlikely(ret <= 0)) {\n\t\tif (!ret) {\n\t\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7824, "func": "  TT_MulFix14( FT_Int32  a,\n               FT_Int    b )\n  {\n    FT_Int32   sign;\n    FT_UInt32  ah, al, mid, lo, hi;\n\n\n    sign = a ^ b;\n\n    if ( a < 0 )\n      a = -a;\n    if ( b < 0 )\n      b = -b;\n\n    ah = (FT_UInt32)( ( a >> 16 ) & 0xFFFFU );\n    al = (FT_UInt32)( a & 0xFFFFU );\n\n    lo    = al * b;\n    mid   = ah * b;\n    hi    = mid >> 16;\n    mid   = ( mid << 16 ) + ( 1 << 13 ); \n    lo   += mid;\n    if ( lo < mid )\n      hi += 1;\n\n    mid = ( lo >> 14 ) | ( hi << 18 );\n\n    return sign >= 0 ? (FT_Int32)mid : -(FT_Int32)mid;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186903, "func": "static void ProxyLocaltimeCallToBrowser(time_t input, struct tm* output,\n                                        char* timezone_out,\n                                        size_t timezone_out_len) {\n  base::Pickle request;\n  request.WriteInt(LinuxSandbox::METHOD_LOCALTIME);\n   request.WriteString(\n       std::string(reinterpret_cast<char*>(&input), sizeof(input)));\n \n   uint8_t reply_buf[512];\n   const ssize_t r = base::UnixDomainSocket::SendRecvMsg(\n       GetSandboxFD(), reply_buf, sizeof(reply_buf), NULL, request);\n   if (r == -1) {\n    memset(output, 0, sizeof(struct tm));\n     return;\n   }\n \n   base::Pickle reply(reinterpret_cast<char*>(reply_buf), r);\n   base::PickleIterator iter(reply);\n  std::string result;\n  std::string timezone;\n  if (!iter.ReadString(&result) ||\n      !iter.ReadString(&timezone) ||\n      result.size() != sizeof(struct tm)) {\n     memset(output, 0, sizeof(struct tm));\n    return;\n  }\n  memcpy(output, result.data(), sizeof(struct tm));\n  if (timezone_out_len) {\n    const size_t copy_len = std::min(timezone_out_len - 1, timezone.size());\n    memcpy(timezone_out, timezone.data(), copy_len);\n    timezone_out[copy_len] = 0;\n    output->tm_zone = timezone_out;\n  } else {\n    base::AutoLock lock(g_timezones_lock.Get());\n    auto ret_pair = g_timezones.Get().insert(timezone);\n    output->tm_zone = ret_pair.first->c_str();\n   }\n }\n", "target": 1, "flaw_line_index": "13,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36"}
{"idx": 8116, "func": "void Gfx::opCurveTo1(Object args[], int numArgs) {\n  double x1, y1, x2, y2, x3, y3;\n\n  if (!state->isCurPt()) {\n    error(getPos(), \"No current point in curveto1\");\n    return;\n  }\n  x1 = state->getCurX();\n  y1 = state->getCurY();\n  x2 = args[0].getNum();\n  y2 = args[1].getNum();\n  x3 = args[2].getNum();\n  y3 = args[3].getNum();\n  state->curveTo(x1, y1, x2, y2, x3, y3);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186928, "func": "  TestJavaScriptDialogManager()\n       : is_fullscreen_(false), message_loop_runner_(new MessageLoopRunner) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7902, "func": "static void cassignop2(JF, js_Ast *lhs, int postfix)\n{\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\tif (postfix) emit(J, F, OP_ROT2);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tif (postfix) emit(J, F, OP_ROT4);\n\t\temit(J, F, OP_SETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tif (postfix) emit(J, F, OP_ROT3);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8035, "func": "int vnc_raw_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int i;\n    uint8_t *row;\n    VncDisplay *vd = vs->vd;\n\n    row = vnc_server_fb_ptr(vd, x, y);\n    for (i = 0; i < h; i++) {\n        vs->write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);\n        row += vnc_server_fb_stride(vd);\n    }\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7992, "func": "static VncBasicInfo *vnc_basic_info_get_from_server_addr(int fd)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    return vnc_basic_info_get(&sa, salen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186587, "func": " bool ChildProcessSecurityPolicyImpl::CanCommitURL(int child_id,\n                                                  const GURL& url) {\n   if (!url.is_valid())\n     return false;  \n \n  const std::string& scheme = url.scheme();\n\n  if (IsPseudoScheme(scheme))\n    return url == url::kAboutBlankURL || url == kAboutSrcDocURL;\n\n  if (url.SchemeIsBlob() || url.SchemeIsFileSystem()) {\n    if (IsMalformedBlobUrl(url))\n       return false;\n \n     url::Origin origin = url::Origin::Create(url);\n    return origin.unique() || CanCommitURL(child_id, GURL(origin.Serialize()));\n   }\n \n   {\n     base::AutoLock lock(lock_);\n \n     if (base::ContainsKey(schemes_okay_to_commit_in_any_process_, scheme))\n       return true;\n\n    SecurityStateMap::iterator state = security_state_.find(child_id);\n    if (state == security_state_.end())\n      return false;\n\n    return state->second->CanCommitURL(url);\n   }\n }\n", "target": 1, "flaw_line_index": "2,20,30,31,32"}
{"idx": 186892, "func": " void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n    callback.Run(success, std::move(global_memory_dump));\n  };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, allocator_dump_names,\n                           false \n, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7829, "func": "  TT_Set_CodeRange( TT_ExecContext  exec,\n                    FT_Int          range,\n                    void*           base,\n                    FT_Long         length )\n  {\n    FT_ASSERT( range >= 1 && range <= 3 );\n\n    exec->codeRangeTable[range - 1].base = (FT_Byte*)base;\n    exec->codeRangeTable[range - 1].size = length;\n\n    return TT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186659, "func": "bool WebGLImageConversion::ExtractTextureData(unsigned width,\n                                              unsigned height,\n                                              GLenum format,\n                                              GLenum type,\n                                              unsigned unpack_alignment,\n                                              bool flip_y,\n                                              bool premultiply_alpha,\n                                              const void* pixels,\n                                              Vector<uint8_t>& data) {\n   DataFormat source_data_format = GetDataFormat(format, type);\n   if (source_data_format == kDataFormatNumFormats)\n    return false;\n\n  unsigned int components_per_pixel, bytes_per_component;\n  if (!ComputeFormatAndTypeParameters(format, type, &components_per_pixel,\n                                      &bytes_per_component))\n    return false;\n   unsigned bytes_per_pixel = components_per_pixel * bytes_per_component;\n   data.resize(width * height * bytes_per_pixel);\n \n  if (!PackPixels(static_cast<const uint8_t*>(pixels), source_data_format,\n                  width, height, IntRect(0, 0, width, height), 1,\n                  unpack_alignment, 0, format, type,\n                   (premultiply_alpha ? kAlphaDoPremultiply : kAlphaDoNothing),\n                   data.data(), flip_y))\n     return false;\n\n  return true;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,23,24,25"}
{"idx": 7468, "func": "  t1_decoder_parse_glyph( T1_Decoder  decoder,\n                          FT_UInt     glyph )\n  {\n    return decoder->parse_callback( decoder, glyph );\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7620, "func": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n{\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n     CirrusVGAState *s = &d->cirrus_vga;\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n     int16_t device_id = pc->device_id;\n\n     if (s->vga.vram_size_mb != 4 && s->vga.vram_size_mb != 8 &&\n         s->vga.vram_size_mb != 16) {\n         error_report(\"Invalid cirrus_vga ram size '%u'\",\n                      s->vga.vram_size_mb);\n         return -1;\n     }\n     vga_common_init(&s->vga, OBJECT(dev), true);\n     cirrus_init_common(s, OBJECT(dev), device_id, 1, pci_address_space(dev),\n                        pci_address_space_io(dev));\n     s->vga.con = graphic_console_init(DEVICE(dev), 0, s->vga.hw_ops, &s->vga);\n\n\n    memory_region_init(&s->pci_bar, OBJECT(dev), \"cirrus-pci-bar0\", 0x2000000);\n\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n                                &s->cirrus_linear_bitblt_io);\n\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n     if (device_id == CIRRUS_ID_CLGD5446) {\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n     }\n     return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7883, "func": "uint64_t xbzrle_mig_bytes_transferred(void)\n{\n    return acct_info.xbzrle_bytes;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7552, "func": "static inline long parse_iv2(const unsigned char *p, const unsigned char **q)\n{\n\tchar cursor;\n\tlong result = 0;\n\tint neg = 0;\n\n\tswitch (*p) {\n\t\tcase '-':\n\t\t\tneg++;\n\t\tcase '+':\n\t\t\tp++;\n\t}\n\t\n\twhile (1) {\n\t\tcursor = (char)*p;\n\t\tif (cursor >= '0' && cursor <= '9') {\n\t\t\tresult = result * 10 + (size_t)(cursor - (unsigned char)'0');\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\tif (q) *q = p;\n\tif (neg) return -result;\n\treturn result;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7820, "func": "  TT_Clear_CodeRange( TT_ExecContext  exec,\n                      FT_Int          range )\n  {\n    FT_ASSERT( range >= 1 && range <= 3 );\n\n    exec->codeRangeTable[range - 1].base = NULL;\n    exec->codeRangeTable[range - 1].size = 0;\n\n    return TT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7504, "func": "simple_method_call (void)\n{\n  DBusMessage *message;\n  message = dbus_message_new_method_call (\"o.b.Q\",\n                                          \"/f/b\",\n                                          \"o.b.Z\",\n                                          \"Fro\");\n  if (message == NULL)\n    _dbus_assert_not_reached (\"oom\");\n  return message;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7544, "func": "revert_tz (timezone_t tz)\n{\n  if (tz == local_tz)\n    return true;\n  else\n    {\n      int saved_errno = errno;\n      bool ok = change_env (tz);\n      if (!ok)\n        saved_errno = errno;\n      tzfree (tz);\n      errno = saved_errno;\n      return ok;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8004, "func": "static long vnc_client_write_plain(VncState *vs)\n{\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    VNC_DEBUG(\"Write Plain: Pending output %p size %zd offset %zd. Wait SSF %d\\n\",\n              vs->output.buffer, vs->output.capacity, vs->output.offset,\n              vs->sasl.waitWriteSSF);\n\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        vs->sasl.waitWriteSSF) {\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);\n        if (ret)\n            vs->sasl.waitWriteSSF -= ret;\n    } else\n#endif \n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);\n    if (!ret)\n        return 0;\n\n    buffer_advance(&vs->output, ret);\n\n    if (vs->output.offset == 0) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7716, "func": "static int v9fs_fill_statfs(V9fsState *s, V9fsPDU *pdu, struct statfs *stbuf)\n{\n    uint32_t f_type;\n    uint32_t f_bsize;\n    uint64_t f_blocks;\n    uint64_t f_bfree;\n    uint64_t f_bavail;\n    uint64_t f_files;\n    uint64_t f_ffree;\n    uint64_t fsid_val;\n    uint32_t f_namelen;\n    size_t offset = 7;\n    int32_t bsize_factor;\n\n    bsize_factor = (s->msize - P9_IOHDRSZ)/stbuf->f_bsize;\n    if (!bsize_factor) {\n        bsize_factor = 1;\n    }\n    f_type  = stbuf->f_type;\n    f_bsize = stbuf->f_bsize;\n    f_bsize *= bsize_factor;\n    f_blocks = stbuf->f_blocks/bsize_factor;\n    f_bfree  = stbuf->f_bfree/bsize_factor;\n    f_bavail = stbuf->f_bavail/bsize_factor;\n    f_files  = stbuf->f_files;\n    f_ffree  = stbuf->f_ffree;\n    fsid_val = (unsigned int) stbuf->f_fsid.__val[0] |\n               (unsigned long long)stbuf->f_fsid.__val[1] << 32;\n    f_namelen = stbuf->f_namelen;\n\n    return pdu_marshal(pdu, offset, \"ddqqqqqqd\",\n                       f_type, f_bsize, f_blocks, f_bfree,\n                       f_bavail, f_files, f_ffree,\n                       fsid_val, f_namelen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7977, "func": "static VncClientInfo *qmp_query_vnc_client(const VncState *client)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    VncClientInfo *info;\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n                    host, sizeof(host),\n                    serv, sizeof(serv),\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(*info));\n    info->base = g_malloc0(sizeof(*info->base));\n    info->base->host = g_strdup(host);\n    info->base->service = g_strdup(serv);\n    info->base->family = inet_netfamily(sa.ss_family);\n\n#ifdef CONFIG_VNC_TLS\n    if (client->tls.session && client->tls.dname) {\n        info->has_x509_dname = true;\n        info->x509_dname = g_strdup(client->tls.dname);\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn && client->sasl.username) {\n        info->has_sasl_username = true;\n        info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n\n    return info;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187017, "func": "    CancelPendingTask() {\n  filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                 MSG_ROUTING_NONE \n);\n}\n", "target": 1, "flaw_line_index": "2,4,5"}
{"idx": 186430, "func": "std::string SanitizeRemoteBase(const std::string& value) {\n  GURL url(value);\n  std::string path = url.path();\n  std::vector<std::string> parts = base::SplitString(\n      path, \"/\", base::KEEP_WHITESPACE, base::SPLIT_WANT_ALL);\n  std::string revision = parts.size() > 2 ? parts[2] : \"\";\n  revision = SanitizeRevision(revision);\n  path = base::StringPrintf(\"/%s/%s/\", kRemoteFrontendPath, revision.c_str());\n  return SanitizeFrontendURL(url, url::kHttpsScheme,\n                             kRemoteFrontendDomain, path, false).spec();\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11"}
{"idx": 187021, "func": "ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(\n    RenderFrameHost* plugin_rfh,\n    int32_t guest_instance_id,\n    int32_t element_instance_id,\n    bool is_full_page_plugin,\n    ExtensionsGuestViewMessageFilter* filter)\n    : content::WebContentsObserver(\n          content::WebContents::FromRenderFrameHost(plugin_rfh)),\n      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),\n      guest_instance_id_(guest_instance_id),\n      element_instance_id_(element_instance_id),\n      is_full_page_plugin_(is_full_page_plugin),\n      filter_(filter),\n      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),\n      weak_factory_(this) {\n  DCHECK(GetGuestView());\n  NavigateToAboutBlank();\n  base::PostDelayedTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::\n                         CancelPendingTask,\n                     weak_factory_.GetWeakPtr()),\n      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24"}
{"idx": 8184, "func": "GfxResources::~GfxResources() {\n  if (fonts) {\n    delete fonts;\n  }\n  xObjDict.free();\n  colorSpaceDict.free();\n  patternDict.free();\n  shadingDict.free();\n  gStateDict.free();\n  propertiesDict.free();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186469, "func": "static PassRefPtr<StaticBitmapImage> cropImage(\n    Image* image,\n    const ParsedOptions& parsedOptions,\n    AlphaDisposition imageFormat = PremultiplyAlpha,\n    ImageDecoder::ColorSpaceOption colorSpaceOp =\n        ImageDecoder::ColorSpaceApplied) {\n  ASSERT(image);\n  IntRect imgRect(IntPoint(), IntSize(image->width(), image->height()));\n  const IntRect srcRect = intersection(imgRect, parsedOptions.cropRect);\n\n  if (srcRect.isEmpty() && !parsedOptions.premultiplyAlpha) {\n    SkImageInfo info =\n         SkImageInfo::Make(parsedOptions.resizeWidth, parsedOptions.resizeHeight,\n                           kN32_SkColorType, kUnpremul_SkAlphaType);\n     RefPtr<ArrayBuffer> dstBuffer = ArrayBuffer::createOrNull(\n        static_cast<size_t>(info.width()) * info.height(),\n         info.bytesPerPixel());\n     if (!dstBuffer)\n       return nullptr;\n     RefPtr<Uint8Array> dstPixels =\n         Uint8Array::create(dstBuffer, 0, dstBuffer->byteLength());\n     return StaticBitmapImage::create(newSkImageFromRaster(\n         info, std::move(dstPixels),\n        static_cast<size_t>(info.width()) * info.bytesPerPixel()));\n   }\n \n   sk_sp<SkImage> skiaImage = image->imageForCurrentFrame();\n  if ((((!parsedOptions.premultiplyAlpha && !skiaImage->isOpaque()) ||\n        !skiaImage) &&\n       image->data() && imageFormat == PremultiplyAlpha) ||\n      colorSpaceOp == ImageDecoder::ColorSpaceIgnored) {\n    std::unique_ptr<ImageDecoder> decoder(ImageDecoder::create(\n        image->data(), true,\n        parsedOptions.premultiplyAlpha ? ImageDecoder::AlphaPremultiplied\n                                       : ImageDecoder::AlphaNotPremultiplied,\n        colorSpaceOp));\n    if (!decoder)\n      return nullptr;\n    skiaImage = ImageBitmap::getSkImageFromDecoder(std::move(decoder));\n    if (!skiaImage)\n      return nullptr;\n  }\n\n  if (parsedOptions.cropRect == srcRect && !parsedOptions.shouldScaleInput) {\n    sk_sp<SkImage> croppedSkImage = skiaImage->makeSubset(srcRect);\n    if (parsedOptions.flipY)\n      return StaticBitmapImage::create(flipSkImageVertically(\n          croppedSkImage.get(), parsedOptions.premultiplyAlpha\n                                    ? PremultiplyAlpha\n                                    : DontPremultiplyAlpha));\n    if (parsedOptions.premultiplyAlpha && imageFormat == DontPremultiplyAlpha)\n      return StaticBitmapImage::create(\n          unPremulSkImageToPremul(croppedSkImage.get()));\n    croppedSkImage->preroll();\n    return StaticBitmapImage::create(std::move(croppedSkImage));\n  }\n\n  sk_sp<SkSurface> surface = SkSurface::MakeRasterN32Premul(\n      parsedOptions.resizeWidth, parsedOptions.resizeHeight);\n  if (!surface)\n    return nullptr;\n  if (srcRect.isEmpty())\n    return StaticBitmapImage::create(surface->makeImageSnapshot());\n\n  SkScalar dstLeft = std::min(0, -parsedOptions.cropRect.x());\n  SkScalar dstTop = std::min(0, -parsedOptions.cropRect.y());\n  if (parsedOptions.cropRect.x() < 0)\n    dstLeft = -parsedOptions.cropRect.x();\n  if (parsedOptions.cropRect.y() < 0)\n    dstTop = -parsedOptions.cropRect.y();\n  if (parsedOptions.flipY) {\n    surface->getCanvas()->translate(0, surface->height());\n    surface->getCanvas()->scale(1, -1);\n  }\n  if (parsedOptions.shouldScaleInput) {\n    SkRect drawSrcRect = SkRect::MakeXYWH(\n        parsedOptions.cropRect.x(), parsedOptions.cropRect.y(),\n        parsedOptions.cropRect.width(), parsedOptions.cropRect.height());\n    SkRect drawDstRect = SkRect::MakeXYWH(0, 0, parsedOptions.resizeWidth,\n                                          parsedOptions.resizeHeight);\n    SkPaint paint;\n    paint.setFilterQuality(parsedOptions.resizeQuality);\n    surface->getCanvas()->drawImageRect(skiaImage, drawSrcRect, drawDstRect,\n                                        &paint);\n  } else {\n    surface->getCanvas()->drawImage(skiaImage, dstLeft, dstTop);\n  }\n  skiaImage = surface->makeImageSnapshot();\n\n  if (parsedOptions.premultiplyAlpha) {\n    if (imageFormat == DontPremultiplyAlpha)\n      return StaticBitmapImage::create(\n          unPremulSkImageToPremul(skiaImage.get()));\n    return StaticBitmapImage::create(std::move(skiaImage));\n  }\n  return StaticBitmapImage::create(premulSkImageToUnPremul(skiaImage.get()));\n}\n", "target": 1, "flaw_line_index": "19,27"}
{"idx": 7974, "func": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        if (len == 8) {\n            uint32_t dlen = read_u32(data, 4);\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n                return 8 + dlen;\n            }\n        }\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n                default:\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    printf(\"Invalid audio channel coount %d\\n\",\n                           read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = read_u32(data, 6);\n                break;\n            default:\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    default:\n        printf(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187160, "func": "void HTMLStyleElement::DidNotifySubtreeInsertionsToDocument() {\n  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\n      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 186487, "func": " void TabGroupHeader::OnPaint(gfx::Canvas* canvas) {\n  constexpr SkColor kPlaceholderColor = SkColorSetRGB(0xAA, 0xBB, 0xCC);\n   gfx::Rect fill_bounds(GetLocalBounds());\n   fill_bounds.Inset(TabStyle::GetTabOverlap(), 0);\n  canvas->FillRect(fill_bounds, kPlaceholderColor);\n }\n", "target": 1, "flaw_line_index": "3,6"}
{"idx": 186594, "func": "void DocumentLoader::DidInstallNewDocument(Document* document) {\n   document->SetReadyState(Document::kLoading);\n   if (content_security_policy_) {\n    document->InitContentSecurityPolicy(content_security_policy_.Release());\n   }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n    document->SetStateForNewFormElements(history_item_->GetDocumentState());\n\n  DCHECK(document->GetFrame());\n  document->GetFrame()->GetClientHintsPreferences().UpdateFrom(\n      client_hints_preferences_);\n\n  Settings* settings = document->GetSettings();\n  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());\n  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());\n\n  const AtomicString& dns_prefetch_control =\n      response_.HttpHeaderField(HTTPNames::X_DNS_Prefetch_Control);\n  if (!dns_prefetch_control.IsEmpty())\n    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);\n\n  String header_content_language =\n      response_.HttpHeaderField(HTTPNames::Content_Language);\n  if (!header_content_language.IsEmpty()) {\n    size_t comma_index = header_content_language.find(',');\n    header_content_language.Truncate(comma_index);\n    header_content_language =\n        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);\n    if (!header_content_language.IsEmpty())\n      document->SetContentLanguage(AtomicString(header_content_language));\n  }\n\n  String referrer_policy_header =\n      response_.HttpHeaderField(HTTPNames::Referrer_Policy);\n  if (!referrer_policy_header.IsNull()) {\n    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);\n    document->ParseAndSetReferrerPolicy(referrer_policy_header);\n  }\n\n  if (response_.IsSignedExchangeInnerResponse())\n    UseCounter::Count(*document, WebFeature::kSignedExchangeInnerResponse);\n\n  GetLocalFrameClient().DidCreateNewDocument();\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 7570, "func": "static void cirrus_bitblt_start(CirrusVGAState * s)\n{\n    uint8_t blt_rop;\n\n    s->vga.gr[0x31] |= CIRRUS_BLT_BUSY;\n\n    s->cirrus_blt_width = (s->vga.gr[0x20] | (s->vga.gr[0x21] << 8)) + 1;\n    s->cirrus_blt_height = (s->vga.gr[0x22] | (s->vga.gr[0x23] << 8)) + 1;\n    s->cirrus_blt_dstpitch = (s->vga.gr[0x24] | (s->vga.gr[0x25] << 8));\n    s->cirrus_blt_srcpitch = (s->vga.gr[0x26] | (s->vga.gr[0x27] << 8));\n    s->cirrus_blt_dstaddr =\n\t(s->vga.gr[0x28] | (s->vga.gr[0x29] << 8) | (s->vga.gr[0x2a] << 16));\n    s->cirrus_blt_srcaddr =\n\t(s->vga.gr[0x2c] | (s->vga.gr[0x2d] << 8) | (s->vga.gr[0x2e] << 16));\n    s->cirrus_blt_mode = s->vga.gr[0x30];\n    s->cirrus_blt_modeext = s->vga.gr[0x33];\n    blt_rop = s->vga.gr[0x32];\n\n#ifdef DEBUG_BITBLT\n    printf(\"rop=0x%02x mode=0x%02x modeext=0x%02x w=%d h=%d dpitch=%d spitch=%d daddr=0x%08x saddr=0x%08x writemask=0x%02x\\n\",\n           blt_rop,\n           s->cirrus_blt_mode,\n           s->cirrus_blt_modeext,\n           s->cirrus_blt_width,\n           s->cirrus_blt_height,\n           s->cirrus_blt_dstpitch,\n           s->cirrus_blt_srcpitch,\n           s->cirrus_blt_dstaddr,\n           s->cirrus_blt_srcaddr,\n           s->vga.gr[0x2f]);\n#endif\n\n    switch (s->cirrus_blt_mode & CIRRUS_BLTMODE_PIXELWIDTHMASK) {\n    case CIRRUS_BLTMODE_PIXELWIDTH8:\n\ts->cirrus_blt_pixelwidth = 1;\n\tbreak;\n    case CIRRUS_BLTMODE_PIXELWIDTH16:\n\ts->cirrus_blt_pixelwidth = 2;\n\tbreak;\n    case CIRRUS_BLTMODE_PIXELWIDTH24:\n\ts->cirrus_blt_pixelwidth = 3;\n\tbreak;\n    case CIRRUS_BLTMODE_PIXELWIDTH32:\n\ts->cirrus_blt_pixelwidth = 4;\n\tbreak;\n    default:\n#ifdef DEBUG_BITBLT\n\tprintf(\"cirrus: bitblt - pixel width is unknown\\n\");\n#endif\n\tgoto bitblt_ignore;\n    }\n    s->cirrus_blt_mode &= ~CIRRUS_BLTMODE_PIXELWIDTHMASK;\n\n    if ((s->\n\t cirrus_blt_mode & (CIRRUS_BLTMODE_MEMSYSSRC |\n\t\t\t    CIRRUS_BLTMODE_MEMSYSDEST))\n\t== (CIRRUS_BLTMODE_MEMSYSSRC | CIRRUS_BLTMODE_MEMSYSDEST)) {\n#ifdef DEBUG_BITBLT\n\tprintf(\"cirrus: bitblt - memory-to-memory copy is requested\\n\");\n#endif\n\tgoto bitblt_ignore;\n    }\n\n    if ((s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_SOLIDFILL) &&\n        (s->cirrus_blt_mode & (CIRRUS_BLTMODE_MEMSYSDEST |\n                               CIRRUS_BLTMODE_TRANSPARENTCOMP |\n                               CIRRUS_BLTMODE_PATTERNCOPY |\n                               CIRRUS_BLTMODE_COLOREXPAND)) ==\n         (CIRRUS_BLTMODE_PATTERNCOPY | CIRRUS_BLTMODE_COLOREXPAND)) {\n        cirrus_bitblt_fgcol(s);\n        cirrus_bitblt_solidfill(s, blt_rop);\n    } else {\n        if ((s->cirrus_blt_mode & (CIRRUS_BLTMODE_COLOREXPAND |\n                                   CIRRUS_BLTMODE_PATTERNCOPY)) ==\n            CIRRUS_BLTMODE_COLOREXPAND) {\n\n            if (s->cirrus_blt_mode & CIRRUS_BLTMODE_TRANSPARENTCOMP) {\n                if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_COLOREXPINV)\n                    cirrus_bitblt_bgcol(s);\n                else\n                    cirrus_bitblt_fgcol(s);\n                s->cirrus_rop = cirrus_colorexpand_transp[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n            } else {\n                cirrus_bitblt_fgcol(s);\n                cirrus_bitblt_bgcol(s);\n                s->cirrus_rop = cirrus_colorexpand[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n            }\n        } else if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n            if (s->cirrus_blt_mode & CIRRUS_BLTMODE_COLOREXPAND) {\n                if (s->cirrus_blt_mode & CIRRUS_BLTMODE_TRANSPARENTCOMP) {\n                    if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_COLOREXPINV)\n                        cirrus_bitblt_bgcol(s);\n                    else\n                        cirrus_bitblt_fgcol(s);\n                    s->cirrus_rop = cirrus_colorexpand_pattern_transp[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n                } else {\n                    cirrus_bitblt_fgcol(s);\n                    cirrus_bitblt_bgcol(s);\n                    s->cirrus_rop = cirrus_colorexpand_pattern[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n                }\n            } else {\n                s->cirrus_rop = cirrus_patternfill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n            }\n        } else {\n\t    if (s->cirrus_blt_mode & CIRRUS_BLTMODE_TRANSPARENTCOMP) {\n\t\tif (s->cirrus_blt_pixelwidth > 2) {\n\t\t    printf(\"src transparent without colorexpand must be 8bpp or 16bpp\\n\");\n\t\t    goto bitblt_ignore;\n\t\t}\n\t\tif (s->cirrus_blt_mode & CIRRUS_BLTMODE_BACKWARDS) {\n\t\t    s->cirrus_blt_dstpitch = -s->cirrus_blt_dstpitch;\n\t\t    s->cirrus_blt_srcpitch = -s->cirrus_blt_srcpitch;\n\t\t    s->cirrus_rop = cirrus_bkwd_transp_rop[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\t\t} else {\n\t\t    s->cirrus_rop = cirrus_fwd_transp_rop[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\t\t}\n\t    } else {\n\t\tif (s->cirrus_blt_mode & CIRRUS_BLTMODE_BACKWARDS) {\n\t\t    s->cirrus_blt_dstpitch = -s->cirrus_blt_dstpitch;\n\t\t    s->cirrus_blt_srcpitch = -s->cirrus_blt_srcpitch;\n\t\t    s->cirrus_rop = cirrus_bkwd_rop[rop_to_index[blt_rop]];\n\t\t} else {\n\t\t    s->cirrus_rop = cirrus_fwd_rop[rop_to_index[blt_rop]];\n\t\t}\n\t    }\n\t}\n        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_MEMSYSSRC) {\n            if (!cirrus_bitblt_cputovideo(s))\n                goto bitblt_ignore;\n        } else if (s->cirrus_blt_mode & CIRRUS_BLTMODE_MEMSYSDEST) {\n            if (!cirrus_bitblt_videotocpu(s))\n                goto bitblt_ignore;\n        } else {\n            if (!cirrus_bitblt_videotovideo(s))\n                goto bitblt_ignore;\n        }\n    }\n    return;\n  bitblt_ignore:;\n    cirrus_bitblt_reset(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187222, "func": "static int composite_open(int sub_api, struct libusb_device_handle *dev_handle)\n{\n \tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n \tint r = LIBUSB_ERROR_NOT_FOUND;\n \tuint8_t i;\n\tbool available[SUB_API_MAX+1] = {0};\n \n \tfor (i=0; i<USB_MAXINTERFACES; i++) {\n \t\tswitch (priv->usb_interface[i].apib->id) {\n \t\tcase USB_API_WINUSBX:\n \t\t\tif (priv->usb_interface[i].sub_api != SUB_API_NOTSET)\n \t\t\t\tavailable[priv->usb_interface[i].sub_api] = true;\n \t\t\tbreak;\n\t\tcase USB_API_HID:\n\t\t\tavailable[SUB_API_MAX] = true;\n\t\t\tbreak;\n \t\tdefault:\n \t\t\tbreak;\n \t\t}\n\t}\n\n\tfor (i=0; i<SUB_API_MAX; i++) {\t\n\t\tif (available[i]) {\n\t\t\tr = usb_api_backend[USB_API_WINUSBX].open(i, dev_handle);\n\t\t\tif (r != LIBUSB_SUCCESS) {\n\t\t\t\treturn r;\n \t\t\t}\n \t\t}\n \t}\n\tif (available[SUB_API_MAX]) {\t\n\t\tr = hid_open(SUB_API_NOTSET, dev_handle);\n\t}\n \treturn r;\n }\n", "target": 1, "flaw_line_index": "6,7,15,16,17,31,32,33"}
{"idx": 186328, "func": "void AwFeatureListCreator::SetUpFieldTrials() {\n  auto* metrics_client = AwMetricsServiceClient::GetInstance();\n\n  DCHECK(!field_trial_list_);\n  field_trial_list_ = std::make_unique<base::FieldTrialList>(\n      metrics_client->CreateLowEntropyProvider());\n\n  std::unique_ptr<variations::SeedResponse> seed = GetAndClearJavaSeed();\n  base::Time null_time;\n  base::Time seed_date =\n      seed ? base::Time::FromJavaTime(seed->date) : null_time;\n  variations::UIStringOverrider ui_string_overrider;\n  client_ = std::make_unique<AwVariationsServiceClient>();\n  auto seed_store = std::make_unique<variations::VariationsSeedStore>(\n      local_state_.get(), \nstd::move(seed),\nbase::DoNothing());\n\n  if (!seed_date.is_null())\n    seed_store->RecordLastFetchTime(seed_date);\n\n  variations_field_trial_creator_ =\n      std::make_unique<variations::VariationsFieldTrialCreator>(\n          local_state_.get(), client_.get(), std::move(seed_store),\n          ui_string_overrider);\n  variations_field_trial_creator_->OverrideVariationsPlatform(\n      variations::Study::PLATFORM_ANDROID_WEBVIEW);\n\n  std::set<std::string> unforceable_field_trials;\n  variations::SafeSeedManager ignored_safe_seed_manager(true,\n                                                        local_state_.get());\n\n  variations_field_trial_creator_->SetupFieldTrials(\n      cc::switches::kEnableGpuBenchmarking, switches::kEnableFeatures,\n      switches::kDisableFeatures, unforceable_field_trials,\n      std::vector<std::string>(),\n      content::GetSwitchDependentFeatureOverrides(\n           *base::CommandLine::ForCurrentProcess()),\nnullptr, std::make_unique<base::FeatureList>(),\n       aw_field_trials_.get(), &ignored_safe_seed_manager);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7467, "func": "  t1_decoder_init( T1_Decoder           decoder,\n                   FT_Face              face,\n                   FT_Size              size,\n                   FT_GlyphSlot         slot,\n                   FT_Byte**            glyph_names,\n                   PS_Blend             blend,\n                   FT_Bool              hinting,\n                   FT_Render_Mode       hint_mode,\n                   T1_Decoder_Callback  parse_callback )\n  {\n    FT_ZERO( decoder );\n\n    {\n      FT_Service_PsCMaps  psnames;\n\n\n      FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );\n      if ( !psnames )\n      {\n        FT_ERROR(( \"t1_decoder_init:\"\n                   \" the `psnames' module is not available\\n\" ));\n        return FT_THROW( Unimplemented_Feature );\n      }\n\n      decoder->psnames = psnames;\n    }\n\n    t1_builder_init( &decoder->builder, face, size, slot, hinting );\n\n\n    decoder->num_glyphs     = (FT_UInt)face->num_glyphs;\n    decoder->glyph_names    = glyph_names;\n    decoder->hint_mode      = hint_mode;\n    decoder->blend          = blend;\n    decoder->parse_callback = parse_callback;\n\n    decoder->funcs          = t1_decoder_funcs;\n\n    return FT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7529, "func": "  tt_name_ascii_from_utf16( TT_Name    entry,\n                            FT_Memory  memory )\n  {\n    FT_String*  string = NULL;\n    FT_UInt     len, code, n;\n    FT_Byte*    read   = (FT_Byte*)entry->string;\n    FT_Error    error;\n\n\n    len = (FT_UInt)entry->stringLength / 2;\n\n    if ( FT_NEW_ARRAY( string, len + 1 ) )\n      return NULL;\n\n    for ( n = 0; n < len; n++ )\n    {\n      code = FT_NEXT_USHORT( read );\n\n      if ( code == 0 )\n        break;\n\n      if ( code < 32 || code > 127 )\n        code = '?';\n\n      string[n] = (char)code;\n    }\n\n    string[n] = 0;\n\n    return string;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 187232, "func": "static int hid_release_interface(int sub_api, struct libusb_device_handle *dev_handle, int iface)\n{\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n\tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n\tCHECK_HID_AVAILABLE;\n\tif (priv->usb_interface[iface].path == NULL) {\n\t\treturn LIBUSB_ERROR_NOT_FOUND;\t\n\t}\n\tif (handle_priv->interface_handle[iface].dev_handle != INTERFACE_CLAIMED) {\n\t\treturn LIBUSB_ERROR_NOT_FOUND;\t\n\t}\n\thandle_priv->interface_handle[iface].dev_handle = INVALID_HANDLE_VALUE;\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14"}
{"idx": 187048, "func": "void ConfigureQuicParams(base::StringPiece quic_trial_group,\n                         const VariationParameters& quic_trial_params,\n                         bool is_quic_force_disabled,\n                         bool is_quic_force_enabled,\n                         const std::string& quic_user_agent_id,\n                         net::HttpNetworkSession::Params* params) {\n  params->enable_quic =\n      ShouldEnableQuic(quic_trial_group, quic_trial_params,\n                       is_quic_force_disabled, is_quic_force_enabled);\n  params->mark_quic_broken_when_network_blackholes =\n      ShouldMarkQuicBrokenWhenNetworkBlackholes(quic_trial_params);\n\n  params->enable_server_push_cancellation =\n      ShouldEnableServerPushCancelation(quic_trial_params);\n\n  params->retry_without_alt_svc_on_quic_errors =\n      ShouldRetryWithoutAltSvcOnQuicErrors(quic_trial_params);\n\n  params->support_ietf_format_quic_altsvc =\n      ShouldSupportIetfFormatQuicAltSvc(quic_trial_params);\n\n   if (params->enable_quic) {\n     params->enable_quic_proxies_for_https_urls =\n         ShouldEnableQuicProxiesForHttpsUrls(quic_trial_params);\n    params->enable_quic_proxies_for_https_urls = false;\n     params->quic_connection_options =\n         GetQuicConnectionOptions(quic_trial_params);\n     params->quic_client_connection_options =\n        GetQuicClientConnectionOptions(quic_trial_params);\n    params->quic_close_sessions_on_ip_change =\n        ShouldQuicCloseSessionsOnIpChange(quic_trial_params);\n    params->quic_goaway_sessions_on_ip_change =\n        ShouldQuicGoAwaySessionsOnIpChange(quic_trial_params);\n    int idle_connection_timeout_seconds =\n        GetQuicIdleConnectionTimeoutSeconds(quic_trial_params);\n    if (idle_connection_timeout_seconds != 0) {\n      params->quic_idle_connection_timeout_seconds =\n          idle_connection_timeout_seconds;\n    }\n    int reduced_ping_timeout_seconds =\n        GetQuicReducedPingTimeoutSeconds(quic_trial_params);\n    if (reduced_ping_timeout_seconds > 0 &&\n        reduced_ping_timeout_seconds < quic::kPingTimeoutSecs) {\n      params->quic_reduced_ping_timeout_seconds = reduced_ping_timeout_seconds;\n    }\n    int max_time_before_crypto_handshake_seconds =\n        GetQuicMaxTimeBeforeCryptoHandshakeSeconds(quic_trial_params);\n    if (max_time_before_crypto_handshake_seconds > 0) {\n      params->quic_max_time_before_crypto_handshake_seconds =\n          max_time_before_crypto_handshake_seconds;\n    }\n    int max_idle_time_before_crypto_handshake_seconds =\n        GetQuicMaxIdleTimeBeforeCryptoHandshakeSeconds(quic_trial_params);\n    if (max_idle_time_before_crypto_handshake_seconds > 0) {\n      params->quic_max_idle_time_before_crypto_handshake_seconds =\n          max_idle_time_before_crypto_handshake_seconds;\n    }\n    params->quic_race_cert_verification =\n        ShouldQuicRaceCertVerification(quic_trial_params);\n    params->quic_estimate_initial_rtt =\n        ShouldQuicEstimateInitialRtt(quic_trial_params);\n    params->quic_headers_include_h2_stream_dependency =\n        ShouldQuicHeadersIncludeH2StreamDependencies(quic_trial_params);\n    params->quic_migrate_sessions_on_network_change_v2 =\n        ShouldQuicMigrateSessionsOnNetworkChangeV2(quic_trial_params);\n    params->quic_migrate_sessions_early_v2 =\n        ShouldQuicMigrateSessionsEarlyV2(quic_trial_params);\n    params->quic_retry_on_alternate_network_before_handshake =\n        ShouldQuicRetryOnAlternateNetworkBeforeHandshake(quic_trial_params);\n    params->quic_go_away_on_path_degrading =\n        ShouldQuicGoawayOnPathDegrading(quic_trial_params);\n    params->quic_race_stale_dns_on_connection =\n        ShouldQuicRaceStaleDNSOnConnection(quic_trial_params);\n    int max_time_on_non_default_network_seconds =\n        GetQuicMaxTimeOnNonDefaultNetworkSeconds(quic_trial_params);\n    if (max_time_on_non_default_network_seconds > 0) {\n      params->quic_max_time_on_non_default_network =\n          base::TimeDelta::FromSeconds(max_time_on_non_default_network_seconds);\n    }\n    int max_migrations_to_non_default_network_on_write_error =\n        GetQuicMaxNumMigrationsToNonDefaultNetworkOnWriteError(\n            quic_trial_params);\n    if (max_migrations_to_non_default_network_on_write_error > 0) {\n      params->quic_max_migrations_to_non_default_network_on_write_error =\n          max_migrations_to_non_default_network_on_write_error;\n    }\n    int max_migrations_to_non_default_network_on_path_degrading =\n        GetQuicMaxNumMigrationsToNonDefaultNetworkOnPathDegrading(\n            quic_trial_params);\n    if (max_migrations_to_non_default_network_on_path_degrading > 0) {\n      params->quic_max_migrations_to_non_default_network_on_path_degrading =\n          max_migrations_to_non_default_network_on_path_degrading;\n    }\n    params->quic_allow_server_migration =\n        ShouldQuicAllowServerMigration(quic_trial_params);\n    params->quic_host_whitelist = GetQuicHostWhitelist(quic_trial_params);\n  }\n\n  size_t max_packet_length = GetQuicMaxPacketLength(quic_trial_params);\n  if (max_packet_length != 0) {\n    params->quic_max_packet_length = max_packet_length;\n  }\n\n  params->quic_user_agent_id = quic_user_agent_id;\n\n  quic::QuicTransportVersionVector supported_versions =\n      GetQuicVersions(quic_trial_params);\n  if (!supported_versions.empty())\n    params->quic_supported_versions = supported_versions;\n}\n", "target": 1, "flaw_line_index": "25"}
{"idx": 187005, "func": "void DownloadResourceHandler::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    network::ResourceResponse* response,\n    std::unique_ptr<ResourceController> controller) {\n  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));\n  if (!follow_cross_origin_redirects_ &&\n      !first_origin_.IsSameOriginWith(new_origin)) {\n    base::PostTaskWithTraits(\n        FROM_HERE, {BrowserThread::UI},\n        base::BindOnce(\n            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),\n            Referrer(GURL(redirect_info.new_referrer),\n                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                          redirect_info.new_referrer_policy)),\n             GetRequestInfo()->HasUserGesture(),\n            GetRequestInfo()->GetWebContentsGetterForRequest()));\n     controller->Cancel();\n     return;\n   }\n  if (core_.OnRequestRedirected()) {\n    controller->Resume();\n  } else {\n    controller->Cancel();\n  }\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 186910, "func": "int BrowserMainLoop::PreCreateThreads() {\n\n  if (parts_) {\n    TRACE_EVENT0(\"startup\",\n        \"BrowserMainLoop::CreateThreads:PreCreateThreads\");\n\n    result_code_ = parts_->PreCreateThreads();\n  }\n\n  if (!base::SequencedWorkerPool::IsEnabled())\n    base::SequencedWorkerPool::EnableForProcess();\n\n  const base::CommandLine* command_line =\n      base::CommandLine::ForCurrentProcess();\n  base::FeatureList::InitializeInstance(\n      command_line->GetSwitchValueASCII(switches::kEnableFeatures),\n      command_line->GetSwitchValueASCII(switches::kDisableFeatures));\n\n  InitializeMemoryManagementComponent();\n\n#if defined(OS_MACOSX)\n  if (base::CommandLine::InitializedForCurrentProcess() &&\n      base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableHeapProfiling)) {\n    base::allocator::PeriodicallyShimNewMallocZones();\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  {\n    TRACE_EVENT0(\"startup\", \"BrowserMainLoop::CreateThreads:PluginService\");\n    PluginService::GetInstance()->Init();\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_LIBRARY_CDMS)\n  CdmRegistry::GetInstance()->Init();\n#endif\n\n#if defined(OS_MACOSX)\n  ui::WindowResizeHelperMac::Get()->Init(base::ThreadTaskRunnerHandle::Get());\n#endif\n\n  GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();\n\n#if defined(USE_X11)\n  gpu_data_manager_visual_proxy_.reset(\n      new internal::GpuDataManagerVisualProxy(gpu_data_manager));\n#endif\n\n  gpu_data_manager->Initialize();\n\n#if !defined(GOOGLE_CHROME_BUILD) || defined(OS_ANDROID)\n  if (parsed_command_line_.HasSwitch(switches::kSingleProcess))\n    RenderProcessHost::SetRunRendererInProcess(true);\n#endif\n\n  std::vector<url::Origin> origins =\n      GetContentClient()->browser()->GetOriginsRequiringDedicatedProcess();\n  ChildProcessSecurityPolicyImpl* policy =\n      ChildProcessSecurityPolicyImpl::GetInstance();\n   for (auto origin : origins)\n     policy->AddIsolatedOrigin(origin);\n \n  EVP_set_buggy_rsa_parser(\n      base::FeatureList::IsEnabled(features::kBuggyRSAParser));\n   return result_code_;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7540, "func": "getenv_TZ (void)\n{\n  return getenv (\"TZ\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187267, "func": "void DevToolsAgentHostImpl::ForceDetachAllClients() {\n   scoped_refptr<DevToolsAgentHostImpl> protect(this);\n  while (!session_by_client_.empty()) {\n    DevToolsAgentHostClient* client = session_by_client_.begin()->first;\n    InnerDetachClient(client);\n     client->AgentHostClosed(this);\n   }\n }\n", "target": 1, "flaw_line_index": "3,4,5"}
{"idx": 7803, "func": "static int h2c_send_conn_wu(struct h2c *h2c)\n{\n\tint ret = 1;\n\n\tif (h2c->rcvd_c <= 0)\n\t\treturn 1;\n\n\tret = h2c_send_window_update(h2c, 0, h2c->rcvd_c);\n\tif (ret > 0)\n\t\th2c->rcvd_c = 0;\n\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7852, "func": "static void migration_bitmap_sync(void)\n{\n    RAMBlock *block;\n    uint64_t num_dirty_pages_init = migration_dirty_pages;\n    MigrationState *s = migrate_get_current();\n    static int64_t start_time;\n    static int64_t bytes_xfer_prev;\n    static int64_t num_dirty_pages_period;\n    int64_t end_time;\n    int64_t bytes_xfer_now;\n    static uint64_t xbzrle_cache_miss_prev;\n    static uint64_t iterations_prev;\n\n    bitmap_sync_count++;\n\n    if (!bytes_xfer_prev) {\n        bytes_xfer_prev = ram_bytes_transferred();\n    }\n\n    if (!start_time) {\n        start_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n    }\n\n    trace_migration_bitmap_sync_start();\n    address_space_sync_dirty_bitmap(&address_space_memory);\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        migration_bitmap_sync_range(block->mr->ram_addr, block->length);\n    }\n    trace_migration_bitmap_sync_end(migration_dirty_pages\n                                    - num_dirty_pages_init);\n    num_dirty_pages_period += migration_dirty_pages - num_dirty_pages_init;\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    if (end_time > start_time + 1000) {\n        if (migrate_auto_converge()) {\n            bytes_xfer_now = ram_bytes_transferred();\n            if (s->dirty_pages_rate &&\n               (num_dirty_pages_period * TARGET_PAGE_SIZE >\n                   (bytes_xfer_now - bytes_xfer_prev)/2) &&\n               (dirty_rate_high_cnt++ > 4)) {\n                    trace_migration_throttle();\n                    mig_throttle_on = true;\n                    dirty_rate_high_cnt = 0;\n             }\n             bytes_xfer_prev = bytes_xfer_now;\n        } else {\n             mig_throttle_on = false;\n        }\n        if (migrate_use_xbzrle()) {\n            if (iterations_prev != 0) {\n                acct_info.xbzrle_cache_miss_rate =\n                   (double)(acct_info.xbzrle_cache_miss -\n                            xbzrle_cache_miss_prev) /\n                   (acct_info.iterations - iterations_prev);\n            }\n            iterations_prev = acct_info.iterations;\n            xbzrle_cache_miss_prev = acct_info.xbzrle_cache_miss;\n        }\n        s->dirty_pages_rate = num_dirty_pages_period * 1000\n            / (end_time - start_time);\n        s->dirty_bytes_rate = s->dirty_pages_rate * TARGET_PAGE_SIZE;\n        start_time = end_time;\n        num_dirty_pages_period = 0;\n        s->dirty_sync_count = bitmap_sync_count;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7880, "func": "uint64_t skipped_mig_pages_transferred(void)\n{\n    return acct_info.skipped_pages;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7868, "func": "static void ram_migration_cancel(void *opaque)\n{\n    migration_end();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8136, "func": "void Gfx::opSave(Object args[], int numArgs) {\n  saveState();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8055, "func": "void vnc_write_s32(VncState *vs, int32_t value)\n{\n    vnc_write_u32(vs, *(uint32_t *)&value);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8153, "func": "void Gfx::opSetLineWidth(Object args[], int numArgs) {\n  state->setLineWidth(args[0].getNum());\n  out->updateLineWidth(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7644, "func": "static ssize_t proxy_pwritev(FsContext *ctx, V9fsFidOpenState *fs,\n                             const struct iovec *iov,\n                             int iovcnt, off_t offset)\n{\n    ssize_t ret;\n\n#ifdef CONFIG_PREADV\n    ret = pwritev(fs->fd, iov, iovcnt, offset);\n#else\n    ret = lseek(fs->fd, offset, SEEK_SET);\n    if (ret >= 0) {\n        ret = writev(fs->fd, iov, iovcnt);\n    }\n#endif\n#ifdef CONFIG_SYNC_FILE_RANGE\n    if (ret > 0 && ctx->export_flags & V9FS_IMMEDIATE_WRITEOUT) {\n        sync_file_range(fs->fd, offset, ret,\n                        SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE);\n    }\n#endif\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7695, "func": "static int handle_symlink(FsContext *fs_ctx, const char *oldpath,\n                          V9fsPath *dir_path, const char *name, FsCred *credp)\n{\n    int fd, dirfd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    ret = symlinkat(oldpath, dirfd, name);\n    if (!ret) {\n        fd = openat(dirfd, name, O_PATH | O_NOFOLLOW);\n        if (fd < 0) {\n            ret = fd;\n            goto err_out;\n        }\n        ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n        close(fd);\n    }\nerr_out:\n    close(dirfd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187056, "func": "void RenderFrameImpl::OnSelectPopupMenuItem(int selected_index) {\n  if (external_popup_menu_ == NULL)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n  external_popup_menu_->DidSelectItem(selected_index);\n  external_popup_menu_.reset();\n }\n", "target": 1, "flaw_line_index": "6,7"}
{"idx": 7966, "func": "static void key_event(VncState *vs, int down, uint32_t sym)\n{\n    int keycode;\n    int lsym = sym;\n\n    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(NULL)) {\n        lsym = lsym - 'A' + 'a';\n    }\n\n    keycode = keysym2scancode(vs->vd->kbd_layout, lsym & 0xFFFF) & SCANCODE_KEYMASK;\n    trace_vnc_key_event_map(down, sym, keycode, code2name(keycode));\n    do_key_event(vs, down, keycode, sym);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186810, "func": " PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n    : PlatformSensor(type, std::move(mapping), provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),\n      polling_thread_task_runner_(std::move(polling_thread_task_runner)),\n      weak_factory_(this) {\n  sensor_reader_ = SensorReader::Create(\n      sensor_device, weak_factory_.GetWeakPtr(), task_runner_);\n}\n", "target": 1, "flaw_line_index": "3,7"}
{"idx": 187122, "func": "void ThreadHeap::WriteBarrier(void* value) {\n  DCHECK(thread_state_->IsIncrementalMarking());\n  DCHECK(value);\n  DCHECK_NE(value, reinterpret_cast<void*>(-1));\n\n  BasePage* const page = PageFromObject(value);\n  HeapObjectHeader* const header =\n      page->IsLargeObjectPage()\n          ? static_cast<LargeObjectPage*>(page)->GetHeapObjectHeader()\n          : static_cast<NormalPage*>(page)->FindHeaderFromAddress(\n                reinterpret_cast<Address>(const_cast<void*>(value)));\n  if (header->IsMarked())\n    return;\n\n   header->Mark();\n   marking_worklist_->Push(\n       WorklistTaskId::MainThread,\n      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n }\n", "target": 1, "flaw_line_index": "20"}
{"idx": 186534, "func": "base::Optional<Gamepad> OpenVRGamepadHelper::GetXRGamepad(\n    vr::IVRSystem* vr_system,\n    uint32_t controller_id,\n    vr::VRControllerState_t controller_state,\n    device::mojom::XRHandedness handedness) {\n   OpenVRGamepadBuilder builder(vr_system, controller_id, controller_state,\n                                handedness);\n \n  if (!builder.TryAddAxesButton(vr::k_EButton_SteamVR_Trigger))\n     return base::nullopt;\n \n  if (!builder.TryAddNextUnusedAxesButton())\n     return base::nullopt;\n \n  if (!builder.TryAddButton(vr::k_EButton_Grip))\n     builder.AddPlaceholderButton();\n \n  if (!builder.TryAddNextUnusedAxesButton())\n     builder.AddPlaceholderButton();\n \n   for (const auto& button : kWebXRButtonOrder) {\n    builder.TryAddButton(button);\n   }\n \n  builder.AddRemainingAxes();\n \n   return builder.GetGamepad();\n }\n", "target": 1, "flaw_line_index": "9,12,15,21,28"}
{"idx": 186712, "func": "  MediaStreamManagerTest()\n      : thread_bundle_(content::TestBrowserThreadBundle::IO_MAINLOOP) {\n    audio_manager_ = std::make_unique<MockAudioManager>();\n    audio_system_ =\n        std::make_unique<media::AudioSystemImpl>(audio_manager_.get());\n    auto video_capture_provider = std::make_unique<MockVideoCaptureProvider>();\n    video_capture_provider_ = video_capture_provider.get();\n     media_stream_manager_ = std::make_unique<MediaStreamManager>(\n         audio_system_.get(), audio_manager_->GetTaskRunner(),\n         std::move(video_capture_provider));\n     base::RunLoop().RunUntilIdle();\n \n     ON_CALL(*video_capture_provider_, DoGetDeviceInfosAsync(_))\n        .WillByDefault(Invoke(\n            [](VideoCaptureProvider::GetDeviceInfosCallback& result_callback) {\n              std::vector<media::VideoCaptureDeviceInfo> stub_results;\n              base::ResetAndReturn(&result_callback).Run(stub_results);\n            }));\n  }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186348, "func": " void ResourcePrefetchPredictor::LearnOrigins(\n     const std::string& host,\n     const GURL& main_frame_origin,\n    const std::map<GURL, OriginRequestSummary>& summaries) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n   if (host.size() > ResourcePrefetchPredictorTables::kMaxStringLength)\n     return;\n\n  OriginData data;\n  bool exists = origin_data_->TryGetData(host, &data);\n  if (!exists) {\n    data.set_host(host);\n    data.set_last_visit_time(base::Time::Now().ToInternalValue());\n    size_t origins_size = summaries.size();\n    auto ordered_origins =\n        std::vector<const OriginRequestSummary*>(origins_size);\n    for (const auto& kv : summaries) {\n      size_t index = kv.second.first_occurrence;\n      DCHECK_LT(index, origins_size);\n      ordered_origins[index] = &kv.second;\n    }\n\n    for (const OriginRequestSummary* summary : ordered_origins) {\n      auto* origin_to_add = data.add_origins();\n      InitializeOriginStatFromOriginRequestSummary(origin_to_add, *summary);\n    }\n   } else {\n     data.set_last_visit_time(base::Time::Now().ToInternalValue());\n \n    std::map<GURL, int> old_index;\n     int old_size = static_cast<int>(data.origins_size());\n     for (int i = 0; i < old_size; ++i) {\n       bool is_new =\n          old_index.insert({GURL(data.origins(i).origin()), i}).second;\n       DCHECK(is_new);\n     }\n \n     for (int i = 0; i < old_size; ++i) {\n       auto* old_origin = data.mutable_origins(i);\n      GURL origin(old_origin->origin());\n       auto it = summaries.find(origin);\n       if (it == summaries.end()) {\n        old_origin->set_number_of_misses(old_origin->number_of_misses() + 1);\n        old_origin->set_consecutive_misses(old_origin->consecutive_misses() +\n                                           1);\n      } else {\n        const auto& new_origin = it->second;\n        old_origin->set_always_access_network(new_origin.always_access_network);\n        old_origin->set_accessed_network(new_origin.accessed_network);\n\n        int position = new_origin.first_occurrence + 1;\n        int total =\n            old_origin->number_of_hits() + old_origin->number_of_misses();\n        old_origin->set_average_position(\n            ((old_origin->average_position() * total) + position) /\n            (total + 1));\n        old_origin->set_number_of_hits(old_origin->number_of_hits() + 1);\n        old_origin->set_consecutive_misses(0);\n      }\n    }\n\n    for (const auto& kv : summaries) {\n      if (old_index.find(kv.first) != old_index.end())\n        continue;\n\n      auto* origin_to_add = data.add_origins();\n      InitializeOriginStatFromOriginRequestSummary(origin_to_add, kv.second);\n    }\n  }\n\n  ResourcePrefetchPredictorTables::TrimOrigins(&data,\n                                               config_.max_consecutive_misses);\n  ResourcePrefetchPredictorTables::SortOrigins(&data, main_frame_origin.spec());\n  if (data.origins_size() > static_cast<int>(config_.max_origins_per_entry)) {\n    data.mutable_origins()->DeleteSubrange(\n        config_.max_origins_per_entry,\n        data.origins_size() - config_.max_origins_per_entry);\n  }\n\n  if (data.origins_size() == 0)\n    origin_data_->DeleteData({host});\n  else\n    origin_data_->UpdateData(host, data);\n}\n", "target": 1, "flaw_line_index": "4,30,34,41"}
{"idx": 8048, "func": "char *vnc_socket_local_addr(const char *format, int fd) {\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0)\n        return NULL;\n\n    return addr_to_string(format, &sa, salen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186352, "func": " void SaveCardBubbleControllerImpl::ReshowBubble() {\n   is_reshow_ = true;\n   AutofillMetrics::LogSaveCardPromptMetric(\n       AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,\n      is_reshow_,\n      pref_service_->GetInteger(\n          prefs::kAutofillAcceptSaveCreditCardPromptState));\n\n  ShowBubble();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7483, "func": "ssize_t pt_listxattr(FsContext *ctx, const char *path,\n                     char *name, void *value, size_t size)\n{\n    int name_size = strlen(name) + 1;\n    if (!value) {\n        return name_size;\n    }\n\n    if (size < name_size) {\n        errno = ERANGE;\n        return -1;\n    }\n\n    memcpy(value, name, name_size);\n    return name_size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7879, "func": "uint64_t skipped_mig_bytes_transferred(void)\n{\n    return acct_info.skipped_pages * TARGET_PAGE_SIZE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187316, "func": "exsltFuncRegisterImportFunc (exsltFuncFunctionData *data,\n\t\t\t     exsltFuncImportRegData *ch,\n\t\t\t     const xmlChar *URI, const xmlChar *name,\n\t\t\t     ATTRIBUTE_UNUSED const xmlChar *ignored) {\n    exsltFuncFunctionData *func=NULL;\n\n    if ((data == NULL) || (ch == NULL) || (URI == NULL) || (name == NULL))\n            return;\n\n    if (ch->ctxt == NULL || ch->hash == NULL)\n\treturn;\n\n     func = (exsltFuncFunctionData*)xmlHashLookup2(ch->hash, URI, name);\n     if (func == NULL) {\t\t\n \tfunc = exsltFuncNewFunctionData();\n \tmemcpy(func, data, sizeof(exsltFuncFunctionData));\n \tif (xmlHashAddEntry2(ch->hash, URI, name, func) < 0) {\n \t    xsltGenericError(xsltGenericErrorContext,\n\t\t    \"Failed to register function {%s}%s\\n\",\n\t\t    URI, name);\n\t} else {\t\t\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t            \"exsltFuncRegisterImportFunc: register {%s}%s\\n\",\n\t\t    URI, name);\n\t    xsltRegisterExtFunction(ch->ctxt, name, URI,\n\t\t    exsltFuncFunctionFunction);\n\t}\n    }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8058, "func": "void vnc_write_u8(VncState *vs, uint8_t value)\n{\n    vnc_write(vs, (char *)&value, 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186842, "func": "void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,\n                                       mojo::ScopedSharedBufferHandle handle) {\n  DVLOG(1) << __func__ << \" buffer_id: \" << buffer_id;\n  DCHECK(io_thread_checker_.CalledOnValidThread());\n  DCHECK(handle.is_valid());\n \n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n  bool read_only_flag = false;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n   DCHECK_EQ(MOJO_RESULT_OK, result);\n   DCHECK_GT(memory_size, 0u);\n \n   std::unique_ptr<base::SharedMemory> shm(\n       new base::SharedMemory(memory_handle, true \n));\n   if (!shm->Map(memory_size)) {\n    DLOG(ERROR) << \"OnBufferCreated: Map failed.\";\n    return;\n  }\n  const bool inserted =\n      client_buffers_\n          .insert(std::make_pair(buffer_id,\n                                 new ClientBuffer(std::move(shm), memory_size)))\n          .second;\n  DCHECK(inserted);\n}\n", "target": 1, "flaw_line_index": "9,12"}
{"idx": 186499, "func": "bool GLES2DecoderPassthroughImpl::IsEmulatedQueryTarget(GLenum target) const {\n  switch (target) {\n    case GL_COMMANDS_COMPLETED_CHROMIUM:\n    case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n    case GL_COMMANDS_ISSUED_CHROMIUM:\n     case GL_LATENCY_QUERY_CHROMIUM:\n     case GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM:\n     case GL_GET_ERROR_QUERY_CHROMIUM:\n       return true;\n \n     default:\n       return false;\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187034, "func": " void DOMStorageContextWrapper::Shutdown() {\n  DCHECK(context_.get());\n  mojo_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,\n                                base::Unretained(mojo_state_)));\n  mojo_state_ = nullptr;\n   if (mojo_session_state_) {\n     mojo_task_runner_->PostTask(\n         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,\n                                   base::Unretained(mojo_session_state_)));\n     mojo_session_state_ = nullptr;\n   }\n   memory_pressure_listener_.reset();\n  context_->task_runner()->PostShutdownBlockingTask(\n      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,\n      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,14,15,16"}
{"idx": 186684, "func": "bool HeapAllocator::backingShrink(void* address,\n                                  size_t quantizedCurrentSize,\n                                  size_t quantizedShrunkSize) {\n  if (!address || quantizedShrunkSize == quantizedCurrentSize)\n    return true;\n\n  ASSERT(quantizedShrunkSize < quantizedCurrentSize);\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return false;\n  ASSERT(!state->isInGC());\n  ASSERT(state->isAllocationAllowed());\n  DCHECK_EQ(&state->heap(), &ThreadState::fromObject(address)->heap());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return false;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n  if (quantizedCurrentSize <=\n          quantizedShrunkSize + sizeof(HeapObjectHeader) + sizeof(void*) * 32 &&\n      !arena->isObjectAllocatedAtAllocationPoint(header))\n    return true;\n\n  bool succeededAtAllocationPoint =\n      arena->shrinkObject(header, quantizedShrunkSize);\n  if (succeededAtAllocationPoint)\n    state->allocationPointAdjusted(arena->arenaIndex());\n  return true;\n}\n", "target": 1, "flaw_line_index": "23"}
{"idx": 8277, "func": "XRenderFindDisplay (Display *dpy)\n{\n    XRenderExtDisplayInfo *dpyinfo;\n\n    dpyinfo = XRenderExtFindDisplay (&XRenderExtensionInfo, dpy);\n    if (!dpyinfo)\n\tdpyinfo = XRenderExtAddDisplay (&XRenderExtensionInfo, dpy,\n                                        XRenderExtensionName);\n    return dpyinfo;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7985, "func": "static void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings)\n{\n    int i;\n    unsigned int enc = 0;\n\n    vs->features = 0;\n    vs->vnc_encoding = 0;\n    vs->tight.compression = 9;\n    vs->tight.quality = -1; \n    vs->absolute = -1;\n\n    for (i = n_encodings - 1; i >= 0; i--) {\n        enc = encodings[i];\n        switch (enc) {\n        case VNC_ENCODING_RAW:\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_COPYRECT:\n            vs->features |= VNC_FEATURE_COPYRECT_MASK;\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vs->features |= VNC_FEATURE_HEXTILE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_TIGHT:\n            vs->features |= VNC_FEATURE_TIGHT_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#ifdef CONFIG_VNC_PNG\n        case VNC_ENCODING_TIGHT_PNG:\n            vs->features |= VNC_FEATURE_TIGHT_PNG_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#endif\n        case VNC_ENCODING_ZLIB:\n            vs->features |= VNC_FEATURE_ZLIB_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZRLE:\n            vs->features |= VNC_FEATURE_ZRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            vs->features |= VNC_FEATURE_ZYWRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_DESKTOPRESIZE:\n            vs->features |= VNC_FEATURE_RESIZE_MASK;\n            break;\n        case VNC_ENCODING_POINTER_TYPE_CHANGE:\n            vs->features |= VNC_FEATURE_POINTER_TYPE_CHANGE_MASK;\n            break;\n        case VNC_ENCODING_RICH_CURSOR:\n            vs->features |= VNC_FEATURE_RICH_CURSOR_MASK;\n            break;\n        case VNC_ENCODING_EXT_KEY_EVENT:\n            send_ext_key_event_ack(vs);\n            break;\n        case VNC_ENCODING_AUDIO:\n            send_ext_audio_ack(vs);\n            break;\n        case VNC_ENCODING_WMVi:\n            vs->features |= VNC_FEATURE_WMVI_MASK;\n            break;\n        case VNC_ENCODING_LED_STATE:\n            vs->features |= VNC_FEATURE_LED_STATE_MASK;\n            break;\n        case VNC_ENCODING_COMPRESSLEVEL0 ... VNC_ENCODING_COMPRESSLEVEL0 + 9:\n            vs->tight.compression = (enc & 0x0F);\n            break;\n        case VNC_ENCODING_QUALITYLEVEL0 ... VNC_ENCODING_QUALITYLEVEL0 + 9:\n            if (vs->vd->lossy) {\n                vs->tight.quality = (enc & 0x0F);\n            }\n            break;\n        default:\n            VNC_DEBUG(\"Unknown encoding: %d (0x%.8x): %d\\n\", i, enc, enc);\n            break;\n        }\n    }\n    vnc_desktop_resize(vs);\n    check_pointer_type_change(&vs->mouse_mode_notifier, NULL);\n    vnc_led_state_change(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7606, "func": "static int cirrus_vga_read_palette(CirrusVGAState * s)\n{\n    int val;\n\n    if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {\n        val = s->cirrus_hidden_palette[(s->vga.dac_read_index & 0x0f) * 3 +\n                                       s->vga.dac_sub_index];\n    } else {\n        val = s->vga.palette[s->vga.dac_read_index * 3 + s->vga.dac_sub_index];\n    }\n    if (++s->vga.dac_sub_index == 3) {\n\ts->vga.dac_sub_index = 0;\n\ts->vga.dac_read_index++;\n    }\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7486, "func": "ssize_t v9fs_get_xattr(FsContext *ctx, const char *path,\n                       const char *name, void *value, size_t size)\n{\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n    if (xops) {\n        return xops->getxattr(ctx, path, name, value, size);\n    }\n    errno = EOPNOTSUPP;\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8172, "func": "void Gfx::opTextMoveSet(Object args[], int numArgs) {\n  double tx, ty;\n\n  tx = state->getLineX() + args[0].getNum();\n  ty = args[1].getNum();\n  state->setLeading(-ty);\n  ty += state->getLineY();\n  state->textMoveTo(tx, ty);\n  out->updateTextPos(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187019, "func": " ExtensionsGuestViewMessageFilter::ExtensionsGuestViewMessageFilter(\n     int render_process_id,\n    BrowserContext* context)\n    : GuestViewMessageFilter(kFilteredMessageClasses,\n                             base::size(kFilteredMessageClasses),\n                              render_process_id,\n                              context),\n       content::BrowserAssociatedInterface<mojom::GuestView>(this, this) {\n  GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8273, "func": "XRenderDepthCheckErrorHandler (Display *dpy, XErrorEvent *evt)\n{\n    if (evt->request_code == X_CreatePixmap && evt->error_code == BadValue)\n    {\n\tDepthCheckPtr\td;\n\t_XLockMutex(_Xglobal_lock);\n\tfor (d = depthChecks; d; d = d->next)\n\t    if (d->dpy == dpy)\n\t    {\n\t\tif ((long) (evt->serial - d->serial) >= 0)\n\t\t    d->missing |= DEPTH_MASK(evt->resourceid);\n\t\tbreak;\n\t    }\n\t_XUnlockMutex (_Xglobal_lock);\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8241, "func": "static void v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n    offset = 7;\n    err = pdu_marshal(pdu, offset, \"d\", total);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7748, "func": "  ft_var_apply_tuple( GX_Blend   blend,\n                      FT_UShort  tupleIndex,\n                      FT_Fixed*  tuple_coords,\n                      FT_Fixed*  im_start_coords,\n                      FT_Fixed*  im_end_coords )\n  {\n    FT_UInt   i;\n    FT_Fixed  apply;\n    FT_Fixed  temp;\n\n\n    apply = 0x10000L;\n    for ( i = 0; i < blend->num_axis; ++i )\n    {\n      if ( tuple_coords[i] == 0 )\n        continue;\n\n      else if ( blend->normalizedcoords[i] == 0                           ||\n                ( blend->normalizedcoords[i] < 0 && tuple_coords[i] > 0 ) ||\n                ( blend->normalizedcoords[i] > 0 && tuple_coords[i] < 0 ) )\n      {\n        apply = 0;\n        break;\n      }\n\n      else if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )\n        apply = FT_MulDiv( apply,\n                           blend->normalizedcoords[i] > 0\n                             ? blend->normalizedcoords[i]\n                             : -blend->normalizedcoords[i],\n                           0x10000L );\n\n      else if ( blend->normalizedcoords[i] <= im_start_coords[i] ||\n                blend->normalizedcoords[i] >= im_end_coords[i]   )\n      {\n        apply = 0;\n        break;\n      }\n\n      else if ( blend->normalizedcoords[i] < tuple_coords[i] )\n      {\n        temp = FT_MulDiv( blend->normalizedcoords[i] - im_start_coords[i],\n                          0x10000L,\n                          tuple_coords[i] - im_start_coords[i]);\n        apply = FT_MulDiv( apply, temp, 0x10000L );\n      }\n\n      else\n      {\n        temp = FT_MulDiv( im_end_coords[i] - blend->normalizedcoords[i],\n                          0x10000L,\n                          im_end_coords[i] - tuple_coords[i] );\n        apply = FT_MulDiv( apply, temp, 0x10000L );\n      }\n    }\n\n    return apply;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 187138, "func": "CSSStyleSheet* CSSStyleSheet::CreateInline(Node& owner_node,\n                                           const KURL& base_url,\n                                           const TextPosition& start_position,\n                                            const WTF::TextEncoding& encoding) {\n   CSSParserContext* parser_context = CSSParserContext::Create(\n       owner_node.GetDocument(), owner_node.GetDocument().BaseURL(),\n       owner_node.GetDocument().GetReferrerPolicy(), encoding);\n   StyleSheetContents* sheet =\n       StyleSheetContents::Create(base_url.GetString(), parser_context);\n  return new CSSStyleSheet(sheet, owner_node, true, start_position);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186495, "func": " void GM2TabStyle::PaintTabBackgroundFill(gfx::Canvas* canvas,\n                                         bool active,\n                                          bool paint_hover_effect,\n                                         SkColor active_color,\n                                         SkColor inactive_color,\n                                          int fill_id,\n                                          int y_inset) const {\n  const SkPath fill_path =\n      GetPath(PathType::kFill, canvas->image_scale(), active);\n   gfx::ScopedCanvas scoped_canvas(canvas);\n   const float scale = canvas->UndoDeviceScaleFactor();\n \n   canvas->ClipPath(fill_path, true);\n \n  if (active || !fill_id) {\n     cc::PaintFlags flags;\n     flags.setAntiAlias(true);\n    flags.setColor(active ? active_color : inactive_color);\n     canvas->DrawRect(gfx::ScaleToEnclosingRect(tab_->GetLocalBounds(), scale),\n                      flags);\n   }\n\n  if (fill_id) {\n    gfx::ScopedCanvas scale_scoper(canvas);\n    canvas->sk_canvas()->scale(scale, scale);\n    canvas->TileImageInt(*tab_->GetThemeProvider()->GetImageSkiaNamed(fill_id),\n                         tab_->GetMirroredX() + tab_->background_offset(), 0, 0,\n                         y_inset, tab_->width(), tab_->height());\n  }\n\n  if (paint_hover_effect) {\n    SkPoint hover_location(gfx::PointToSkPoint(hover_controller_->location()));\n    hover_location.scale(SkFloatToScalar(scale));\n    const SkScalar kMinHoverRadius = 16;\n     const SkScalar radius =\n         std::max(SkFloatToScalar(tab_->width() / 4.f), kMinHoverRadius);\n     DrawHighlight(canvas, hover_location, radius * scale,\n                  SkColorSetA(active_color, hover_controller_->GetAlpha()));\n   }\n }\n", "target": 1, "flaw_line_index": "2,4,5,8,9,15,16,17,18,21,41"}
{"idx": 8244, "func": "static void v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n    xattr_fidp->fs.xattr.flags = flags;\n    v9fs_string_init(&xattr_fidp->fs.xattr.name);\n    v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    xattr_fidp->fs.xattr.value = g_malloc(size);\n    err = offset;\n    put_fid(pdu, file_fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186767, "func": " void SharedWorkerDevToolsAgentHost::WorkerDestroyed() {\n  DCHECK_NE(WORKER_TERMINATED, state_);\n  DCHECK(worker_host_);\n  state_ = WORKER_TERMINATED;\n   for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n     inspector->TargetCrashed();\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(nullptr, nullptr);\n   worker_host_ = nullptr;\n   agent_ptr_.reset();\n }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 186377, "func": "bool ClientControlledShellSurface::OnPreWidgetCommit() {\n  if (!widget_) {\n    if (!pending_geometry_.IsEmpty())\n      origin_ = pending_geometry_.origin();\n    CreateShellSurfaceWidget(ash::ToWindowShowState(pending_window_state_));\n  }\n\n  ash::wm::WindowState* window_state = GetWindowState();\n  if (window_state->GetStateType() == pending_window_state_) {\n    if (window_state->IsPip() && !window_state->is_dragged()) {\n      client_controlled_state_->set_next_bounds_change_animation_type(\n          ash::wm::ClientControlledState::kAnimationAnimated);\n    }\n\n    return true;\n  }\n\n  if (IsPinned(window_state)) {\n    VLOG(1) << \"State change was requested while pinned\";\n    return true;\n  }\n\n  auto animation_type = ash::wm::ClientControlledState::kAnimationNone;\n  switch (pending_window_state_) {\n    case ash::WindowStateType::kNormal:\n      if (widget_->IsMaximized() || widget_->IsFullscreen()) {\n        animation_type = ash::wm::ClientControlledState::kAnimationCrossFade;\n      }\n      break;\n\n    case ash::WindowStateType::kMaximized:\n    case ash::WindowStateType::kFullscreen:\n      if (!window_state->IsPip())\n        animation_type = ash::wm::ClientControlledState::kAnimationCrossFade;\n      break;\n\n    default:\n      break;\n  }\n\n  if (pending_window_state_ == ash::WindowStateType::kPip) {\n    if (ash::features::IsPipRoundedCornersEnabled()) {\n      decorator_ = std::make_unique<ash::RoundedCornerDecorator>(\n          window_state->window(), host_window(), host_window()->layer(),\n          ash::kPipRoundedCornerRadius);\n    }\n  } else {\n    decorator_.reset();  \n  }\n \n   bool wasPip = window_state->IsPip();\n \n   if (client_controlled_state_->EnterNextState(window_state,\n                                                pending_window_state_)) {\n     client_controlled_state_->set_next_bounds_change_animation_type(\n        animation_type);\n  }\n\n  if (wasPip && !window_state->IsMinimized()) {\n    ash::Shell::Get()->split_view_controller()->EndSplitView(\n        ash::SplitViewController::EndReason::kPipExpanded);\n    window_state->Activate();\n  }\n\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186761, "func": " void ServiceWorkerDevToolsAgentHost::WorkerDestroyed() {\n  DCHECK_NE(WORKER_TERMINATED, state_);\n  state_ = WORKER_TERMINATED;\n  agent_ptr_.reset();\n   for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n     inspector->TargetCrashed();\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(nullptr, nullptr);\n }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 187047, "func": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n  DCHECK_EQ(read_type_, kReadAsArrayBuffer);\n  if (array_buffer_result_)\n    return array_buffer_result_;\n\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n \n  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  if (finished_loading_) {\n    array_buffer_result_ = result;\n    AdjustReportedMemoryUsageToV8(\n        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n    raw_data_.reset();\n   }\n  return result;\n }\n", "target": 1, "flaw_line_index": "10,11,12,13,14,15,17"}
{"idx": 187200, "func": "bool PlatformFontSkia::InitDefaultFont() {\n  if (g_default_font.Get())\n    return true;\n \n   bool success = false;\n   std::string family = kFallbackFontFamilyName;\n  int size_pixels = 12;\n   int style = Font::NORMAL;\n   Font::Weight weight = Font::Weight::NORMAL;\n   FontRenderParams params;\n\n  const SkiaFontDelegate* delegate = SkiaFontDelegate::instance();\n  if (delegate) {\n    delegate->GetDefaultFontDescription(&family, &size_pixels, &style, &weight,\n                                        &params);\n  } else if (default_font_description_) {\n#if defined(OS_CHROMEOS)\n    FontRenderParamsQuery query;\n    CHECK(FontList::ParseDescription(*default_font_description_,\n                                     &query.families, &query.style,\n                                     &query.pixel_size, &query.weight))\n        << \"Failed to parse font description \" << *default_font_description_;\n    params = gfx::GetFontRenderParams(query, &family);\n    size_pixels = query.pixel_size;\n    style = query.style;\n    weight = query.weight;\n#else\n    NOTREACHED();\n#endif\n  }\n\n  sk_sp<SkTypeface> typeface =\n      CreateSkTypeface(style & Font::ITALIC, weight, &family, &success);\n  if (!success)\n    return false;\n  g_default_font.Get() = new PlatformFontSkia(\n      std::move(typeface), family, size_pixels, style, weight, params);\n  return true;\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 7953, "func": "static int buffer_empty(Buffer *buffer)\n{\n    return buffer->offset == 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187052, "func": "void ImageBitmapFactories::ImageBitmapLoader::LoadBlobAsync(\n    Blob* blob) {\n   loader_->Start(blob->GetBlobDataHandle());\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187050, "func": " void ImageBitmapFactories::ImageBitmapLoader::DidFinishLoading() {\n   DOMArrayBuffer* array_buffer = loader_->ArrayBufferResult();\n   if (!array_buffer) {\n     RejectPromise(kAllocationFailureImageBitmapRejectionReason);\n     return;\n  }\n  ScheduleAsyncImageBitmapDecoding(array_buffer);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187008, "func": "void HTMLCanvasElement::Dispose() {\n   if (PlaceholderFrame())\n     ReleasePlaceholderFrame();\n \n   if (context_) {\n     context_->DetachHost();\n     context_ = nullptr;\n  }\n\n  if (canvas2d_bridge_) {\n    canvas2d_bridge_->SetCanvasResourceHost(nullptr);\n    canvas2d_bridge_ = nullptr;\n  }\n\n  if (gpu_memory_usage_) {\n    DCHECK_GT(global_accelerated_context_count_, 0u);\n    global_accelerated_context_count_--;\n  }\n  global_gpu_memory_usage_ -= gpu_memory_usage_;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7534, "func": "void doMergeFormDict(Dict *srcFormDict, Dict *mergeFormDict, int numOffset) {\n  Object srcFields, mergeFields;\n\n  srcFormDict->lookup(\"Fields\", &srcFields);\n  mergeFormDict->lookup(\"Fields\", &mergeFields);\n  if (srcFields.isArray() && mergeFields.isArray()) {\n    for (int i = 0; i < mergeFields.arrayGetLength(); i++) {\n      Object value;\n      Object *newValue = new Object();\n      mergeFields.arrayGetNF(i, &value);\n      newValue->initRef(value.getRef().num + numOffset, value.getRef().gen);\n      srcFields.arrayAdd(newValue);\n      value.free();\n      delete newValue;\n    }\n  }\n  srcFields.free();\n  mergeFields.free();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7948, "func": "static void audio_add(VncState *vs)\n{\n    struct audio_capture_ops ops;\n\n    if (vs->audio_cap) {\n        error_report(\"audio already running\");\n        return;\n    }\n\n    ops.notify = audio_capture_notify;\n    ops.destroy = audio_capture_destroy;\n    ops.capture = audio_capture;\n\n    vs->audio_cap = AUD_add_capture(&vs->as, &ops, vs);\n    if (!vs->audio_cap) {\n        error_report(\"Failed to add audio capture\");\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8056, "func": "void vnc_write_u16(VncState *vs, uint16_t value)\n{\n    uint8_t buf[2];\n\n    buf[0] = (value >> 8) & 0xFF;\n    buf[1] = value & 0xFF;\n\n    vnc_write(vs, buf, 2);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7930, "func": "static void emitnumber(JF, double num)\n{\n\tif (num == 0) {\n\t\temit(J, F, OP_NUMBER_0);\n\t\tif (signbit(num))\n\t\t\temit(J, F, OP_NEG);\n\t} else if (num == 1) {\n\t\temit(J, F, OP_NUMBER_1);\n\t} else if (num == (js_Instruction)num) {\n\t\temit(J, F, OP_NUMBER_POS);\n\t\temitraw(J, F, (js_Instruction)num);\n\t} else if (num < 0 && -num == (js_Instruction)(-num)) {\n\t\temit(J, F, OP_NUMBER_NEG);\n\t\temitraw(J, F, (js_Instruction)(-num));\n\t} else {\n\t\temit(J, F, OP_NUMBER);\n\t\temitraw(J, F, addnumber(J, F, num));\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186426, "func": "std::string SanitizeFrontendPath(const std::string& path) {\n  for (size_t i = 0; i < path.length(); i++) {\n    if (path[i] != '/' && path[i] != '-' && path[i] != '_'\n        && path[i] != '.' && path[i] != '@'\n        && !(path[i] >= '0' && path[i] <= '9')\n        && !(path[i] >= 'a' && path[i] <= 'z')\n        && !(path[i] >= 'A' && path[i] <= 'Z')) {\n      return std::string();\n    }\n  }\n  return path;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12"}
{"idx": 186529, "func": "  void InitPrefMembers() {\n    settings_->InitPrefMembers();\n  }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 187324, "func": "xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){\n    static char base_address;\n    xmlNodePtr cur = NULL;\n     xmlXPathObjectPtr obj = NULL;\n     long val;\n     xmlChar str[30];\n    xmlDocPtr doc;\n \n     if (nargs == 0) {\n \tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlNodeSetPtr nodelist;\n\tint i, ret;\n\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid arg expecting a node-set\\n\");\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewCString(\"\"));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t        cur = nodelist->nodeTab[i];\n\t}\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid number of args %d\\n\", nargs);\n \tctxt->error = XPATH_INVALID_ARITY;\n \treturn;\n     }\n    if (cur->type != XML_NAMESPACE_DECL)\n        doc = cur->doc;\n    else {\n        xmlNsPtr ns = (xmlNsPtr) cur;\n        if (ns->context != NULL)\n            doc = ns->context;\n        else\n            doc = ctxt->context->doc;\n    }\n \n     if (obj)\n         xmlXPathFreeObject(obj);\n \n     val = (long)((char *)cur - (char *)&base_address);\n     if (val >= 0) {\n      sprintf((char *)str, \"idp%ld\", val);\n     } else {\n      sprintf((char *)str, \"idm%ld\", -val);\n     }\n     valuePush(ctxt, xmlXPathNewString(str));\n }\n", "target": 1, "flaw_line_index": "7,39,39,40,41,42,43,44,45,46,47,48,55,57"}
{"idx": 7675, "func": "static int handle_lremovexattr(FsContext *ctx, V9fsPath *fs_path,\n                               const char *name)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fremovexattr(fd, name);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8229, "func": "void v9fs_reclaim_fd(V9fsPDU *pdu)\n{\n    int reclaim_count = 0;\n    V9fsState *s = pdu->s;\n    V9fsFidState *f, *reclaim_list = NULL;\n\n    for (f = s->fid_list; f; f = f->next) {\n        if (f->ref || f->flags & FID_NON_RECLAIMABLE) {\n            continue;\n        }\n        if (f->flags & FID_REFERENCED) {\n            f->flags &= ~FID_REFERENCED;\n            continue;\n        }\n        if (f->fid_type == P9_FID_FILE) {\n            if (f->fs.fd != -1) {\n                f->ref++;\n                f->rclm_lst = reclaim_list;\n                reclaim_list = f;\n                f->fs_reclaim.fd = f->fs.fd;\n                f->fs.fd = -1;\n                reclaim_count++;\n            }\n        } else if (f->fid_type == P9_FID_DIR) {\n            if (f->fs.dir.stream != NULL) {\n                f->ref++;\n                f->rclm_lst = reclaim_list;\n                reclaim_list = f;\n                f->fs_reclaim.dir.stream = f->fs.dir.stream;\n                f->fs.dir.stream = NULL;\n                reclaim_count++;\n            }\n        }\n        if (reclaim_count >= open_fd_rc) {\n            break;\n        }\n    }\n    while (reclaim_list) {\n        f = reclaim_list;\n        reclaim_list = f->rclm_lst;\n        if (f->fid_type == P9_FID_FILE) {\n            v9fs_co_close(pdu, &f->fs_reclaim);\n        } else if (f->fid_type == P9_FID_DIR) {\n            v9fs_co_closedir(pdu, &f->fs_reclaim);\n        }\n        f->rclm_lst = NULL;\n        put_fid(pdu, f);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186402, "func": "void PageInfo::ComputeUIInputs(\n    const GURL& url,\n    security_state::SecurityLevel security_level,\n    const security_state::VisibleSecurityState& visible_security_state) {\n#if !defined(OS_ANDROID)\n  DCHECK(!url.SchemeIs(content::kChromeUIScheme) &&\n         !url.SchemeIs(content::kChromeDevToolsScheme) &&\n         !url.SchemeIs(content::kViewSourceScheme) &&\n         !url.SchemeIs(content_settings::kExtensionScheme));\n#endif\n\n  bool is_chrome_ui_native_scheme = false;\n#if defined(OS_ANDROID)\n  is_chrome_ui_native_scheme = url.SchemeIs(chrome::kChromeUINativeScheme);\n#endif\n\n  security_level_ = security_level;\n\n  if (url.SchemeIs(url::kAboutScheme)) {\n     DCHECK_EQ(url::kAboutBlankURL, url.spec());\n     site_identity_status_ = SITE_IDENTITY_STATUS_NO_CERT;\n    site_details_message_ =\n         l10n_util::GetStringUTF16(IDS_PAGE_INFO_SECURITY_TAB_INSECURE_IDENTITY);\n     site_connection_status_ = SITE_CONNECTION_STATUS_UNENCRYPTED;\n     site_connection_details_ = l10n_util::GetStringFUTF16(\n        IDS_PAGE_INFO_SECURITY_TAB_NOT_ENCRYPTED_CONNECTION_TEXT,\n        UTF8ToUTF16(url.spec()));\n    return;\n  }\n \n   if (url.SchemeIs(content::kChromeUIScheme) || is_chrome_ui_native_scheme) {\n     site_identity_status_ = SITE_IDENTITY_STATUS_INTERNAL_PAGE;\n    site_details_message_ =\n         l10n_util::GetStringUTF16(IDS_PAGE_INFO_INTERNAL_PAGE);\n     site_connection_status_ = SITE_CONNECTION_STATUS_INTERNAL_PAGE;\n     return;\n  }\n\n   certificate_ = visible_security_state.certificate;\n \n  if (certificate_ &&\n      (!net::IsCertStatusError(visible_security_state.cert_status) ||\n       net::IsCertStatusMinorError(visible_security_state.cert_status))) {\n     if (security_level == security_state::SECURE_WITH_POLICY_INSTALLED_CERT) {\n #if defined(OS_CHROMEOS)\n       site_identity_status_ = SITE_IDENTITY_STATUS_ADMIN_PROVIDED_CERT;\n      site_details_message_ = l10n_util::GetStringFUTF16(\n           IDS_CERT_POLICY_PROVIDED_CERT_MESSAGE, UTF8ToUTF16(url.host()));\n #else\n       DCHECK(false) << \"Policy certificates exist only on ChromeOS\";\n#endif\n    } else if (net::IsCertStatusMinorError(\n                   visible_security_state.cert_status)) {\n      site_identity_status_ = SITE_IDENTITY_STATUS_CERT_REVOCATION_UNKNOWN;\n      base::string16 issuer_name(\n          UTF8ToUTF16(certificate_->issuer().GetDisplayName()));\n      if (issuer_name.empty()) {\n        issuer_name.assign(l10n_util::GetStringUTF16(\n             IDS_PAGE_INFO_SECURITY_TAB_UNKNOWN_PARTY));\n       }\n \n      site_details_message_.assign(l10n_util::GetStringFUTF16(\n           IDS_PAGE_INFO_SECURITY_TAB_SECURE_IDENTITY_VERIFIED, issuer_name));\n \n      site_details_message_ += ASCIIToUTF16(\"\\n\\n\");\n       if (visible_security_state.cert_status &\n           net::CERT_STATUS_UNABLE_TO_CHECK_REVOCATION) {\n        site_details_message_ += l10n_util::GetStringUTF16(\n             IDS_PAGE_INFO_SECURITY_TAB_UNABLE_TO_CHECK_REVOCATION);\n       } else if (visible_security_state.cert_status &\n                  net::CERT_STATUS_NO_REVOCATION_MECHANISM) {\n        site_details_message_ += l10n_util::GetStringUTF16(\n             IDS_PAGE_INFO_SECURITY_TAB_NO_REVOCATION_MECHANISM);\n       } else {\n         NOTREACHED() << \"Need to specify string for this warning\";\n      }\n    } else {\n      if (visible_security_state.cert_status & net::CERT_STATUS_IS_EV) {\n        site_identity_status_ = SITE_IDENTITY_STATUS_EV_CERT;\n        DCHECK(!certificate_->subject().organization_names.empty());\n        organization_name_ =\n            UTF8ToUTF16(certificate_->subject().organization_names[0]);\n         DCHECK(!certificate_->subject().locality_name.empty());\n         DCHECK(!certificate_->subject().country_name.empty());\n        site_details_message_.assign(l10n_util::GetStringFUTF16(\n             IDS_PAGE_INFO_SECURITY_TAB_SECURE_IDENTITY_EV_VERIFIED,\n             organization_name_,\n             UTF8ToUTF16(certificate_->subject().country_name)));\n      } else {\n        site_identity_status_ = SITE_IDENTITY_STATUS_CERT;\n        base::string16 issuer_name(\n            UTF8ToUTF16(certificate_->issuer().GetDisplayName()));\n        if (issuer_name.empty()) {\n          issuer_name.assign(l10n_util::GetStringUTF16(\n               IDS_PAGE_INFO_SECURITY_TAB_UNKNOWN_PARTY));\n         }\n \n        site_details_message_.assign(l10n_util::GetStringFUTF16(\n             IDS_PAGE_INFO_SECURITY_TAB_SECURE_IDENTITY_VERIFIED, issuer_name));\n       }\n       if (security_state::IsSHA1InChain(visible_security_state)) {\n         site_identity_status_ =\n             SITE_IDENTITY_STATUS_DEPRECATED_SIGNATURE_ALGORITHM;\n        site_details_message_ +=\n             UTF8ToUTF16(\"\\n\\n\") +\n             l10n_util::GetStringUTF16(\n                 IDS_PAGE_INFO_SECURITY_TAB_DEPRECATED_SIGNATURE_ALGORITHM);\n       }\n     }\n   } else {\n    site_details_message_.assign(l10n_util::GetStringUTF16(\n         IDS_PAGE_INFO_SECURITY_TAB_INSECURE_IDENTITY));\n     if (!security_state::IsSchemeCryptographic(visible_security_state.url) ||\n         !visible_security_state.certificate) {\n      site_identity_status_ = SITE_IDENTITY_STATUS_NO_CERT;\n    } else {\n      site_identity_status_ = SITE_IDENTITY_STATUS_ERROR;\n    }\n\n    const base::string16 bullet = UTF8ToUTF16(\"\\n \u2022 \");\n    std::vector<ssl_errors::ErrorInfo> errors;\n     ssl_errors::ErrorInfo::GetErrorsForCertStatus(\n         certificate_, visible_security_state.cert_status, url, &errors);\n     for (size_t i = 0; i < errors.size(); ++i) {\n      site_details_message_ += bullet;\n      site_details_message_ += errors[i].short_description();\n     }\n \n     if (visible_security_state.cert_status & net::CERT_STATUS_NON_UNIQUE_NAME) {\n      site_details_message_ += ASCIIToUTF16(\"\\n\\n\");\n      site_details_message_ +=\n           l10n_util::GetStringUTF16(IDS_PAGE_INFO_SECURITY_TAB_NON_UNIQUE_NAME);\n     }\n   }\n \n  if (visible_security_state.malicious_content_status !=\n      security_state::MALICIOUS_CONTENT_STATUS_NONE) {\n    GetSafeBrowsingStatusByMaliciousContentStatus(\n        visible_security_state.malicious_content_status, &safe_browsing_status_,\n        &site_details_message_);\n#if defined(FULL_SAFE_BROWSING)\n    bool old_show_change_pw_buttons = show_change_password_buttons_;\n#endif\n    show_change_password_buttons_ =\n        (visible_security_state.malicious_content_status ==\n             security_state::MALICIOUS_CONTENT_STATUS_SIGN_IN_PASSWORD_REUSE ||\n         visible_security_state.malicious_content_status ==\n             security_state::\n                 MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE);\n#if defined(FULL_SAFE_BROWSING)\n    if (show_change_password_buttons_ && !old_show_change_pw_buttons) {\n      RecordPasswordReuseEvent();\n    }\n#endif\n  }\n  site_connection_status_ = SITE_CONNECTION_STATUS_UNKNOWN;\n\n  base::string16 subject_name(GetSimpleSiteName(url));\n  if (subject_name.empty()) {\n    subject_name.assign(\n        l10n_util::GetStringUTF16(IDS_PAGE_INFO_SECURITY_TAB_UNKNOWN_PARTY));\n  }\n\n  if (!visible_security_state.certificate ||\n      !security_state::IsSchemeCryptographic(visible_security_state.url)) {\n    site_connection_status_ = SITE_CONNECTION_STATUS_UNENCRYPTED;\n\n    site_connection_details_.assign(l10n_util::GetStringFUTF16(\n        IDS_PAGE_INFO_SECURITY_TAB_NOT_ENCRYPTED_CONNECTION_TEXT,\n        subject_name));\n  } else if (!visible_security_state.connection_info_initialized) {\n    DCHECK_NE(security_level, security_state::NONE);\n    site_connection_status_ = SITE_CONNECTION_STATUS_ENCRYPTED_ERROR;\n  } else {\n    site_connection_status_ = SITE_CONNECTION_STATUS_ENCRYPTED;\n\n    if (net::ObsoleteSSLStatus(\n            visible_security_state.connection_status,\n            visible_security_state.peer_signature_algorithm) ==\n        net::OBSOLETE_SSL_NONE) {\n      site_connection_details_.assign(l10n_util::GetStringFUTF16(\n          IDS_PAGE_INFO_SECURITY_TAB_ENCRYPTED_CONNECTION_TEXT, subject_name));\n    } else {\n      site_connection_details_.assign(l10n_util::GetStringFUTF16(\n          IDS_PAGE_INFO_SECURITY_TAB_WEAK_ENCRYPTION_CONNECTION_TEXT,\n          subject_name));\n    }\n\n    ReportAnyInsecureContent(visible_security_state, &site_connection_status_,\n                             &site_connection_details_);\n  }\n\n  uint16_t cipher_suite = net::SSLConnectionStatusToCipherSuite(\n      visible_security_state.connection_status);\n  if (visible_security_state.connection_info_initialized && cipher_suite) {\n    int ssl_version = net::SSLConnectionStatusToVersion(\n        visible_security_state.connection_status);\n    const char* ssl_version_str;\n    net::SSLVersionToString(&ssl_version_str, ssl_version);\n    site_connection_details_ += ASCIIToUTF16(\"\\n\\n\");\n    site_connection_details_ += l10n_util::GetStringFUTF16(\n        IDS_PAGE_INFO_SECURITY_TAB_SSL_VERSION, ASCIIToUTF16(ssl_version_str));\n\n    const char *key_exchange, *cipher, *mac;\n    bool is_aead, is_tls13;\n    net::SSLCipherSuiteToStrings(&key_exchange, &cipher, &mac, &is_aead,\n                                 &is_tls13, cipher_suite);\n\n    site_connection_details_ += ASCIIToUTF16(\"\\n\\n\");\n    if (is_aead) {\n      if (is_tls13) {\n        key_exchange =\n            SSL_get_curve_name(visible_security_state.key_exchange_group);\n        if (!key_exchange) {\n          NOTREACHED();\n          key_exchange = \"\";\n        }\n      }\n      site_connection_details_ += l10n_util::GetStringFUTF16(\n          IDS_PAGE_INFO_SECURITY_TAB_ENCRYPTION_DETAILS_AEAD,\n          ASCIIToUTF16(cipher), ASCIIToUTF16(key_exchange));\n    } else {\n      site_connection_details_ += l10n_util::GetStringFUTF16(\n          IDS_PAGE_INFO_SECURITY_TAB_ENCRYPTION_DETAILS, ASCIIToUTF16(cipher),\n          ASCIIToUTF16(mac), ASCIIToUTF16(key_exchange));\n    }\n  }\n\n  ChromeSSLHostStateDelegate* delegate =\n       ChromeSSLHostStateDelegateFactory::GetForProfile(profile_);\n   DCHECK(delegate);\n  show_ssl_decision_revoke_button_ =\n      delegate->HasAllowException(url.host()) &&\n      visible_security_state.malicious_content_status ==\n          security_state::MALICIOUS_CONTENT_STATUS_NONE;\n }\n", "target": 1, "flaw_line_index": "25,36,45,46,47,52,67,70,73,77,94,108,114,122,136,137,141,142,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168"}
{"idx": 186547, "func": "void PeopleHandler::HandlePauseSync(const base::ListValue* args) {\n  DCHECK(AccountConsistencyModeManager::IsDiceEnabledForProfile(profile_));\n  SigninManager* signin_manager = SigninManagerFactory::GetForProfile(profile_);\n   DCHECK(signin_manager->IsAuthenticated());\n   ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)->UpdateCredentials(\n       signin_manager->GetAuthenticatedAccountId(),\n      OAuth2TokenServiceDelegate::kInvalidRefreshToken);\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 186715, "func": "GURL CreateResource(const std::string& content, const std::string& file_ext) {\n   base::FilePath path;\n   EXPECT_TRUE(base::CreateTemporaryFile(&path));\n   EXPECT_EQ(static_cast<int>(content.size()),\n             base::WriteFile(path, content.c_str(), content.size()));\n  base::FilePath path_with_extension;\n  path_with_extension = path.AddExtension(FILE_PATH_LITERAL(file_ext));\n  EXPECT_TRUE(base::Move(path, path_with_extension));\n  return net::FilePathToFileURL(path_with_extension);\n }\n", "target": 1, "flaw_line_index": "6,7,8,9"}
{"idx": 7665, "func": "static int handle_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8232, "func": "static void v9fs_renameat(void *opaque)\n{\n    ssize_t err = 0;\n    size_t offset = 7;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t olddirfid, newdirfid;\n    V9fsString old_name, new_name;\n\n    v9fs_string_init(&old_name);\n    v9fs_string_init(&new_name);\n    err = pdu_unmarshal(pdu, offset, \"dsds\", &olddirfid,\n                        &old_name, &newdirfid, &new_name);\n    if (err < 0) {\n        goto out_err;\n    }\n\n    if (name_is_illegal(old_name.data) || name_is_illegal(new_name.data)) {\n        err = -ENOENT;\n        goto out_err;\n    }\n\n    if (!strcmp(\".\", old_name.data) || !strcmp(\"..\", old_name.data) ||\n        !strcmp(\".\", new_name.data) || !strcmp(\"..\", new_name.data)) {\n        err = -EISDIR;\n        goto out_err;\n    }\n\n    v9fs_path_write_lock(s);\n    err = v9fs_complete_renameat(pdu, olddirfid,\n                                 &old_name, newdirfid, &new_name);\n    v9fs_path_unlock(s);\n    if (!err) {\n        err = offset;\n    }\n\nout_err:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&old_name);\n    v9fs_string_free(&new_name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186344, "func": " PreresolveJob::PreresolveJob(PreconnectRequest preconnect_request,\n                              PreresolveInfo* info)\n    : url(std::move(preconnect_request.origin)),\n       num_sockets(preconnect_request.num_sockets),\n       allow_credentials(preconnect_request.allow_credentials),\n       network_isolation_key(\n          std::move(preconnect_request.network_isolation_key)),\n      info(info) {\n  DCHECK_GE(num_sockets, 0);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8064, "func": "void FoFiType1::writeEncoded(char **newEncoding,\n\t\t\t     FoFiOutputFunc outputFunc, void *outputStream) {\n  char buf[512];\n  char *line, *line2, *p;\n  int i;\n\n  for (line = (char *)file;\n       line && strncmp(line, \"/Encoding\", 9);\n       line = getNextLine(line)) ;\n  if (!line) {\n    (*outputFunc)(outputStream, (char *)file, len);\n    return;\n  }\n  (*outputFunc)(outputStream, (char *)file, line - (char *)file);\n\n  (*outputFunc)(outputStream, \"/Encoding 256 array\\n\", 20);\n  (*outputFunc)(outputStream,\n\t\t\"0 1 255 {1 index exch /.notdef put} for\\n\", 40);\n  for (i = 0; i < 256; ++i) {\n    if (newEncoding[i]) {\n      sprintf(buf, \"dup %d /%s put\\n\", i, newEncoding[i]);\n      (*outputFunc)(outputStream, buf, strlen(buf));\n    }\n  }\n  (*outputFunc)(outputStream, \"readonly def\\n\", 13);\n  \n  if (!strncmp(line, \"/Encoding StandardEncoding def\", 30)) {\n    line = getNextLine(line);\n  } else {\n    p = line + 10;\n    line = NULL;\n    for (; p < (char *)file + len; ++p) {\n      if ((*p == ' ' || *p == '\\t' || *p == '\\x0a' ||\n\t   *p == '\\x0d' || *p == '\\x0c' || *p == '\\0') &&\n\t  p + 4 <= (char *)file + len &&\n\t  !strncmp(p + 1, \"def\", 3)) {\n\tline = p + 4;\n\tbreak;\n      }\n    }\n  }\n\n  if (line) {\n    for (line2 = line, i = 0;\n\t i < 20 && line2 && strncmp(line2, \"/Encoding\", 9);\n\t line2 = getNextLine(line2), ++i) ;\n    if (i < 20 && line2) {\n      (*outputFunc)(outputStream, line, line2 - line);\n      if (!strncmp(line2, \"/Encoding StandardEncoding def\", 30)) {\n\tline = getNextLine(line2);\n      } else {\n\tp = line2 + 10;\n\tline = NULL;\n\tfor (; p < (char *)file + len; ++p) {\n\t  if ((*p == ' ' || *p == '\\t' || *p == '\\x0a' ||\n\t       *p == '\\x0d' || *p == '\\x0c' || *p == '\\0') &&\n\t      p + 4 <= (char *)file + len &&\n\t      !strncmp(p + 1, \"def\", 3)) {\n\t    line = p + 4;\n\t    break;\n\t  }\n\t}\n      }\n    }\n\n    if (line) {\n      (*outputFunc)(outputStream, line, ((char *)file + len) - line);\n    }\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186434, "func": "void InspectorNetworkAgent::DidReceiveResourceResponse(\n    unsigned long identifier,\n    DocumentLoader* loader,\n    const ResourceResponse& response,\n    Resource* cached_resource) {\n  String request_id = IdentifiersFactory::RequestId(identifier);\n  bool is_not_modified = response.HttpStatusCode() == 304;\n\n  bool resource_is_empty = true;\n  std::unique_ptr<protocol::Network::Response> resource_response =\n      BuildObjectForResourceResponse(response, cached_resource,\n                                      &resource_is_empty);\n \n   InspectorPageAgent::ResourceType type =\n      cached_resource ? InspectorPageAgent::CachedResourceType(*cached_resource)\n                      : InspectorPageAgent::kOtherResource;\n   InspectorPageAgent::ResourceType saved_type =\n       resources_data_->GetResourceType(request_id);\n  if (saved_type == InspectorPageAgent::kScriptResource ||\n      saved_type == InspectorPageAgent::kXHRResource ||\n      saved_type == InspectorPageAgent::kDocumentResource ||\n      saved_type == InspectorPageAgent::kFetchResource ||\n      saved_type == InspectorPageAgent::kEventSourceResource) {\n    type = saved_type;\n  }\n  if (type == InspectorPageAgent::kDocumentResource && loader &&\n      loader->GetSubstituteData().IsValid())\n    return;\n\n  if (cached_resource)\n    resources_data_->AddResource(request_id, cached_resource);\n  String frame_id = loader && loader->GetFrame()\n                        ? IdentifiersFactory::FrameId(loader->GetFrame())\n                        : \"\";\n  String loader_id = loader ? IdentifiersFactory::LoaderId(loader) : \"\";\n  resources_data_->ResponseReceived(request_id, frame_id, response);\n  resources_data_->SetResourceType(request_id, type);\n\n  if (response.GetSecurityStyle() != ResourceResponse::kSecurityStyleUnknown &&\n      response.GetSecurityStyle() !=\n          ResourceResponse::kSecurityStyleUnauthenticated) {\n    const ResourceResponse::SecurityDetails* response_security_details =\n        response.GetSecurityDetails();\n    resources_data_->SetCertificate(request_id,\n                                    response_security_details->certificate);\n  }\n\n  if (resource_response && !resource_is_empty) {\n    Maybe<String> maybe_frame_id;\n    if (!frame_id.IsEmpty())\n      maybe_frame_id = frame_id;\n    GetFrontend()->responseReceived(\n        request_id, loader_id, MonotonicallyIncreasingTime(),\n        InspectorPageAgent::ResourceTypeJson(type),\n        std::move(resource_response), std::move(maybe_frame_id));\n  }\n  if (is_not_modified && cached_resource && cached_resource->EncodedSize())\n    DidReceiveData(identifier, loader, 0, cached_resource->EncodedSize());\n}\n", "target": 1, "flaw_line_index": "15,16"}
{"idx": 7746, "func": "  TT_Set_Var_Design( TT_Face    face,\n                     FT_UInt    num_coords,\n                     FT_Fixed*  coords )\n  {\n    FT_Error        error      = TT_Err_Ok;\n    FT_Fixed*       normalized = NULL;\n    GX_Blend        blend;\n    FT_MM_Var*      mmvar;\n    FT_UInt         i, j;\n    FT_Var_Axis*    a;\n    GX_AVarSegment  av;\n    FT_Memory       memory = face->root.memory;\n\n\n    if ( face->blend == NULL )\n    {\n      if ( (error = TT_Get_MM_Var( face, NULL )) != 0 )\n        goto Exit;\n    }\n\n    blend = face->blend;\n    mmvar = blend->mmvar;\n\n    if ( num_coords != mmvar->num_axis )\n    {\n      error = TT_Err_Invalid_Argument;\n      goto Exit;\n    }\n\n\n    if ( FT_NEW_ARRAY( normalized, mmvar->num_axis ) )\n      goto Exit;\n\n    a = mmvar->axis;\n    for ( i = 0; i < mmvar->num_axis; ++i, ++a )\n    {\n      if ( coords[i] > a->maximum || coords[i] < a->minimum )\n      {\n        error = TT_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( coords[i] < a->def )\n      {\n        normalized[i] = -FT_MulDiv( coords[i] - a->def,\n                                    0x10000L,\n                                    a->minimum - a->def );\n      }\n      else if ( a->maximum == a->def )\n        normalized[i] = 0;\n      else\n      {\n        normalized[i] = FT_MulDiv( coords[i] - a->def,\n                                   0x10000L,\n                                   a->maximum - a->def );\n      }\n    }\n\n    if ( !blend->avar_checked )\n      ft_var_load_avar( face );\n\n    if ( blend->avar_segment != NULL )\n    {\n      av = blend->avar_segment;\n      for ( i = 0; i < mmvar->num_axis; ++i, ++av )\n      {\n        for ( j = 1; j < (FT_UInt)av->pairCount; ++j )\n          if ( normalized[i] < av->correspondence[j].fromCoord )\n          {\n            normalized[i] =\n              FT_MulDiv(\n                FT_MulDiv(\n                  normalized[i] - av->correspondence[j - 1].fromCoord,\n                  0x10000L,\n                  av->correspondence[j].fromCoord -\n                    av->correspondence[j - 1].fromCoord ),\n                av->correspondence[j].toCoord -\n                  av->correspondence[j - 1].toCoord,\n                0x10000L ) +\n              av->correspondence[j - 1].toCoord;\n            break;\n          }\n      }\n    }\n\n    error = TT_Set_MM_Blend( face, num_coords, normalized );\n\n  Exit:\n    FT_FREE( normalized );\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8216, "func": "static void v9fs_fs_ro(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    pdu_complete(pdu, -EROFS);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187128, "func": "MediaElementAudioSourceHandler::MediaElementAudioSourceHandler(\n    AudioNode& node,\n    HTMLMediaElement& media_element)\n    : AudioHandler(kNodeTypeMediaElementAudioSource,\n                   node,\n                   node.context()->sampleRate()),\n       media_element_(media_element),\n       source_number_of_channels_(0),\n       source_sample_rate_(0),\n      passes_current_src_cors_access_check_(\n          PassesCurrentSrcCORSAccessCheck(media_element.currentSrc())),\n      maybe_print_cors_message_(!passes_current_src_cors_access_check_),\n      current_src_string_(media_element.currentSrc().GetString()) {\n   DCHECK(IsMainThread());\n  AddOutput(2);\n\n  if (Context()->GetExecutionContext()) {\n    task_runner_ = Context()->GetExecutionContext()->GetTaskRunner(\n        TaskType::kMediaElementEvent);\n  }\n\n  Initialize();\n}\n", "target": 1, "flaw_line_index": "10,11,12,13"}
{"idx": 186736, "func": " NetworkHandler::NetworkHandler(const std::string& host_id)\n     : DevToolsDomainHandler(Network::Metainfo::domainName),\n      process_(nullptr),\n       host_(nullptr),\n       enabled_(false),\n       host_id_(host_id),\n      bypass_service_worker_(false),\n      cache_disabled_(false),\n      weak_factory_(this) {\n  static bool have_configured_service_worker_context = false;\n  if (have_configured_service_worker_context)\n    return;\n  have_configured_service_worker_context = true;\n  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                          base::BindOnce(&ConfigureServiceWorkerContextOnIO));\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186635, "func": "void GLES2DecoderImpl::GetTexParameterImpl(\n    GLenum target, GLenum pname, GLfloat* fparams, GLint* iparams,\n    const char* function_name) {\n  TextureRef* texture_ref = texture_manager()->GetTextureInfoForTarget(\n      &state_, target);\n  if (!texture_ref) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"unknown texture for target\");\n    return;\n  }\n  Texture* texture = texture_ref->texture();\n  switch (pname) {\n    case GL_TEXTURE_MAX_ANISOTROPY_EXT:\n      if (workarounds().init_texture_max_anisotropy) {\n        texture->InitTextureMaxAnisotropyIfNeeded(target);\n      }\n      break;\n    case GL_TEXTURE_IMMUTABLE_LEVELS:\n      if (gl_version_info().IsLowerThanGL(4, 2)) {\n        GLint levels = texture->GetImmutableLevels();\n        if (fparams) {\n          fparams[0] = static_cast<GLfloat>(levels);\n        } else {\n          iparams[0] = levels;\n        }\n         return;\n       }\n       break;\n      if (workarounds().use_shadowed_tex_level_params) {\n        if (fparams) {\n          fparams[0] = static_cast<GLfloat>(texture->base_level());\n        } else {\n          iparams[0] = texture->base_level();\n        }\n        return;\n       }\n      break;\n     case GL_TEXTURE_MAX_LEVEL:\n      if (workarounds().use_shadowed_tex_level_params) {\n        if (fparams) {\n          fparams[0] = static_cast<GLfloat>(texture->max_level());\n        } else {\n          iparams[0] = texture->max_level();\n        }\n        return;\n       }\n      break;\n     case GL_TEXTURE_SWIZZLE_R:\n       if (fparams) {\n         fparams[0] = static_cast<GLfloat>(texture->swizzle_r());\n      } else {\n        iparams[0] = texture->swizzle_r();\n      }\n      return;\n    case GL_TEXTURE_SWIZZLE_G:\n      if (fparams) {\n        fparams[0] = static_cast<GLfloat>(texture->swizzle_g());\n      } else {\n        iparams[0] = texture->swizzle_g();\n      }\n      return;\n    case GL_TEXTURE_SWIZZLE_B:\n      if (fparams) {\n        fparams[0] = static_cast<GLfloat>(texture->swizzle_b());\n      } else {\n        iparams[0] = texture->swizzle_b();\n      }\n      return;\n    case GL_TEXTURE_SWIZZLE_A:\n      if (fparams) {\n        fparams[0] = static_cast<GLfloat>(texture->swizzle_a());\n      } else {\n        iparams[0] = texture->swizzle_a();\n      }\n      return;\n    default:\n      break;\n  }\n  if (fparams) {\n    api()->glGetTexParameterfvFn(target, pname, fparams);\n  } else {\n    api()->glGetTexParameterivFn(target, pname, iparams);\n  }\n}\n", "target": 1, "flaw_line_index": "29,30,31,33,34,35,36,37,38,39,41,43,44,45,46,47,48,49,51"}
{"idx": 8023, "func": "static void vnc_dpy_switch(DisplayChangeListener *dcl,\n                           DisplaySurface *surface)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs;\n    int width, height;\n\n    vnc_abort_display_jobs(vd);\n\n    qemu_pixman_image_unref(vd->server);\n    vd->ds = surface;\n    width = MIN(VNC_MAX_WIDTH, ROUND_UP(surface_width(vd->ds),\n                                        VNC_DIRTY_PIXELS_PER_BIT));\n    height = MIN(VNC_MAX_HEIGHT, surface_height(vd->ds));\n    vd->server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,\n                                          width, height, NULL, 0);\n\n#if 0 \n    if (ds_get_bytes_per_pixel(ds) != vd->guest.ds->pf.bytes_per_pixel)\n        console_color_init(ds);\n#endif\n    qemu_pixman_image_unref(vd->guest.fb);\n    vd->guest.fb = pixman_image_ref(surface->image);\n    vd->guest.format = surface->format;\n    memset(vd->guest.dirty, 0x00, sizeof(vd->guest.dirty));\n    vnc_set_area_dirty(vd->guest.dirty, width, height, 0, 0,\n                       width, height);\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_colordepth(vs);\n        vnc_desktop_resize(vs);\n        if (vs->vd->cursor) {\n            vnc_cursor_define(vs);\n        }\n        memset(vs->dirty, 0x00, sizeof(vs->dirty));\n        vnc_set_area_dirty(vs->dirty, width, height, 0, 0,\n                           width, height);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8246, "func": "static void virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187318, "func": " exsltStrPaddingFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n    int number, str_len = 0;\n    xmlChar *str = NULL, *ret = NULL, *tmp;\n \n     if ((nargs < 1) || (nargs > 2)) {\n \txmlXPathSetArityError(ctxt);\n\treturn;\n    }\n\n     if (nargs == 2) {\n \tstr = xmlXPathPopString(ctxt);\n \tstr_len = xmlUTF8Strlen(str);\n     }\n     if (str_len == 0) {\n \tif (str != NULL) xmlFree(str);\n \tstr = xmlStrdup((const xmlChar *) \" \");\n \tstr_len = 1;\n     }\n \n     number = (int) xmlXPathPopNumber(ctxt);\n\n    if (number <= 0) {\n\txmlXPathReturnEmptyString(ctxt);\n\txmlFree(str);\n\treturn;\n     }\n \n     while (number >= str_len) {\n\tret = xmlStrncat(ret, str, str_len);\n \tnumber -= str_len;\n     }\n    tmp = xmlUTF8Strndup (str, number);\n    ret = xmlStrcat(ret, tmp);\n    if (tmp != NULL)\n\txmlFree (tmp);\n \n     xmlXPathReturnString(ctxt, ret);\n \n    if (str != NULL)\n\txmlFree(str);\n}\n", "target": 1, "flaw_line_index": "2,3,29,32,33,34,35"}
{"idx": 186686, "func": "Address LargeObjectArena::doAllocateLargeObjectPage(size_t allocationSize,\n                                                    size_t gcInfoIndex) {\n  size_t largeObjectSize = LargeObjectPage::pageHeaderSize() + allocationSize;\n#if defined(ADDRESS_SANITIZER)\n  largeObjectSize += allocationGranularity;\n#endif\n\n  getThreadState()->shouldFlushHeapDoesNotContainCache();\n  PageMemory* pageMemory = PageMemory::allocate(\n      largeObjectSize, getThreadState()->heap().getRegionTree());\n  Address largeObjectAddress = pageMemory->writableStart();\n  Address headerAddress =\n      largeObjectAddress + LargeObjectPage::pageHeaderSize();\n#if DCHECK_IS_ON()\n  for (size_t i = 0; i < largeObjectSize; ++i)\n    ASSERT(!largeObjectAddress[i]);\n#endif\n  ASSERT(gcInfoIndex > 0);\n  HeapObjectHeader* header = new (NotNull, headerAddress)\n      HeapObjectHeader(largeObjectSizeInHeader, gcInfoIndex);\n  Address result = headerAddress + sizeof(*header);\n   ASSERT(!(reinterpret_cast<uintptr_t>(result) & allocationMask));\n   LargeObjectPage* largeObject = new (largeObjectAddress)\n       LargeObjectPage(pageMemory, this, allocationSize);\n  ASSERT(header->checkHeader());\n \n   ASAN_POISON_MEMORY_REGION(header, sizeof(*header));\n  ASAN_POISON_MEMORY_REGION(largeObject->getAddress() + largeObject->size(),\n                            allocationGranularity);\n\n  largeObject->link(&m_firstPage);\n\n  getThreadState()->heap().heapStats().increaseAllocatedSpace(\n      largeObject->size());\n  getThreadState()->increaseAllocatedObjectSize(largeObject->size());\n  return result;\n}\n", "target": 1, "flaw_line_index": "28"}
{"idx": 186541, "func": "void DiceResponseHandler::OnTokenExchangeSuccess(\n    DiceTokenFetcher* token_fetcher,\n    const std::string& refresh_token,\n    bool is_under_advanced_protection) {\n  const std::string& email = token_fetcher->email();\n  const std::string& gaia_id = token_fetcher->gaia_id();\n  if (!CanGetTokenForAccount(gaia_id, email))\n    return;\n  VLOG(1) << \"[Dice] OAuth success for email \" << email;\n  bool should_enable_sync = token_fetcher->should_enable_sync();\n  std::string account_id =\n       account_tracker_service_->SeedAccountInfo(gaia_id, email);\n   account_tracker_service_->SetIsAdvancedProtectionAccount(\n       account_id, is_under_advanced_protection);\n  token_service_->UpdateCredentials(account_id, refresh_token);\n   about_signin_internals_->OnRefreshTokenReceived(\n       base::StringPrintf(\"Successful (%s)\", account_id.c_str()));\n   if (should_enable_sync)\n    token_fetcher->delegate()->EnableSync(account_id);\n\n  DeleteTokenFetcher(token_fetcher);\n}\n", "target": 1, "flaw_line_index": "15"}
{"idx": 186636, "func": "void GLES2DecoderImpl::TexStorageImpl(GLenum target,\n                                      GLsizei levels,\n                                      GLenum internal_format,\n                                      GLsizei width,\n                                      GLsizei height,\n                                      GLsizei depth,\n                                      ContextState::Dimension dimension,\n                                      const char* function_name) {\n  if (levels == 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"levels == 0\");\n    return;\n  }\n  bool is_compressed_format = IsCompressedTextureFormat(internal_format);\n  if (is_compressed_format && target == GL_TEXTURE_3D) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"target invalid for format\");\n    return;\n  }\n  bool is_invalid_texstorage_size = width < 1 || height < 1 || depth < 1;\n  if (!texture_manager()->ValidForTarget(target, 0, width, height, depth) ||\n      is_invalid_texstorage_size ||\n      TextureManager::ComputeMipMapCount(target, width, height, depth) <\n          levels) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_VALUE, function_name, \"dimensions out of range\");\n    return;\n  }\n  TextureRef* texture_ref = texture_manager()->GetTextureInfoForTarget(\n      &state_, target);\n  if (!texture_ref) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"unknown texture for target\");\n    return;\n  }\n  Texture* texture = texture_ref->texture();\n  if (texture->IsAttachedToFramebuffer()) {\n    framebuffer_state_.clear_state_dirty = true;\n  }\n  if (texture->IsImmutable()) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"texture is immutable\");\n    return;\n  }\n\n  GLenum format = TextureManager::ExtractFormatFromStorageFormat(\n      internal_format);\n  GLenum type = TextureManager::ExtractTypeFromStorageFormat(internal_format);\n\n  {\n    GLsizei level_width = width;\n    GLsizei level_height = height;\n    GLsizei level_depth = depth;\n    base::CheckedNumeric<uint32_t> estimated_size(0);\n    PixelStoreParams params;\n    params.alignment = 1;\n    for (int ii = 0; ii < levels; ++ii) {\n      uint32_t size;\n      if (is_compressed_format) {\n        GLsizei level_size;\n        if (!GetCompressedTexSizeInBytes(\n                function_name, level_width, level_height, level_depth,\n                internal_format, &level_size, state_.GetErrorState())) {\n          return;\n        }\n        size = static_cast<uint32_t>(level_size);\n      } else {\n        if (!GLES2Util::ComputeImageDataSizesES3(level_width,\n                                                 level_height,\n                                                 level_depth,\n                                                 format, type,\n                                                 params,\n                                                 &size,\n                                                 nullptr, nullptr,\n                                                 nullptr, nullptr)) {\n          LOCAL_SET_GL_ERROR(\n              GL_OUT_OF_MEMORY, function_name, \"dimensions too large\");\n          return;\n        }\n      }\n      estimated_size += size;\n      level_width = std::max(1, level_width >> 1);\n      level_height = std::max(1, level_height >> 1);\n      if (target == GL_TEXTURE_3D)\n        level_depth = std::max(1, level_depth >> 1);\n    }\n    if (!estimated_size.IsValid()) {\n      LOCAL_SET_GL_ERROR(GL_OUT_OF_MEMORY, function_name, \"out of memory\");\n      return;\n    }\n  }\n\n  GLenum compatibility_internal_format =\n      texture_manager()->AdjustTexStorageFormat(feature_info_.get(),\n                                                internal_format);\n\n  const CompressedFormatInfo* format_info =\n      GetCompressedFormatInfo(internal_format);\n  if (format_info != nullptr && !format_info->support_check(*feature_info_)) {\n     compatibility_internal_format = format_info->decompressed_internal_format;\n   }\n \n  if (workarounds().reset_base_mipmap_level_before_texstorage &&\n      texture->base_level() > 0)\n    api()->glTexParameteriFn(target, GL_TEXTURE_BASE_LEVEL, 0);\n  if (dimension == ContextState::k2D) {\n    api()->glTexStorage2DEXTFn(target, levels, compatibility_internal_format,\n                               width, height);\n  } else {\n    api()->glTexStorage3DFn(target, levels, compatibility_internal_format,\n                            width, height, depth);\n  }\n  if (workarounds().reset_base_mipmap_level_before_texstorage &&\n      texture->base_level() > 0)\n    api()->glTexParameteriFn(target, GL_TEXTURE_BASE_LEVEL,\n                             texture->base_level());\n   {\n     GLsizei level_width = width;\n     GLsizei level_height = height;\n    GLsizei level_depth = depth;\n\n    GLenum adjusted_internal_format =\n        feature_info_->IsWebGL1OrES2Context() ? format : internal_format;\n    for (int ii = 0; ii < levels; ++ii) {\n      if (target == GL_TEXTURE_CUBE_MAP) {\n        for (int jj = 0; jj < 6; ++jj) {\n          GLenum face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + jj;\n          texture_manager()->SetLevelInfo(\n              texture_ref, face, ii, adjusted_internal_format, level_width,\n              level_height, 1, 0, format, type, gfx::Rect());\n        }\n      } else {\n        texture_manager()->SetLevelInfo(\n            texture_ref, target, ii, adjusted_internal_format, level_width,\n            level_height, level_depth, 0, format, type, gfx::Rect());\n      }\n      level_width = std::max(1, level_width >> 1);\n      level_height = std::max(1, level_height >> 1);\n      if (target == GL_TEXTURE_3D)\n        level_depth = std::max(1, level_depth >> 1);\n    }\n     texture->ApplyFormatWorkarounds(feature_info_.get());\n     texture->SetImmutable(true);\n   }\n }\n", "target": 1, "flaw_line_index": "109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125"}
{"idx": 7844, "func": "static inline bool is_zero_range(uint8_t *p, uint64_t size)\n{\n    return buffer_find_nonzero_offset(p, size) == size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187270, "func": "void RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   session->SetRenderer(frame_host_ ? frame_host_->GetProcess()->GetID()\n                                    : ChildProcessHost::kInvalidUniqueID,\n                        frame_host_);\n\n  protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(\n      base::WrapUnique(new protocol::TargetHandler(false \n)));\n  session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n      protocol::TracingHandler::Renderer,\n      frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,\n      GetIOContext())));\n  session->AddHandler(\n      base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n\n  if (EnsureAgent())\n    session->AttachToAgent(agent_ptr_);\n\n  if (sessions().size() == 1) {\n    frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    GrantPolicy();\n#if defined(OS_ANDROID)\n     GetWakeLock()->RequestWakeLock();\n #endif\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7424, "func": "ZEND_API int zend_ts_hash_index_exists(TsHashTable *ht, zend_ulong h)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_index_exists(TS_HASH(ht), h);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7814, "func": "static int h2s_frt_make_resp_data(struct h2s *h2s, struct buffer *buf)\n{\n\tstruct h2c *h2c = h2s->h2c;\n\tstruct h1m *h1m = &h2s->res;\n\tstruct chunk outbuf;\n\tint ret = 0;\n\tint total = 0;\n\tint es_now = 0;\n\tint size = 0;\n\tchar *blk1, *blk2;\n\tint len1, len2;\n\n\tif (h2c_mux_busy(h2c, h2s)) {\n\t\th2s->flags |= H2_SF_BLK_MBUSY;\n\t\tgoto end;\n\t}\n\n\tif (!h2_get_buf(h2c, &h2c->mbuf)) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\tgoto end;\n\t}\n\n new_frame:\n\tif (!buf->o)\n\t\tgoto end;\n\n\tchunk_reset(&outbuf);\n\n\twhile (1) {\n\t\toutbuf.str  = bo_end(h2c->mbuf);\n\t\toutbuf.size = bo_contig_space(h2c->mbuf);\n\t\toutbuf.len = 0;\n\n\t\tif (outbuf.size >= 9 || !buffer_space_wraps(h2c->mbuf))\n\t\t\tbreak;\n\trealign_again:\n\t\tbuffer_slow_realign(h2c->mbuf);\n\t}\n\n\tif (outbuf.size < 9) {\n\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\tgoto end;\n\t}\n\n\tmemcpy(outbuf.str, \"\\x00\\x00\\x00\\x00\\x00\", 5);\n\twrite_n32(outbuf.str + 5, h2s->id); \n\toutbuf.len = 9;\n\n\tswitch (h1m->flags & (H1_MF_CLEN|H1_MF_CHNK)) {\n\tcase 0:           \n\t\tsize = buf->o;\n\t\th1m->curr_len = size;\n\t\tbreak;\n\tcase H1_MF_CLEN:  \n\t\tsize = buf->o;\n\t\tif ((long long)size > h1m->curr_len)\n\t\t\tsize = h1m->curr_len;\n\t\tbreak;\n\tdefault:          \n\t\tif (h1m->state == HTTP_MSG_CHUNK_CRLF) {\n\t\t\tret = h1_skip_chunk_crlf(buf, -buf->o, 0);\n\t\t\tif (!ret)\n\t\t\t\tgoto end;\n\n\t\t\tif (ret < 0) {\n\t\t\t\th1m->err_pos = ret;\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tbo_del(buf, ret);\n\t\t\ttotal += ret;\n\t\t\th1m->state = HTTP_MSG_CHUNK_SIZE;\n\t\t}\n\n\t\tif (h1m->state == HTTP_MSG_CHUNK_SIZE) {\n\t\t\tunsigned int chunk;\n\n\t\t\tret = h1_parse_chunk_size(buf, -buf->o, 0, &chunk);\n\t\t\tif (!ret)\n\t\t\t\tgoto end;\n\n\t\t\tif (ret < 0) {\n\t\t\t\th1m->err_pos = ret;\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tsize = chunk;\n\t\t\th1m->curr_len = chunk;\n\t\t\th1m->body_len += chunk;\n\t\t\tbo_del(buf, ret);\n\t\t\ttotal += ret;\n\t\t\th1m->state = size ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;\n\t\t\tif (!size)\n\t\t\t\tgoto send_empty;\n\t\t}\n\n\t\tsize = h1m->curr_len;\n\t\tbreak;\n\t}\n\n\n\tif (size > buf->o)\n\t\tsize = buf->o;\n\n\tif (size > h2s->mws)\n\t\tsize = h2s->mws;\n\n\tif (size <= 0) {\n\t\th2s->flags |= H2_SF_BLK_SFCTL;\n\t\tgoto end;\n\t}\n\n\tif (h2c->mfs && size > h2c->mfs)\n\t\tsize = h2c->mfs;\n\n\tif (size + 9 > outbuf.size) {\n\t\tif (buffer_space_wraps(h2c->mbuf))\n\t\t\tgoto realign_again;\n\t\tsize = outbuf.size - 9;\n\t}\n\n\tif (size <= 0) {\n\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\tgoto end;\n\t}\n\n\tif (size > h2c->mws)\n\t\tsize = h2c->mws;\n\n\tif (size <= 0) {\n\t\th2s->flags |= H2_SF_BLK_MFCTL;\n\t\tgoto end;\n\t}\n\n\tblk1 = blk2 = NULL; \n\tret = bo_getblk_nc(buf, &blk1, &len1, &blk2, &len2);\n\tif (ret == 1)\n\t\tlen2 = 0;\n\n\tif (!ret || len1 + len2 < size) {\n\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\tgoto end;\n\t}\n\n\tif (len1 + len2 > size) {\n\t\tint sub = len1 + len2 - size;\n\n\t\tif (len2 > sub)\n\t\t\tlen2 -= sub;\n\t\telse {\n\t\t\tsub -= len2;\n\t\t\tlen2 = 0;\n\t\t\tlen1 -= sub;\n\t\t}\n\t}\n\n\tmemcpy(outbuf.str + 9, blk1, len1);\n\tif (len2)\n\t\tmemcpy(outbuf.str + 9 + len1, blk2, len2);\n\n send_empty:\n\tif (((h1m->flags & H1_MF_CLEN) && !(h1m->curr_len - size)) ||\n\t    !h1m->curr_len || h1m->state >= HTTP_MSG_DONE)\n\t\tes_now = 1;\n\n\th2_set_frame_size(outbuf.str, size);\n\n\tif (es_now)\n\t\toutbuf.str[4] |= H2_F_DATA_END_STREAM;\n\n\th2c->mbuf->o += size + 9;\n\th2c->mbuf->p = b_ptr(h2c->mbuf, size + 9);\n\n\tif (size > 0) {\n\t\tbo_del(buf, size);\n\t\ttotal += size;\n\t\th1m->curr_len -= size;\n\t\th2s->mws -= size;\n\t\th2c->mws -= size;\n\n\t\tif (size && !h1m->curr_len && (h1m->flags & H1_MF_CHNK)) {\n\t\t\th1m->state = HTTP_MSG_CHUNK_CRLF;\n\t\t\tgoto new_frame;\n\t\t}\n\t}\n\n\tif (es_now) {\n\t\tif (h2s->st == H2_SS_OPEN)\n\t\t\th2s->st = H2_SS_HLOC;\n\t\telse\n\t\t\th2s_close(h2s);\n\n\t\tif (!(h1m->flags & H1_MF_CHNK)) {\n\t\t\tbo_del(buf, buf->o);\n\n\t\t\th1m->state = HTTP_MSG_DONE;\n\t\t}\n\n\t\th2s->flags |= H2_SF_ES_SENT;\n\t}\n\n end:\n\ttrace(\"[%d] sent simple H2 DATA response (sid=%d) = %d bytes out (%d in, st=%s, ep=%u, es=%s, h2cws=%d h2sws=%d) buf->o=%d\", h2c->st0, h2s->id, size+9, total, h1_msg_state_str(h1m->state), h1m->err_pos, h1_msg_state_str(h1m->err_state), h2c->mws, h2s->mws, buf->o);\n\treturn total;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186895, "func": "void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n    RequestGlobalDumpCallback callback) {\n  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n  coordinator->GetVmRegionsForHeapProfiler(callback);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 7438, "func": "ZEND_API int _zend_ts_hash_quick_add_or_update(TsHashTable *ht, char *arKey, uint nKeyLength, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = _zend_hash_quick_add_or_update(TS_HASH(ht), arKey, nKeyLength, h, pData, nDataSize, pDest, flag ZEND_FILE_LINE_RELAY_CC);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186316, "func": " bool MediaControlsProgressView::OnMousePressed(const ui::MouseEvent& event) {\n  gfx::Point location_in_bar(event.location());\n  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);\n  if (!event.IsOnlyLeftMouseButton() ||\n      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {\n     return false;\n   }\n \n  HandleSeeking(location_in_bar);\n   return true;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,9"}
{"idx": 7621, "func": "static void unmap_linear_vram(CirrusVGAState *s)\n{\n    if (s->bustype == CIRRUS_BUSTYPE_PCI && s->linear_vram) {\n        s->linear_vram = false;\n        memory_region_del_subregion(&s->pci_bar, &s->vga.vram);\n    }\n    memory_region_set_enabled(&s->cirrus_bank[0], false);\n    memory_region_set_enabled(&s->cirrus_bank[1], false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186730, "func": " void NetworkHandler::ClearBrowserCookies(\n     std::unique_ptr<ClearBrowserCookiesCallback> callback) {\n  if (!process_) {\n     callback->sendFailure(Response::InternalError());\n     return;\n   }\n\n  BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(\n           &ClearCookiesOnIO,\n          base::Unretained(\n              process_->GetStoragePartition()->GetURLRequestContext()),\n           std::move(callback)));\n }\n", "target": 1, "flaw_line_index": "3,12,13"}
{"idx": 187216, "func": "static int _hid_get_report_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n{\n\tuint8_t d[MAX_HID_DESCRIPTOR_SIZE];\n\tsize_t i = 0;\n\td[i++] = 0x06; d[i++] = 0xA0; d[i++] = 0xFF;\n\td[i++] = 0x09; d[i++] = 0x01;\n\td[i++] = 0xA1; d[i++] = 0x01;\n\tif (dev->input_report_size) {\n\t\td[i++] = 0x09; d[i++] = 0x01;\n\t\td[i++] = 0x15; d[i++] = 0x00;\n\t\td[i++] = 0x25; d[i++] = 0xFF;\n\t\td[i++] = 0x75; d[i++] = 0x08;\n\t\td[i++] = 0x95; d[i++] = (uint8_t)dev->input_report_size - 1;\n\t\td[i++] = 0x81; d[i++] = 0x00;\n\t}\n\tif (dev->output_report_size) {\n\t\td[i++] = 0x09; d[i++] = 0x02;\n\t\td[i++] = 0x15; d[i++] = 0x00;\n\t\td[i++] = 0x25; d[i++] = 0xFF;\n\t\td[i++] = 0x75; d[i++] = 0x08;\n\t\td[i++] = 0x95; d[i++] = (uint8_t)dev->output_report_size - 1;\n\t\td[i++] = 0x91; d[i++] = 0x00;\n\t}\n\tif (dev->feature_report_size) {\n\t\td[i++] = 0x09; d[i++] = 0x03;\n\t\td[i++] = 0x15; d[i++] = 0x00;\n\t\td[i++] = 0x25; d[i++] = 0xFF;\n\t\td[i++] = 0x75; d[i++] = 0x08;\n\t\td[i++] = 0x95; d[i++] = (uint8_t)dev->feature_report_size - 1;\n\t\td[i++] = 0xb2; d[i++] = 0x02; d[i++] = 0x01;\n\t}\n\td[i++] = 0xC0;\n\tif (*size > i)\n\t\t*size = i;\n\tmemcpy(data, d, *size);\n\treturn LIBUSB_COMPLETED;\n}\n", "target": 1, "flaw_line_index": "2,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,31,31,32,33,34,35,36,37"}
{"idx": 186901, "func": "ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();\n#if BUILDFLAG(USE_ALLOCATOR_SHIM)\n  if (cmdline->HasSwitch(switches::kMemlog) ||\n      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {\n    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {\n      LOG(ERROR) << \"--\" << switches::kEnableHeapProfiling\n                 << \" specified with --\" << switches::kMemlog\n                 << \"which are not compatible. Memlog will be disabled.\";\n      return Mode::kNone;\n    }\n\n    std::string mode;\n    if (cmdline->HasSwitch(switches::kMemlog)) {\n      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);\n    } else {\n      mode = base::GetFieldTrialParamValueByFeature(\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n \n    if (mode == switches::kMemlogModeAll)\n      return Mode::kAll;\n    if (mode == switches::kMemlogModeMinimal)\n      return Mode::kMinimal;\n    if (mode == switches::kMemlogModeBrowser)\n      return Mode::kBrowser;\n    if (mode == switches::kMemlogModeGpu)\n      return Mode::kGpu;\n    if (mode == switches::kMemlogModeRendererSampling)\n      return Mode::kRendererSampling;\n    DLOG(ERROR) << \"Unsupported value: \\\"\" << mode << \"\\\" passed to --\"\n                << switches::kMemlog;\n   }\n   return Mode::kNone;\n #else\n  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))\n      << \"--\" << switches::kMemlog\n      << \" specified but it will have no effect because the use_allocator_shim \"\n      << \"is not available in this build.\";\n  return Mode::kNone;\n #endif\n }\n", "target": 1, "flaw_line_index": "24,25,26,27,28,29,30,31,32,33,34,35"}
{"idx": 8268, "func": "static XRecordInterceptData *alloc_inter_data(XExtDisplayInfo *info)\n{\n    struct mem_cache_str *cache = (struct mem_cache_str *)info->data;\n    struct intercept_queue *iq;\n\n    if (cache->inter_data) {\n\tiq = cache->inter_data;\n\tcache->inter_data = iq->next;\n\treturn &iq->data;\n    }\n    iq = (struct intercept_queue *)Xmalloc(sizeof(struct intercept_queue));\n    if (!iq)\n\treturn NULL;\n    iq->cache = cache;\n    cache->inter_data_count++;\n    return &iq->data;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7973, "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n{\n    char buf[1024];\n    VncShareMode mode;\n    int size;\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n    switch (vs->vd->share_policy) {\n    case VNC_SHARE_POLICY_IGNORE:\n        break;\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            VncState *client;\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n                if (vs == client) {\n                    continue;\n                }\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n                    continue;\n                }\n                vnc_disconnect_start(client);\n            }\n        }\n        if (mode == VNC_SHARE_MODE_SHARED) {\n            if (vs->vd->num_exclusive > 0) {\n                vnc_disconnect_start(vs);\n                return 0;\n            }\n        }\n        break;\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            vnc_disconnect_start(vs);\n            return 0;\n        }\n        break;\n    }\n    vnc_set_share_mode(vs, mode);\n\n    vs->client_width = pixman_image_get_width(vs->vd->server);\n    vs->client_height = pixman_image_get_height(vs->vd->server);\n    vnc_write_u16(vs, vs->client_width);\n    vnc_write_u16(vs, vs->client_height);\n\n    pixel_format_message(vs);\n\n    if (qemu_name)\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n    else\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_flush(vs);\n\n    vnc_client_cache_auth(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187150, "func": "void FetchManager::Loader::Start() {\n\n\n\n\n\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n \n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n\n  PerformHTTPFetch();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187057, "func": " void RenderFrameImpl::OnSelectPopupMenuItems(\n    bool canceled,\n    const std::vector<int>& selected_indices) {\n  if (!external_popup_menu_)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n  external_popup_menu_->DidSelectItems(canceled, selected_indices);\n  external_popup_menu_.reset();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187139, "func": "void NavigationControllerImpl::Reload(ReloadType reload_type,\n                                      bool check_for_repost) {\n  DCHECK_NE(ReloadType::NONE, reload_type);\n\n  if (transient_entry_index_ != -1) {\n    NavigationEntryImpl* transient_entry = GetTransientEntry();\n    if (!transient_entry)\n      return;\n    LoadURL(transient_entry->GetURL(),\n            Referrer(),\n            ui::PAGE_TRANSITION_RELOAD,\n            transient_entry->extra_headers());\n    return;\n  }\n\n  NavigationEntryImpl* entry = nullptr;\n  int current_index = -1;\n\n  if (IsInitialNavigation() && pending_entry_) {\n    entry = pending_entry_;\n    current_index = pending_entry_index_;\n  } else {\n    DiscardNonCommittedEntriesInternal();\n    current_index = GetCurrentEntryIndex();\n    if (current_index != -1) {\n      entry = GetEntryAtIndex(current_index);\n    }\n  }\n\n  if (!entry)\n    return;\n\n  if (last_committed_reload_type_ != ReloadType::NONE) {\n    DCHECK(!last_committed_reload_time_.is_null());\n    base::Time now =\n        time_smoother_.GetSmoothedTime(get_timestamp_callback_.Run());\n    DCHECK_GT(now, last_committed_reload_time_);\n    if (!last_committed_reload_time_.is_null() &&\n        now > last_committed_reload_time_) {\n      base::TimeDelta delta = now - last_committed_reload_time_;\n      UMA_HISTOGRAM_MEDIUM_TIMES(\"Navigation.Reload.ReloadToReloadDuration\",\n                                 delta);\n      if (last_committed_reload_type_ == ReloadType::NORMAL) {\n        UMA_HISTOGRAM_MEDIUM_TIMES(\n            \"Navigation.Reload.ReloadMainResourceToReloadDuration\", delta);\n      }\n    }\n  }\n\n  entry->set_reload_type(reload_type);\n\n  if (g_check_for_repost && check_for_repost &&\n      entry->GetHasPostData()) {\n    delegate_->NotifyBeforeFormRepostWarningShow();\n\n    pending_reload_ = reload_type;\n    delegate_->ActivateAndShowRepostFormWarningDialog();\n  } else {\n    if (!IsInitialNavigation())\n      DiscardNonCommittedEntriesInternal();\n\n    SiteInstanceImpl* site_instance = entry->site_instance();\n    bool is_for_guests_only = site_instance && site_instance->HasProcess() &&\n        site_instance->GetProcess()->IsForGuestsOnly();\n    if (!is_for_guests_only && site_instance &&\n        site_instance->HasWrongProcessForURL(entry->GetURL())) {\n      NavigationEntryImpl* nav_entry = NavigationEntryImpl::FromNavigationEntry(\n          CreateNavigationEntry(entry->GetURL(), entry->GetReferrer(),\n                                entry->GetTransitionType(), false,\n                                entry->extra_headers(), browser_context_,\n                                nullptr \n)\n              .release());\n\n       reload_type = ReloadType::NONE;\n \n       nav_entry->set_should_replace_entry(true);\n       pending_entry_ = nav_entry;\n       DCHECK_EQ(-1, pending_entry_index_);\n     } else {\n      pending_entry_ = entry;\n      pending_entry_index_ = current_index;\n\n      pending_entry_->SetTransitionType(ui::PAGE_TRANSITION_RELOAD);\n    }\n\n    NavigateToPendingEntry(reload_type, nullptr \n);\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186749, "func": "StorageHandler::IndexedDBObserver* StorageHandler::GetIndexedDBObserver() {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (!indexed_db_observer_) {\n     indexed_db_observer_ = std::make_unique<IndexedDBObserver>(\n         weak_ptr_factory_.GetWeakPtr(),\n         static_cast<IndexedDBContextImpl*>(\n            process_->GetStoragePartition()->GetIndexedDBContext()));\n   }\n   return indexed_db_observer_.get();\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 7846, "func": "int kvm_available(void)\n{\n#ifdef CONFIG_KVM\n    return 1;\n#else\n    return 0;\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7631, "func": "static int proxy_ioc_getversion(FsContext *fs_ctx, V9fsPath *path,\n                                mode_t st_mode, uint64_t *st_gen)\n{\n    int err;\n\n    if (!S_ISREG(st_mode) && !S_ISDIR(st_mode)) {\n        errno = ENOTTY;\n        return -1;\n    }\n    err = v9fs_request(fs_ctx->private, T_GETVERSION, st_gen, path);\n    if (err < 0) {\n        errno = -err;\n        err = -1;\n    }\n    return err;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186319, "func": "void DatabaseImpl::IDBThreadHelper::CreateTransaction(\n    int64_t transaction_id,\n    const std::vector<int64_t>& object_store_ids,\n    blink::WebIDBTransactionMode mode) {\n  DCHECK(idb_thread_checker_.CalledOnValidThread());\n   if (!connection_->IsConnected())\n     return;\n \n   connection_->database()->CreateTransaction(transaction_id, connection_.get(),\n                                              object_store_ids, mode);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8272, "func": "XRenderCloseDisplay (Display *dpy, XExtCodes *codes)\n{\n    XRenderExtDisplayInfo *info = XRenderFindDisplay (dpy);\n    if (info && info->info) XFree (info->info);\n\n    return XRenderExtRemoveDisplay (&XRenderExtensionInfo, dpy);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8174, "func": "void Gfx::opXObject(Object args[], int numArgs) {\n  char *name;\n  Object obj1, obj2, obj3, refObj;\n#if OPI_SUPPORT\n  Object opiDict;\n#endif\n\n  name = args[0].getName();\n  if (!res->lookupXObject(name, &obj1)) {\n    return;\n  }\n  if (!obj1.isStream()) {\n    error(getPos(), \"XObject '%s' is wrong type\", name);\n    obj1.free();\n    return;\n  }\n\n  obj1.streamGetDict()->lookupNF(\"OC\", &obj2);\n  if (obj2.isNull()) {\n  } else if (obj2.isRef()) {\n    if ( catalog->getOptContentConfig() && ! catalog->getOptContentConfig()->optContentIsVisible( &obj2 ) ) {\n      obj2.free();\n      obj1.free();\n      return;\n    }\n  } else {\n    error(getPos(), \"XObject OC value not null or dict: %i\", obj2.getType());\n  }\n  obj2.free();\n\n#if OPI_SUPPORT\n  obj1.streamGetDict()->lookup(\"OPI\", &opiDict);\n  if (opiDict.isDict()) {\n    out->opiBegin(state, opiDict.getDict());\n  }\n#endif\n  obj1.streamGetDict()->lookup(\"Subtype\", &obj2);\n  if (obj2.isName(\"Image\")) {\n    if (out->needNonText()) {\n      res->lookupXObjectNF(name, &refObj);\n      doImage(&refObj, obj1.getStream(), gFalse);\n      refObj.free();\n    }\n  } else if (obj2.isName(\"Form\")) {\n    res->lookupXObjectNF(name, &refObj);\n    if (out->useDrawForm() && refObj.isRef()) {\n      out->drawForm(refObj.getRef());\n    } else {\n      doForm(&obj1);\n    }\n    refObj.free();\n  } else if (obj2.isName(\"PS\")) {\n    obj1.streamGetDict()->lookup(\"Level1\", &obj3);\n    out->psXObject(obj1.getStream(),\n\t\t   obj3.isStream() ? obj3.getStream() : (Stream *)NULL);\n  } else if (obj2.isName()) {\n    error(getPos(), \"Unknown XObject subtype '%s'\", obj2.getName());\n  } else {\n    error(getPos(), \"XObject subtype is missing or wrong type\");\n  }\n  obj2.free();\n#if OPI_SUPPORT\n  if (opiDict.isDict()) {\n    out->opiEnd(state, opiDict.getDict());\n  }\n  opiDict.free();\n#endif\n  obj1.free();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186511, "func": " SendTabToSelfInfoBarDelegate::SendTabToSelfInfoBarDelegate(\n     const SendTabToSelfEntry* entry) {\n   entry_ = entry;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186963, "func": "  void FailStoreGroup() {\n     PushNextTask(base::BindOnce(&AppCacheStorageImplTest::Verify_FailStoreGroup,\n                                 base::Unretained(this)));\n \n     const int64_t kTooBig = 10 * 1024 * 1024;  \n     group_ =\n         new AppCacheGroup(storage(), kManifestUrl, storage()->NewGroupId());\n     cache_ = new AppCache(storage(), storage()->NewCacheId());\n    cache_->AddEntry(kManifestUrl,\n                     AppCacheEntry(AppCacheEntry::MANIFEST, 1, kTooBig));\n \n    storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());\n    EXPECT_FALSE(delegate()->stored_group_success_);  \n  }\n", "target": 1, "flaw_line_index": "6,12,13,14"}
{"idx": 186783, "func": " bool VaapiVideoDecodeAccelerator::VaapiVP9Accelerator::OutputPicture(\n     const scoped_refptr<VP9Picture>& pic) {\n   scoped_refptr<VaapiDecodeSurface> dec_surface =\n       VP9PictureToVaapiDecodeSurface(pic);\n   dec_surface->set_visible_rect(pic->visible_rect);\n  vaapi_dec_->SurfaceReady(dec_surface);\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8024, "func": "static void vnc_dpy_update(DisplayChangeListener *dcl,\n                           int x, int y, int w, int h)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    struct VncSurface *s = &vd->guest;\n    int width = pixman_image_get_width(vd->server);\n    int height = pixman_image_get_height(vd->server);\n\n    vnc_set_area_dirty(s->dirty, width, height, x, y, w, h);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186406, "func": "void PageInfo::PresentSiteIdentity() {\n  DCHECK_NE(site_identity_status_, SITE_IDENTITY_STATUS_UNKNOWN);\n  DCHECK_NE(site_connection_status_, SITE_CONNECTION_STATUS_UNKNOWN);\n  PageInfoUI::IdentityInfo info;\n  if (site_identity_status_ == SITE_IDENTITY_STATUS_EV_CERT)\n    info.site_identity = UTF16ToUTF8(organization_name());\n  else\n    info.site_identity = UTF16ToUTF8(GetSimpleSiteName(site_url_));\n\n   info.connection_status = site_connection_status_;\n   info.connection_status_description = UTF16ToUTF8(site_connection_details_);\n   info.identity_status = site_identity_status_;\n  info.safe_browsing_status = safe_browsing_status_;\n  info.identity_status_description = UTF16ToUTF8(site_details_message_);\n   info.certificate = certificate_;\n   info.show_ssl_decision_revoke_button = show_ssl_decision_revoke_button_;\n   info.show_change_password_buttons = show_change_password_buttons_;\n  ui_->SetIdentityInfo(info);\n}\n", "target": 1, "flaw_line_index": "15,16"}
{"idx": 186630, "func": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  \n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  \n    }\n\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186345, "func": "void PreconnectManager::Start(const GURL& url,\n                              std::vector<PreconnectRequest> requests) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  const std::string host = url.host();\n  if (preresolve_info_.find(host) != preresolve_info_.end())\n    return;\n\n  auto iterator_and_whether_inserted = preresolve_info_.emplace(\n      host, std::make_unique<PreresolveInfo>(url, requests.size()));\n  PreresolveInfo* info = iterator_and_whether_inserted.first->second.get();\n \n   for (auto request_it = requests.begin(); request_it != requests.end();\n        ++request_it) {\n    DCHECK(request_it->origin.GetOrigin() == request_it->origin);\n     PreresolveJobId job_id = preresolve_jobs_.Add(\n         std::make_unique<PreresolveJob>(std::move(*request_it), info));\n     queued_jobs_.push_back(job_id);\n  }\n\n  TryToLaunchPreresolveJobs();\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 187071, "func": " void PaymentRequest::Show(bool is_user_gesture) {\n  if (!client_.is_bound() || !binding_.is_bound()) {\n    LOG(ERROR) << \"Attempted Show(), but binding(s) missing.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n   display_handle_ = display_manager_->TryShow(delegate_.get());\n   if (!display_handle_) {\n    LOG(ERROR) << \"A PaymentRequest UI is already showing\";\n     journey_logger_.SetNotShown(\n         JourneyLogger::NOT_SHOWN_REASON_CONCURRENT_REQUESTS);\n     client_->OnError(mojom::PaymentErrorReason::ALREADY_SHOWING);\n    OnConnectionTerminated();\n    return;\n   }\n \n   if (!delegate_->IsBrowserWindowActive()) {\n    LOG(ERROR) << \"Cannot show PaymentRequest UI in a background tab\";\n     journey_logger_.SetNotShown(JourneyLogger::NOT_SHOWN_REASON_OTHER);\n     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (!state_) {\n     AreRequestedMethodsSupportedCallback(false);\n     return;\n   }\n\n  is_show_user_gesture_ = is_user_gesture;\n\n  display_handle_->Show(this);\n\n  state_->AreRequestedMethodsSupported(\n      base::BindOnce(&PaymentRequest::AreRequestedMethodsSupportedCallback,\n                     weak_ptr_factory_.GetWeakPtr()));\n }\n", "target": 1, "flaw_line_index": "2,3,11,20,28"}
{"idx": 186425, "func": "std::string SanitizeEndpoint(const std::string& value) {\n  if (value.find('&') != std::string::npos\n      || value.find('?') != std::string::npos)\n    return std::string();\n  return value;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7541, "func": "isdst_differ (int a, int b)\n{\n  return !a != !b && 0 <= a && 0 <= b;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186500, "func": " error::Error GLES2DecoderPassthroughImpl::ProcessQueries(bool did_finish) {\n   while (!pending_queries_.empty()) {\n    const PendingQuery& query = pending_queries_.front();\n     GLuint result_available = GL_FALSE;\n     GLuint64 result = 0;\n     switch (query.target) {\n      case GL_COMMANDS_COMPLETED_CHROMIUM:\n        DCHECK(query.commands_completed_fence != nullptr);\n        result_available =\n            did_finish || query.commands_completed_fence->HasCompleted();\n        result = result_available;\n        break;\n\n      case GL_COMMANDS_ISSUED_CHROMIUM:\n        result_available = GL_TRUE;\n        result = GL_TRUE;\n        break;\n\n      case GL_LATENCY_QUERY_CHROMIUM:\n        result_available = GL_TRUE;\n        result = (base::TimeTicks::Now() - base::TimeTicks()).InMilliseconds();\n        break;\n\n      case GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM:\n        result_available = GL_TRUE;\n        result = GL_TRUE;\n        for (const PendingReadPixels& pending_read_pixels :\n             pending_read_pixels_) {\n          if (pending_read_pixels.waiting_async_pack_queries.count(\n                  query.service_id) > 0) {\n            DCHECK(!did_finish);\n            result_available = GL_FALSE;\n            result = GL_FALSE;\n            break;\n          }\n        }\n        break;\n\n      case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n        DCHECK(query.buffer_shadow_update_fence);\n        if (did_finish || query.buffer_shadow_update_fence->HasCompleted()) {\n          ReadBackBuffersIntoShadowCopies(query.buffer_shadow_updates);\n          result_available = GL_TRUE;\n          result = 0;\n        }\n        break;\n\n      case GL_GET_ERROR_QUERY_CHROMIUM:\n        result_available = GL_TRUE;\n        FlushErrors();\n         result = PopError();\n         break;\n \n       default:\n         DCHECK(!IsEmulatedQueryTarget(query.target));\n         if (did_finish) {\n          result_available = GL_TRUE;\n        } else {\n          api()->glGetQueryObjectuivFn(\n              query.service_id, GL_QUERY_RESULT_AVAILABLE, &result_available);\n        }\n        if (result_available == GL_TRUE) {\n          if (feature_info_->feature_flags().ext_disjoint_timer_query) {\n            api()->glGetQueryObjectui64vFn(query.service_id, GL_QUERY_RESULT,\n                                           &result);\n          } else {\n            GLuint temp_result = 0;\n            api()->glGetQueryObjectuivFn(query.service_id, GL_QUERY_RESULT,\n                                         &temp_result);\n            result = temp_result;\n          }\n        }\n        break;\n    }\n\n    if (!result_available) {\n      break;\n    }\n\n    query.sync->result = result;\n    base::subtle::Release_Store(&query.sync->process_count, query.submit_count);\n    pending_queries_.pop_front();\n  }\n \n  DCHECK(!did_finish || pending_queries_.empty());\n   return error::kNoError;\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7528, "func": "  tt_name_ascii_from_other( TT_Name    entry,\n                            FT_Memory  memory )\n  {\n    FT_String*  string = NULL;\n    FT_UInt     len, code, n;\n    FT_Byte*    read   = (FT_Byte*)entry->string;\n    FT_Error    error;\n\n\n    len = (FT_UInt)entry->stringLength;\n\n    if ( FT_NEW_ARRAY( string, len + 1 ) )\n      return NULL;\n\n    for ( n = 0; n < len; n++ )\n    {\n      code = *read++;\n\n      if ( code == 0 )\n        break;\n\n      if ( code < 32 || code > 127 )\n        code = '?';\n\n      string[n] = (char)code;\n    }\n\n    string[n] = 0;\n\n    return string;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7633, "func": "static ssize_t proxy_llistxattr(FsContext *ctx, V9fsPath *fs_path,\n                                void *value, size_t size)\n{\n    int retval;\n    retval = v9fs_request(ctx->private, T_LLISTXATTR, value, size, fs_path);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7656, "func": "static int proxy_utimensat(FsContext *s, V9fsPath *fs_path,\n                           const struct timespec *buf)\n{\n    int retval;\n    retval = v9fs_request(s->private, T_UTIME, NULL, fs_path,\n                          buf[0].tv_sec, buf[0].tv_nsec,\n                          buf[1].tv_sec, buf[1].tv_nsec);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187089, "func": " void MediaStreamManager::OpenDevice(int render_process_id,\n                                     int render_frame_id,\n                                     int page_request_id,\n                                     const std::string& device_id,\n                                     MediaStreamType type,\n                                    MediaDeviceSaltAndOrigin salt_and_origin,\n                                    OpenDeviceCallback open_device_cb,\n                                    DeviceStoppedCallback device_stopped_cb) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DCHECK(type == MEDIA_DEVICE_AUDIO_CAPTURE ||\n         type == MEDIA_DEVICE_VIDEO_CAPTURE);\n  DVLOG(1) << \"OpenDevice ({page_request_id = \" << page_request_id << \"})\";\n  StreamControls controls;\n  if (IsAudioInputMediaType(type)) {\n    controls.audio.requested = true;\n    controls.audio.stream_type = type;\n    controls.audio.device_id = device_id;\n  } else if (IsVideoInputMediaType(type)) {\n    controls.video.requested = true;\n    controls.video.stream_type = type;\n    controls.video.device_id = device_id;\n  } else {\n     NOTREACHED();\n   }\n   DeviceRequest* request = new DeviceRequest(\n      render_process_id, render_frame_id, page_request_id,\n       false \n, MEDIA_OPEN_DEVICE_PEPPER_ONLY, controls,\n       std::move(salt_and_origin), std::move(device_stopped_cb));\n \n  const std::string& label = AddRequest(request);\n\n  request->open_device_cb = std::move(open_device_cb);\n  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},\n                           base::BindOnce(&MediaStreamManager::SetUpRequest,\n                                          base::Unretained(this), label));\n}\n", "target": 1, "flaw_line_index": "26"}
{"idx": 8176, "func": "void Gfx::popResources() {\n  GfxResources *resPtr;\n\n  resPtr = res->getNext();\n  delete res;\n  res = resPtr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187284, "func": " FileStream::FileStream(const scoped_refptr<base::TaskRunner>& task_runner)\n    : context_(base::MakeUnique<Context>(task_runner)) {}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8162, "func": "void Gfx::opSetTextLeading(Object args[], int numArgs) {\n  state->setLeading(args[0].getNum());\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187129, "func": "void MediaElementAudioSourceHandler::OnCurrentSrcChanged(\n    const KURL& current_src) {\n  DCHECK(IsMainThread());\n  Locker<MediaElementAudioSourceHandler> locker(*this);\n \n  passes_current_src_cors_access_check_ =\n      PassesCurrentSrcCORSAccessCheck(current_src);\n \n  maybe_print_cors_message_ = !passes_current_src_cors_access_check_;\n  current_src_string_ = current_src.GetString();\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,7,8,10,11,12"}
{"idx": 7946, "func": "static js_Ast *returntarget(JF, js_Ast *node)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\treturn node;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7533, "func": "  sfnt_open_font( FT_Stream  stream,\n                  TT_Face    face )\n  {\n    FT_Memory  memory = stream->memory;\n    FT_Error   error;\n    FT_ULong   tag, offset;\n\n    static const FT_Frame_Field  ttc_header_fields[] =\n    {\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  TTC_HeaderRec\n\n      FT_FRAME_START( 8 ),\n        FT_FRAME_LONG( version ),\n        FT_FRAME_LONG( count   ),  \n      FT_FRAME_END\n    };\n\n\n    face->ttc_header.tag     = 0;\n    face->ttc_header.version = 0;\n    face->ttc_header.count   = 0;\n\n  retry:\n    offset = FT_STREAM_POS();\n\n    if ( FT_READ_ULONG( tag ) )\n      return error;\n\n    if ( tag == TTAG_wOFF )\n    {\n      FT_TRACE2(( \"sfnt_open_font: file is a WOFF; synthesizing SFNT\\n\" ));\n\n      if ( FT_STREAM_SEEK( offset ) )\n        return error;\n\n      error = woff_open_font( stream, face );\n      if ( error )\n        return error;\n\n      stream = face->root.stream;\n      goto retry;\n    }\n\n    if ( tag != 0x00010000UL &&\n         tag != TTAG_ttcf    &&\n         tag != TTAG_OTTO    &&\n         tag != TTAG_true    &&\n         tag != TTAG_typ1    &&\n         tag != 0x00020000UL )\n    {\n      FT_TRACE2(( \"  not a font using the SFNT container format\\n\" ));\n      return FT_THROW( Unknown_File_Format );\n    }\n\n    face->ttc_header.tag = TTAG_ttcf;\n\n    if ( tag == TTAG_ttcf )\n    {\n      FT_Int  n;\n\n\n      FT_TRACE3(( \"sfnt_open_font: file is a collection\\n\" ));\n\n      if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &face->ttc_header ) )\n        return error;\n\n      FT_TRACE3(( \"                with %ld subfonts\\n\",\n                  face->ttc_header.count ));\n\n      if ( face->ttc_header.count == 0 )\n        return FT_THROW( Invalid_Table );\n\n      if ( (FT_ULong)face->ttc_header.count > stream->size / ( 28 + 4 ) )\n        return FT_THROW( Array_Too_Large );\n\n      if ( FT_NEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) )\n        return error;\n\n      if ( FT_FRAME_ENTER( face->ttc_header.count * 4L ) )\n        return error;\n\n      for ( n = 0; n < face->ttc_header.count; n++ )\n        face->ttc_header.offsets[n] = FT_GET_ULONG();\n\n      FT_FRAME_EXIT();\n    }\n    else\n    {\n      FT_TRACE3(( \"sfnt_open_font: synthesize TTC\\n\" ));\n\n      face->ttc_header.version = 1 << 16;\n      face->ttc_header.count   = 1;\n\n      if ( FT_NEW( face->ttc_header.offsets ) )\n        return error;\n\n      face->ttc_header.offsets[0] = offset;\n    }\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8074, "func": "void Gfx::doEndPath() {\n  if (state->isCurPt() && clip != clipNone) {\n    state->clip();\n    if (clip == clipNormal) {\n      out->clip(state);\n    } else {\n      out->eoClip(state);\n    }\n  }\n  clip = clipNone;\n  state->clearPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8254, "func": "Status _xvmc_create_surface (\n    Display *dpy,\n    XvMCContext *context,\n    XvMCSurface *surface,\n    int *priv_count,\n    CARD32 **priv_data\n)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcCreateSurfaceReply rep;\n    xvmcCreateSurfaceReq  *req;\n\n    *priv_count = 0;\n    *priv_data = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (CreateSurface, req);\n\n    surface->surface_id = XAllocID(dpy);\n    surface->context_id = context->context_id;\n    surface->surface_type_id = context->surface_type_id;\n    surface->width = context->width;\n    surface->height = context->height;\n\n    req->surface_id = surface->surface_id;\n    req->context_id = surface->context_id;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n        return BadImplementation;\n    }\n\n    if(rep.length) {\n        if (rep.length < (INT_MAX >> 2))\n            *priv_data = Xmalloc(rep.length << 2);\n        if(*priv_data) {\n            _XRead(dpy, (char*)(*priv_data), rep.length << 2);\n            *priv_count = rep.length;\n        } else\n            _XEatDataWords(dpy, rep.length);\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return Success;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186798, "func": " bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n}\n", "target": 1, "flaw_line_index": "3,4,6"}
{"idx": 8156, "func": "void Gfx::opSetStrokeCMYKColor(Object args[], int numArgs) {\n  GfxColor color;\n  int i;\n\n  state->setStrokePattern(NULL);\n  state->setStrokeColorSpace(new GfxDeviceCMYKColorSpace());\n  out->updateStrokeColorSpace(state);\n  for (i = 0; i < 4; ++i) {\n    color.c[i] = dblToCol(args[i].getNum());\n  }\n  state->setStrokeColor(&color);\n  out->updateStrokeColor(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8010, "func": "static int vnc_cursor_define(VncState *vs)\n{\n    QEMUCursor *c = vs->vd->cursor;\n    int isize;\n\n    if (vnc_has_feature(vs, VNC_FEATURE_RICH_CURSOR)) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs,  VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs,  0);  \n        vnc_write_u16(vs, 1);  \n        vnc_framebuffer_update(vs, c->hot_x, c->hot_y, c->width, c->height,\n                               VNC_ENCODING_RICH_CURSOR);\n        isize = c->width * c->height * vs->client_pf.bytes_per_pixel;\n        vnc_write_pixels_generic(vs, c->data, isize);\n        vnc_write(vs, vs->vd->cursor_mask, vs->vd->cursor_msize);\n        vnc_unlock_output(vs);\n        return 0;\n    }\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187146, "func": " void HTMLMediaElement::MediaLoadingFailed(WebMediaPlayer::NetworkState error,\n                                          const String& message) {\n   BLINK_MEDIA_LOG << \"MediaLoadingFailed(\" << (void*)this << \", \"\n                  << static_cast<int>(error) << \", message='\" << message\n                   << \"')\";\n \n   StopPeriodicTimers();\n \n  if (ready_state_ < kHaveMetadata &&\n      load_state_ == kLoadingFromSourceElement) {\n    if (current_source_node_) {\n      current_source_node_->ScheduleErrorEvent();\n    } else {\n      BLINK_MEDIA_LOG << \"mediaLoadingFailed(\" << (void*)this\n                      << \") - error event not sent, <source> was removed\";\n    }\n\n\n    ForgetResourceSpecificTracks();\n\n    if (HavePotentialSourceChild()) {\n      BLINK_MEDIA_LOG << \"mediaLoadingFailed(\" << (void*)this\n                      << \") - scheduling next <source>\";\n      ScheduleNextSourceChild();\n    } else {\n      BLINK_MEDIA_LOG << \"mediaLoadingFailed(\" << (void*)this\n                      << \") - no more <source> elements, waiting\";\n      WaitForSourceChange();\n    }\n\n    return;\n  }\n\n  if (error == WebMediaPlayer::kNetworkStateNetworkError &&\n      ready_state_ >= kHaveMetadata) {\n    MediaEngineError(MediaError::Create(MediaError::kMediaErrNetwork, message));\n  } else if (error == WebMediaPlayer::kNetworkStateDecodeError) {\n    MediaEngineError(MediaError::Create(MediaError::kMediaErrDecode, message));\n  } else if ((error == WebMediaPlayer::kNetworkStateFormatError ||\n              error == WebMediaPlayer::kNetworkStateNetworkError) &&\n             load_state_ == kLoadingFromSrcAttr) {\n    if (message.IsEmpty()) {\n      NoneSupported(BuildElementErrorMessage(\n          error == WebMediaPlayer::kNetworkStateFormatError ? \"Format error\"\n                                                            : \"Network error\"));\n    } else {\n      NoneSupported(message);\n    }\n  }\n\n  UpdateDisplayState();\n}\n", "target": 1, "flaw_line_index": "2,4"}
{"idx": 7943, "func": "static int listlength(js_Ast *list)\n{\n\tint n = 0;\n\twhile (list) ++n, list = list->b;\n\treturn n;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186883, "func": "void BaseRenderingContext2D::Reset() {\n  ValidateStateStack();\n  UnwindStateStack();\n  state_stack_.resize(1);\n  state_stack_.front() = CanvasRenderingContext2DState::Create();\n  path_.Clear();\n  if (PaintCanvas* c = ExistingDrawingCanvas()) {\n    DCHECK_EQ(c->getSaveCount(), 2);\n    c->restore();\n    c->save();\n    DCHECK(c->getTotalMatrix().isIdentity());\n#if DCHECK_IS_ON()\n    SkIRect clip_bounds;\n    DCHECK(c->getDeviceClipBounds(&clip_bounds));\n    DCHECK(clip_bounds == c->imageInfo().bounds());\n #endif\n   }\n   ValidateStateStack();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186433, "func": "void InspectorNetworkAgent::DidBlockRequest(\n    ExecutionContext* execution_context,\n     const ResourceRequest& request,\n     DocumentLoader* loader,\n     const FetchInitiatorInfo& initiator_info,\n    ResourceRequestBlockedReason reason) {\n   unsigned long identifier = CreateUniqueIdentifier();\n   WillSendRequestInternal(execution_context, identifier, loader, request,\n                          ResourceResponse(), initiator_info);\n \n   String request_id = IdentifiersFactory::RequestId(identifier);\n   String protocol_reason = BuildBlockedReason(reason);\n  GetFrontend()->loadingFailed(\n      request_id, MonotonicallyIncreasingTime(),\n      InspectorPageAgent::ResourceTypeJson(\n          resources_data_->GetResourceType(request_id)),\n      String(), false, protocol_reason);\n}\n", "target": 1, "flaw_line_index": "6,9"}
{"idx": 186692, "func": " bool NormalPageArena::shrinkObject(HeapObjectHeader* header, size_t newSize) {\n  ASSERT(header->checkHeader());\n   ASSERT(header->payloadSize() > newSize);\n   size_t allocationSize = ThreadHeap::allocationSizeFromSize(newSize);\n   ASSERT(header->size() > allocationSize);\n  size_t shrinkSize = header->size() - allocationSize;\n  if (isObjectAllocatedAtAllocationPoint(header)) {\n    m_currentAllocationPoint -= shrinkSize;\n    setRemainingAllocationSize(m_remainingAllocationSize + shrinkSize);\n    SET_MEMORY_INACCESSIBLE(m_currentAllocationPoint, shrinkSize);\n    header->setSize(allocationSize);\n    return true;\n  }\n  ASSERT(shrinkSize >= sizeof(HeapObjectHeader));\n  ASSERT(header->gcInfoIndex() > 0);\n  Address shrinkAddress = header->payloadEnd() - shrinkSize;\n  HeapObjectHeader* freedHeader = new (NotNull, shrinkAddress)\n      HeapObjectHeader(shrinkSize, header->gcInfoIndex());\n  freedHeader->markPromptlyFreed();\n  ASSERT(pageFromObject(reinterpret_cast<Address>(header)) ==\n         findPageFromAddress(reinterpret_cast<Address>(header)));\n  m_promptlyFreedSize += shrinkSize;\n  header->setSize(allocationSize);\n  SET_MEMORY_INACCESSIBLE(shrinkAddress + sizeof(HeapObjectHeader),\n                          shrinkSize - sizeof(HeapObjectHeader));\n  return false;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7775, "func": "static inline int h2_recv_allowed(const struct h2c *h2c)\n{\n\tif (h2c->dbuf->i == 0 &&\n\t    (h2c->st0 >= H2_CS_ERROR ||\n\t     h2c->conn->flags & CO_FL_ERROR ||\n\t     conn_xprt_read0_pending(h2c->conn)))\n\t\treturn 0;\n\n\tif (!(h2c->flags & H2_CF_DEM_DALLOC) &&\n\t    !(h2c->flags & H2_CF_DEM_BLOCK_ANY))\n\t\treturn 1;\n\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7456, "func": "ZEND_API int zend_ts_hash_sort(TsHashTable *ht, sort_func_t sort_func, compare_func_t compare_func, int renumber TSRMLS_DC)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_sort(TS_HASH(ht), sort_func, compare_func, renumber TSRMLS_CC);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7470, "func": "  t1operator_seac( T1_Decoder  decoder,\n                   FT_Pos      asb,\n                   FT_Pos      adx,\n                   FT_Pos      ady,\n                   FT_Int      bchar,\n                   FT_Int      achar )\n  {\n    FT_Error     error;\n    FT_Int       bchar_index, achar_index;\n#if 0\n    FT_Int       n_base_points;\n    FT_Outline*  base = decoder->builder.base;\n#endif\n    FT_Vector    left_bearing, advance;\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n    T1_Face      face  = (T1_Face)decoder->builder.face;\n#endif\n\n\n    if ( decoder->seac )\n    {\n      FT_ERROR(( \"t1operator_seac: invalid nested seac\\n\" ));\n      return FT_THROW( Syntax_Error );\n    }\n\n    if ( decoder->builder.metrics_only )\n    {\n      FT_ERROR(( \"t1operator_seac: unexpected seac\\n\" ));\n      return FT_THROW( Syntax_Error );\n    }\n\n    adx += decoder->builder.left_bearing.x;\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n    if ( decoder->glyph_names == 0                   &&\n         !face->root.internal->incremental_interface )\n#else\n    if ( decoder->glyph_names == 0 )\n#endif \n    {\n      FT_ERROR(( \"t1operator_seac:\"\n                 \" glyph names table not available in this font\\n\" ));\n      return FT_THROW( Syntax_Error );\n    }\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n    if ( face->root.internal->incremental_interface )\n    {\n      bchar_index = bchar;\n      achar_index = achar;\n    }\n    else\n#endif\n    {\n      bchar_index = t1_lookup_glyph_by_stdcharcode( decoder, bchar );\n      achar_index = t1_lookup_glyph_by_stdcharcode( decoder, achar );\n    }\n\n    if ( bchar_index < 0 || achar_index < 0 )\n    {\n      FT_ERROR(( \"t1operator_seac:\"\n                 \" invalid seac character code arguments\\n\" ));\n      return FT_THROW( Syntax_Error );\n    }\n\n    if ( decoder->builder.no_recurse )\n    {\n      FT_GlyphSlot    glyph  = (FT_GlyphSlot)decoder->builder.glyph;\n      FT_GlyphLoader  loader = glyph->internal->loader;\n      FT_SubGlyph     subg;\n\n\n      error = FT_GlyphLoader_CheckSubGlyphs( loader, 2 );\n      if ( error )\n        goto Exit;\n\n      subg = loader->current.subglyphs;\n\n      subg->index = bchar_index;\n      subg->flags = FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES |\n                    FT_SUBGLYPH_FLAG_USE_MY_METRICS;\n      subg->arg1  = 0;\n      subg->arg2  = 0;\n      subg++;\n\n      subg->index = achar_index;\n      subg->flags = FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES;\n      subg->arg1  = (FT_Int)FIXED_TO_INT( adx - asb );\n      subg->arg2  = (FT_Int)FIXED_TO_INT( ady );\n\n      glyph->num_subglyphs = 2;\n      glyph->subglyphs     = loader->base.subglyphs;\n      glyph->format        = FT_GLYPH_FORMAT_COMPOSITE;\n\n      loader->current.num_subglyphs = 2;\n      goto Exit;\n    }\n\n\n    FT_GlyphLoader_Prepare( decoder->builder.loader );  \n\n    decoder->seac = TRUE;\n    error = t1_decoder_parse_glyph( decoder, (FT_UInt)bchar_index );\n    decoder->seac = FALSE;\n    if ( error )\n      goto Exit;\n\n\n    left_bearing = decoder->builder.left_bearing;\n    advance      = decoder->builder.advance;\n\n    decoder->builder.left_bearing.x = 0;\n    decoder->builder.left_bearing.y = 0;\n\n    decoder->builder.pos_x = adx - asb;\n    decoder->builder.pos_y = ady;\n\n\n    decoder->seac = TRUE;\n    error = t1_decoder_parse_glyph( decoder, (FT_UInt)achar_index );\n    decoder->seac = FALSE;\n    if ( error )\n      goto Exit;\n\n\n    decoder->builder.left_bearing = left_bearing;\n    decoder->builder.advance      = advance;\n\n    decoder->builder.pos_x = 0;\n    decoder->builder.pos_y = 0;\n\n  Exit:\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 187177, "func": "bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,\n                                        MIMETypeCheck mime_type_check) const {\n  if (ErrorOccurred())\n    return false;\n\n  KURL sheet_url = GetResponse().Url();\n  if (sheet_url.IsLocalFile()) {\n    if (parser_context) {\n      parser_context->Count(WebFeature::kLocalCSSFile);\n    }\n    String extension;\n    int last_dot = sheet_url.LastPathComponent().ReverseFind('.');\n    if (last_dot != -1)\n      extension = sheet_url.LastPathComponent().Substring(last_dot + 1);\n    if (!EqualIgnoringASCIICase(\n            MIMETypeRegistry::GetMIMETypeForExtension(extension), \"text/css\")) {\n      if (parser_context) {\n         parser_context->CountDeprecation(\n             WebFeature::kLocalCSSFileExtensionRejected);\n       }\n      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {\n        return false;\n      }\n     }\n   }\n \n  if (mime_type_check == MIMETypeCheck::kLax)\n    return true;\n  AtomicString content_type = HttpContentType();\n  return content_type.IsEmpty() ||\n         DeprecatedEqualIgnoringCase(content_type, \"text/css\") ||\n         DeprecatedEqualIgnoringCase(content_type,\n                                     \"application/x-unknown-content-type\");\n}\n", "target": 1, "flaw_line_index": "27,28,29"}
{"idx": 187278, "func": "ExtensionNavigationThrottle::WillStartOrRedirectRequest() {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  content::WebContents* web_contents = navigation_handle()->GetWebContents();\n  ExtensionRegistry* registry =\n      ExtensionRegistry::Get(web_contents->GetBrowserContext());\n\n  const GURL& url = navigation_handle()->GetURL();\n  bool url_has_extension_scheme = url.SchemeIs(kExtensionScheme);\n  url::Origin target_origin = url::Origin::Create(url);\n  const Extension* target_extension = nullptr;\n  if (url_has_extension_scheme) {\n    target_extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(url);\n  } else if (target_origin.scheme() == kExtensionScheme) {\n    DCHECK(url.SchemeIsFileSystem() || url.SchemeIsBlob());\n    target_extension =\n        registry->enabled_extensions().GetByID(target_origin.host());\n  } else {\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  if (!target_extension) {\n    return content::NavigationThrottle::BLOCK_REQUEST;\n  }\n\n  if (target_extension->is_hosted_app()) {\n    base::StringPiece resource_root_relative_path =\n        url.path_piece().empty() ? base::StringPiece()\n                                 : url.path_piece().substr(1);\n    if (!IconsInfo::GetIcons(target_extension)\n             .ContainsPath(resource_root_relative_path)) {\n      return content::NavigationThrottle::BLOCK_REQUEST;\n     }\n   }\n \n  if (navigation_handle()->IsInMainFrame()) {\n    bool current_frame_is_extension_process =\n        !!registry->enabled_extensions().GetExtensionOrAppByURL(\n            navigation_handle()->GetStartingSiteInstance()->GetSiteURL());\n    if (!url_has_extension_scheme && !current_frame_is_extension_process) {\n      if (target_origin.scheme() == kExtensionScheme &&\n          navigation_handle()->GetSuggestedFilename().has_value()) {\n        return content::NavigationThrottle::PROCEED;\n      }\n      bool has_webview_permission =\n          target_extension->permissions_data()->HasAPIPermission(\n              APIPermission::kWebView);\n      if (!has_webview_permission)\n        return content::NavigationThrottle::CANCEL;\n     }\n \n     guest_view::GuestViewBase* guest =\n         guest_view::GuestViewBase::FromWebContents(web_contents);\n     if (url_has_extension_scheme && guest) {\n      const std::string& owner_extension_id = guest->owner_host();\n      const Extension* owner_extension =\n          registry->enabled_extensions().GetByID(owner_extension_id);\n\n      std::string partition_domain;\n      std::string partition_id;\n      bool in_memory = false;\n      bool is_guest = WebViewGuest::GetGuestPartitionConfigForSite(\n          navigation_handle()->GetStartingSiteInstance()->GetSiteURL(),\n          &partition_domain, &partition_id, &in_memory);\n\n      bool allowed = true;\n      url_request_util::AllowCrossRendererResourceLoadHelper(\n          is_guest, target_extension, owner_extension, partition_id, url.path(),\n          navigation_handle()->GetPageTransition(), &allowed);\n      if (!allowed)\n        return content::NavigationThrottle::BLOCK_REQUEST;\n    }\n\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  content::RenderFrameHost* parent = navigation_handle()->GetParentFrame();\n\n  bool external_ancestor = false;\n  for (auto* ancestor = parent; ancestor; ancestor = ancestor->GetParent()) {\n    if (ancestor->GetLastCommittedOrigin() == target_origin)\n      continue;\n    if (url::Origin::Create(ancestor->GetLastCommittedURL()) == target_origin)\n      continue;\n    if (ancestor->GetLastCommittedURL().SchemeIs(\n            content::kChromeDevToolsScheme))\n      continue;\n\n    external_ancestor = true;\n    break;\n  }\n\n  if (external_ancestor) {\n    if (!url_has_extension_scheme)\n      return content::NavigationThrottle::CANCEL;\n\n    if (!WebAccessibleResourcesInfo::IsResourceWebAccessible(target_extension,\n                                                             url.path()))\n      return content::NavigationThrottle::BLOCK_REQUEST;\n\n    if (target_extension->is_platform_app())\n      return content::NavigationThrottle::CANCEL;\n\n    const Extension* parent_extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(\n            parent->GetSiteInstance()->GetSiteURL());\n    if (parent_extension && parent_extension->is_platform_app())\n      return content::NavigationThrottle::BLOCK_REQUEST;\n  }\n\n  return content::NavigationThrottle::PROCEED;\n}\n", "target": 1, "flaw_line_index": "46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65"}
{"idx": 7772, "func": "static int h2_process_mux(struct h2c *h2c)\n{\n\tstruct h2s *h2s, *h2s_back;\n\n\tif (h2c->rcvd_c > 0 &&\n\t    !(h2c->flags & (H2_CF_MUX_MFULL | H2_CF_MUX_MALLOC)) &&\n\t    h2c_send_conn_wu(h2c) < 0)\n\t\tgoto fail;\n\n\n\tlist_for_each_entry_safe(h2s, h2s_back, &h2c->fctl_list, list) {\n\t\tif (h2c->mws <= 0 || h2c->flags & H2_CF_MUX_BLOCK_ANY ||\n\t\t    h2c->st0 >= H2_CS_ERROR)\n\t\t\tbreak;\n\n\t\th2s->flags &= ~H2_SF_BLK_ANY;\n\n\t\tif (h2s->cs) {\n\t\t\th2s->cs->data_cb->send(h2s->cs);\n\t\t\th2s->cs->data_cb->wake(h2s->cs);\n\t\t} else {\n\t\t\th2s_send_rst_stream(h2c, h2s);\n\t\t}\n\n\t\tif ((h2s->flags & H2_SF_BLK_MFCTL) == 0) {\n\t\t\tif (h2s->flags & H2_SF_BLK_ANY) {\n\t\t\t\tLIST_DEL(&h2s->list);\n\t\t\t\tLIST_ADDQ(&h2c->send_list, &h2s->list);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLIST_DEL(&h2s->list);\n\t\t\t\tLIST_INIT(&h2s->list);\n\t\t\t\tif (h2s->cs)\n\t\t\t\t\th2s->cs->flags &= ~CS_FL_DATA_WR_ENA;\n\t\t\t\telse {\n\t\t\t\t\th2s_destroy(h2s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(h2s, h2s_back, &h2c->send_list, list) {\n\t\tif (h2c->st0 >= H2_CS_ERROR || h2c->flags & H2_CF_MUX_BLOCK_ANY)\n\t\t\tbreak;\n\n\t\th2s->flags &= ~H2_SF_BLK_ANY;\n\n\t\tif (h2s->cs) {\n\t\t\th2s->cs->data_cb->send(h2s->cs);\n\t\t\th2s->cs->data_cb->wake(h2s->cs);\n\t\t} else {\n\t\t\th2s_send_rst_stream(h2c, h2s);\n\t\t}\n\t\tif (h2s->flags & H2_SF_BLK_MFCTL) {\n\t\t\tLIST_DEL(&h2s->list);\n\t\t\tLIST_ADDQ(&h2c->fctl_list, &h2s->list);\n\t\t}\n\t\telse if (!(h2s->flags & H2_SF_BLK_ANY)) {\n\t\t\tLIST_DEL(&h2s->list);\n\t\t\tLIST_INIT(&h2s->list);\n\t\t\tif (h2s->cs)\n\t\t\t\th2s->cs->flags &= ~CS_FL_DATA_WR_ENA;\n\t\t\telse {\n\t\t\t\th2s_destroy(h2s);\n\t\t\t}\n\t\t}\n\t}\n\n fail:\n\tif (unlikely(h2c->st0 >= H2_CS_ERROR)) {\n\t\tif (h2c->st0 == H2_CS_ERROR) {\n\t\t\tif (h2c->max_id >= 0) {\n\t\t\t\th2c_send_goaway_error(h2c, NULL);\n\t\t\t\tif (h2c->flags & H2_CF_MUX_BLOCK_ANY)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\th2c->st0 = H2_CS_ERROR2; \n\t\t}\n\t\treturn 1;\n\t}\n\treturn (h2c->mws <= 0 || LIST_ISEMPTY(&h2c->fctl_list)) && LIST_ISEMPTY(&h2c->send_list);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7669, "func": "static int handle_fsync(FsContext *ctx, int fid_type,\n                        V9fsFidOpenState *fs, int datasync)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n\n    if (datasync) {\n        return qemu_fdatasync(fd);\n    } else {\n        return fsync(fd);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7934, "func": "static int here(JF)\n{\n\treturn F->codelen;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7614, "func": "static void cirrus_write_hidden_dac(CirrusVGAState * s, int reg_value)\n{\n    if (s->cirrus_hidden_dac_lockindex == 4) {\n\ts->cirrus_hidden_dac_data = reg_value;\n#if defined(DEBUG_CIRRUS)\n\tprintf(\"cirrus: outport hidden DAC, value %02x\\n\", reg_value);\n#endif\n    }\n    s->cirrus_hidden_dac_lockindex = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186906, "func": " inline HTMLIFrameElement::HTMLIFrameElement(Document& document)\n     : HTMLFrameElementBase(iframeTag, document),\n      did_load_non_empty_document_(false),\n       collapsed_by_client_(false),\n       sandbox_(HTMLIFrameElementSandbox::Create(this)),\n       referrer_policy_(kReferrerPolicyDefault) {}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187018, "func": "    DidFinishNavigation(NavigationHandle* handle) {\n  if (handle->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  if (!handle->HasCommitted())\n    return;\n  if (handle->GetRenderFrameHost()->GetSiteInstance() != parent_site_instance_)\n    return;\n  if (!handle->GetURL().IsAboutBlank())\n    return;\n  if (!handle->GetRenderFrameHost()->PrepareForInnerWebContentsAttach()) {\n    filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                   MSG_ROUTING_NONE \n);\n  }\n  base::PostTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy,\n                     filter_, element_instance_id_,\n                     handle->GetRenderFrameHost()->GetRoutingID()));\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,18,19,20"}
{"idx": 7537, "func": "change_env (timezone_t tz)\n{\n  if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n    return false;\n  tzset ();\n  return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7830, "func": "  TT_VecLen( FT_F26Dot6  X,\n             FT_F26Dot6  Y )\n  {\n    FT_Vector  v;\n\n\n    v.x = X;\n    v.y = Y;\n\n    return FT_Vector_Length( &v );\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8173, "func": "void Gfx::opTextNextLine(Object args[], int numArgs) {\n  double tx, ty;\n\n  tx = state->getLineX();\n  ty = state->getLineY() - state->getLeading();\n  state->textMoveTo(tx, ty);\n  out->updateTextPos(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186561, "func": " std::unique_ptr<HttpResponse> HandleFileRequest(\n     const base::FilePath& server_root,\n    const HttpRequest& request) {\n  base::ScopedAllowBlockingForTesting allow_blocking;\n\n  GURL request_url = request.GetURL();\n  std::string relative_path(request_url.path());\n\n  std::string post_prefix(\"/post/\");\n  if (base::StartsWith(relative_path, post_prefix,\n                       base::CompareCase::SENSITIVE)) {\n    if (request.method != METHOD_POST)\n      return nullptr;\n    relative_path = relative_path.substr(post_prefix.size() - 1);\n  }\n\n  RequestQuery query = ParseQuery(request_url);\n\n  std::unique_ptr<BasicHttpResponse> failed_response(new BasicHttpResponse);\n  failed_response->set_code(HTTP_NOT_FOUND);\n\n  if (query.find(\"expected_body\") != query.end()) {\n    if (request.content.find(query[\"expected_body\"].front()) ==\n        std::string::npos) {\n      return std::move(failed_response);\n    }\n  }\n\n  if (query.find(\"expected_headers\") != query.end()) {\n    for (const auto& header : query[\"expected_headers\"]) {\n      if (header.find(\":\") == std::string::npos)\n        return std::move(failed_response);\n      std::string key = header.substr(0, header.find(\":\"));\n      std::string value = header.substr(header.find(\":\") + 1);\n      if (request.headers.find(key) == request.headers.end() ||\n          request.headers.at(key) != value) {\n        return std::move(failed_response);\n      }\n    }\n  }\n\n  DCHECK(base::StartsWith(relative_path, \"/\", base::CompareCase::SENSITIVE));\n  std::string request_path = relative_path.substr(1);\n  base::FilePath file_path(server_root.AppendASCII(request_path));\n  std::string file_contents;\n  if (!base::ReadFileToString(file_path, &file_contents)) {\n    file_path = file_path.AppendASCII(\"index.html\");\n    if (!base::ReadFileToString(file_path, &file_contents))\n      return nullptr;\n  }\n\n   if (request.method == METHOD_HEAD)\n     file_contents = \"\";\n \n  if (query.find(\"replace_text\") != query.end()) {\n    for (const auto& replacement : query[\"replace_text\"]) {\n      if (replacement.find(\":\") == std::string::npos)\n        return std::move(failed_response);\n      std::string find;\n      std::string with;\n      base::Base64Decode(replacement.substr(0, replacement.find(\":\")), &find);\n      base::Base64Decode(replacement.substr(replacement.find(\":\") + 1), &with);\n      base::ReplaceSubstringsAfterOffset(&file_contents, 0, find, with);\n    }\n  }\n \n   base::FilePath::StringPieceType mock_headers_extension;\n #if defined(OS_WIN)\n  base::string16 temp = base::ASCIIToUTF16(kMockHttpHeadersExtension);\n  mock_headers_extension = temp;\n#else\n  mock_headers_extension = kMockHttpHeadersExtension;\n#endif\n\n  base::FilePath headers_path(file_path.AddExtension(mock_headers_extension));\n\n   if (base::PathExists(headers_path)) {\n     std::string headers_contents;\n \n    if (!base::ReadFileToString(headers_path, &headers_contents))\n       return nullptr;\n \n     return std::make_unique<RawHttpResponse>(headers_contents, file_contents);\n   }\n\n  std::unique_ptr<BasicHttpResponse> http_response(new BasicHttpResponse);\n  http_response->set_code(HTTP_OK);\n\n  if (request.headers.find(\"Range\") != request.headers.end()) {\n    std::vector<HttpByteRange> ranges;\n\n    if (HttpUtil::ParseRangeHeader(request.headers.at(\"Range\"), &ranges) &&\n        ranges.size() == 1) {\n      ranges[0].ComputeBounds(file_contents.size());\n      size_t start = ranges[0].first_byte_position();\n      size_t end = ranges[0].last_byte_position();\n\n      http_response->set_code(HTTP_PARTIAL_CONTENT);\n      http_response->AddCustomHeader(\n          \"Content-Range\",\n          base::StringPrintf(\"bytes %\" PRIuS \"-%\" PRIuS \"/%\" PRIuS, start, end,\n                             file_contents.size()));\n\n      file_contents = file_contents.substr(start, end - start + 1);\n    }\n  }\n\n  http_response->set_content_type(GetContentType(file_path));\n  http_response->AddCustomHeader(\"Accept-Ranges\", \"bytes\");\n  http_response->AddCustomHeader(\"ETag\", \"'\" + file_path.MaybeAsASCII() + \"'\");\n  http_response->set_content(file_contents);\n  return std::move(http_response);\n}\n", "target": 1, "flaw_line_index": "60,61,62,63,64,65,66,67,68,69,70,85"}
{"idx": 7721, "func": "static void coroutine_fn v9fs_getlock(void *opaque)\n{\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsGetlock glock;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&glock.client_id);\n    err = pdu_unmarshal(pdu, offset, \"dbqqds\", &fid, &glock.type,\n                        &glock.start, &glock.length, &glock.proc_id,\n                        &glock.client_id);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getlock(pdu->tag, pdu->id, fid,\n                       glock.type, glock.start, glock.length);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    glock.type = P9_LOCK_TYPE_UNLCK;\n    err = pdu_marshal(pdu, offset, \"bqqds\", glock.type,\n                          glock.start, glock.length, glock.proc_id,\n                          &glock.client_id);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_getlock_return(pdu->tag, pdu->id, glock.type, glock.start,\n                              glock.length, glock.proc_id);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&glock.client_id);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186478, "func": "GURL DevToolsWindow::GetDevToolsURL(Profile* profile,\n                                    const GURL& base_url,\n                                    bool shared_worker_frontend,\n                                    bool v8_only_frontend,\n                                    const std::string& remote_frontend,\n                                    bool can_dock) {\n  if (base_url.SchemeIs(\"data\"))\n    return base_url;\n\n  std::string frontend_url(\n      !remote_frontend.empty() ?\n          remote_frontend :\n          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));\n  if (shared_worker_frontend)\n    url_string += \"&isSharedWorker=true\";\n  if (v8_only_frontend)\n    url_string += \"&v8only=true\";\n  if (remote_frontend.size()) {\n    url_string += \"&remoteFrontend=true\";\n  } else {\n    url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();\n   }\n   if (can_dock)\n     url_string += \"&can_dock=true\";\n  return GURL(url_string);\n }\n", "target": 1, "flaw_line_index": "30"}
{"idx": 7865, "func": "void ram_handle_compressed(void *host, uint8_t ch, uint64_t size)\n{\n    if (ch != 0 || !is_zero_range(host, size)) {\n        memset(host, ch, size);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186863, "func": "    shared_memory_handle(const gfx::GpuMemoryBufferHandle& handle) {\n  if (handle.type != gfx::SHARED_MEMORY_BUFFER &&\n       handle.type != gfx::DXGI_SHARED_HANDLE &&\n       handle.type != gfx::ANDROID_HARDWARE_BUFFER)\n     return mojo::ScopedSharedBufferHandle();\n  return mojo::WrapSharedMemoryHandle(handle.handle, handle.handle.GetSize(),\n                                      false);\n }\n", "target": 1, "flaw_line_index": "6,7"}
{"idx": 8157, "func": "void Gfx::opSetStrokeColor(Object args[], int numArgs) {\n  GfxColor color;\n  int i;\n\n  if (numArgs != state->getStrokeColorSpace()->getNComps()) {\n    error(getPos(), \"Incorrect number of arguments in 'SC' command\");\n    return;\n  }\n  state->setStrokePattern(NULL);\n  for (i = 0; i < numArgs; ++i) {\n    color.c[i] = dblToCol(args[i].getNum());\n  }\n  state->setStrokeColor(&color);\n  out->updateStrokeColor(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7550, "func": "static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong datalen;\n\n\tdatalen = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\tif (datalen < 0 || (max - (*p)) <= datalen) {\n\t\tzend_error(E_WARNING, \"Insufficient data for unserializing - %ld required, %ld present\", datalen, (long)(max - (*p)));\n\t\treturn 0;\n\t}\n\n\tif (ce->unserialize == NULL) {\n\t\tzend_error(E_WARNING, \"Class %s has no unserializer\", ce->name);\n\t\tobject_init_ex(*rval, ce);\n\t} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash TSRMLS_CC) != SUCCESS) {\n\t\treturn 0;\n\t}\n\n\t(*p) += datalen;\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8100, "func": "GBool GfxResources::lookupGStateNF(char *name, Object *obj) {\n  GfxResources *resPtr;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->gStateDict.isDict()) {\n      if (!resPtr->gStateDict.dictLookupNF(name, obj)->isNull()) {\n\treturn gTrue;\n      }\n      obj->free();\n    }\n  }\n  error(-1, \"ExtGState '%s' is unknown\", name);\n  return gFalse;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186787, "func": "bool VaapiVideoDecodeAccelerator::VaapiVP9Accelerator::SubmitDecode(\n    const scoped_refptr<VP9Picture>& pic,\n    const Vp9SegmentationParams& seg,\n     const Vp9LoopFilterParams& lf,\n     const std::vector<scoped_refptr<VP9Picture>>& ref_pictures,\n     const base::Closure& done_cb) {\n   DCHECK(done_cb.is_null());\n \n  VADecPictureParameterBufferVP9 pic_param;\n  memset(&pic_param, 0, sizeof(pic_param));\n\n  const Vp9FrameHeader* frame_hdr = pic->frame_hdr.get();\n  DCHECK(frame_hdr);\n\n  pic_param.frame_width = base::checked_cast<uint16_t>(frame_hdr->frame_width);\n  pic_param.frame_height =\n      base::checked_cast<uint16_t>(frame_hdr->frame_height);\n\n  CHECK_EQ(ref_pictures.size(), arraysize(pic_param.reference_frames));\n  for (size_t i = 0; i < arraysize(pic_param.reference_frames); ++i) {\n    VASurfaceID va_surface_id;\n    if (ref_pictures[i]) {\n      scoped_refptr<VaapiDecodeSurface> surface =\n          VP9PictureToVaapiDecodeSurface(ref_pictures[i]);\n      va_surface_id = surface->va_surface()->id();\n    } else {\n      va_surface_id = VA_INVALID_SURFACE;\n    }\n\n    pic_param.reference_frames[i] = va_surface_id;\n  }\n\n#define FHDR_TO_PP_PF1(a) pic_param.pic_fields.bits.a = frame_hdr->a\n#define FHDR_TO_PP_PF2(a, b) pic_param.pic_fields.bits.a = b\n  FHDR_TO_PP_PF2(subsampling_x, frame_hdr->subsampling_x == 1);\n  FHDR_TO_PP_PF2(subsampling_y, frame_hdr->subsampling_y == 1);\n  FHDR_TO_PP_PF2(frame_type, frame_hdr->IsKeyframe() ? 0 : 1);\n  FHDR_TO_PP_PF1(show_frame);\n  FHDR_TO_PP_PF1(error_resilient_mode);\n  FHDR_TO_PP_PF1(intra_only);\n  FHDR_TO_PP_PF1(allow_high_precision_mv);\n  FHDR_TO_PP_PF2(mcomp_filter_type, frame_hdr->interpolation_filter);\n  FHDR_TO_PP_PF1(frame_parallel_decoding_mode);\n  FHDR_TO_PP_PF1(reset_frame_context);\n  FHDR_TO_PP_PF1(refresh_frame_context);\n  FHDR_TO_PP_PF2(frame_context_idx, frame_hdr->frame_context_idx_to_save_probs);\n  FHDR_TO_PP_PF2(segmentation_enabled, seg.enabled);\n  FHDR_TO_PP_PF2(segmentation_temporal_update, seg.temporal_update);\n  FHDR_TO_PP_PF2(segmentation_update_map, seg.update_map);\n  FHDR_TO_PP_PF2(last_ref_frame, frame_hdr->ref_frame_idx[0]);\n  FHDR_TO_PP_PF2(last_ref_frame_sign_bias,\n                 frame_hdr->ref_frame_sign_bias[Vp9RefType::VP9_FRAME_LAST]);\n  FHDR_TO_PP_PF2(golden_ref_frame, frame_hdr->ref_frame_idx[1]);\n  FHDR_TO_PP_PF2(golden_ref_frame_sign_bias,\n                 frame_hdr->ref_frame_sign_bias[Vp9RefType::VP9_FRAME_GOLDEN]);\n  FHDR_TO_PP_PF2(alt_ref_frame, frame_hdr->ref_frame_idx[2]);\n  FHDR_TO_PP_PF2(alt_ref_frame_sign_bias,\n                 frame_hdr->ref_frame_sign_bias[Vp9RefType::VP9_FRAME_ALTREF]);\n  FHDR_TO_PP_PF2(lossless_flag, frame_hdr->quant_params.IsLossless());\n#undef FHDR_TO_PP_PF2\n#undef FHDR_TO_PP_PF1\n\n  pic_param.filter_level = lf.level;\n  pic_param.sharpness_level = lf.sharpness;\n  pic_param.log2_tile_rows = frame_hdr->tile_rows_log2;\n  pic_param.log2_tile_columns = frame_hdr->tile_cols_log2;\n  pic_param.frame_header_length_in_bytes = frame_hdr->uncompressed_header_size;\n  pic_param.first_partition_size = frame_hdr->header_size_in_bytes;\n\n  ARRAY_MEMCPY_CHECKED(pic_param.mb_segment_tree_probs, seg.tree_probs);\n  ARRAY_MEMCPY_CHECKED(pic_param.segment_pred_probs, seg.pred_probs);\n\n  pic_param.profile = frame_hdr->profile;\n  pic_param.bit_depth = frame_hdr->bit_depth;\n  DCHECK((pic_param.profile == 0 && pic_param.bit_depth == 8) ||\n         (pic_param.profile == 2 && pic_param.bit_depth == 10));\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,\n                                    sizeof(pic_param), &pic_param))\n    return false;\n\n  VASliceParameterBufferVP9 slice_param;\n  memset(&slice_param, 0, sizeof(slice_param));\n  slice_param.slice_data_size = frame_hdr->frame_size;\n  slice_param.slice_data_offset = 0;\n  slice_param.slice_data_flag = VA_SLICE_DATA_FLAG_ALL;\n\n  static_assert(arraysize(Vp9SegmentationParams::feature_enabled) ==\n                    arraysize(slice_param.seg_param),\n                \"seg_param array of incorrect size\");\n  for (size_t i = 0; i < arraysize(slice_param.seg_param); ++i) {\n    VASegmentParameterVP9& seg_param = slice_param.seg_param[i];\n#define SEG_TO_SP_SF(a, b) seg_param.segment_flags.fields.a = b\n    SEG_TO_SP_SF(\n        segment_reference_enabled,\n        seg.FeatureEnabled(i, Vp9SegmentationParams::SEG_LVL_REF_FRAME));\n    SEG_TO_SP_SF(segment_reference,\n                 seg.FeatureData(i, Vp9SegmentationParams::SEG_LVL_REF_FRAME));\n    SEG_TO_SP_SF(segment_reference_skipped,\n                 seg.FeatureEnabled(i, Vp9SegmentationParams::SEG_LVL_SKIP));\n#undef SEG_TO_SP_SF\n\n    ARRAY_MEMCPY_CHECKED(seg_param.filter_level, lf.lvl[i]);\n\n    seg_param.luma_dc_quant_scale = seg.y_dequant[i][0];\n    seg_param.luma_ac_quant_scale = seg.y_dequant[i][1];\n    seg_param.chroma_dc_quant_scale = seg.uv_dequant[i][0];\n    seg_param.chroma_ac_quant_scale = seg.uv_dequant[i][1];\n  }\n\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceParameterBufferType,\n                                    sizeof(slice_param), &slice_param))\n    return false;\n\n  void* non_const_ptr = const_cast<uint8_t*>(frame_hdr->data);\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceDataBufferType,\n                                    frame_hdr->frame_size, non_const_ptr))\n    return false;\n\n  scoped_refptr<VaapiDecodeSurface> dec_surface =\n      VP9PictureToVaapiDecodeSurface(pic);\n\n  return vaapi_dec_->DecodeSurface(dec_surface);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7817, "func": "static int h2s_send_rst_stream(struct h2c *h2c, struct h2s *h2s)\n{\n\tstruct buffer *res;\n\tchar str[13];\n\tint ret;\n\n\tif (!h2s || h2s->st == H2_SS_CLOSED)\n\t\treturn 1;\n\n\tif (h2c->dft == H2_FT_RST_STREAM) {\n\t\tret = 1;\n\t\tgoto ignore;\n\t}\n\n\tif (h2c_mux_busy(h2c, h2s)) {\n\t\th2s->flags |= H2_SF_BLK_MBUSY;\n\t\treturn 0;\n\t}\n\n\tres = h2_get_buf(h2c, &h2c->mbuf);\n\tif (!res) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\treturn 0;\n\t}\n\n\tmemcpy(str, \"\\x00\\x00\\x04\\x03\\x00\", 5);\n\twrite_n32(str + 5, h2s->id);\n\twrite_n32(str + 9, h2s->errcode);\n\tret = bo_istput(res, ist2(str, 13));\n\n\tif (unlikely(ret <= 0)) {\n\t\tif (!ret) {\n\t\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n ignore:\n\th2s->flags |= H2_SF_RST_SENT;\n\th2s_close(h2s);\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187063, "func": "void PaymentRequest::AreRequestedMethodsSupportedCallback(\n    bool methods_supported) {\n  if (methods_supported) {\n    if (SatisfiesSkipUIConstraints()) {\n      skipped_payment_request_ui_ = true;\n      Pay();\n    }\n  } else {\n    journey_logger_.SetNotShown(\n        JourneyLogger::NOT_SHOWN_REASON_NO_SUPPORTED_PAYMENT_METHOD);\n    client_->OnError(mojom::PaymentErrorReason::NOT_SUPPORTED);\n    if (observer_for_testing_)\n      observer_for_testing_->OnNotSupportedError();\n     OnConnectionTerminated();\n   }\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,16"}
{"idx": 7685, "func": "static ssize_t handle_preadv(FsContext *ctx, V9fsFidOpenState *fs,\n                             const struct iovec *iov,\n                             int iovcnt, off_t offset)\n{\n#ifdef CONFIG_PREADV\n    return preadv(fs->fd, iov, iovcnt, offset);\n#else\n    int err = lseek(fs->fd, offset, SEEK_SET);\n    if (err == -1) {\n        return err;\n    } else {\n        return readv(fs->fd, iov, iovcnt);\n    }\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186435, "func": "void InspectorNetworkAgent::WillSendRequest(\n    ExecutionContext* execution_context,\n    unsigned long identifier,\n     DocumentLoader* loader,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n    const FetchInitiatorInfo& initiator_info) {\n   if (initiator_info.name == FetchInitiatorTypeNames::internal)\n     return;\n\n  if (initiator_info.name == FetchInitiatorTypeNames::document &&\n      loader->GetSubstituteData().IsValid())\n    return;\n\n  protocol::DictionaryValue* headers =\n      state_->getObject(NetworkAgentState::kExtraRequestHeaders);\n  if (headers) {\n    for (size_t i = 0; i < headers->size(); ++i) {\n      auto header = headers->at(i);\n      String value;\n      if (header.second->asString(&value))\n        request.SetHTTPHeaderField(AtomicString(header.first),\n                                   AtomicString(value));\n    }\n  }\n\n  request.SetReportRawHeaders(true);\n\n  if (state_->booleanProperty(NetworkAgentState::kCacheDisabled, false)) {\n    if (LoadsFromCacheOnly(request) &&\n        request.GetRequestContext() != WebURLRequest::kRequestContextInternal) {\n      request.SetCachePolicy(WebCachePolicy::kBypassCacheLoadOnlyFromCache);\n    } else {\n      request.SetCachePolicy(WebCachePolicy::kBypassingCache);\n    }\n    request.SetShouldResetAppCache(true);\n  }\n   if (state_->booleanProperty(NetworkAgentState::kBypassServiceWorker, false))\n     request.SetServiceWorkerMode(WebURLRequest::ServiceWorkerMode::kNone);\n \n   WillSendRequestInternal(execution_context, identifier, loader, request,\n                          redirect_response, initiator_info);\n \n   if (!host_id_.IsEmpty()) {\n     request.AddHTTPHeaderField(\n        HTTPNames::X_DevTools_Emulate_Network_Conditions_Client_Id,\n        AtomicString(host_id_));\n  }\n}\n", "target": 1, "flaw_line_index": "7,43"}
{"idx": 186372, "func": " void PrintViewManager::PrintPreviewDone() {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK_NE(NOT_PREVIEWING, print_preview_state_);\n \n   if (print_preview_state_ == SCRIPTED_PREVIEW) {\n     auto& map = g_scripted_print_preview_closure_map.Get();\n    auto it = map.find(scripted_print_preview_rph_);\n    CHECK(it != map.end());\n    it->second.Run();\n    map.erase(it);\n    scripted_print_preview_rph_ = nullptr;\n  }\n  print_preview_state_ = NOT_PREVIEWING;\n  print_preview_rfh_ = nullptr;\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186953, "func": "bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,\n                                           std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"\n       \"  WHERE cache_id = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, cache_id);\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().cache_id == cache_id);\n  }\n\n  return statement.Succeeded();\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 186840, "func": "void MojoAudioInputIPC::StreamCreated(\n    media::mojom::AudioInputStreamPtr stream,\n    media::mojom::AudioInputStreamClientRequest stream_client_request,\n    mojo::ScopedSharedBufferHandle shared_memory,\n    mojo::ScopedHandle socket,\n    bool initially_muted) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(delegate_);\n  DCHECK(socket.is_valid());\n  DCHECK(shared_memory.is_valid());\n  DCHECK(!stream_);\n  DCHECK(!stream_client_binding_.is_bound());\n  stream_ = std::move(stream);\n  stream_client_binding_.Bind(std::move(stream_client_request));\n\n  base::PlatformFile socket_handle;\n  auto result = mojo::UnwrapPlatformFile(std::move(socket), &socket_handle);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n \n   base::SharedMemoryHandle memory_handle;\n  bool read_only = true;\n   result = mojo::UnwrapSharedMemoryHandle(std::move(shared_memory),\n                                          &memory_handle, nullptr, &read_only);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n  DCHECK(read_only);\n \n   delegate_->OnStreamCreated(memory_handle, socket_handle, initially_muted);\n }\n", "target": 1, "flaw_line_index": "21,23,25"}
{"idx": 7457, "func": "ZEND_API int _zend_ts_hash_init(TsHashTable *ht, uint nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n#ifdef ZTS\n\tht->mx_reader = tsrm_mutex_alloc();\n\tht->mx_writer = tsrm_mutex_alloc();\n\tht->reader = 0;\n#endif\n\treturn _zend_hash_init(TS_HASH(ht), nSize, pDestructor, persistent ZEND_FILE_LINE_RELAY_CC);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7782, "func": "static void h2_shutr(struct conn_stream *cs, enum cs_shr_mode mode)\n{\n\tstruct h2s *h2s = cs->ctx;\n\n\tif (!mode)\n\t\treturn;\n\n\tif (h2s->st == H2_SS_HLOC || h2s->st == H2_SS_ERROR || h2s->st == H2_SS_CLOSED)\n\t\treturn;\n\n\tif (!(h2s->flags & H2_SF_RST_SENT) &&\n\t    h2s_send_rst_stream(h2s->h2c, h2s) <= 0)\n\t\tgoto add_to_list;\n\n\tif (!(h2s->flags & H2_SF_OUTGOING_DATA) &&\n\t    !(h2s->h2c->flags & (H2_CF_GOAWAY_SENT|H2_CF_GOAWAY_FAILED)) &&\n\t    h2c_send_goaway_error(h2s->h2c, h2s) <= 0)\n\t\tgoto add_to_list;\n\n\tif (h2s->h2c->mbuf->o && !(cs->conn->flags & CO_FL_XPRT_WR_ENA))\n\t\tconn_xprt_want_send(cs->conn);\n\n\th2s_close(h2s);\n\n add_to_list:\n\tif (LIST_ISEMPTY(&h2s->list)) {\n\t\tif (h2s->flags & H2_SF_BLK_MFCTL)\n\t\t\tLIST_ADDQ(&h2s->h2c->fctl_list, &h2s->list);\n\t\telse if (h2s->flags & (H2_SF_BLK_MBUSY|H2_SF_BLK_MROOM))\n\t\t\tLIST_ADDQ(&h2s->h2c->send_list, &h2s->list);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8049, "func": "char *vnc_socket_remote_addr(const char *format, int fd) {\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0)\n        return NULL;\n\n    return addr_to_string(format, &sa, salen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7925, "func": "static void emitfunction(JF, js_Function *fun)\n{\n\temit(J, F, OP_CLOSURE);\n\temitraw(J, F, addfunction(J, F, fun));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7437, "func": "ZEND_API int _zend_ts_hash_init_ex(TsHashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection ZEND_FILE_LINE_DC)\n{\n#ifdef ZTS\n\tht->mx_reader = tsrm_mutex_alloc();\n\tht->mx_writer = tsrm_mutex_alloc();\n\tht->reader = 0;\n#endif\n\treturn _zend_hash_init_ex(TS_HASH(ht), nSize, pHashFunction, pDestructor, persistent, bApplyProtection ZEND_FILE_LINE_RELAY_CC);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7898, "func": "static void cassign(JF, js_Ast *exp)\n{\n\tjs_Ast *lhs = exp->a;\n\tjs_Ast *rhs = exp->b;\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\tcexp(J, F, rhs);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\tcexp(J, F, rhs);\n\t\temit(J, F, OP_SETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, rhs);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186983, "func": "WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(\n    int window_id,\n    std::string* error) {\n  Browser* browser = NULL;\n  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))\n    return nullptr;\n\n  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();\n  if (!contents) {\n    *error = \"No active web contents to capture\";\n    return nullptr;\n  }\n \n   if (!extension()->permissions_data()->CanCaptureVisiblePage(\n           contents->GetLastCommittedURL(),\n          SessionTabHelper::IdForTab(contents).id(), error)) {\n     return nullptr;\n   }\n   return contents;\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 8301, "func": "XFreeFeedbackList(XFeedbackState *list)\n{\n    XFree((char *)list);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186925, "func": "htmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n    const xmlChar *base = ctxt->input->base;\n\n    GROW;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || \n\t(!IS_LETTER(c) && (c != '_') &&\n         (c != ':'))) {\n\treturn(NULL);\n    }\n\n    while ((c != ' ') && (c != '>') && (c != '/') && \n\t   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n            (c == '.') || (c == '-') ||\n\t    (c == '_') || (c == ':') ||\n\t    (IS_COMBINING(c)) ||\n\t    (IS_EXTENDER(c)))) {\n\tif (count++ > 100) {\n\t    count = 0;\n\t    GROW;\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n\tif (ctxt->input->base != base) {\n\t    return(htmlParseNameComplex(ctxt));\n \t}\n     }\n \n    if (ctxt->input->base > ctxt->input->cur - len)\n\treturn(NULL);\n \n     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));\n }\n", "target": 1, "flaw_line_index": "33,34"}
{"idx": 7459, "func": "bool DBusHelperProxy::isCallerAuthorized(const QString &action, const QByteArray &callerID)\n{\n    switch (BackendsManager::authBackend()->extraCallerIDVerificationMethod()) {\n        case AuthBackend::NoExtraCallerIDVerificationMethod:\n        break;\n\n        case AuthBackend::VerifyAgainstDBusServiceName:\n            if (message().service().toUtf8() != callerID) {\n                return false;\n            }\n        break;\n\n        case AuthBackend::VerifyAgainstDBusServicePid:\n            if (connection().interface()->servicePid(message().service()).value() != callerID.toUInt()) {\n                return false;\n            }\n        break;\n    }\n\n    return BackendsManager::authBackend()->isCallerAuthorized(action, callerID);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7637, "func": "static int proxy_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,\n                       const char *name, FsCred *credp)\n{\n    int retval;\n    V9fsString fullname;\n\n    v9fs_string_init(&fullname);\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    retval = v9fs_request(fs_ctx->private, T_MKDIR, NULL, &fullname,\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n    v9fs_string_free(&fullname);\n    if (retval < 0) {\n        errno = -retval;\n        retval = -1;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187241, "func": "void IndexedDBTransaction::Abort(const IndexedDBDatabaseError& error) {\n  IDB_TRACE1(\"IndexedDBTransaction::Abort\", \"txn.id\", id());\n  DCHECK(!processing_event_queue_);\n  if (state_ == FINISHED)\n    return;\n\n  UMA_HISTOGRAM_ENUMERATION(\"WebCore.IndexedDB.TransactionAbortReason\",\n                            ExceptionCodeToUmaEnum(error.code()),\n                            UmaIDBExceptionExclusiveMaxValue);\n\n  timeout_timer_.Stop();\n\n  state_ = FINISHED;\n  should_process_queue_ = false;\n\n  if (backing_store_transaction_begun_)\n    transaction_->Rollback();\n\n  while (!abort_task_stack_.empty())\n    abort_task_stack_.pop().Run();\n\n  preemptive_task_queue_.clear();\n  pending_preemptive_events_ = 0;\n  task_queue_.clear();\n\n  CloseOpenCursors();\n  transaction_->Reset();\n\n  database_->transaction_coordinator().DidFinishTransaction(this);\n#ifndef NDEBUG\n  DCHECK(!database_->transaction_coordinator().IsActive(this));\n#endif\n\n  if (callbacks_.get())\n    callbacks_->OnAbort(*this, error);\n\n   database_->TransactionFinished(this, false);\n \n  connection_->RemoveTransaction(id_);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8169, "func": "void Gfx::opShowText(Object args[], int numArgs) {\n  if (!state->getFont()) {\n    error(getPos(), \"No font in show\");\n    return;\n  }\n  if (fontChanged) {\n    out->updateFont(state);\n    fontChanged = gFalse;\n  }\n  out->beginStringOp(state);\n  doShowText(args[0].getString());\n  out->endStringOp(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186972, "func": "  void Verify_StoreExistingGroupExistingCache(base::Time expected_update_time) {\n    EXPECT_TRUE(delegate()->stored_group_success_);\n    EXPECT_EQ(cache_.get(), group_->newest_complete_cache());\n\n    AppCacheDatabase::CacheRecord cache_record;\n    EXPECT_TRUE(database()->FindCache(1, &cache_record));\n    EXPECT_EQ(1, cache_record.cache_id);\n    EXPECT_EQ(1, cache_record.group_id);\n     EXPECT_FALSE(cache_record.online_wildcard);\n     EXPECT_TRUE(expected_update_time == cache_record.update_time);\n     EXPECT_EQ(100 + kDefaultEntrySize, cache_record.cache_size);\n \n     std::vector<AppCacheDatabase::EntryRecord> entry_records;\n     EXPECT_TRUE(database()->FindEntriesForCache(1, &entry_records));\n    EXPECT_EQ(2U, entry_records.size());\n    if (entry_records[0].url == kDefaultEntryUrl)\n       entry_records.erase(entry_records.begin());\n     EXPECT_EQ(1, entry_records[0].cache_id);\n     EXPECT_EQ(kEntryUrl, entry_records[0].url);\n    EXPECT_EQ(AppCacheEntry::MASTER, entry_records[0].flags);\n     EXPECT_EQ(1, entry_records[0].response_id);\n     EXPECT_EQ(100, entry_records[0].response_size);\n \n    EXPECT_EQ(100 + kDefaultEntrySize, storage()->usage_map_[kOrigin]);\n     EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);\n     EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);\n    EXPECT_EQ(100, mock_quota_manager_proxy_->last_delta_);\n \n     TestFinished();\n   }\n", "target": 1, "flaw_line_index": "20,25,28"}
{"idx": 8106, "func": "void Gfx::opBeginIgnoreUndef(Object args[], int numArgs) {\n  ++ignoreUndef;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7694, "func": "static int handle_statfs(FsContext *ctx, V9fsPath *fs_path,\n                         struct statfs *stbuf)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fstatfs(fd, stbuf);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186545, "func": "void ProfileChooserView::RemoveAccount() {\n  DCHECK(!account_id_to_remove_.empty());\n   ProfileOAuth2TokenService* oauth2_token_service =\n       ProfileOAuth2TokenServiceFactory::GetForProfile(browser_->profile());\n   if (oauth2_token_service) {\n    oauth2_token_service->RevokeCredentials(account_id_to_remove_);\n     PostActionPerformed(ProfileMetrics::PROFILE_DESKTOP_MENU_REMOVE_ACCT);\n   }\n   account_id_to_remove_.clear();\n\n  ShowViewFromMode(profiles::BUBBLE_VIEW_MODE_ACCOUNT_MANAGEMENT);\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 7653, "func": "static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return telldir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8126, "func": "void Gfx::opFill(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    return;\n  }\n  if (state->isPath() && !contentIsHidden()) {\n    if (state->getFillColorSpace()->getMode() == csPattern) {\n      doPatternFill(gFalse);\n    } else {\n      out->fill(state);\n    }\n  }\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7691, "func": "static int handle_renameat(FsContext *ctx, V9fsPath *olddir,\n                           const char *old_name, V9fsPath *newdir,\n                           const char *new_name)\n{\n    int olddirfd, newdirfd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    olddirfd = open_by_handle(data->mountfd, olddir->data, O_PATH);\n    if (olddirfd < 0) {\n        return olddirfd;\n    }\n    newdirfd = open_by_handle(data->mountfd, newdir->data, O_PATH);\n    if (newdirfd < 0) {\n        close(olddirfd);\n        return newdirfd;\n    }\n    ret = renameat(olddirfd, old_name, newdirfd, new_name);\n    close(newdirfd);\n    close(olddirfd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7514, "func": "  tt_get_sfnt_checksum( TT_Face    face,\n                        FT_UShort  i )\n  {\n#if 0 \n    if ( face->dir_tables[i].CheckSum )\n      return face->dir_tables[i].CheckSum;\n#endif\n\n    if ( !face->goto_table )\n      return 0;\n\n    if ( face->goto_table( face,\n                           face->dir_tables[i].Tag,\n                           face->root.stream,\n                           NULL ) )\n      return 0;\n\n    return (FT_ULong)tt_synth_sfnt_checksum( face->root.stream,\n                                             face->dir_tables[i].Length );\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186888, "func": "void ContextState::RestoreTextureUnitBindings(\n    GLuint unit, const ContextState* prev_state) const {\n   DCHECK_LT(unit, texture_units.size());\n   const TextureUnit& texture_unit = texture_units[unit];\n   GLuint service_id_2d = Get2dServiceId(texture_unit);\n   GLuint service_id_cube = GetCubeServiceId(texture_unit);\n   GLuint service_id_oes = GetOesServiceId(texture_unit);\n   GLuint service_id_arb = GetArbServiceId(texture_unit);\n\n  bool bind_texture_2d = true;\n  bool bind_texture_cube = true;\n  bool bind_texture_oes =\n       feature_info_->feature_flags().oes_egl_image_external ||\n       feature_info_->feature_flags().nv_egl_stream_consumer_external;\n   bool bind_texture_arb = feature_info_->feature_flags().arb_texture_rectangle;\n \n   if (prev_state) {\n     const TextureUnit& prev_unit = prev_state->texture_units[unit];\n     bind_texture_2d = service_id_2d != Get2dServiceId(prev_unit);\n     bind_texture_cube = service_id_cube != GetCubeServiceId(prev_unit);\n     bind_texture_oes =\n         bind_texture_oes && service_id_oes != GetOesServiceId(prev_unit);\n    bind_texture_arb =\n        bind_texture_arb && service_id_arb != GetArbServiceId(prev_unit);\n   }\n \n  if (!bind_texture_2d && !bind_texture_cube\n      && !bind_texture_oes && !bind_texture_arb) {\n     return;\n   }\n \n  api()->glActiveTextureFn(GL_TEXTURE0 + unit);\n  if (bind_texture_2d) {\n    api()->glBindTextureFn(GL_TEXTURE_2D, service_id_2d);\n  }\n  if (bind_texture_cube) {\n    api()->glBindTextureFn(GL_TEXTURE_CUBE_MAP, service_id_cube);\n  }\n  if (bind_texture_oes) {\n    api()->glBindTextureFn(GL_TEXTURE_EXTERNAL_OES, service_id_oes);\n  }\n   if (bind_texture_arb) {\n     api()->glBindTextureFn(GL_TEXTURE_RECTANGLE_ARB, service_id_arb);\n   }\n }\n", "target": 1, "flaw_line_index": "28,29"}
{"idx": 186364, "func": "CompositorFrameMetadata LayerTreeHostImpl::MakeCompositorFrameMetadata() const {\n  CompositorFrameMetadata metadata;\n  metadata.device_scale_factor = active_tree_->painted_device_scale_factor() *\n                                 active_tree_->device_scale_factor();\n\n  metadata.page_scale_factor = active_tree_->current_page_scale_factor();\n  metadata.scrollable_viewport_size = active_tree_->ScrollableViewportSize();\n  metadata.root_layer_size = active_tree_->ScrollableSize();\n  metadata.min_page_scale_factor = active_tree_->min_page_scale_factor();\n  metadata.max_page_scale_factor = active_tree_->max_page_scale_factor();\n  metadata.top_controls_height =\n      browser_controls_offset_manager_->TopControlsHeight();\n  metadata.top_controls_shown_ratio =\n      browser_controls_offset_manager_->TopControlsShownRatio();\n  metadata.bottom_controls_height =\n      browser_controls_offset_manager_->BottomControlsHeight();\n   metadata.bottom_controls_shown_ratio =\n       browser_controls_offset_manager_->BottomControlsShownRatio();\n   metadata.root_background_color = active_tree_->background_color();\n \n   active_tree_->GetViewportSelection(&metadata.selection);\n \n  if (OuterViewportScrollLayer()) {\n    metadata.root_overflow_x_hidden =\n        !OuterViewportScrollLayer()->user_scrollable_horizontal();\n    metadata.root_overflow_y_hidden =\n        !OuterViewportScrollLayer()->user_scrollable_vertical();\n  }\n\n  if (GetDrawMode() == DRAW_MODE_RESOURCELESS_SOFTWARE) {\n    metadata.is_resourceless_software_draw_with_scroll_or_animation =\n        IsActivelyScrolling() || mutator_host_->NeedsTickAnimations();\n  }\n\n  for (LayerImpl* surface_layer : active_tree_->SurfaceLayers()) {\n    SurfaceLayerImpl* surface_layer_impl =\n        static_cast<SurfaceLayerImpl*>(surface_layer);\n    metadata.referenced_surfaces.push_back(\n        surface_layer_impl->primary_surface_info().id());\n    if (surface_layer_impl->fallback_surface_info().is_valid()) {\n      metadata.referenced_surfaces.push_back(\n          surface_layer_impl->fallback_surface_info().id());\n    }\n  }\n  if (!InnerViewportScrollLayer())\n    return metadata;\n\n  metadata.root_overflow_x_hidden |=\n      !InnerViewportScrollLayer()->user_scrollable_horizontal();\n  metadata.root_overflow_y_hidden |=\n      !InnerViewportScrollLayer()->user_scrollable_vertical();\n\n  metadata.root_scroll_offset =\n      gfx::ScrollOffsetToVector2dF(active_tree_->TotalScrollOffset());\n\n  return metadata;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7854, "func": "static void migration_end(void)\n{\n    if (migration_bitmap) {\n        memory_global_dirty_log_stop();\n        g_free(migration_bitmap);\n        migration_bitmap = NULL;\n    }\n\n    XBZRLE_cache_lock();\n    if (XBZRLE.cache) {\n        cache_fini(XBZRLE.cache);\n        g_free(XBZRLE.encoded_buf);\n        g_free(XBZRLE.current_buf);\n        XBZRLE.cache = NULL;\n        XBZRLE.encoded_buf = NULL;\n        XBZRLE.current_buf = NULL;\n    }\n    XBZRLE_cache_unlock();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186628, "func": "bool InstallablePaymentAppCrawler::CompleteAndStorePaymentWebAppInfoIfValid(\n    const GURL& method_manifest_url,\n    const GURL& web_app_manifest_url,\n    std::unique_ptr<WebAppInstallationInfo> app_info) {\n  if (app_info == nullptr)\n    return false;\n\n  if (app_info->sw_js_url.empty() || !base::IsStringUTF8(app_info->sw_js_url)) {\n    WarnIfPossible(\n        \"The installable payment app's js url is not a non-empty UTF8 string.\");\n    return false;\n  }\n\n  if (!GURL(app_info->sw_js_url).is_valid()) {\n    GURL absolute_url = web_app_manifest_url.Resolve(app_info->sw_js_url);\n    if (!absolute_url.is_valid()) {\n      WarnIfPossible(\n          \"Failed to resolve the installable payment app's js url (\" +\n           app_info->sw_js_url + \").\");\n       return false;\n     }\n     app_info->sw_js_url = absolute_url.spec();\n   }\n \n  if (!GURL(app_info->sw_scope).is_valid()) {\n    GURL absolute_scope =\n        web_app_manifest_url.GetWithoutFilename().Resolve(app_info->sw_scope);\n    if (!absolute_scope.is_valid()) {\n      WarnIfPossible(\n          \"Failed to resolve the installable payment app's registration \"\n          \"scope (\" +\n           app_info->sw_scope + \").\");\n       return false;\n     }\n     app_info->sw_scope = absolute_scope.spec();\n   }\n \n  std::string error_message;\n  if (!content::PaymentAppProvider::GetInstance()->IsValidInstallablePaymentApp(\n          web_app_manifest_url, GURL(app_info->sw_js_url),\n          GURL(app_info->sw_scope), &error_message)) {\n    WarnIfPossible(error_message);\n    return false;\n  }\n\n  if (installable_apps_.find(method_manifest_url) != installable_apps_.end())\n    return false;\n\n  installable_apps_[method_manifest_url] = std::move(app_info);\n\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7590, "func": "static uint8_t cirrus_mmio_blt_read(CirrusVGAState * s, unsigned address)\n{\n    int value = 0xff;\n\n    switch (address) {\n    case (CIRRUS_MMIO_BLTBGCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x00);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x10);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x12);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 3):\n\tvalue = cirrus_vga_read_gr(s, 0x14);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x01);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x11);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x13);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 3):\n\tvalue = cirrus_vga_read_gr(s, 0x15);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x20);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x21);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x22);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x23);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x24);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x25);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x26);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x27);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x28);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x29);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x2a);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x2c);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x2d);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x2e);\n\tbreak;\n    case CIRRUS_MMIO_BLTWRITEMASK:\n\tvalue = cirrus_vga_read_gr(s, 0x2f);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODE:\n\tvalue = cirrus_vga_read_gr(s, 0x30);\n\tbreak;\n    case CIRRUS_MMIO_BLTROP:\n\tvalue = cirrus_vga_read_gr(s, 0x32);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODEEXT:\n\tvalue = cirrus_vga_read_gr(s, 0x33);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x34);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x35);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x38);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x39);\n\tbreak;\n    case CIRRUS_MMIO_BLTSTATUS:\n\tvalue = cirrus_vga_read_gr(s, 0x31);\n\tbreak;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: mmio read - address 0x%04x\\n\", address);\n#endif\n\tbreak;\n    }\n\n    return (uint8_t) value;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7982, "func": "static void reset_keys(VncState *vs)\n{\n    int i;\n    for(i = 0; i < 256; i++) {\n        if (vs->modifiers_state[i]) {\n            qemu_input_event_send_key_number(vs->vd->dcl.con, i, false);\n            vs->modifiers_state[i] = 0;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7640, "func": "static int proxy_open(FsContext *ctx, V9fsPath *fs_path,\n                      int flags, V9fsFidOpenState *fs)\n{\n    fs->fd = v9fs_request(ctx->private, T_OPEN, NULL, fs_path, flags);\n    if (fs->fd < 0) {\n        errno = -fs->fd;\n        fs->fd = -1;\n    }\n    return fs->fd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186739, "func": " void NetworkHandler::SetNetworkConditions(\n     network::mojom::NetworkConditionsPtr conditions) {\n  if (!process_)\n     return;\n  StoragePartition* partition = process_->GetStoragePartition();\n  network::mojom::NetworkContext* context = partition->GetNetworkContext();\n   context->SetNetworkConditions(host_id_, std::move(conditions));\n }\n", "target": 1, "flaw_line_index": "3,5,6"}
{"idx": 186462, "func": "HistogramBase* SparseHistogram::FactoryGet(const std::string& name,\n                                           int32_t flags) {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);\n  if (!histogram) {\n    PersistentMemoryAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  \n      DCHECK(!allocator);      \n      flags &= ~HistogramBase::kIsPersistent;\n      tentative_histogram.reset(new SparseHistogram(name));\n      tentative_histogram->SetFlags(flags);\n    }\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n   return histogram;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187131, "func": "bool MediaElementAudioSourceHandler::PassesCORSAccessCheck() {\n  DCHECK(MediaElement());\n  return (MediaElement()->GetWebMediaPlayer() &&\n          MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n         passes_current_src_cors_access_check_;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7450, "func": "ZEND_API int zend_ts_hash_find(TsHashTable *ht, char *arKey, uint nKeyLength, void **pData)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_find(TS_HASH(ht), arKey, nKeyLength, pData);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186486, "func": "TabGroupData::TabGroupData() {\n  static int next_placeholder_title_number = 1;\n  title_ = base::ASCIIToUTF16(\n      \"Group \" + base::NumberToString(next_placeholder_title_number));\n   ++next_placeholder_title_number;\n \n   static SkRandom rand;\n  stroke_color_ = rand.nextU() | 0xff000000;\n }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 187195, "func": " void WebBluetoothServiceImpl::ClearState() {\n   characteristic_id_to_notify_session_.clear();\n   pending_primary_services_requests_.clear();\n   descriptor_id_to_characteristic_id_.clear();\n  characteristic_id_to_service_id_.clear();\n  service_id_to_device_address_.clear();\n  connected_devices_.reset(\n      new FrameConnectedBluetoothDevices(render_frame_host_));\n  device_chooser_controller_.reset();\n  BluetoothAdapterFactoryWrapper::Get().ReleaseAdapter(this);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186934, "func": "bool ChromeContentBrowserClientExtensionsPart::ShouldAllowOpenURL(\n    content::SiteInstance* site_instance,\n    const GURL& to_url,\n    bool* result) {\n  DCHECK(result);\n\n  url::Origin to_origin(to_url);\n  if (to_origin.scheme() != kExtensionScheme) {\n    return false;\n  }\n\n\n  ExtensionRegistry* registry =\n      ExtensionRegistry::Get(site_instance->GetBrowserContext());\n   const Extension* to_extension =\n       registry->enabled_extensions().GetByID(to_origin.host());\n   if (!to_extension) {\n    *result = true;\n     return true;\n   }\n \n  GURL site_url(site_instance->GetSiteURL());\n  const Extension* from_extension =\n      registry->enabled_extensions().GetExtensionOrAppByURL(site_url);\n  if (from_extension && from_extension == to_extension) {\n    *result = true;\n    return true;\n  }\n\n  if (to_url.SchemeIsFileSystem() || to_url.SchemeIsBlob()) {\n    if (to_url.SchemeIsFileSystem())\n      RecordShouldAllowOpenURLFailure(FAILURE_FILE_SYSTEM_URL, site_url);\n    else\n      RecordShouldAllowOpenURLFailure(FAILURE_BLOB_URL, site_url);\n\n    char site_url_copy[256];\n    base::strlcpy(site_url_copy, site_url.spec().c_str(),\n                  arraysize(site_url_copy));\n    base::debug::Alias(&site_url_copy);\n    char to_origin_copy[256];\n    base::strlcpy(to_origin_copy, to_origin.Serialize().c_str(),\n                  arraysize(to_origin_copy));\n    base::debug::Alias(&to_origin_copy);\n    base::debug::DumpWithoutCrashing();\n\n    *result = false;\n    return true;\n  }\n\n  if (site_url.SchemeIs(content::kChromeUIScheme) ||\n      site_url.SchemeIs(content::kChromeDevToolsScheme) ||\n      site_url.SchemeIs(chrome::kChromeSearchScheme)) {\n    *result = true;\n    return true;\n  }\n\n  if (site_url.SchemeIs(content::kGuestScheme)) {\n    *result = true;\n    return true;\n  }\n\n  if (WebAccessibleResourcesInfo::IsResourceWebAccessible(to_extension,\n                                                          to_url.path())) {\n    *result = true;\n    return true;\n  }\n\n  if (!site_url.SchemeIsHTTPOrHTTPS() && !site_url.SchemeIs(kExtensionScheme)) {\n    RecordShouldAllowOpenURLFailure(\n        FAILURE_SCHEME_NOT_HTTP_OR_HTTPS_OR_EXTENSION, site_url);\n  } else {\n    RecordShouldAllowOpenURLFailure(FAILURE_RESOURCE_NOT_WEB_ACCESSIBLE,\n                                    site_url);\n  }\n\n  *result = false;\n  return true;\n}\n", "target": 1, "flaw_line_index": "24"}
{"idx": 186421, "func": "     DidStartNavigationToPendingEntry(const GURL& url,\n                                      content::ReloadType reload_type) {\n  devtools_bindings_->frontend_host_.reset(\n      content::DevToolsFrontendHost::Create(\n          web_contents()->GetMainFrame(),\n          base::Bind(&DevToolsUIBindings::HandleMessageFromDevToolsFrontend,\n                     base::Unretained(devtools_bindings_))));\n }\n", "target": 1, "flaw_line_index": "3,4,5,6,7"}
{"idx": 7407, "func": "static void begin_read(TsHashTable *ht)\n{\n#ifdef ZTS\n\ttsrm_mutex_lock(ht->mx_reader);\n\tif ((++(ht->reader)) == 1) {\n\t\ttsrm_mutex_lock(ht->mx_writer);\n\t}\n\ttsrm_mutex_unlock(ht->mx_reader);\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8205, "func": "void pdu_free(V9fsPDU *pdu)\n{\n    if (pdu) {\n        V9fsState *s = pdu->s;\n        if (!pdu->cancelled) {\n            QLIST_REMOVE(pdu, next);\n            QLIST_INSERT_HEAD(&s->free_list, pdu, next);\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187291, "func": "AutomationInternalCustomBindings::AutomationInternalCustomBindings(\n    ScriptContext* context)\n    : ObjectBackedNativeHandler(context),\n      is_active_profile_(true),\n      tree_change_observer_overall_filter_(\n          api::automation::TREE_CHANGE_OBSERVER_FILTER_NOTREECHANGES) {\n  #define ROUTE_FUNCTION(FN) \\\n  RouteFunction(#FN, \\\n                 base::Bind(&AutomationInternalCustomBindings::FN, \\\n                base::Unretained(this)))\n   ROUTE_FUNCTION(IsInteractPermitted);\n   ROUTE_FUNCTION(GetSchemaAdditions);\n   ROUTE_FUNCTION(GetRoutingID);\n  ROUTE_FUNCTION(StartCachingAccessibilityTrees);\n  ROUTE_FUNCTION(DestroyAccessibilityTree);\n  ROUTE_FUNCTION(AddTreeChangeObserver);\n  ROUTE_FUNCTION(RemoveTreeChangeObserver);\n  ROUTE_FUNCTION(GetChildIDAtIndex);\n  ROUTE_FUNCTION(GetFocus);\n  ROUTE_FUNCTION(GetState);\n  #undef ROUTE_FUNCTION\n\n\n  RouteTreeIDFunction(\n      \"GetRootID\", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n                      TreeCache* cache) {\n        result.Set(v8::Integer::New(isolate, cache->tree.root()->id()));\n      });\n  RouteTreeIDFunction(\n      \"GetDocURL\", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n                      TreeCache* cache) {\n        result.Set(\n            v8::String::NewFromUtf8(isolate, cache->tree.data().url.c_str()));\n      });\n  RouteTreeIDFunction(\n      \"GetDocTitle\", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n                        TreeCache* cache) {\n        result.Set(\n            v8::String::NewFromUtf8(isolate, cache->tree.data().title.c_str()));\n      });\n  RouteTreeIDFunction(\n      \"GetDocLoaded\", [](v8::Isolate* isolate,\n                         v8::ReturnValue<v8::Value> result, TreeCache* cache) {\n        result.Set(v8::Boolean::New(isolate, cache->tree.data().loaded));\n      });\n  RouteTreeIDFunction(\"GetDocLoadingProgress\",\n                      [](v8::Isolate* isolate,\n                         v8::ReturnValue<v8::Value> result, TreeCache* cache) {\n                        result.Set(v8::Number::New(\n                            isolate, cache->tree.data().loading_progress));\n                      });\n  RouteTreeIDFunction(\"GetAnchorObjectID\",\n                      [](v8::Isolate* isolate,\n                         v8::ReturnValue<v8::Value> result, TreeCache* cache) {\n                        result.Set(v8::Number::New(\n                            isolate, cache->tree.data().sel_anchor_object_id));\n                      });\n  RouteTreeIDFunction(\"GetAnchorOffset\", [](v8::Isolate* isolate,\n                                            v8::ReturnValue<v8::Value> result,\n                                            TreeCache* cache) {\n    result.Set(v8::Number::New(isolate, cache->tree.data().sel_anchor_offset));\n  });\n  RouteTreeIDFunction(\"GetFocusObjectID\",\n                      [](v8::Isolate* isolate,\n                         v8::ReturnValue<v8::Value> result, TreeCache* cache) {\n                        result.Set(v8::Number::New(\n                            isolate, cache->tree.data().sel_focus_object_id));\n                      });\n  RouteTreeIDFunction(\"GetFocusOffset\", [](v8::Isolate* isolate,\n                                           v8::ReturnValue<v8::Value> result,\n                                           TreeCache* cache) {\n    result.Set(v8::Number::New(isolate, cache->tree.data().sel_focus_offset));\n  });\n\n\n  RouteNodeIDFunction(\n      \"GetParentID\", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n                        TreeCache* cache, ui::AXNode* node) {\n        if (node->parent())\n          result.Set(v8::Integer::New(isolate, node->parent()->id()));\n      });\n  RouteNodeIDFunction(\"GetChildCount\", [](v8::Isolate* isolate,\n                                          v8::ReturnValue<v8::Value> result,\n                                          TreeCache* cache, ui::AXNode* node) {\n    result.Set(v8::Integer::New(isolate, node->child_count()));\n  });\n  RouteNodeIDFunction(\n      \"GetIndexInParent\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         TreeCache* cache, ui::AXNode* node) {\n        result.Set(v8::Integer::New(isolate, node->index_in_parent()));\n      });\n  RouteNodeIDFunction(\n      \"GetRole\", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n                    TreeCache* cache, ui::AXNode* node) {\n        std::string role_name = ui::ToString(node->data().role);\n        result.Set(v8::String::NewFromUtf8(isolate, role_name.c_str()));\n      });\n  RouteNodeIDFunction(\n      \"GetLocation\", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n                        TreeCache* cache, ui::AXNode* node) {\n        gfx::Rect location = ComputeGlobalNodeBounds(cache, node);\n        location.Offset(cache->location_offset);\n        result.Set(RectToV8Object(isolate, location));\n      });\n\n\n  RouteNodeIDPlusRangeFunction(\n      \"GetBoundsForRange\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         TreeCache* cache, ui::AXNode* node, int start, int end) {\n        gfx::Rect location = ComputeGlobalNodeBounds(cache, node);\n        location.Offset(cache->location_offset);\n        if (node->data().role == ui::AX_ROLE_INLINE_TEXT_BOX) {\n          std::string name = node->data().GetStringAttribute(ui::AX_ATTR_NAME);\n          std::vector<int> character_offsets =\n              node->data().GetIntListAttribute(ui::AX_ATTR_CHARACTER_OFFSETS);\n          int len =\n              static_cast<int>(std::min(name.size(), character_offsets.size()));\n          if (start >= 0 && start <= end && end <= len) {\n            int start_offset = start > 0 ? character_offsets[start - 1] : 0;\n            int end_offset = end > 0 ? character_offsets[end - 1] : 0;\n\n            switch (node->data().GetIntAttribute(ui::AX_ATTR_TEXT_DIRECTION)) {\n              case ui::AX_TEXT_DIRECTION_LTR:\n              default:\n                location.set_x(location.x() + start_offset);\n                location.set_width(end_offset - start_offset);\n                break;\n              case ui::AX_TEXT_DIRECTION_RTL:\n                location.set_x(location.x() + location.width() - end_offset);\n                location.set_width(end_offset - start_offset);\n                break;\n              case ui::AX_TEXT_DIRECTION_TTB:\n                location.set_y(location.y() + start_offset);\n                location.set_height(end_offset - start_offset);\n                break;\n              case ui::AX_TEXT_DIRECTION_BTT:\n                location.set_y(location.y() + location.height() - end_offset);\n                location.set_height(end_offset - start_offset);\n                break;\n            }\n          }\n        }\n        result.Set(RectToV8Object(isolate, location));\n      });\n\n\n  RouteNodeIDPlusAttributeFunction(\n      \"GetStringAttribute\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         ui::AXNode* node, const std::string& attribute_name) {\n        ui::AXStringAttribute attribute =\n            ui::ParseAXStringAttribute(attribute_name);\n        std::string attr_value;\n        if (!node->data().GetStringAttribute(attribute, &attr_value))\n          return;\n\n        result.Set(v8::String::NewFromUtf8(isolate, attr_value.c_str()));\n      });\n  RouteNodeIDPlusAttributeFunction(\n      \"GetBoolAttribute\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         ui::AXNode* node, const std::string& attribute_name) {\n        ui::AXBoolAttribute attribute =\n            ui::ParseAXBoolAttribute(attribute_name);\n        bool attr_value;\n        if (!node->data().GetBoolAttribute(attribute, &attr_value))\n          return;\n\n        result.Set(v8::Boolean::New(isolate, attr_value));\n      });\n  RouteNodeIDPlusAttributeFunction(\n      \"GetIntAttribute\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         ui::AXNode* node, const std::string& attribute_name) {\n        ui::AXIntAttribute attribute = ui::ParseAXIntAttribute(attribute_name);\n        int attr_value;\n        if (!node->data().GetIntAttribute(attribute, &attr_value))\n          return;\n\n        result.Set(v8::Integer::New(isolate, attr_value));\n      });\n  RouteNodeIDPlusAttributeFunction(\n      \"GetFloatAttribute\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         ui::AXNode* node, const std::string& attribute_name) {\n        ui::AXFloatAttribute attribute =\n            ui::ParseAXFloatAttribute(attribute_name);\n        float attr_value;\n\n        if (!node->data().GetFloatAttribute(attribute, &attr_value))\n          return;\n\n        result.Set(v8::Number::New(isolate, attr_value));\n      });\n  RouteNodeIDPlusAttributeFunction(\n      \"GetIntListAttribute\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         ui::AXNode* node, const std::string& attribute_name) {\n        ui::AXIntListAttribute attribute =\n            ui::ParseAXIntListAttribute(attribute_name);\n        if (!node->data().HasIntListAttribute(attribute))\n          return;\n        const std::vector<int32_t>& attr_value =\n            node->data().GetIntListAttribute(attribute);\n\n        v8::Local<v8::Array> array_result(\n            v8::Array::New(isolate, attr_value.size()));\n        for (size_t i = 0; i < attr_value.size(); ++i)\n          array_result->Set(static_cast<uint32_t>(i),\n                            v8::Integer::New(isolate, attr_value[i]));\n        result.Set(array_result);\n      });\n  RouteNodeIDPlusAttributeFunction(\n      \"GetHtmlAttribute\",\n      [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,\n         ui::AXNode* node, const std::string& attribute_name) {\n        std::string attr_value;\n        if (!node->data().GetHtmlAttribute(attribute_name.c_str(), &attr_value))\n          return;\n\n        result.Set(v8::String::NewFromUtf8(isolate, attr_value.c_str()));\n      });\n}\n", "target": 1, "flaw_line_index": "10,11,13"}
{"idx": 7444, "func": "ZEND_API void zend_ts_hash_copy(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, void *tmp, uint size)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_copy(TS_HASH(target), TS_HASH(source), pCopyConstructor, tmp, size);\n\tend_write(target);\n\tend_read(source);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7485, "func": "int pt_setxattr(FsContext *ctx, const char *path, const char *name, void *value,\n                size_t size, int flags)\n{\n    return local_setxattr_nofollow(ctx, path, name, value, size, flags);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186990, "func": "bool DoCanonicalizePathURL(const URLComponentSource<CHAR>& source,\n                           const Parsed& parsed,\n                           CanonOutput* output,\n                           Parsed* new_parsed) {\n  bool success = CanonicalizeScheme(source.scheme, parsed.scheme,\n                                    output, &new_parsed->scheme);\n\n  new_parsed->username.reset();\n  new_parsed->password.reset();\n  new_parsed->host.reset();\n   new_parsed->port.reset();\n  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(\n      source.path, parsed.path, '\\0', output, &new_parsed->path);\n  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(\n      source.query, parsed.query, '?', output, &new_parsed->query);\n  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(\n      source.ref, parsed.ref, '#', output, &new_parsed->ref);\n \n   return success;\n }\n", "target": 1, "flaw_line_index": "17,18,19,20,21"}
{"idx": 7965, "func": "static void kbd_leds(void *opaque, int ledstate)\n{\n    VncState *vs = opaque;\n    int caps, num, scr;\n    bool has_changed = (ledstate != current_led_state(vs));\n\n    trace_vnc_key_guest_leds((ledstate & QEMU_CAPS_LOCK_LED),\n                             (ledstate & QEMU_NUM_LOCK_LED),\n                             (ledstate & QEMU_SCROLL_LOCK_LED));\n\n    caps = ledstate & QEMU_CAPS_LOCK_LED ? 1 : 0;\n    num  = ledstate & QEMU_NUM_LOCK_LED  ? 1 : 0;\n    scr  = ledstate & QEMU_SCROLL_LOCK_LED ? 1 : 0;\n\n    if (vs->modifiers_state[0x3a] != caps) {\n        vs->modifiers_state[0x3a] = caps;\n    }\n    if (vs->modifiers_state[0x45] != num) {\n        vs->modifiers_state[0x45] = num;\n    }\n    if (vs->modifiers_state[0x46] != scr) {\n        vs->modifiers_state[0x46] = scr;\n    }\n\n    if (has_changed) {\n        vnc_led_state_change(vs);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186816, "func": " bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  if (shared_buffer_handle_.is_valid())\n     return true;\n \n  shared_buffer_handle_ =\n      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n  return shared_buffer_handle_.is_valid();\n }\n", "target": 1, "flaw_line_index": "3,6,7,8"}
{"idx": 7897, "func": "static void carray(JF, js_Ast *list)\n{\n\tint i = 0;\n\twhile (list) {\n\t\tif (list->a->type != EXP_UNDEF) {\n\t\t\temitnumber(J, F, i++);\n\t\t\tcexp(J, F, list->a);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7538, "func": "equal_tm (const struct tm *a, const struct tm *b)\n{\n  return ! ((a->tm_sec ^ b->tm_sec)\n            | (a->tm_min ^ b->tm_min)\n            | (a->tm_hour ^ b->tm_hour)\n            | (a->tm_mday ^ b->tm_mday)\n            | (a->tm_mon ^ b->tm_mon)\n            | (a->tm_year ^ b->tm_year)\n            | isdst_differ (a->tm_isdst, b->tm_isdst));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186527, "func": " void DataReductionProxySettings::SetDataReductionProxyEnabled(bool enabled) {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   DCHECK(data_reduction_proxy_service_->compression_stats());\n  if (spdy_proxy_auth_enabled_.GetValue() != enabled) {\n    spdy_proxy_auth_enabled_.SetValue(enabled);\n     OnProxyEnabledPrefChange();\n #if defined(OS_ANDROID)\n     data_reduction_proxy_service_->compression_stats()\n        ->SetDataUsageReportingEnabled(enabled);\n#endif  \n  }\n}\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 7947, "func": "static char *addr_to_string(const char *format,\n                            struct sockaddr_storage *sa,\n                            socklen_t salen) {\n    char *addr;\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    int err;\n    size_t addrlen;\n\n    if ((err = getnameinfo((struct sockaddr *)sa, salen,\n                           host, sizeof(host),\n                           serv, sizeof(serv),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        VNC_DEBUG(\"Cannot resolve address %d: %s\\n\",\n                  err, gai_strerror(err));\n        return NULL;\n    }\n\n    addrlen = strlen(format) + strlen(host) + strlen(serv);\n    addr = g_malloc(addrlen + 1);\n    snprintf(addr, addrlen, format, host, serv);\n    addr[addrlen] = '\\0';\n\n    return addr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8067, "func": "int Gfx::bottomGuard() {\n    return stateGuards[stateGuards.size()-1];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7449, "func": "ZEND_API int zend_ts_hash_exists(TsHashTable *ht, char *arKey, uint nKeyLength)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_exists(TS_HASH(ht), arKey, nKeyLength);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7944, "func": "static int matchlabel(js_Ast *node, const char *label)\n{\n\twhile (node && node->type == STM_LABEL) {\n\t\tif (!strcmp(node->a->string, label))\n\t\t\treturn 1;\n\t\tnode = node->parent;\n\t}\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7892, "func": "static int addnumber(JF, double value)\n{\n\tint i;\n\tfor (i = 0; i < F->numlen; ++i)\n\t\tif (F->numtab[i] == value)\n\t\t\treturn i;\n\tif (F->numlen >= F->numcap) {\n\t\tF->numcap = F->numcap ? F->numcap * 2 : 16;\n\t\tF->numtab = js_realloc(J, F->numtab, F->numcap * sizeof *F->numtab);\n\t}\n\tF->numtab[F->numlen] = value;\n\treturn F->numlen++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186374, "func": "void InputEngine::ProcessText(const std::string& message,\n                              ProcessTextCallback callback) {\n  NOTIMPLEMENTED();  \n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 186362, "func": "LayerTreeHost::LayerTreeHost(InitParams* params, CompositorMode mode)\n    : micro_benchmark_controller_(this),\n      image_worker_task_runner_(params->image_worker_task_runner),\n      compositor_mode_(mode),\n      ui_resource_manager_(base::MakeUnique<UIResourceManager>()),\n      client_(params->client),\n      rendering_stats_instrumentation_(RenderingStatsInstrumentation::Create()),\n      settings_(*params->settings),\n       debug_state_(settings_.initial_debug_state),\n       id_(s_layer_tree_host_sequence_number.GetNext() + 1),\n       task_graph_runner_(params->task_graph_runner),\n       event_listener_properties_(),\n       mutator_host_(params->mutator_host) {\n   DCHECK(task_graph_runner_);\n  DCHECK(!settings_.enable_checker_imaging || image_worker_task_runner_);\n  DCHECK(!settings_.enable_checker_imaging ||\n         settings_.image_decode_tasks_enabled);\n\n  mutator_host_->SetMutatorHostClient(this);\n\n  rendering_stats_instrumentation_->set_record_rendering_stats(\n      debug_state_.RecordRenderingStats());\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186415, "func": " bool FakeCentral::IsPowered() const {\n   switch (state_) {\n     case mojom::CentralState::POWERED_OFF:\n       return false;\n     case mojom::CentralState::POWERED_ON:\n       return true;\n    case mojom::CentralState::ABSENT:\n      NOTREACHED();\n      return false;\n   }\n   NOTREACHED();\n   return false;\n}\n", "target": 1, "flaw_line_index": "7,8,9,10"}
{"idx": 187208, "func": "FileReaderLoader::FileReaderLoader(ReadType read_type,\n                                   FileReaderLoaderClient* client)\n    : read_type_(read_type),\n      client_(client),\n       handle_watcher_(FROM_HERE, mojo::SimpleWatcher::ArmingPolicy::AUTOMATIC),\n      binding_(this) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7433, "func": "ZEND_API zval *zend_ts_hash_str_find(TsHashTable *ht, const char *key, size_t len)\n{\n\tzval *retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_str_find(TS_HASH(ht), key, len);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8087, "func": "void Gfx::doTilingPatternFill(GfxTilingPattern *tPat,\n\t\t\t      GBool stroke, GBool eoFill) {\n  GfxPatternColorSpace *patCS;\n  GfxColorSpace *cs;\n  GfxColor color;\n  GfxPath *savedPath;\n  double xMin, yMin, xMax, yMax, x, y, x1, y1;\n  double cxMin, cyMin, cxMax, cyMax;\n  int xi0, yi0, xi1, yi1, xi, yi;\n  double *ctm, *btm, *ptm;\n  double m[6], ictm[6], m1[6], imb[6];\n  double det;\n  double xstep, ystep;\n  int i;\n\n  patCS = (GfxPatternColorSpace *)(stroke ? state->getStrokeColorSpace()\n\t\t\t\t          : state->getFillColorSpace());\n\n  ctm = state->getCTM();\n  btm = baseMatrix;\n  ptm = tPat->getMatrix();\n  det = 1 / (ctm[0] * ctm[3] - ctm[1] * ctm[2]);\n  ictm[0] = ctm[3] * det;\n  ictm[1] = -ctm[1] * det;\n  ictm[2] = -ctm[2] * det;\n  ictm[3] = ctm[0] * det;\n  ictm[4] = (ctm[2] * ctm[5] - ctm[3] * ctm[4]) * det;\n  ictm[5] = (ctm[1] * ctm[4] - ctm[0] * ctm[5]) * det;\n  m1[0] = ptm[0] * btm[0] + ptm[1] * btm[2];\n  m1[1] = ptm[0] * btm[1] + ptm[1] * btm[3];\n  m1[2] = ptm[2] * btm[0] + ptm[3] * btm[2];\n  m1[3] = ptm[2] * btm[1] + ptm[3] * btm[3];\n  m1[4] = ptm[4] * btm[0] + ptm[5] * btm[2] + btm[4];\n  m1[5] = ptm[4] * btm[1] + ptm[5] * btm[3] + btm[5];\n  m[0] = m1[0] * ictm[0] + m1[1] * ictm[2];\n  m[1] = m1[0] * ictm[1] + m1[1] * ictm[3];\n  m[2] = m1[2] * ictm[0] + m1[3] * ictm[2];\n  m[3] = m1[2] * ictm[1] + m1[3] * ictm[3];\n  m[4] = m1[4] * ictm[0] + m1[5] * ictm[2] + ictm[4];\n  m[5] = m1[4] * ictm[1] + m1[5] * ictm[3] + ictm[5];\n\n  det = 1 / (m1[0] * m1[3] - m1[1] * m1[2]);\n  imb[0] = m1[3] * det;\n  imb[1] = -m1[1] * det;\n  imb[2] = -m1[2] * det;\n  imb[3] = m1[0] * det;\n  imb[4] = (m1[2] * m1[5] - m1[3] * m1[4]) * det;\n  imb[5] = (m1[1] * m1[4] - m1[0] * m1[5]) * det;\n\n  savedPath = state->getPath()->copy();\n  saveState();\n\n  if (tPat->getPaintType() == 2 && (cs = patCS->getUnder())) {\n    state->setFillColorSpace(cs->copy());\n    out->updateFillColorSpace(state);\n    state->setStrokeColorSpace(cs->copy());\n    out->updateStrokeColorSpace(state);\n    if (stroke) {\n\tstate->setFillColor(state->getStrokeColor());\n    } else {\n\tstate->setStrokeColor(state->getFillColor());\n    }\n  } else {\n    cs = new GfxDeviceGrayColorSpace();\n    state->setFillColorSpace(cs);\n    cs->getDefaultColor(&color);\n    state->setFillColor(&color);\n    out->updateFillColorSpace(state);\n    state->setStrokeColorSpace(new GfxDeviceGrayColorSpace());\n    state->setStrokeColor(&color);\n    out->updateStrokeColorSpace(state);\n  }\n  state->setFillPattern(NULL);\n  out->updateFillColor(state);\n  state->setStrokePattern(NULL);\n  out->updateStrokeColor(state);\n\n  if (stroke) {\n    state->clipToStrokePath();\n    out->clipToStrokePath(state);\n  } else if (!textHaveCSPattern && !maskHaveCSPattern) {\n    state->clip();\n    if (eoFill) {\n      out->eoClip(state);\n    } else {\n      out->clip(state);\n    }\n  }\n  state->clearPath();\n  state->setLineWidth(0);\n  out->updateLineWidth(state);\n\n  state->getClipBBox(&cxMin, &cyMin, &cxMax, &cyMax);\n  if (cxMin > cxMax || cyMin > cyMax) {\n    goto restore;\n  }\n\n  xMin = xMax = cxMin * imb[0] + cyMin * imb[2] + imb[4];\n  yMin = yMax = cxMin * imb[1] + cyMin * imb[3] + imb[5];\n  x1 = cxMin * imb[0] + cyMax * imb[2] + imb[4];\n  y1 = cxMin * imb[1] + cyMax * imb[3] + imb[5];\n  if (x1 < xMin) {\n    xMin = x1;\n  } else if (x1 > xMax) {\n    xMax = x1;\n  }\n  if (y1 < yMin) {\n    yMin = y1;\n  } else if (y1 > yMax) {\n    yMax = y1;\n  }\n  x1 = cxMax * imb[0] + cyMin * imb[2] + imb[4];\n  y1 = cxMax * imb[1] + cyMin * imb[3] + imb[5];\n  if (x1 < xMin) {\n    xMin = x1;\n  } else if (x1 > xMax) {\n    xMax = x1;\n  }\n  if (y1 < yMin) {\n    yMin = y1;\n  } else if (y1 > yMax) {\n    yMax = y1;\n  }\n  x1 = cxMax * imb[0] + cyMax * imb[2] + imb[4];\n  y1 = cxMax * imb[1] + cyMax * imb[3] + imb[5];\n  if (x1 < xMin) {\n    xMin = x1;\n  } else if (x1 > xMax) {\n    xMax = x1;\n  }\n  if (y1 < yMin) {\n    yMin = y1;\n  } else if (y1 > yMax) {\n    yMax = y1;\n  }\n\n  xstep = fabs(tPat->getXStep());\n  ystep = fabs(tPat->getYStep());\n  xi0 = (int)ceil((xMin - tPat->getBBox()[2]) / xstep);\n  xi1 = (int)floor((xMax - tPat->getBBox()[0]) / xstep) + 1;\n  yi0 = (int)ceil((yMin - tPat->getBBox()[3]) / ystep);\n  yi1 = (int)floor((yMax - tPat->getBBox()[1]) / ystep) + 1;\n  for (i = 0; i < 4; ++i) {\n    m1[i] = m[i];\n  }\n  if (!contentIsHidden()) {\n    m1[4] = m[4];\n    m1[5] = m[5];\n    if (out->useTilingPatternFill() &&\n\tout->tilingPatternFill(state, tPat->getContentStream(),\n\t\t\t       tPat->getPaintType(), tPat->getResDict(),\n\t\t\t       m1, tPat->getBBox(),\n\t\t\t       xi0, yi0, xi1, yi1, xstep, ystep)) {\n\t    goto restore;\n    } else {\n      for (yi = yi0; yi < yi1; ++yi) {\n        for (xi = xi0; xi < xi1; ++xi) {\n\t  x = xi * xstep;\n\t  y = yi * ystep;\n\t  m1[4] = x * m[0] + y * m[2] + m[4];\n\t  m1[5] = x * m[1] + y * m[3] + m[5];\n\t  doForm1(tPat->getContentStream(), tPat->getResDict(),\n\t\t  m1, tPat->getBBox());\n\t}\n      }\n    }\n  }\n\n restore:\n  restoreState();\n  state->setPath(savedPath);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186948, "func": "void AppCache::InitializeWithDatabaseRecords(\n    const AppCacheDatabase::CacheRecord& cache_record,\n    const std::vector<AppCacheDatabase::EntryRecord>& entries,\n     const std::vector<AppCacheDatabase::NamespaceRecord>& intercepts,\n     const std::vector<AppCacheDatabase::NamespaceRecord>& fallbacks,\n     const std::vector<AppCacheDatabase::OnlineWhiteListRecord>& whitelists) {\n  DCHECK(cache_id_ == cache_record.cache_id);\n   online_whitelist_all_ = cache_record.online_wildcard;\n   update_time_ = cache_record.update_time;\n \n   for (size_t i = 0; i < entries.size(); ++i) {\n     const AppCacheDatabase::EntryRecord& entry = entries.at(i);\n     AddEntry(entry.url, AppCacheEntry(entry.flags, entry.response_id,\n                                      entry.response_size));\n   }\n  DCHECK(cache_size_ == cache_record.cache_size);\n \n   for (size_t i = 0; i < intercepts.size(); ++i)\n     intercept_namespaces_.push_back(intercepts.at(i).namespace_);\n\n  for (size_t i = 0; i < fallbacks.size(); ++i)\n    fallback_namespaces_.push_back(fallbacks.at(i).namespace_);\n\n  std::sort(intercept_namespaces_.begin(), intercept_namespaces_.end(),\n            SortNamespacesByLength);\n  std::sort(fallback_namespaces_.begin(), fallback_namespaces_.end(),\n            SortNamespacesByLength);\n\n  for (size_t i = 0; i < whitelists.size(); ++i) {\n    const AppCacheDatabase::OnlineWhiteListRecord& record = whitelists.at(i);\n    online_whitelist_namespaces_.push_back(\n        AppCacheNamespace(APPCACHE_NETWORK_NAMESPACE,\n                  record.namespace_url,\n                  GURL(),\n                  record.is_pattern));\n  }\n}\n", "target": 1, "flaw_line_index": "7,14,16"}
{"idx": 186867, "func": "ClassicScript* ClassicPendingScript::GetSource(const KURL& document_url,\n                                               bool& error_occurred) const {\n  CheckState();\n  DCHECK(IsReady());\n\n  error_occurred = ErrorOccurred();\n  if (!is_external_) {\n    ScriptSourceCode source_code(\n        GetElement()->TextFromChildren(), source_location_type_,\n        nullptr \n, document_url, StartingPosition());\n    return ClassicScript::Create(source_code, base_url_for_inline_script_,\n                                 options_, kSharableCrossOrigin);\n  }\n\n  DCHECK(GetResource()->IsLoaded());\n  ScriptResource* resource = ToScriptResource(GetResource());\n  bool streamer_ready = (ready_state_ == kReady) && streamer_ &&\n                        !streamer_->StreamingSuppressed();\n  ScriptSourceCode source_code(streamer_ready ? streamer_ : nullptr, resource);\n   const KURL& base_url = source_code.Url();\n  return ClassicScript::Create(source_code, base_url, options_,\n                               resource->CalculateAccessControlStatus());\n }\n", "target": 1, "flaw_line_index": "25"}
{"idx": 8094, "func": "void Gfx::go(GBool topLevel) {\n  Object obj;\n  Object args[maxArgs];\n  int numArgs, i;\n  int lastAbortCheck;\n\n  pushStateGuard();\n  updateLevel = lastAbortCheck = 0;\n  numArgs = 0;\n  parser->getObj(&obj);\n  while (!obj.isEOF()) {\n    commandAborted = gFalse;\n\n    if (obj.isCmd()) {\n      if (printCommands) {\n\tobj.print(stdout);\n\tfor (i = 0; i < numArgs; ++i) {\n\t  printf(\" \");\n\t  args[i].print(stdout);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n      }\n      GooTimer timer;\n\n      execOp(&obj, args, numArgs);\n\n      if (profileCommands) {\n\tGooHash *hash;\n\n\thash = out->getProfileHash ();\n\tif (hash) {\n\t  GooString *cmd_g;\n\t  ProfileData *data_p;\n\n\t  cmd_g = new GooString (obj.getCmd());\n\t  data_p = (ProfileData *)hash->lookup (cmd_g);\n\t  if (data_p == NULL) {\n\t    data_p = new ProfileData();\n\t    hash->add (cmd_g, data_p);\n\t  }\n\t  \n\t  data_p->addElement(timer.getElapsed ());\n\t}\n      }\n      obj.free();\n      for (i = 0; i < numArgs; ++i)\n\targs[i].free();\n      numArgs = 0;\n\n      if (++updateLevel >= 20000) {\n\tout->dump();\n\tupdateLevel = 0;\n      }\n\n      if (commandAborted) {\n\tcommandAborted = gFalse;\n\tbreak;\n      }\n\n      if (abortCheckCbk) {\n\tif (updateLevel - lastAbortCheck > 10) {\n\t  if ((*abortCheckCbk)(abortCheckCbkData)) {\n\t    break;\n\t  }\n\t  lastAbortCheck = updateLevel;\n\t}\n      }\n\n    } else if (numArgs < maxArgs) {\n      args[numArgs++] = obj;\n\n    } else {\n      error(getPos(), \"Too many args in content stream\");\n      if (printCommands) {\n\tprintf(\"throwing away arg: \");\n\tobj.print(stdout);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n      }\n      obj.free();\n    }\n\n    parser->getObj(&obj);\n  }\n  obj.free();\n\n  if (numArgs > 0) {\n    error(getPos(), \"Leftover args in content stream\");\n    if (printCommands) {\n      printf(\"%d leftovers:\", numArgs);\n      for (i = 0; i < numArgs; ++i) {\n\tprintf(\" \");\n\targs[i].print(stdout);\n      }\n      printf(\"\\n\");\n      fflush(stdout);\n    }\n    for (i = 0; i < numArgs; ++i)\n      args[i].free();\n  }\n\n  popStateGuard();\n\n  if (topLevel && updateLevel > 0) {\n    out->dump();\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7454, "func": "ZEND_API int zend_ts_hash_minmax(TsHashTable *ht, compare_func_t compar, int flag, void **pData TSRMLS_DC)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_minmax(TS_HASH(ht), compar, flag, pData TSRMLS_CC);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7458, "func": "ZEND_API int _zend_ts_hash_init_ex(TsHashTable *ht, uint nSize, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection ZEND_FILE_LINE_DC)\n{\n#ifdef ZTS\n\tht->mx_reader = tsrm_mutex_alloc();\n\tht->mx_writer = tsrm_mutex_alloc();\n\tht->reader = 0;\n#endif\n\treturn _zend_hash_init_ex(TS_HASH(ht), nSize, pDestructor, persistent, bApplyProtection ZEND_FILE_LINE_RELAY_CC);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186751, "func": "void StorageHandler::SetRenderer(RenderProcessHost* process_host,\n                                  RenderFrameHostImpl* frame_host) {\n  process_ = process_host;\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7926, "func": "static int emitjump(JF, int opcode)\n{\n\tint inst = F->codelen + 1;\n\temit(J, F, opcode);\n\temitraw(J, F, 0);\n\treturn inst;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187305, "func": "v8::Local<v8::Value> V8ValueConverterImpl::ToV8Array(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> creation_context,\n     const base::ListValue* val) const {\n   v8::Local<v8::Array> result(v8::Array::New(isolate, val->GetSize()));\n \n   for (size_t i = 0; i < val->GetSize(); ++i) {\n     const base::Value* child = NULL;\n     CHECK(val->Get(i, &child));\n\n    v8::Local<v8::Value> child_v8 =\n         ToV8ValueImpl(isolate, creation_context, child);\n     CHECK(!child_v8.IsEmpty());\n \n    v8::TryCatch try_catch(isolate);\n    result->Set(static_cast<uint32_t>(i), child_v8);\n    if (try_catch.HasCaught())\n      LOG(ERROR) << \"Setter for index \" << i << \" threw an exception.\";\n   }\n \n   return result;\n}\n", "target": 1, "flaw_line_index": "15,16,17,18"}
{"idx": 186808, "func": "  void SensorCreated(scoped_refptr<PlatformSensor> sensor) {\n    if (!result_callback_) {\n      return;\n    }\n\n    if (!sensor) {\n      std::move(result_callback_).Run(nullptr);\n      return;\n    }\n    mojom::SensorType type = sensor->GetType();\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n", "target": 1, "flaw_line_index": "17"}
{"idx": 187009, "func": " void OffscreenCanvas::Dispose() {\n   if (context_) {\n     context_->DetachHost();\n     context_ = nullptr;\n  }\n\n  if (HasPlaceholderCanvas() && GetTopExecutionContext() &&\n      GetTopExecutionContext()->IsWorkerGlobalScope()) {\n    WorkerAnimationFrameProvider* animation_frame_provider =\n        To<WorkerGlobalScope>(GetTopExecutionContext())\n            ->GetAnimationFrameProvider();\n    if (animation_frame_provider)\n      animation_frame_provider->DeregisterOffscreenCanvas(this);\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7517, "func": "  tt_size_done( FT_Size  ttsize )           \n  {\n    TT_Size  size = (TT_Size)ttsize;\n\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    tt_size_done_bytecode( ttsize );\n#endif\n\n    size->ttmetrics.valid = FALSE;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186821, "func": " void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n    CreateFusionSensor(type, std::move(mapping), callback);\n     return;\n   }\n \n  if (!sensor_nodes_enumerated_) {\n    if (!sensor_nodes_enumeration_started_) {\n      sensor_nodes_enumeration_started_ = file_task_runner_->PostTask(\n          FROM_HERE,\n          base::Bind(&SensorDeviceManager::Start,\n                     base::Unretained(sensor_device_manager_.get()), this));\n    }\n    return;\n  }\n\n  SensorInfoLinux* sensor_device = GetSensorDevice(type);\n  if (!sensor_device) {\n    callback.Run(nullptr);\n     return;\n   }\n \n  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n }\n", "target": 1, "flaw_line_index": "3,11,31"}
{"idx": 186574, "func": " void AcceleratedStaticBitmapImage::Transfer() {\n  CheckThread();\n   EnsureMailbox(kVerifiedSyncToken, GL_NEAREST);\n  detach_thread_at_next_check_ = true;\n }\n", "target": 1, "flaw_line_index": "2,4"}
{"idx": 187192, "func": "bool SectionHasAutofilledField(const FormStructure& form_structure,\n                               const FormData& form,\n                               const std::string& section) {\n  DCHECK_EQ(form_structure.field_count(), form.fields.size());\n  for (size_t i = 0; i < form_structure.field_count(); ++i) {\n    if (form_structure.field(i)->section == section &&\n        form.fields[i].is_autofilled) {\n      return true;\n    }\n  }\n  return false;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12"}
{"idx": 186988, "func": "bool PermissionsData::CanCaptureVisiblePage(const GURL& document_url,\n                                            int tab_id,\n                                            std::string* error) const {\n   bool has_active_tab = false;\n   bool has_all_urls = false;\n  url::Origin origin = url::Origin::Create(document_url);\n  const GURL origin_url = origin.GetURL();\n  {\n    base::AutoLock auto_lock(runtime_lock_);\n    if (location_ != Manifest::COMPONENT &&\n        IsPolicyBlockedHostUnsafe(origin_url)) {\n      if (error)\n        *error = extension_misc::kPolicyBlockedScripting;\n      return false;\n    }\n\n    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);\n    has_active_tab = tab_permissions &&\n                     tab_permissions->HasAPIPermission(APIPermission::kTab);\n\n    const URLPattern all_urls(URLPattern::SCHEME_ALL,\n                               URLPattern::kAllUrlsPattern);\n     has_all_urls =\n         active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls);\n   }\n \n  if (!has_active_tab && !has_all_urls) {\n    if (error)\n      *error = manifest_errors::kAllURLOrActiveTabNeeded;\n    return false;\n  }\n \n  std::string access_error;\n  if (GetPageAccess(origin_url, tab_id, &access_error) == PageAccess::kAllowed)\n    return true;\n \n \n   if (origin_url.host() == extension_id_)\n    return true;\n\n  bool allowed_with_active_tab =\n      origin_url.SchemeIs(content::kChromeUIScheme) ||\n      origin_url.SchemeIs(kExtensionScheme) ||\n      document_url.SchemeIs(url::kDataScheme) ||\n      origin.IsSameOriginWith(\n          url::Origin::Create(ExtensionsClient::Get()->GetWebstoreBaseURL()));\n\n  if (!allowed_with_active_tab) {\n    if (error)\n       *error = access_error;\n     return false;\n   }\n   if (has_active_tab)\n     return true;\n\n  if (error)\n    *error = manifest_errors::kActiveTabPermissionNotGranted;\n  return false;\n}\n", "target": 1, "flaw_line_index": "2,3,35,36,37,38,39,40,42,43,44,45,46,47,48,49,50,51,52,53,60"}
{"idx": 8072, "func": "void Gfx::display(Object *obj, GBool topLevel) {\n  Object obj2;\n  int i;\n\n  if (obj->isArray()) {\n    for (i = 0; i < obj->arrayGetLength(); ++i) {\n      obj->arrayGet(i, &obj2);\n      if (!obj2.isStream()) {\n\terror(-1, \"Weird page contents\");\n\tobj2.free();\n\treturn;\n      }\n      obj2.free();\n    }\n  } else if (!obj->isStream()) {\n    error(-1, \"Weird page contents\");\n    return;\n  }\n  parser = new Parser(xref, new Lexer(xref, obj), gFalse);\n  go(topLevel);\n  delete parser;\n  parser = NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186682, "func": "bool HeapAllocator::backingExpand(void* address, size_t newSize) {\n  if (!address)\n    return false;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return false;\n  ASSERT(!state->isInGC());\n  ASSERT(state->isAllocationAllowed());\n  DCHECK_EQ(&state->heap(), &ThreadState::fromObject(address)->heap());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return false;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   bool succeed = arena->expandObject(header, newSize);\n   if (succeed)\n    state->allocationPointAdjusted(arena->arenaIndex());\n  return succeed;\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 8198, "func": "static inline void recv_fifo_put(SerialState *s, uint8_t chr)\n{\n    if (!fifo8_is_full(&s->recv_fifo)) {\n        fifo8_push(&s->recv_fifo, chr);\n    } else {\n        s->lsr |= UART_LSR_OE;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187255, "func": "  testing::AssertionResult ScriptAllowedExclusivelyOnTab(\n      const Extension* extension,\n      const std::set<GURL>& allowed_urls,\n       int tab_id) {\n     std::vector<std::string> errors;\n     for (const GURL& url : urls_) {\n      bool allowed = IsAllowedScript(extension, url, tab_id);\n      if (allowed && !allowed_urls.count(url))\n        errors.push_back(\"Script unexpectedly disallowed on \" + url.spec());\n      else if (!allowed && allowed_urls.count(url))\n        errors.push_back(\"Script unexpectedly allowed on \" + url.spec());\n     }\n \n     if (!errors.empty())\n      return testing::AssertionFailure() << base::JoinString(errors, \"\\n\");\n    return testing::AssertionSuccess();\n  }\n", "target": 1, "flaw_line_index": "7,8,9,10,11"}
{"idx": 187262, "func": "bool DebuggerDetachFunction::RunAsync() {\n  std::unique_ptr<Detach::Params> params(Detach::Params::Create(*args_));\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n\n  CopyDebuggee(&debuggee_, params->target);\n   if (!InitClientHost())\n     return false;\n \n   client_host_->Close();\n   SendResponse(true);\n   return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186375, "func": " bool PasswordAutofillAgent::TryToShowTouchToFill(\n     const WebFormControlElement& control_element) {\n   const WebInputElement* element = ToWebInputElement(&control_element);\n  if (!element || (!base::Contains(web_input_to_password_info_, *element) &&\n                   !base::Contains(password_to_username_, *element))) {\n     return false;\n   }\n   if (was_touch_to_fill_ui_shown_)\n    return false;\n  was_touch_to_fill_ui_shown_ = true;\n\n  GetPasswordManagerDriver()->ShowTouchToFill();\n  return true;\n}\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 7683, "func": "static int handle_opendir(FsContext *ctx,\n                          V9fsPath *fs_path, V9fsFidOpenState *fs)\n{\n    int ret;\n    ret = handle_open(ctx, fs_path, O_DIRECTORY, fs);\n    if (ret < 0) {\n        return -1;\n    }\n    fs->dir.stream = fdopendir(ret);\n    if (!fs->dir.stream) {\n        return -1;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186418, "func": "static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n                                                       String scriptClassName,\n                                                       const char* source,\n                                                       size_t size) {\n  v8::Isolate* isolate = scriptState->isolate();\n  v8::TryCatch block(isolate);\n  String sourceString(source, size);\n  String fileName = scriptClassName + \".js\";\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n  v8::Local<v8::Value> privateScriptController =\n      global->Get(context, v8String(isolate, \"privateScriptController\"))\n          .ToLocalChecked();\n  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n                 privateScriptController->IsObject());\n  if (privateScriptController->IsObject()) {\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =\n        privateScriptControllerObject->Get(context, v8String(isolate, \"import\"))\n            .ToLocalChecked();\n    if (importFunctionValue->IsUndefined()) {\n      v8::Local<v8::Function> function;\n      if (!v8::FunctionTemplate::New(isolate, importFunction)\n               ->GetFunction(context)\n               .ToLocal(&function) ||\n          !v8CallBoolean(privateScriptControllerObject->Set(\n              context, v8String(isolate, \"import\"), function))) {\n        dumpV8Message(context, block.Message());\n        LOG(FATAL)\n            << \"Private script error: Setting import function failed. (Class \"\n               \"name = \"\n            << scriptClassName.utf8().data() << \")\";\n      }\n    }\n  }\n\n  v8::Local<v8::Script> script;\n  if (!v8Call(V8ScriptRunner::compileScript(\n                  v8String(isolate, sourceString), fileName, String(),\n                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,\n                  nullptr, NotSharableCrossOrigin),\n              script, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: Compile failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n\n  v8::Local<v8::Value> result;\n  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),\n              result, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: installClass() failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  return result;\n}\n", "target": 1, "flaw_line_index": "12,13,14,15,16,17"}
{"idx": 7702, "func": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n{\n    return open_by_handle_at(mountfd, (struct file_handle *)fh, flags);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8110, "func": "void Gfx::opClip(Object args[], int numArgs) {\n  clip = clipNormal;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186492, "func": " void GM2TabStyle::PaintInactiveTabBackground(gfx::Canvas* canvas,\n                                              const SkPath& clip) const {\n   bool has_custom_image;\n   int fill_id = tab_->controller()->GetBackgroundResourceId(&has_custom_image);\n   if (!has_custom_image)\n     fill_id = 0;\n \n  PaintTabBackground(canvas, false \n, fill_id, 0,\n                      tab_->controller()->MaySetClip() ? &clip : nullptr);\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8250, "func": "XvMCSurfaceInfo * XvMCListSurfaceTypes(Display *dpy, XvPortID port, int *num)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcListSurfaceTypesReply rep;\n    xvmcListSurfaceTypesReq  *req;\n    XvMCSurfaceInfo *surface_info = NULL;\n\n    *num = 0;\n\n    XvMCCheckExtension (dpy, info, NULL);\n\n    LockDisplay (dpy);\n    XvMCGetReq (ListSurfaceTypes, req);\n    req->port = port;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n        return NULL;\n    }\n\n    if(rep.num > 0) {\n        if (rep.num < (INT_MAX / sizeof(XvMCSurfaceInfo)))\n            surface_info = Xmalloc(rep.num * sizeof(XvMCSurfaceInfo));\n\n        if(surface_info) {\n\t    xvmcSurfaceInfo sinfo;\n\t    int i;\n\n\t    *num = rep.num;\n\n\t    for(i = 0; i < rep.num; i++) {\n\t\t_XRead(dpy, (char*)&sinfo, sizeof(xvmcSurfaceInfo));\n\t       surface_info[i].surface_type_id = sinfo.surface_type_id;\n\t       surface_info[i].chroma_format = sinfo.chroma_format;\n\t       surface_info[i].max_width = sinfo.max_width;\n\t       surface_info[i].max_height = sinfo.max_height;\n\t       surface_info[i].subpicture_max_width =\n\t\t\t\t\tsinfo.subpicture_max_width;\n\t       surface_info[i].subpicture_max_height =\n\t\t\t\t\tsinfo.subpicture_max_height;\n\t       surface_info[i].mc_type = sinfo.mc_type;\n\t       surface_info[i].flags = sinfo.flags;\n\t    }\n\t} else\n\t   _XEatDataWords(dpy, rep.length);\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return surface_info;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7428, "func": "ZEND_API zval *zend_ts_hash_minmax(TsHashTable *ht, compare_func_t compar, int flag)\n{\n\tzval *retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_minmax(TS_HASH(ht), compar, flag);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7995, "func": "void vnc_client_error(VncState *vs)\n{\n    VNC_DEBUG(\"Closing down client sock: protocol error\\n\");\n    vnc_disconnect_start(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7939, "func": "void jsC_error(js_State *J, js_Ast *node, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tchar msgbuf[256];\n\n\tva_start(ap, fmt);\n\tvsnprintf(msgbuf, 256, fmt, ap);\n\tva_end(ap);\n\n\tsnprintf(buf, 256, \"%s:%d: \", J->filename, node->line);\n\tstrcat(buf, msgbuf);\n\n\tjs_newsyntaxerror(J, buf);\n\tjs_throw(J);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186800, "func": " void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n  ReadingBuffer* buffer =\n      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;\n  seqlock.WriteEnd();\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8054, "func": "static void vnc_write_pixels_copy(VncState *vs,\n                                  void *pixels, int size)\n{\n    vnc_write(vs, pixels, size);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7736, "func": "static void coroutine_fn v9fs_unlinkat(void *opaque)\n{\n    int err = 0;\n    V9fsString name;\n    int32_t dfid, flags;\n    size_t offset = 7;\n    V9fsPath path;\n    V9fsFidState *dfidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsd\", &dfid, &name, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data)) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\"..\", name.data)) {\n        err = -ENOTEMPTY;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    v9fs_path_init(&path);\n    err = v9fs_co_name_to_path(pdu, &dfidp->path, name.data, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_mark_fids_unreclaim(pdu, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_unlinkat(pdu, &dfidp->path, &name, flags);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    put_fid(pdu, dfidp);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187045, "func": "void Location::SetLocation(const String& url,\n                           LocalDOMWindow* current_window,\n                           LocalDOMWindow* entered_window,\n                           ExceptionState* exception_state,\n                           SetLocationPolicy set_location_policy) {\n  if (!IsAttached())\n    return;\n\n  if (!current_window->GetFrame())\n    return;\n\n  Document* entered_document = entered_window->document();\n  if (!entered_document)\n    return;\n\n  KURL completed_url = entered_document->CompleteURL(url);\n  if (completed_url.IsNull())\n    return;\n\n  if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),\n                                               completed_url)) {\n    if (exception_state) {\n      exception_state->ThrowSecurityError(\n          \"The current window does not have permission to navigate the target \"\n          \"frame to '\" +\n          url + \"'.\");\n    }\n    return;\n  }\n  if (exception_state && !completed_url.IsValid()) {\n    exception_state->ThrowDOMException(DOMExceptionCode::kSyntaxError,\n                                       \"'\" + url + \"' is not a valid URL.\");\n    return;\n  }\n\n   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))\n     return;\n \n   V8DOMActivityLogger* activity_logger =\n       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();\n   if (activity_logger) {\n    Vector<String> argv;\n    argv.push_back(\"LocalDOMWindow\");\n    argv.push_back(\"url\");\n    argv.push_back(entered_document->Url());\n    argv.push_back(completed_url);\n    activity_logger->LogEvent(\"blinkSetAttribute\", argv.size(), argv.data());\n  }\n  WebFrameLoadType frame_load_type = WebFrameLoadType::kStandard;\n  if (set_location_policy == SetLocationPolicy::kReplaceThisFrame)\n    frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  dom_window_->GetFrame()->ScheduleNavigation(*current_window->document(),\n                                              completed_url, frame_load_type,\n                                              UserGestureStatus::kNone);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8066, "func": "GfxResources::GfxResources(XRef *xref, Dict *resDict, GfxResources *nextA) :\n    gStateCache(2, xref) {\n  Object obj1, obj2;\n  Ref r;\n\n  if (resDict) {\n\n    fonts = NULL;\n    resDict->lookupNF(\"Font\", &obj1);\n    if (obj1.isRef()) {\n      obj1.fetch(xref, &obj2);\n      if (obj2.isDict()) {\n\tr = obj1.getRef();\n\tfonts = new GfxFontDict(xref, &r, obj2.getDict());\n      }\n      obj2.free();\n    } else if (obj1.isDict()) {\n      fonts = new GfxFontDict(xref, NULL, obj1.getDict());\n    }\n    obj1.free();\n\n    resDict->lookup(\"XObject\", &xObjDict);\n\n    resDict->lookup(\"ColorSpace\", &colorSpaceDict);\n\n    resDict->lookup(\"Pattern\", &patternDict);\n\n    resDict->lookup(\"Shading\", &shadingDict);\n\n    resDict->lookup(\"ExtGState\", &gStateDict);\n\n    resDict->lookup(\"Properties\", &propertiesDict);\n\n  } else {\n    fonts = NULL;\n    xObjDict.initNull();\n    colorSpaceDict.initNull();\n    patternDict.initNull();\n    shadingDict.initNull();\n    gStateDict.initNull();\n    propertiesDict.initNull();\n  }\n\n  next = nextA;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186339, "func": "void LoadingStatsCollector::RecordPreconnectStats(\n    std::unique_ptr<PreconnectStats> stats) {\n   const GURL& main_frame_url = stats->url;\n   auto it = preconnect_stats_.find(main_frame_url);\n   if (it != preconnect_stats_.end()) {\n    ReportPreconnectAccuracy(*it->second,\n                             std::map<GURL, OriginRequestSummary>());\n     preconnect_stats_.erase(it);\n   }\n \n  preconnect_stats_.emplace(main_frame_url, std::move(stats));\n}\n", "target": 1, "flaw_line_index": "6,7"}
{"idx": 7492, "func": "generate_many_bodies_inner (DBusMessageDataIter *iter,\n                            DBusMessage        **message_p)\n{\n  DBusMessage *message;\n  DBusString signature;\n  DBusString body;\n\n  message = dbus_message_new_method_call (\"o.z.F\",\n                                          \"/\",\n                                          \"o.z.B\",\n                                          \"Nah\");\n  if (message == NULL)\n    _dbus_assert_not_reached (\"oom\");\n\n  set_reply_serial (message);\n\n  if (!_dbus_string_init (&signature) || !_dbus_string_init (&body))\n    _dbus_assert_not_reached (\"oom\");\n  \n  if (dbus_internal_do_not_use_generate_bodies (iter_get_sequence (iter),\n                                                message->byte_order,\n                                                &signature, &body))\n    {\n      const char *v_SIGNATURE;\n\n      v_SIGNATURE = _dbus_string_get_const_data (&signature);\n      if (!_dbus_header_set_field_basic (&message->header,\n                                         DBUS_HEADER_FIELD_SIGNATURE,\n                                         DBUS_TYPE_SIGNATURE,\n                                         &v_SIGNATURE))\n        _dbus_assert_not_reached (\"oom\");\n\n      if (!_dbus_string_move (&body, 0, &message->body, 0))\n        _dbus_assert_not_reached (\"oom\");\n\n      _dbus_marshal_set_uint32 (&message->header.data, BODY_LENGTH_OFFSET,\n                                _dbus_string_get_length (&message->body),\n                                message->byte_order);\n      \n      *message_p = message;\n    }\n  else\n    {\n      dbus_message_unref (message);\n      *message_p = NULL;\n    }\n  \n  _dbus_string_free (&signature);\n  _dbus_string_free (&body);\n\n  return *message_p != NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186826, "func": " PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n    : PlatformSensor(type, std::move(mapping), provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {\n  DCHECK(sensor_reader_);\n  sensor_reader_->SetClient(this);\n}\n", "target": 1, "flaw_line_index": "3,7"}
{"idx": 187286, "func": "NetworkChangeNotifierMac::NetworkChangeNotifierMac()\n    : NetworkChangeNotifier(NetworkChangeCalculatorParamsMac()),\n      connection_type_(CONNECTION_UNKNOWN),\n       connection_type_initialized_(false),\n       initial_connection_type_cv_(&connection_type_lock_),\n       forwarder_(this),\n      dns_config_service_thread_(base::MakeUnique<DnsConfigServiceThread>()) {\n  config_watcher_ = base::MakeUnique<NetworkConfigWatcherMac>(&forwarder_);\n   dns_config_service_thread_->StartWithOptions(\n       base::Thread::Options(base::MessageLoop::TYPE_IO, 0));\n }\n", "target": 1, "flaw_line_index": "7,10"}
{"idx": 7771, "func": "static __maybe_unused int h2_peek_frame_hdr(const struct buffer *b, struct h2_fh *h)\n{\n\tuint64_t w;\n\n\tif (b->i < 9)\n\t\treturn 0;\n\n\tw = readv_n64(b_ptr(b,1), b_end(b) - b_ptr(b,1), b->data);\n\th->len = *b->p << 16;\n\th->sid = w & 0x7FFFFFFF; \n\th->ff = w >> 32;\n\th->ft = w >> 40;\n\th->len += w >> 48;\n\treturn 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7959, "func": "static const char *code2name(int keycode)\n{\n    return QKeyCode_lookup[qemu_input_key_number_to_qcode(keycode)];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7912, "func": "static void cobject(JF, js_Ast *list)\n{\n\tjs_Ast *head = list;\n\n\twhile (list) {\n\t\tjs_Ast *kv = list->a;\n\t\tjs_Ast *prop = kv->a;\n\n\t\tif (prop->type == AST_IDENTIFIER || prop->type == EXP_STRING)\n\t\t\temitstring(J, F, OP_STRING, prop->string);\n\t\telse if (prop->type == EXP_NUMBER)\n\t\t\temitnumber(J, F, prop->number);\n\t\telse\n\t\t\tjsC_error(J, prop, \"invalid property name in object initializer\");\n\n\t\tif (J->strict)\n\t\t\tcheckdup(J, F, head, kv);\n\n\t\tswitch (kv->type) {\n\t\tdefault: \n break;\n\t\tcase EXP_PROP_VAL:\n\t\t\tcexp(J, F, kv->b);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t\tbreak;\n\t\tcase EXP_PROP_GET:\n\t\t\temitfunction(J, F, newfun(J, NULL, kv->b, kv->c, 0));\n\t\t\temit(J, F, OP_INITGETTER);\n\t\t\tbreak;\n\t\tcase EXP_PROP_SET:\n\t\t\temitfunction(J, F, newfun(J, NULL, kv->b, kv->c, 0));\n\t\t\temit(J, F, OP_INITSETTER);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187243, "func": "void OnSuggestionModelAdded(UiScene* scene,\n                            UiBrowserInterface* browser,\n                            Model* model,\n                            SuggestionBinding* element_binding) {\n  auto icon = base::MakeUnique<VectorIcon>(100);\n  icon->SetDrawPhase(kPhaseForeground);\n  icon->SetType(kTypeOmniboxSuggestionIcon);\n  icon->set_hit_testable(false);\n  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);\n  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,\n            &VectorIcon::SetColor);\n  VectorIcon* p_icon = icon.get();\n\n  auto icon_box = base::MakeUnique<UiElement>();\n  icon_box->SetDrawPhase(kPhaseNone);\n  icon_box->SetType(kTypeOmniboxSuggestionIconField);\n  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);\n  icon_box->AddChild(std::move(icon));\n\n  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);\n  content_text->SetDrawPhase(kPhaseForeground);\n  content_text->SetType(kTypeOmniboxSuggestionContentText);\n  content_text->set_hit_testable(false);\n  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\n  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,\n            &Text::SetColor);\n  Text* p_content_text = content_text.get();\n\n  auto description_text =\n      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);\n   description_text->SetDrawPhase(kPhaseForeground);\n   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);\n   description_text->set_hit_testable(false);\n  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\n   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n   BindColor(model, description_text.get(),\n            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);\n  Text* p_description_text = description_text.get();\n\n  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);\n  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);\n  text_layout->set_hit_testable(false);\n  text_layout->set_margin(kSuggestionLineGapDMM);\n  text_layout->AddChild(std::move(content_text));\n  text_layout->AddChild(std::move(description_text));\n\n  auto right_margin = base::MakeUnique<UiElement>();\n  right_margin->SetDrawPhase(kPhaseNone);\n  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);\n\n  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);\n  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);\n  suggestion_layout->set_hit_testable(false);\n  suggestion_layout->AddChild(std::move(icon_box));\n  suggestion_layout->AddChild(std::move(text_layout));\n  suggestion_layout->AddChild(std::move(right_margin));\n\n  auto background = Create<Button>(\n      kNone, kPhaseForeground,\n      base::BindRepeating(\n          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {\n            b->Navigate(e->model()->destination);\n            m->omnibox_input_active = false;\n          },\n          base::Unretained(browser), base::Unretained(model),\n          base::Unretained(element_binding)));\n\n  background->SetType(kTypeOmniboxSuggestionBackground);\n  background->set_hit_testable(true);\n  background->set_bubble_events(true);\n  background->set_bounds_contain_children(true);\n  background->set_hover_offset(0.0);\n  BindButtonColors(model, background.get(),\n                   &ColorScheme::suggestion_button_colors,\n                   &Button::SetButtonColors);\n  background->AddChild(std::move(suggestion_layout));\n\n  element_binding->bindings().push_back(\n      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,\n                   model()->content, Text, p_content_text, SetText));\n  element_binding->bindings().push_back(\n      base::MakeUnique<Binding<base::string16>>(\n          base::BindRepeating(\n              [](SuggestionBinding* m) { return m->model()->description; },\n              base::Unretained(element_binding)),\n          base::BindRepeating(\n              [](Text* v, const base::string16& text) {\n                v->SetVisibleImmediately(!text.empty());\n                v->set_requires_layout(!text.empty());\n                if (!text.empty()) {\n                  v->SetText(text);\n                }\n              },\n              base::Unretained(p_description_text))));\n  element_binding->bindings().push_back(\n      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,\n              model()->type, VectorIcon, p_icon,\n              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));\n  element_binding->set_view(background.get());\n  scene->AddUiElement(kOmniboxSuggestions, std::move(background));\n}\n", "target": 1, "flaw_line_index": "36"}
{"idx": 186381, "func": "void MaybeReportDownloadDeepScanningVerdict(\n    Profile* profile,\n    const GURL& url,\n    const std::string& file_name,\n     const std::string& download_digest_sha256,\n     BinaryUploadService::Result result,\n     DeepScanningClientResponse response) {\n   if (response.malware_scan_verdict().verdict() ==\n           MalwareDeepScanningVerdict::UWS ||\n       response.malware_scan_verdict().verdict() ==\n           MalwareDeepScanningVerdict::MALWARE) {\n     extensions::SafeBrowsingPrivateEventRouterFactory::GetForProfile(profile)\n         ->OnDangerousDeepScanningResult(url, file_name, download_digest_sha256);\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7511, "func": "  tt_driver_init( FT_Module  ttdriver )     \n  {\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n\n    TT_Driver  driver = (TT_Driver)ttdriver;\n\n    driver->interpreter_version = TT_INTERPRETER_VERSION_35;\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n    driver->interpreter_version = TT_INTERPRETER_VERSION_38;\n#endif\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n    driver->interpreter_version = TT_INTERPRETER_VERSION_40;\n#endif\n\n#else \n\n    FT_UNUSED( ttdriver );\n\n#endif \n\n    return FT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186673, "func": "BackendImpl::BackendImpl(\n    const base::FilePath& path,\n    scoped_refptr<BackendCleanupTracker> cleanup_tracker,\n    const scoped_refptr<base::SingleThreadTaskRunner>& cache_thread,\n    net::NetLog* net_log)\n    : cleanup_tracker_(std::move(cleanup_tracker)),\n      background_queue_(this, FallbackToInternalIfNull(cache_thread)),\n      path_(path),\n      block_files_(path),\n      mask_(0),\n      max_size_(0),\n      up_ticks_(0),\n      cache_type_(net::DISK_CACHE),\n      uma_report_(0),\n      user_flags_(0),\n      init_(false),\n      restarted_(false),\n      unit_test_(false),\n      read_only_(false),\n      disabled_(false),\n       new_eviction_(false),\n       first_timer_(true),\n       user_load_(false),\n       net_log_(net_log),\n       done_(base::WaitableEvent::ResetPolicy::MANUAL,\n             base::WaitableEvent::InitialState::NOT_SIGNALED),\n      ptr_factory_(this) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7690, "func": "static int handle_rename(FsContext *ctx, const char *oldpath,\n                         const char *newpath)\n{\n    errno = EOPNOTSUPP;\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186758, "func": " void RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  session->SetRenderer(frame_host_ ? frame_host_->GetProcess() : nullptr,\n                        frame_host_);\n \n   protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::TargetHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n      protocol::TracingHandler::Renderer,\n      frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,\n      GetIOContext())));\n  if (frame_tree_node_ && !frame_tree_node_->parent()) {\n    session->AddHandler(\n        base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n    session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n  }\n\n  if (EnsureAgent())\n    session->AttachToAgent(agent_ptr_);\n\n  if (sessions().size() == 1) {\n    frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8007, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n                        bool skipauth, bool websocket)\n{\n    VncState *vs = g_malloc0(sizeof(VncState));\n    int i;\n\n    vs->csock = csock;\n\n    if (skipauth) {\n\tvs->auth = VNC_AUTH_NONE;\n#ifdef CONFIG_VNC_TLS\n\tvs->subauth = VNC_AUTH_INVALID;\n#endif\n    } else {\n\tvs->auth = vd->auth;\n#ifdef CONFIG_VNC_TLS\n\tvs->subauth = vd->subauth;\n#endif\n    }\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n    }\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    qemu_set_nonblock(vs->csock);\n#ifdef CONFIG_VNC_WS\n    if (websocket) {\n        vs->websocket = 1;\n#ifdef CONFIG_VNC_TLS\n        if (vd->tls.x509cert) {\n            qemu_set_fd_handler2(vs->csock, NULL, vncws_tls_handshake_peek,\n                                 NULL, vs);\n        } else\n#endif \n        {\n            qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read,\n                                 NULL, vs);\n        }\n    } else\n#endif \n    {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    vnc_client_cache_addr(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n    vs->vd = vd;\n\n#ifdef CONFIG_VNC_WS\n    if (!vs->websocket)\n#endif\n    {\n        vnc_init_state(vs);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186857, "func": "  void Initialized(mojo::ScopedSharedBufferHandle shared_buffer,\n                   mojo::ScopedHandle socket_handle) {\n    ASSERT_TRUE(shared_buffer.is_valid());\n    ASSERT_TRUE(socket_handle.is_valid());\n\n    base::PlatformFile fd;\n    mojo::UnwrapPlatformFile(std::move(socket_handle), &fd);\n    socket_ = std::make_unique<base::CancelableSyncSocket>(fd);\n    EXPECT_NE(socket_->handle(), base::CancelableSyncSocket::kInvalidHandle);\n \n     size_t memory_length;\n     base::SharedMemoryHandle shmem_handle;\n    bool read_only;\n     EXPECT_EQ(\n         mojo::UnwrapSharedMemoryHandle(std::move(shared_buffer), &shmem_handle,\n                                       &memory_length, &read_only),\n         MOJO_RESULT_OK);\n    EXPECT_FALSE(read_only);\n    buffer_ = std::make_unique<base::SharedMemory>(shmem_handle, read_only);\n \n     GotNotification();\n   }\n", "target": 1, "flaw_line_index": "13,16,18,19"}
{"idx": 186409, "func": " PageInfoUI::IdentityInfo::IdentityInfo()\n     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),\n      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),\n       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),\n       show_ssl_decision_revoke_button(false),\n       show_change_password_buttons(false) {}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186665, "func": "   void DoTest(ExternalProtocolHandler::BlockState block_state,\n               shell_integration::DefaultWebClientState os_state,\n               Action expected_action) {\n    GURL url(\"mailto:test@test.com\");\n     EXPECT_FALSE(delegate_.has_prompted());\n     EXPECT_FALSE(delegate_.has_launched());\n     EXPECT_FALSE(delegate_.has_blocked());\n\n    delegate_.set_block_state(block_state);\n    delegate_.set_os_state(os_state);\n    ExternalProtocolHandler::LaunchUrlWithDelegate(\n        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);\n    content::RunAllTasksUntilIdle();\n\n    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());\n    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());\n    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());\n  }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186323, "func": "void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {\n  if (!timer_.IsRunning()) {\n    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,\n                 &BinaryUploadService::ResetAuthorizationData);\n  }\n\n   if (!can_upload_data_.has_value()) {\n     if (!pending_validate_data_upload_request_) {\n      std::string dm_token = GetDMToken();\n      if (dm_token.empty()) {\n         std::move(callback).Run(false);\n         return;\n       }\n\n      pending_validate_data_upload_request_ = true;\n       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(\n           &BinaryUploadService::ValidateDataUploadRequestCallback,\n           weakptr_factory_.GetWeakPtr()));\n      request->set_dm_token(dm_token);\n       UploadForDeepScanning(std::move(request));\n     }\n     authorization_callbacks_.push_back(std::move(callback));\n    return;\n  }\n  std::move(callback).Run(can_upload_data_.value());\n}\n", "target": 1, "flaw_line_index": "12,13,22"}
{"idx": 7697, "func": "static int handle_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK | O_WRONLY);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = ftruncate(fd, size);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187292, "func": "CastStreamingNativeHandler::CastStreamingNativeHandler(ScriptContext* context)\n     : ObjectBackedNativeHandler(context),\n       last_transport_id_(1),\n       weak_factory_(this) {\n  RouteFunction(\"CreateSession\",\n                 base::Bind(&CastStreamingNativeHandler::CreateCastSession,\n                            weak_factory_.GetWeakPtr()));\n  RouteFunction(\"DestroyCastRtpStream\",\n                 base::Bind(&CastStreamingNativeHandler::DestroyCastRtpStream,\n                            weak_factory_.GetWeakPtr()));\n   RouteFunction(\n      \"GetSupportedParamsCastRtpStream\",\n       base::Bind(&CastStreamingNativeHandler::GetSupportedParamsCastRtpStream,\n                  weak_factory_.GetWeakPtr()));\n  RouteFunction(\"StartCastRtpStream\",\n                 base::Bind(&CastStreamingNativeHandler::StartCastRtpStream,\n                            weak_factory_.GetWeakPtr()));\n  RouteFunction(\"StopCastRtpStream\",\n                 base::Bind(&CastStreamingNativeHandler::StopCastRtpStream,\n                            weak_factory_.GetWeakPtr()));\n  RouteFunction(\"DestroyCastUdpTransport\",\n                 base::Bind(&CastStreamingNativeHandler::DestroyCastUdpTransport,\n                            weak_factory_.GetWeakPtr()));\n   RouteFunction(\n      \"SetDestinationCastUdpTransport\",\n       base::Bind(&CastStreamingNativeHandler::SetDestinationCastUdpTransport,\n                  weak_factory_.GetWeakPtr()));\n   RouteFunction(\n      \"SetOptionsCastUdpTransport\",\n       base::Bind(&CastStreamingNativeHandler::SetOptionsCastUdpTransport,\n                  weak_factory_.GetWeakPtr()));\n  RouteFunction(\"ToggleLogging\",\n                 base::Bind(&CastStreamingNativeHandler::ToggleLogging,\n                            weak_factory_.GetWeakPtr()));\n  RouteFunction(\"GetRawEvents\",\n                 base::Bind(&CastStreamingNativeHandler::GetRawEvents,\n                            weak_factory_.GetWeakPtr()));\n  RouteFunction(\"GetStats\", base::Bind(&CastStreamingNativeHandler::GetStats,\n                                       weak_factory_.GetWeakPtr()));\n  RouteFunction(\"StartCastRtpReceiver\",\n                 base::Bind(&CastStreamingNativeHandler::StartCastRtpReceiver,\n                            weak_factory_.GetWeakPtr()));\n }\n", "target": 1, "flaw_line_index": "5,8,12,15,18,21,25,29,32,35,38,39,40"}
{"idx": 186516, "func": " bool ChromeContentBrowserClient::IsDataSaverEnabled(\n     content::BrowserContext* browser_context) {\n  data_reduction_proxy::DataReductionProxySettings*\n      data_reduction_proxy_settings =\n          DataReductionProxyChromeSettingsFactory::GetForBrowserContext(\n              browser_context);\n  return data_reduction_proxy_settings &&\n         data_reduction_proxy_settings->IsDataSaverEnabledByUser();\n }\n", "target": 1, "flaw_line_index": "3,4,5,6,7,8"}
{"idx": 8113, "func": "void Gfx::opClosePath(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    error(getPos(), \"No current point in closepath\");\n    return;\n  }\n  state->closePath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8135, "func": "void Gfx::opRestore(Object args[], int numArgs) {\n  restoreState();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7791, "func": "static inline __maybe_unused void h2c_error(struct h2c *h2c, enum h2_err err)\n{\n\th2c->errcode = err;\n\th2c->st0 = H2_CS_ERROR;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7981, "func": "static uint8_t read_u8(uint8_t *data, size_t offset)\n{\n    return data[offset];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186894, "func": "void CoordinatorImpl::RequestGlobalMemoryDumpForPid(\n    base::ProcessId pid,\n    const RequestGlobalMemoryDumpForPidCallback& callback) {\n  if (pid == base::kNullProcessId) {\n    callback.Run(false, nullptr);\n    return;\n  }\n\n  auto adapter = [](const RequestGlobalMemoryDumpForPidCallback& callback,\n                    bool success, uint64_t,\n                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n    callback.Run(success, std::move(global_memory_dump));\n  };\n\n   QueuedRequest::Args args(\n       base::trace_event::MemoryDumpType::SUMMARY_ONLY,\n       base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND, {},\n      false \n, pid);\n   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186595, "func": "void DocumentLoader::InstallNewDocument(\n    const KURL& url,\n    Document* owner_document,\n    WebGlobalObjectReusePolicy global_object_reuse_policy,\n    const AtomicString& mime_type,\n    const AtomicString& encoding,\n    InstallNewDocumentReason reason,\n    ParserSynchronizationPolicy parsing_policy,\n    const KURL& overriding_url) {\n  DCHECK(!frame_->GetDocument() || !frame_->GetDocument()->IsActive());\n  DCHECK_EQ(frame_->Tree().ChildCount(), 0u);\n  if (GetFrameLoader().StateMachine()->IsDisplayingInitialEmptyDocument()) {\n    GetFrameLoader().StateMachine()->AdvanceTo(\n        FrameLoaderStateMachine::kCommittedFirstRealLoad);\n   }\n \n   const SecurityOrigin* previous_security_origin = nullptr;\n  if (frame_->GetDocument())\n     previous_security_origin = frame_->GetDocument()->GetSecurityOrigin();\n \n  if (global_object_reuse_policy != WebGlobalObjectReusePolicy::kUseExisting)\n    frame_->SetDOMWindow(LocalDOMWindow::Create(*frame_));\n\n  if (reason == InstallNewDocumentReason::kNavigation)\n    WillCommitNavigation();\n\n  Document* document = frame_->DomWindow()->InstallNewDocument(\n      mime_type,\n      DocumentInit::Create()\n           .WithDocumentLoader(this)\n           .WithURL(url)\n           .WithOwnerDocument(owner_document)\n          .WithNewRegistrationContext(),\n       false);\n \n  if (frame_->IsMainFrame())\n    frame_->ClearActivation();\n\n  if (frame_->HasReceivedUserGestureBeforeNavigation() !=\n      had_sticky_activation_) {\n    frame_->SetDocumentHasReceivedUserGestureBeforeNavigation(\n        had_sticky_activation_);\n    GetLocalFrameClient().SetHasReceivedUserGestureBeforeNavigation(\n        had_sticky_activation_);\n  }\n\n  if (ShouldClearWindowName(*frame_, previous_security_origin, *document)) {\n    frame_->Tree().ExperimentalSetNulledName();\n  }\n \n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n  DidInstallNewDocument(document);\n \n  if (reason == InstallNewDocumentReason::kNavigation)\n    DidCommitNavigation(global_object_reuse_policy);\n\n  if (GetFrameLoader().StateMachine()->CommittedFirstRealDocumentLoad()) {\n    if (document->GetSettings()\n            ->GetForceTouchEventFeatureDetectionForInspector()) {\n      OriginTrialContext::FromOrCreate(document)->AddFeature(\n          \"ForceTouchEventFeatureDetectionForInspector\");\n    }\n    OriginTrialContext::AddTokensFromHeader(\n        document, response_.HttpHeaderField(HTTPNames::Origin_Trial));\n  }\n  bool stale_while_revalidate_enabled =\n      OriginTrials::StaleWhileRevalidateEnabled(document);\n  fetcher_->SetStaleWhileRevalidateEnabled(stale_while_revalidate_enabled);\n\n  if (stale_while_revalidate_enabled &&\n      !RuntimeEnabledFeatures::StaleWhileRevalidateEnabledByRuntimeFlag())\n    UseCounter::Count(frame_, WebFeature::kStaleWhileRevalidateEnabled);\n\n  parser_ = document->OpenForNavigation(parsing_policy, mime_type, encoding);\n\n  ScriptableDocumentParser* scriptable_parser =\n      parser_->AsScriptableDocumentParser();\n  if (scriptable_parser && GetResource()) {\n    scriptable_parser->SetInlineScriptCacheHandler(\n        ToRawResource(GetResource())->InlineScriptCacheHandler());\n  }\n\n  document->ApplyFeaturePolicyFromHeader(\n      response_.HttpHeaderField(HTTPNames::Feature_Policy));\n\n  GetFrameLoader().DispatchDidClearDocumentOfWindowObject();\n}\n", "target": 1, "flaw_line_index": "18,41,71"}
{"idx": 186874, "func": "PrintMsg_Print_Params::PrintMsg_Print_Params()\n    : page_size(),\n      content_size(),\n      printable_area(),\n      margin_top(0),\n      margin_left(0),\n      dpi(0),\n      scale_factor(1.0f),\n      rasterize_pdf(false),\n      document_cookie(0),\n      selection_only(false),\n      supports_alpha_blend(false),\n      preview_ui_id(-1),\n      preview_request_id(0),\n      is_first_request(false),\n      print_scaling_option(blink::kWebPrintScalingOptionSourceSize),\n      print_to_pdf(false),\n       display_header_footer(false),\n       title(),\n       url(),\n       should_print_backgrounds(false),\n       printed_doc_type(printing::SkiaDocumentType::PDF) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187125, "func": " void MarkingVisitor::ConservativelyMarkHeader(HeapObjectHeader* header) {\n  const GCInfo* gc_info = ThreadHeap::GcInfo(header->GcInfoIndex());\n   if (gc_info->HasVTable() && !VTableInitialized(header->Payload())) {\n    MarkHeaderNoTracing(header);\n#if DCHECK_IS_ON()\n    DCHECK(IsUninitializedMemory(header->Payload(), header->PayloadSize()));\n#endif\n  } else {\n    MarkHeader(header, gc_info->trace_);\n  }\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186907, "func": "void NavigationObserver::PromptToEnableExtensionIfNecessary(\n    NavigationController* nav_controller) {\n  if (!in_progress_prompt_extension_id_.empty())\n    return;\n\n  NavigationEntry* nav_entry = nav_controller->GetVisibleEntry();\n   if (!nav_entry)\n     return;\n \n  const GURL& url = (nav_entry->GetPageType() == content::PAGE_TYPE_ERROR &&\n                     nav_entry->GetURL() == url::kAboutBlankURL &&\n                     nav_entry->GetVirtualURL().SchemeIs(kExtensionScheme))\n                        ? nav_entry->GetVirtualURL()\n                        : nav_entry->GetURL();\n \n  if (!url.SchemeIs(kExtensionScheme))\n    return;\n\n  const Extension* extension = ExtensionRegistry::Get(profile_)\n                                   ->disabled_extensions()\n                                   .GetExtensionOrAppByURL(url);\n  if (!extension)\n    return;\n\n  if (!prompted_extensions_.insert(extension->id()).second &&\n      !g_repeat_prompting) {\n    return;\n  }\n\n  ExtensionPrefs* extension_prefs = ExtensionPrefs::Get(profile_);\n  if (extension_prefs->DidExtensionEscalatePermissions(extension->id())) {\n    in_progress_prompt_extension_id_ = extension->id();\n    in_progress_prompt_navigation_controller_ = nav_controller;\n\n    extension_install_prompt_.reset(\n        new ExtensionInstallPrompt(nav_controller->GetWebContents()));\n    ExtensionInstallPrompt::PromptType type =\n        ExtensionInstallPrompt::GetReEnablePromptTypeForExtension(profile_,\n                                                                  extension);\n    extension_install_prompt_->ShowDialog(\n        base::Bind(&NavigationObserver::OnInstallPromptDone,\n                   weak_factory_.GetWeakPtr()),\n        extension, nullptr,\n        base::MakeUnique<ExtensionInstallPrompt::Prompt>(type),\n        ExtensionInstallPrompt::GetDefaultShowDialogCallback());\n  }\n}\n", "target": 1, "flaw_line_index": "11,12,13,14,15,16,17,18,19"}
{"idx": 186865, "func": "bool ImageResource::IsAccessAllowed(\n     const SecurityOrigin* security_origin,\n     ImageResourceInfo::DoesCurrentFrameHaveSingleSecurityOrigin\n         does_current_frame_has_single_security_origin) const {\n  if (GetCORSStatus() == CORSStatus::kServiceWorkerOpaque)\n    return false;\n \n   if (does_current_frame_has_single_security_origin !=\n       ImageResourceInfo::kHasSingleSecurityOrigin)\n     return false;\n \n  if (IsSameOriginOrCORSSuccessful())\n     return true;\n \n   return !security_origin->TaintsCanvas(GetResponse().Url());\n}\n", "target": 1, "flaw_line_index": "5,6,12"}
{"idx": 186762, "func": "void ServiceWorkerDevToolsAgentHost::WorkerReadyForInspection(\n    blink::mojom::DevToolsAgentAssociatedPtrInfo devtools_agent_ptr_info) {\n  DCHECK_EQ(WORKER_NOT_READY, state_);\n  state_ = WORKER_READY;\n  agent_ptr_.Bind(std::move(devtools_agent_ptr_info));\n  if (!sessions().empty()) {\n    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                            base::BindOnce(&SetDevToolsAttachedOnIO,\n                                            context_weak_, version_id_, true));\n   }\n \n  RenderProcessHost* host = RenderProcessHost::FromID(worker_process_id_);\n   for (DevToolsSession* session : sessions()) {\n    session->SetRenderer(host, nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n }\n", "target": 1, "flaw_line_index": "12,13,14,16"}
{"idx": 7663, "func": "static int v9fs_request(V9fsProxy *proxy, int type, void *response, ...)\n{\n    dev_t rdev;\n    va_list ap;\n    int size = 0;\n    int retval = 0;\n    uint64_t offset;\n    ProxyHeader header = { 0, 0};\n    struct timespec spec[2];\n    int flags, mode, uid, gid;\n    V9fsString *name, *value;\n    V9fsString *path, *oldpath;\n    struct iovec *iovec = NULL, *reply = NULL;\n\n    qemu_mutex_lock(&proxy->mutex);\n\n    if (proxy->sockfd == -1) {\n        retval = -EIO;\n        goto err_out;\n    }\n    iovec = &proxy->out_iovec;\n    reply = &proxy->in_iovec;\n    va_start(ap, response);\n    switch (type) {\n    case T_OPEN:\n        path = va_arg(ap, V9fsString *);\n        flags = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, flags);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_OPEN;\n        }\n        break;\n    case T_CREATE:\n        path = va_arg(ap, V9fsString *);\n        flags = va_arg(ap, int);\n        mode = va_arg(ap, int);\n        uid = va_arg(ap, int);\n        gid = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdddd\", path,\n                                    flags, mode, uid, gid);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_CREATE;\n        }\n        break;\n    case T_MKNOD:\n        path = va_arg(ap, V9fsString *);\n        mode = va_arg(ap, int);\n        rdev = va_arg(ap, long int);\n        uid = va_arg(ap, int);\n        gid = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsdq\",\n                                    uid, gid, path, mode, rdev);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_MKNOD;\n        }\n        break;\n    case T_MKDIR:\n        path = va_arg(ap, V9fsString *);\n        mode = va_arg(ap, int);\n        uid = va_arg(ap, int);\n        gid = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsd\",\n                                    uid, gid, path, mode);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_MKDIR;\n        }\n        break;\n    case T_SYMLINK:\n        oldpath = va_arg(ap, V9fsString *);\n        path = va_arg(ap, V9fsString *);\n        uid = va_arg(ap, int);\n        gid = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddss\",\n                                    uid, gid, oldpath, path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_SYMLINK;\n        }\n        break;\n    case T_LINK:\n        oldpath = va_arg(ap, V9fsString *);\n        path = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\",\n                                    oldpath, path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_LINK;\n        }\n        break;\n    case T_LSTAT:\n        path = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_LSTAT;\n        }\n        break;\n    case T_READLINK:\n        path = va_arg(ap, V9fsString *);\n        size = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, size);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_READLINK;\n        }\n        break;\n    case T_STATFS:\n        path = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_STATFS;\n        }\n        break;\n    case T_CHMOD:\n        path = va_arg(ap, V9fsString *);\n        mode = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, mode);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_CHMOD;\n        }\n        break;\n    case T_CHOWN:\n        path = va_arg(ap, V9fsString *);\n        uid = va_arg(ap, int);\n        gid = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdd\", path, uid, gid);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_CHOWN;\n        }\n        break;\n    case T_TRUNCATE:\n        path = va_arg(ap, V9fsString *);\n        offset = va_arg(ap, uint64_t);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sq\", path, offset);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_TRUNCATE;\n        }\n        break;\n    case T_UTIME:\n        path = va_arg(ap, V9fsString *);\n        spec[0].tv_sec = va_arg(ap, long);\n        spec[0].tv_nsec = va_arg(ap, long);\n        spec[1].tv_sec = va_arg(ap, long);\n        spec[1].tv_nsec = va_arg(ap, long);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sqqqq\", path,\n                                    spec[0].tv_sec, spec[1].tv_nsec,\n                                    spec[1].tv_sec, spec[1].tv_nsec);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_UTIME;\n        }\n        break;\n    case T_RENAME:\n        oldpath = va_arg(ap, V9fsString *);\n        path = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", oldpath, path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_RENAME;\n        }\n        break;\n    case T_REMOVE:\n        path = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_REMOVE;\n        }\n        break;\n    case T_LGETXATTR:\n        size = va_arg(ap, int);\n        path = va_arg(ap, V9fsString *);\n        name = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ,\n                                    \"dss\", size, path, name);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_LGETXATTR;\n        }\n        break;\n    case T_LLISTXATTR:\n        size = va_arg(ap, int);\n        path = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ds\", size, path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_LLISTXATTR;\n        }\n        break;\n    case T_LSETXATTR:\n        path = va_arg(ap, V9fsString *);\n        name = va_arg(ap, V9fsString *);\n        value = va_arg(ap, V9fsString *);\n        size = va_arg(ap, int);\n        flags = va_arg(ap, int);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sssdd\",\n                                    path, name, value, size, flags);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_LSETXATTR;\n        }\n        break;\n    case T_LREMOVEXATTR:\n        path = va_arg(ap, V9fsString *);\n        name = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", path, name);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_LREMOVEXATTR;\n        }\n        break;\n    case T_GETVERSION:\n        path = va_arg(ap, V9fsString *);\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n        if (retval > 0) {\n            header.size = retval;\n            header.type = T_GETVERSION;\n        }\n        break;\n    default:\n        error_report(\"Invalid type %d\", type);\n        retval = -EINVAL;\n        break;\n    }\n    va_end(ap);\n\n    if (retval < 0) {\n        goto err_out;\n    }\n\n    proxy_marshal(iovec, 0, \"dd\", header.type, header.size);\n    header.size += PROXY_HDR_SZ;\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n    if (retval != header.size) {\n        goto close_error;\n    }\n\n    switch (type) {\n    case T_OPEN:\n    case T_CREATE:\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n            goto close_error;\n        }\n        break;\n    case T_MKNOD:\n    case T_MKDIR:\n    case T_SYMLINK:\n    case T_LINK:\n    case T_CHMOD:\n    case T_CHOWN:\n    case T_RENAME:\n    case T_TRUNCATE:\n    case T_UTIME:\n    case T_REMOVE:\n    case T_LSETXATTR:\n    case T_LREMOVEXATTR:\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n            goto close_error;\n        }\n        break;\n    case T_LSTAT:\n    case T_READLINK:\n    case T_STATFS:\n    case T_GETVERSION:\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n            goto close_error;\n        }\n        break;\n    case T_LGETXATTR:\n    case T_LLISTXATTR:\n        if (!size) {\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n                goto close_error;\n            }\n        } else {\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n                goto close_error;\n            }\n        }\n        break;\n    }\n\nerr_out:\n    qemu_mutex_unlock(&proxy->mutex);\n    return retval;\n\nclose_error:\n    close(proxy->sockfd);\n    proxy->sockfd = -1;\n    qemu_mutex_unlock(&proxy->mutex);\n    return -EIO;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7543, "func": "mktime_z (timezone_t tz, struct tm *tm)\n{\n  if (!tz)\n    return timegm (tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          time_t t = mktime (tm);\n#if HAVE_TM_ZONE || HAVE_TZNAME\n          time_t badtime = -1;\n          struct tm tm_1;\n          if ((t != badtime\n               || (localtime_r (&t, &tm_1) && equal_tm (tm, &tm_1)))\n              && !save_abbr (tz, tm))\n            t = badtime;\n#endif\n          if (revert_tz (old_tz))\n            return t;\n        }\n      return -1;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187060, "func": "   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {\n     uintptr_t receiver_id = RTCRtpReceiver::getId(\n         transceiver_state.receiver_state()->webrtc_receiver().get());\n     for (const auto& receiver : handler_->rtp_receivers_) {\n      if (receiver->Id() == receiver_id)\n        return false;\n    }\n    return true;\n  }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7794, "func": "static int h2c_frt_init(struct connection *conn)\n{\n\tstruct h2c *h2c;\n\tstruct task *t = NULL;\n\tstruct session *sess = conn->owner;\n\n\th2c = pool_alloc(pool_head_h2c);\n\tif (!h2c)\n\t\tgoto fail;\n\n\n\th2c->shut_timeout = h2c->timeout = sess->fe->timeout.client;\n\tif (tick_isset(sess->fe->timeout.clientfin))\n\t\th2c->shut_timeout = sess->fe->timeout.clientfin;\n\n\th2c->task = NULL;\n\tif (tick_isset(h2c->timeout)) {\n\t\tt = task_new(tid_bit);\n\t\tif (!t)\n\t\t\tgoto fail;\n\n\t\th2c->task = t;\n\t\tt->process = h2_timeout_task;\n\t\tt->context = h2c;\n\t\tt->expire = tick_add(now_ms, h2c->timeout);\n\t}\n\n\th2c->ddht = hpack_dht_alloc(h2_settings_header_table_size);\n\tif (!h2c->ddht)\n\t\tgoto fail;\n\n\th2c->st0 = H2_CS_PREFACE;\n\th2c->conn = conn;\n\th2c->max_id = -1;\n\th2c->errcode = H2_ERR_NO_ERROR;\n\th2c->flags = H2_CF_NONE;\n\th2c->rcvd_c = 0;\n\th2c->rcvd_s = 0;\n\th2c->nb_streams = 0;\n\n\th2c->dbuf = &buf_empty;\n\th2c->dsi = -1;\n\th2c->msi = -1;\n\th2c->last_sid = -1;\n\n\th2c->mbuf = &buf_empty;\n\th2c->miw = 65535; \n\th2c->mws = 65535; \n\th2c->mfs = 16384; \n\th2c->streams_by_id = EB_ROOT_UNIQUE;\n\tLIST_INIT(&h2c->send_list);\n\tLIST_INIT(&h2c->fctl_list);\n\tLIST_INIT(&h2c->buf_wait.list);\n\tconn->mux_ctx = h2c;\n\n\tif (t)\n\t\ttask_queue(t);\n\tconn_xprt_want_recv(conn);\n\n\treturn 0;\n fail:\n\tif (t)\n\t\ttask_free(t);\n\tpool_free(pool_head_h2c, h2c);\n\treturn -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186984, "func": "  bool CanCapture(const Extension& extension, const GURL& url) {\n     return extension.permissions_data()->CanCaptureVisiblePage(\n        url, kTabId, nullptr \n);\n   }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186476, "func": " static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {\n  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),\n                                       kN32_SkColorType, kPremul_SkAlphaType);\n  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);\n  if (!dstPixels)\n     return nullptr;\n   return newSkImageFromRaster(\n       info, std::move(dstPixels),\n      static_cast<size_t>(input->width()) * info.bytesPerPixel());\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8040, "func": "static int vnc_refresh_server_surface(VncDisplay *vd)\n{\n    int width = MIN(pixman_image_get_width(vd->guest.fb),\n                    pixman_image_get_width(vd->server));\n    int height = MIN(pixman_image_get_height(vd->guest.fb),\n                     pixman_image_get_height(vd->server));\n    int cmp_bytes, server_stride, min_stride, guest_stride, y = 0;\n    uint8_t *guest_row0 = NULL, *server_row0;\n    VncState *vs;\n    int has_dirty = 0;\n    pixman_image_t *tmpbuf = NULL;\n\n    struct timeval tv = { 0, 0 };\n\n    if (!vd->non_adaptive) {\n        gettimeofday(&tv, NULL);\n        has_dirty = vnc_update_stats(vd, &tv);\n    }\n\n    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n    server_stride = guest_stride = pixman_image_get_stride(vd->server);\n    cmp_bytes = MIN(VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES,\n                    server_stride);\n    if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n        int width = pixman_image_get_width(vd->server);\n        tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n    } else {\n        guest_row0 = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n        guest_stride = pixman_image_get_stride(vd->guest.fb);\n    }\n    min_stride = MIN(server_stride, guest_stride);\n\n    for (;;) {\n        int x;\n        uint8_t *guest_ptr, *server_ptr;\n        unsigned long offset = find_next_bit((unsigned long *) &vd->guest.dirty,\n                                             height * VNC_DIRTY_BPL(&vd->guest),\n                                             y * VNC_DIRTY_BPL(&vd->guest));\n        if (offset == height * VNC_DIRTY_BPL(&vd->guest)) {\n            break;\n        }\n        y = offset / VNC_DIRTY_BPL(&vd->guest);\n        x = offset % VNC_DIRTY_BPL(&vd->guest);\n\n        server_ptr = server_row0 + y * server_stride + x * cmp_bytes;\n\n        if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n            qemu_pixman_linebuf_fill(tmpbuf, vd->guest.fb, width, 0, y);\n            guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n        } else {\n            guest_ptr = guest_row0 + y * guest_stride;\n        }\n        guest_ptr += x * cmp_bytes;\n\n        for (; x < DIV_ROUND_UP(width, VNC_DIRTY_PIXELS_PER_BIT);\n             x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n            int _cmp_bytes = cmp_bytes;\n            if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n                continue;\n            }\n            if ((x + 1) * cmp_bytes > min_stride) {\n                _cmp_bytes = min_stride - x * cmp_bytes;\n            }\n            if (memcmp(server_ptr, guest_ptr, _cmp_bytes) == 0) {\n                continue;\n            }\n            memcpy(server_ptr, guest_ptr, _cmp_bytes);\n            if (!vd->non_adaptive) {\n                vnc_rect_updated(vd, x * VNC_DIRTY_PIXELS_PER_BIT,\n                                 y, &tv);\n            }\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                set_bit(x, vs->dirty[y]);\n            }\n            has_dirty++;\n        }\n\n        y++;\n    }\n    qemu_pixman_image_unref(tmpbuf);\n    return has_dirty;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186591, "func": "void RemoteFrame::ScheduleNavigation(Document& origin_document,\n                                      const KURL& url,\n                                      WebFrameLoadType frame_load_type,\n                                      UserGestureStatus user_gesture_status) {\n   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));\n   frame_request.GetResourceRequest().SetHasUserGesture(\n       user_gesture_status == UserGestureStatus::kActive);\n  frame_request.GetResourceRequest().SetFrameType(\n      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel\n                    : network::mojom::RequestContextFrameType::kNested);\n  Navigate(frame_request, frame_load_type);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7777, "func": "static inline void h2_release_buf(struct h2c *h2c, struct buffer **bptr)\n{\n\tif ((*bptr)->size) {\n\t\tb_free(bptr);\n\t\toffer_buffers(h2c->buf_wait.target,\n\t\t\t      tasks_run_queue + applets_active_queue);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7753, "func": "  tt_face_vary_cvt( TT_Face    face,\n                    FT_Stream  stream )\n  {\n    FT_Error    error;\n    FT_Memory   memory = stream->memory;\n    FT_ULong    table_start;\n    FT_ULong    table_len;\n    FT_UInt     tupleCount;\n    FT_ULong    offsetToData;\n    FT_ULong    here;\n    FT_UInt     i, j;\n    FT_Fixed*   tuple_coords    = NULL;\n    FT_Fixed*   im_start_coords = NULL;\n    FT_Fixed*   im_end_coords   = NULL;\n    GX_Blend    blend           = face->blend;\n    FT_UInt     point_count;\n    FT_UShort*  localpoints;\n    FT_Short*   deltas;\n\n\n    FT_TRACE2(( \"CVAR \" ));\n\n    if ( blend == NULL )\n    {\n      FT_TRACE2(( \"tt_face_vary_cvt: no blend specified\\n\" ));\n\n      error = TT_Err_Ok;\n      goto Exit;\n    }\n\n    if ( face->cvt == NULL )\n    {\n      FT_TRACE2(( \"tt_face_vary_cvt: no `cvt ' table\\n\" ));\n\n      error = TT_Err_Ok;\n      goto Exit;\n    }\n\n    error = face->goto_table( face, TTAG_cvar, stream, &table_len );\n    if ( error )\n    {\n      FT_TRACE2(( \"is missing\\n\" ));\n\n      error = TT_Err_Ok;\n      goto Exit;\n    }\n\n    if ( FT_FRAME_ENTER( table_len ) )\n    {\n      error = TT_Err_Ok;\n      goto Exit;\n    }\n\n    table_start = FT_Stream_FTell( stream );\n    if ( FT_GET_LONG() != 0x00010000L )\n    {\n      FT_TRACE2(( \"bad table version\\n\" ));\n\n      error = TT_Err_Ok;\n      goto FExit;\n    }\n\n    if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||\n         FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||\n         FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )\n      goto FExit;\n\n    tupleCount   = FT_GET_USHORT();\n    offsetToData = table_start + FT_GET_USHORT();\n\n\n    for ( i = 0; i < ( tupleCount & 0xFFF ); ++i )\n    {\n      FT_UInt   tupleDataSize;\n      FT_UInt   tupleIndex;\n      FT_Fixed  apply;\n\n\n      tupleDataSize = FT_GET_USHORT();\n      tupleIndex    = FT_GET_USHORT();\n\n\n      if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )\n      {\n        for ( j = 0; j < blend->num_axis; ++j )\n          tuple_coords[j] = FT_GET_SHORT() << 2; \n      }\n      else\n      {\n\n        if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )\n          for ( j = 0; j < 2 * blend->num_axis; ++j )\n            (void)FT_GET_SHORT();\n\n        offsetToData += tupleDataSize;\n        continue;\n      }\n\n      if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )\n      {\n        for ( j = 0; j < blend->num_axis; ++j )\n          im_start_coords[j] = FT_GET_SHORT() << 2;\n        for ( j = 0; j < blend->num_axis; ++j )\n          im_end_coords[j] = FT_GET_SHORT() << 2;\n      }\n\n      apply = ft_var_apply_tuple( blend,\n                                  (FT_UShort)tupleIndex,\n                                  tuple_coords,\n                                  im_start_coords,\n                                  im_end_coords );\n      if ( \n           apply == 0                                    ||\n           !( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS ) )\n      {\n        offsetToData += tupleDataSize;\n        continue;\n      }\n\n      here = FT_Stream_FTell( stream );\n\n      FT_Stream_SeekSet( stream, offsetToData );\n\n      localpoints = ft_var_readpackedpoints( stream, &point_count );\n      deltas      = ft_var_readpackeddeltas( stream,\n                                             point_count == 0 ? face->cvt_size\n                                                              : point_count );\n      if ( localpoints == NULL || deltas == NULL )\n;\n\n      else if ( localpoints == ALL_POINTS )\n      {\n        for ( j = 0; j < face->cvt_size; ++j )\n          face->cvt[j] = (FT_Short)( face->cvt[j] +\n                                     FT_MulFix( deltas[j], apply ) );\n      }\n\n      else\n      {\n        for ( j = 0; j < point_count; ++j )\n        {\n          int  pindex = localpoints[j];\n\n          face->cvt[pindex] = (FT_Short)( face->cvt[pindex] +\n                                          FT_MulFix( deltas[j], apply ) );\n        }\n      }\n\n      if ( localpoints != ALL_POINTS )\n        FT_FREE( localpoints );\n      FT_FREE( deltas );\n\n      offsetToData += tupleDataSize;\n\n      FT_Stream_SeekSet( stream, here );\n    }\n\n  FExit:\n    FT_FRAME_EXIT();\n\n  Exit:\n    FT_FREE( tuple_coords );\n    FT_FREE( im_start_coords );\n    FT_FREE( im_end_coords );\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186394, "func": "WarmupURLFetcher::WarmupURLFetcher(\n    CreateCustomProxyConfigCallback create_custom_proxy_config_callback,\n    WarmupURLFetcherCallback callback,\n    GetHttpRttCallback get_http_rtt_callback,\n    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,\n    const std::string& user_agent)\n    : is_fetch_in_flight_(false),\n      previous_attempt_counts_(0),\n      create_custom_proxy_config_callback_(create_custom_proxy_config_callback),\n      callback_(callback),\n      get_http_rtt_callback_(get_http_rtt_callback),\n       user_agent_(user_agent),\n       ui_task_runner_(ui_task_runner) {\n   DCHECK(create_custom_proxy_config_callback);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186515, "func": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n \n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7501, "func": "iter_unrecurse (DBusMessageDataIter *iter)\n{\n  iter->depth -= 1;\n  _dbus_assert (iter->depth >= 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7808, "func": "static int h2c_snd_settings(struct h2c *h2c)\n{\n\tstruct buffer *res;\n\tchar buf_data[100]; \n\tstruct chunk buf;\n\tint ret;\n\n\tif (h2c_mux_busy(h2c, NULL)) {\n\t\th2c->flags |= H2_CF_DEM_MBUSY;\n\t\treturn 0;\n\t}\n\n\tres = h2_get_buf(h2c, &h2c->mbuf);\n\tif (!res) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\treturn 0;\n\t}\n\n\tchunk_init(&buf, buf_data, sizeof(buf_data));\n\tchunk_memcpy(&buf,\n\t       \"\\x00\\x00\\x00\"      \n\t       \"\\x04\\x00\"          \n\t       \"\\x00\\x00\\x00\\x00\", \n\t       9);\n\n\tif (h2_settings_header_table_size != 4096) {\n\t\tchar str[6] = \"\\x00\\x01\"; \n\n\t\twrite_n32(str + 2, h2_settings_header_table_size);\n\t\tchunk_memcat(&buf, str, 6);\n\t}\n\n\tif (h2_settings_initial_window_size != 65535) {\n\t\tchar str[6] = \"\\x00\\x04\"; \n\n\t\twrite_n32(str + 2, h2_settings_initial_window_size);\n\t\tchunk_memcat(&buf, str, 6);\n\t}\n\n\tif (h2_settings_max_concurrent_streams != 0) {\n\t\tchar str[6] = \"\\x00\\x03\"; \n\n\t\twrite_n32(str + 2, h2_settings_max_concurrent_streams);\n\t\tchunk_memcat(&buf, str, 6);\n\t}\n\n\tif (global.tune.bufsize != 16384) {\n\t\tchar str[6] = \"\\x00\\x05\"; \n\n\t\twrite_n32(str + 2, global.tune.bufsize);\n\t\tchunk_memcat(&buf, str, 6);\n\t}\n\n\th2_set_frame_size(buf.str, buf.len - 9);\n\tret = bo_istput(res, ist2(buf.str, buf.len));\n\tif (unlikely(ret <= 0)) {\n\t\tif (!ret) {\n\t\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186603, "func": "void ResourceMultiBufferDataProvider::DidReceiveResponse(\n    const WebURLResponse& response) {\n#if DCHECK_IS_ON()\n  std::string version;\n  switch (response.HttpVersion()) {\n    case WebURLResponse::kHTTPVersion_0_9:\n      version = \"0.9\";\n      break;\n    case WebURLResponse::kHTTPVersion_1_0:\n      version = \"1.0\";\n      break;\n    case WebURLResponse::kHTTPVersion_1_1:\n      version = \"1.1\";\n      break;\n    case WebURLResponse::kHTTPVersion_2_0:\n      version = \"2.1\";\n      break;\n    case WebURLResponse::kHTTPVersionUnknown:\n      version = \"unknown\";\n      break;\n  }\n  DVLOG(1) << \"didReceiveResponse: HTTP/\" << version << \" \"\n           << response.HttpStatusCode();\n#endif\n  DCHECK(active_loader_);\n\n  scoped_refptr<UrlData> destination_url_data(url_data_);\n\n  if (!redirects_to_.is_empty()) {\n    destination_url_data =\n        url_data_->url_index()->GetByUrl(redirects_to_, cors_mode_);\n    redirects_to_ = GURL();\n  }\n\n  base::Time last_modified;\n  if (base::Time::FromString(\n          response.HttpHeaderField(\"Last-Modified\").Utf8().data(),\n          &last_modified)) {\n    destination_url_data->set_last_modified(last_modified);\n  }\n\n  destination_url_data->set_etag(\n      response.HttpHeaderField(\"ETag\").Utf8().data());\n\n  destination_url_data->set_valid_until(base::Time::Now() +\n                                        GetCacheValidUntil(response));\n\n  uint32_t reasons = GetReasonsForUncacheability(response);\n  destination_url_data->set_cacheable(reasons == 0);\n  UMA_HISTOGRAM_BOOLEAN(\"Media.CacheUseful\", reasons == 0);\n  int shift = 0;\n  int max_enum = base::bits::Log2Ceiling(kMaxReason);\n  while (reasons) {\n    DCHECK_LT(shift, max_enum);  \n    if (reasons & 0x1) {\n      UMA_HISTOGRAM_EXACT_LINEAR(\"Media.UncacheableReason\", shift,\n                                 max_enum);  \n    }\n\n    reasons >>= 1;\n    ++shift;\n  }\n\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n   bytes_to_discard_ = 0;\n \n  if (destination_url_data->url().SchemeIsHTTPOrHTTPS()) {\n    bool partial_response = (response.HttpStatusCode() == kHttpPartialContent);\n    bool ok_response = (response.HttpStatusCode() == kHttpOK);\n\n    std::string accept_ranges =\n        response.HttpHeaderField(\"Accept-Ranges\").Utf8();\n    if (accept_ranges.find(\"bytes\") != std::string::npos)\n      destination_url_data->set_range_supported();\n\n    if (partial_response &&\n        VerifyPartialResponse(response, destination_url_data)) {\n      destination_url_data->set_range_supported();\n    } else if (ok_response) {\n      destination_url_data->set_length(content_length);\n      bytes_to_discard_ = byte_pos();\n    } else if (response.HttpStatusCode() == kHttpRangeNotSatisfiable) {\n      end_of_file = true;\n    } else {\n      active_loader_.reset();\n      do_fail = true;\n    }\n  } else {\n    destination_url_data->set_range_supported();\n    if (content_length != kPositionNotSpecified) {\n      destination_url_data->set_length(content_length + byte_pos());\n    }\n  }\n\n  if (!do_fail) {\n    destination_url_data =\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n  destination_url_data->set_has_opaque_data(\n      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n \n   if (destination_url_data != url_data_) {\n\n    scoped_refptr<UrlData> old_url_data(url_data_);\n    destination_url_data->Use();\n\n    std::unique_ptr<DataProvider> self(\n        url_data_->multibuffer()->RemoveProvider(this));\n    url_data_ = destination_url_data.get();\n    url_data_->multibuffer()->AddProvider(std::move(self));\n\n    old_url_data->RedirectTo(destination_url_data);\n  }\n\n  if (do_fail) {\n    destination_url_data->Fail();\n    return;  \n  }\n\n  const GURL& original_url = response.WasFetchedViaServiceWorker()\n                                 ? response.OriginalURLViaServiceWorker()\n                                 : response.Url();\n  if (!url_data_->ValidateDataOrigin(original_url.GetOrigin())) {\n    active_loader_.reset();\n    url_data_->Fail();\n    return;  \n  }\n\n  if (end_of_file) {\n    fifo_.push_back(DataBuffer::CreateEOSBuffer());\n    url_data_->multibuffer()->OnDataProviderEvent(this);\n  }\n}\n", "target": 1, "flaw_line_index": "124,125,126,127"}
{"idx": 186744, "func": "Response ServiceWorkerHandler::DispatchSyncEvent(\n    const std::string& origin,\n    const std::string& registration_id,\n    const std::string& tag,\n     bool last_chance) {\n   if (!enabled_)\n     return CreateDomainNotEnabledErrorResponse();\n  if (!process_)\n     return CreateContextErrorResponse();\n   int64_t id = 0;\n   if (!base::StringToInt64(registration_id, &id))\n     return CreateInvalidVersionIdErrorResponse();\n \n  StoragePartitionImpl* partition =\n      static_cast<StoragePartitionImpl*>(process_->GetStoragePartition());\n  BackgroundSyncContext* sync_context = partition->GetBackgroundSyncContext();\n \n   BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                           base::BindOnce(&DispatchSyncEventOnIO, context_,\n                                         base::WrapRefCounted(sync_context),\n                                         GURL(origin), id, tag, last_chance));\n  return Response::OK();\n}\n", "target": 1, "flaw_line_index": "8,14,15,16"}
{"idx": 8300, "func": "XRRSetProviderOutputSource(Display *dpy, XID provider,\n\t\t\t   XID source_provider)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRSetProviderOutputSourceReq *req;\n\n    RRCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (RRSetProviderOutputSource, req);\n    req->reqType = info->codes->major_opcode;\n    req->randrReqType = X_RRSetProviderOutputSource;\n    req->provider = provider;\n    req->source_provider = source_provider;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7831, "func": "  Update_Max( FT_Memory  memory,\n              FT_ULong*  size,\n              FT_Long    multiplier,\n              void*      _pbuff,\n              FT_ULong   new_max )\n  {\n    FT_Error  error;\n    void**    pbuff = (void**)_pbuff;\n\n\n    if ( *size < new_max )\n    {\n      if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )\n        return error;\n      *size = new_max;\n    }\n\n    return TT_Err_Ok;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186814, "func": " void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n                                                 callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n                                                callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n                                                 callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n          Java_PlatformSensorProvider_createSensor(env, j_object_,\n                                                   static_cast<jint>(type));\n\n      if (!sensor.obj()) {\n        callback.Run(nullptr);\n        return;\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n          type, std::move(mapping), this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n  }\n}\n", "target": 1, "flaw_line_index": "3,12,13,16,17,20,21,34"}
{"idx": 186929, "func": "Page* ChromeClientImpl::CreateWindow(LocalFrame* frame,\n                                     const FrameLoadRequest& r,\n                                     const WebWindowFeatures& features,\n                                     NavigationPolicy navigation_policy,\n                                     SandboxFlags sandbox_flags) {\n  if (!web_view_->Client())\n    return nullptr;\n \n   if (!frame->GetPage() || frame->GetPage()->Paused())\n     return nullptr;\n  DCHECK(frame->GetDocument());\n  Fullscreen::FullyExitFullscreen(*frame->GetDocument());\n \n   const AtomicString& frame_name =\n       !EqualIgnoringASCIICase(r.FrameName(), \"_blank\") ? r.FrameName()\n                                                       : g_empty_atom;\n  WebViewImpl* new_view =\n      static_cast<WebViewImpl*>(web_view_->Client()->CreateView(\n          WebLocalFrameImpl::FromFrame(frame),\n          WrappedResourceRequest(r.GetResourceRequest()), features, frame_name,\n          static_cast<WebNavigationPolicy>(navigation_policy),\n          r.GetShouldSetOpener() == kNeverSetOpener,\n          static_cast<WebSandboxFlags>(sandbox_flags)));\n  if (!new_view)\n    return nullptr;\n  return new_view->GetPage();\n}\n", "target": 1, "flaw_line_index": "11,12"}
{"idx": 8130, "func": "void Gfx::opMarkPoint(Object args[], int numArgs) {\n  if (printCommands) {\n    printf(\"  mark point: %s \", args[0].getName());\n    if (numArgs == 2)\n      args[1].print(stdout);\n    printf(\"\\n\");\n    fflush(stdout);\n  }\n\n  if(numArgs == 2 && args[1].isDict()) {\n    out->markPoint(args[0].getName(),args[1].getDict());\n  } else {\n    out->markPoint(args[0].getName());\n  }\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187078, "func": "void MediaStreamDispatcherHost::DoGenerateStream(\n    int32_t page_request_id,\n    const StreamControls& controls,\n    bool user_gesture,\n    GenerateStreamCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(MEDIA_DEVICE_INVALID_SECURITY_ORIGIN, std::string(),\n                            MediaStreamDevices(), MediaStreamDevices());\n    return;\n   }\n \n   media_stream_manager_->GenerateStream(\n      render_process_id_, render_frame_id_, page_request_id, controls,\n      std::move(salt_and_origin), user_gesture, std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceChanged,\n                          weak_factory_.GetWeakPtr()));\n}\n", "target": 1, "flaw_line_index": "16,17"}
{"idx": 186489, "func": " void TabStrip::ChangeTabGroup(int model_index,\n                               base::Optional<int> old_group,\n                               base::Optional<int> new_group) {\n   if (new_group.has_value() && !group_headers_[new_group.value()]) {\n    const TabGroupData* group_data =\n        controller_->GetDataForGroup(new_group.value());\n    auto header = std::make_unique<TabGroupHeader>(group_data->title());\n     header->set_owned_by_client();\n     AddChildView(header.get());\n     group_headers_[new_group.value()] = std::move(header);\n  }\n  if (old_group.has_value() &&\n      controller_->ListTabsInGroup(old_group.value()).size() == 0) {\n    group_headers_.erase(old_group.value());\n  }\n  UpdateIdealBounds();\n  AnimateToIdealBounds();\n}\n", "target": 1, "flaw_line_index": "5,6,7"}
{"idx": 186823, "func": " void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n          std::move(mapping), this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n      PlatformSensorFusion::Create(std::move(mapping), this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION: {\n      auto orientation_quaternion_fusion_algorithm_using_euler_angles =\n          std::make_unique<\n              OrientationQuaternionFusionAlgorithmUsingEulerAngles>(\n              false \n);\n       PlatformSensorFusion::Create(\n          std::move(mapping), this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;\n    }\n    default:\n      callback.Run(nullptr);\n  }\n}\n", "target": 1, "flaw_line_index": "3,9,15,23,36"}
{"idx": 7658, "func": "static void prstatfs_to_statfs(struct statfs *stfs, ProxyStatFS *prstfs)\n{\n    memset(stfs, 0, sizeof(*stfs));\n    stfs->f_type = prstfs->f_type;\n    stfs->f_bsize = prstfs->f_bsize;\n    stfs->f_blocks = prstfs->f_blocks;\n    stfs->f_bfree = prstfs->f_bfree;\n    stfs->f_bavail = prstfs->f_bavail;\n    stfs->f_files = prstfs->f_files;\n    stfs->f_ffree = prstfs->f_ffree;\n    stfs->f_fsid.__val[0] = prstfs->f_fsid[0] & 0xFFFFFFFFU;\n    stfs->f_fsid.__val[1] = prstfs->f_fsid[1] >> 32 & 0xFFFFFFFFU;\n    stfs->f_namelen = prstfs->f_namelen;\n    stfs->f_frsize = prstfs->f_frsize;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186706, "func": "IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(\n    base::StringPiece host,\n    base::OffsetAdjuster::Adjustments* adjustments,\n    bool enable_spoof_checks) {\n  if (adjustments)\n    adjustments->clear();\n  base::string16 input16;\n   input16.reserve(host.length());\n   input16.insert(input16.end(), host.begin(), host.end());\n \n  bool is_tld_ascii = true;\n   size_t last_dot = host.rfind('.');\n  if (last_dot != base::StringPiece::npos &&\n      host.substr(last_dot).starts_with(\".xn--\")) {\n    is_tld_ascii = false;\n   }\n \n   IDNConversionResult result;\n  base::string16 out16;\n  for (size_t component_start = 0, component_end;\n       component_start < input16.length();\n       component_start = component_end + 1) {\n    component_end = input16.find('.', component_start);\n    if (component_end == base::string16::npos)\n      component_end = input16.length();  \n    size_t component_length = component_end - component_start;\n    size_t new_component_start = out16.length();\n    bool converted_idn = false;\n    if (component_end > component_start) {\n       bool has_idn_component = false;\n       converted_idn = IDNToUnicodeOneComponent(\n          input16.data() + component_start, component_length, is_tld_ascii,\n           enable_spoof_checks, &out16, &has_idn_component);\n       result.has_idn_component |= has_idn_component;\n     }\n    size_t new_component_length = out16.length() - new_component_start;\n\n    if (converted_idn && adjustments) {\n      adjustments->push_back(base::OffsetAdjuster::Adjustment(\n          component_start, component_length, new_component_length));\n    }\n\n    if (component_end < input16.length())\n      out16.push_back('.');\n  }\n\n  result.result = out16;\n\n  if (result.has_idn_component) {\n    result.matching_top_domain =\n        g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);\n    if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {\n      if (adjustments)\n        adjustments->clear();\n      result.result = input16;\n    }\n  }\n\n  return result;\n}\n", "target": 1, "flaw_line_index": "12,14,15,16,37"}
{"idx": 8092, "func": "PopplerCache *Gfx::getIccColorSpaceCache()\n{\n  return &iccColorSpaceCache;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7678, "func": "static int handle_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,\n                       const char *name, FsCred *credp)\n{\n    int dirfd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    ret = mkdirat(dirfd, name, credp->fc_mode);\n    if (!ret) {\n        ret = handle_update_file_cred(dirfd, name, credp);\n    }\n    close(dirfd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186544, "func": " void SupervisedUserService::InitSync(const std::string& refresh_token) {\n   ProfileOAuth2TokenService* token_service =\n       ProfileOAuth2TokenServiceFactory::GetForProfile(profile_);\n  token_service->UpdateCredentials(supervised_users::kSupervisedUserPseudoEmail,\n                                   refresh_token);\n }\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 7419, "func": "ZEND_API int zend_ts_hash_del(TsHashTable *ht, zend_string *key)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_del(TS_HASH(ht), key);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186368, "func": " void TabletModeWindowManager::ForgetWindow(aura::Window* window,\n                                           bool destroyed) {\n   added_windows_.erase(window);\n   window->RemoveObserver(this);\n \n  WindowToState::iterator it = window_state_map_.find(window);\n  if (it == window_state_map_.end())\n    return;\n\n  if (destroyed) {\n    window_state_map_.erase(it);\n   } else {\n    it->second->LeaveTabletMode(wm::GetWindowState(it->first));\n     DCHECK(!IsTrackingWindow(window));\n   }\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186326, "func": "void CheckClientDownloadRequest::UploadBinary(\n    DownloadCheckResult result,\n    DownloadCheckResultReason reason) {\n  saved_result_ = result;\n  saved_reason_ = reason;\n\n  bool upload_for_dlp = ShouldUploadForDlpScan();\n  bool upload_for_malware = ShouldUploadForMalwareScan(reason);\n  auto request = std::make_unique<DownloadItemRequest>(\n      item_, \ntrue,\n      base::BindOnce(&CheckClientDownloadRequest::OnDeepScanningComplete,\n                     weakptr_factory_.GetWeakPtr()));\n\n  Profile* profile = Profile::FromBrowserContext(GetBrowserContext());\n\n  if (upload_for_dlp) {\n    DlpDeepScanningClientRequest dlp_request;\n    dlp_request.set_content_source(DlpDeepScanningClientRequest::FILE_DOWNLOAD);\n    request->set_request_dlp_scan(std::move(dlp_request));\n  }\n\n  if (upload_for_malware) {\n    MalwareDeepScanningClientRequest malware_request;\n    malware_request.set_population(\n        MalwareDeepScanningClientRequest::POPULATION_ENTERPRISE);\n    malware_request.set_download_token(\n        DownloadProtectionService::GetDownloadPingToken(item_));\n     request->set_request_malware_scan(std::move(malware_request));\n   }\n \n  request->set_dm_token(\n      policy::BrowserDMTokenStorage::Get()->RetrieveDMToken());\n \n   service()->UploadForDeepScanning(profile, std::move(request));\n }\n", "target": 1, "flaw_line_index": "32,33"}
{"idx": 186528, "func": "DataReductionProxySettings::~DataReductionProxySettings() {\n  spdy_proxy_auth_enabled_.Destroy();\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 186508, "func": "void SendTabToSelfInfoBar::ShowInfoBar(content::WebContents* web_contents,\n                                       SendTabToSelfInfoBarDelegate* delegate) {\n  NOTIMPLEMENTED();\n }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 186457, "func": "  explicit ConsoleCallbackFilter(\n      base::Callback<void(const base::string16&)> callback)\n      : callback_(callback) {}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 7593, "func": "static void cirrus_mmio_write(void *opaque, hwaddr addr,\n                              uint64_t val, unsigned size)\n{\n    CirrusVGAState *s = opaque;\n\n    if (addr >= 0x100) {\n\tcirrus_mmio_blt_write(s, addr - 0x100, val);\n    } else {\n        cirrus_vga_ioport_write(s, addr + 0x10, val, size);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8212, "func": "static void v9fs_create(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsQID qid;\n    int32_t perm;\n    int8_t mode;\n    V9fsPath path;\n    struct stat stbuf;\n    V9fsString name;\n    V9fsString extension;\n    int iounit;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_path_init(&path);\n    v9fs_string_init(&name);\n    v9fs_string_init(&extension);\n    err = pdu_unmarshal(pdu, offset, \"dsdbs\", &fid, &name,\n                        &perm, &mode, &extension);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_create(pdu->tag, pdu->id, fid, name.data, perm, mode);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (perm & P9_STAT_MODE_DIR) {\n        err = v9fs_co_mkdir(pdu, fidp, &name, perm & 0777,\n                            fidp->uid, -1, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n        err = v9fs_co_opendir(pdu, fidp);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_DIR;\n    } else if (perm & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_symlink(pdu, fidp, &name,\n                              extension.data, -1 , &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else if (perm & P9_STAT_MODE_LINK) {\n        int32_t ofid = atoi(extension.data);\n        V9fsFidState *ofidp = get_fid(pdu, ofid);\n        if (ofidp == NULL) {\n            err = -EINVAL;\n            goto out;\n        }\n        err = v9fs_co_link(pdu, ofidp, fidp, &name);\n        put_fid(pdu, ofidp);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            fidp->fid_type = P9_FID_NONE;\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n        err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n        if (err < 0) {\n            fidp->fid_type = P9_FID_NONE;\n            goto out;\n        }\n    } else if (perm & P9_STAT_MODE_DEVICE) {\n        char ctype;\n        uint32_t major, minor;\n        mode_t nmode = 0;\n\n        if (sscanf(extension.data, \"%c %u %u\", &ctype, &major, &minor) != 3) {\n            err = -errno;\n            goto out;\n        }\n\n        switch (ctype) {\n        case 'c':\n            nmode = S_IFCHR;\n            break;\n        case 'b':\n            nmode = S_IFBLK;\n            break;\n        default:\n            err = -EIO;\n            goto out;\n        }\n\n        nmode |= perm & 0777;\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n                            makedev(major, minor), nmode, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else if (perm & P9_STAT_MODE_NAMED_PIPE) {\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n                            0, S_IFIFO | (perm & 0777), &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else if (perm & P9_STAT_MODE_SOCKET) {\n        err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,\n                            0, S_IFSOCK | (perm & 0777), &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        v9fs_path_copy(&fidp->path, &path);\n    } else {\n        err = v9fs_co_open2(pdu, fidp, &name, -1,\n                            omode_to_uflags(mode)|O_CREAT, perm, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_FILE;\n        fidp->open_flags = omode_to_uflags(mode);\n        if (fidp->open_flags & O_EXCL) {\n            fidp->flags |= FID_NON_RECLAIMABLE;\n        }\n    }\n    iounit = get_iounit(pdu, &fidp->path);\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_create_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path, iounit);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n   pdu_complete(pdu, err);\n   v9fs_string_free(&name);\n   v9fs_string_free(&extension);\n   v9fs_path_free(&path);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7539, "func": "extend_abbrs (char *abbrs, char const *abbr, size_t abbr_size)\n{\n  memcpy (abbrs, abbr, abbr_size);\n  abbrs[abbr_size] = '\\0';\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187290, "func": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n \n   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n   v8::Local<v8::Value> exports;\n  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n       !exports->IsUndefined())\n     return handle_scope.Escape(exports);\n \n   exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetProperty(v8_context, modules, module_name, exports);\n   return handle_scope.Escape(exports);\n }\n", "target": 1, "flaw_line_index": "21,26"}
{"idx": 7819, "func": "  Init_Context( TT_ExecContext  exec,\n                FT_Memory       memory )\n  {\n    FT_Error  error;\n\n\n    FT_TRACE1(( \"Init_Context: new object at 0x%08p\\n\", exec ));\n\n    exec->memory   = memory;\n    exec->callSize = 32;\n\n    if ( FT_NEW_ARRAY( exec->callStack, exec->callSize ) )\n      goto Fail_Memory;\n\n    exec->maxPoints   = 0;\n    exec->maxContours = 0;\n\n    exec->stackSize = 0;\n    exec->glyphSize = 0;\n\n    exec->stack     = NULL;\n    exec->glyphIns  = NULL;\n\n    exec->face = NULL;\n    exec->size = NULL;\n\n    return TT_Err_Ok;\n\n  Fail_Memory:\n    FT_ERROR(( \"Init_Context: not enough memory for 0x%08lx\\n\",\n               (FT_Long)exec ));\n    TT_Done_Context( exec );\n\n    return error;\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7465, "func": "DBusHelperProxy::~DBusHelperProxy()\n{\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187285, "func": " FileStream::FileStream(base::File file,\n                        const scoped_refptr<base::TaskRunner>& task_runner)\n    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8291, "func": "XRRDeleteMonitor(Display *dpy, Window window, Atom name)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRDeleteMonitorReq\t    *req;\n\n    RRSimpleCheckExtension (dpy, info);\n\n    LockDisplay(dpy);\n    GetReq (RRDeleteMonitor, req);\n    req->reqType = info->codes->major_opcode;\n    req->randrReqType = X_RRDeleteMonitor;\n    req->window = window;\n    req->name = name;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186856, "func": "void MojoAudioOutputStream::OnStreamCreated(\n    int stream_id,\n    const base::SharedMemory* shared_memory,\n    std::unique_ptr<base::CancelableSyncSocket> foreign_socket) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(stream_created_callback_);\n  DCHECK(shared_memory);\n  DCHECK(foreign_socket);\n\n  base::SharedMemoryHandle foreign_memory_handle =\n      base::SharedMemory::DuplicateHandle(shared_memory->handle());\n  if (!base::SharedMemory::IsHandleValid(foreign_memory_handle)) {\n    OnStreamError(\n 0);\n    return;\n   }\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n      foreign_memory_handle, shared_memory->requested_size(), false);\n   mojo::ScopedHandle socket_handle =\n       mojo::WrapPlatformFile(foreign_socket->Release());\n \n  DCHECK(buffer_handle.is_valid());\n  DCHECK(socket_handle.is_valid());\n\n  base::ResetAndReturn(&stream_created_callback_)\n      .Run(std::move(buffer_handle), std::move(socket_handle));\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 186771, "func": "void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {\n  LocalizedString localized_strings[] = {\n      {\"passwordsAndAutofillPageTitle\",\n       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},\n       {\"autofill\", IDS_SETTINGS_AUTOFILL},\n       {\"googlePayments\", IDS_SETTINGS_GOOGLE_PAYMENTS},\n       {\"googlePaymentsCached\", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},\n       {\"addresses\", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},\n       {\"addAddressTitle\", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},\n       {\"editAddressTitle\", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},\n      {\"addressCountry\", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},\n      {\"addressPhone\", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},\n      {\"addressEmail\", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},\n      {\"removeAddress\", IDS_SETTINGS_ADDRESS_REMOVE},\n      {\"creditCards\", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},\n      {\"removeCreditCard\", IDS_SETTINGS_CREDIT_CARD_REMOVE},\n      {\"clearCreditCard\", IDS_SETTINGS_CREDIT_CARD_CLEAR},\n      {\"creditCardType\", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},\n      {\"creditCardExpiration\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},\n      {\"creditCardName\", IDS_SETTINGS_NAME_ON_CREDIT_CARD},\n      {\"creditCardNumber\", IDS_SETTINGS_CREDIT_CARD_NUMBER},\n      {\"creditCardExpirationMonth\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},\n      {\"creditCardExpirationYear\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},\n      {\"creditCardExpired\", IDS_SETTINGS_CREDIT_CARD_EXPIRED},\n      {\"editCreditCardTitle\", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},\n       {\"addCreditCardTitle\", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},\n       {\"autofillDetail\", IDS_SETTINGS_AUTOFILL_DETAIL},\n       {\"passwords\", IDS_SETTINGS_PASSWORDS},\n       {\"passwordsAutosigninLabel\",\n        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},\n       {\"passwordsAutosigninDescription\",\n       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},\n      {\"passwordsDetail\", IDS_SETTINGS_PASSWORDS_DETAIL},\n      {\"savedPasswordsHeading\", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},\n      {\"passwordExceptionsHeading\", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},\n      {\"deletePasswordException\", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},\n      {\"removePassword\", IDS_SETTINGS_PASSWORD_REMOVE},\n      {\"searchPasswords\", IDS_SETTINGS_PASSWORD_SEARCH},\n      {\"showPassword\", IDS_SETTINGS_PASSWORD_SHOW},\n      {\"hidePassword\", IDS_SETTINGS_PASSWORD_HIDE},\n      {\"passwordDetailsTitle\", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},\n      {\"passwordViewDetails\", IDS_SETTINGS_PASSWORD_DETAILS},\n      {\"editPasswordWebsiteLabel\", IDS_SETTINGS_PASSWORDS_WEBSITE},\n      {\"editPasswordUsernameLabel\", IDS_SETTINGS_PASSWORDS_USERNAME},\n      {\"editPasswordPasswordLabel\", IDS_SETTINGS_PASSWORDS_PASSWORD},\n      {\"noAddressesFound\", IDS_SETTINGS_ADDRESS_NONE},\n      {\"noCreditCardsFound\", IDS_SETTINGS_CREDIT_CARD_NONE},\n      {\"noCreditCardsPolicy\", IDS_SETTINGS_CREDIT_CARD_DISABLED},\n      {\"noPasswordsFound\", IDS_SETTINGS_PASSWORDS_NONE},\n      {\"noExceptionsFound\", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},\n      {\"import\", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},\n      {\"exportMenuItem\", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},\n      {\"undoRemovePassword\", IDS_SETTINGS_PASSWORD_UNDO},\n      {\"passwordDeleted\", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},\n      {\"exportPasswordsTitle\", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},\n      {\"exportPasswordsDescription\", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},\n      {\"exportPasswords\", IDS_SETTINGS_PASSWORDS_EXPORT},\n      {\"exportingPasswordsTitle\", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},\n      {\"exportPasswordsTryAgain\", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},\n      {\"exportPasswordsFailTitle\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},\n      {\"exportPasswordsFailTips\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},\n      {\"exportPasswordsFailTipsEnoughSpace\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},\n      {\"exportPasswordsFailTipsAnotherFolder\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};\n\n  html_source->AddString(\n      \"managePasswordsLabel\",\n      l10n_util::GetStringFUTF16(\n          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,\n          base::ASCIIToUTF16(\n              password_manager::kPasswordManagerAccountDashboardURL)));\n  html_source->AddString(\"passwordManagerLearnMoreURL\",\n                         chrome::kPasswordManagerLearnMoreURL);\n  html_source->AddString(\"manageAddressesUrl\",\n                         autofill::payments::GetManageAddressesUrl(0).spec());\n  html_source->AddString(\"manageCreditCardsUrl\",\n                         autofill::payments::GetManageInstrumentsUrl(0).spec());\n\n  AddLocalizedStringsBulk(html_source, localized_strings,\n                          arraysize(localized_strings));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187143, "func": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }\n", "target": 1, "flaw_line_index": "12"}
{"idx": 8228, "func": "static void v9fs_readlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    size_t offset = 7;\n    V9fsString target;\n    int32_t fid;\n    int err = 0;\n    V9fsFidState *fidp;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_readlink(pdu->tag, pdu->id, fid);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    v9fs_string_init(&target);\n    err = v9fs_co_readlink(pdu, &fidp->path, &target);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"s\", &target);\n    if (err < 0) {\n        v9fs_string_free(&target);\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_readlink_return(pdu->tag, pdu->id, target.data);\n    v9fs_string_free(&target);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8181, "func": "void Gfx::restoreState() {\n  if (stackHeight <= bottomGuard() || !state->hasSaves()) {\n    error(-1, \"Restoring state when no valid states to pop\");\n    commandAborted = gTrue;\n    return;\n  }\n  state = state->restore();\n  out->restoreState(state);\n  stackHeight--;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8127, "func": "void Gfx::opFillStroke(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    return;\n  }\n  if (state->isPath() && !contentIsHidden()) {\n    if (state->getFillColorSpace()->getMode() == csPattern) {\n      doPatternFill(gFalse);\n    } else {\n      out->fill(state);\n    }\n    if (state->getStrokeColorSpace()->getMode() == csPattern) {\n      doPatternStroke();\n    } else {\n      out->stroke(state);\n    }\n  }\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187300, "func": "void ObjectBackedNativeHandler::RouteFunction(\n    const std::string& name,\n    const std::string& feature_name,\n    const HandlerFunction& handler_function) {\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope handle_scope(isolate);\n  v8::Context::Scope context_scope(context_->v8_context());\n\n   v8::Local<v8::Object> data = v8::Object::New(isolate);\n   SetPrivate(data, kHandlerFunction,\n              v8::External::New(isolate, new HandlerFunction(handler_function)));\n   SetPrivate(data, kFeatureName,\n              v8_helpers::ToV8StringUnsafe(isolate, feature_name));\n   v8::Local<v8::FunctionTemplate> function_template =\n      v8::FunctionTemplate::New(isolate, Router, data);\n  v8::Local<v8::ObjectTemplate>::New(isolate, object_template_)\n      ->Set(isolate, name.c_str(), function_template);\n  router_data_.Append(data);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7894, "func": "static void analyze(JF, js_Ast *node)\n{\n\tif (isfun(node->type)) {\n\t\tF->lightweight = 0;\n\t\treturn; \n\t}\n\n\tif (node->type == STM_WITH) {\n\t\tF->lightweight = 0;\n\t}\n\n\tif (node->type == STM_TRY && node->c) {\n\t\tF->lightweight = 0;\n\t}\n\n\tif (node->type == EXP_IDENTIFIER) {\n\t\tif (!strcmp(node->string, \"arguments\")) {\n\t\t\tF->lightweight = 0;\n\t\t\tF->arguments = 1;\n\t\t} else if (!strcmp(node->string, \"eval\")) {\n\t\t\tif (!node->parent || node->parent->type != EXP_CALL || node->parent->a != node)\n\t\t\t\tjs_evalerror(J, \"%s:%d: invalid use of 'eval'\", J->filename, node->line);\n\t\t\tF->lightweight = 0;\n\t\t}\n\t}\n\n\tif (node->a) analyze(J, F, node->a);\n\tif (node->b) analyze(J, F, node->b);\n\tif (node->c) analyze(J, F, node->c);\n\tif (node->d) analyze(J, F, node->d);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186804, "func": " void PlatformSensorFusion::Create(\n    mojo::ScopedSharedBufferMapping mapping,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n                               callback, provider);\n }\n", "target": 1, "flaw_line_index": "2,6"}
{"idx": 186908, "func": "bool IsBlockedNavigation(net::Error error_code) {\n  switch (error_code) {\n    case net::ERR_BLOCKED_BY_CLIENT:\n    case net::ERR_BLOCKED_BY_RESPONSE:\n    case net::ERR_BLOCKED_BY_XSS_AUDITOR:\n    case net::ERR_UNSAFE_REDIRECT:\n      return true;\n    default:\n      return false;\n  }\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11"}
{"idx": 8109, "func": "void Gfx::opBeginText(Object args[], int numArgs) {\n  out->beginTextObject(state);\n  drawText = gTrue;\n  state->setTextMat(1, 0, 0, 1, 0, 0);\n  state->textMoveTo(0, 0);\n  out->updateTextMat(state);\n  out->updateTextPos(state);\n  fontChanged = gTrue;\n  if (out->supportTextCSPattern(state)) {\n    textHaveCSPattern = gTrue;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7815, "func": "static int h2s_frt_make_resp_headers(struct h2s *h2s, struct buffer *buf)\n{\n\tstruct http_hdr list[MAX_HTTP_HDR];\n\tstruct h2c *h2c = h2s->h2c;\n\tstruct h1m *h1m = &h2s->res;\n\tstruct chunk outbuf;\n\tint es_now = 0;\n\tint ret = 0;\n\tint hdr;\n\n\tif (h2c_mux_busy(h2c, h2s)) {\n\t\th2s->flags |= H2_SF_BLK_MBUSY;\n\t\treturn 0;\n\t}\n\n\tif (!h2_get_buf(h2c, &h2c->mbuf)) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\treturn 0;\n\t}\n\n\tret = h1_headers_to_hdr_list(bo_ptr(buf), bo_ptr(buf) + buf->o,\n\t                             list, sizeof(list)/sizeof(list[0]), h1m);\n\tif (ret <= 0) {\n\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tchunk_reset(&outbuf);\n\n\twhile (1) {\n\t\toutbuf.str  = bo_end(h2c->mbuf);\n\t\toutbuf.size = bo_contig_space(h2c->mbuf);\n\t\toutbuf.len = 0;\n\n\t\tif (outbuf.size >= 9 || !buffer_space_wraps(h2c->mbuf))\n\t\t\tbreak;\n\trealign_again:\n\t\tbuffer_slow_realign(h2c->mbuf);\n\t}\n\n\tif (outbuf.size < 9) {\n\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tmemcpy(outbuf.str, \"\\x00\\x00\\x00\\x01\\x04\", 5);\n\twrite_n32(outbuf.str + 5, h2s->id); \n\toutbuf.len = 9;\n\n\tif (outbuf.len < outbuf.size && h1m->status == 200)\n\t\toutbuf.str[outbuf.len++] = 0x88; \n\telse if (outbuf.len < outbuf.size && h1m->status == 304)\n\t\toutbuf.str[outbuf.len++] = 0x8b; \n\telse if (unlikely(list[0].v.len != 3)) {\n\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\telse if (unlikely(outbuf.len + 2 + 3 <= outbuf.size)) {\n\t\toutbuf.str[outbuf.len++] = 0x48; \n\t\toutbuf.str[outbuf.len++] = 0x03; \n\t\toutbuf.str[outbuf.len++] = list[0].v.ptr[0];\n\t\toutbuf.str[outbuf.len++] = list[0].v.ptr[1];\n\t\toutbuf.str[outbuf.len++] = list[0].v.ptr[2];\n\t}\n\telse {\n\t\tif (buffer_space_wraps(h2c->mbuf))\n\t\t\tgoto realign_again;\n\n\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tfor (hdr = 1; hdr < sizeof(list)/sizeof(list[0]); hdr++) {\n\t\tif (isteq(list[hdr].n, ist(\"connection\")) ||\n\t\t    isteq(list[hdr].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[hdr].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[hdr].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[hdr].n, ist(\"transfer-encoding\")))\n\t\t\tcontinue;\n\n\t\tif (isteq(list[hdr].n, ist(\"\")))\n\t\t\tbreak; \n\n\t\tif (!hpack_encode_header(&outbuf, list[hdr].n, list[hdr].v)) {\n\t\t\tif (buffer_space_wraps(h2c->mbuf))\n\t\t\t\tgoto realign_again;\n\n\t\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\t\tret = 0;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (((h1m->flags & H1_MF_CLEN) && !h1m->body_len) || h2s->cs->flags & CS_FL_SHW)\n\t\tes_now = 1;\n\n\th2_set_frame_size(outbuf.str, outbuf.len - 9);\n\n\tif (es_now)\n\t\toutbuf.str[4] |= H2_F_HEADERS_END_STREAM;\n\n\tbo_del(buf, ret);\n\n\th2c->mbuf->o += outbuf.len;\n\th2c->mbuf->p = b_ptr(h2c->mbuf, outbuf.len);\n\th2s->flags |= H2_SF_HEADERS_SENT;\n\n\tif (es_now) {\n\t\tbo_del(buf, buf->o);\n\n\t\th1m->state = HTTP_MSG_DONE;\n\t\th2s->flags |= H2_SF_ES_SENT;\n\t\tif (h2s->st == H2_SS_OPEN)\n\t\t\th2s->st = H2_SS_HLOC;\n\t\telse\n\t\t\th2s_close(h2s);\n\t}\n\telse if (h1m->status >= 100 && h1m->status < 200) {\n\t\th1m->state = HTTP_MSG_RPBEFORE;\n\t\th1m->status = 0;\n\t\th1m->flags = 0;\n\t\tgoto end;\n\t}\n\telse\n\t\th1m->state = (h1m->flags & H1_MF_CHNK) ? HTTP_MSG_CHUNK_SIZE : HTTP_MSG_BODY;\n\n end:\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187067, "func": " void PaymentRequest::NoUpdatedPaymentDetails() {\n   spec_->RecomputeSpecForDetails();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8206, "func": "static int put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7475, "func": "ssize_t local_getxattr_nofollow(FsContext *ctx, const char *path,\n                                const char *name, void *value, size_t size)\n{\n    char *dirpath = g_path_get_dirname(path);\n    char *filename = g_path_get_basename(path);\n    int dirfd;\n    ssize_t ret = -1;\n\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    if (dirfd == -1) {\n        goto out;\n    }\n\n    ret = fgetxattrat_nofollow(dirfd, filename, name, value, size);\n    close_preserve_errno(dirfd);\nout:\n    g_free(dirpath);\n    g_free(filename);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7404, "func": "ZEND_API void _zend_ts_hash_init(TsHashTable *ht, uint nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n#ifdef ZTS\n\tht->mx_reader = tsrm_mutex_alloc();\n\tht->mx_writer = tsrm_mutex_alloc();\n\tht->reader = 0;\n#endif\n\t_zend_hash_init(TS_HASH(ht), nSize, pDestructor, persistent ZEND_FILE_LINE_RELAY_CC);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7586, "func": "static uint64_t cirrus_linear_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    addr &= s->cirrus_addr_mask;\n\n    if (((s->vga.sr[0x17] & 0x44) == 0x44) &&\n        ((addr & s->linear_mmio_mask) == s->linear_mmio_mask)) {\n\tret = cirrus_mmio_blt_read(s, addr & 0xff);\n    } else if (0) {\n\tret = 0xff;\n    } else {\n\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\t    addr <<= 4;\n\t} else if (s->vga.gr[0x0B] & 0x02) {\n\t    addr <<= 3;\n\t}\n\taddr &= s->cirrus_addr_mask;\n\tret = *(s->vga.vram_ptr + addr);\n    }\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186428, "func": "GURL SanitizeFrontendURL(\n    const GURL& url,\n    const std::string& scheme,\n    const std::string& host,\n    const std::string& path,\n    bool allow_query) {\n  std::vector<std::string> query_parts;\n  if (allow_query) {\n    for (net::QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n      std::string value = SanitizeFrontendQueryParam(it.GetKey(),\n          it.GetValue());\n      if (!value.empty()) {\n        query_parts.push_back(\n            base::StringPrintf(\"%s=%s\", it.GetKey().c_str(), value.c_str()));\n      }\n    }\n  }\n  std::string query =\n      query_parts.empty() ? \"\" : \"?\" + base::JoinString(query_parts, \"&\");\n  std::string constructed = base::StringPrintf(\"%s:\n      scheme.c_str(), host.c_str(), path.c_str(), query.c_str());\n  GURL result = GURL(constructed);\n  if (!result.is_valid())\n    return GURL();\n  return result;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26"}
{"idx": 186951, "func": "bool AppCacheDatabase::FindCache(int64_t cache_id, CacheRecord* record) {\n  DCHECK(record);\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, group_id, online_wildcard, update_time, cache_size\"\n       \" FROM Caches WHERE cache_id = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, cache_id);\n\n  if (!statement.Step())\n    return false;\n\n  ReadCacheRecord(statement, record);\n  return true;\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 186602, "func": "void MultibufferDataSource::StartCallback() {\n  DCHECK(render_task_runner_->BelongsToCurrentThread());\n\n  if (!init_cb_) {\n    SetReader(nullptr);\n    return;\n  }\n\n  bool success = reader_ && reader_->Available() > 0 && url_data() &&\n                 (!assume_fully_buffered() ||\n                  url_data()->length() != kPositionNotSpecified);\n\n  if (success) {\n    {\n      base::AutoLock auto_lock(lock_);\n      total_bytes_ = url_data()->length();\n    }\n    streaming_ =\n        !assume_fully_buffered() && (total_bytes_ == kPositionNotSpecified ||\n                                     !url_data()->range_supported());\n\n    media_log_->SetDoubleProperty(\"total_bytes\",\n                                  static_cast<double>(total_bytes_));\n    media_log_->SetBooleanProperty(\"streaming\", streaming_);\n  } else {\n    SetReader(nullptr);\n  }\n\n  base::AutoLock auto_lock(lock_);\n  if (stop_signal_received_)\n    return;\n\n  if (success) {\n    if (total_bytes_ != kPositionNotSpecified) {\n      host_->SetTotalBytes(total_bytes_);\n      if (assume_fully_buffered())\n        host_->AddBufferedByteRange(0, total_bytes_);\n    }\n\n     media_log_->SetBooleanProperty(\"single_origin\", single_origin_);\n    media_log_->SetBooleanProperty(\"passed_cors_access_check\",\n                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\"range_header_supported\",\n                                    url_data()->range_supported());\n   }\n\n  render_task_runner_->PostTask(FROM_HERE,\n                                base::Bind(std::move(init_cb_), success));\n\n  UpdateBufferSizes();\n\n  UpdateLoadingState_Locked(true);\n}\n", "target": 1, "flaw_line_index": "47,48"}
{"idx": 7813, "func": "static inline __maybe_unused void h2s_error(struct h2s *h2s, enum h2_err err)\n{\n\tif (h2s->st > H2_SS_IDLE && h2s->st < H2_SS_ERROR) {\n\t\th2s->errcode = err;\n\t\th2s->st = H2_SS_ERROR;\n\t\tif (h2s->cs)\n\t\t\th2s->cs->flags |= CS_FL_ERROR;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8286, "func": "short *XRRRates (Display *dpy, int screen, int sizeID, int *nrates)\n{\n  XRRScreenConfiguration *config;\n  XExtDisplayInfo *info = XRRFindDisplay(dpy);\n  short *rates;\n\n  LockDisplay(dpy);\n  if ((config = _XRRValidateCache(dpy, info, screen))) {\n    rates = XRRConfigRates (config, sizeID, nrates);\n    UnlockDisplay(dpy);\n    return rates;\n    }\n  else {\n    UnlockDisplay(dpy);\n    *nrates = 0;\n    return NULL;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187242, "func": "IndexedDBTransaction::IndexedDBTransaction(\n    int64_t id,\n    IndexedDBConnection* connection,\n    const std::set<int64_t>& object_store_ids,\n    blink::WebIDBTransactionMode mode,\n    IndexedDBBackingStore::Transaction* backing_store_transaction)\n     : id_(id),\n       object_store_ids_(object_store_ids),\n       mode_(mode),\n      connection_(connection),\n       transaction_(backing_store_transaction),\n       ptr_factory_(this) {\n   IDB_ASYNC_TRACE_BEGIN(\"IndexedDBTransaction::lifetime\", this);\n  callbacks_ = connection_->callbacks();\n  database_ = connection_->database();\n\n  diagnostics_.tasks_scheduled = 0;\n  diagnostics_.tasks_completed = 0;\n  diagnostics_.creation_time = base::Time::Now();\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 7763, "func": "static inline __maybe_unused void h2_get_buf_bytes(void *dst, size_t bytes,\n                                    const struct buffer *b, int o)\n{\n\treadv_bytes(dst, bytes, b_ptr(b, o), b_end(b) - b_ptr(b, o), b->data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7478, "func": "ssize_t notsup_getxattr(FsContext *ctx, const char *path, const char *name,\n                        void *value, size_t size)\n{\n    errno = ENOTSUP;\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7849, "func": "static void mig_throttle_guest_down(void)\n{\n    CPUState *cpu;\n\n    qemu_mutex_lock_iothread();\n    CPU_FOREACH(cpu) {\n        async_run_on_cpu(cpu, mig_sleep_cpu, NULL);\n    }\n    qemu_mutex_unlock_iothread();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7735, "func": "static void coroutine_fn v9fs_statfs(void *opaque)\n{\n    int32_t fid;\n    ssize_t retval = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    struct statfs stbuf;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    retval = v9fs_co_statfs(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval = v9fs_fill_statfs(s, pdu, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8139, "func": "void Gfx::opSetCharWidth(Object args[], int numArgs) {\n  out->type3D0(state, args[0].getNum(), args[1].getNum());\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187264, "func": " void DevToolsAgentHostImpl::AttachClient(DevToolsAgentHostClient* client) {\n   if (SessionByClient(client))\n     return;\n  InnerAttachClient(client);\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187205, "func": "void CoordinatorImpl::PerformNextQueuedGlobalMemoryDump() {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  QueuedRequest* request = GetCurrentRequest();\n\n  if (request == nullptr)\n    return;\n\n  std::vector<QueuedRequestDispatcher::ClientInfo> clients;\n  for (const auto& kv : clients_) {\n    auto client_identity = kv.second->identity;\n    const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);\n    if (pid == base::kNullProcessId) {\n      VLOG(1) << \"Couldn't find a PID for client \\\"\" << client_identity.name()\n              << \".\" << client_identity.instance() << \"\\\"\";\n      continue;\n    }\n     clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);\n   }\n \n  auto chrome_callback = base::Bind(\n      &CoordinatorImpl::OnChromeMemoryDumpResponse, base::Unretained(this));\n  auto os_callback = base::Bind(&CoordinatorImpl::OnOSMemoryDumpResponse,\n                                base::Unretained(this), request->dump_guid);\n   QueuedRequestDispatcher::SetUpAndDispatch(request, clients, chrome_callback,\n                                             os_callback);\n \n   base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(\n       FROM_HERE,\n       base::BindOnce(&CoordinatorImpl::OnQueuedRequestTimedOut,\n                     base::Unretained(this), request->dump_guid),\n       client_process_timeout_);\n \n   if (request->args.add_to_trace && heap_profiler_) {\n    request->heap_dump_in_progress = true;\n\n    bool strip_path_from_mapped_files =\n        base::trace_event::TraceLog::GetInstance()\n            ->GetCurrentTraceConfig()\n             .IsArgumentFilterEnabled();\n     heap_profiler_->DumpProcessesForTracing(\n         strip_path_from_mapped_files,\n            base::BindRepeating(&CoordinatorImpl::OnDumpProcessesForTracing,\n                           base::Unretained(this), request->dump_guid));\n \n     base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(\n         FROM_HERE,\n         base::BindOnce(&CoordinatorImpl::OnHeapDumpTimeOut,\n                       base::Unretained(this), request->dump_guid),\n         kHeapDumpTimeout);\n   }\n \n  FinalizeGlobalMemoryDumpIfAllManagersReplied();\n}\n", "target": 1, "flaw_line_index": "20,21,22,23,30,46,47,52"}
{"idx": 186585, "func": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session,\n                                                 TargetRegistry* registry) {\n  if (!ShouldAllowSession(session))\n    return false;\n\n  protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(\n      GetId(),\n      frame_tree_node_ ? frame_tree_node_->devtools_frame_token()\n                       : base::UnguessableToken(),\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::TargetHandler(\n      session->client()->MayDiscoverTargets()\n           ? protocol::TargetHandler::AccessMode::kRegular\n           : protocol::TargetHandler::AccessMode::kAutoAttachOnly,\n       GetId(), registry)));\n  session->AddHandler(\n      base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n   session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n   if (!frame_tree_node_ || !frame_tree_node_->parent()) {\n     session->AddHandler(base::WrapUnique(\n        new protocol::TracingHandler(frame_tree_node_, GetIOContext())));\n  }\n\n  if (sessions().empty()) {\n    bool use_video_capture_api = true;\n#ifdef OS_ANDROID\n    if (!CompositorImpl::IsInitialized())\n      use_video_capture_api = false;\n#endif\n    if (!use_video_capture_api)\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}\n", "target": 1, "flaw_line_index": "29,30"}
{"idx": 7921, "func": "static void cunary(JF, js_Ast *exp, int opcode)\n{\n\tcexp(J, F, exp->a);\n\temit(J, F, opcode);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7654, "func": "static int proxy_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int retval;\n\n    retval = v9fs_request(ctx->private, T_TRUNCATE, NULL, fs_path, size);\n    if (retval < 0) {\n        errno = -retval;\n        return -1;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187306, "func": "v8::Local<v8::Value> V8ValueConverterImpl::ToV8Object(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> creation_context,\n     const base::DictionaryValue* val) const {\n   v8::Local<v8::Object> result(v8::Object::New(isolate));\n \n   for (base::DictionaryValue::Iterator iter(*val);\n        !iter.IsAtEnd(); iter.Advance()) {\n     const std::string& key = iter.key();\n     v8::Local<v8::Value> child_v8 =\n         ToV8ValueImpl(isolate, creation_context, &iter.value());\n     CHECK(!child_v8.IsEmpty());\n \n    v8::TryCatch try_catch(isolate);\n    result->Set(\n        v8::String::NewFromUtf8(\n            isolate, key.c_str(), v8::String::kNormalString, key.length()),\n         child_v8);\n    if (try_catch.HasCaught()) {\n      LOG(ERROR) << \"Setter for property \" << key.c_str() << \" threw an \"\n                 << \"exception.\";\n    }\n   }\n \n   return result;\n}\n", "target": 1, "flaw_line_index": "14,15,16,17,19,20,21,22"}
{"idx": 7487, "func": "int v9fs_remove_xattr(FsContext *ctx,\n                      const char *path, const char *name)\n{\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n    if (xops) {\n        return xops->removexattr(ctx, path, name);\n    }\n    errno = EOPNOTSUPP;\n    return -1;\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186322, "func": "std::string* GetTestingDMToken() {\n  static std::string dm_token;\n   return &dm_token;\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7876, "func": "static size_t save_block_hdr(QEMUFile *f, RAMBlock *block, ram_addr_t offset,\n                             int cont, int flag)\n{\n    size_t size;\n\n    qemu_put_be64(f, offset | cont | flag);\n    size = 8;\n\n    if (!cont) {\n        qemu_put_byte(f, strlen(block->idstr));\n        qemu_put_buffer(f, (uint8_t *)block->idstr,\n                        strlen(block->idstr));\n        size += 1 + strlen(block->idstr);\n    }\n    return size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186484, "func": "Compositor::Compositor(\n    const viz::FrameSinkId& frame_sink_id,\n    ui::ContextFactory* context_factory,\n    ui::ContextFactoryPrivate* context_factory_private,\n    scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n    bool enable_pixel_canvas,\n    ui::ExternalBeginFrameClient* external_begin_frame_client,\n    bool force_software_compositor,\n    const char* trace_environment_name)\n    : context_factory_(context_factory),\n      context_factory_private_(context_factory_private),\n      frame_sink_id_(frame_sink_id),\n      task_runner_(task_runner),\n      vsync_manager_(new CompositorVSyncManager()),\n      external_begin_frame_client_(external_begin_frame_client),\n      force_software_compositor_(force_software_compositor),\n      layer_animator_collection_(this),\n      is_pixel_canvas_(enable_pixel_canvas),\n      lock_manager_(task_runner),\n      trace_environment_name_(trace_environment_name\n                                  ? trace_environment_name\n                                  : kDefaultTraceEnvironmentName),\n      context_creation_weak_ptr_factory_(this) {\n  if (context_factory_private) {\n    auto* host_frame_sink_manager =\n        context_factory_private_->GetHostFrameSinkManager();\n    host_frame_sink_manager->RegisterFrameSinkId(\n        frame_sink_id_, this, viz::ReportFirstSurfaceActivation::kNo);\n    host_frame_sink_manager->SetFrameSinkDebugLabel(frame_sink_id_,\n                                                    \"Compositor\");\n  }\n  root_web_layer_ = cc::Layer::Create();\n\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n\n  cc::LayerTreeSettings settings;\n\n  settings.layers_always_allowed_lcd_text = true;\n  settings.use_occlusion_for_tile_prioritization = true;\n  settings.main_frame_before_activation_enabled = false;\n  settings.delegated_sync_points_required =\n      context_factory_->SyncTokensRequiredForDisplayCompositor();\n\n  settings.enable_edge_anti_aliasing = false;\n\n  if (command_line->HasSwitch(cc::switches::kUIShowCompositedLayerBorders)) {\n    std::string layer_borders_string = command_line->GetSwitchValueASCII(\n        cc::switches::kUIShowCompositedLayerBorders);\n    std::vector<base::StringPiece> entries = base::SplitStringPiece(\n        layer_borders_string, \",\", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);\n    if (entries.empty()) {\n      settings.initial_debug_state.show_debug_borders.set();\n    } else {\n      for (const auto& entry : entries) {\n        const struct {\n          const char* name;\n          cc::DebugBorderType type;\n        } kBorders[] = {{cc::switches::kCompositedRenderPassBorders,\n                         cc::DebugBorderType::RENDERPASS},\n                        {cc::switches::kCompositedSurfaceBorders,\n                         cc::DebugBorderType::SURFACE},\n                        {cc::switches::kCompositedLayerBorders,\n                         cc::DebugBorderType::LAYER}};\n        for (const auto& border : kBorders) {\n          if (border.name == entry) {\n            settings.initial_debug_state.show_debug_borders.set(border.type);\n            break;\n          }\n        }\n      }\n    }\n  }\n  settings.initial_debug_state.show_fps_counter =\n      command_line->HasSwitch(cc::switches::kUIShowFPSCounter);\n  settings.initial_debug_state.show_layer_animation_bounds_rects =\n      command_line->HasSwitch(cc::switches::kUIShowLayerAnimationBounds);\n  settings.initial_debug_state.show_paint_rects =\n      command_line->HasSwitch(switches::kUIShowPaintRects);\n  settings.initial_debug_state.show_property_changed_rects =\n      command_line->HasSwitch(cc::switches::kUIShowPropertyChangedRects);\n  settings.initial_debug_state.show_surface_damage_rects =\n      command_line->HasSwitch(cc::switches::kUIShowSurfaceDamageRects);\n  settings.initial_debug_state.show_screen_space_rects =\n      command_line->HasSwitch(cc::switches::kUIShowScreenSpaceRects);\n\n  settings.initial_debug_state.SetRecordRenderingStats(\n      command_line->HasSwitch(cc::switches::kEnableGpuBenchmarking));\n  settings.enable_surface_synchronization = true;\n  settings.build_hit_test_data = features::IsVizHitTestingSurfaceLayerEnabled();\n\n  settings.use_zero_copy = IsUIZeroCopyEnabled();\n\n  settings.use_layer_lists =\n      command_line->HasSwitch(cc::switches::kUIEnableLayerLists);\n\n  settings.use_partial_raster = !settings.use_zero_copy;\n\n  settings.use_rgba_4444 =\n      command_line->HasSwitch(switches::kUIEnableRGBA4444Textures);\n\n#if defined(OS_MACOSX)\n  settings.resource_settings.use_gpu_memory_buffer_resources =\n      settings.use_zero_copy;\n  settings.enable_elastic_overscroll = true;\n#endif\n\n  settings.memory_policy.bytes_limit_when_visible = 512 * 1024 * 1024;\n\n  if (command_line->HasSwitch(\n          switches::kUiCompositorMemoryLimitWhenVisibleMB)) {\n    std::string value_str = command_line->GetSwitchValueASCII(\n        switches::kUiCompositorMemoryLimitWhenVisibleMB);\n    unsigned value_in_mb;\n    if (base::StringToUint(value_str, &value_in_mb)) {\n      settings.memory_policy.bytes_limit_when_visible =\n          1024 * 1024 * value_in_mb;\n    }\n  }\n\n  settings.memory_policy.priority_cutoff_when_visible =\n      gpu::MemoryAllocation::CUTOFF_ALLOW_NICE_TO_HAVE;\n\n  settings.disallow_non_exact_resource_reuse =\n      command_line->HasSwitch(switches::kDisallowNonExactResourceReuse);\n\n  if (command_line->HasSwitch(switches::kRunAllCompositorStagesBeforeDraw)) {\n    settings.wait_for_all_pipeline_stages_before_draw = true;\n    settings.enable_latency_recovery = false;\n  }\n\n  if (base::FeatureList::IsEnabled(\n          features::kCompositorThreadedScrollbarScrolling)) {\n    settings.compositor_threaded_scrollbar_scrolling = true;\n  }\n\n  animation_host_ = cc::AnimationHost::CreateMainInstance();\n\n  cc::LayerTreeHost::InitParams params;\n  params.client = this;\n  params.task_graph_runner = context_factory_->GetTaskGraphRunner();\n  params.settings = &settings;\n  params.main_task_runner = task_runner_;\n  params.mutator_host = animation_host_.get();\n  host_ = cc::LayerTreeHost::CreateSingleThreaded(this, std::move(params));\n\n  if (base::FeatureList::IsEnabled(features::kUiCompositorScrollWithLayers) &&\n      host_->GetInputHandler()) {\n    scroll_input_handler_.reset(\n        new ScrollInputHandler(host_->GetInputHandler()));\n  }\n\n  animation_timeline_ =\n      cc::AnimationTimeline::Create(cc::AnimationIdProvider::NextTimelineId());\n  animation_host_->AddAnimationTimeline(animation_timeline_.get());\n \n   host_->SetHasGpuRasterizationTrigger(features::IsUiGpuRasterizationEnabled());\n   host_->SetRootLayer(root_web_layer_);\n   host_->SetVisible(true);\n \n   if (command_line->HasSwitch(switches::kUISlowAnimations)) {\n    slow_animations_ = std::make_unique<ScopedAnimationDurationScaleMode>(\n        ScopedAnimationDurationScaleMode::SLOW_DURATION);\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7956, "func": "void buffer_reserve(Buffer *buffer, size_t len)\n{\n    if ((buffer->capacity - buffer->offset) < len) {\n        buffer->capacity += (len + 1024);\n        buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);\n        if (buffer->buffer == NULL) {\n            fprintf(stderr, \"vnc: out of memory\\n\");\n            exit(1);\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186361, "func": "    Read(cc::mojom::CompositorFrameMetadataDataView data,\n         cc::CompositorFrameMetadata* out) {\n  out->device_scale_factor = data.device_scale_factor();\n  if (!data.ReadRootScrollOffset(&out->root_scroll_offset))\n    return false;\n\n  out->page_scale_factor = data.page_scale_factor();\n  if (!data.ReadScrollableViewportSize(&out->scrollable_viewport_size) ||\n      !data.ReadRootLayerSize(&out->root_layer_size)) {\n    return false;\n  }\n\n  out->min_page_scale_factor = data.min_page_scale_factor();\n  out->max_page_scale_factor = data.max_page_scale_factor();\n  out->root_overflow_x_hidden = data.root_overflow_x_hidden();\n  out->root_overflow_y_hidden = data.root_overflow_y_hidden();\n  out->may_contain_video = data.may_contain_video();\n  out->is_resourceless_software_draw_with_scroll_or_animation =\n      data.is_resourceless_software_draw_with_scroll_or_animation();\n  out->top_controls_height = data.top_controls_height();\n   out->top_controls_shown_ratio = data.top_controls_shown_ratio();\n   out->bottom_controls_height = data.bottom_controls_height();\n   out->bottom_controls_shown_ratio = data.bottom_controls_shown_ratio();\n \n   out->root_background_color = data.root_background_color();\n   out->can_activate_before_dependencies =\n      data.can_activate_before_dependencies();\n  return data.ReadSelection(&out->selection) &&\n         data.ReadLatencyInfo(&out->latency_info) &&\n         data.ReadReferencedSurfaces(&out->referenced_surfaces);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186444, "func": "void WorkerFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n     const FetchInitiatorInfo& initiator_info) {\n   probe::willSendRequest(global_scope_, identifier, nullptr, request,\n                         redirect_response, initiator_info);\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 187102, "func": "bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n                             const PermissionSet& required_permissions,\n                             const PermissionSet& optional_permissions,\n                             bool allow_file_access,\n                             UnpackPermissionSetResult* result,\n                             std::string* error) {\n  int user_script_schemes = UserScript::ValidUserScriptSchemes();\n  int explicit_schemes = Extension::kValidHostPermissionSchemes;\n  if (!allow_file_access) {\n    user_script_schemes &= ~URLPattern::SCHEME_FILE;\n     explicit_schemes &= ~URLPattern::SCHEME_FILE;\n   }\n \n   for (const auto& origin_str : origins_input) {\n     URLPattern explicit_origin(explicit_schemes);\n     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);\n    if (URLPattern::ParseResult::kSuccess != parse_result) {\n      *error = ErrorUtils::FormatErrorMessage(\n          kInvalidOrigin, origin_str,\n          URLPattern::GetParseResultString(parse_result));\n       return false;\n     }\n \n     bool used_origin = false;\n     if (required_permissions.explicit_hosts().ContainsPattern(\n             explicit_origin)) {\n      used_origin = true;\n      result->required_explicit_hosts.AddPattern(explicit_origin);\n    } else if (optional_permissions.explicit_hosts().ContainsPattern(\n                   explicit_origin)) {\n      used_origin = true;\n      result->optional_explicit_hosts.AddPattern(explicit_origin);\n    }\n \n     URLPattern scriptable_origin(user_script_schemes);\n     if (scriptable_origin.Parse(origin_str) ==\n            URLPattern::ParseResult::kSuccess &&\n        required_permissions.scriptable_hosts().ContainsPattern(\n            scriptable_origin)) {\n      used_origin = true;\n      result->required_scriptable_hosts.AddPattern(scriptable_origin);\n     }\n \n     if (!used_origin)\n      result->unlisted_hosts.AddPattern(explicit_origin);\n  }\n\n  return true;\n}\n", "target": 1, "flaw_line_index": "37,38,39,40,41"}
{"idx": 187307, "func": "void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)\n{\n    if (!m_provider) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, \"Failed to register a ServiceWorker: The document is in an invalid state.\"));\n        return;\n    }\n\n    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();\n    String errorMessage;\n    if (!executionContext->isSecureContext(errorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));\n        return;\n    }\n\n    KURL pageURL = KURL(KURL(), documentOrigin->toString());\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the current origin ('\" + documentOrigin->toString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL scriptURL = rawScriptURL;\n    scriptURL.removeFragmentIdentifier();\n    if (!documentOrigin->canRequest(scriptURL)) {\n        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scriptURL ('\" + scriptOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the script ('\" + scriptURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL patternURL = scope;\n    patternURL.removeFragmentIdentifier();\n\n    if (!documentOrigin->canRequest(patternURL)) {\n        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scope ('\" + patternOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the scope ('\" + patternURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    WebString webErrorMessage;\n    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(\"Failed to register a ServiceWorker: \" + webErrorMessage.utf8())));\n         return;\n     }\n \n     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7423, "func": "ZEND_API int zend_ts_hash_index_del(TsHashTable *ht, zend_ulong h)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_index_del(TS_HASH(ht), h);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8112, "func": "void Gfx::opCloseFillStroke(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    return;\n  }\n  if (state->isPath() && !contentIsHidden()) {\n    state->closePath();\n    if (state->getFillColorSpace()->getMode() == csPattern) {\n      doPatternFill(gFalse);\n    } else {\n      out->fill(state);\n    }\n    if (state->getStrokeColorSpace()->getMode() == csPattern) {\n      doPatternStroke();\n    } else {\n      out->stroke(state);\n    }\n  }\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7636, "func": "static int proxy_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n{\n    int retval;\n    retval = v9fs_request(fs_ctx->private, T_LSTAT, stbuf, fs_path);\n    if (retval < 0) {\n        errno = -retval;\n        return -1;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7941, "func": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7757, "func": "static struct conn_stream *h2_attach(struct connection *conn)\n{\n\treturn NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7410, "func": "static void end_write(TsHashTable *ht)\n{\n#ifdef ZTS\n\ttsrm_mutex_unlock(ht->mx_writer);\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187309, "func": " exsltCryptoRc4DecryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n \n    int key_len = 0, key_size = 0;\n     int str_len = 0, bin_len = 0, ret_len = 0;\n     xmlChar *key = NULL, *str = NULL, *padkey = NULL, *bin =\n \tNULL, *ret = NULL;\n    xsltTransformContextPtr tctxt = NULL;\n\n    if (nargs != 2) {\n\txmlXPathSetArityError (ctxt);\n\treturn;\n    }\n     tctxt = xsltXPathGetTransformContext(ctxt);\n \n     str = xmlXPathPopString (ctxt);\n    str_len = xmlUTF8Strlen (str);\n \n     if (str_len == 0) {\n \txmlXPathReturnEmptyString (ctxt);\n\txmlFree (str);\n\treturn;\n     }\n \n     key = xmlXPathPopString (ctxt);\n    key_len = xmlUTF8Strlen (key);\n \n     if (key_len == 0) {\n \txmlXPathReturnEmptyString (ctxt);\n\txmlFree (key);\n\txmlFree (str);\n\treturn;\n    }\n\n    padkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);\n    if (padkey == NULL) {\n\txsltTransformError(tctxt, NULL, tctxt->inst,\n\t    \"exsltCryptoRc4EncryptFunction: Failed to allocate padkey\\n\");\n\ttctxt->state = XSLT_STATE_STOPPED;\n\txmlXPathReturnEmptyString (ctxt);\n \tgoto done;\n     }\n     memset(padkey, 0, RC4_KEY_LENGTH + 1);\n    key_size = xmlUTF8Strsize (key, key_len);\n    if ((key_size > RC4_KEY_LENGTH) || (key_size < 0)) {\n \txsltTransformError(tctxt, NULL, tctxt->inst,\n \t    \"exsltCryptoRc4EncryptFunction: key size too long or key broken\\n\");\n \ttctxt->state = XSLT_STATE_STOPPED;\n \txmlXPathReturnEmptyString (ctxt);\n \tgoto done;\n     }\n    memcpy (padkey, key, key_size);\n \n     bin_len = str_len;\n    bin = xmlMallocAtomic (bin_len);\n    if (bin == NULL) {\n\txsltTransformError(tctxt, NULL, tctxt->inst,\n\t    \"exsltCryptoRc4EncryptFunction: Failed to allocate string\\n\");\n\ttctxt->state = XSLT_STATE_STOPPED;\n\txmlXPathReturnEmptyString (ctxt);\n\tgoto done;\n    }\n    ret_len = exsltCryptoHex2Bin (str, str_len, bin, bin_len);\n\n    ret = xmlMallocAtomic (ret_len + 1);\n    if (ret == NULL) {\n\txsltTransformError(tctxt, NULL, tctxt->inst,\n\t    \"exsltCryptoRc4EncryptFunction: Failed to allocate result\\n\");\n\ttctxt->state = XSLT_STATE_STOPPED;\n\txmlXPathReturnEmptyString (ctxt);\n\tgoto done;\n    }\n    PLATFORM_RC4_DECRYPT (ctxt, padkey, bin, ret_len, ret, ret_len);\n    ret[ret_len] = 0;\n\n    xmlXPathReturnString (ctxt, ret);\n\ndone:\n    if (key != NULL)\n\txmlFree (key);\n    if (str != NULL)\n\txmlFree (str);\n    if (padkey != NULL)\n\txmlFree (padkey);\n    if (bin != NULL)\n\txmlFree (bin);\n}\n", "target": 1, "flaw_line_index": "3,16,25,43,44,51"}
{"idx": 187229, "func": "static int hid_exit(int sub_api)\n{\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 186317, "func": "static bool ShouldAutofocus(const HTMLFormControlElement* element) {\n  if (!element->isConnected())\n    return false;\n  if (!element->IsAutofocusable())\n    return false;\n\n\n\n   Document& doc = element->GetDocument();\n \n \n  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control because the form's frame is \"\n        \"sandboxed and the 'allow-scripts' permission is not set.\"));\n    return false;\n  }\n\n  if (!doc.IsInMainFrame() &&\n      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control in a cross-origin subframe.\"));\n    return false;\n  }\n\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186754, "func": " Response StorageHandler::TrackIndexedDBForOrigin(const std::string& origin) {\n  if (!process_)\n     return Response::InternalError();\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid())\n    return Response::InvalidParams(origin + \" is not a valid URL\");\n\n  GetIndexedDBObserver()->TaskRunner()->PostTask(\n      FROM_HERE, base::BindOnce(&IndexedDBObserver::TrackOriginOnIDBThread,\n                                base::Unretained(GetIndexedDBObserver()),\n                                url::Origin::Create(origin_url)));\n  return Response::OK();\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186824, "func": " void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n    callback.Run(nullptr);\n    return;\n  }\n\n  switch (type) {\n    case mojom::SensorType::LINEAR_ACCELERATION: {\n      auto linear_acceleration_fusion_algorithm = std::make_unique<\n          LinearAccelerationFusionAlgorithmUsingAccelerometer>();\n       PlatformSensorFusion::Create(\n          std::move(mapping), this,\n          std::move(linear_acceleration_fusion_algorithm), callback);\n       break;\n     }\n \n    default: {\n      base::PostTaskAndReplyWithResult(\n          sensor_thread_->task_runner().get(), FROM_HERE,\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n                     base::Unretained(this), type, base::Passed(&mapping),\n                     callback));\n       break;\n     }\n   }\n}\n", "target": 1, "flaw_line_index": "3,19,20,31,32"}
{"idx": 187218, "func": "static int _hid_set_report(struct hid_device_priv* dev, HANDLE hid_handle, int id, void *data,\n\t\t\t\t\t\t   struct windows_transfer_priv *tp, size_t *size, OVERLAPPED* overlapped,\n\t\t\t\t\t\t   int report_type)\n{\n\tuint8_t *buf = NULL;\n\tDWORD ioctl_code, write_size= (DWORD)*size;\n\tif (tp->hid_buffer != NULL) {\n\t\tusbi_dbg(\"program assertion failed: hid_buffer is not NULL\");\n\t}\n\tif ((*size == 0) || (*size > MAX_HID_REPORT_SIZE)) {\n\t\tusbi_dbg(\"invalid size (%d)\", *size);\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tswitch (report_type) {\n\t\tcase HID_REPORT_TYPE_OUTPUT:\n\t\t\tioctl_code = IOCTL_HID_SET_OUTPUT_REPORT;\n\t\t\tbreak;\n\t\tcase HID_REPORT_TYPE_FEATURE:\n\t\t\tioctl_code = IOCTL_HID_SET_FEATURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusbi_dbg(\"unknown HID report type %d\", report_type);\n\t\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tusbi_dbg(\"report ID: 0x%02X\", id);\n\tif (id == 0) {\n\t\twrite_size++;\n\t}\n\tbuf = (uint8_t*) malloc(write_size);\n\tif (buf == NULL) {\n\t\treturn LIBUSB_ERROR_NO_MEM;\n\t}\n\tif (id == 0) {\n\t\tbuf[0] = 0;\n\t\tmemcpy(buf + 1, data, *size);\n\t} else {\n\t\tmemcpy(buf, data, *size);\n\t\tif (buf[0] != id) {\n\t\t\tusbi_warn(NULL, \"mismatched report ID (data is %02X, parameter is %02X)\", buf[0], id);\n\t\t}\n\t}\n\tif (!DeviceIoControl(hid_handle, ioctl_code, buf, write_size,\n\t\tbuf, write_size, &write_size, overlapped)) {\n\t\tif (GetLastError() != ERROR_IO_PENDING) {\n\t\t\tusbi_dbg(\"Failed to Write HID Output Report: %s\", windows_error_str(0));\n\t\t\tsafe_free(buf);\n\t\t\treturn LIBUSB_ERROR_IO;\n\t\t}\n\t\ttp->hid_buffer = buf;\n\t\ttp->hid_dest = NULL;\n\t\treturn LIBUSB_SUCCESS;\n\t}\n\t*size = write_size;\n\tif (write_size == 0) {\n\t\tusbi_dbg(\"program assertion failed - write completed synchronously, but no data was written\");\n\t}\n\tsafe_free(buf);\n\treturn LIBUSB_COMPLETED;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60"}
{"idx": 186849, "func": "void MojoJpegDecodeAccelerator::Decode(\n    const BitstreamBuffer& bitstream_buffer,\n    const scoped_refptr<VideoFrame>& video_frame) {\n  DCHECK(io_task_runner_->BelongsToCurrentThread());\n  DCHECK(jpeg_decoder_.is_bound());\n\n  DCHECK(\n      base::SharedMemory::IsHandleValid(video_frame->shared_memory_handle()));\n\n  base::SharedMemoryHandle output_handle =\n      base::SharedMemory::DuplicateHandle(video_frame->shared_memory_handle());\n  if (!base::SharedMemory::IsHandleValid(output_handle)) {\n    DLOG(ERROR) << \"Failed to duplicate handle of VideoFrame\";\n    return;\n  }\n\n   size_t output_buffer_size = VideoFrame::AllocationSize(\n       video_frame->format(), video_frame->coded_size());\n   mojo::ScopedSharedBufferHandle output_frame_handle =\n      mojo::WrapSharedMemoryHandle(output_handle, output_buffer_size,\n                                   false \n);\n \n   jpeg_decoder_->Decode(bitstream_buffer, video_frame->coded_size(),\n                        std::move(output_frame_handle),\n                        base::checked_cast<uint32_t>(output_buffer_size),\n                        base::Bind(&MojoJpegDecodeAccelerator::OnDecodeAck,\n                                   base::Unretained(this)));\n}\n", "target": 1, "flaw_line_index": "20,22"}
{"idx": 7555, "func": "static int var_access(php_unserialize_data_t *var_hashx, long id, zval ***store)\n{\n\tvar_entries *var_hash = (*var_hashx)->first;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_access(%ld): %ld\\n\", var_hash?var_hash->used_slots:-1L, id);\n#endif\n\t\t\n\twhile (id >= VAR_ENTRIES_MAX && var_hash && var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = var_hash->next;\n\t\tid -= VAR_ENTRIES_MAX;\n\t}\n\n\tif (!var_hash) return !SUCCESS;\n\n\tif (id < 0 || id >= var_hash->used_slots) return !SUCCESS;\n\n\t*store = &var_hash->data[id];\n\n\treturn SUCCESS;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186464, "func": "UserInitiatedInfo CreateUserInitiatedInfo(\n    content::NavigationHandle* navigation_handle,\n    PageLoadTracker* committed_load) {\n  if (!navigation_handle->IsRendererInitiated())\n     return UserInitiatedInfo::BrowserInitiated();\n \n   return UserInitiatedInfo::RenderInitiated(\n      navigation_handle->HasUserGesture());\n }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 186449, "func": " bool Browser::ShouldFocusLocationBarByDefault(WebContents* source) {\n   const content::NavigationEntry* entry =\n       source->GetController().GetActiveEntry();\n   if (entry) {\n    const GURL& url = entry->GetURL();\n    const GURL& virtual_url = entry->GetVirtualURL();\n    if ((url.SchemeIs(content::kChromeUIScheme) &&\n         url.host_piece() == chrome::kChromeUINewTabHost) ||\n        (virtual_url.SchemeIs(content::kChromeUIScheme) &&\n         virtual_url.host_piece() == chrome::kChromeUINewTabHost)) {\n      return true;\n    }\n  }\n\n  return search::NavEntryIsInstantNTP(source, entry);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7737, "func": "static void coroutine_fn v9fs_version(void *opaque)\n{\n    ssize_t err;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsString version;\n    size_t offset = 7;\n\n    v9fs_string_init(&version);\n    err = pdu_unmarshal(pdu, offset, \"ds\", &s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    trace_v9fs_version(pdu->tag, pdu->id, s->msize, version.data);\n\n    virtfs_reset(pdu);\n\n    if (!strcmp(version.data, \"9P2000.u\")) {\n        s->proto_version = V9FS_PROTO_2000U;\n    } else if (!strcmp(version.data, \"9P2000.L\")) {\n        s->proto_version = V9FS_PROTO_2000L;\n    } else {\n        v9fs_string_sprintf(&version, \"unknown\");\n    }\n\n    err = pdu_marshal(pdu, offset, \"ds\", s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    offset += err;\n    trace_v9fs_version_return(pdu->tag, pdu->id, s->msize, version.data);\nout:\n    pdu_complete(pdu, offset);\n    v9fs_string_free(&version);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7783, "func": "static void h2_shutw(struct conn_stream *cs, enum cs_shw_mode mode)\n{\n\tstruct h2s *h2s = cs->ctx;\n\n\tif (h2s->st == H2_SS_HLOC || h2s->st == H2_SS_ERROR || h2s->st == H2_SS_CLOSED)\n\t\treturn;\n\n\tif (h2s->flags & H2_SF_HEADERS_SENT) {\n\n\t\tif (!(h2s->flags & (H2_SF_ES_SENT|H2_SF_RST_SENT)) &&\n\t\t    h2_send_empty_data_es(h2s) <= 0)\n\t\t\tgoto add_to_list;\n\n\t\tif (h2s->st == H2_SS_HREM)\n\t\t\th2s_close(h2s);\n\t\telse\n\t\t\th2s->st = H2_SS_HLOC;\n\t} else {\n\t\tif (!(h2s->flags & H2_SF_RST_SENT) &&\n\t\t    h2s_send_rst_stream(h2s->h2c, h2s) <= 0)\n\t\t\tgoto add_to_list;\n\n\t\tif (!(h2s->flags & H2_SF_OUTGOING_DATA) &&\n\t\t    !(h2s->h2c->flags & (H2_CF_GOAWAY_SENT|H2_CF_GOAWAY_FAILED)) &&\n\t\t    h2c_send_goaway_error(h2s->h2c, h2s) <= 0)\n\t\t\tgoto add_to_list;\n\n\t\th2s_close(h2s);\n\t}\n\n\tif (h2s->h2c->mbuf->o && !(cs->conn->flags & CO_FL_XPRT_WR_ENA))\n\t\tconn_xprt_want_send(cs->conn);\n\n add_to_list:\n\tif (LIST_ISEMPTY(&h2s->list)) {\n\t\tif (h2s->flags & H2_SF_BLK_MFCTL)\n\t\t\tLIST_ADDQ(&h2s->h2c->fctl_list, &h2s->list);\n\t\telse if (h2s->flags & (H2_SF_BLK_MBUSY|H2_SF_BLK_MROOM))\n\t\t\tLIST_ADDQ(&h2s->h2c->send_list, &h2s->list);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186583, "func": "PageHandler::PageHandler(EmulationHandler* emulation_handler)\n     : DevToolsDomainHandler(Page::Metainfo::domainName),\n       enabled_(false),\n       screencast_enabled_(false),\n      screencast_quality_(kDefaultScreenshotQuality),\n      screencast_max_width_(-1),\n      screencast_max_height_(-1),\n      capture_every_nth_frame_(1),\n      capture_retry_count_(0),\n      has_compositor_frame_metadata_(false),\n      session_id_(0),\n      frame_counter_(0),\n      frames_in_flight_(0),\n      video_consumer_(nullptr),\n       last_surface_size_(gfx::Size()),\n       host_(nullptr),\n       emulation_handler_(emulation_handler),\n       observer_(this),\n       weak_factory_(this) {\n   bool create_video_consumer = true;\n#ifdef OS_ANDROID\n  if (!CompositorImpl::IsInitialized())\n    create_video_consumer = false;\n#endif\n  if (create_video_consumer) {\n    video_consumer_ = std::make_unique<DevToolsVideoConsumer>(\n        base::BindRepeating(&PageHandler::OnFrameFromVideoConsumer,\n                            weak_factory_.GetWeakPtr()));\n  }\n  DCHECK(emulation_handler_);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7401, "func": "magic_entry_free(struct magic_entry *me, uint32_t nme)\n{\n\tuint32_t i;\n\tif (me == NULL)\n\t\treturn;\n\tfor (i = 0; i < nme; i++)\n\t\tefree(me[i].mp);\n\tefree(me);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7827, "func": "  TT_Run_Context( TT_ExecContext  exec,\n                  FT_Bool         debug )\n  {\n    FT_Error  error;\n\n\n    if ( ( error = TT_Goto_CodeRange( exec, tt_coderange_glyph, 0  ) )\n           != TT_Err_Ok )\n      return error;\n\n    exec->zp0 = exec->pts;\n    exec->zp1 = exec->pts;\n    exec->zp2 = exec->pts;\n\n    exec->GS.gep0 = 1;\n    exec->GS.gep1 = 1;\n    exec->GS.gep2 = 1;\n\n    exec->GS.projVector.x = 0x4000;\n    exec->GS.projVector.y = 0x0000;\n\n    exec->GS.freeVector = exec->GS.projVector;\n    exec->GS.dualVector = exec->GS.projVector;\n\n#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING\n    exec->GS.both_x_axis = TRUE;\n#endif\n\n    exec->GS.round_state = 1;\n    exec->GS.loop        = 1;\n\n    exec->top     = 0;\n    exec->callTop = 0;\n\n#if 1\n    FT_UNUSED( debug );\n\n    return exec->face->interpreter( exec );\n#else\n    if ( !debug )\n      return TT_RunIns( exec );\n    else\n      return TT_Err_Ok;\n#endif\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7804, "func": "static int h2c_send_goaway_error(struct h2c *h2c, struct h2s *h2s)\n{\n\tstruct buffer *res;\n\tchar str[17];\n\tint ret;\n\n\tif (h2c->flags & H2_CF_GOAWAY_FAILED)\n\t\treturn 1; \n\n\tif (h2c_mux_busy(h2c, h2s)) {\n\t\tif (h2s)\n\t\t\th2s->flags |= H2_SF_BLK_MBUSY;\n\t\telse\n\t\t\th2c->flags |= H2_CF_DEM_MBUSY;\n\t\treturn 0;\n\t}\n\n\tres = h2_get_buf(h2c, &h2c->mbuf);\n\tif (!res) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\tif (h2s)\n\t\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\telse\n\t\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\treturn 0;\n\t}\n\n\tmemcpy(str, \"\\x00\\x00\\x08\\x07\\x00\\x00\\x00\\x00\\x00\", 9);\n\n\tif (h2c->last_sid < 0)\n\t\th2c->last_sid = h2c->max_id;\n\n\twrite_n32(str + 9, h2c->last_sid);\n\twrite_n32(str + 13, h2c->errcode);\n\tret = bo_istput(res, ist2(str, 17));\n\tif (unlikely(ret <= 0)) {\n\t\tif (!ret) {\n\t\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\t\tif (h2s)\n\t\t\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\t\telse\n\t\t\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\t\th2c->flags |= H2_CF_GOAWAY_FAILED;\n\t\t\treturn 1;\n\t\t}\n\t}\n\th2c->flags |= H2_CF_GOAWAY_SENT;\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187023, "func": "ProcessIdToFilterMap* GetProcessIdToFilterMap() {\n  static base::NoDestructor<ProcessIdToFilterMap> instance;\n  return instance.get();\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 187100, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n   cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n   cyrillic_letters_latin_alike_.freeze();\n \n   cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n          \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n          \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n          \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u0909\u0993\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),\n      UTRANS_FORWARD, parse_error, status));\n  DCHECK(U_SUCCESS(status))\n      << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": "58"}
{"idx": 186554, "func": "  MirrorMockURLRequestJob(net::URLRequest* request,\n                          net::NetworkDelegate* network_delegate,\n                          const base::FilePath& file_path,\n                          ReportResponseHeadersOnUI report_on_ui)\n      : net::URLRequestMockHTTPJob(request, network_delegate, file_path),\n        report_on_ui_(report_on_ui) {}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7476, "func": "ssize_t local_removexattr_nofollow(FsContext *ctx, const char *path,\n                                   const char *name)\n{\n    char *dirpath = g_path_get_dirname(path);\n    char *filename = g_path_get_basename(path);\n    int dirfd;\n    ssize_t ret = -1;\n\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    if (dirfd == -1) {\n        goto out;\n    }\n\n    ret = fremovexattrat_nofollow(dirfd, filename, name);\n    close_preserve_errno(dirfd);\nout:\n    g_free(dirpath);\n    g_free(filename);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186848, "func": "  void UnwrapAndVerifyMojoHandle(mojo::ScopedSharedBufferHandle buffer_handle,\n                                 size_t expected_size,\n                                 bool expected_read_only_flag) {\n     base::SharedMemoryHandle memory_handle;\n     size_t memory_size = 0;\n    bool read_only_flag = false;\n    const MojoResult result =\n        mojo::UnwrapSharedMemoryHandle(std::move(buffer_handle), &memory_handle,\n                                       &memory_size, &read_only_flag);\n     EXPECT_EQ(MOJO_RESULT_OK, result);\n     EXPECT_EQ(expected_size, memory_size);\n    EXPECT_EQ(expected_read_only_flag, read_only_flag);\n   }\n", "target": 1, "flaw_line_index": "2,3,6,7,8,9,12"}
{"idx": 187101, "func": "bool SetExtendedFileAttribute(const char* path,\n                              const char* name,\n                               const char* value,\n                               size_t value_size,\n                               int flags) {\n   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);\n   int result = setxattr(path, name, value, value_size, flags);\n   if (result) {\n     DPLOG(ERROR) << \"Could not set extended attribute \" << name << \" on file \"\n                  << path;\n     return false;\n   }\n   return true;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187258, "func": " void ExtensionDevToolsClientHost::AgentHostClosed(\n     DevToolsAgentHost* agent_host) {\n   DCHECK(agent_host == agent_host_.get());\n   SendDetachedEvent();\n   delete this;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187188, "func": "void DocumentLoader::CommitNavigation(const AtomicString& mime_type,\n                                      const KURL& overriding_url) {\n  if (state_ != kProvisional)\n    return;\n\n  if (!GetFrameLoader().StateMachine()->CreatingInitialEmptyDocument()) {\n    SetHistoryItemStateForCommit(\n        GetFrameLoader().GetDocumentLoader()->GetHistoryItem(), load_type_,\n        HistoryNavigationType::kDifferentDocument);\n  }\n\n  DCHECK_EQ(state_, kProvisional);\n  GetFrameLoader().CommitProvisionalLoad();\n  if (!frame_)\n    return;\n\n  const AtomicString& encoding = GetResponse().TextEncodingName();\n\n  Document* owner_document = nullptr;\n  if (Document::ShouldInheritSecurityOriginFromOwner(Url())) {\n    Frame* owner_frame = frame_->Tree().Parent();\n    if (!owner_frame)\n      owner_frame = frame_->Loader().Opener();\n    if (owner_frame && owner_frame->IsLocalFrame())\n      owner_document = ToLocalFrame(owner_frame)->GetDocument();\n  }\n  DCHECK(frame_->GetPage());\n\n  ParserSynchronizationPolicy parsing_policy = kAllowAsynchronousParsing;\n   if (!Document::ThreadedParsingEnabledForTesting())\n     parsing_policy = kForceSynchronousParsing;\n \n  InstallNewDocument(Url(), owner_document,\n                     frame_->ShouldReuseDefaultView(Url())\n                         ? WebGlobalObjectReusePolicy::kUseExisting\n                         : WebGlobalObjectReusePolicy::kCreateNew,\n                     mime_type, encoding, InstallNewDocumentReason::kNavigation,\n                     parsing_policy, overriding_url);\n   parser_->SetDocumentWasLoadedAsPartOfNavigation();\n   if (request_.WasDiscarded())\n     frame_->GetDocument()->SetWasDiscarded(true);\n  frame_->GetDocument()->MaybeHandleHttpRefresh(\n      response_.HttpHeaderField(HTTPNames::Refresh),\n      Document::kHttpRefreshFromHeader);\n}\n", "target": 1, "flaw_line_index": "40,41,42,43,44,45"}
{"idx": 186871, "func": " bool ParamTraits<SkBitmap>::Read(const base::Pickle* m,\n                                  base::PickleIterator* iter,\n                                  SkBitmap* r) {\n  const char* fixed_data;\n  int fixed_data_size = 0;\n  if (!iter->ReadData(&fixed_data, &fixed_data_size) ||\n     (fixed_data_size <= 0)) {\n     return false;\n  }\n  if (fixed_data_size != sizeof(SkBitmap_Data))\n    return false;  \n \n  const char* variable_data;\n  int variable_data_size = 0;\n  if (!iter->ReadData(&variable_data, &variable_data_size) ||\n     (variable_data_size < 0)) {\n     return false;\n  }\n  const SkBitmap_Data* bmp_data =\n      reinterpret_cast<const SkBitmap_Data*>(fixed_data);\n  return bmp_data->InitSkBitmapFromData(r, variable_data, variable_data_size);\n }\n", "target": 1, "flaw_line_index": "4,5,6,7,9,10,11,13,14,15,16,18,19,20,21"}
{"idx": 186386, "func": " void DataReductionProxyConfig::SecureProxyCheck(\n     SecureProxyCheckerCallback fetcher_callback) {\n   secure_proxy_checker_->CheckIfSecureProxyIsAllowed(fetcher_callback);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186438, "func": " String InspectorPageAgent::CachedResourceTypeJson(\n     const Resource& cached_resource) {\n  return ResourceTypeJson(CachedResourceType(cached_resource));\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187127, "func": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response.Url());\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n \n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 187225, "func": "static int hid_claim_interface(int sub_api, struct libusb_device_handle *dev_handle, int iface)\n{\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n\tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n\tCHECK_HID_AVAILABLE;\n\tif (priv->usb_interface[iface].path == NULL) {\n\t\treturn LIBUSB_ERROR_NOT_FOUND;\t\n\t}\n\tif (handle_priv->interface_handle[iface].dev_handle == INTERFACE_CLAIMED) {\n\t\treturn LIBUSB_ERROR_BUSY;\t\n\t}\n\thandle_priv->interface_handle[iface].dev_handle = INTERFACE_CLAIMED;\n\tusbi_dbg(\"claimed interface %d\", iface);\n\thandle_priv->active_interface = iface;\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17"}
{"idx": 186411, "func": "void BluetoothDeviceChooserController::GetDevice(\n    blink::mojom::WebBluetoothRequestDeviceOptionsPtr options,\n    const SuccessCallback& success_callback,\n    const ErrorCallback& error_callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  DCHECK(success_callback_.is_null());\n  DCHECK(error_callback_.is_null());\n\n  success_callback_ = success_callback;\n  error_callback_ = error_callback;\n  options_ = std::move(options);\n  LogRequestDeviceOptions(options_);\n\n  if (options_->filters &&\n       BluetoothBlocklist::Get().IsExcluded(options_->filters.value())) {\n     RecordRequestDeviceOutcome(\n         UMARequestDeviceOutcome::BLOCKLISTED_SERVICE_IN_FILTER);\n    PostErrorCallback(\n        blink::mojom::WebBluetoothResult::REQUEST_DEVICE_WITH_BLOCKLISTED_UUID);\n     return;\n   }\n   BluetoothBlocklist::Get().RemoveExcludedUUIDs(options_.get());\n \n  const url::Origin requesting_origin =\n      render_frame_host_->GetLastCommittedOrigin();\n  const url::Origin embedding_origin =\n      web_contents_->GetMainFrame()->GetLastCommittedOrigin();\n  if (!embedding_origin.IsSameOriginWith(requesting_origin)) {\n    PostErrorCallback(blink::mojom::WebBluetoothResult::\n                          REQUEST_DEVICE_FROM_CROSS_ORIGIN_IFRAME);\n     return;\n   }\n  DCHECK(!requesting_origin.opaque());\n \n   if (!adapter_->IsPresent()) {\n     DVLOG(1) << \"Bluetooth Adapter not present. Can't serve requestDevice.\";\n     RecordRequestDeviceOutcome(\n         UMARequestDeviceOutcome::BLUETOOTH_ADAPTER_NOT_PRESENT);\n    PostErrorCallback(blink::mojom::WebBluetoothResult::NO_BLUETOOTH_ADAPTER);\n     return;\n   }\n \n  switch (GetContentClient()->browser()->AllowWebBluetooth(\n      web_contents_->GetBrowserContext(), requesting_origin,\n      embedding_origin)) {\n    case ContentBrowserClient::AllowWebBluetoothResult::BLOCK_POLICY: {\n      RecordRequestDeviceOutcome(\n          UMARequestDeviceOutcome::BLUETOOTH_CHOOSER_POLICY_DISABLED);\n      PostErrorCallback(blink::mojom::WebBluetoothResult::\n                            CHOOSER_NOT_SHOWN_API_LOCALLY_DISABLED);\n      return;\n    }\n    case ContentBrowserClient::AllowWebBluetoothResult::\n        BLOCK_GLOBALLY_DISABLED: {\n      web_contents_->GetMainFrame()->AddMessageToConsole(\n          blink::mojom::ConsoleMessageLevel::kInfo,\n          \"Bluetooth permission has been blocked.\");\n      RecordRequestDeviceOutcome(\n          UMARequestDeviceOutcome::BLUETOOTH_GLOBALLY_DISABLED);\n      PostErrorCallback(blink::mojom::WebBluetoothResult::\n                            CHOOSER_NOT_SHOWN_API_GLOBALLY_DISABLED);\n      return;\n    }\n    case ContentBrowserClient::AllowWebBluetoothResult::ALLOW:\n      break;\n  }\n   BluetoothChooser::EventHandler chooser_event_handler =\n       base::Bind(&BluetoothDeviceChooserController::OnBluetoothChooserEvent,\n                  base::Unretained(this));\n\n  if (WebContentsDelegate* delegate = web_contents_->GetDelegate()) {\n    chooser_ = delegate->RunBluetoothChooser(render_frame_host_,\n                                             std::move(chooser_event_handler));\n   }\n \n   if (!chooser_.get()) {\n    PostErrorCallback(\n        blink::mojom::WebBluetoothResult::WEB_BLUETOOTH_NOT_SUPPORTED);\n     return;\n   }\n \n  if (!chooser_->CanAskForScanningPermission()) {\n    DVLOG(1) << \"Closing immediately because Chooser cannot obtain permission.\";\n    OnBluetoothChooserEvent(BluetoothChooser::Event::DENIED_PERMISSION,\n                            \"\" \n);\n    return;\n  }\n\n  device_ids_.clear();\n  PopulateConnectedDevices();\n  if (!chooser_.get()) {\n    return;\n  }\n\n  if (!adapter_->IsPowered()) {\n    chooser_->SetAdapterPresence(\n        BluetoothChooser::AdapterPresence::POWERED_OFF);\n    return;\n  }\n\n  StartDeviceDiscovery();\n}\n", "target": 1, "flaw_line_index": "21,22,27,28,29,30,31,32,33,34,35,36,39,40,41,47,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,88,89"}
{"idx": 7906, "func": "static void ceval(JF, js_Ast *fun, js_Ast *args)\n{\n\tint n = cargs(J, F, args);\n\tif (n == 0)\n\t\temit(J, F, OP_UNDEF);\n\telse while (n-- > 1)\n\t\temit(J, F, OP_POP);\n\temit(J, F, OP_EVAL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187161, "func": " Node::InsertionNotificationRequest HTMLStyleElement::InsertedInto(\n     ContainerNode* insertion_point) {\n   HTMLElement::InsertedInto(insertion_point);\n  return kInsertionShouldCallDidNotifySubtreeInsertions;\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8155, "func": "void Gfx::opSetRenderingIntent(Object args[], int numArgs) {\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7536, "func": "void doMergeNameTree(PDFDoc *doc, XRef *srcXRef, XRef *countRef, int oldRefNum, int newRefNum, Dict *srcNameTree, Dict *mergeNameTree, int numOffset) {\n  Object mergeNameArray;\n  Object srcNameArray;\n  mergeNameTree->lookup(\"Names\", &mergeNameArray);\n  srcNameTree->lookup(\"Names\", &srcNameArray);\n  if (mergeNameArray.isArray() && srcNameArray.isArray()) {\n    Object *newNameArray = new Object();\n    newNameArray->initArray(srcXRef);\n    int j = 0;\n    for (int i = 0; i < srcNameArray.arrayGetLength() - 1; i += 2) {\n      Object key;\n      Object value;\n      srcNameArray.arrayGetNF(i, &key);\n      srcNameArray.arrayGetNF(i + 1, &value);\n      if (key.isString() && value.isRef()) {\n        while (j < mergeNameArray.arrayGetLength() - 1) {\n          Object mkey;\n          Object mvalue;\n          mergeNameArray.arrayGetNF(j, &mkey);\n          mergeNameArray.arrayGetNF(j + 1, &mvalue);\n          if (mkey.isString() && mvalue.isRef()) {\n            if (mkey.getString()->cmp(key.getString()) < 0) {\n              Object *newKey = new Object();\n\t      newKey->initString(new GooString(mkey.getString()->getCString()));\n              newNameArray->arrayAdd(newKey);\n              Object *newValue = new Object();\n              newValue->initRef(mvalue.getRef().num + numOffset, mvalue.getRef().gen);\n              newNameArray->arrayAdd(newValue);\n              delete newKey;\n              delete newValue;\n              j += 2;\n            } else if (mkey.getString()->cmp(key.getString()) == 0) {\n              j += 2;\n            } else {\n              mkey.free();\n              mvalue.free();\n              break;\n            }\n          } else {\n            j += 2;\n          }\n          mkey.free();\n          mvalue.free();\n        }\n        Object *newKey = new Object();\n        newKey->initString(new GooString(key.getString()->getCString()));\n        newNameArray->arrayAdd(newKey);\n        Object *newValue = new Object();\n        newValue->initRef(value.getRef().num, value.getRef().gen);\n        newNameArray->arrayAdd(newValue);\n        delete newKey;\n        delete newValue;\n      }\n      key.free();\n      value.free();\n    }\n    while (j < mergeNameArray.arrayGetLength() - 1) {\n      Object mkey;\n      Object mvalue;\n      mergeNameArray.arrayGetNF(j, &mkey);\n      mergeNameArray.arrayGetNF(j + 1, &mvalue);\n      if (mkey.isString() && mvalue.isRef()) {\n        Object *newKey = new Object();\n        newKey->initString(new GooString(mkey.getString()->getCString()));\n        newNameArray->arrayAdd(newKey);\n        Object *newValue = new Object();\n        newValue->initRef(mvalue.getRef().num + numOffset, mvalue.getRef().gen);\n        newNameArray->arrayAdd(newValue);\n        delete newKey;\n        delete newValue;\n      }\n      j += 2;\n      mkey.free();\n      mvalue.free();\n    }\n    srcNameTree->set(\"Names\", newNameArray);\n    doc->markPageObjects(mergeNameTree, srcXRef, countRef, numOffset, oldRefNum, newRefNum);\n    delete newNameArray;\n  } else if (srcNameArray.isNull() && mergeNameArray.isArray()) {\n    Object *newNameArray = new Object();\n    newNameArray->initArray(srcXRef);\n    for (int i = 0; i < mergeNameArray.arrayGetLength() - 1; i += 2) {\n      Object key;\n      Object value;\n      mergeNameArray.arrayGetNF(i, &key);\n      mergeNameArray.arrayGetNF(i + 1, &value);\n      if (key.isString() && value.isRef()) {\n        Object *newKey = new Object();\n\tnewKey->initString(new GooString(key.getString()->getCString()));\n        newNameArray->arrayAdd(newKey);\n        Object *newValue = new Object();\n        newValue->initRef(value.getRef().num + numOffset, value.getRef().gen);\n        newNameArray->arrayAdd(newValue);\n        delete newKey;\n        delete newValue;\n      }\n      key.free();\n      value.free();\n    }\n    srcNameTree->add(copyString(\"Names\"), newNameArray);\n    doc->markPageObjects(mergeNameTree, srcXRef, countRef, numOffset, oldRefNum, newRefNum);\n  }\n  mergeNameArray.free();\n  srcNameArray.free();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187236, "func": "static int hid_submit_control_transfer(int sub_api, struct usbi_transfer *itransfer)\n{\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);\n\tstruct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);\n\tstruct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);\n\tWINUSB_SETUP_PACKET *setup = (WINUSB_SETUP_PACKET *) transfer->buffer;\n\tHANDLE hid_handle;\n\tstruct winfd wfd;\n\tint current_interface, config;\n\tsize_t size;\n\tint r = LIBUSB_ERROR_INVALID_PARAM;\n\tCHECK_HID_AVAILABLE;\n\ttransfer_priv->pollable_fd = INVALID_WINFD;\n\tsafe_free(transfer_priv->hid_buffer);\n\ttransfer_priv->hid_dest = NULL;\n\tsize = transfer->length - LIBUSB_CONTROL_SETUP_SIZE;\n\tif (size > MAX_CTRL_BUFFER_LENGTH) {\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tcurrent_interface = get_valid_interface(transfer->dev_handle, USB_API_HID);\n\tif (current_interface < 0) {\n\t\tif (auto_claim(transfer, &current_interface, USB_API_HID) != LIBUSB_SUCCESS) {\n\t\t\treturn LIBUSB_ERROR_NOT_FOUND;\n\t\t}\n\t}\n\tusbi_dbg(\"will use interface %d\", current_interface);\n\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\twfd = usbi_create_fd(hid_handle, RW_READ, NULL, NULL);\n\tif (wfd.fd < 0) {\n\t\treturn LIBUSB_ERROR_NOT_FOUND;\n\t}\n\tswitch(LIBUSB_REQ_TYPE(setup->request_type)) {\n\tcase LIBUSB_REQUEST_TYPE_STANDARD:\n\t\tswitch(setup->request) {\n\t\tcase LIBUSB_REQUEST_GET_DESCRIPTOR:\n\t\t\tr = _hid_get_descriptor(priv->hid, wfd.handle, LIBUSB_REQ_RECIPIENT(setup->request_type),\n\t\t\t\t(setup->value >> 8) & 0xFF, setup->value & 0xFF, transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE, &size);\n\t\t\tbreak;\n\t\tcase LIBUSB_REQUEST_GET_CONFIGURATION:\n\t\t\tr = windows_get_configuration(transfer->dev_handle, &config);\n\t\t\tif (r == LIBUSB_SUCCESS) {\n\t\t\t\tsize = 1;\n\t\t\t\t((uint8_t*)transfer->buffer)[LIBUSB_CONTROL_SETUP_SIZE] = (uint8_t)config;\n\t\t\t\tr = LIBUSB_COMPLETED;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LIBUSB_REQUEST_SET_CONFIGURATION:\n\t\t\tif (setup->value == priv->active_config) {\n\t\t\t\tr = LIBUSB_COMPLETED;\n\t\t\t} else {\n\t\t\t\tusbi_warn(ctx, \"cannot set configuration other than the default one\");\n\t\t\t\tr = LIBUSB_ERROR_INVALID_PARAM;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LIBUSB_REQUEST_GET_INTERFACE:\n\t\t\tsize = 1;\n\t\t\t((uint8_t*)transfer->buffer)[LIBUSB_CONTROL_SETUP_SIZE] = 0;\n\t\t\tr = LIBUSB_COMPLETED;\n\t\t\tbreak;\n\t\tcase LIBUSB_REQUEST_SET_INTERFACE:\n\t\t\tr = hid_set_interface_altsetting(0, transfer->dev_handle, setup->index, setup->value);\n\t\t\tif (r == LIBUSB_SUCCESS) {\n\t\t\t\tr = LIBUSB_COMPLETED;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusbi_warn(ctx, \"unsupported HID control request\");\n\t\t\tr = LIBUSB_ERROR_INVALID_PARAM;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase LIBUSB_REQUEST_TYPE_CLASS:\n\t\tr =_hid_class_request(priv->hid, wfd.handle, setup->request_type, setup->request, setup->value,\n\t\t\tsetup->index, transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE, transfer_priv,\n\t\t\t&size, wfd.overlapped);\n\t\tbreak;\n\tdefault:\n\t\tusbi_warn(ctx, \"unsupported HID control request\");\n\t\tr = LIBUSB_ERROR_INVALID_PARAM;\n\t\tbreak;\n\t}\n\tif (r == LIBUSB_COMPLETED) {\n\t\twfd.overlapped->Internal = STATUS_COMPLETED_SYNCHRONOUSLY;\n\t\twfd.overlapped->InternalHigh = (DWORD)size;\n\t\tr = LIBUSB_SUCCESS;\n\t}\n\tif (r == LIBUSB_SUCCESS) {\n\t\ttransfer_priv->pollable_fd = wfd;\n\t\ttransfer_priv->interface_number = (uint8_t)current_interface;\n\t} else {\n\t\tusbi_free_fd(&wfd);\n\t}\n\treturn r;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97"}
{"idx": 187027, "func": "void RemoveProcessIdFromGlobalMap(int32_t process_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  GetProcessIdToFilterMap()->erase(process_id);\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 7523, "func": "  tt_size_run_prep( TT_Size  size,\n                    FT_Bool  pedantic )\n  {\n    TT_Face         face = (TT_Face)size->root.face;\n    TT_ExecContext  exec;\n    FT_Error        error;\n\n\n    exec = size->context;\n\n    error = TT_Load_Context( exec, face, size );\n    if ( error )\n      return error;\n\n    exec->callTop = 0;\n    exec->top     = 0;\n\n    exec->instruction_trap = FALSE;\n\n    exec->pedantic_hinting = pedantic;\n\n    TT_Set_CodeRange( exec,\n                      tt_coderange_cvt,\n                      face->cvt_program,\n                      (FT_Long)face->cvt_program_size );\n\n    TT_Clear_CodeRange( exec, tt_coderange_glyph );\n\n    if ( face->cvt_program_size > 0 )\n    {\n      TT_Goto_CodeRange( exec, tt_coderange_cvt, 0 );\n\n      FT_TRACE4(( \"Executing `prep' table.\\n\" ));\n      error = face->interpreter( exec );\n#ifdef FT_DEBUG_LEVEL_TRACE\n      if ( error )\n        FT_TRACE4(( \"  interpretation failed with error code 0x%x\\n\",\n                    error ));\n#endif\n    }\n    else\n      error = FT_Err_Ok;\n\n    size->cvt_ready = error;\n\n\n    exec->GS.dualVector.x = 0x4000;\n    exec->GS.dualVector.y = 0;\n    exec->GS.projVector.x = 0x4000;\n    exec->GS.projVector.y = 0x0;\n    exec->GS.freeVector.x = 0x4000;\n    exec->GS.freeVector.y = 0x0;\n\n    exec->GS.rp0 = 0;\n    exec->GS.rp1 = 0;\n    exec->GS.rp2 = 0;\n\n    exec->GS.gep0 = 1;\n    exec->GS.gep1 = 1;\n    exec->GS.gep2 = 1;\n\n    exec->GS.loop = 1;\n\n    size->GS = exec->GS;\n\n    TT_Save_Context( exec, size );\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7462, "func": "void DBusHelperProxy::setHelperResponder(QObject *o)\n{\n    responder = o;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7670, "func": "static int handle_init(FsContext *ctx)\n{\n    int ret, mnt_id;\n    struct statfs stbuf;\n    struct file_handle fh;\n    struct handle_data *data = g_malloc(sizeof(struct handle_data));\n\n    data->mountfd = open(ctx->fs_root, O_DIRECTORY);\n    if (data->mountfd < 0) {\n        ret = data->mountfd;\n        goto err_out;\n    }\n    ret = statfs(ctx->fs_root, &stbuf);\n    if (!ret) {\n        switch (stbuf.f_type) {\n        case EXT2_SUPER_MAGIC:\n        case BTRFS_SUPER_MAGIC:\n        case REISERFS_SUPER_MAGIC:\n        case XFS_SUPER_MAGIC:\n            ctx->exops.get_st_gen = handle_ioc_getversion;\n            break;\n        }\n    }\n    memset(&fh, 0, sizeof(struct file_handle));\n    ret = name_to_handle(data->mountfd, \".\", &fh, &mnt_id, 0);\n    if (ret && errno == EOVERFLOW) {\n        data->handle_bytes = fh.handle_bytes;\n        ctx->private = data;\n        ret = 0;\n        goto out;\n    }\n    ret = -1;\n    close(data->mountfd);\nerr_out:\n    g_free(data);\nout:\n     return ret;\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7873, "func": "static ram_addr_t ram_save_remaining(void)\n{\n    return migration_dirty_pages;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8179, "func": "void Gfx::pushResources(Dict *resDict) {\n  res = new GfxResources(xref, resDict, res);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186625, "func": "void RenderViewImpl::NavigateBackForwardSoon(int offset) {\n   history_navigation_virtual_time_pauser_ =\n       RenderThreadImpl::current()\n           ->GetWebMainThreadScheduler()\n           ->CreateWebScopedVirtualTimePauser(\n               \"NavigateBackForwardSoon\",\n               blink::WebScopedVirtualTimePauser::VirtualTaskDuration::kInstant);\n   history_navigation_virtual_time_pauser_.PauseVirtualTime();\n  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8202, "func": "static V9fsFidState *get_fid(V9fsPDU *pdu, int32_t fid)\n{\n    int err;\n    V9fsFidState *f;\n    V9fsState *s = pdu->s;\n\n    for (f = s->fid_list; f; f = f->next) {\n        BUG_ON(f->clunked);\n        if (f->fid == fid) {\n            f->ref++;\n            err = v9fs_reopen_fid(pdu, f);\n            if (err < 0) {\n                f->ref--;\n                return NULL;\n            }\n            f->flags |= FID_REFERENCED;\n            return f;\n        }\n    }\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7805, "func": "static int h2c_send_rst_stream(struct h2c *h2c, struct h2s *h2s)\n{\n\tstruct buffer *res;\n\tchar str[13];\n\tint ret;\n\n\tif (h2c->dft == H2_FT_RST_STREAM) {\n\t\tret = 1;\n\t\tgoto ignore;\n\t}\n\n\tif (h2c_mux_busy(h2c, h2s)) {\n\t\th2c->flags |= H2_CF_DEM_MBUSY;\n\t\treturn 0;\n\t}\n\n\tres = h2_get_buf(h2c, &h2c->mbuf);\n\tif (!res) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\treturn 0;\n\t}\n\n\tmemcpy(str, \"\\x00\\x00\\x04\\x03\\x00\", 5);\n\n\twrite_n32(str + 5, h2c->dsi);\n\twrite_n32(str + 9, (h2s->st > H2_SS_IDLE && h2s->st < H2_SS_CLOSED) ?\n\t\t  h2s->errcode : H2_ERR_STREAM_CLOSED);\n\tret = bo_istput(res, ist2(str, 13));\n\n\tif (unlikely(ret <= 0)) {\n\t\tif (!ret) {\n\t\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\t\th2c->flags |= H2_CF_DEM_MROOM;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n ignore:\n\tif (h2s->st > H2_SS_IDLE && h2s->st < H2_SS_CLOSED) {\n\t\th2s->flags |= H2_SF_RST_SENT;\n\t\th2s_close(h2s);\n\t}\n\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186680, "func": "void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,\n                                      UpdateFromElementBehavior update_behavior,\n                                      const KURL& url,\n                                      ReferrerPolicy referrer_policy,\n                                      UpdateType update_type) {\n  pending_task_.reset();\n  std::unique_ptr<IncrementLoadEventDelayCount> load_delay_counter;\n  load_delay_counter.swap(delay_until_do_update_from_element_);\n\n  Document& document = element_->GetDocument();\n  if (!document.IsActive())\n    return;\n\n  AtomicString image_source_url = element_->ImageSourceURL();\n  ImageResourceContent* new_image_content = nullptr;\n  if (!url.IsNull() && !url.IsEmpty()) {\n    ResourceLoaderOptions resource_loader_options;\n    resource_loader_options.initiator_info.name = GetElement()->localName();\n    ResourceRequest resource_request(url);\n    if (update_behavior == kUpdateForcedReload) {\n      resource_request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);\n      resource_request.SetPreviewsState(WebURLRequest::kPreviewsNoTransform);\n    }\n\n    if (referrer_policy != kReferrerPolicyDefault) {\n      resource_request.SetHTTPReferrer(SecurityPolicy::GenerateReferrer(\n          referrer_policy, url, document.OutgoingReferrer()));\n    }\n\n    if (IsHTMLPictureElement(GetElement()->parentNode()) ||\n        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull()) {\n      resource_request.SetRequestContext(\n          WebURLRequest::kRequestContextImageSet);\n    } else if (IsHTMLObjectElement(GetElement())) {\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextObject);\n    } else if (IsHTMLEmbedElement(GetElement())) {\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextEmbed);\n    }\n\n    bool page_is_being_dismissed =\n        document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;\n    if (page_is_being_dismissed) {\n      resource_request.SetHTTPHeaderField(HTTPNames::Cache_Control,\n                                          \"max-age=0\");\n      resource_request.SetKeepalive(true);\n       resource_request.SetRequestContext(WebURLRequest::kRequestContextPing);\n     }\n \n     FetchParameters params(resource_request, resource_loader_options);\n     ConfigureRequest(params, bypass_behavior, *element_,\n                      document.GetClientHintsPreferences());\n\n    if (update_behavior != kUpdateForcedReload && document.GetFrame())\n      document.GetFrame()->MaybeAllowImagePlaceholder(params);\n\n    new_image_content = ImageResourceContent::Fetch(params, document.Fetcher());\n\n    if (page_is_being_dismissed)\n      new_image_content = nullptr;\n\n    ClearFailedLoadURL();\n  } else {\n    if (!image_source_url.IsNull()) {\n      DispatchErrorEvent();\n    }\n    NoImageResourceToLoad();\n  }\n\n  ImageResourceContent* old_image_content = image_content_.Get();\n  if (old_image_content != new_image_content)\n    RejectPendingDecodes(update_type);\n\n  if (update_behavior == kUpdateSizeChanged && element_->GetLayoutObject() &&\n      element_->GetLayoutObject()->IsImage() &&\n      new_image_content == old_image_content) {\n    ToLayoutImage(element_->GetLayoutObject())->IntrinsicSizeChanged();\n  } else {\n    if (pending_load_event_.IsActive())\n      pending_load_event_.Cancel();\n\n    if (pending_error_event_.IsActive() && new_image_content)\n      pending_error_event_.Cancel();\n\n    UpdateImageState(new_image_content);\n\n    UpdateLayoutObject();\n    if (new_image_content) {\n      new_image_content->AddObserver(this);\n    }\n    if (old_image_content) {\n      old_image_content->RemoveObserver(this);\n    }\n  }\n\n  if (LayoutImageResource* image_resource = GetLayoutImageResource())\n    image_resource->ResetAnimation();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7396, "func": "getstr(struct magic_set *ms, struct magic *m, const char *s, int warn)\n{\n\tconst char *origs = s;\n\tchar\t*p = m->value.s;\n\tsize_t  plen = sizeof(m->value.s);\n\tchar \t*origp = p;\n\tchar\t*pmax = p + plen - 1;\n\tint\tc;\n\tint\tval;\n\n\twhile ((c = *s++) != '\\0') {\n\t\tif (isspace((unsigned char) c))\n\t\t\tbreak;\n\t\tif (p >= pmax) {\n\t\t\tfile_error(ms, 0, \"string too long: `%s'\", origs);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c == '\\\\') {\n\t\t\tswitch(c = *s++) {\n\n\t\t\tcase '\\0':\n\t\t\t\tif (warn)\n\t\t\t\t\tfile_magwarn(ms, \"incomplete escape\");\n\t\t\t\tgoto out;\n\n\t\t\tcase '\\t':\n\t\t\t\tif (warn) {\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"escaped tab found, use \\\\t instead\");\n\t\t\t\t\twarn = 0;\t\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif (warn) {\n\t\t\t\t\tif (isprint((unsigned char)c)) {\n\t\t\t\t\t\tif (strchr(\"<>&^=!\", c) == NULL\n\t\t\t\t\t\t    && (m->type != FILE_REGEX ||\n\t\t\t\t\t\t    strchr(\"[]().*?^$|{}\", c)\n\t\t\t\t\t\t    == NULL)) {\n\t\t\t\t\t\t\tfile_magwarn(ms, \"no \"\n\t\t\t\t\t\t\t    \"need to escape \"\n\t\t\t\t\t\t\t    \"`%c'\", c);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"unknown escape sequence: \"\n\t\t\t\t\t\t    \"\\\\%03o\", c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase ' ':\n#if 0\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '?':\n#endif\n\t\t\tcase '>':\n\t\t\tcase '<':\n\t\t\tcase '&':\n\t\t\tcase '^':\n\t\t\tcase '=':\n\t\t\tcase '!':\n\t\t\tcase '\\\\':\n\t\t\t\t*p++ = (char) c;\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\t\t*p++ = '\\a';\n\t\t\t\tbreak;\n\n\t\t\tcase 'b':\n\t\t\t\t*p++ = '\\b';\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\t*p++ = '\\f';\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\t*p++ = '\\n';\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t*p++ = '\\r';\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t*p++ = '\\t';\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\t*p++ = '\\v';\n\t\t\t\tbreak;\n\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\t\tval = c - '0';\n\t\t\t\tc = *s++;  \n\t\t\t\tif (c >= '0' && c <= '7') {\n\t\t\t\t\tval = (val << 3) | (c - '0');\n\t\t\t\t\tc = *s++;  \n\t\t\t\t\tif (c >= '0' && c <= '7')\n\t\t\t\t\t\tval = (val << 3) | (c-'0');\n\t\t\t\t\telse\n\t\t\t\t\t\t--s;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t--s;\n\t\t\t\t*p++ = (char)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 'x':\n\t\t\t\tval = 'x';\t\n\t\t\t\tc = hextoint(*s++);\t\n\t\t\t\tif (c >= 0) {\n\t\t\t\t\tval = c;\n\t\t\t\t\tc = hextoint(*s++);\n\t\t\t\t\tif (c >= 0)\n\t\t\t\t\t\tval = (val << 4) + c;\n\t\t\t\t\telse\n\t\t\t\t\t\t--s;\n\t\t\t\t} else\n\t\t\t\t\t--s;\n\t\t\t\t*p++ = (char)val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\t*p++ = (char)c;\n\t}\nout:\n\t*p = '\\0';\n\tm->vallen = CAST(unsigned char, (p - origp));\n\tif (m->type == FILE_PSTRING)\n\t\tm->vallen += (unsigned char)file_pstring_length_size(m);\n\treturn s;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8298, "func": "XRRFreeProviderInfo(XRRProviderInfo *provider)\n{\n    free(provider);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8134, "func": "void Gfx::opRectangle(Object args[], int numArgs) {\n  double x, y, w, h;\n\n  x = args[0].getNum();\n  y = args[1].getNum();\n  w = args[2].getNum();\n  h = args[3].getNum();\n  state->moveTo(x, y);\n  state->lineTo(x + w, y);\n  state->lineTo(x + w, y + h);\n  state->lineTo(x, y + h);\n  state->closePath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187149, "func": "ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n     : InfoBarView(std::move(delegate)) {\n   auto* delegate_ptr = GetDelegate();\n   label_ = CreateLabel(delegate_ptr->GetMessageText());\n   AddChildView(label_);\n \n   const auto buttons = delegate_ptr->GetButtons();\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {\n    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);\n    ok_button_->SetProminent(true);\n    if (delegate_ptr->OKButtonTriggersUACPrompt()) {\n      elevation_icon_setter_.reset(new ElevationIconSetter(\n          ok_button_,\n          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));\n    }\n  }\n\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {\n    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);\n    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)\n      cancel_button_->SetProminent(true);\n  }\n\n  link_ = CreateLink(delegate_ptr->GetLinkText(), this);\n  AddChildView(link_);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186904, "func": "BlobStorageContext::BlobFlattener::BlobFlattener(\n    const BlobDataBuilder& input_builder,\n    BlobEntry* output_blob,\n    BlobStorageRegistry* registry) {\n  const std::string& uuid = input_builder.uuid_;\n  std::set<std::string> dependent_blob_uuids;\n\n  size_t num_files_with_unknown_size = 0;\n  size_t num_building_dependent_blobs = 0;\n\n  bool found_memory_transport = false;\n  bool found_file_transport = false;\n\n  base::CheckedNumeric<uint64_t> checked_total_size = 0;\n  base::CheckedNumeric<uint64_t> checked_total_memory_size = 0;\n  base::CheckedNumeric<uint64_t> checked_transport_quota_needed = 0;\n  base::CheckedNumeric<uint64_t> checked_copy_quota_needed = 0;\n\n  for (scoped_refptr<BlobDataItem> input_item : input_builder.items_) {\n    const DataElement& input_element = input_item->data_element();\n    DataElement::Type type = input_element.type();\n    uint64_t length = input_element.length();\n\n    RecordBlobItemSizeStats(input_element);\n\n    if (IsBytes(type)) {\n      DCHECK_NE(0 + DataElement::kUnknownSize, input_element.length());\n      found_memory_transport = true;\n      if (found_file_transport) {\n        status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n        return;\n      }\n      contains_unpopulated_transport_items |=\n          (type == DataElement::TYPE_BYTES_DESCRIPTION);\n      checked_transport_quota_needed += length;\n      checked_total_size += length;\n      scoped_refptr<ShareableBlobDataItem> item = new ShareableBlobDataItem(\n          std::move(input_item), ShareableBlobDataItem::QUOTA_NEEDED);\n      pending_transport_items.push_back(item);\n      transport_items.push_back(item.get());\n      output_blob->AppendSharedBlobItem(std::move(item));\n      continue;\n    }\n    if (type == DataElement::TYPE_BLOB) {\n      BlobEntry* ref_entry = registry->GetEntry(input_element.blob_uuid());\n\n      if (!ref_entry || input_element.blob_uuid() == uuid) {\n        status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n        return;\n      }\n\n      if (BlobStatusIsError(ref_entry->status())) {\n        status = BlobStatus::ERR_REFERENCED_BLOB_BROKEN;\n        return;\n      }\n\n      if (ref_entry->total_size() == DataElement::kUnknownSize) {\n        status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n        return;\n      }\n\n      if (dependent_blob_uuids.find(input_element.blob_uuid()) ==\n          dependent_blob_uuids.end()) {\n        dependent_blobs.push_back(\n            std::make_pair(input_element.blob_uuid(), ref_entry));\n        dependent_blob_uuids.insert(input_element.blob_uuid());\n        if (BlobStatusIsPending(ref_entry->status())) {\n          num_building_dependent_blobs++;\n        }\n      }\n\n      length = length == DataElement::kUnknownSize ? ref_entry->total_size()\n                                                   : input_element.length();\n      checked_total_size += length;\n\n      if (input_element.offset() == 0 && length == ref_entry->total_size()) {\n        for (const auto& shareable_item : ref_entry->items()) {\n          output_blob->AppendSharedBlobItem(shareable_item);\n        }\n        continue;\n       }\n \n      if (input_element.offset() + length > ref_entry->total_size()) {\n         status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n         return;\n       }\n\n      BlobSlice slice(*ref_entry, input_element.offset(), length);\n\n      if (!slice.copying_memory_size.IsValid() ||\n          !slice.total_memory_size.IsValid()) {\n        status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n        return;\n      }\n      checked_total_memory_size += slice.total_memory_size;\n\n      if (slice.first_source_item) {\n        copies.push_back(ItemCopyEntry(slice.first_source_item,\n                                       slice.first_item_slice_offset,\n                                       slice.dest_items.front()));\n        pending_copy_items.push_back(slice.dest_items.front());\n      }\n      if (slice.last_source_item) {\n        copies.push_back(\n            ItemCopyEntry(slice.last_source_item, 0, slice.dest_items.back()));\n        pending_copy_items.push_back(slice.dest_items.back());\n      }\n      checked_copy_quota_needed += slice.copying_memory_size;\n\n      for (auto& shareable_item : slice.dest_items) {\n        output_blob->AppendSharedBlobItem(std::move(shareable_item));\n      }\n      continue;\n    }\n\n    scoped_refptr<ShareableBlobDataItem> item;\n    if (BlobDataBuilder::IsFutureFileItem(input_element)) {\n      found_file_transport = true;\n      if (found_memory_transport) {\n        status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n        return;\n      }\n      contains_unpopulated_transport_items = true;\n      item = new ShareableBlobDataItem(std::move(input_item),\n                                       ShareableBlobDataItem::QUOTA_NEEDED);\n      pending_transport_items.push_back(item);\n      transport_items.push_back(item.get());\n      checked_transport_quota_needed += length;\n    } else {\n      item = new ShareableBlobDataItem(\n          std::move(input_item),\n          ShareableBlobDataItem::POPULATED_WITHOUT_QUOTA);\n    }\n    if (length == DataElement::kUnknownSize)\n      num_files_with_unknown_size++;\n\n    checked_total_size += length;\n    output_blob->AppendSharedBlobItem(std::move(item));\n  }\n\n  if (num_files_with_unknown_size > 1 && input_builder.items_.size() > 1) {\n    status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n    return;\n  }\n  if (!checked_total_size.IsValid() || !checked_total_memory_size.IsValid() ||\n      !checked_transport_quota_needed.IsValid() ||\n      !checked_copy_quota_needed.IsValid()) {\n    status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;\n    return;\n  }\n  total_size = checked_total_size.ValueOrDie();\n  total_memory_size = checked_total_memory_size.ValueOrDie();\n  transport_quota_needed = checked_transport_quota_needed.ValueOrDie();\n  copy_quota_needed = checked_copy_quota_needed.ValueOrDie();\n  transport_quota_type = found_file_transport ? TransportQuotaType::FILE\n                                              : TransportQuotaType::MEMORY;\n  if (transport_quota_needed) {\n    status = BlobStatus::PENDING_QUOTA;\n  } else {\n    status = BlobStatus::PENDING_INTERNALS;\n  }\n}\n", "target": 1, "flaw_line_index": "87"}
{"idx": 8045, "func": "int vnc_server_fb_stride(VncDisplay *vd)\n{\n    return pixman_image_get_stride(vd->server);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8105, "func": "GBool GfxResources::lookupXObjectNF(char *name, Object *obj) {\n  GfxResources *resPtr;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->xObjDict.isDict()) {\n      if (!resPtr->xObjDict.dictLookupNF(name, obj)->isNull())\n\treturn gTrue;\n      obj->free();\n    }\n  }\n  error(-1, \"XObject '%s' is unknown\", name);\n  return gFalse;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187157, "func": " DownloadCoreServiceImpl::GetDownloadManagerDelegate() {\n   DownloadManager* manager = BrowserContext::GetDownloadManager(profile_);\n  if (download_manager_created_) {\n    DCHECK(static_cast<DownloadManagerDelegate*>(manager_delegate_.get()) ==\n           manager->GetDelegate());\n     return manager_delegate_.get();\n  }\n   download_manager_created_ = true;\n \n  if (!manager_delegate_.get())\n    manager_delegate_.reset(new ChromeDownloadManagerDelegate(profile_));\n\n  manager_delegate_->SetDownloadManager(manager);\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  extension_event_router_.reset(\n      new extensions::ExtensionDownloadsEventRouter(profile_, manager));\n#endif\n\n  if (!profile_->IsOffTheRecord()) {\n    history::HistoryService* history = HistoryServiceFactory::GetForProfile(\n        profile_, ServiceAccessType::EXPLICIT_ACCESS);\n    history->GetNextDownloadId(\n        manager_delegate_->GetDownloadIdReceiverCallback());\n    download_history_.reset(new DownloadHistory(\n        manager, std::unique_ptr<DownloadHistory::HistoryAdapter>(\n                     new DownloadHistory::HistoryAdapter(history))));\n  }\n\n  download_ui_.reset(new DownloadUIController(\n      manager, std::unique_ptr<DownloadUIController::Delegate>()));\n \n   g_browser_process->download_status_updater()->AddManager(manager);\n \n   return manager_delegate_.get();\n}\n", "target": 1, "flaw_line_index": "4,5,6,8"}
{"idx": 186887, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n       UTRANS_FORWARD, parse_error, status));\n \n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"\u04cf > l; [\u043a\u0138\u03ba] > k; \u043f > n; [\u0185\u044c] > b; \u0432 > b; \u043c > m; \u043d > h; \"\n          \"\u0442 > t; [\u0448\u0449] > w; \u0d1f > s;\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186818, "func": "PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n  if (mapping)\n    memset(mapping.get(), 0, kReadingBufferSize);\n  return mapping;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7869, "func": "static int ram_save_complete(QEMUFile *f, void *opaque)\n{\n    qemu_mutex_lock_ramlist();\n    migration_bitmap_sync();\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n\n    while (true) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, true);\n        if (bytes_sent == 0) {\n            break;\n        }\n        bytes_transferred += bytes_sent;\n    }\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n    migration_end();\n\n    qemu_mutex_unlock_ramlist();\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7724, "func": "static void coroutine_fn v9fs_lock(void *opaque)\n{\n    int8_t status;\n    V9fsFlock flock;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n\n    status = P9_LOCK_ERROR;\n    v9fs_string_init(&flock.client_id);\n    err = pdu_unmarshal(pdu, offset, \"dbdqqds\", &fid, &flock.type,\n                        &flock.flags, &flock.start, &flock.length,\n                        &flock.proc_id, &flock.client_id);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_lock(pdu->tag, pdu->id, fid,\n                    flock.type, flock.start, flock.length);\n\n\n    if (flock.flags & ~P9_LOCK_FLAGS_BLOCK) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    status = P9_LOCK_SUCCESS;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    err = pdu_marshal(pdu, offset, \"b\", status);\n    if (err > 0) {\n        err += offset;\n    }\n    trace_v9fs_lock_return(pdu->tag, pdu->id, status);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&flock.client_id);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8167, "func": "void Gfx::opShFill(Object args[], int numArgs) {\n  GfxShading *shading;\n  GfxPath *savedPath;\n  double xMin, yMin, xMax, yMax;\n\n  if (!(shading = res->lookupShading(args[0].getName(), this))) {\n    return;\n  }\n\n  savedPath = state->getPath()->copy();\n  saveState();\n\n  if (shading->getHasBBox()) {\n    shading->getBBox(&xMin, &yMin, &xMax, &yMax);\n    state->moveTo(xMin, yMin);\n    state->lineTo(xMax, yMin);\n    state->lineTo(xMax, yMax);\n    state->lineTo(xMin, yMax);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n\n  state->setFillColorSpace(shading->getColorSpace()->copy());\n  out->updateFillColorSpace(state);\n\n#if 1 \n  GBool vaa = out->getVectorAntialias();\n  if (vaa) {\n    out->setVectorAntialias(gFalse);\n  }\n#endif\n\n  switch (shading->getType()) {\n  case 1:\n    doFunctionShFill((GfxFunctionShading *)shading);\n    break;\n  case 2:\n    doAxialShFill((GfxAxialShading *)shading);\n    break;\n  case 3:\n    doRadialShFill((GfxRadialShading *)shading);\n    break;\n  case 4:\n  case 5:\n    doGouraudTriangleShFill((GfxGouraudTriangleShading *)shading);\n    break;\n  case 6:\n  case 7:\n    doPatchMeshShFill((GfxPatchMeshShading *)shading);\n    break;\n  }\n\n#if 1 \n  if (vaa) {\n    out->setVectorAntialias(gTrue);\n  }\n#endif\n\n  restoreState();\n  state->setPath(savedPath);\n\n  delete shading;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187024, "func": "ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\n    NavigationHandle* handle) {\n  DCHECK(content::MimeHandlerViewMode::UsesCrossProcessFrame());\n  if (!handle->GetParentFrame()) {\n    return nullptr;\n  }\n  int32_t parent_process_id = handle->GetParentFrame()->GetProcess()->GetID();\n  auto& map = *GetProcessIdToFilterMap();\n  if (!base::ContainsKey(map, parent_process_id) || !map[parent_process_id]) {\n    return nullptr;\n  }\n  for (auto& pair : map[parent_process_id]->frame_navigation_helpers_) {\n    if (!pair.second->ShouldCancelAndIgnore(handle))\n      continue;\n    return std::make_unique<CancelAndIgnoreNavigationForPluginFrameThrottle>(\n        handle);\n  }\n  return nullptr;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20"}
{"idx": 186405, "func": "void PageInfo::OnWhitelistPasswordReuseButtonPressed(\n     content::WebContents* web_contents) {\n #if defined(FULL_SAFE_BROWSING)\n   DCHECK(password_protection_service_);\n  DCHECK(safe_browsing_status_ == SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE ||\n         safe_browsing_status_ ==\n             SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE);\n   password_protection_service_->OnUserAction(\n       web_contents,\n      safe_browsing_status_ == SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE\n           ? PasswordReuseEvent::SIGN_IN_PASSWORD\n           : PasswordReuseEvent::ENTERPRISE_PASSWORD,\n       safe_browsing::WarningUIType::PAGE_INFO,\n      safe_browsing::WarningAction::MARK_AS_LEGITIMATE);\n#endif\n}\n", "target": 1, "flaw_line_index": "5,6,7,10"}
{"idx": 187296, "func": " FileManagerPrivateCustomBindings::FileManagerPrivateCustomBindings(\n     ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetFileSystem\",\n       base::Bind(&FileManagerPrivateCustomBindings::GetFileSystem,\n                  base::Unretained(this)));\n }\n", "target": 1, "flaw_line_index": "5,6,7"}
{"idx": 8235, "func": "static void v9fs_stat(void *opaque)\n{\n    int32_t fid;\n    V9fsStat v9stat;\n    ssize_t err = 0;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n    if (err < 0) {\n        v9fs_stat_free(&v9stat);\n        goto out;\n    }\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n    err += offset;\n    v9fs_stat_free(&v9stat);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186939, "func": " void ImageCapture::ResolveWithMediaTrackConstraints(\n    MediaTrackConstraints constraints,\n     ScriptPromiseResolver* resolver) {\n   DCHECK(resolver);\n   resolver->Resolve(constraints);\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186728, "func": "void IOHandler::SetRenderer(RenderProcessHost* process_host,\n                             RenderFrameHostImpl* frame_host) {\n  process_host_ = process_host;\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186572, "func": " PaintImage AcceleratedStaticBitmapImage::PaintImageForCurrentFrame() {\n  CheckThread();\n   if (!IsValid())\n     return PaintImage();\n \n   sk_sp<SkImage> image;\n   if (original_skia_image_ &&\n      original_skia_image_thread_id_ ==\n          Platform::Current()->CurrentThread()->ThreadId()) {\n    image = original_skia_image_;\n  } else {\n    CreateImageFromMailboxIfNeeded();\n    image = texture_holder_->GetSkImage();\n  }\n\n  return CreatePaintImageBuilder()\n      .set_image(image, paint_image_content_id_)\n      .set_completion_state(PaintImage::CompletionState::DONE)\n      .TakePaintImage();\n}\n", "target": 1, "flaw_line_index": "4,10,11"}
{"idx": 186461, "func": "HistogramBase* Histogram::Factory::Build() {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name_);\n  if (!histogram) {\n    const BucketRanges* created_ranges = CreateRanges();\n    const BucketRanges* registered_ranges =\n        StatisticsRecorder::RegisterOrDeleteDuplicateRanges(created_ranges);\n\n    if (bucket_count_ == 0) {\n      bucket_count_ = static_cast<uint32_t>(registered_ranges->bucket_count());\n      minimum_ = registered_ranges->range(1);\n      maximum_ = registered_ranges->range(bucket_count_ - 1);\n    }\n\n    PersistentHistogramAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          histogram_type_,\n          name_,\n          minimum_,\n          maximum_,\n          registered_ranges,\n          flags_,\n          &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  \n      DCHECK(!allocator);  \n      flags_ &= ~HistogramBase::kIsPersistent;\n      tentative_histogram = HeapAlloc(registered_ranges);\n      tentative_histogram->SetFlags(flags_);\n    }\n\n    FillHistogram(tentative_histogram.get());\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n   if (bucket_count_ != 0 &&\n       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {\n    DLOG(ERROR) << \"Histogram \" << name_ << \" has bad construction arguments\";\n    return nullptr;\n  }\n  return histogram;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7657, "func": "static void prstat_to_stat(struct stat *stbuf, ProxyStat *prstat)\n{\n   memset(stbuf, 0, sizeof(*stbuf));\n   stbuf->st_dev = prstat->st_dev;\n   stbuf->st_ino = prstat->st_ino;\n   stbuf->st_nlink = prstat->st_nlink;\n   stbuf->st_mode = prstat->st_mode;\n   stbuf->st_uid = prstat->st_uid;\n   stbuf->st_gid = prstat->st_gid;\n   stbuf->st_rdev = prstat->st_rdev;\n   stbuf->st_size = prstat->st_size;\n   stbuf->st_blksize = prstat->st_blksize;\n   stbuf->st_blocks = prstat->st_blocks;\n   stbuf->st_atim.tv_sec = prstat->st_atim_sec;\n   stbuf->st_atim.tv_nsec = prstat->st_atim_nsec;\n   stbuf->st_mtime = prstat->st_mtim_sec;\n   stbuf->st_mtim.tv_nsec = prstat->st_mtim_nsec;\n   stbuf->st_ctime = prstat->st_ctim_sec;\n   stbuf->st_ctim.tv_nsec = prstat->st_ctim_nsec;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186729, "func": " void NetworkHandler::ClearBrowserCache(\n     std::unique_ptr<ClearBrowserCacheCallback> callback) {\n  if (!process_) {\n     callback->sendFailure(Response::InternalError());\n     return;\n   }\n   content::BrowsingDataRemover* remover =\n      content::BrowserContext::GetBrowsingDataRemover(\n          process_->GetBrowserContext());\n   remover->RemoveAndReply(\n       base::Time(), base::Time::Max(),\n       content::BrowsingDataRemover::DATA_TYPE_CACHE,\n      content::BrowsingDataRemover::ORIGIN_TYPE_UNPROTECTED_WEB,\n      new DevtoolsClearCacheObserver(remover, std::move(callback)));\n}\n", "target": 1, "flaw_line_index": "3,8,9"}
{"idx": 7495, "func": "generate_trivial_inner (DBusMessageDataIter *iter,\n                        DBusMessage        **message_p)\n{\n  DBusMessage *message;\n\n  switch (iter_get_sequence (iter))\n    {\n    case 0:\n      message = dbus_message_new_method_call (\"org.freedesktop.TextEditor\",\n                                              \"/foo/bar\",\n                                              \"org.freedesktop.DocumentFactory\",\n                                              \"Create\");\n      break;\n    case 1:\n      message = dbus_message_new (DBUS_MESSAGE_TYPE_METHOD_RETURN);\n      set_reply_serial (message);\n      break;\n    case 2:\n      message = dbus_message_new_signal (\"/foo/bar\",\n                                         \"org.freedesktop.DocumentFactory\",\n                                         \"Created\");\n      break;\n    case 3:\n      message = dbus_message_new (DBUS_MESSAGE_TYPE_ERROR);\n\n      if (!dbus_message_set_error_name (message,\n                                        \"org.freedesktop.TestErrorName\"))\n        _dbus_assert_not_reached (\"oom\");\n      \n      {\n        DBusMessageIter iter;\n        const char *v_STRING = \"This is an error\";\n        \n        dbus_message_iter_init_append (message, &iter);\n        if (!dbus_message_iter_append_basic (&iter,\n                                             DBUS_TYPE_STRING,\n                                             &v_STRING))\n          _dbus_assert_not_reached (\"oom\");\n      }\n      \n      set_reply_serial (message);\n      break;\n    default:\n      return FALSE;\n    }\n  \n  if (message == NULL)\n    _dbus_assert_not_reached (\"oom\");\n\n  *message_p = message;\n  \n  return TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7623, "func": "static int connect_namedsocket(const char *path)\n{\n    int sockfd, size;\n    struct sockaddr_un helper;\n\n    if (strlen(path) >= sizeof(helper.sun_path)) {\n        error_report(\"Socket name too long\");\n        return -1;\n    }\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        error_report(\"Failed to create socket: %s\", strerror(errno));\n        return -1;\n    }\n    strcpy(helper.sun_path, path);\n    helper.sun_family = AF_UNIX;\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n        error_report(\"Failed to connect to %s: %s\", path, strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n\n    unlink(path);\n    return sockfd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186320, "func": "IndexedDBTransaction* IndexedDBConnection::CreateTransaction(\n    int64_t id,\n     const std::set<int64_t>& scope,\n     blink::WebIDBTransactionMode mode,\n     IndexedDBBackingStore::Transaction* backing_store_transaction) {\n  DCHECK_EQ(GetTransaction(id), nullptr) << \"Duplicate transaction id.\" << id;\n   std::unique_ptr<IndexedDBTransaction> transaction =\n       IndexedDBClassFactory::Get()->CreateIndexedDBTransaction(\n           id, this, scope, mode, backing_store_transaction);\n  IndexedDBTransaction* transaction_ptr = transaction.get();\n  transactions_[id] = std::move(transaction);\n  return transaction_ptr;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187240, "func": "static int windows_get_device_list(struct libusb_context *ctx, struct discovered_devs **_discdevs)\n{\n\tstruct discovered_devs *discdevs;\n\tHDEVINFO dev_info = { 0 };\n \tconst char* usb_class[] = {\"USB\", \"NUSB3\", \"IUSB3\"};\n \tSP_DEVINFO_DATA dev_info_data = { 0 };\n \tSP_DEVICE_INTERFACE_DETAIL_DATA_A *dev_interface_details = NULL;\n\tGUID hid_guid;\n #define MAX_ENUM_GUIDS 64\n \tconst GUID* guid[MAX_ENUM_GUIDS];\n #define HCD_PASS 0\n #define HUB_PASS 1\n #define GEN_PASS 2\n #define DEV_PASS 3\n#define HID_PASS 4\n \tint r = LIBUSB_SUCCESS;\n \tint api, sub_api;\n \tsize_t class_index = 0;\n\tunsigned int nb_guids, pass, i, j, ancestor;\n\tchar path[MAX_PATH_LENGTH];\n\tchar strbuf[MAX_PATH_LENGTH];\n\tstruct libusb_device *dev, *parent_dev;\n\tstruct windows_device_priv *priv, *parent_priv;\n\tchar* dev_interface_path = NULL;\n\tchar* dev_id_path = NULL;\n\tunsigned long session_id;\n\tDWORD size, reg_type, port_nr, install_state;\n\tHKEY key;\n\tWCHAR guid_string_w[MAX_GUID_STRING_LENGTH];\n\tGUID* if_guid;\n\tLONG s;\n\tlibusb_device** unref_list;\n\tunsigned int unref_size = 64;\n\tunsigned int unref_cur = 0;\n\n \n \tguid[HCD_PASS] = &GUID_DEVINTERFACE_USB_HOST_CONTROLLER;\n \tguid[HUB_PASS] = &GUID_DEVINTERFACE_USB_HUB;\n \tguid[GEN_PASS] = NULL;\n \tguid[DEV_PASS] = &GUID_DEVINTERFACE_USB_DEVICE;\n\tHidD_GetHidGuid(&hid_guid);\n\tguid[HID_PASS] = &hid_guid;\n\tnb_guids = HID_PASS+1;\n \n \tunref_list = (libusb_device**) calloc(unref_size, sizeof(libusb_device*));\n \tif (unref_list == NULL) {\n\t\treturn LIBUSB_ERROR_NO_MEM;\n\t}\n\n \tfor (pass = 0; ((pass < nb_guids) && (r == LIBUSB_SUCCESS)); pass++) {\n #ifdef ENUM_DEBUG\n\t\tconst char *passname[] = { \"HCD\", \"HUB\", \"GEN\", \"DEV\", \"HID\", \"EXT\" };\n\t\tusbi_dbg(\"\\n#### PROCESSING %ss %s\", passname[(pass<=HID_PASS)?pass:HID_PASS+1],\n \t\t\t(pass!=GEN_PASS)?guid_to_string(guid[pass]):\"\");\n #endif\n \t\tfor (i = 0; ; i++) {\n\t\t\tsafe_free(dev_interface_details);\n\t\t\tsafe_free(dev_interface_path);\n\t\t\tsafe_free(dev_id_path);\n\t\t\tpriv = parent_priv = NULL;\n\t\t\tdev = parent_dev = NULL;\n\n\t\t\tif (r != LIBUSB_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((pass == HCD_PASS) && (i == UINT8_MAX)) {\n\t\t\t\tusbi_warn(ctx, \"program assertion failed - found more than %d buses, skipping the rest.\", UINT8_MAX);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pass != GEN_PASS) {\n\t\t\t\tdev_interface_details = get_interface_details(ctx, &dev_info, &dev_info_data, guid[pass], i);\n\t\t\t\tif (dev_interface_details == NULL) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdev_interface_path = sanitize_path(dev_interface_details->DevicePath);\n\t\t\t\t\tif (dev_interface_path == NULL) {\n\t\t\t\t\t\tusbi_warn(ctx, \"could not sanitize device interface path for '%s'\", dev_interface_details->DevicePath);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (; class_index < ARRAYSIZE(usb_class); class_index++) {\n\t\t\t\t\tif (get_devinfo_data(ctx, &dev_info, &dev_info_data, usb_class[class_index], i))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ti = 0;\n\t\t\t\t}\n\t\t\t\tif (class_index >= ARRAYSIZE(usb_class))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (CM_Get_Device_IDA(dev_info_data.DevInst, path, sizeof(path), 0) != CR_SUCCESS) {\n\t\t\t\tusbi_warn(ctx, \"could not read the device id path for devinst %X, skipping\",\n\t\t\t\t\tdev_info_data.DevInst);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdev_id_path = sanitize_path(path);\n\t\t\tif (dev_id_path == NULL) {\n\t\t\t\tusbi_warn(ctx, \"could not sanitize device id path for devinst %X, skipping\",\n\t\t\t\t\tdev_info_data.DevInst);\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef ENUM_DEBUG\n\t\t\tusbi_dbg(\"PRO: %s\", dev_id_path);\n#endif\n\n\t\t\tport_nr = 0;\n\t\t\tif ((pass >= HUB_PASS) && (pass <= GEN_PASS)) {\n\t\t\t\tif ( (!pSetupDiGetDeviceRegistryPropertyA(dev_info, &dev_info_data, SPDRP_ADDRESS,\n\t\t\t\t\t&reg_type, (BYTE*)&port_nr, 4, &size))\n\t\t\t\t  || (size != 4) ) {\n\t\t\t\t\tusbi_warn(ctx, \"could not retrieve port number for device '%s', skipping: %s\",\n\t\t\t\t\t\tdev_id_path, windows_error_str(0));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tapi = USB_API_UNSUPPORTED;\n\t\t\tsub_api = SUB_API_NOTSET;\n\t\t\tswitch (pass) {\n\t\t\tcase HCD_PASS:\n\t\t\t\tbreak;\n\t\t\tcase GEN_PASS:\n\t\t\t\tsize = sizeof(strbuf);\n\t\t\t\tif (!pSetupDiGetDeviceRegistryPropertyA(dev_info, &dev_info_data, SPDRP_DRIVER,\n\t\t\t\t\t&reg_type, (BYTE*)strbuf, size, &size)) {\n\t\t\t\t\t\tusbi_info(ctx, \"The following device has no driver: '%s'\", dev_id_path);\n\t\t\t\t\t\tusbi_info(ctx, \"libusbx will not be able to access it.\");\n\t\t\t\t}\n\t\t\t\tkey = pSetupDiOpenDevRegKey(dev_info, &dev_info_data, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);\n\t\t\t\tif (key != INVALID_HANDLE_VALUE) {\n\t\t\t\t\tsize = sizeof(guid_string_w);\n\t\t\t\t\ts = pRegQueryValueExW(key, L\"DeviceInterfaceGUIDs\", NULL, &reg_type,\n\t\t\t\t\t\t(BYTE*)guid_string_w, &size);\n\t\t\t\t\tpRegCloseKey(key);\n\t\t\t\t\tif (s == ERROR_SUCCESS) {\n\t\t\t\t\t\tif (nb_guids >= MAX_ENUM_GUIDS) {\n\t\t\t\t\t\t\tusbi_err(ctx, \"program assertion failed: too many GUIDs\");\n\t\t\t\t\t\t\tLOOP_BREAK(LIBUSB_ERROR_OVERFLOW);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif_guid = (GUID*) calloc(1, sizeof(GUID));\n\t\t\t\t\t\tpCLSIDFromString(guid_string_w, if_guid);\n\t\t\t\t\t\tguid[nb_guids++] = if_guid;\n\t\t\t\t\t\tusbi_dbg(\"extra GUID: %s\", guid_to_string(if_guid));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n\t\t\tcase HID_PASS:\n\t\t\t\tapi = USB_API_HID;\n\t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tif ( (!pSetupDiGetDeviceRegistryPropertyA(dev_info, &dev_info_data, SPDRP_INSTALL_STATE,\n\t\t\t\t\t&reg_type, (BYTE*)&install_state, 4, &size))\n\t\t\t\t  || (size != 4) ){\n\t\t\t\t\tusbi_warn(ctx, \"could not detect installation state of driver for '%s': %s\",\n\t\t\t\t\t\tdev_id_path, windows_error_str(0));\n\t\t\t\t} else if (install_state != 0) {\n\t\t\t\t\tusbi_warn(ctx, \"driver for device '%s' is reporting an issue (code: %d) - skipping\",\n\t\t\t\t\t\tdev_id_path, install_state);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tget_api_type(ctx, &dev_info, &dev_info_data, &api, &sub_api);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (pass) {\n\t\t\tcase HCD_PASS:\n\t\t\tcase DEV_PASS:\n\t\t\tcase HUB_PASS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tparent_dev = NULL;\n\t\t\t\tfor (ancestor = 1; parent_dev == NULL; ancestor++) {\n\t\t\t\t\tsession_id = get_ancestor_session_id(dev_info_data.DevInst, ancestor);\n\t\t\t\t\tif (session_id == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tparent_dev = usbi_get_device_by_session_id(ctx, session_id);\n\t\t\t\t}\n\t\t\t\tif (parent_dev == NULL) {\n\t\t\t\t\tusbi_dbg(\"unlisted ancestor for '%s' (non USB HID, newly connected, etc.) - ignoring\", dev_id_path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tparent_priv = _device_priv(parent_dev);\n\t\t\t\tif ( (pass == GEN_PASS) && (parent_priv->apib->id != USB_API_HUB) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pass <= DEV_PASS) {\t\n\t\t\t\tsession_id = htab_hash(dev_id_path);\n\t\t\t\tdev = usbi_get_device_by_session_id(ctx, session_id);\n\t\t\t\tif (dev == NULL) {\n\t\t\t\t\tif (pass == DEV_PASS) {\n\t\t\t\t\t\tusbi_warn(ctx, \"'%s' was only detected in late pass (newly connected device?)\"\n\t\t\t\t\t\t\t\" - ignoring\", dev_id_path);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tusbi_dbg(\"allocating new device for session [%X]\", session_id);\n\t\t\t\t\tif ((dev = usbi_alloc_device(ctx, session_id)) == NULL) {\n\t\t\t\t\t\tLOOP_BREAK(LIBUSB_ERROR_NO_MEM);\n\t\t\t\t\t}\n\t\t\t\t\twindows_device_priv_init(dev);\n\t\t\t\t\tunref_list[unref_cur++] = dev;\n\t\t\t\t\tif (unref_cur >= unref_size) {\n\t\t\t\t\t\tunref_size += 64;\n\t\t\t\t\t\tunref_list = usbi_reallocf(unref_list, unref_size*sizeof(libusb_device*));\n\t\t\t\t\t\tif (unref_list == NULL) {\n\t\t\t\t\t\t\tusbi_err(ctx, \"could not realloc list for unref - aborting.\");\n\t\t\t\t\t\t\tLOOP_BREAK(LIBUSB_ERROR_NO_MEM);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tusbi_dbg(\"found existing device for session [%X] (%d.%d)\",\n\t\t\t\t\t\tsession_id, dev->bus_number, dev->device_address);\n\t\t\t\t}\n\t\t\t\tpriv = _device_priv(dev);\n\t\t\t}\n\n\t\t\tswitch (pass) {\n\t\t\tcase HCD_PASS:\n\t\t\t\tdev->bus_number = (uint8_t)(i + 1);\t\n\t\t\t\tdev->device_address = 0;\n\t\t\t\tdev->num_configurations = 0;\n\t\t\t\tpriv->apib = &usb_api_backend[USB_API_HUB];\n\t\t\t\tpriv->sub_api = SUB_API_NOTSET;\n\t\t\t\tpriv->depth = UINT8_MAX;\t\n\t\t\t\tpriv->path = dev_interface_path; dev_interface_path = NULL;\n\t\t\t\tbreak;\n\t\t\tcase HUB_PASS:\n\t\t\tcase DEV_PASS:\n\t\t\t\tif (priv->path != NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tpriv->path = dev_interface_path; dev_interface_path = NULL;\n\t\t\t\tpriv->apib = &usb_api_backend[api];\n\t\t\t\tpriv->sub_api = sub_api;\n\t\t\t\tswitch(api) {\n \t\t\t\tcase USB_API_COMPOSITE:\n \t\t\t\tcase USB_API_HUB:\n \t\t\t\t\tbreak;\n\t\t\t\tcase USB_API_HID:\n\t\t\t\t\tpriv->hid = calloc(1, sizeof(struct hid_device_priv));\n\t\t\t\t\tif (priv->hid == NULL) {\n\t\t\t\t\t\tLOOP_BREAK(LIBUSB_ERROR_NO_MEM);\n\t\t\t\t\t}\n\t\t\t\t\tpriv->hid->nb_interfaces = 0;\n\t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tpriv->usb_interface[0].path = (char*) calloc(safe_strlen(priv->path)+1, 1);\n\t\t\t\t\tif (priv->usb_interface[0].path != NULL) {\n\t\t\t\t\t\tsafe_strcpy(priv->usb_interface[0].path, safe_strlen(priv->path)+1, priv->path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusbi_warn(ctx, \"could not duplicate interface path '%s'\", priv->path);\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=0; j<USB_MAXINTERFACES; j++) {\n\t\t\t\t\t\tpriv->usb_interface[j].apib = &usb_api_backend[api];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GEN_PASS:\n\t\t\t\tr = init_device(dev, parent_dev, (uint8_t)port_nr, dev_id_path, dev_info_data.DevInst);\n\t\t\t\tif (r == LIBUSB_SUCCESS) {\n\t\t\t\t\tdiscdevs = discovered_devs_append(*_discdevs, dev);\n\t\t\t\t\tif (!discdevs) {\n\t\t\t\t\t\tLOOP_BREAK(LIBUSB_ERROR_NO_MEM);\n\t\t\t\t\t}\n\t\t\t\t\t*_discdevs = discdevs;\n\t\t\t\t} else if (r == LIBUSB_ERROR_NO_DEVICE) {\n \t\t\t\t\tr = LIBUSB_SUCCESS;\n \t\t\t\t}\n \t\t\t\tbreak;\n\t\t\tdefault:\t\n\t\t\t\tif (parent_priv->apib->id == USB_API_HID) {\n\t\t\t\t\tusbi_dbg(\"setting HID interface for [%lX]:\", parent_dev->session_data);\n\t\t\t\t\tr = set_hid_interface(ctx, parent_dev, dev_interface_path);\n\t\t\t\t\tif (r != LIBUSB_SUCCESS) LOOP_BREAK(r);\n\t\t\t\t\tdev_interface_path = NULL;\n\t\t\t\t} else if (parent_priv->apib->id == USB_API_COMPOSITE) {\n \t\t\t\t\tusbi_dbg(\"setting composite interface for [%lX]:\", parent_dev->session_data);\n \t\t\t\t\tswitch (set_composite_interface(ctx, parent_dev, dev_interface_path, dev_id_path, api, sub_api)) {\n \t\t\t\t\tcase LIBUSB_SUCCESS:\n\t\t\t\t\t\tdev_interface_path = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LIBUSB_ERROR_ACCESS:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tLOOP_BREAK(r);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n \t}\n \n\tfor (pass = HID_PASS+1; pass < nb_guids; pass++) {\n \t\tsafe_free(guid[pass]);\n \t}\n \n\tfor (i=0; i<unref_cur; i++) {\n\t\tsafe_unref_device(unref_list[i]);\n\t}\n\tsafe_free(unref_list);\n\n\treturn r;\n}\n", "target": 1, "flaw_line_index": "8,15,42,43,50,51,52,62,63,171,172,173,276,277,278,279,280,281,282"}
{"idx": 187238, "func": "static int set_hid_interface(struct libusb_context* ctx, struct libusb_device* dev,\n\t\t\t\t\t\t\tchar* dev_interface_path)\n{\n\tint i;\n\tstruct windows_device_priv *priv = _device_priv(dev);\n\tif (priv->hid == NULL) {\n\t\tusbi_err(ctx, \"program assertion failed: parent is not HID\");\n\t\treturn LIBUSB_ERROR_NO_DEVICE;\n\t}\n\tif (priv->hid->nb_interfaces == USB_MAXINTERFACES) {\n\t\tusbi_err(ctx, \"program assertion failed: max USB interfaces reached for HID device\");\n\t\treturn LIBUSB_ERROR_NO_DEVICE;\n\t}\n\tfor (i=0; i<priv->hid->nb_interfaces; i++) {\n\t\tif (safe_strcmp(priv->usb_interface[i].path, dev_interface_path) == 0) {\n\t\t\tusbi_dbg(\"interface[%d] already set to %s\", i, dev_interface_path);\n\t\t\treturn LIBUSB_SUCCESS;\n\t\t}\n\t}\n \n\tpriv->usb_interface[priv->hid->nb_interfaces].path = dev_interface_path;\n\tpriv->usb_interface[priv->hid->nb_interfaces].apib = &usb_api_backend[USB_API_HID];\n\tusbi_dbg(\"interface[%d] = %s\", priv->hid->nb_interfaces, dev_interface_path);\n\tpriv->hid->nb_interfaces++;\n \treturn LIBUSB_SUCCESS;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,21,22,23,24"}
{"idx": 7560, "func": "static bool blit_region_is_unsafe(struct CirrusVGAState *s,\n                                  int32_t pitch, int32_t addr)\n{\n    if (pitch < 0) {\n        int64_t min = addr\n            + ((int64_t)s->cirrus_blt_height-1) * pitch;\n        int32_t max = addr\n            + s->cirrus_blt_width;\n        if (min < 0 || max >= s->vga.vram_size) {\n            return true;\n        }\n    } else {\n        int64_t max = addr\n            + ((int64_t)s->cirrus_blt_height-1) * pitch\n            + s->cirrus_blt_width;\n        if (max >= s->vga.vram_size) {\n            return true;\n        }\n    }\n    return false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7634, "func": "static int proxy_lremovexattr(FsContext *ctx, V9fsPath *fs_path,\n                              const char *name)\n{\n    int retval;\n    V9fsString xname;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n    retval = v9fs_request(ctx->private, T_LREMOVEXATTR, NULL, fs_path, &xname);\n    v9fs_string_free(&xname);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187053, "func": " void ImageBitmapFactories::ImageBitmapLoader::RejectPromise(\n    ImageBitmapRejectionReason reason) {\n  switch (reason) {\n    case kUndecodableImageBitmapRejectionReason:\n      resolver_->Reject(\n          DOMException::Create(DOMExceptionCode::kInvalidStateError,\n                               \"The source image could not be decoded.\"));\n      break;\n    case kAllocationFailureImageBitmapRejectionReason:\n      resolver_->Reject(\n          DOMException::Create(DOMExceptionCode::kInvalidStateError,\n                               \"The ImageBitmap could not be allocated.\"));\n      break;\n     default:\n       NOTREACHED();\n   }\n   factory_->DidFinishLoading(this);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186753, "func": " Response StorageHandler::TrackCacheStorageForOrigin(const std::string& origin) {\n  if (!process_)\n     return Response::InternalError();\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid())\n    return Response::InvalidParams(origin + \" is not a valid URL\");\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::BindOnce(&CacheStorageObserver::TrackOriginOnIOThread,\n                     base::Unretained(GetCacheStorageObserver()),\n                     url::Origin::Create(origin_url)));\n  return Response::OK();\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186414, "func": "BluetoothDeviceChooserController::~BluetoothDeviceChooserController() {\n  if (scanning_start_time_) {\n    RecordScanningDuration(base::TimeTicks::Now() -\n                           scanning_start_time_.value());\n  }\n \n   if (chooser_) {\n     DCHECK(!error_callback_.is_null());\n    error_callback_.Run(blink::mojom::WebBluetoothResult::CHOOSER_CANCELLED);\n   }\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8119, "func": "void Gfx::opEOFill(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    return;\n  }\n  if (state->isPath() && !contentIsHidden()) {\n    if (state->getFillColorSpace()->getMode() == csPattern) {\n      doPatternFill(gTrue);\n    } else {\n      out->eoFill(state);\n    }\n  }\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187303, "func": "bool SiteInstanceImpl::DoesSiteRequireDedicatedProcess(\n    BrowserContext* browser_context,\n    const GURL& url) {\n   if (SiteIsolationPolicy::UseDedicatedProcessesForAllSites())\n     return true;\n \n  if (url.SchemeIs(kChromeErrorScheme))\n     return true;\n \n  GURL site_url = SiteInstance::GetSiteForURL(browser_context, url);\n  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();\n  if (policy->IsIsolatedOrigin(url::Origin::Create(site_url)))\n     return true;\n \n  if (GetContentClient()->browser()->DoesSiteRequireDedicatedProcess(\n          browser_context, site_url)) {\n    return true;\n  }\n\n  return false;\n}\n", "target": 1, "flaw_line_index": "11,14,15,16,17"}
{"idx": 7866, "func": "static int ram_load(QEMUFile *f, void *opaque, int version_id)\n{\n    int flags = 0, ret = 0;\n    static uint64_t seq_iter;\n\n    seq_iter++;\n\n    if (version_id != 4) {\n        ret = -EINVAL;\n    }\n\n    while (!ret && !(flags & RAM_SAVE_FLAG_EOS)) {\n        ram_addr_t addr, total_ram_bytes;\n        void *host;\n        uint8_t ch;\n\n        addr = qemu_get_be64(f);\n        flags = addr & ~TARGET_PAGE_MASK;\n        addr &= TARGET_PAGE_MASK;\n\n        switch (flags & ~RAM_SAVE_FLAG_CONTINUE) {\n        case RAM_SAVE_FLAG_MEM_SIZE:\n            total_ram_bytes = addr;\n            while (!ret && total_ram_bytes) {\n                RAMBlock *block;\n                uint8_t len;\n                char id[256];\n                ram_addr_t length;\n\n                len = qemu_get_byte(f);\n                qemu_get_buffer(f, (uint8_t *)id, len);\n                id[len] = 0;\n                length = qemu_get_be64(f);\n\n                QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n                    if (!strncmp(id, block->idstr, sizeof(id))) {\n                        if (block->length != length) {\n                            error_report(\"Length mismatch: %s: 0x\" RAM_ADDR_FMT\n                                         \" in != 0x\" RAM_ADDR_FMT, id, length,\n                                         block->length);\n                            ret =  -EINVAL;\n                        }\n                        break;\n                    }\n                }\n\n                if (!block) {\n                    error_report(\"Unknown ramblock \\\"%s\\\", cannot \"\n                                 \"accept migration\", id);\n                    ret = -EINVAL;\n                }\n\n                total_ram_bytes -= length;\n            }\n            break;\n        case RAM_SAVE_FLAG_COMPRESS:\n            host = host_from_stream_offset(f, addr, flags);\n            if (!host) {\n                error_report(\"Illegal RAM offset \" RAM_ADDR_FMT, addr);\n                ret = -EINVAL;\n                break;\n            }\n\n            ch = qemu_get_byte(f);\n            ram_handle_compressed(host, ch, TARGET_PAGE_SIZE);\n            break;\n        case RAM_SAVE_FLAG_PAGE:\n            host = host_from_stream_offset(f, addr, flags);\n            if (!host) {\n                error_report(\"Illegal RAM offset \" RAM_ADDR_FMT, addr);\n                ret = -EINVAL;\n                break;\n            }\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n            break;\n        case RAM_SAVE_FLAG_XBZRLE:\n            host = host_from_stream_offset(f, addr, flags);\n            if (!host) {\n                error_report(\"Illegal RAM offset \" RAM_ADDR_FMT, addr);\n                ret = -EINVAL;\n                break;\n            }\n\n            if (load_xbzrle(f, addr, host) < 0) {\n                error_report(\"Failed to decompress XBZRLE page at \"\n                             RAM_ADDR_FMT, addr);\n                ret = -EINVAL;\n                break;\n            }\n            break;\n        case RAM_SAVE_FLAG_EOS:\n            break;\n        default:\n            if (flags & RAM_SAVE_FLAG_HOOK) {\n                ram_control_load_hook(f, flags);\n            } else {\n                error_report(\"Unknown combination of migration flags: %#x\",\n                             flags);\n                ret = -EINVAL;\n            }\n        }\n        if (!ret) {\n            ret = qemu_file_get_error(f);\n        }\n    }\n\n    DPRINTF(\"Completed load of VM with exit code %d seq iteration \"\n            \"%\" PRIu64 \"\\n\", ret, seq_iter);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7415, "func": "ZEND_API void zend_ts_hash_clean(TsHashTable *ht)\n{\n\tht->reader = 0;\n\tbegin_write(ht);\n\tzend_hash_clean(TS_HASH(ht));\n\tend_write(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186431, "func": "std::string SanitizeRemoteFrontendURL(const std::string& value) {\n  GURL url(net::UnescapeURLComponent(value,\n      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |\n      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |\n      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE));\n  std::string path = url.path();\n  std::vector<std::string> parts = base::SplitString(\n      path, \"/\", base::KEEP_WHITESPACE, base::SPLIT_WANT_ALL);\n  std::string revision = parts.size() > 2 ? parts[2] : \"\";\n  revision = SanitizeRevision(revision);\n  std::string filename = parts.size() ? parts[parts.size() - 1] : \"\";\n  if (filename != \"devtools.html\")\n    filename = \"inspector.html\";\n  path = base::StringPrintf(\"/serve_rev/%s/%s\",\n                            revision.c_str(), filename.c_str());\n  std::string sanitized = SanitizeFrontendURL(url, url::kHttpsScheme,\n      kRemoteFrontendDomain, path, true).spec();\n  return net::EscapeQueryParamValue(sanitized, false);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19"}
{"idx": 187210, "func": "static int _hid_class_request(struct hid_device_priv* dev, HANDLE hid_handle, int request_type,\n\t\t\t\t\t\t\t  int request, int value, int _index, void *data, struct windows_transfer_priv *tp,\n\t\t\t\t\t\t\t  size_t *size, OVERLAPPED* overlapped)\n{\n\tint report_type = (value >> 8) & 0xFF;\n\tint report_id = value & 0xFF;\n\tif ( (LIBUSB_REQ_RECIPIENT(request_type) != LIBUSB_RECIPIENT_INTERFACE)\n\t  && (LIBUSB_REQ_RECIPIENT(request_type) != LIBUSB_RECIPIENT_DEVICE) )\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\tif (LIBUSB_REQ_OUT(request_type) && request == HID_REQ_SET_REPORT)\n\t\treturn _hid_set_report(dev, hid_handle, report_id, data, tp, size, overlapped, report_type);\n\tif (LIBUSB_REQ_IN(request_type) && request == HID_REQ_GET_REPORT)\n\t\treturn _hid_get_report(dev, hid_handle, report_id, data, tp, size, overlapped, report_type);\n\treturn LIBUSB_ERROR_INVALID_PARAM;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15"}
{"idx": 7578, "func": "static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n{\n    int sx = 0, sy = 0;\n    int dx = 0, dy = 0;\n    int depth = 0;\n    int notify = 0;\n\n    if (*s->cirrus_rop == cirrus_bitblt_rop_fwd_src ||\n        *s->cirrus_rop == cirrus_bitblt_rop_bkwd_src) {\n\n        int width, height;\n\n        depth = s->vga.get_bpp(&s->vga) / 8;\n        s->vga.get_resolution(&s->vga, &width, &height);\n\n        sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;\n        sy = (src / ABS(s->cirrus_blt_srcpitch));\n        dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;\n        dy = (dst / ABS(s->cirrus_blt_dstpitch));\n\n        w /= depth;\n\n        if (s->cirrus_blt_dstpitch < 0) {\n            sx -= (s->cirrus_blt_width / depth) - 1;\n            dx -= (s->cirrus_blt_width / depth) - 1;\n            sy -= s->cirrus_blt_height - 1;\n            dy -= s->cirrus_blt_height - 1;\n        }\n\n        if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n            (sx + w) <= width && (sy + h) <= height &&\n            (dx + w) <= width && (dy + h) <= height) {\n            notify = 1;\n        }\n    }\n\n    if (notify)\n        graphic_hw_update(s->vga.con);\n\n    (*s->cirrus_rop) (s, s->vga.vram_ptr +\n\t\t      (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t      s->vga.vram_ptr +\n\t\t      (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    if (notify) {\n        qemu_console_copy(s->vga.con,\n\t\t\t  sx, sy, dx, dy,\n\t\t\t  s->cirrus_blt_width / depth,\n\t\t\t  s->cirrus_blt_height);\n    }\n\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\ts->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\ts->cirrus_blt_height);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186503, "func": " error::Error GLES2DecoderPassthroughImpl::DoLinkProgram(GLuint program) {\n   TRACE_EVENT0(\"gpu\", \"GLES2DecoderPassthroughImpl::DoLinkProgram\");\n   SCOPED_UMA_HISTOGRAM_TIMER(\"GPU.PassthroughDoLinkProgramTime\");\n  api()->glLinkProgramFn(GetProgramServiceID(program, resources_));\n \n   ExitCommandProcessingEarly();\n \n   return error::kNoError;\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186474, "func": "static sk_sp<SkImage> scaleSkImage(sk_sp<SkImage> skImage,\n                                   unsigned resizeWidth,\n                                   unsigned resizeHeight,\n                                   SkFilterQuality resizeQuality) {\n  SkImageInfo resizedInfo = SkImageInfo::Make(\n      resizeWidth, resizeHeight, kN32_SkColorType, kUnpremul_SkAlphaType);\n  RefPtr<ArrayBuffer> dstBuffer = ArrayBuffer::createOrNull(\n      resizeWidth * resizeHeight, resizedInfo.bytesPerPixel());\n  if (!dstBuffer)\n    return nullptr;\n  RefPtr<Uint8Array> resizedPixels =\n       Uint8Array::create(dstBuffer, 0, dstBuffer->byteLength());\n   SkPixmap pixmap(\n       resizedInfo, resizedPixels->data(),\n      static_cast<size_t>(resizeWidth) * resizedInfo.bytesPerPixel());\n   skImage->scalePixels(pixmap, resizeQuality);\n   return SkImage::MakeFromRaster(pixmap,\n                                  [](const void*, void* pixels) {\n                                   static_cast<Uint8Array*>(pixels)->deref();\n                                 },\n                                 resizedPixels.release().leakRef());\n}\n", "target": 1, "flaw_line_index": "15"}
{"idx": 186909, "func": "bool NavigationControllerImpl::RendererDidNavigate(\n    RenderFrameHostImpl* rfh,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,\n    LoadCommittedDetails* details,\n    bool is_navigation_within_page,\n    NavigationHandleImpl* navigation_handle) {\n  is_initial_navigation_ = false;\n\n  bool overriding_user_agent_changed = false;\n  if (GetLastCommittedEntry()) {\n    details->previous_url = GetLastCommittedEntry()->GetURL();\n    details->previous_entry_index = GetLastCommittedEntryIndex();\n    if (pending_entry_ &&\n        pending_entry_->GetIsOverridingUserAgent() !=\n            GetLastCommittedEntry()->GetIsOverridingUserAgent())\n      overriding_user_agent_changed = true;\n  } else {\n    details->previous_url = GURL();\n    details->previous_entry_index = -1;\n  }\n\n  bool was_restored = false;\n  DCHECK(pending_entry_index_ == -1 || pending_entry_->site_instance() ||\n         pending_entry_->restore_type() != RestoreType::NONE);\n  if (pending_entry_ && pending_entry_->restore_type() != RestoreType::NONE) {\n    pending_entry_->set_restore_type(RestoreType::NONE);\n    was_restored = true;\n  }\n\n  details->did_replace_entry = params.should_replace_current_entry;\n\n  details->type = ClassifyNavigation(rfh, params);\n\n  details->is_same_document = is_navigation_within_page;\n\n  if (PendingEntryMatchesHandle(navigation_handle)) {\n    if (pending_entry_->reload_type() != ReloadType::NONE) {\n      last_committed_reload_type_ = pending_entry_->reload_type();\n      last_committed_reload_time_ =\n          time_smoother_.GetSmoothedTime(get_timestamp_callback_.Run());\n    } else if (!pending_entry_->is_renderer_initiated() ||\n               params.gesture == NavigationGestureUser) {\n      last_committed_reload_type_ = ReloadType::NONE;\n      last_committed_reload_time_ = base::Time();\n    }\n  }\n\n  switch (details->type) {\n    case NAVIGATION_TYPE_NEW_PAGE:\n      RendererDidNavigateToNewPage(rfh, params, details->is_same_document,\n                                   details->did_replace_entry,\n                                   navigation_handle);\n      break;\n    case NAVIGATION_TYPE_EXISTING_PAGE:\n      details->did_replace_entry = details->is_same_document;\n      RendererDidNavigateToExistingPage(rfh, params, details->is_same_document,\n                                        was_restored, navigation_handle);\n      break;\n    case NAVIGATION_TYPE_SAME_PAGE:\n      RendererDidNavigateToSamePage(rfh, params, navigation_handle);\n      break;\n    case NAVIGATION_TYPE_NEW_SUBFRAME:\n      RendererDidNavigateNewSubframe(rfh, params, details->is_same_document,\n                                     details->did_replace_entry);\n      break;\n    case NAVIGATION_TYPE_AUTO_SUBFRAME:\n      if (!RendererDidNavigateAutoSubframe(rfh, params)) {\n        NotifyEntryChanged(GetLastCommittedEntry());\n        return false;\n      }\n      break;\n    case NAVIGATION_TYPE_NAV_IGNORE:\n      if (pending_entry_) {\n        DiscardNonCommittedEntries();\n        delegate_->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n      }\n      return false;\n    default:\n      NOTREACHED();\n  }\n\n  base::Time timestamp =\n      time_smoother_.GetSmoothedTime(get_timestamp_callback_.Run());\n  DVLOG(1) << \"Navigation finished at (smoothed) timestamp \"\n           << timestamp.ToInternalValue();\n\n  DiscardNonCommittedEntriesInternal();\n\n  DCHECK(params.page_state.IsValid()) << \"Shouldn't see an empty PageState.\";\n  NavigationEntryImpl* active_entry = GetLastCommittedEntry();\n  active_entry->SetTimestamp(timestamp);\n  active_entry->SetHttpStatusCode(params.http_status_code);\n\n  FrameNavigationEntry* frame_entry =\n      active_entry->GetFrameEntry(rfh->frame_tree_node());\n  if (frame_entry && frame_entry->site_instance() != rfh->GetSiteInstance())\n    frame_entry = nullptr;\n  if (frame_entry) {\n     DCHECK(params.page_state == frame_entry->page_state());\n   }\n \n  if (!rfh->GetParent() &&\n      IsBlockedNavigation(navigation_handle->GetNetErrorCode())) {\n    DCHECK(params.url_is_unreachable);\n    active_entry->SetURL(GURL(url::kAboutBlankURL));\n    active_entry->SetVirtualURL(params.url);\n    if (frame_entry) {\n      frame_entry->SetPageState(\n          PageState::CreateFromURL(active_entry->GetURL()));\n    }\n  }\n   size_t redirect_chain_size = 0;\n  for (size_t i = 0; i < params.redirects.size(); ++i) {\n    redirect_chain_size += params.redirects[i].spec().length();\n  }\n  UMA_HISTOGRAM_COUNTS(\"Navigation.RedirectChainSize\", redirect_chain_size);\n\n  active_entry->ResetForCommit(frame_entry);\n\n  if (!rfh->GetParent())\n    CHECK_EQ(active_entry->site_instance(), rfh->GetSiteInstance());\n\n  active_entry->SetBindings(rfh->GetEnabledBindings());\n\n  details->entry = active_entry;\n  details->is_main_frame = !rfh->GetParent();\n  details->http_status_code = params.http_status_code;\n\n  NotifyNavigationEntryCommitted(details);\n\n  if (active_entry->GetURL().SchemeIs(url::kHttpsScheme) && !rfh->GetParent() &&\n      navigation_handle->GetNetErrorCode() == net::OK) {\n    UMA_HISTOGRAM_BOOLEAN(\"Navigation.SecureSchemeHasSSLStatus\",\n                          !!active_entry->GetSSL().certificate);\n  }\n\n  if (overriding_user_agent_changed)\n    delegate_->UpdateOverridingUserAgent();\n\n  int nav_entry_id = active_entry->GetUniqueID();\n  for (FrameTreeNode* node : delegate_->GetFrameTree()->Nodes())\n    node->current_frame_host()->set_nav_entry_id(nav_entry_id);\n  return true;\n}\n", "target": 1, "flaw_line_index": "132,133,134,135,136,137,138,139,140,141,142,143,144,145"}
{"idx": 186786, "func": "bool VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::SubmitDecode(\n    const scoped_refptr<VP8Picture>& pic,\n    const Vp8FrameHeader* frame_hdr,\n     const scoped_refptr<VP8Picture>& last_frame,\n     const scoped_refptr<VP8Picture>& golden_frame,\n     const scoped_refptr<VP8Picture>& alt_frame) {\n   VAIQMatrixBufferVP8 iq_matrix_buf;\n   memset(&iq_matrix_buf, 0, sizeof(VAIQMatrixBufferVP8));\n \n  const Vp8SegmentationHeader& sgmnt_hdr = frame_hdr->segmentation_hdr;\n  const Vp8QuantizationHeader& quant_hdr = frame_hdr->quantization_hdr;\n  static_assert(arraysize(iq_matrix_buf.quantization_index) == kMaxMBSegments,\n                \"incorrect quantization matrix size\");\n  for (size_t i = 0; i < kMaxMBSegments; ++i) {\n    int q = quant_hdr.y_ac_qi;\n\n    if (sgmnt_hdr.segmentation_enabled) {\n      if (sgmnt_hdr.segment_feature_mode ==\n          Vp8SegmentationHeader::FEATURE_MODE_ABSOLUTE)\n        q = sgmnt_hdr.quantizer_update_value[i];\n      else\n        q += sgmnt_hdr.quantizer_update_value[i];\n    }\n\n#define CLAMP_Q(q) std::min(std::max(q, 0), 127)\n    static_assert(arraysize(iq_matrix_buf.quantization_index[i]) == 6,\n                  \"incorrect quantization matrix size\");\n    iq_matrix_buf.quantization_index[i][0] = CLAMP_Q(q);\n    iq_matrix_buf.quantization_index[i][1] = CLAMP_Q(q + quant_hdr.y_dc_delta);\n    iq_matrix_buf.quantization_index[i][2] = CLAMP_Q(q + quant_hdr.y2_dc_delta);\n    iq_matrix_buf.quantization_index[i][3] = CLAMP_Q(q + quant_hdr.y2_ac_delta);\n    iq_matrix_buf.quantization_index[i][4] = CLAMP_Q(q + quant_hdr.uv_dc_delta);\n    iq_matrix_buf.quantization_index[i][5] = CLAMP_Q(q + quant_hdr.uv_ac_delta);\n#undef CLAMP_Q\n  }\n\n  if (!vaapi_wrapper_->SubmitBuffer(\n          VAIQMatrixBufferType, sizeof(VAIQMatrixBufferVP8), &iq_matrix_buf))\n    return false;\n\n  VAProbabilityDataBufferVP8 prob_buf;\n  memset(&prob_buf, 0, sizeof(VAProbabilityDataBufferVP8));\n\n  const Vp8EntropyHeader& entr_hdr = frame_hdr->entropy_hdr;\n  ARRAY_MEMCPY_CHECKED(prob_buf.dct_coeff_probs, entr_hdr.coeff_probs);\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAProbabilityBufferType,\n                                    sizeof(VAProbabilityDataBufferVP8),\n                                    &prob_buf))\n    return false;\n\n  VAPictureParameterBufferVP8 pic_param;\n  memset(&pic_param, 0, sizeof(VAPictureParameterBufferVP8));\n  pic_param.frame_width = frame_hdr->width;\n  pic_param.frame_height = frame_hdr->height;\n\n  if (last_frame) {\n    scoped_refptr<VaapiDecodeSurface> last_frame_surface =\n        VP8PictureToVaapiDecodeSurface(last_frame);\n    pic_param.last_ref_frame = last_frame_surface->va_surface()->id();\n  } else {\n    pic_param.last_ref_frame = VA_INVALID_SURFACE;\n  }\n\n  if (golden_frame) {\n    scoped_refptr<VaapiDecodeSurface> golden_frame_surface =\n        VP8PictureToVaapiDecodeSurface(golden_frame);\n    pic_param.golden_ref_frame = golden_frame_surface->va_surface()->id();\n  } else {\n    pic_param.golden_ref_frame = VA_INVALID_SURFACE;\n  }\n\n  if (alt_frame) {\n    scoped_refptr<VaapiDecodeSurface> alt_frame_surface =\n        VP8PictureToVaapiDecodeSurface(alt_frame);\n    pic_param.alt_ref_frame = alt_frame_surface->va_surface()->id();\n  } else {\n    pic_param.alt_ref_frame = VA_INVALID_SURFACE;\n  }\n\n  pic_param.out_of_loop_frame = VA_INVALID_SURFACE;\n\n  const Vp8LoopFilterHeader& lf_hdr = frame_hdr->loopfilter_hdr;\n\n#define FHDR_TO_PP_PF(a, b) pic_param.pic_fields.bits.a = (b)\n  FHDR_TO_PP_PF(key_frame, frame_hdr->IsKeyframe() ? 0 : 1);\n  FHDR_TO_PP_PF(version, frame_hdr->version);\n  FHDR_TO_PP_PF(segmentation_enabled, sgmnt_hdr.segmentation_enabled);\n  FHDR_TO_PP_PF(update_mb_segmentation_map,\n                sgmnt_hdr.update_mb_segmentation_map);\n  FHDR_TO_PP_PF(update_segment_feature_data,\n                sgmnt_hdr.update_segment_feature_data);\n  FHDR_TO_PP_PF(filter_type, lf_hdr.type);\n  FHDR_TO_PP_PF(sharpness_level, lf_hdr.sharpness_level);\n  FHDR_TO_PP_PF(loop_filter_adj_enable, lf_hdr.loop_filter_adj_enable);\n  FHDR_TO_PP_PF(mode_ref_lf_delta_update, lf_hdr.mode_ref_lf_delta_update);\n  FHDR_TO_PP_PF(sign_bias_golden, frame_hdr->sign_bias_golden);\n  FHDR_TO_PP_PF(sign_bias_alternate, frame_hdr->sign_bias_alternate);\n  FHDR_TO_PP_PF(mb_no_coeff_skip, frame_hdr->mb_no_skip_coeff);\n  FHDR_TO_PP_PF(loop_filter_disable, lf_hdr.level == 0);\n#undef FHDR_TO_PP_PF\n\n  ARRAY_MEMCPY_CHECKED(pic_param.mb_segment_tree_probs, sgmnt_hdr.segment_prob);\n\n  static_assert(arraysize(sgmnt_hdr.lf_update_value) ==\n                    arraysize(pic_param.loop_filter_level),\n                \"loop filter level arrays mismatch\");\n  for (size_t i = 0; i < arraysize(sgmnt_hdr.lf_update_value); ++i) {\n    int lf_level = lf_hdr.level;\n    if (sgmnt_hdr.segmentation_enabled) {\n      if (sgmnt_hdr.segment_feature_mode ==\n          Vp8SegmentationHeader::FEATURE_MODE_ABSOLUTE)\n        lf_level = sgmnt_hdr.lf_update_value[i];\n      else\n        lf_level += sgmnt_hdr.lf_update_value[i];\n    }\n\n    lf_level = std::min(std::max(lf_level, 0), 63);\n    pic_param.loop_filter_level[i] = lf_level;\n  }\n\n  static_assert(\n      arraysize(lf_hdr.ref_frame_delta) ==\n              arraysize(pic_param.loop_filter_deltas_ref_frame) &&\n          arraysize(lf_hdr.mb_mode_delta) ==\n              arraysize(pic_param.loop_filter_deltas_mode) &&\n          arraysize(lf_hdr.ref_frame_delta) == arraysize(lf_hdr.mb_mode_delta),\n      \"loop filter deltas arrays size mismatch\");\n  for (size_t i = 0; i < arraysize(lf_hdr.ref_frame_delta); ++i) {\n    pic_param.loop_filter_deltas_ref_frame[i] = lf_hdr.ref_frame_delta[i];\n    pic_param.loop_filter_deltas_mode[i] = lf_hdr.mb_mode_delta[i];\n  }\n\n#define FHDR_TO_PP(a) pic_param.a = frame_hdr->a\n  FHDR_TO_PP(prob_skip_false);\n  FHDR_TO_PP(prob_intra);\n  FHDR_TO_PP(prob_last);\n  FHDR_TO_PP(prob_gf);\n#undef FHDR_TO_PP\n\n  ARRAY_MEMCPY_CHECKED(pic_param.y_mode_probs, entr_hdr.y_mode_probs);\n  ARRAY_MEMCPY_CHECKED(pic_param.uv_mode_probs, entr_hdr.uv_mode_probs);\n  ARRAY_MEMCPY_CHECKED(pic_param.mv_probs, entr_hdr.mv_probs);\n\n  pic_param.bool_coder_ctx.range = frame_hdr->bool_dec_range;\n  pic_param.bool_coder_ctx.value = frame_hdr->bool_dec_value;\n  pic_param.bool_coder_ctx.count = frame_hdr->bool_dec_count;\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,\n                                    sizeof(pic_param), &pic_param))\n    return false;\n\n  VASliceParameterBufferVP8 slice_param;\n  memset(&slice_param, 0, sizeof(slice_param));\n  slice_param.slice_data_size = frame_hdr->frame_size;\n  slice_param.slice_data_offset = frame_hdr->first_part_offset;\n  slice_param.slice_data_flag = VA_SLICE_DATA_FLAG_ALL;\n  slice_param.macroblock_offset = frame_hdr->macroblock_bit_offset;\n  slice_param.num_of_partitions = frame_hdr->num_of_dct_partitions + 1;\n\n  slice_param.partition_size[0] =\n      frame_hdr->first_part_size - ((frame_hdr->macroblock_bit_offset + 7) / 8);\n\n  for (size_t i = 0; i < frame_hdr->num_of_dct_partitions; ++i)\n    slice_param.partition_size[i + 1] = frame_hdr->dct_partition_sizes[i];\n\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceParameterBufferType,\n                                    sizeof(VASliceParameterBufferVP8),\n                                    &slice_param))\n    return false;\n\n  void* non_const_ptr = const_cast<uint8_t*>(frame_hdr->data);\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceDataBufferType,\n                                    frame_hdr->frame_size, non_const_ptr))\n    return false;\n\n  scoped_refptr<VaapiDecodeSurface> dec_surface =\n      VP8PictureToVaapiDecodeSurface(pic);\n\n  return vaapi_dec_->DecodeSurface(dec_surface);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187148, "func": "void HTMLMediaElement::ProgressEventTimerFired(TimerBase*) {\n   if (network_state_ != kNetworkLoading)\n     return;\n \n   double time = WTF::CurrentTime();\n   double timedelta = time - previous_progress_time_;\n \n  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress()) {\n    ScheduleEvent(EventTypeNames::progress);\n    previous_progress_time_ = time;\n    sent_stalled_event_ = false;\n    if (GetLayoutObject())\n      GetLayoutObject()->UpdateFromElement();\n  } else if (timedelta > 3.0 && !sent_stalled_event_) {\n    ScheduleEvent(EventTypeNames::stalled);\n    sent_stalled_event_ = true;\n    SetShouldDelayLoadEvent(false);\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7551, "func": "static inline long parse_iv(const unsigned char *p)\n{\n\treturn parse_iv2(p, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7955, "func": "void buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186564, "func": "AcceleratedStaticBitmapImage::AcceleratedStaticBitmapImage(\n    sk_sp<SkImage> image,\n    base::WeakPtr<WebGraphicsContext3DProviderWrapper>&&\n        context_provider_wrapper)\n    : paint_image_content_id_(cc::PaintImage::GetNextContentId()) {\n   CHECK(image && image->isTextureBacked());\n   texture_holder_ = std::make_unique<SkiaTextureHolder>(\n       std::move(image), std::move(context_provider_wrapper));\n  thread_checker_.DetachFromThread();\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 187145, "func": " void HTMLMediaElement::ChangeNetworkStateFromLoadingToIdle() {\n   progress_event_timer_.Stop();\n \n  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress())\n    ScheduleEvent(EventTypeNames::progress);\n  ScheduleEvent(EventTypeNames::suspend);\n  SetNetworkState(kNetworkIdle);\n }\n", "target": 1, "flaw_line_index": "4,5,6,7,8,9"}
{"idx": 8281, "func": "short XRRConfigCurrentRate (XRRScreenConfiguration *config)\n{\n    return config->current_rate;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187207, "func": "void CoordinatorImpl::UnregisterClientProcess(\n    mojom::ClientProcess* client_process) {\n  QueuedRequest* request = GetCurrentRequest();\n  if (request != nullptr) {\n    auto it = request->pending_responses.begin();\n    while (it != request->pending_responses.end()) {\n      std::set<QueuedRequest::PendingResponse>::iterator current = it++;\n      if (current->client != client_process)\n        continue;\n      RemovePendingResponse(client_process, current->type);\n      request->failed_memory_dump_count++;\n    }\n    FinalizeGlobalMemoryDumpIfAllManagersReplied();\n  }\n\n  for (auto& pair : in_progress_vm_region_requests_) {\n    QueuedVmRegionRequest* request = pair.second.get();\n    auto it = request->pending_responses.begin();\n    while (it != request->pending_responses.end()) {\n      auto current = it++;\n      if (*current == client_process) {\n        request->pending_responses.erase(current);\n      }\n    }\n  }\n\n  for (auto& pair : in_progress_vm_region_requests_) {\n    base::SequencedTaskRunnerHandle::Get()->PostTask(\n         FROM_HERE,\n         base::BindOnce(\n             &CoordinatorImpl::FinalizeVmRegionDumpIfAllManagersReplied,\n            base::Unretained(this), pair.second->dump_guid));\n   }\n \n   size_t num_deleted = clients_.erase(client_process);\n  DCHECK(num_deleted == 1);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186523, "func": " bool DataReductionProxySettings::IsDataReductionProxyEnabled() const {\n   if (base::FeatureList::IsEnabled(network::features::kNetworkService) &&\n       !params::IsEnabledWithNetworkService()) {\n     return false;\n   }\n  return IsDataSaverEnabledByUser();\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 7740, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n                           uint64_t off, uint32_t max_count)\n{\n    ssize_t err;\n    size_t offset = 7;\n    uint64_t read_count;\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n    if (fidp->fs.xattr.len < off) {\n        read_count = 0;\n    } else {\n        read_count = fidp->fs.xattr.len - off;\n    }\n    if (read_count > max_count) {\n        read_count = max_count;\n    }\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n    if (err < 0) {\n        return err;\n    }\n    offset += err;\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n                    ((char *)fidp->fs.xattr.value) + off,\n                    read_count);\n    if (err < 0) {\n        return err;\n    }\n    offset += err;\n    return offset;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7810, "func": "static struct h2s *h2c_stream_new(struct h2c *h2c, int id)\n{\n\tstruct conn_stream *cs;\n\tstruct h2s *h2s;\n\n\th2s = pool_alloc(pool_head_h2s);\n\tif (!h2s)\n\t\tgoto out;\n\n\th2s->h2c       = h2c;\n\th2s->mws       = h2c->miw;\n\th2s->flags     = H2_SF_NONE;\n\th2s->errcode   = H2_ERR_NO_ERROR;\n\th2s->st        = H2_SS_IDLE;\n\th1m_init(&h2s->req);\n\th1m_init(&h2s->res);\n\th2s->by_id.key = h2s->id = id;\n\th2c->max_id    = id;\n\tLIST_INIT(&h2s->list);\n\n\teb32_insert(&h2c->streams_by_id, &h2s->by_id);\n\th2c->nb_streams++;\n\tif (h2c->nb_streams > h2_settings_max_concurrent_streams)\n\t\tgoto out_close;\n\n\tcs = cs_new(h2c->conn);\n\tif (!cs)\n\t\tgoto out_close;\n\n\th2s->cs = cs;\n\tcs->ctx = h2s;\n\n\tif (stream_create_from_cs(cs) < 0)\n\t\tgoto out_free_cs;\n\n\treturn h2s;\n\n out_free_cs:\n\tcs_free(cs);\n out_close:\n\th2s_destroy(h2s);\n\th2s = NULL;\n out:\n\treturn h2s;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186860, "func": "MojoResult Core::WrapPlatformSharedBufferHandle(\n    const MojoPlatformHandle* platform_handle,\n    size_t size,\n    const MojoSharedBufferGuid* guid,\n    MojoPlatformSharedBufferHandleFlags flags,\n    MojoHandle* mojo_handle) {\n  DCHECK(size);\n  ScopedPlatformHandle handle;\n  MojoResult result =\n      MojoPlatformHandleToScopedPlatformHandle(platform_handle, &handle);\n  if (result != MOJO_RESULT_OK)\n    return result;\n \n   base::UnguessableToken token =\n       base::UnguessableToken::Deserialize(guid->high, guid->low);\n  bool read_only = flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n   scoped_refptr<PlatformSharedBuffer> platform_buffer =\n       PlatformSharedBuffer::CreateFromPlatformHandle(size, read_only, token,\n                                                      std::move(handle));\n  if (!platform_buffer)\n    return MOJO_RESULT_UNKNOWN;\n\n  scoped_refptr<SharedBufferDispatcher> dispatcher;\n  result = SharedBufferDispatcher::CreateFromPlatformSharedBuffer(\n      platform_buffer, &dispatcher);\n  if (result != MOJO_RESULT_OK)\n    return result;\n\n  MojoHandle h = AddDispatcher(dispatcher);\n  if (h == MOJO_HANDLE_INVALID) {\n    dispatcher->Close();\n    return MOJO_RESULT_RESOURCE_EXHAUSTED;\n  }\n\n  *mojo_handle = h;\n  return MOJO_RESULT_OK;\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 186331, "func": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n             R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n             R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n             R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339])\",\n             -1, US_INV),\n         0, status);\n    tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7650, "func": "static void proxy_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    rewinddir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187173, "func": "RenderFrameHostManager::GetSiteInstanceForNavigationRequest(\n    const NavigationRequest& request) {\n  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();\n  bool no_renderer_swap_allowed = false;\n  bool was_server_redirect = request.navigation_handle() &&\n                             request.navigation_handle()->WasServerRedirect();\n\n  if (frame_tree_node_->IsMainFrame()) {\n    bool can_renderer_initiate_transfer =\n        (request.state() == NavigationRequest::FAILED &&\n         SiteIsolationPolicy::IsErrorPageIsolationEnabled(\n             true \n)) ||\n        (render_frame_host_->IsRenderFrameLive() &&\n         IsURLHandledByNetworkStack(request.common_params().url) &&\n         IsRendererTransferNeededForNavigation(render_frame_host_.get(),\n                                               request.common_params().url));\n    no_renderer_swap_allowed |=\n        request.from_begin_navigation() && !can_renderer_initiate_transfer;\n  } else {\n     no_renderer_swap_allowed |= !CanSubframeSwapProcess(\n         request.common_params().url, request.source_site_instance(),\n        request.dest_site_instance(), was_server_redirect);\n   }\n \n   if (no_renderer_swap_allowed)\n    return scoped_refptr<SiteInstance>(current_site_instance);\n\n  SiteInstance* candidate_site_instance =\n      speculative_render_frame_host_\n          ? speculative_render_frame_host_->GetSiteInstance()\n          : nullptr;\n\n  scoped_refptr<SiteInstance> dest_site_instance = GetSiteInstanceForNavigation(\n      request.common_params().url, request.source_site_instance(),\n      request.dest_site_instance(), candidate_site_instance,\n      request.common_params().transition,\n      request.state() == NavigationRequest::FAILED,\n      request.restore_type() != RestoreType::NONE, request.is_view_source(),\n      was_server_redirect);\n\n  return dest_site_instance;\n}\n", "target": 1, "flaw_line_index": "35"}
{"idx": 186413, "func": " void BluetoothDeviceChooserController::PostErrorCallback(\n    blink::mojom::WebBluetoothResult error) {\n   if (!base::ThreadTaskRunnerHandle::Get()->PostTask(\n           FROM_HERE, base::BindOnce(error_callback_, error))) {\n     LOG(WARNING) << \"No TaskRunner.\";\n  }\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8132, "func": "void Gfx::opMoveShowText(Object args[], int numArgs) {\n  double tx, ty;\n\n  if (!state->getFont()) {\n    error(getPos(), \"No font in move/show\");\n    return;\n  }\n  if (fontChanged) {\n    out->updateFont(state);\n    fontChanged = gFalse;\n  }\n  tx = state->getLineX();\n  ty = state->getLineY() - state->getLeading();\n  state->textMoveTo(tx, ty);\n  out->updateTextPos(state);\n  out->beginStringOp(state);\n  doShowText(args[0].getString());\n  out->endStringOp(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187095, "func": "SpeechRecognitionManagerImpl::SpeechRecognitionManagerImpl(\n    media::AudioSystem* audio_system,\n    MediaStreamManager* media_stream_manager)\n    : audio_system_(audio_system),\n      media_stream_manager_(media_stream_manager),\n      primary_session_id_(kSessionIDInvalid),\n      last_session_id_(kSessionIDInvalid),\n      is_dispatching_event_(false),\n       delegate_(GetContentClient()\n                     ->browser()\n                     ->CreateSpeechRecognitionManagerDelegate()),\n       weak_factory_(this) {\n   DCHECK(!g_speech_recognition_manager_impl);\n   g_speech_recognition_manager_impl = this;\n\n  frame_deletion_observer_.reset(new FrameDeletionObserver(\n      base::BindRepeating(&SpeechRecognitionManagerImpl::AbortSessionImpl,\n                          weak_factory_.GetWeakPtr())));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186947, "func": "AppCache::AppCache(AppCacheStorage* storage, int64_t cache_id)\n    : cache_id_(cache_id),\n      owning_group_(nullptr),\n       online_whitelist_all_(false),\n       is_complete_(false),\n       cache_size_(0),\n       storage_(storage) {\n   storage_->working_set()->AddCache(this);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187256, "func": "bool PermissionsData::CanCaptureVisiblePage(int tab_id,\n                                             std::string* error) const {\n   const URLPattern all_urls(URLPattern::SCHEME_ALL,\n                             URLPattern::kAllUrlsPattern);\n \n   base::AutoLock auto_lock(runtime_lock_);\n   if (active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls))\n     return true;\n \n  if (tab_id >= 0) {\n    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);\n    if (tab_permissions &&\n        tab_permissions->HasAPIPermission(APIPermission::kTab)) {\n      return true;\n    }\n    if (error)\n      *error = manifest_errors::kActiveTabPermissionNotGranted;\n    return false;\n   }\n \n   if (error)\n    *error = manifest_errors::kAllURLOrActiveTabNeeded;\n  return false;\n}\n", "target": 1, "flaw_line_index": "10,11,12,13,14,15,16,17,18"}
{"idx": 186640, "func": " void HTMLImportsController::Dispose() {\n  for (const auto& loader : loaders_)\n    loader->Dispose();\n  loaders_.clear();\n \n   if (root_) {\n     root_->Dispose();\n    root_.Clear();\n  }\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 186722, "func": "void DOMHandler::SetRenderer(RenderProcessHost* process_host,\n                              RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8165, "func": "void Gfx::opSetTextRise(Object args[], int numArgs) {\n  state->setRise(args[0].getNum());\n  out->updateRise(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7567, "func": "static void cirrus_bitblt_reset(CirrusVGAState * s)\n{\n    int need_update;\n\n    s->vga.gr[0x31] &=\n\t~(CIRRUS_BLT_START | CIRRUS_BLT_BUSY | CIRRUS_BLT_FIFOUSED);\n    need_update = s->cirrus_srcptr != &s->cirrus_bltbuf[0]\n        || s->cirrus_srcptr_end != &s->cirrus_bltbuf[0];\n    s->cirrus_srcptr = &s->cirrus_bltbuf[0];\n    s->cirrus_srcptr_end = &s->cirrus_bltbuf[0];\n    s->cirrus_srccounter = 0;\n    if (!need_update)\n        return;\n    cirrus_update_memory_access(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7447, "func": "void zend_ts_hash_display(TsHashTable *ht)\n{\n\tbegin_read(ht);\n\tzend_hash_display(TS_HASH(ht));\n\tend_read(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186817, "func": " void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n     shared_buffer_handle_.reset();\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186329, "func": "static void gatherSecurityPolicyViolationEventData(\n    SecurityPolicyViolationEventInit& init,\n    ExecutionContext* context,\n    const String& directiveText,\n    const ContentSecurityPolicy::DirectiveType& effectiveType,\n    const KURL& blockedURL,\n    const String& header,\n    RedirectStatus redirectStatus,\n    ContentSecurityPolicyHeaderType headerType,\n    ContentSecurityPolicy::ViolationType violationType,\n    int contextLine,\n    const String& scriptSource) {\n  if (effectiveType == ContentSecurityPolicy::DirectiveType::FrameAncestors) {\n    init.setDocumentURI(blockedURL.getString());\n    init.setBlockedURI(blockedURL.getString());\n   } else {\n    init.setDocumentURI(context->url().getString());\n     switch (violationType) {\n       case ContentSecurityPolicy::InlineViolation:\n         init.setBlockedURI(\"inline\");\n        break;\n      case ContentSecurityPolicy::EvalViolation:\n        init.setBlockedURI(\"eval\");\n        break;\n      case ContentSecurityPolicy::URLViolation:\n        init.setBlockedURI(stripURLForUseInReport(\n            context, blockedURL, redirectStatus, effectiveType));\n        break;\n    }\n  }\n\n  String effectiveDirective =\n      ContentSecurityPolicy::getDirectiveName(effectiveType);\n  init.setViolatedDirective(effectiveDirective);\n  init.setEffectiveDirective(effectiveDirective);\n  init.setOriginalPolicy(header);\n  init.setDisposition(headerType == ContentSecurityPolicyHeaderTypeEnforce\n                          ? \"enforce\"\n                          : \"report\");\n  init.setSourceFile(String());\n  init.setLineNumber(contextLine);\n  init.setColumnNumber(0);\n  init.setStatusCode(0);\n\n  if (context->isDocument()) {\n    Document* document = toDocument(context);\n    DCHECK(document);\n    init.setReferrer(document->referrer());\n    if (!SecurityOrigin::isSecure(context->url()) && document->loader())\n      init.setStatusCode(document->loader()->response().httpStatusCode());\n  }\n\n  std::unique_ptr<SourceLocation> location = SourceLocation::capture(context);\n  if (location->lineNumber()) {\n    KURL source = KURL(ParsedURLString, location->url());\n    init.setSourceFile(\n        stripURLForUseInReport(context, source, redirectStatus, effectiveType));\n    init.setLineNumber(location->lineNumber());\n    init.setColumnNumber(location->columnNumber());\n  }\n\n  if (!scriptSource.isEmpty())\n    init.setSample(scriptSource.stripWhiteSpace().left(40));\n}\n", "target": 1, "flaw_line_index": "17,18,20"}
{"idx": 186332, "func": "void RequestSender::OnNetworkFetcherComplete(\n    const GURL& original_url,\n    std::unique_ptr<std::string> response_body,\n    int net_error,\n    const std::string& header_etag,\n    int64_t xheader_retry_after_sec) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n   VLOG(1) << \"request completed from url: \" << original_url.spec();\n \n   int error = -1;\n  if (response_body && response_code_ == 200) {\n    DCHECK_EQ(0, net_error);\n     error = 0;\n  } else if (response_code_ != -1) {\n     error = response_code_;\n  } else {\n     error = net_error;\n  }\n \n   int retry_after_sec = -1;\n   if (original_url.SchemeIsCryptographic() && error > 0)\n    retry_after_sec = base::saturated_cast<int>(xheader_retry_after_sec);\n\n  base::ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, base::BindOnce(&RequestSender::SendInternalComplete,\n                                base::Unretained(this), error,\n                                response_body ? *response_body : std::string(),\n                                header_etag, retry_after_sec));\n}\n", "target": 1, "flaw_line_index": "12,13,15,17,19"}
{"idx": 7627, "func": "static int proxy_closedir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return closedir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186979, "func": " void ResetPaddingKeyForTesting() {\n  *GetPaddingKey() = SymmetricKey::GenerateRandomKey(kPaddingKeyAlgorithm, 128);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8101, "func": "GBool GfxResources::lookupMarkedContentNF(char *name, Object *obj) {\n  GfxResources *resPtr;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->propertiesDict.isDict()) {\n      if (!resPtr->propertiesDict.dictLookupNF(name, obj)->isNull())\n\treturn gTrue;\n      obj->free();\n    }\n  }\n  error(-1, \"Marked Content '%s' is unknown\", name);\n  return gFalse;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187319, "func": "exsltStrXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n{\n    if (ctxt\n        && prefix\n        && !xmlXPathRegisterNs(ctxt,\n                               prefix,\n                               (const xmlChar *) EXSLT_STRINGS_NAMESPACE)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"encode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrEncodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"decode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrDecodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"padding\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrPaddingFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"align\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrAlignFunction)\n         && !xmlXPathRegisterFuncNS(ctxt,\n                                    (const xmlChar *) \"concat\",\n                                    (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrConcatFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"replace\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrReplaceFunction)) {\n         return 0;\n     }\n     return -1;\n}\n", "target": 1, "flaw_line_index": "27,28,29,30,31"}
{"idx": 187311, "func": "_exsltDateAdd (exsltDateValPtr dt, exsltDateValPtr dur)\n{\n    exsltDateValPtr ret;\n    long carry, tempdays, temp;\n    exsltDateValDatePtr r, d;\n    exsltDateValDurationPtr u;\n\n    if ((dt == NULL) || (dur == NULL))\n        return NULL;\n\n    ret = exsltDateCreateDate(dt->type);\n    if (ret == NULL)\n        return NULL;\n\n    r = &(ret->value.date);\n     d = &(dt->value.date);\n     u = &(dur->value.dur);\n \n    if (d->mon == 0)\n        d->mon = 1;\n     u->sec -= (d->tzo * 60);\t\n     d->tzo = 0;\n \n    if (d->day == 0)\n        d->day = 1;\n     carry  = d->mon + u->mon;\n     r->mon = (unsigned int)MODULO_RANGE(carry, 1, 13);\n    carry  = (long)FQUOTIENT_RANGE(carry, 1, 13);\n\n    r->year = d->year + carry;\n    if (r->year == 0) {\n        if (d->year > 0)\n            r->year--;\n        else\n            r->year++;\n    }\n\n    r->tzo     = d->tzo;\n    r->tz_flag = d->tz_flag;\n\n    r->sec = d->sec + u->sec;\n    carry  = (long)FQUOTIENT((long)r->sec, 60);\n    if (r->sec != 0.0) {\n        r->sec = MODULO(r->sec, 60.0);\n    }\n\n    carry += d->min;\n    r->min = (unsigned int)MODULO(carry, 60);\n    carry  = (long)FQUOTIENT(carry, 60);\n\n    carry  += d->hour;\n    r->hour = (unsigned int)MODULO(carry, 24);\n    carry   = (long)FQUOTIENT(carry, 24);\n\n    if ((VALID_YEAR(r->year)) && (VALID_MONTH(r->mon)) &&\n                  (d->day > MAX_DAYINMONTH(r->year, r->mon)))\n        tempdays = MAX_DAYINMONTH(r->year, r->mon);\n    else if (d->day < 1)\n        tempdays = 1;\n    else\n        tempdays = d->day;\n\n    tempdays += u->day + carry;\n\n    while (1) {\n        if (tempdays < 1) {\n            long tmon = (long)MODULO_RANGE((int)r->mon-1, 1, 13);\n            long tyr  = r->year + (long)FQUOTIENT_RANGE((int)r->mon-1, 1, 13);\n            if (tyr == 0)\n                tyr--;\n\t    if (tmon < 0)\n\t        tmon = 0;\n\t    if (tmon > 12)\n\t        tmon = 12;\n            tempdays += MAX_DAYINMONTH(tyr, tmon);\n            carry = -1;\n        } else if (tempdays > (long)MAX_DAYINMONTH(r->year, r->mon)) {\n            tempdays = tempdays - MAX_DAYINMONTH(r->year, r->mon);\n            carry = 1;\n        } else\n            break;\n\n        temp = r->mon + carry;\n        r->mon = (unsigned int)MODULO_RANGE(temp, 1, 13);\n        r->year = r->year + (long)FQUOTIENT_RANGE(temp, 1, 13);\n        if (r->year == 0) {\n            if (temp < 1)\n                r->year--;\n            else\n                r->year++;\n\t}\n    }\n\n    r->day = tempdays;\n\n    if (ret->type != XS_DATETIME) {\n        if ((r->hour) || (r->min) || (r->sec))\n            ret->type = XS_DATETIME;\n        else if (ret->type != XS_DATE) {\n            if (r->day != 1)\n                ret->type = XS_DATE;\n            else if ((ret->type != XS_GYEARMONTH) && (r->mon != 1))\n                ret->type = XS_GYEARMONTH;\n        }\n    }\n\n    return ret;\n}\n", "target": 1, "flaw_line_index": "18,19,20,23,24,25"}
{"idx": 7611, "func": "static void cirrus_vga_write_palette(CirrusVGAState * s, int reg_value)\n{\n    s->vga.dac_cache[s->vga.dac_sub_index] = reg_value;\n    if (++s->vga.dac_sub_index == 3) {\n        if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {\n            memcpy(&s->cirrus_hidden_palette[(s->vga.dac_write_index & 0x0f) * 3],\n                   s->vga.dac_cache, 3);\n        } else {\n            memcpy(&s->vga.palette[s->vga.dac_write_index * 3], s->vga.dac_cache, 3);\n        }\n\ts->vga.dac_sub_index = 0;\n\ts->vga.dac_write_index++;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186916, "func": " void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {\n   v8::Isolate* isolate = args.GetIsolate();\n  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n \n   v8::Local<v8::Function> compile_callback =\n       v8::Function::New(isolate, CompileFromResponseCallback);\n\n\n  V8SetReturnValue(args, ScriptPromise::Cast(script_state, args[0])\n                             .Then(compile_callback)\n                             .V8Value());\n\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187206, "func": "void CoordinatorImpl::RegisterClientProcess(\n    mojom::ClientProcessPtr client_process_ptr,\n    mojom::ProcessType process_type) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   mojom::ClientProcess* client_process = client_process_ptr.get();\n   client_process_ptr.set_connection_error_handler(\n       base::BindOnce(&CoordinatorImpl::UnregisterClientProcess,\n                     base::Unretained(this), client_process));\n   auto identity = GetClientIdentityForCurrentRequest();\n   auto client_info = std::make_unique<ClientInfo>(\n       std::move(identity), std::move(client_process_ptr), process_type);\n  auto iterator_and_inserted =\n      clients_.emplace(client_process, std::move(client_info));\n  DCHECK(iterator_and_inserted.second);\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 186604, "func": "void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n  if (ValidateDataOrigin(other->data_origin_)) {\n    DCHECK(thread_checker_.CalledOnValidThread());\n    valid_until_ = std::max(valid_until_, other->valid_until_);\n    set_length(other->length_);\n    cacheable_ |= other->cacheable_;\n    range_supported_ |= other->range_supported_;\n    if (last_modified_.is_null()) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n    set_has_opaque_data(other->has_opaque_data_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n", "target": 1, "flaw_line_index": "16"}
{"idx": 7600, "func": "static uint64_t cirrus_vga_ioport_read(void *opaque, hwaddr addr,\n                                       unsigned size)\n{\n    CirrusVGAState *c = opaque;\n    VGACommonState *s = &c->vga;\n    int val, index;\n\n    addr += 0x3b0;\n\n    if (vga_ioport_invalid(s, addr)) {\n\tval = 0xff;\n    } else {\n\tswitch (addr) {\n\tcase 0x3c0:\n\t    if (s->ar_flip_flop == 0) {\n\t\tval = s->ar_index;\n\t    } else {\n\t\tval = 0;\n\t    }\n\t    break;\n\tcase 0x3c1:\n\t    index = s->ar_index & 0x1f;\n\t    if (index < 21)\n\t\tval = s->ar[index];\n\t    else\n\t\tval = 0;\n\t    break;\n\tcase 0x3c2:\n\t    val = s->st00;\n\t    break;\n\tcase 0x3c4:\n\t    val = s->sr_index;\n\t    break;\n\tcase 0x3c5:\n\t    val = cirrus_vga_read_sr(c);\n            break;\n#ifdef DEBUG_VGA_REG\n\t    printf(\"vga: read SR%x = 0x%02x\\n\", s->sr_index, val);\n#endif\n\t    break;\n\tcase 0x3c6:\n\t    val = cirrus_read_hidden_dac(c);\n\t    break;\n\tcase 0x3c7:\n\t    val = s->dac_state;\n\t    break;\n\tcase 0x3c8:\n\t    val = s->dac_write_index;\n\t    c->cirrus_hidden_dac_lockindex = 0;\n\t    break;\n        case 0x3c9:\n            val = cirrus_vga_read_palette(c);\n            break;\n\tcase 0x3ca:\n\t    val = s->fcr;\n\t    break;\n\tcase 0x3cc:\n\t    val = s->msr;\n\t    break;\n\tcase 0x3ce:\n\t    val = s->gr_index;\n\t    break;\n\tcase 0x3cf:\n\t    val = cirrus_vga_read_gr(c, s->gr_index);\n#ifdef DEBUG_VGA_REG\n\t    printf(\"vga: read GR%x = 0x%02x\\n\", s->gr_index, val);\n#endif\n\t    break;\n\tcase 0x3b4:\n\tcase 0x3d4:\n\t    val = s->cr_index;\n\t    break;\n\tcase 0x3b5:\n\tcase 0x3d5:\n            val = cirrus_vga_read_cr(c, s->cr_index);\n#ifdef DEBUG_VGA_REG\n\t    printf(\"vga: read CR%x = 0x%02x\\n\", s->cr_index, val);\n#endif\n\t    break;\n\tcase 0x3ba:\n\tcase 0x3da:\n\t    val = s->st01 = s->retrace(s);\n\t    s->ar_flip_flop = 0;\n\t    break;\n\tdefault:\n\t    val = 0x00;\n\t    break;\n\t}\n    }\n#if defined(DEBUG_VGA)\n    printf(\"VGA: read addr=0x%04x data=0x%02x\\n\", addr, val);\n#endif\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186681, "func": " void assertObjectHasGCInfo(const void* payload, size_t gcInfoIndex) {\n  ASSERT(HeapObjectHeader::fromPayload(payload)->checkHeader());\n #if !defined(COMPONENT_BUILD)\n  ASSERT(HeapObjectHeader::fromPayload(payload)->gcInfoIndex() == gcInfoIndex);\n#endif\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8209, "func": "static void v9fs_clunk(void *opaque)\n{\n    int err;\n    int32_t fid;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_clunk(pdu->tag, pdu->id, fid);\n\n    fidp = clunk_fid(s, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    fidp->ref++;\n    err = put_fid(pdu, fidp);\n    if (!err) {\n        err = offset;\n    }\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186621, "func": " void HttpAuthFilterWhitelist::SetWhitelist(\n     const std::string& server_whitelist) {\n  rules_.ParseFromString(server_whitelist);\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8069, "func": "Stream *Gfx::buildImageStream() {\n  Object dict;\n  Object obj;\n  char *key;\n  Stream *str;\n\n  dict.initDict(xref);\n  parser->getObj(&obj);\n  while (!obj.isCmd(\"ID\") && !obj.isEOF()) {\n    if (!obj.isName()) {\n      error(getPos(), \"Inline image dictionary key must be a name object\");\n      obj.free();\n    } else {\n      key = copyString(obj.getName());\n      obj.free();\n      parser->getObj(&obj);\n      if (obj.isEOF() || obj.isError()) {\n\tgfree(key);\n\tbreak;\n      }\n      dict.dictAdd(key, &obj);\n    }\n    parser->getObj(&obj);\n  }\n  if (obj.isEOF()) {\n    error(getPos(), \"End of file in inline image\");\n    obj.free();\n    dict.free();\n    return NULL;\n  }\n  obj.free();\n\n  if (parser->getStream()) {\n    str = new EmbedStream(parser->getStream(), &dict, gFalse, 0);\n    str = str->addFilters(&dict);\n  } else {\n    str = NULL;\n    dict.free();\n  }\n\n  return str;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7477, "func": "ssize_t local_setxattr_nofollow(FsContext *ctx, const char *path,\n                                const char *name, void *value, size_t size,\n                                int flags)\n{\n    char *dirpath = g_path_get_dirname(path);\n    char *filename = g_path_get_basename(path);\n    int dirfd;\n    ssize_t ret = -1;\n\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    if (dirfd == -1) {\n        goto out;\n    }\n\n    ret = fsetxattrat_nofollow(dirfd, filename, name, value, size, flags);\n    close_preserve_errno(dirfd);\nout:\n    g_free(dirpath);\n    g_free(filename);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186962, "func": "  void SetupMockGroup() {\n    std::unique_ptr<net::HttpResponseInfo> info(MakeMockResponseInfo());\n    const int kMockInfoSize = GetResponseInfoSize(info.get());\n\n    scoped_refptr<AppCacheGroup> group(\n        new AppCacheGroup(service_->storage(), kManifestUrl, kMockGroupId));\n    scoped_refptr<AppCache> cache(\n        new AppCache(service_->storage(), kMockCacheId));\n     cache->AddEntry(\n         kManifestUrl,\n         AppCacheEntry(AppCacheEntry::MANIFEST, kMockResponseId,\n                      kMockInfoSize + kMockBodySize));\n     cache->set_complete(true);\n     group->AddCache(cache.get());\n     mock_storage()->AddStoredGroup(group.get());\n    mock_storage()->AddStoredCache(cache.get());\n  }\n", "target": 1, "flaw_line_index": "13"}
{"idx": 8059, "func": "FoFiType1::FoFiType1(char *fileA, int lenA, GBool freeFileDataA):\n  FoFiBase(fileA, lenA, freeFileDataA)\n{\n  name = NULL;\n  encoding = NULL;\n  parsed = gFalse;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8258, "func": "SendRange(\n    Display \t*dpy,\n    XRecordRange **range_item,\n    int   \tnranges)\n{\n    int \t\trlen = SIZEOF(xRecordRange);\n    while(nranges--)\n    {\n       xRecordRange xrange;\n\n       xrange.coreRequestsFirst = (*range_item)->core_requests.first;\n       xrange.coreRequestsLast = (*range_item)->core_requests.last;\n       xrange.coreRepliesFirst = (*range_item)->core_replies.first;\n       xrange.coreRepliesLast = (*range_item)->core_replies.last;\n       xrange.extRequestsMajorFirst = (*range_item)->ext_requests.ext_major.first;\n       xrange.extRequestsMajorLast = (*range_item)->ext_requests.ext_major.last;\n       xrange.extRequestsMinorFirst = (*range_item)->ext_requests.ext_minor.first;\n       xrange.extRequestsMinorLast = (*range_item)->ext_requests.ext_minor.last;\n       xrange.extRepliesMajorFirst = (*range_item)->ext_replies.ext_major.first;\n       xrange.extRepliesMajorLast = (*range_item)->ext_replies.ext_major.last;\n       xrange.extRepliesMinorFirst = (*range_item)->ext_replies.ext_minor.first;\n       xrange.extRepliesMinorLast = (*range_item)->ext_replies.ext_minor.last;\n       xrange.deliveredEventsFirst = (*range_item)->delivered_events.first;\n       xrange.deliveredEventsLast = (*range_item)->delivered_events.last;\n       xrange.deviceEventsFirst = (*range_item)->device_events.first;\n       xrange.deviceEventsLast = (*range_item)->device_events.last;\n       xrange.errorsFirst = (*range_item)->errors.first;\n       xrange.errorsLast = (*range_item)->errors.last;\n       xrange.clientStarted = (*range_item)->client_started;\n       xrange.clientDied = (*range_item)->client_died;\n\n       Data(dpy, (char *)&xrange, rlen);\n       range_item++;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186941, "func": "InlineBoxPosition ComputeInlineBoxPositionTemplate(\n    const PositionTemplate<Strategy>& position,\n    TextAffinity affinity,\n    TextDirection primary_direction) {\n  int caret_offset = position.ComputeEditingOffset();\n  Node* const anchor_node = position.AnchorNode();\n  LayoutObject* layout_object =\n      anchor_node->IsShadowRoot()\n          ? ToShadowRoot(anchor_node)->host().GetLayoutObject()\n          : anchor_node->GetLayoutObject();\n\n  DCHECK(layout_object) << position;\n\n  if (layout_object->IsText()) {\n    return ComputeInlineBoxPositionForTextNode(layout_object, caret_offset,\n                                                affinity, primary_direction);\n   }\n \n  if (layout_object->IsLayoutBlockFlow()) {\n    if (CanHaveChildrenForEditing(anchor_node) &&\n        HasRenderedNonAnonymousDescendantsWithHeight(layout_object)) {\n      const PositionTemplate<Strategy>& downstream_equivalent =\n          DownstreamIgnoringEditingBoundaries(position);\n      if (downstream_equivalent != position) {\n        return ComputeInlineBoxPosition(\n            downstream_equivalent, TextAffinity::kUpstream, primary_direction);\n      }\n      const PositionTemplate<Strategy>& upstream_equivalent =\n          UpstreamIgnoringEditingBoundaries(position);\n      if (upstream_equivalent == position ||\n          DownstreamIgnoringEditingBoundaries(upstream_equivalent) == position)\n        return InlineBoxPosition();\n      return ComputeInlineBoxPosition(\n          upstream_equivalent, TextAffinity::kUpstream, primary_direction);\n    }\n   }\n \n  if (!layout_object->IsAtomicInlineLevel())\n     return InlineBoxPosition();\n  if (!layout_object->IsBox())\n     return InlineBoxPosition();\n  InlineBox* const inline_box = ToLayoutBox(layout_object)->InlineBoxWrapper();\n  if (!inline_box)\n     return InlineBoxPosition();\n  if ((caret_offset > inline_box->CaretMinOffset() &&\n       caret_offset < inline_box->CaretMaxOffset()))\n    return InlineBoxPosition(inline_box, caret_offset);\n  return AdjustInlineBoxPositionForTextDirection(\n      inline_box, caret_offset, layout_object->Style()->GetUnicodeBidi(),\n      primary_direction);\n }\n", "target": 1, "flaw_line_index": "19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,47,49,51,52"}
{"idx": 186851, "func": "void MojoVideoEncodeAccelerator::UseOutputBitstreamBuffer(\n    const BitstreamBuffer& buffer) {\n  DVLOG(2) << __func__ << \" buffer.id()= \" << buffer.id()\n            << \" buffer.size()= \" << buffer.size() << \"B\";\n   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n      buffer.handle().Duplicate(), buffer.size(), true \n);\n \n   vea_->UseOutputBitstreamBuffer(buffer.id(), std::move(buffer_handle));\n }\n", "target": 1, "flaw_line_index": "7,9,12"}
{"idx": 187026, "func": "    NavigateToAboutBlank() {\n  GURL about_blank(url::kAboutBlankURL);\n  content::NavigationController::LoadURLParams params(about_blank);\n  params.frame_tree_node_id = frame_tree_node_id_;\n  params.source_site_instance = parent_site_instance_;\n  params.is_renderer_initiated = true;\n  web_contents()->GetController().LoadURLWithParams(params);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9"}
{"idx": 8102, "func": "GfxPattern *GfxResources::lookupPattern(char *name, Gfx *gfx) {\n  GfxResources *resPtr;\n  GfxPattern *pattern;\n  Object obj;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->patternDict.isDict()) {\n      if (!resPtr->patternDict.dictLookup(name, &obj)->isNull()) {\n\tpattern = GfxPattern::parse(&obj, gfx);\n\tobj.free();\n\treturn pattern;\n      }\n      obj.free();\n    }\n  }\n  error(-1, \"Unknown pattern '%s'\", name);\n  return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8150, "func": "void Gfx::opSetHorizScaling(Object args[], int numArgs) {\n  state->setHorizScaling(args[0].getNum());\n  out->updateHorizScaling(state);\n  fontChanged = gTrue;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186539, "func": "void SerializedScriptValue::transferArrayBuffers(v8::Isolate* isolate, const ArrayBufferArray& arrayBuffers, ExceptionState& exceptionState)\n{\n    if (!arrayBuffers.size())\n        return;\n\n    for (size_t i = 0; i < arrayBuffers.size(); ++i) {\n        if (arrayBuffers[i]->isNeutered()) {\n            exceptionState.throwDOMException(DataCloneError, \"ArrayBuffer at index \" + String::number(i) + \" is already neutered.\");\n            return;\n        }\n    }\n\n    OwnPtr<ArrayBufferContentsArray> contents = adoptPtr(new ArrayBufferContentsArray(arrayBuffers.size()));\n\n    HeapHashSet<Member<DOMArrayBufferBase>> visited;\n    for (size_t i = 0; i < arrayBuffers.size(); ++i) {\n        if (visited.contains(arrayBuffers[i]))\n            continue;\n        visited.add(arrayBuffers[i]);\n\n        if (arrayBuffers[i]->isShared()) {\n            bool result = arrayBuffers[i]->shareContentsWith(contents->at(i));\n            if (!result) {\n                exceptionState.throwDOMException(DataCloneError, \"SharedArrayBuffer at index \" + String::number(i) + \" could not be transferred.\");\n                return;\n            }\n        } else {\n            Vector<v8::Local<v8::ArrayBuffer>, 4> bufferHandles;\n            v8::HandleScope handleScope(isolate);\n            acculumateArrayBuffersForAllWorlds(isolate, static_cast<DOMArrayBuffer*>(arrayBuffers[i].get()), bufferHandles);\n            bool isNeuterable = true;\n            for (size_t j = 0; j < bufferHandles.size(); ++j)\n                isNeuterable &= bufferHandles[j]->IsNeuterable();\n \n             DOMArrayBufferBase* toTransfer = arrayBuffers[i];\n             if (!isNeuterable)\n                toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer());\n             bool result = toTransfer->transfer(contents->at(i));\n             if (!result) {\n                 exceptionState.throwDOMException(DataCloneError, \"ArrayBuffer at index \" + String::number(i) + \" could not be transferred.\");\n                return;\n            }\n\n            if (isNeuterable)\n                for (size_t j = 0; j < bufferHandles.size(); ++j)\n                    bufferHandles[j]->Neuter();\n        }\n\n    }\n    m_arrayBufferContentsArray = contents.release();\n}\n", "target": 1, "flaw_line_index": "37"}
{"idx": 7416, "func": "ZEND_API int zend_ts_hash_compare(TsHashTable *ht1, TsHashTable *ht2, compare_func_t compar, zend_bool ordered)\n{\n\tint retval;\n\n\tbegin_read(ht1);\n\tbegin_read(ht2);\n\tretval = zend_hash_compare(TS_HASH(ht1), TS_HASH(ht2), compar, ordered);\n\tend_read(ht2);\n\tend_read(ht1);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7723, "func": "static void coroutine_fn v9fs_lcreate(void *opaque)\n{\n    int32_t dfid, flags, mode;\n    gid_t gid;\n    ssize_t err = 0;\n    ssize_t offset = 7;\n    V9fsString name;\n    V9fsFidState *fidp;\n    struct stat stbuf;\n    V9fsQID qid;\n    int32_t iounit;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsddd\", &dfid,\n                        &name, &flags, &mode, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_lcreate(pdu->tag, pdu->id, dfid, flags, mode, gid);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, dfid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    flags = get_dotl_openflags(pdu->s, flags);\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n                        flags | O_CREAT, mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    fidp->fid_type = P9_FID_FILE;\n    fidp->open_flags = flags;\n    if (flags & O_EXCL) {\n        fidp->flags |= FID_NON_RECLAIMABLE;\n    }\n    iounit =  get_iounit(pdu, &fidp->path);\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path, iounit);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186648, "func": "void DevToolsDataSource::StartDataRequest(\n    const std::string& path,\n    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n    const content::URLDataSource::GotDataCallback& callback) {\n  std::string bundled_path_prefix(chrome::kChromeUIDevToolsBundledPath);\n  bundled_path_prefix += \"/\";\n  if (base::StartsWith(path, bundled_path_prefix,\n                       base::CompareCase::INSENSITIVE_ASCII)) {\n    StartBundledDataRequest(path.substr(bundled_path_prefix.length()),\n                            callback);\n    return;\n  }\n\n  std::string empty_path_prefix(chrome::kChromeUIDevToolsBlankPath);\n  if (base::StartsWith(path, empty_path_prefix,\n                       base::CompareCase::INSENSITIVE_ASCII)) {\n    callback.Run(new base::RefCountedStaticMemory());\n    return;\n  }\n\n  std::string remote_path_prefix(chrome::kChromeUIDevToolsRemotePath);\n  remote_path_prefix += \"/\";\n  if (base::StartsWith(path, remote_path_prefix,\n                       base::CompareCase::INSENSITIVE_ASCII)) {\n    GURL url(kRemoteFrontendBase + path.substr(remote_path_prefix.length()));\n\n    CHECK_EQ(url.host(), kRemoteFrontendDomain);\n    if (url.is_valid() && DevToolsUIBindings::IsValidRemoteFrontendURL(url)) {\n      StartRemoteDataRequest(url, callback);\n    } else {\n      DLOG(ERROR) << \"Refusing to load invalid remote front-end URL\";\n      callback.Run(new base::RefCountedStaticMemory(kHttpNotFound,\n                                                    strlen(kHttpNotFound)));\n    }\n    return;\n  }\n\n  std::string custom_frontend_url =\n      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n          switches::kCustomDevtoolsFrontend);\n\n  if (custom_frontend_url.empty()) {\n    callback.Run(NULL);\n    return;\n  }\n\n  std::string custom_path_prefix(chrome::kChromeUIDevToolsCustomPath);\n  custom_path_prefix += \"/\";\n\n  if (base::StartsWith(path, custom_path_prefix,\n                        base::CompareCase::INSENSITIVE_ASCII)) {\n     GURL url = GURL(custom_frontend_url +\n                     path.substr(custom_path_prefix.length()));\n     StartCustomDataRequest(url, callback);\n     return;\n   }\n\n  callback.Run(NULL);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186832, "func": "bool PrintRenderFrameHelper::PrintPagesNative(blink::WebLocalFrame* frame,\n                                              int page_count) {\n  const PrintMsg_PrintPages_Params& params = *print_pages_params_;\n  const PrintMsg_Print_Params& print_params = params.params;\n\n  std::vector<int> printed_pages = GetPrintedPages(params, page_count);\n  if (printed_pages.empty())\n    return false;\n\n  PdfMetafileSkia metafile(print_params.printed_doc_type);\n  CHECK(metafile.Init());\n\n  for (int page_number : printed_pages) {\n    PrintPageInternal(print_params, page_number, page_count, frame, &metafile,\n                      nullptr, nullptr);\n  }\n\n  FinishFramePrinting();\n\n  metafile.FinishDocument();\n\n#if defined(OS_ANDROID)\n  int sequence_number = -1;\n  base::FileDescriptor fd;\n\n  Send(new PrintHostMsg_AllocateTempFileForPrinting(routing_id(), &fd,\n                                                    &sequence_number));\n  if (!SaveToFD(metafile, fd))\n    return false;\n\n  Send(new PrintHostMsg_TempFileForPrintingWritten(\n      routing_id(), sequence_number, printed_pages.size()));\n   return true;\n #else\n   PrintHostMsg_DidPrintDocument_Params page_params;\n  if (!CopyMetafileDataToSharedMem(metafile,\n                                   &page_params.metafile_data_handle)) {\n     return false;\n   }\n \n  page_params.data_size = metafile.GetDataSize();\n  page_params.document_cookie = print_params.document_cookie;\n  Send(new PrintHostMsg_DidPrintDocument(routing_id(), page_params));\n  return true;\n#endif  \n}\n", "target": 1, "flaw_line_index": "39,40"}
{"idx": 186356, "func": "bool IDNSpoofChecker::Check(base::StringPiece16 label) {\n   UErrorCode status = U_ZERO_ERROR;\n   int32_t result = uspoof_check(checker_, label.data(),\n                                 base::checked_cast<int32_t>(label.size()),\n                                NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n     return false;\n \n   result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII ||\n      (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n       kana_letters_exceptions_.containsNone(label_string)))\n    return true;\n \n  if (non_ascii_latin_letters_.containsSome(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            \"[^\\\\p{scx=kana}\\\\p{scx=hira}\\\\p{scx=hani}]\"\n            \"[\\\\u30ce\\\\u30f3\\\\u30bd\\\\u30be]\"\n            \"[^\\\\p{scx=kana}\\\\p{scx=hira}\\\\p{scx=hani}]|\"\n            \"[^\\\\p{scx=kana}\\\\p{scx=hira}]\\\\u30fc|\"\n            \"\\\\u30fc[^\\\\p{scx=kana}\\\\p{scx=hira}]|\"\n            \"^[\\\\p{scx=kana}]+[\\\\u3078-\\\\u307a][\\\\p{scx=kana}]+$|\"\n            \"^[\\\\p{scx=hira}]+[\\\\u30d8-\\\\u30da][\\\\p{scx=hira}]+$|\"\n            \"[a-z]\\\\u30fb|\\\\u30fb[a-z]|\"\n            \"^[\\\\u0585\\\\u0581]+[a-z]|[a-z][\\\\u0585\\\\u0581]+$|\"\n            \"[a-z][\\\\u0585\\\\u0581]+[a-z]|\"\n            \"^[og]+[\\\\p{scx=armn}]|[\\\\p{scx=armn}][og]+$|\"\n            \"[\\\\p{scx=armn}][og]+[\\\\p{scx=armn}]\", -1, US_INV),\n        0, status);\n    tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n   return !dangerous_pattern->find();\n }\n", "target": 1, "flaw_line_index": "29,30,31,36,37,38,39"}
{"idx": 7998, "func": "long vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen)\n{\n    long ret;\n#ifdef CONFIG_VNC_TLS\n    if (vs->tls.session) {\n        ret = vnc_client_read_tls(&vs->tls.session, data, datalen);\n    } else {\n#ifdef CONFIG_VNC_WS\n        if (vs->ws_tls.session) {\n            ret = vnc_client_read_tls(&vs->ws_tls.session, data, datalen);\n        } else\n#endif \n#endif \n        {\n            ret = qemu_recv(vs->csock, data, datalen, 0);\n        }\n#ifdef CONFIG_VNC_TLS\n    }\n#endif \n    VNC_DEBUG(\"Read wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, socket_error());\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7527, "func": "  sfnt_stream_close( FT_Stream  stream )\n  {\n    FT_Memory  memory = stream->memory;\n\n\n    FT_FREE( stream->base );\n\n    stream->size  = 0;\n    stream->base  = NULL;\n    stream->close = NULL;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7629, "func": "static int proxy_fsync(FsContext *ctx, int fid_type,\n                       V9fsFidOpenState *fs, int datasync)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n\n    if (datasync) {\n        return qemu_fdatasync(fd);\n    } else {\n        return fsync(fd);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186455, "func": "void ServiceWorkerContextCore::OnReportConsoleMessage(\n    ServiceWorkerVersion* version,\n    blink::mojom::ConsoleMessageSource source,\n    blink::mojom::ConsoleMessageLevel message_level,\n    const base::string16& message,\n    int line_number,\n     const GURL& source_url) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  const bool is_builtin_component = HasWebUIScheme(source_url);\n\n  LogConsoleMessage(ConsoleMessageLevelToLogSeverity(message_level), message,\n                    line_number, is_builtin_component, wrapper_->is_incognito(),\n                    base::UTF8ToUTF16(source_url.spec()));\n\n  observer_list_->Notify(\n      FROM_HERE, &ServiceWorkerContextCoreObserver::OnReportConsoleMessage,\n      version->version_id(),\n      ConsoleMessage(source, message_level, message, line_number, source_url));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7610, "func": "cirrus_vga_write_gr(CirrusVGAState * s, unsigned reg_index, int reg_value)\n{\n#if defined(DEBUG_BITBLT) && 0\n    printf(\"gr%02x: %02x\\n\", reg_index, reg_value);\n#endif\n    switch (reg_index) {\n    case 0x00:\t\t\t\n\ts->vga.gr[reg_index] = reg_value & gr_mask[reg_index];\n\ts->cirrus_shadow_gr0 = reg_value;\n\tbreak;\n    case 0x01:\t\t\t\n\ts->vga.gr[reg_index] = reg_value & gr_mask[reg_index];\n\ts->cirrus_shadow_gr1 = reg_value;\n\tbreak;\n    case 0x02:\t\t\t\n    case 0x03:\t\t\t\n    case 0x04:\t\t\t\n    case 0x06:\t\t\t\n    case 0x07:\t\t\t\n    case 0x08:\t\t\t\n\ts->vga.gr[reg_index] = reg_value & gr_mask[reg_index];\n        break;\n    case 0x05:\t\t\t\n\ts->vga.gr[reg_index] = reg_value & 0x7f;\n        cirrus_update_memory_access(s);\n\tbreak;\n    case 0x09:\t\t\t\n    case 0x0A:\t\t\t\n\ts->vga.gr[reg_index] = reg_value;\n\tcirrus_update_bank_ptr(s, 0);\n\tcirrus_update_bank_ptr(s, 1);\n        cirrus_update_memory_access(s);\n        break;\n    case 0x0B:\n\ts->vga.gr[reg_index] = reg_value;\n\tcirrus_update_bank_ptr(s, 0);\n\tcirrus_update_bank_ptr(s, 1);\n        cirrus_update_memory_access(s);\n\tbreak;\n    case 0x10:\t\t\t\n    case 0x11:\t\t\t\n    case 0x12:\t\t\t\n    case 0x13:\t\t\t\n    case 0x14:\t\t\t\n    case 0x15:\t\t\t\n    case 0x20:\t\t\t\n    case 0x22:\t\t\t\n    case 0x24:\t\t\t\n    case 0x26:\t\t\t\n    case 0x28:\t\t\t\n    case 0x29:\t\t\t\n    case 0x2c:\t\t\t\n    case 0x2d:\t\t\t\n    case 0x2f:                  \n    case 0x30:\t\t\t\n    case 0x32:\t\t\t\n    case 0x33:\t\t\t\n    case 0x34:\t\t\t\n    case 0x35:\t\t\t\n    case 0x38:\t\t\t\n    case 0x39:\t\t\t\n\ts->vga.gr[reg_index] = reg_value;\n\tbreak;\n    case 0x21:\t\t\t\n    case 0x23:\t\t\t\n    case 0x25:\t\t\t\n    case 0x27:\t\t\t\n\ts->vga.gr[reg_index] = reg_value & 0x1f;\n\tbreak;\n    case 0x2a:\t\t\t\n\ts->vga.gr[reg_index] = reg_value & 0x3f;\n        if (s->vga.gr[0x31] & CIRRUS_BLT_AUTOSTART) {\n            cirrus_bitblt_start(s);\n        }\n\tbreak;\n    case 0x2e:\t\t\t\n\ts->vga.gr[reg_index] = reg_value & 0x3f;\n\tbreak;\n    case 0x31:\t\t\t\n\tcirrus_write_bitblt(s, reg_value);\n\tbreak;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: outport gr_index %02x, gr_value %02x\\n\", reg_index,\n\t       reg_value);\n#endif\n\tbreak;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7591, "func": "static void cirrus_mmio_blt_write(CirrusVGAState * s, unsigned address,\n\t\t\t\t  uint8_t value)\n{\n    switch (address) {\n    case (CIRRUS_MMIO_BLTBGCOLOR + 0):\n\tcirrus_vga_write_gr(s, 0x00, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 1):\n\tcirrus_vga_write_gr(s, 0x10, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 2):\n\tcirrus_vga_write_gr(s, 0x12, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 3):\n\tcirrus_vga_write_gr(s, 0x14, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 0):\n\tcirrus_vga_write_gr(s, 0x01, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 1):\n\tcirrus_vga_write_gr(s, 0x11, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 2):\n\tcirrus_vga_write_gr(s, 0x13, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 3):\n\tcirrus_vga_write_gr(s, 0x15, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 0):\n\tcirrus_vga_write_gr(s, 0x20, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 1):\n\tcirrus_vga_write_gr(s, 0x21, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 0):\n\tcirrus_vga_write_gr(s, 0x22, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 1):\n\tcirrus_vga_write_gr(s, 0x23, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 0):\n\tcirrus_vga_write_gr(s, 0x24, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 1):\n\tcirrus_vga_write_gr(s, 0x25, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 0):\n\tcirrus_vga_write_gr(s, 0x26, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 1):\n\tcirrus_vga_write_gr(s, 0x27, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 0):\n\tcirrus_vga_write_gr(s, 0x28, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 1):\n\tcirrus_vga_write_gr(s, 0x29, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 2):\n\tcirrus_vga_write_gr(s, 0x2a, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 3):\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 0):\n\tcirrus_vga_write_gr(s, 0x2c, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 1):\n\tcirrus_vga_write_gr(s, 0x2d, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 2):\n\tcirrus_vga_write_gr(s, 0x2e, value);\n\tbreak;\n    case CIRRUS_MMIO_BLTWRITEMASK:\n\tcirrus_vga_write_gr(s, 0x2f, value);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODE:\n\tcirrus_vga_write_gr(s, 0x30, value);\n\tbreak;\n    case CIRRUS_MMIO_BLTROP:\n\tcirrus_vga_write_gr(s, 0x32, value);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODEEXT:\n\tcirrus_vga_write_gr(s, 0x33, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 0):\n\tcirrus_vga_write_gr(s, 0x34, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 1):\n\tcirrus_vga_write_gr(s, 0x35, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 0):\n\tcirrus_vga_write_gr(s, 0x38, value);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 1):\n\tcirrus_vga_write_gr(s, 0x39, value);\n\tbreak;\n    case CIRRUS_MMIO_BLTSTATUS:\n\tcirrus_vga_write_gr(s, 0x31, value);\n\tbreak;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: mmio write - addr 0x%04x val 0x%02x (ignored)\\n\",\n\t       address, value);\n#endif\n\tbreak;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7632, "func": "static int proxy_link(FsContext *ctx, V9fsPath *oldpath,\n                      V9fsPath *dirpath, const char *name)\n{\n    int retval;\n    V9fsString newpath;\n\n    v9fs_string_init(&newpath);\n    v9fs_string_sprintf(&newpath, \"%s/%s\", dirpath->data, name);\n\n    retval = v9fs_request(ctx->private, T_LINK, NULL, oldpath, &newpath);\n    v9fs_string_free(&newpath);\n    if (retval < 0) {\n        errno = -retval;\n        retval = -1;\n    }\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187312, "func": "_exsltDateTruncateDate (exsltDateValPtr dt, exsltDateType type)\n{\n    if (dt == NULL)\n        return 1;\n\n    if ((type & XS_TIME) != XS_TIME) {\n        dt->value.date.hour = 0;\n        dt->value.date.min  = 0;\n        dt->value.date.sec  = 0.0;\n     }\n \n     if ((type & XS_GDAY) != XS_GDAY)\n        dt->value.date.day = 0;\n \n     if ((type & XS_GMONTH) != XS_GMONTH)\n        dt->value.date.mon = 0;\n \n     if ((type & XS_GYEAR) != XS_GYEAR)\n         dt->value.date.year = 0;\n\n    dt->type = type;\n\n    return 0;\n}\n", "target": 1, "flaw_line_index": "13,16"}
{"idx": 7871, "func": "static int ram_save_page(QEMUFile *f, RAMBlock* block, ram_addr_t offset,\n                         bool last_stage)\n{\n    int bytes_sent;\n    int cont;\n    ram_addr_t current_addr;\n    MemoryRegion *mr = block->mr;\n    uint8_t *p;\n    int ret;\n    bool send_async = true;\n\n    cont = (block == last_sent_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n    p = memory_region_get_ram_ptr(mr) + offset;\n\n    bytes_sent = -1;\n    ret = ram_control_save_page(f, block->offset,\n                           offset, TARGET_PAGE_SIZE, &bytes_sent);\n\n    XBZRLE_cache_lock();\n\n    current_addr = block->offset + offset;\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n            if (bytes_sent > 0) {\n                acct_info.norm_pages++;\n            } else if (bytes_sent == 0) {\n                acct_info.dup_pages++;\n            }\n        }\n    } else if (is_zero_range(p, TARGET_PAGE_SIZE)) {\n        acct_info.dup_pages++;\n        bytes_sent = save_block_hdr(f, block, offset, cont,\n                                    RAM_SAVE_FLAG_COMPRESS);\n        qemu_put_byte(f, 0);\n        bytes_sent++;\n        xbzrle_cache_zero_page(current_addr);\n    } else if (!ram_bulk_stage && migrate_use_xbzrle()) {\n        bytes_sent = save_xbzrle_page(f, &p, current_addr, block,\n                                      offset, cont, last_stage);\n        if (!last_stage) {\n            send_async = false;\n        }\n    }\n\n    if (bytes_sent == -1) {\n        bytes_sent = save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n        if (send_async) {\n            qemu_put_buffer_async(f, p, TARGET_PAGE_SIZE);\n        } else {\n            qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n        }\n        bytes_sent += TARGET_PAGE_SIZE;\n        acct_info.norm_pages++;\n    }\n\n    XBZRLE_cache_unlock();\n\n    return bytes_sent;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8287, "func": "Rotation XRRRotations(Display *dpy, int screen, Rotation *current_rotation)\n{\n  XRRScreenConfiguration *config;\n  XExtDisplayInfo *info = XRRFindDisplay(dpy);\n  Rotation cr;\n  LockDisplay(dpy);\n  if ((config = _XRRValidateCache(dpy, info, screen))) {\n    *current_rotation = config->current_rotation;\n    cr = config->rotations;\n    UnlockDisplay(dpy);\n    return cr;\n  }\n  else {\n    UnlockDisplay(dpy);\n    *current_rotation = RR_Rotate_0;\n    return 0;\t\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186664, "func": "void ExternalProtocolHandler::LaunchUrlWithDelegate(\n    const GURL& url,\n    int render_process_host_id,\n    int render_view_routing_id,\n    ui::PageTransition page_transition,\n    bool has_user_gesture,\n    Delegate* delegate) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n \n   std::string escaped_url_string = net::EscapeExternalHandlerValue(url.spec());\n   GURL escaped_url(escaped_url_string);\n \n  content::WebContents* web_contents = tab_util::GetWebContentsByID(\n      render_process_host_id, render_view_routing_id);\n  Profile* profile = nullptr;\n  if (web_contents)  \n    profile = Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  BlockState block_state =\n      GetBlockStateWithDelegate(escaped_url.scheme(), delegate, profile);\n  if (block_state == BLOCK) {\n    if (delegate)\n      delegate->BlockRequest();\n    return;\n  }\n\n  g_accept_requests = false;\n\n   shell_integration::DefaultWebClientWorkerCallback callback = base::Bind(\n      &OnDefaultProtocolClientWorkerFinished, url, render_process_host_id,\n      render_view_routing_id, block_state == UNKNOWN, page_transition,\n      has_user_gesture, delegate);\n \n  CreateShellWorker(callback, escaped_url.scheme(), delegate)\n      ->StartCheckIsDefault();\n}\n", "target": 1, "flaw_line_index": "33,34,35"}
{"idx": 7835, "func": "void acct_update_position(QEMUFile *f, size_t size, bool zero)\n{\n    uint64_t pages = size / TARGET_PAGE_SIZE;\n    if (zero) {\n        acct_info.dup_pages += pages;\n    } else {\n        acct_info.norm_pages += pages;\n        bytes_transferred += size;\n        qemu_update_position(f, size);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7526, "func": "  sfnt_find_encoding( int  platform_id,\n                      int  encoding_id )\n  {\n    typedef struct  TEncoding_\n    {\n      int          platform_id;\n      int          encoding_id;\n      FT_Encoding  encoding;\n\n    } TEncoding;\n\n    static\n    const TEncoding  tt_encodings[] =\n    {\n      { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },\n\n      { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },\n\n      { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },\n\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_SJIS },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_PRC,        FT_ENCODING_PRC },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_BIG5 },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_WANSUNG },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_JOHAB }\n    };\n\n    const TEncoding  *cur, *limit;\n\n\n    cur   = tt_encodings;\n    limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );\n\n    for ( ; cur < limit; cur++ )\n    {\n      if ( cur->platform_id == platform_id )\n      {\n        if ( cur->encoding_id == encoding_id ||\n             cur->encoding_id == -1          )\n          return cur->encoding;\n      }\n    }\n\n    return FT_ENCODING_NONE;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7646, "func": "static ssize_t proxy_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n                              char *buf, size_t bufsz)\n{\n    int retval;\n    retval = v9fs_request(fs_ctx->private, T_READLINK, buf, fs_path, bufsz);\n    if (retval < 0) {\n        errno = -retval;\n        return -1;\n    }\n    return strlen(buf);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186530, "func": "base::string16 GetRelyingPartyIdString(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  static constexpr char kRpIdUrlPrefix[] = \"https:\n  static constexpr int kDialogWidth = 300;\n   const auto& rp_id = dialog_model->relying_party_id();\n   DCHECK(!rp_id.empty());\n   GURL rp_id_url(kRpIdUrlPrefix + rp_id);\n  auto max_static_string_length = gfx::GetStringWidthF(\n      l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(),\n      gfx::Typesetter::DEFAULT);\n  return url_formatter::ElideHost(rp_id_url, gfx::FontList(),\n                                  kDialogWidth - max_static_string_length);\n }\n", "target": 1, "flaw_line_index": "10,11,12,13,14"}
{"idx": 7744, "func": "  TT_Get_MM_Var( TT_Face      face,\n                 FT_MM_Var*  *master )\n  {\n    FT_Stream            stream = face->root.stream;\n    FT_Memory            memory = face->root.memory;\n    FT_ULong             table_len;\n    FT_Error             error  = TT_Err_Ok;\n    FT_ULong             fvar_start;\n    FT_Int               i, j;\n    FT_MM_Var*           mmvar;\n    FT_Fixed*            next_coords;\n    FT_String*           next_name;\n    FT_Var_Axis*         a;\n    FT_Var_Named_Style*  ns;\n    GX_FVar_Head         fvar_head;\n\n    static const FT_Frame_Field  fvar_fields[] =\n    {\n\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  GX_FVar_Head\n\n      FT_FRAME_START( 16 ),\n        FT_FRAME_LONG  ( version ),\n        FT_FRAME_USHORT( offsetToData ),\n        FT_FRAME_USHORT( countSizePairs ),\n        FT_FRAME_USHORT( axisCount ),\n        FT_FRAME_USHORT( axisSize ),\n        FT_FRAME_USHORT( instanceCount ),\n        FT_FRAME_USHORT( instanceSize ),\n      FT_FRAME_END\n    };\n\n    static const FT_Frame_Field  fvaraxis_fields[] =\n    {\n\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  GX_FVar_Axis\n\n      FT_FRAME_START( 20 ),\n        FT_FRAME_ULONG ( axisTag ),\n        FT_FRAME_ULONG ( minValue ),\n        FT_FRAME_ULONG ( defaultValue ),\n        FT_FRAME_ULONG ( maxValue ),\n        FT_FRAME_USHORT( flags ),\n        FT_FRAME_USHORT( nameID ),\n      FT_FRAME_END\n    };\n\n\n    if ( face->blend == NULL )\n    {\n      if ( (error = face->goto_table( face, TTAG_gvar,\n                                      stream, &table_len )) != 0 )\n        goto Exit;\n\n      if ( (error = face->goto_table( face, TTAG_fvar,\n                                      stream, &table_len )) != 0 )\n        goto Exit;\n\n      fvar_start = FT_STREAM_POS( );\n\n      if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )\n        goto Exit;\n\n      if ( fvar_head.version != (FT_Long)0x00010000L                      ||\n           fvar_head.countSizePairs != 2                                  ||\n           fvar_head.axisSize != 20                                       ||\n           fvar_head.axisCount > 0x3FFE                                   ||\n           fvar_head.instanceSize != 4 + 4 * fvar_head.axisCount          ||\n           fvar_head.instanceCount > 0x7EFF                               ||\n           fvar_head.offsetToData + fvar_head.axisCount * 20U +\n             fvar_head.instanceCount * fvar_head.instanceSize > table_len )\n      {\n        error = TT_Err_Invalid_Table;\n        goto Exit;\n      }\n\n      if ( FT_NEW( face->blend ) )\n        goto Exit;\n\n      face->blend->mmvar_len =\n        sizeof ( FT_MM_Var ) +\n        fvar_head.axisCount * sizeof ( FT_Var_Axis ) +\n        fvar_head.instanceCount * sizeof ( FT_Var_Named_Style ) +\n        fvar_head.instanceCount * fvar_head.axisCount * sizeof ( FT_Fixed ) +\n        5 * fvar_head.axisCount;\n\n      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n        goto Exit;\n      face->blend->mmvar = mmvar;\n\n      mmvar->num_axis =\n        fvar_head.axisCount;\n      mmvar->num_designs =\n        (FT_UInt)-1;           \n      mmvar->num_namedstyles =\n        fvar_head.instanceCount;\n      mmvar->axis =\n        (FT_Var_Axis*)&(mmvar[1]);\n      mmvar->namedstyle =\n        (FT_Var_Named_Style*)&(mmvar->axis[fvar_head.axisCount]);\n\n      next_coords =\n        (FT_Fixed*)&(mmvar->namedstyle[fvar_head.instanceCount]);\n      for ( i = 0; i < fvar_head.instanceCount; ++i )\n      {\n        mmvar->namedstyle[i].coords  = next_coords;\n        next_coords                 += fvar_head.axisCount;\n      }\n\n      next_name = (FT_String*)next_coords;\n      for ( i = 0; i < fvar_head.axisCount; ++i )\n      {\n        mmvar->axis[i].name  = next_name;\n        next_name           += 5;\n      }\n\n      if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )\n        goto Exit;\n\n      a = mmvar->axis;\n      for ( i = 0; i < fvar_head.axisCount; ++i )\n      {\n        GX_FVar_Axis  axis_rec;\n\n\n        if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )\n          goto Exit;\n        a->tag     = axis_rec.axisTag;\n        a->minimum = axis_rec.minValue;     \n        a->def     = axis_rec.defaultValue; \n        a->maximum = axis_rec.maxValue;     \n        a->strid   = axis_rec.nameID;\n\n        a->name[0] = (FT_String)(   a->tag >> 24 );\n        a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );\n        a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );\n        a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );\n        a->name[4] = 0;\n\n        ++a;\n      }\n\n      ns = mmvar->namedstyle;\n      for ( i = 0; i < fvar_head.instanceCount; ++i, ++ns )\n      {\n        if ( FT_FRAME_ENTER( 4L + 4L * fvar_head.axisCount ) )\n          goto Exit;\n\n        ns->strid       =    FT_GET_USHORT();\n        (void) \n FT_GET_USHORT();\n\n        for ( j = 0; j < fvar_head.axisCount; ++j )\n          ns->coords[j] = FT_GET_ULONG();     \n\n        FT_FRAME_EXIT();\n      }\n    }\n\n    if ( master != NULL )\n    {\n      FT_UInt  n;\n\n\n      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n        goto Exit;\n      FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );\n\n      mmvar->axis =\n        (FT_Var_Axis*)&(mmvar[1]);\n      mmvar->namedstyle =\n        (FT_Var_Named_Style*)&(mmvar->axis[mmvar->num_axis]);\n      next_coords =\n        (FT_Fixed*)&(mmvar->namedstyle[mmvar->num_namedstyles]);\n\n      for ( n = 0; n < mmvar->num_namedstyles; ++n )\n      {\n        mmvar->namedstyle[n].coords  = next_coords;\n        next_coords                 += mmvar->num_axis;\n      }\n\n      a = mmvar->axis;\n      next_name = (FT_String*)next_coords;\n      for ( n = 0; n < mmvar->num_axis; ++n )\n      {\n        a->name = next_name;\n\n        if ( a->tag == TTAG_wght )\n          a->name = (char *)\"Weight\";\n        else if ( a->tag == TTAG_wdth )\n          a->name = (char *)\"Width\";\n        else if ( a->tag == TTAG_opsz )\n          a->name = (char *)\"OpticalSize\";\n        else if ( a->tag == TTAG_slnt )\n          a->name = (char *)\"Slant\";\n\n        next_name += 5;\n        ++a;\n      }\n\n      *master = mmvar;\n    }\n\n  Exit:\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8019, "func": "int vnc_display_password(DisplayState *ds, const char *password)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs) {\n        return -EINVAL;\n    }\n    if (vs->auth == VNC_AUTH_NONE) {\n        error_printf_unless_qmp(\"If you want use passwords please enable \"\n                                \"password auth using '-vnc ${dpy},password'.\");\n        return -EINVAL;\n    }\n\n    g_free(vs->password);\n    vs->password = g_strdup(password);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7756, "func": "static void __h2_init(void)\n{\n\talpn_register_mux(&alpn_mux_h2);\n\tcfg_register_keywords(&cfg_kws);\n\thap_register_post_deinit(__h2_deinit);\n\tpool_head_h2c = create_pool(\"h2c\", sizeof(struct h2c), MEM_F_SHARED);\n\tpool_head_h2s = create_pool(\"h2s\", sizeof(struct h2s), MEM_F_SHARED);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8073, "func": "void Gfx::doAxialShFill(GfxAxialShading *shading) {\n  double xMin, yMin, xMax, yMax;\n  double x0, y0, x1, y1;\n  double dx, dy, mul;\n  GBool dxZero, dyZero;\n  double bboxIntersections[4];\n  double tMin, tMax, tx, ty;\n  double s[4], sMin, sMax, tmp;\n  double ux0, uy0, ux1, uy1, vx0, vy0, vx1, vy1;\n  double t0, t1, tt;\n  double ta[axialMaxSplits + 1];\n  int next[axialMaxSplits + 1];\n  GfxColor color0, color1;\n  int nComps;\n  int i, j, k;\n  GBool needExtend = gTrue;\n\n  state->getUserClipBBox(&xMin, &yMin, &xMax, &yMax);\n\n  shading->getCoords(&x0, &y0, &x1, &y1);\n  dx = x1 - x0;\n  dy = y1 - y0;\n  dxZero = fabs(dx) < 0.01;\n  dyZero = fabs(dy) < 0.01;\n  if (dxZero && dyZero) {\n    tMin = tMax = 0;\n  } else {\n    mul = 1 / (dx * dx + dy * dy);\n    bboxIntersections[0] = ((xMin - x0) * dx + (yMin - y0) * dy) * mul;\n    bboxIntersections[1] = ((xMin - x0) * dx + (yMax - y0) * dy) * mul;\n    bboxIntersections[2] = ((xMax - x0) * dx + (yMin - y0) * dy) * mul;\n    bboxIntersections[3] = ((xMax - x0) * dx + (yMax - y0) * dy) * mul;\n    bubbleSort(bboxIntersections);\n    tMin = bboxIntersections[0];\n    tMax = bboxIntersections[3];\n    if (tMin < 0 && !shading->getExtend0()) {\n      tMin = 0;\n    }\n    if (tMax > 1 && !shading->getExtend1()) {\n      tMax = 1;\n    }\n  }\n\n  if (out->useShadedFills() &&\n      out->axialShadedFill(state, shading, tMin, tMax)) {\n\t  return;\n  }\n\n  t0 = shading->getDomain0();\n  t1 = shading->getDomain1();\n\n\n  nComps = shading->getColorSpace()->getNComps();\n  ta[0] = tMin;\n  next[0] = axialMaxSplits / 2;\n  ta[axialMaxSplits / 2] = 0.5 * (tMin + tMax);\n  next[axialMaxSplits / 2] = axialMaxSplits;\n  ta[axialMaxSplits] = tMax;\n\n  if (tMin < 0) {\n    tt = t0;\n  } else if (tMin > 1) {\n    tt = t1;\n  } else {\n    tt = t0 + (t1 - t0) * tMin;\n  }\n  shading->getColor(tt, &color0);\n\n  if (out->useFillColorStop()) {\n    state->setFillColor(&color0);\n    out->updateFillColorStop(state, 0);\n  }\n\n  tx = x0 + tMin * dx;\n  ty = y0 + tMin * dy;\n  if (dxZero && dyZero) {\n    sMin = sMax = 0;\n  } else if (dxZero) {\n    sMin = (xMin - tx) / -dy;\n    sMax = (xMax - tx) / -dy;\n    if (sMin > sMax) { tmp = sMin; sMin = sMax; sMax = tmp; }\n  } else if (dyZero) {\n    sMin = (yMin - ty) / dx;\n    sMax = (yMax - ty) / dx;\n    if (sMin > sMax) { tmp = sMin; sMin = sMax; sMax = tmp; }\n  } else {\n    s[0] = (yMin - ty) / dx;\n    s[1] = (yMax - ty) / dx;\n    s[2] = (xMin - tx) / -dy;\n    s[3] = (xMax - tx) / -dy;\n    bubbleSort(s);\n    sMin = s[1];\n    sMax = s[2];\n  }\n  ux0 = tx - sMin * dy;\n  uy0 = ty + sMin * dx;\n  vx0 = tx - sMax * dy;\n  vy0 = ty + sMax * dx;\n\n  i = 0;\n  bool doneBBox1, doneBBox2;\n  if (dxZero && dyZero) {\n    doneBBox1 = doneBBox2 = true;\n  } else {\n    doneBBox1 = bboxIntersections[1] < tMin;\n    doneBBox2 = bboxIntersections[2] > tMax;\n  }\n\n  needExtend = !out->axialShadedSupportExtend(state, shading);\n\n  while (i < axialMaxSplits) {\n\n    j = next[i];\n    while (j > i + 1) {\n      if (ta[j] < 0) {\n\ttt = t0;\n      } else if (ta[j] > 1) {\n\ttt = t1;\n      } else {\n\ttt = t0 + (t1 - t0) * ta[j];\n      }\n      shading->getColor(tt, &color1);\n      if (isSameGfxColor(color1, color0, nComps, axialColorDelta)) {\n         if (!doneBBox1 && ta[i] < bboxIntersections[1] && ta[j] > bboxIntersections[1]) {\n           int teoricalj = (int) ((bboxIntersections[1] - tMin) * axialMaxSplits / (tMax - tMin));\n           if (teoricalj <= i) teoricalj = i + 1;\n           if (teoricalj < j) {\n             next[i] = teoricalj;\n             next[teoricalj] = j;\n           }\n           else {\n             teoricalj = j;\n           }\n           ta[teoricalj] = bboxIntersections[1];\n           j = teoricalj;\n           doneBBox1 = true;\n         }\n         if (!doneBBox2 && ta[i] < bboxIntersections[2] && ta[j] > bboxIntersections[2]) {\n           int teoricalj = (int) ((bboxIntersections[2] - tMin) * axialMaxSplits / (tMax - tMin));\n           if (teoricalj <= i) teoricalj = i + 1;\n           if (teoricalj < j) {\n             next[i] = teoricalj;\n             next[teoricalj] = j;\n           }\n           else {\n             teoricalj = j;\n           }\n           ta[teoricalj] = bboxIntersections[2];\n           j = teoricalj;\n           doneBBox2 = true;\n         }\n         break;\n      }\n      k = (i + j) / 2;\n      ta[k] = 0.5 * (ta[i] + ta[j]);\n      next[i] = k;\n      next[k] = j;\n      j = k;\n    }\n\n    for (k = 0; k < nComps; ++k) {\n      color0.c[k] = (color0.c[k] + color1.c[k]) / 2;\n    }\n\n    tx = x0 + ta[j] * dx;\n    ty = y0 + ta[j] * dy;\n    if (dxZero && dyZero) {\n      sMin = sMax = 0;\n    } else if (dxZero) {\n      sMin = (xMin - tx) / -dy;\n      sMax = (xMax - tx) / -dy;\n      if (sMin > sMax) { tmp = sMin; sMin = sMax; sMax = tmp; }\n    } else if (dyZero) {\n      sMin = (yMin - ty) / dx;\n      sMax = (yMax - ty) / dx;\n      if (sMin > sMax) { tmp = sMin; sMin = sMax; sMax = tmp; }\n    } else {\n      s[0] = (yMin - ty) / dx;\n      s[1] = (yMax - ty) / dx;\n      s[2] = (xMin - tx) / -dy;\n      s[3] = (xMax - tx) / -dy;\n      bubbleSort(s);\n      sMin = s[1];\n      sMax = s[2];\n    }\n    ux1 = tx - sMin * dy;\n    uy1 = ty + sMin * dx;\n    vx1 = tx - sMax * dy;\n    vy1 = ty + sMax * dx;\n\n    state->setFillColor(&color0);\n    if (out->useFillColorStop())\n      out->updateFillColorStop(state, (ta[j] - tMin)/(tMax - tMin));\n    else\n      out->updateFillColor(state);\n\n    if (needExtend) {\n      state->moveTo(ux0, uy0);\n      state->lineTo(vx0, vy0);\n      state->lineTo(vx1, vy1);\n      state->lineTo(ux1, uy1);\n      state->closePath();\n    }\n\n    if (!out->useFillColorStop()) {\n      if (!contentIsHidden())\n        out->fill(state);\n      state->clearPath();\n    }\n\n    ux0 = ux1;\n    uy0 = uy1;\n    vx0 = vx1;\n    vy0 = vy1;\n    color0 = color1;\n    i = next[i];\n  }\n\n  if (out->useFillColorStop()) {\n    if (!needExtend) {\n      state->moveTo(xMin, yMin);\n      state->lineTo(xMin, yMax);\n      state->lineTo(xMax, yMax);\n      state->lineTo(xMax, yMin);\n      state->closePath();\n    }\n    if (!contentIsHidden())\n      out->fill(state);\n    state->clearPath();\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7664, "func": "static int handle_chmod(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fchmod(fd, credp->fc_mode);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186520, "func": "PrefService* DataReductionProxySettings::GetOriginalProfilePrefs() {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return prefs_;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8193, "func": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n    xattr_fidp->fs.xattr.flags = flags;\n    v9fs_string_init(&xattr_fidp->fs.xattr.name);\n    v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    g_free(xattr_fidp->fs.xattr.value);\n    xattr_fidp->fs.xattr.value = g_malloc0(size);\n    err = offset;\n    put_fid(pdu, file_fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7914, "func": "static void cparams(JF, js_Ast *list)\n{\n\tF->numparams = listlength(list);\n\twhile (list) {\n\t\taddlocal(J, F, list->a, 0);\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7837, "func": "static void check_guest_throttling(void)\n{\n    static int64_t t0;\n    int64_t        t1;\n\n    if (!mig_throttle_on) {\n        return;\n    }\n\n    if (!t0)  {\n        t0 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n        return;\n    }\n\n    t1 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    if (40 < (t1-t0)/1000000) {\n        mig_throttle_guest_down();\n        t0 = t1;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186451, "func": "void RecordResourceCompletionUMA(bool image_complete,\n                                 bool css_complete,\n                                 bool xhr_complete) {\n  base::UmaHistogramBoolean(\"OfflinePages.Background.ResourceCompletion.Image\",\n                            image_complete);\n  base::UmaHistogramBoolean(\"OfflinePages.Background.ResourceCompletion.Css\",\n                            css_complete);\n  base::UmaHistogramBoolean(\"OfflinePages.Background.ResourceCompletion.Xhr\",\n                            xhr_complete);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10"}
{"idx": 186363, "func": "void LayerTreeHost::PushPropertiesTo(LayerTreeImpl* tree_impl) {\n  tree_impl->set_needs_full_tree_sync(needs_full_tree_sync_);\n  needs_full_tree_sync_ = false;\n\n  if (hud_layer_.get()) {\n    LayerImpl* hud_impl = tree_impl->LayerById(hud_layer_->id());\n    tree_impl->set_hud_layer(static_cast<HeadsUpDisplayLayerImpl*>(hud_impl));\n  } else {\n    tree_impl->set_hud_layer(nullptr);\n  }\n\n  tree_impl->set_background_color(background_color_);\n  tree_impl->set_has_transparent_background(has_transparent_background_);\n  tree_impl->set_have_scroll_event_handlers(have_scroll_event_handlers_);\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kTouchStartOrMove,\n      event_listener_properties(EventListenerClass::kTouchStartOrMove));\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kMouseWheel,\n      event_listener_properties(EventListenerClass::kMouseWheel));\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kTouchEndOrCancel,\n      event_listener_properties(EventListenerClass::kTouchEndOrCancel));\n\n  if (page_scale_layer_ && inner_viewport_scroll_layer_) {\n    tree_impl->SetViewportLayersFromIds(\n        overscroll_elasticity_layer_ ? overscroll_elasticity_layer_->id()\n                                     : Layer::INVALID_ID,\n        page_scale_layer_->id(), inner_viewport_scroll_layer_->id(),\n        outer_viewport_scroll_layer_ ? outer_viewport_scroll_layer_->id()\n                                     : Layer::INVALID_ID);\n    DCHECK(inner_viewport_scroll_layer_->IsContainerForFixedPositionLayers());\n  } else {\n    tree_impl->ClearViewportLayers();\n  }\n\n  tree_impl->RegisterSelection(selection_);\n\n  bool property_trees_changed_on_active_tree =\n      tree_impl->IsActiveTree() && tree_impl->property_trees()->changed;\n  if (root_layer_ && property_trees_changed_on_active_tree) {\n    if (property_trees_.sequence_number ==\n        tree_impl->property_trees()->sequence_number)\n      tree_impl->property_trees()->PushChangeTrackingTo(&property_trees_);\n    else\n      tree_impl->MoveChangeTrackingToLayers();\n  }\n  tree_impl->SetPropertyTrees(&property_trees_);\n\n  tree_impl->PushPageScaleFromMainThread(\n      page_scale_factor_, min_page_scale_factor_, max_page_scale_factor_);\n\n  tree_impl->set_browser_controls_shrink_blink_size(\n      browser_controls_shrink_blink_size_);\n  tree_impl->set_top_controls_height(top_controls_height_);\n  tree_impl->set_bottom_controls_height(bottom_controls_height_);\n  tree_impl->PushBrowserControlsFromMainThread(top_controls_shown_ratio_);\n  tree_impl->elastic_overscroll()->PushFromMainThread(elastic_overscroll_);\n  if (tree_impl->IsActiveTree())\n    tree_impl->elastic_overscroll()->PushPendingToActive();\n\n  tree_impl->set_painted_device_scale_factor(painted_device_scale_factor_);\n \n   tree_impl->SetDeviceColorSpace(device_color_space_);\n \n   if (pending_page_scale_animation_) {\n     tree_impl->SetPendingPageScaleAnimation(\n         std::move(pending_page_scale_animation_));\n  }\n\n  DCHECK(!tree_impl->ViewportSizeInvalid());\n\n  tree_impl->set_has_ever_been_drawn(false);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187054, "func": "void ImageBitmapFactories::Trace(blink::Visitor* visitor) {\n  visitor->Trace(pending_loaders_);\n  Supplement<LocalDOMWindow>::Trace(visitor);\n  Supplement<WorkerGlobalScope>::Trace(visitor);\n }\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 186989, "func": "bool DoCanonicalizePathComponent(const CHAR* source,\n                                  const Component& component,\n                                  char separator,\n                                  CanonOutput* output,\n                                  Component* new_component) {\n  bool success = true;\n   if (component.is_valid()) {\n     if (separator)\n       output->push_back(separator);\n    new_component->begin = output->length();\n    int end = component.end();\n     for (int i = component.begin; i < end; i++) {\n       UCHAR uch = static_cast<UCHAR>(source[i]);\n       if (uch < 0x20 || uch >= 0x80)\n        success &= AppendUTF8EscapedChar(source, &i, end, output);\n       else\n         output->push_back(static_cast<char>(uch));\n     }\n    new_component->len = output->length() - new_component->begin;\n  } else {\n     new_component->reset();\n   }\n  return success;\n }\n", "target": 1, "flaw_line_index": "6,18"}
{"idx": 7655, "func": "static int proxy_unlinkat(FsContext *ctx, V9fsPath *dir,\n                          const char *name, int flags)\n{\n    int ret;\n    V9fsString fullname;\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir->data, name);\n    ret = proxy_remove(ctx, fullname.data);\n    v9fs_string_free(&fullname);\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187201, "func": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n    const GURL& document_url,\n    std::string* error) {\n  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {\n    if (error)\n      *error = errors::kCannotScriptGallery;\n     return true;\n   }\n \n  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;\n  }\n\n  return false;\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 7834, "func": "static void acct_clear(void)\n{\n    memset(&acct_info, 0, sizeof(acct_info));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186467, "func": "ImageBitmap::ImageBitmap(ImageData* data,\n                         Optional<IntRect> cropRect,\n                         const ImageBitmapOptions& options) {\n  IntRect dataSrcRect = IntRect(IntPoint(), data->size());\n  ParsedOptions parsedOptions =\n      parseOptions(options, cropRect, data->bitmapSourceSize());\n  if (dstBufferSizeHasOverflow(parsedOptions))\n    return;\n  IntRect srcRect = cropRect ? intersection(parsedOptions.cropRect, dataSrcRect)\n                             : dataSrcRect;\n\n  if (!parsedOptions.premultiplyAlpha) {\n    unsigned char* srcAddr = data->data()->data();\n\n     SkImageInfo info = SkImageInfo::Make(\n         parsedOptions.cropRect.width(), parsedOptions.cropRect.height(),\n         kN32_SkColorType, kUnpremul_SkAlphaType);\n    size_t bytesPerPixel = static_cast<size_t>(info.bytesPerPixel());\n    size_t srcPixelBytesPerRow = bytesPerPixel * data->size().width();\n    size_t dstPixelBytesPerRow = bytesPerPixel * parsedOptions.cropRect.width();\n     sk_sp<SkImage> skImage;\n     if (parsedOptions.cropRect == IntRect(IntPoint(), data->size())) {\n       swizzleImageData(srcAddr, data->size().height(), srcPixelBytesPerRow,\n                       parsedOptions.flipY);\n      skImage =\n          SkImage::MakeRasterCopy(SkPixmap(info, srcAddr, dstPixelBytesPerRow));\n      swizzleImageData(srcAddr, data->size().height(), srcPixelBytesPerRow,\n                        parsedOptions.flipY);\n     } else {\n       RefPtr<ArrayBuffer> dstBuffer = ArrayBuffer::createOrNull(\n          static_cast<size_t>(parsedOptions.cropRect.height()) *\n               parsedOptions.cropRect.width(),\n           bytesPerPixel);\n       if (!dstBuffer)\n        return;\n      RefPtr<Uint8Array> copiedDataBuffer =\n          Uint8Array::create(dstBuffer, 0, dstBuffer->byteLength());\n      if (!srcRect.isEmpty()) {\n        IntPoint srcPoint = IntPoint(\n            (parsedOptions.cropRect.x() > 0) ? parsedOptions.cropRect.x() : 0,\n            (parsedOptions.cropRect.y() > 0) ? parsedOptions.cropRect.y() : 0);\n        IntPoint dstPoint = IntPoint(\n            (parsedOptions.cropRect.x() >= 0) ? 0 : -parsedOptions.cropRect.x(),\n            (parsedOptions.cropRect.y() >= 0) ? 0\n                                              : -parsedOptions.cropRect.y());\n        int copyHeight = data->size().height() - srcPoint.y();\n        if (parsedOptions.cropRect.height() < copyHeight)\n          copyHeight = parsedOptions.cropRect.height();\n        int copyWidth = data->size().width() - srcPoint.x();\n         if (parsedOptions.cropRect.width() < copyWidth)\n           copyWidth = parsedOptions.cropRect.width();\n         for (int i = 0; i < copyHeight; i++) {\n          size_t srcStartCopyPosition =\n               (i + srcPoint.y()) * srcPixelBytesPerRow +\n               srcPoint.x() * bytesPerPixel;\n          size_t srcEndCopyPosition =\n               srcStartCopyPosition + copyWidth * bytesPerPixel;\n          size_t dstStartCopyPosition;\n           if (parsedOptions.flipY)\n             dstStartCopyPosition =\n                 (parsedOptions.cropRect.height() - 1 - dstPoint.y() - i) *\n                    dstPixelBytesPerRow +\n                dstPoint.x() * bytesPerPixel;\n           else\n             dstStartCopyPosition = (dstPoint.y() + i) * dstPixelBytesPerRow +\n                                    dstPoint.x() * bytesPerPixel;\n          for (size_t j = 0; j < srcEndCopyPosition - srcStartCopyPosition;\n                j++) {\n             if (kN32_SkColorType == kBGRA_8888_SkColorType) {\n              if (j % 4 == 0)\n                copiedDataBuffer->data()[dstStartCopyPosition + j] =\n                    srcAddr[srcStartCopyPosition + j + 2];\n              else if (j % 4 == 2)\n                copiedDataBuffer->data()[dstStartCopyPosition + j] =\n                    srcAddr[srcStartCopyPosition + j - 2];\n              else\n                copiedDataBuffer->data()[dstStartCopyPosition + j] =\n                    srcAddr[srcStartCopyPosition + j];\n            } else {\n              copiedDataBuffer->data()[dstStartCopyPosition + j] =\n                  srcAddr[srcStartCopyPosition + j];\n            }\n          }\n        }\n      }\n      skImage = newSkImageFromRaster(info, std::move(copiedDataBuffer),\n                                     dstPixelBytesPerRow);\n    }\n    if (!skImage)\n      return;\n    if (parsedOptions.shouldScaleInput)\n      m_image = StaticBitmapImage::create(scaleSkImage(\n          skImage, parsedOptions.resizeWidth, parsedOptions.resizeHeight,\n          parsedOptions.resizeQuality));\n    else\n      m_image = StaticBitmapImage::create(skImage);\n    if (!m_image)\n      return;\n    m_image->setPremultiplied(parsedOptions.premultiplyAlpha);\n    return;\n  }\n\n  std::unique_ptr<ImageBuffer> buffer = ImageBuffer::create(\n      parsedOptions.cropRect.size(), NonOpaque, DoNotInitializeImagePixels);\n  if (!buffer)\n    return;\n\n  if (srcRect.isEmpty()) {\n    m_image = StaticBitmapImage::create(buffer->newSkImageSnapshot(\n        PreferNoAcceleration, SnapshotReasonUnknown));\n    return;\n  }\n\n  IntPoint dstPoint = IntPoint(std::min(0, -parsedOptions.cropRect.x()),\n                               std::min(0, -parsedOptions.cropRect.y()));\n  if (parsedOptions.cropRect.x() < 0)\n    dstPoint.setX(-parsedOptions.cropRect.x());\n  if (parsedOptions.cropRect.y() < 0)\n    dstPoint.setY(-parsedOptions.cropRect.y());\n  buffer->putByteArray(Unmultiplied, data->data()->data(), data->size(),\n                       srcRect, dstPoint);\n  sk_sp<SkImage> skImage =\n      buffer->newSkImageSnapshot(PreferNoAcceleration, SnapshotReasonUnknown);\n  if (parsedOptions.flipY)\n    skImage = flipSkImageVertically(skImage.get(), PremultiplyAlpha);\n  if (!skImage)\n    return;\n  if (parsedOptions.shouldScaleInput) {\n    sk_sp<SkSurface> surface = SkSurface::MakeRasterN32Premul(\n        parsedOptions.resizeWidth, parsedOptions.resizeHeight);\n    if (!surface)\n      return;\n    SkPaint paint;\n    paint.setFilterQuality(parsedOptions.resizeQuality);\n    SkRect dstDrawRect =\n        SkRect::MakeWH(parsedOptions.resizeWidth, parsedOptions.resizeHeight);\n    surface->getCanvas()->drawImageRect(skImage, dstDrawRect, &paint);\n    skImage = surface->makeImageSnapshot();\n  }\n  m_image = StaticBitmapImage::create(std::move(skImage));\n}\n", "target": 1, "flaw_line_index": "21,22,23,35,57,60,62,71"}
{"idx": 186782, "func": " bool VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::OutputPicture(\n     const scoped_refptr<VP8Picture>& pic) {\n   scoped_refptr<VaapiDecodeSurface> dec_surface =\n       VP8PictureToVaapiDecodeSurface(pic);\n   dec_surface->set_visible_rect(pic->visible_rect);\n  vaapi_dec_->SurfaceReady(dec_surface);\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8124, "func": "void Gfx::opEndPath(Object args[], int numArgs) {\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7812, "func": "static void h2s_destroy(struct h2s *h2s)\n{\n\th2s_close(h2s);\n\tLIST_DEL(&h2s->list);\n\tLIST_INIT(&h2s->list);\n\teb32_delete(&h2s->by_id);\n\tpool_free(pool_head_h2s, h2s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186589, "func": "  void OnReadAllMetadata(\n      const SessionStore::SessionInfo& session_info,\n      SessionStore::FactoryCompletionCallback callback,\n      std::unique_ptr<ModelTypeStore> store,\n       std::unique_ptr<ModelTypeStore::RecordList> record_list,\n       const base::Optional<syncer::ModelError>& error,\n       std::unique_ptr<syncer::MetadataBatch> metadata_batch) {\n     if (error) {\n       std::move(callback).Run(error, \nnullptr,\nnullptr);\n      return;\n    }\n\n    std::map<std::string, sync_pb::SessionSpecifics> initial_data;\n    for (ModelTypeStore::Record& record : *record_list) {\n      const std::string& storage_key = record.id;\n      SessionSpecifics specifics;\n      if (storage_key.empty() ||\n          !specifics.ParseFromString(std::move(record.value))) {\n        DVLOG(1) << \"Ignoring corrupt database entry with key: \" << storage_key;\n        continue;\n      }\n      initial_data[storage_key].Swap(&specifics);\n    }\n\n    auto session_store = std::make_unique<SessionStore>(\n        sessions_client_, session_info, std::move(store),\n        std::move(initial_data), metadata_batch->GetAllMetadata(),\n        restored_foreign_tab_callback_);\n\n    std::move(callback).Run(\nbase::nullopt, std::move(session_store),\n                            std::move(metadata_batch));\n  }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8050, "func": "static int vnc_update_client(VncState *vs, int has_dirty, bool sync)\n{\n    vs->has_dirty += has_dirty;\n    if (vs->need_update && vs->csock != -1) {\n        VncDisplay *vd = vs->vd;\n        VncJob *job;\n        int y;\n        int height, width;\n        int n = 0;\n\n        if (vs->output.offset && !vs->audio_cap && !vs->force_update)\n            return 0;\n\n        if (!vs->has_dirty && !vs->audio_cap && !vs->force_update)\n            return 0;\n\n        job = vnc_job_new(vs);\n\n        height = pixman_image_get_height(vd->server);\n        width = pixman_image_get_width(vd->server);\n\n        y = 0;\n        for (;;) {\n            int x, h;\n            unsigned long x2;\n            unsigned long offset = find_next_bit((unsigned long *) &vs->dirty,\n                                                 height * VNC_DIRTY_BPL(vs),\n                                                 y * VNC_DIRTY_BPL(vs));\n            if (offset == height * VNC_DIRTY_BPL(vs)) {\n                break;\n            }\n            y = offset / VNC_DIRTY_BPL(vs);\n            x = offset % VNC_DIRTY_BPL(vs);\n            x2 = find_next_zero_bit((unsigned long *) &vs->dirty[y],\n                                    VNC_DIRTY_BPL(vs), x);\n            bitmap_clear(vs->dirty[y], x, x2 - x);\n            h = find_and_clear_dirty_height(vs, y, x, x2, height);\n            x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);\n            if (x2 > x) {\n                n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,\n                                      (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);\n            }\n        }\n\n        vnc_job_push(job);\n        if (sync) {\n            vnc_jobs_join(vs);\n        }\n        vs->force_update = 0;\n        vs->has_dirty = 0;\n        return n;\n    }\n\n    if (vs->csock == -1) {\n        vnc_disconnect_finish(vs);\n    } else if (sync) {\n        vnc_jobs_join(vs);\n    }\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8186, "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n    rc = 0;\nout:\n    if (rc) {\n        g_free(s->ctx.fs_root);\n        g_free(s->tag);\n        v9fs_path_free(&path);\n    }\n    return rc;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186666, "func": "GURL SanitizeFrontendURL(const GURL& url,\n                         const std::string& scheme,\n                         const std::string& host,\n                         const std::string& path,\n                         bool allow_query_and_fragment) {\n  std::vector<std::string> query_parts;\n  std::string fragment;\n  if (allow_query_and_fragment) {\n    for (net::QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n      std::string value = SanitizeFrontendQueryParam(it.GetKey(),\n          it.GetValue());\n      if (!value.empty()) {\n        query_parts.push_back(\n             base::StringPrintf(\"%s=%s\", it.GetKey().c_str(), value.c_str()));\n       }\n     }\n    if (url.has_ref())\n       fragment = '#' + url.ref();\n   }\n   std::string query =\n      query_parts.empty() ? \"\" : \"?\" + base::JoinString(query_parts, \"&\");\n  std::string constructed =\n      base::StringPrintf(\"%s:\n                         path.c_str(), query.c_str(), fragment.c_str());\n  GURL result = GURL(constructed);\n  if (!result.is_valid())\n    return GURL();\n  return result;\n}\n", "target": 1, "flaw_line_index": "17"}
{"idx": 7931, "func": "static void emitraw(JF, int value)\n{\n\tif (value != (js_Instruction)value)\n\t\tjs_syntaxerror(J, \"integer overflow in instruction coding\");\n\tif (F->codelen >= F->codecap) {\n\t\tF->codecap = F->codecap ? F->codecap * 2 : 64;\n\t\tF->code = js_realloc(J, F->code, F->codecap * sizeof *F->code);\n\t}\n\tF->code[F->codelen++] = value;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8129, "func": "void Gfx::opLineTo(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    error(getPos(), \"No current point in lineto\");\n    return;\n  }\n  state->lineTo(args[0].getNum(), args[1].getNum());\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186922, "func": " bool XmlReader::LoadFile(const std::string& file_path) {\n   const int kParseOptions = XML_PARSE_RECOVER |  \n                            XML_PARSE_NONET |    \n                            XML_PARSE_NOXXE;     \n   reader_ = xmlReaderForFile(file_path.c_str(), NULL, kParseOptions);\n   return reader_ != NULL;\n }\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 8013, "func": "static void vnc_disconnect_start(VncState *vs)\n{\n    if (vs->csock == -1)\n        return;\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_DISCONNECTED);\n    qemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);\n    closesocket(vs->csock);\n    vs->csock = -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186703, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u044b\u0441\u0501\u0435\u050d\u04bb\u0456\u044e\u0458\u04cf\u043e\u0440\u0517\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n \n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n           \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01\u05d7] > n; \u0153 > ce;\"\n           \"[\u0167\u0442\u04ad\u050f\u4e03\u4e05\u4e06\u4e01] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n          \"[\u04ab\u1004] > c; [\u04b1\u4e2b] > y; [\u03c7\u04b3\u04fd\u04ff\u4e42] > x;\"\n          \"[\u0503\u10eb]  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0966\u09e6\u0a66\u0ae6\u0b20\u0b66\u0ce6] > o;\"\n          \"[\u09ed\u0a67\u0ae7] > q;\"\n          \"[\u0e1a\u0e9a] > u;\"\n          \"[\u03b8] > 0;\"\n          \"[\u0968\u09e8\u0a68\u0a68\u0ae8\u0ce9\u0ced\u0577] > 2;\"\n          \"[\u0437\u0499\u04e1\u0909\u0993\u0a24\u0a69\u0ae9\u0c69\u1012\u10d5\u10de] > 3;\"\n          \"[\u0a6b\u4e29\u3110] > 4;\"\n          \"[\u0573] > 6;\"\n          \"[\u09ea\u0a6a\u0b6b] > 8;\"\n          \"[\u0aed\u0b68\u0c68] > 9;\"\n          \"[\u2014\u4e00\u2015\u2e3a\u2e3b] > \\\\-;\"),\n      UTRANS_FORWARD, parse_error, status));\n  DCHECK(U_SUCCESS(status))\n      << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186993, "func": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    blink::MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false \n, std::string(),\n                            blink::MediaStreamDevice());\n    return;\n   }\n \n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, page_request_id, requester_id_,\n       device_id, type, std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n}\n", "target": 1, "flaw_line_index": "17"}
{"idx": 186971, "func": "  void Verify_StoreExistingGroup() {\n    EXPECT_TRUE(delegate()->stored_group_success_);\n    EXPECT_EQ(group_.get(), delegate()->stored_group_.get());\n    EXPECT_EQ(cache2_.get(), group_->newest_complete_cache());\n    EXPECT_TRUE(cache2_->is_complete());\n\n    AppCacheDatabase::GroupRecord group_record;\n    AppCacheDatabase::CacheRecord cache_record;\n    EXPECT_TRUE(database()->FindGroup(1, &group_record));\n    EXPECT_TRUE(database()->FindCache(2, &cache_record));\n\n     EXPECT_FALSE(database()->FindCache(1, &cache_record));\n \n    EXPECT_EQ(kDefaultEntrySize + 100, storage()->usage_map_[kOrigin]);\n     EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);\n     EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);\n    EXPECT_EQ(100, mock_quota_manager_proxy_->last_delta_);\n \n     TestFinished();\n   }\n", "target": 1, "flaw_line_index": "17,20"}
{"idx": 7705, "func": "static void coroutine_fn pdu_complete(V9fsPDU *pdu, ssize_t len)\n{\n    int8_t id = pdu->id + 1; \n    V9fsState *s = pdu->s;\n\n    if (len < 0) {\n        int err = -len;\n        len = 7;\n\n        if (s->proto_version != V9FS_PROTO_2000L) {\n            V9fsString str;\n\n            str.data = strerror(err);\n            str.size = strlen(str.data);\n\n            len += pdu_marshal(pdu, len, \"s\", &str);\n            id = P9_RERROR;\n        }\n\n        len += pdu_marshal(pdu, len, \"d\", err);\n\n        if (s->proto_version == V9FS_PROTO_2000L) {\n            id = P9_RLERROR;\n        }\n        trace_v9fs_rerror(pdu->tag, pdu->id, err); \n    }\n\n    pdu_marshal(pdu, 0, \"dbw\", (int32_t)len, id, pdu->tag);\n\n    pdu->size = len;\n    pdu->id = id;\n\n    pdu_push_and_notify(pdu);\n\n    if (!qemu_co_queue_next(&pdu->complete)) {\n        pdu_free(pdu);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186382, "func": "   std::unique_ptr<net::test_server::HttpResponse> GetConfigResponse(\n       const net::test_server::HttpRequest& request) {\n     auto response = std::make_unique<net::test_server::BasicHttpResponse>();\n     response->set_content(config_.SerializeAsString());\n     response->set_content_type(\"text/plain\");\n    if (config_run_loop_)\n      config_run_loop_->Quit();\n    return response;\n  }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8271, "func": "static int close_display(\n    Display *dpy,\n    XExtCodes *codes)\t\t\n{\n    XExtDisplayInfo *info = find_display (dpy);\n\n    LockDisplay(dpy);\n    if (info && info->data) {\n\tstruct mem_cache_str *cache = (struct mem_cache_str *)info->data;\n\tstruct intercept_queue *iq, *iq_next;\n\tstruct reply_buffer *rbp, **rbp_next_p;\n\n\tfor (iq=cache->inter_data; iq; iq=iq_next) {\n\t    iq_next = iq->next;\n\t    XFree(iq);\n\t    cache->inter_data_count--;\n\t}\n\n\tfor (rbp_next_p = &cache->reply_buffers; *rbp_next_p; ) {\n\t    rbp = *rbp_next_p;\n\t    if (rbp->ref_count == 0) {\n\t\t*rbp_next_p = rbp->next;\n\t\tXFree(rbp->buf);\n\t\tXFree(rbp);\n\t    } else {\n\t\trbp_next_p = &rbp->next;\n\t    }\n\t}\n\n\tif (cache->reply_buffers == NULL  &&  cache->inter_data_count == 0) {\n\t    XFree(cache);\n\t} else {\n\t    cache->display_closed = True;\n\t    cache->inter_data = NULL; \n\t}\n    }\n    UnlockDisplay(dpy);\n    return XextRemoveDisplay(xrecord_info, dpy);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7473, "func": "int fsetxattrat_nofollow(int dirfd, const char *filename, const char *name,\n                         void *value, size_t size, int flags)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = lsetxattr(proc_path, name, value, size, flags);\n    g_free(proc_path);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8039, "func": "static int vnc_refresh_lossy_rect(VncDisplay *vd, int x, int y)\n{\n    VncState *vs;\n    int sty = y / VNC_STAT_RECT;\n    int stx = x / VNC_STAT_RECT;\n    int has_dirty = 0;\n\n    y = y / VNC_STAT_RECT * VNC_STAT_RECT;\n    x = x / VNC_STAT_RECT * VNC_STAT_RECT;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        int j;\n\n        if (vs->output.offset) {\n            continue;\n        }\n\n        if (!vs->lossy_rect[sty][stx]) {\n            continue;\n        }\n\n        vs->lossy_rect[sty][stx] = 0;\n        for (j = 0; j < VNC_STAT_RECT; ++j) {\n            bitmap_set(vs->dirty[y + j],\n                       x / VNC_DIRTY_PIXELS_PER_BIT,\n                       VNC_STAT_RECT / VNC_DIRTY_PIXELS_PER_BIT);\n        }\n        has_dirty++;\n    }\n\n    return has_dirty;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7942, "func": "static void labelto(JF, int inst, int addr)\n{\n\tif (addr != (js_Instruction)addr)\n\t\tjs_syntaxerror(J, \"jump address integer overflow\");\n\tF->code[inst] = addr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186619, "func": "bool TestDataReductionProxyConfig::ShouldAddDefaultProxyBypassRules() const {\n  return add_default_proxy_bypass_rules_;\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186424, "func": " DevToolsUI::DevToolsUI(content::WebUI* web_ui)\n    : WebUIController(web_ui) {\n   web_ui->SetBindings(0);\n   Profile* profile = Profile::FromWebUI(web_ui);\n   content::URLDataSource::Add(\n       profile,\n       new DevToolsDataSource(profile->GetRequestContext()));\n \n  GURL url = web_ui->GetWebContents()->GetVisibleURL();\n  if (url.spec() != SanitizeFrontendURL(url).spec())\n     return;\n  if (profile->IsOffTheRecord()) {\n    GURL site = content::SiteInstance::GetSiteForURL(profile, url);\n    content::BrowserContext::GetStoragePartitionForSite(profile, site)->\n        GetFileSystemContext()->EnableTemporaryFileSystemInIncognito();\n  }\n  bindings_.reset(new DevToolsUIBindings(web_ui->GetWebContents()));\n }\n", "target": 1, "flaw_line_index": "2,9,10,12,13,14,15,16,17"}
{"idx": 187260, "func": " void ExtensionDevToolsClientHost::InfoBarDismissed() {\n   detach_reason_ = api::debugger::DETACH_REASON_CANCELED_BY_USER;\n   SendDetachedEvent();\n   Close();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8093, "func": "int Gfx::getPos() {\n  return parser ? parser->getPos() : -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7589, "func": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\t\t\t\t\t     unsigned mode,\n\t\t\t\t\t     unsigned offset,\n\t\t\t\t\t     uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (offset &= s->cirrus_addr_mask);\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t}\n\tval <<= 1;\n\tdst++;\n    }\n    memory_region_set_dirty(&s->vga.vram, offset, 8);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7980, "func": "uint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187259, "func": "ExtensionDevToolsClientHost::ExtensionDevToolsClientHost(\n    Profile* profile,\n    DevToolsAgentHost* agent_host,\n    const std::string& extension_id,\n    const std::string& extension_name,\n    const Debuggee& debuggee)\n     : profile_(profile),\n       agent_host_(agent_host),\n       extension_id_(extension_id),\n       last_request_id_(0),\n       infobar_(nullptr),\n       detach_reason_(api::debugger::DETACH_REASON_TARGET_CLOSED),\n      extension_registry_observer_(this) {\n  CopyDebuggee(&debuggee_, debuggee);\n\n  g_attached_client_hosts.Get().insert(this);\n\n  extension_registry_observer_.Add(ExtensionRegistry::Get(profile_));\n\n   registrar_.Add(this, chrome::NOTIFICATION_APP_TERMINATING,\n                  content::NotificationService::AllSources());\n \n  agent_host_->AttachClient(this);\n \n   if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n           ::switches::kSilentDebuggerExtensionAPI)) {\n    return;\n   }\n \n   const Extension* extension =\n      ExtensionRegistry::Get(profile)->enabled_extensions().GetByID(\n          extension_id);\n   if (extension && Manifest::IsPolicyLocation(extension->location()))\n    return;\n \n   infobar_ = ExtensionDevToolsInfoBar::Create(\n      extension_id, extension_name, this,\n       base::Bind(&ExtensionDevToolsClientHost::InfoBarDismissed,\n                  base::Unretained(this)));\n }\n", "target": 1, "flaw_line_index": "29,33,39,40"}
{"idx": 7888, "func": "int xen_available(void)\n{\n#ifdef CONFIG_XEN\n    return 1;\n#else\n    return 0;\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8098, "func": "GfxFont *GfxResources::lookupFont(char *name) {\n  GfxFont *font;\n  GfxResources *resPtr;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->fonts) {\n      if ((font = resPtr->fonts->lookup(name)))\n\treturn font;\n    }\n  }\n  error(-1, \"Unknown font tag '%s'\", name);\n  return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187087, "func": " void MediaStreamManager::GenerateStream(\n     int render_process_id,\n     int render_frame_id,\n     int page_request_id,\n     const StreamControls& controls,\n     MediaDeviceSaltAndOrigin salt_and_origin,\n    bool user_gesture,\n    GenerateStreamCallback generate_stream_cb,\n    DeviceStoppedCallback device_stopped_cb,\n    DeviceChangedCallback device_changed_cb) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   DVLOG(1) << \"GenerateStream()\";\n \n   DeviceRequest* request = new DeviceRequest(\n      render_process_id, render_frame_id, page_request_id, user_gesture,\n      MEDIA_GENERATE_STREAM, controls, std::move(salt_and_origin),\n       std::move(device_stopped_cb));\n   request->device_changed_cb = std::move(device_changed_cb);\n \n  const std::string& label = AddRequest(request);\n\n  request->generate_stream_cb = std::move(generate_stream_cb);\n\n  if (generate_stream_test_callback_) {\n    if (std::move(generate_stream_test_callback_).Run(controls)) {\n      FinalizeGenerateStream(label, request);\n    } else {\n      FinalizeRequestFailed(label, request, MEDIA_DEVICE_INVALID_STATE);\n    }\n    return;\n  }\n\n  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},\n                           base::BindOnce(&MediaStreamManager::SetUpRequest,\n                                          base::Unretained(this), label));\n}\n", "target": 1, "flaw_line_index": "15,16"}
{"idx": 8097, "func": "void GfxResources::lookupColorSpace(char *name, Object *obj) {\n  GfxResources *resPtr;\n\n  for (resPtr = this; resPtr; resPtr = resPtr->next) {\n    if (resPtr->colorSpaceDict.isDict()) {\n      if (!resPtr->colorSpaceDict.dictLookup(name, obj)->isNull()) {\n\treturn;\n      }\n      obj->free();\n    }\n  }\n  obj->initNull();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186531, "func": " void TestGamepadCompleteDataImpl(WebXrVrBrowserTestBase* t) {\n   WebXrControllerInputMock my_mock;\n \n   uint64_t supported_buttons =\n       device::XrButtonMaskFromId(device::XrButtonId::kAxisTrigger) |\n       device::XrButtonMaskFromId(device::XrButtonId::kAxisPrimary) |\n      device::XrButtonMaskFromId(device::XrButtonId::kAxisSecondary) |\n      device::XrButtonMaskFromId(device::XrButtonId::kGrip);\n\n  std::map<device::XrButtonId, unsigned int> axis_types = {\n      {device::XrButtonId::kAxisPrimary, t->GetPrimaryAxisType()},\n      {device::XrButtonId::kAxisTrigger, device::XrAxisType::kTrigger},\n      {device::XrButtonId::kAxisSecondary, t->GetSecondaryAxisType()},\n  };\n\n  unsigned int controller_index = my_mock.CreateAndConnectController(\n      device::ControllerRole::kControllerRoleRight, axis_types,\n      supported_buttons);\n\n  t->LoadUrlAndAwaitInitialization(\n      t->GetFileUrlForHtmlTestFile(\"test_webxr_gamepad_support\"));\n  t->EnterSessionWithUserGestureOrFail();\n\n  my_mock.SetAxes(controller_index, device::XrButtonId::kAxisSecondary, 0.25,\n                  -0.25);\n\n  my_mock.ToggleButtonTouches(\n      controller_index,\n      device::XrButtonMaskFromId(device::XrButtonId::kAxisSecondary));\n\n  my_mock.ToggleButtons(controller_index,\n                        device::XrButtonMaskFromId(device::XrButtonId::kGrip));\n\n   t->PollJavaScriptBooleanOrFail(\"isMappingEqualTo('xr-standard')\",\n                                  WebVrBrowserTestBase::kPollTimeoutShort);\n \n   t->PollJavaScriptBooleanOrFail(\"areAxesValuesEqualTo(1, 0.25, -0.25)\",\n                                  WebVrBrowserTestBase::kPollTimeoutShort);\n\n  t->PollJavaScriptBooleanOrFail(\"isButtonPressedEqualTo(2, true)\",\n                                 WebVrBrowserTestBase::kPollTimeoutShort);\n\n  t->PollJavaScriptBooleanOrFail(\"isButtonPressedEqualTo(3, false)\",\n                                 WebVrBrowserTestBase::kPollTimeoutShort);\n  t->PollJavaScriptBooleanOrFail(\"isButtonTouchedEqualTo(3, true)\",\n                                 WebVrBrowserTestBase::kPollTimeoutShort);\n\n  t->RunJavaScriptOrFail(\"done()\");\n  t->EndTest();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8012, "func": "void vnc_disconnect_finish(VncState *vs)\n{\n    int i;\n\n    vnc_jobs_join(vs); \n\n    vnc_lock_output(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n#ifdef CONFIG_VNC_WS\n    buffer_free(&vs->ws_input);\n    buffer_free(&vs->ws_output);\n#endif \n\n    qapi_free_VncClientInfo(vs->info);\n\n    vnc_zlib_clear(vs);\n    vnc_tight_clear(vs);\n    vnc_zrle_clear(vs);\n\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif \n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif \n    audio_del(vs);\n    vnc_release_modifiers(vs);\n\n    if (vs->initialized) {\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    }\n\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    vnc_unlock_output(vs);\n\n    qemu_mutex_destroy(&vs->output_mutex);\n    if (vs->bh != NULL) {\n        qemu_bh_delete(vs->bh);\n    }\n    buffer_free(&vs->jobs_buffer);\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        g_free(vs->lossy_rect[i]);\n    }\n    g_free(vs->lossy_rect);\n    g_free(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186373, "func": " void PrintViewManager::RenderFrameDeleted(\n     content::RenderFrameHost* render_frame_host) {\n   if (render_frame_host == print_preview_rfh_)\n    print_preview_state_ = NOT_PREVIEWING;\n   PrintViewManagerBase::RenderFrameDeleted(render_frame_host);\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186872, "func": " void ParamTraits<SkBitmap>::Write(base::Pickle* m, const SkBitmap& p) {\n  size_t fixed_size = sizeof(SkBitmap_Data);\n  SkBitmap_Data bmp_data;\n  bmp_data.InitSkBitmapDataForTransfer(p);\n  m->WriteData(reinterpret_cast<const char*>(&bmp_data),\n               static_cast<int>(fixed_size));\n   size_t pixel_size = p.computeByteSize();\n   m->WriteData(reinterpret_cast<const char*>(p.getPixels()),\n                static_cast<int>(pixel_size));\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7928, "func": "static void emitline(JF, js_Ast *node)\n{\n\tif (F->lastline != node->line) {\n\t\tF->lastline = node->line;\n\t\temit(J, F, OP_LINE);\n\t\temitraw(J, F, node->line);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7935, "func": "static int isfun(enum js_AstType T)\n{\n\treturn T == AST_FUNDEC || T == EXP_FUN || T == EXP_PROP_GET || T == EXP_PROP_SET;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186392, "func": "void WarmupURLFetcher::FetchWarmupURL(\n     size_t previous_attempt_counts,\n     const DataReductionProxyServer& proxy_server) {\n   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n \n   previous_attempt_counts_ = previous_attempt_counts;\n \n  DCHECK_LE(0u, previous_attempt_counts_);\n  DCHECK_GE(2u, previous_attempt_counts_);\n\n  fetch_delay_timer_.Stop();\n\n  if (previous_attempt_counts_ == 0) {\n    FetchWarmupURLNow(proxy_server);\n    return;\n  }\n  fetch_delay_timer_.Start(\n      FROM_HERE, GetFetchWaitTime(),\n      base::BindOnce(&WarmupURLFetcher::FetchWarmupURLNow,\n                     base::Unretained(this), proxy_server));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7576, "func": "static void cirrus_cursor_draw_line(VGACommonState *s1, uint8_t *d1, int scr_y)\n{\n    CirrusVGAState *s = container_of(s1, CirrusVGAState, vga);\n    int w, h, x1, x2, poffset;\n    unsigned int color0, color1;\n    const uint8_t *palette, *src;\n    uint32_t content;\n\n    if (!(s->vga.sr[0x12] & CIRRUS_CURSOR_SHOW))\n        return;\n    if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE) {\n        h = 64;\n    } else {\n        h = 32;\n    }\n    if (scr_y < s->hw_cursor_y ||\n        scr_y >= (s->hw_cursor_y + h))\n        return;\n\n    src = s->vga.vram_ptr + s->real_vram_size - 16 * 1024;\n    if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE) {\n        src += (s->vga.sr[0x13] & 0x3c) * 256;\n        src += (scr_y - s->hw_cursor_y) * 16;\n        poffset = 8;\n        content = ((uint32_t *)src)[0] |\n            ((uint32_t *)src)[1] |\n            ((uint32_t *)src)[2] |\n            ((uint32_t *)src)[3];\n    } else {\n        src += (s->vga.sr[0x13] & 0x3f) * 256;\n        src += (scr_y - s->hw_cursor_y) * 4;\n\n\n        poffset = 128;\n        content = ((uint32_t *)src)[0] |\n            ((uint32_t *)(src + 128))[0];\n    }\n    if (!content)\n        return;\n    w = h;\n\n    x1 = s->hw_cursor_x;\n    if (x1 >= s->vga.last_scr_width)\n        return;\n    x2 = s->hw_cursor_x + w;\n    if (x2 > s->vga.last_scr_width)\n        x2 = s->vga.last_scr_width;\n    w = x2 - x1;\n    palette = s->cirrus_hidden_palette;\n    color0 = rgb_to_pixel32(c6_to_8(palette[0x0 * 3]),\n                            c6_to_8(palette[0x0 * 3 + 1]),\n                            c6_to_8(palette[0x0 * 3 + 2]));\n    color1 = rgb_to_pixel32(c6_to_8(palette[0xf * 3]),\n                            c6_to_8(palette[0xf * 3 + 1]),\n                            c6_to_8(palette[0xf * 3 + 2]));\n    d1 += x1 * 4;\n    vga_draw_cursor_line(d1, src, poffset, w, color0, color1, 0xffffff);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7729, "func": "void v9fs_path_copy(V9fsPath *lhs, V9fsPath *rhs)\n{\n    v9fs_path_free(lhs);\n    lhs->data = g_malloc(rhs->size);\n    memcpy(lhs->data, rhs->data, rhs->size);\n    lhs->size = rhs->size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8201, "func": "static int free_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    int retval = 0;\n\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd != -1) {\n            retval = v9fs_co_close(pdu, &fidp->fs);\n        }\n    } else if (fidp->fid_type == P9_FID_DIR) {\n        if (fidp->fs.dir.stream != NULL) {\n            retval = v9fs_co_closedir(pdu, &fidp->fs);\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        retval = v9fs_xattr_fid_clunk(pdu, fidp);\n    }\n    v9fs_path_free(&fidp->path);\n    g_free(fidp);\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7676, "func": "static int handle_lsetxattr(FsContext *ctx, V9fsPath *fs_path, const char *name,\n                            void *value, size_t size, int flags)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fsetxattr(fd, name, value, size, flags);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186921, "func": " bool XmlReader::Load(const std::string& input) {\n   const int kParseOptions = XML_PARSE_RECOVER |  \n                            XML_PARSE_NONET |    \n                            XML_PARSE_NOXXE;     \n   reader_ = xmlReaderForMemory(input.data(), static_cast<int>(input.size()),\n                               NULL, NULL, kParseOptions);\n  return reader_ != NULL;\n}\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 187269, "func": " DevToolsSession::DevToolsSession(DevToolsAgentHostImpl* agent_host,\n                                 DevToolsAgentHostClient* client)\n     : binding_(this),\n       agent_host_(agent_host),\n       client_(client),\n       process_host_id_(ChildProcessHost::kInvalidUniqueID),\n       host_(nullptr),\n       dispatcher_(new protocol::UberDispatcher(this)),\n      weak_factory_(this) {\n  dispatcher_->setFallThroughForNotFound(true);\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7833, "func": "static void XBZRLE_cache_unlock(void)\n{\n    if (migrate_use_xbzrle())\n        qemu_mutex_unlock(&XBZRLE.lock);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186620, "func": "void HttpAuthFilterWhitelist::AddRuleToBypassLocal() {\n  rules_.AddRuleToBypassLocal();\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 187012, "func": "void HTMLFormElement::ScheduleFormSubmission(FormSubmission* submission) {\n  DCHECK(submission->Method() == FormSubmission::kPostMethod ||\n         submission->Method() == FormSubmission::kGetMethod);\n  DCHECK(submission->Data());\n  DCHECK(submission->Form());\n  if (submission->Action().IsEmpty())\n    return;\n  if (GetDocument().IsSandboxed(kSandboxForms)) {\n    GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n        kSecurityMessageSource, kErrorMessageLevel,\n        \"Blocked form submission to '\" + submission->Action().ElidedString() +\n            \"' because the form's frame is sandboxed and the 'allow-forms' \"\n            \"permission is not set.\"));\n    return;\n  }\n\n  if (!GetDocument().GetContentSecurityPolicy()->AllowFormAction(\n          submission->Action())) {\n    return;\n  }\n\n  if (submission->Action().ProtocolIsJavaScript()) {\n    GetDocument()\n        .GetFrame()\n        ->GetScriptController()\n        .ExecuteScriptIfJavaScriptURL(submission->Action(), this);\n    return;\n  }\n\n  Frame* target_frame = GetDocument().GetFrame()->FindFrameForNavigation(\n      submission->Target(), *GetDocument().GetFrame(),\n      submission->RequestURL());\n  if (!target_frame) {\n    target_frame = GetDocument().GetFrame();\n  } else {\n    submission->ClearTarget();\n  }\n  if (!target_frame->GetPage())\n    return;\n\n  UseCounter::Count(GetDocument(), WebFeature::kFormsSubmitted);\n  if (MixedContentChecker::IsMixedFormAction(GetDocument().GetFrame(),\n                                             submission->Action())) {\n    UseCounter::Count(GetDocument().GetFrame(),\n                      WebFeature::kMixedContentFormsSubmitted);\n  }\n\n  if (target_frame->IsLocalFrame()) {\n    ToLocalFrame(target_frame)\n        ->GetNavigationScheduler()\n        .ScheduleFormSubmission(&GetDocument(), submission);\n   } else {\n     FrameLoadRequest frame_load_request =\n         submission->CreateFrameLoadRequest(&GetDocument());\n     ToRemoteFrame(target_frame)->Navigate(frame_load_request);\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7874, "func": "static int ram_save_setup(QEMUFile *f, void *opaque)\n{\n    RAMBlock *block;\n    int64_t ram_bitmap_pages; \n\n    mig_throttle_on = false;\n    dirty_rate_high_cnt = 0;\n    bitmap_sync_count = 0;\n\n    if (migrate_use_xbzrle()) {\n        XBZRLE_cache_lock();\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size() /\n                                  TARGET_PAGE_SIZE,\n                                  TARGET_PAGE_SIZE);\n        if (!XBZRLE.cache) {\n            XBZRLE_cache_unlock();\n            error_report(\"Error creating cache\");\n            return -1;\n        }\n        XBZRLE_cache_unlock();\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n        if (!XBZRLE.encoded_buf) {\n            error_report(\"Error allocating encoded_buf\");\n            return -1;\n        }\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n        if (!XBZRLE.current_buf) {\n            error_report(\"Error allocating current_buf\");\n            g_free(XBZRLE.encoded_buf);\n            XBZRLE.encoded_buf = NULL;\n            return -1;\n        }\n\n        acct_clear();\n    }\n\n    qemu_mutex_lock_iothread();\n    qemu_mutex_lock_ramlist();\n    bytes_transferred = 0;\n    reset_ram_globals();\n\n    ram_bitmap_pages = last_ram_offset() >> TARGET_PAGE_BITS;\n    migration_bitmap = bitmap_new(ram_bitmap_pages);\n    bitmap_set(migration_bitmap, 0, ram_bitmap_pages);\n\n    migration_dirty_pages = 0;\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        uint64_t block_pages;\n\n        block_pages = block->length >> TARGET_PAGE_BITS;\n        migration_dirty_pages += block_pages;\n    }\n\n    memory_global_dirty_log_start();\n    migration_bitmap_sync();\n    qemu_mutex_unlock_iothread();\n\n    qemu_put_be64(f, ram_bytes_total() | RAM_SAVE_FLAG_MEM_SIZE);\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        qemu_put_byte(f, strlen(block->idstr));\n        qemu_put_buffer(f, (uint8_t *)block->idstr, strlen(block->idstr));\n        qemu_put_be64(f, block->length);\n    }\n\n    qemu_mutex_unlock_ramlist();\n\n    ram_control_before_iterate(f, RAM_CONTROL_SETUP);\n    ram_control_after_iterate(f, RAM_CONTROL_SETUP);\n\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8128, "func": "void Gfx::opImageData(Object args[], int numArgs) {\n  error(getPos(), \"Internal: got 'ID' operator\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7792, "func": "static int h2c_frt_handle_data(struct h2c *h2c, struct h2s *h2s)\n{\n\tint error;\n\n\n\tif (!h2c->dbuf->size && h2c->dfl)\n\t\treturn 0; \n\n\tif (h2c->dbuf->i < h2c->dfl && h2c->dbuf->i < h2c->dbuf->size)\n\t\treturn 0; \n\n\n\tif (!h2c->dsi) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2s->st != H2_SS_OPEN && h2s->st != H2_SS_HLOC) {\n\t\terror = H2_ERR_STREAM_CLOSED;\n\t\tgoto strm_err;\n\t}\n\n\tif (!h2s->cs) {\n\t\terror = H2_ERR_STREAM_CLOSED;\n\t\tgoto strm_err;\n\t}\n\n\th2s->cs->data_cb->recv(h2s->cs);\n\n\tif (h2s->cs->data_cb->wake(h2s->cs) < 0) {\n\t\terror = H2_ERR_STREAM_CLOSED;\n\t\tgoto strm_err;\n\t}\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn 0;\n\n\tif (h2s->st >= H2_SS_ERROR) {\n\t\th2c->st0 = H2_CS_FRAME_E;\n\t}\n\n\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\treturn 0;\n\n\n\tif (h2c->dff & H2_F_DATA_END_STREAM) {\n\t\th2s->st = H2_SS_HREM;\n\t\th2s->flags |= H2_SF_ES_RCVD;\n\t}\n\n\treturn 1;\n\n conn_err:\n\th2c_error(h2c, error);\n\treturn 0;\n\n strm_err:\n\tif (h2s) {\n\t\th2s_error(h2s, error);\n\t\th2c->st0 = H2_CS_FRAME_E;\n\t}\n\telse\n\t\th2c_error(h2c, error);\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186440, "func": "ResourceRequestBlockedReason BaseFetchContext::CanRequest(\n    Resource::Type type,\n    const ResourceRequest& resource_request,\n    const KURL& url,\n    const ResourceLoaderOptions& options,\n    SecurityViolationReportingPolicy reporting_policy,\n    FetchParameters::OriginRestriction origin_restriction,\n    ResourceRequest::RedirectStatus redirect_status) const {\n  ResourceRequestBlockedReason blocked_reason =\n      CanRequestInternal(type, resource_request, url, options, reporting_policy,\n                         origin_restriction, redirect_status);\n   if (blocked_reason != ResourceRequestBlockedReason::kNone &&\n       reporting_policy == SecurityViolationReportingPolicy::kReport) {\n     DispatchDidBlockRequest(resource_request, options.initiator_info,\n                            blocked_reason);\n   }\n   return blocked_reason;\n }\n", "target": 1, "flaw_line_index": "15"}
{"idx": 7838, "func": "void cpudef_init(void)\n{\n#if defined(cpudef_setup)\n    cpudef_setup(); \n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186708, "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u0527\u0529] > h;\"\n                                   \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u0167\u0442\u04ad] > t;\"\n                                    \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449] > w; [\u043c\u04ce] > m;\"\n                                   \"\u043f > n; [\u0454\u04bd\u04bf] > e; \u0491 > r; \u0493 > f; \u04ab > c;\"\n                                    \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                    \"\u04cf > l;\"\n #endif\n                                   \"\u0503  > d; \u050d > g; \u0d1f > s\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7493, "func": "generate_outer (DBusMessageDataIter   *iter,\n                DBusString            *data,\n                DBusValidity          *expected_validity,\n                DBusInnerGeneratorFunc func)\n{\n  DBusMessage *message;\n\n  message = NULL;\n  if (!(*func)(iter, &message))\n    return FALSE;\n\n  iter_next (iter);\n  \n  _dbus_assert (message != NULL);\n\n  generate_from_message (data, expected_validity, message);\n\n  dbus_message_unref (message);\n\n  return TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8189, "func": "static void coroutine_fn v9fs_rename(void *opaque)\n{\n    int32_t fid;\n    ssize_t err = 0;\n    size_t offset = 7;\n    V9fsString name;\n    int32_t newdirfid;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newdirfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EISDIR;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out;\n    }\n    v9fs_path_write_lock(s);\n    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);\n    v9fs_path_unlock(s);\n    if (!err) {\n        err = offset;\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7984, "func": "static void send_ext_key_event_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           pixman_image_get_width(vs->vd->server),\n                           pixman_image_get_height(vs->vd->server),\n                           VNC_ENCODING_EXT_KEY_EVENT);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7999, "func": "static long vnc_client_read_plain(VncState *vs)\n{\n    int ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7500, "func": "iter_set_sequence (DBusMessageDataIter *iter,\n                   int                  sequence)\n{\n  _dbus_assert (sequence >= 0);\n  iter->sequence_nos[iter->depth] = sequence;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187248, "func": "void RenderWidgetHostImpl::WasShown(const ui::LatencyInfo& latency_info) {\n  if (!is_hidden_)\n    return;\n\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::WasShown\");\n  is_hidden_ = false;\n \n  if (new_content_rendering_timeout_ &&\n      new_content_rendering_timeout_->IsRunning()) {\n    new_content_rendering_timeout_->Stop();\n    ClearDisplayedGraphics();\n  }\n \n   SendScreenRects();\n   RestartHangMonitorTimeoutIfNecessary();\n\n  bool needs_repainting = true;\n  needs_repainting_on_restore_ = false;\n  Send(new ViewMsg_WasShown(routing_id_, needs_repainting, latency_info));\n\n  process_->WidgetRestored();\n\n  bool is_visible = true;\n  NotificationService::current()->Notify(\n      NOTIFICATION_RENDER_WIDGET_VISIBILITY_CHANGED,\n      Source<RenderWidgetHost>(this),\n      Details<bool>(&is_visible));\n\n  WasResized();\n}\n", "target": 1, "flaw_line_index": "10,11,12,13,14"}
{"idx": 186731, "func": "void NetworkHandler::ContinueInterceptedRequest(\n    const std::string& interception_id,\n    Maybe<std::string> error_reason,\n    Maybe<std::string> base64_raw_response,\n    Maybe<std::string> url,\n    Maybe<std::string> method,\n    Maybe<std::string> post_data,\n    Maybe<protocol::Network::Headers> headers,\n     Maybe<protocol::Network::AuthChallengeResponse> auth_challenge_response,\n     std::unique_ptr<ContinueInterceptedRequestCallback> callback) {\n   DevToolsInterceptorController* interceptor =\n      DevToolsInterceptorController::FromBrowserContext(\n          process_->GetBrowserContext());\n   if (!interceptor) {\n     callback->sendFailure(Response::InternalError());\n     return;\n  }\n\n  base::Optional<std::string> raw_response;\n  if (base64_raw_response.isJust()) {\n    std::string decoded;\n    if (!base::Base64Decode(base64_raw_response.fromJust(), &decoded)) {\n      callback->sendFailure(Response::InvalidParams(\"Invalid rawResponse.\"));\n      return;\n    }\n    raw_response = decoded;\n  }\n\n  base::Optional<net::Error> error;\n  bool mark_as_canceled = false;\n  if (error_reason.isJust()) {\n    bool ok;\n    error = NetErrorFromString(error_reason.fromJust(), &ok);\n    if (!ok) {\n      callback->sendFailure(Response::InvalidParams(\"Invalid errorReason.\"));\n      return;\n    }\n\n    mark_as_canceled = true;\n  }\n\n  interceptor->ContinueInterceptedRequest(\n      interception_id,\n      std::make_unique<DevToolsURLRequestInterceptor::Modifications>(\n          std::move(error), std::move(raw_response), std::move(url),\n          std::move(method), std::move(post_data), std::move(headers),\n          std::move(auth_challenge_response), mark_as_canceled),\n      std::move(callback));\n}\n", "target": 1, "flaw_line_index": "12,13"}
{"idx": 8161, "func": "void Gfx::opSetStrokeRGBColor(Object args[], int numArgs) {\n  GfxColor color;\n  int i;\n\n  state->setStrokePattern(NULL);\n  state->setStrokeColorSpace(new GfxDeviceRGBColorSpace());\n  out->updateStrokeColorSpace(state);\n  for (i = 0; i < 3; ++i) {\n    color.c[i] = dblToCol(args[i].getNum());\n  }\n  state->setStrokeColor(&color);\n  out->updateStrokeColor(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7975, "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n{\n    char local[13];\n\n    memcpy(local, version, 12);\n    local[12] = 0;\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n        vnc_client_error(vs);\n        return 0;\n    }\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n    if (vs->major != 3 ||\n        (vs->minor != 3 &&\n         vs->minor != 4 &&\n         vs->minor != 5 &&\n         vs->minor != 7 &&\n         vs->minor != 8)) {\n        VNC_DEBUG(\"Unsupported client version\\n\");\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n        vnc_flush(vs);\n        vnc_client_error(vs);\n        return 0;\n    }\n    if (vs->minor == 4 || vs->minor == 5)\n        vs->minor = 3;\n\n    if (vs->minor == 3) {\n        if (vs->auth == VNC_AUTH_NONE) {\n            VNC_DEBUG(\"Tell client auth none\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_client_init(vs);\n       } else if (vs->auth == VNC_AUTH_VNC) {\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_auth_vnc(vs);\n       } else {\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n            vnc_flush(vs);\n            vnc_client_error(vs);\n       }\n    } else {\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n        vnc_write_u8(vs, 1); \n        vnc_write_u8(vs, vs->auth);\n        vnc_read_when(vs, protocol_client_auth, 1);\n        vnc_flush(vs);\n    }\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7601, "func": "static void cirrus_vga_ioport_write(void *opaque, hwaddr addr, uint64_t val,\n                                    unsigned size)\n{\n    CirrusVGAState *c = opaque;\n    VGACommonState *s = &c->vga;\n    int index;\n\n    addr += 0x3b0;\n\n    if (vga_ioport_invalid(s, addr)) {\n\treturn;\n    }\n#ifdef DEBUG_VGA\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n#endif\n\n    switch (addr) {\n    case 0x3c0:\n\tif (s->ar_flip_flop == 0) {\n\t    val &= 0x3f;\n\t    s->ar_index = val;\n\t} else {\n\t    index = s->ar_index & 0x1f;\n\t    switch (index) {\n\t    case 0x00 ... 0x0f:\n\t\ts->ar[index] = val & 0x3f;\n\t\tbreak;\n\t    case 0x10:\n\t\ts->ar[index] = val & ~0x10;\n\t\tbreak;\n\t    case 0x11:\n\t\ts->ar[index] = val;\n\t\tbreak;\n\t    case 0x12:\n\t\ts->ar[index] = val & ~0xc0;\n\t\tbreak;\n\t    case 0x13:\n\t\ts->ar[index] = val & ~0xf0;\n\t\tbreak;\n\t    case 0x14:\n\t\ts->ar[index] = val & ~0xf0;\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n\ts->ar_flip_flop ^= 1;\n\tbreak;\n    case 0x3c2:\n\ts->msr = val & ~0x10;\n\ts->update_retrace_info(s);\n\tbreak;\n    case 0x3c4:\n\ts->sr_index = val;\n\tbreak;\n    case 0x3c5:\n#ifdef DEBUG_VGA_REG\n\tprintf(\"vga: write SR%x = 0x%02\" PRIu64 \"\\n\", s->sr_index, val);\n#endif\n\tcirrus_vga_write_sr(c, val);\n        break;\n    case 0x3c6:\n\tcirrus_write_hidden_dac(c, val);\n\tbreak;\n    case 0x3c7:\n\ts->dac_read_index = val;\n\ts->dac_sub_index = 0;\n\ts->dac_state = 3;\n\tbreak;\n    case 0x3c8:\n\ts->dac_write_index = val;\n\ts->dac_sub_index = 0;\n\ts->dac_state = 0;\n\tbreak;\n    case 0x3c9:\n        cirrus_vga_write_palette(c, val);\n        break;\n    case 0x3ce:\n\ts->gr_index = val;\n\tbreak;\n    case 0x3cf:\n#ifdef DEBUG_VGA_REG\n\tprintf(\"vga: write GR%x = 0x%02\" PRIu64 \"\\n\", s->gr_index, val);\n#endif\n\tcirrus_vga_write_gr(c, s->gr_index, val);\n\tbreak;\n    case 0x3b4:\n    case 0x3d4:\n\ts->cr_index = val;\n\tbreak;\n    case 0x3b5:\n    case 0x3d5:\n#ifdef DEBUG_VGA_REG\n\tprintf(\"vga: write CR%x = 0x%02\"PRIu64\"\\n\", s->cr_index, val);\n#endif\n\tcirrus_vga_write_cr(c, val);\n\tbreak;\n    case 0x3ba:\n    case 0x3da:\n\ts->fcr = val & 0x10;\n\tbreak;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7607, "func": "static int cirrus_vga_read_sr(CirrusVGAState * s)\n{\n    switch (s->vga.sr_index) {\n    case 0x00:\t\t\t\n    case 0x01:\t\t\t\n    case 0x02:\t\t\t\n    case 0x03:\t\t\t\n    case 0x04:\t\t\t\n\treturn s->vga.sr[s->vga.sr_index];\n    case 0x06:\t\t\t\n\treturn s->vga.sr[s->vga.sr_index];\n    case 0x10:\n    case 0x30:\n    case 0x50:\n    case 0x70:\t\t\t\n    case 0x90:\n    case 0xb0:\n    case 0xd0:\n    case 0xf0:\t\t\t\n\treturn s->vga.sr[0x10];\n    case 0x11:\n    case 0x31:\n    case 0x51:\n    case 0x71:\t\t\t\n    case 0x91:\n    case 0xb1:\n    case 0xd1:\n    case 0xf1:\t\t\t\n\treturn s->vga.sr[0x11];\n    case 0x05:\t\t\t\n    case 0x07:\t\t\t\n    case 0x08:\t\t\t\n    case 0x09:\t\t\t\n    case 0x0a:\t\t\t\n    case 0x0b:\t\t\t\n    case 0x0c:\t\t\t\n    case 0x0d:\t\t\t\n    case 0x0e:\t\t\t\n    case 0x0f:\t\t\t\n    case 0x12:\t\t\t\n    case 0x13:\t\t\t\n    case 0x14:\t\t\t\n    case 0x15:\t\t\t\n    case 0x16:\t\t\t\n    case 0x17:\t\t\t\n    case 0x18:\t\t\t\n    case 0x19:\t\t\t\n    case 0x1a:\t\t\t\n    case 0x1b:\t\t\t\n    case 0x1c:\t\t\t\n    case 0x1d:\t\t\t\n    case 0x1e:\t\t\t\n    case 0x1f:\t\t\t\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: handled inport sr_index %02x\\n\", s->vga.sr_index);\n#endif\n\treturn s->vga.sr[s->vga.sr_index];\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: inport sr_index %02x\\n\", s->vga.sr_index);\n#endif\n\treturn 0xff;\n\tbreak;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8195, "func": "static void coroutine_fn virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186720, "func": "void DevToolsSession::SetRenderer(RenderProcessHost* process_host,\n                                   RenderFrameHostImpl* frame_host) {\n  process_ = process_host;\n   host_ = frame_host;\n   for (auto& pair : handlers_)\n    pair.second->SetRenderer(process_, host_);\n }\n", "target": 1, "flaw_line_index": "3,6"}
{"idx": 186360, "func": "bool IsIDNComponentSafe(base::StringPiece16 label) {\n  return g_idn_spoof_checker.Get().Check(label);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7689, "func": "static int handle_remove(FsContext *ctx, const char *path)\n{\n    errno = EOPNOTSUPP;\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7915, "func": "static void cstmlist(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tcstm(J, F, list->a);\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186403, "func": "void PageInfo::GetSafeBrowsingStatusByMaliciousContentStatus(\n     security_state::MaliciousContentStatus malicious_content_status,\n    PageInfo::SafeBrowsingStatus* status,\n     base::string16* details) {\n   switch (malicious_content_status) {\n     case security_state::MALICIOUS_CONTENT_STATUS_NONE:\n       NOTREACHED();\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_MALWARE:\n      *status = PageInfo::SAFE_BROWSING_STATUS_MALWARE;\n       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_MALWARE_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING:\n      *status = PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING;\n       *details =\n           l10n_util::GetStringUTF16(IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_UNWANTED_SOFTWARE:\n      *status = PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE;\n       *details =\n           l10n_util::GetStringUTF16(IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_SIGN_IN_PASSWORD_REUSE:\n #if defined(FULL_SAFE_BROWSING)\n      *status = PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE;\n       *details = password_protection_service_\n                      ? password_protection_service_->GetWarningDetailText(\n                           PasswordReuseEvent::SIGN_IN_PASSWORD)\n                     : base::string16();\n#endif\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE:\n #if defined(FULL_SAFE_BROWSING)\n      *status = PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE;\n       *details = password_protection_service_\n                      ? password_protection_service_->GetWarningDetailText(\n                           PasswordReuseEvent::ENTERPRISE_PASSWORD)\n                     : base::string16();\n #endif\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_BILLING:\n      *status = PageInfo::SAFE_BROWSING_STATUS_BILLING;\n       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_BILLING_DETAILS);\n       break;\n   }\n}\n", "target": 1, "flaw_line_index": "3,10,14,19,25,35,44"}
{"idx": 186496, "func": "void GLES2Implementation::BeginQueryEXT(GLenum target, GLuint id) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] BeginQueryEXT(\"\n                     << GLES2Util::GetStringQueryTarget(target) << \", \" << id\n                     << \")\");\n\n  switch (target) {\n    case GL_COMMANDS_ISSUED_CHROMIUM:\n     case GL_LATENCY_QUERY_CHROMIUM:\n     case GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM:\n     case GL_GET_ERROR_QUERY_CHROMIUM:\n       break;\n     case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n     case GL_COMMANDS_COMPLETED_CHROMIUM:\n      if (!capabilities_.sync_query) {\n        SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n                   \"not enabled for commands completed queries\");\n        return;\n      }\n      break;\n    case GL_SAMPLES_PASSED_ARB:\n      if (!capabilities_.occlusion_query) {\n        SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n                   \"not enabled for occlusion queries\");\n        return;\n      }\n      break;\n    case GL_ANY_SAMPLES_PASSED:\n    case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:\n      if (!capabilities_.occlusion_query_boolean) {\n        SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n                   \"not enabled for boolean occlusion queries\");\n        return;\n      }\n      break;\n    case GL_TIME_ELAPSED_EXT:\n      if (!capabilities_.timer_queries) {\n        SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n                   \"not enabled for timing queries\");\n        return;\n      }\n      break;\n    case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:\n      if (capabilities_.major_version >= 3)\n        break;\n      FALLTHROUGH;\n    default:\n      SetGLError(GL_INVALID_ENUM, \"glBeginQueryEXT\", \"unknown query target\");\n      return;\n  }\n\n  if (query_tracker_->GetCurrentQuery(target)) {\n    SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n               \"query already in progress\");\n    return;\n  }\n\n  if (id == 0) {\n    SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"id is 0\");\n    return;\n  }\n\n  if (!GetIdAllocator(IdNamespaces::kQueries)->InUse(id)) {\n    SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"invalid id\");\n    return;\n  }\n\n  switch (target) {\n    case GL_TIME_ELAPSED_EXT:\n      if (!query_tracker_->SetDisjointSync(this)) {\n        SetGLError(GL_OUT_OF_MEMORY, \"glBeginQueryEXT\",\n                   \"buffer allocation failed\");\n        return;\n      }\n      break;\n    default:\n      break;\n  }\n\n  if (query_tracker_->BeginQuery(id, target, this))\n    CheckGLError();\n\n  if (target == GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM) {\n    AllocateShadowCopiesForReadback();\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186719, "func": " void DevToolsSession::ReceivedBadMessage() {\n   MojoConnectionDestroyed();\n  if (process_) {\n     bad_message::ReceivedBadMessage(\n        process_, bad_message::RFH_INCONSISTENT_DEVTOOLS_MESSAGE);\n   }\n }\n", "target": 1, "flaw_line_index": "3,5"}
{"idx": 186718, "func": "DevToolsSession::DevToolsSession(DevToolsAgentHostImpl* agent_host,\n                                 DevToolsAgentHostClient* client)\n     : binding_(this),\n       agent_host_(agent_host),\n       client_(client),\n      process_(nullptr),\n       host_(nullptr),\n       dispatcher_(new protocol::UberDispatcher(this)),\n       weak_factory_(this) {\n  dispatcher_->setFallThroughForNotFound(true);\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 186473, "func": "static sk_sp<SkImage> premulSkImageToUnPremul(SkImage* input) {\n  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),\n                                       kN32_SkColorType, kUnpremul_SkAlphaType);\n  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);\n  if (!dstPixels)\n     return nullptr;\n   return newSkImageFromRaster(\n       info, std::move(dstPixels),\n      static_cast<size_t>(input->width()) * info.bytesPerPixel());\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 7545, "func": "gmt_offset (time_t s)\n{\n  long gmtoff;\n\n#if !HAVE_TM_GMTOFF\n  struct tm tm_local = *localtime (&s);\n  struct tm tm_gmt   = *gmtime (&s);\n\n  gmtoff = tm_diff (&tm_local, &tm_gmt);\n#else\n  gmtoff = localtime (&s)->tm_gmtoff;\n#endif\n\n  return gmtoff;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7793, "func": "static int h2c_frt_handle_headers(struct h2c *h2c, struct h2s *h2s)\n{\n\tint error;\n\n\tif (!h2c->dfl) {\n\t\terror = H2_ERR_PROTOCOL_ERROR; \n\t\tgoto strm_err;\n\t}\n\n\tif (!h2c->dbuf->size)\n\t\treturn 0; \n\n\tif (h2c->dbuf->i < h2c->dfl && h2c->dbuf->i < h2c->dbuf->size)\n\t\treturn 0; \n\n\tif (h2s->st != H2_SS_IDLE) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\telse if (h2c->dsi <= h2c->max_id || !(h2c->dsi & 1)) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\th2s = h2c_stream_new(h2c, h2c->dsi);\n\tif (!h2s) {\n\t\terror = H2_ERR_INTERNAL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\th2s->st = H2_SS_OPEN;\n\tif (h2c->dff & H2_F_HEADERS_END_STREAM) {\n\t\th2s->st = H2_SS_HREM;\n\t\th2s->flags |= H2_SF_ES_RCVD;\n\t}\n\n\th2s->cs->data_cb->recv(h2s->cs);\n\n\tif (h2s->cs->data_cb->wake(h2s->cs) < 0) {\n\t\terror = H2_ERR_INTERNAL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn 0;\n\n\tif (h2s->st >= H2_SS_ERROR) {\n\t\th2c->st0 = H2_CS_FRAME_E;\n\t}\n\telse {\n\t\tif (h2s->id > h2c->max_id)\n\t\t\th2c->max_id = h2s->id;\n\t}\n\n\treturn 1;\n\n conn_err:\n\th2c_error(h2c, error);\n\treturn 0;\n\n strm_err:\n\tif (h2s) {\n\t\th2s_error(h2s, error);\n\t\th2c->st0 = H2_CS_FRAME_E;\n\t}\n\telse\n\t\th2c_error(h2c, error);\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186427, "func": "std::string SanitizeFrontendQueryParam(\n    const std::string& key,\n    const std::string& value) {\n  if (key == \"can_dock\" || key == \"debugFrontend\" || key == \"experiments\" ||\n      key == \"isSharedWorker\" || key == \"v8only\" || key == \"remoteFrontend\")\n    return \"true\";\n  if (key == \"ws\" || key == \"service-backend\")\n    return SanitizeEndpoint(value);\n  if (key == \"dockSide\" && value == \"undocked\")\n    return value;\n  if (key == \"panel\" && (value == \"elements\" || value == \"console\"))\n    return value;\n  if (key == \"remoteBase\")\n    return SanitizeRemoteBase(value);\n  if (key == \"remoteFrontendUrl\")\n    return SanitizeRemoteFrontendURL(value);\n  return std::string();\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19"}
{"idx": 186412, "func": "void BluetoothDeviceChooserController::OnBluetoothChooserEvent(\n    BluetoothChooser::Event event,\n    const std::string& device_address) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(chooser_.get());\n\n  switch (event) {\n    case BluetoothChooser::Event::RESCAN:\n      RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));\n      device_ids_.clear();\n      PopulateConnectedDevices();\n      DCHECK(chooser_);\n      StartDeviceDiscovery();\n       return;\n     case BluetoothChooser::Event::DENIED_PERMISSION:\n       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));\n      PostErrorCallback(blink::mojom::WebBluetoothResult::\n                            CHOOSER_NOT_SHOWN_USER_DENIED_PERMISSION_TO_SCAN);\n       break;\n     case BluetoothChooser::Event::CANCELLED:\n       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));\n      PostErrorCallback(blink::mojom::WebBluetoothResult::CHOOSER_CANCELLED);\n       break;\n     case BluetoothChooser::Event::SHOW_OVERVIEW_HELP:\n       DVLOG(1) << \"Overview Help link pressed.\";\n       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));\n      PostErrorCallback(blink::mojom::WebBluetoothResult::CHOOSER_CANCELLED);\n       break;\n     case BluetoothChooser::Event::SHOW_ADAPTER_OFF_HELP:\n       DVLOG(1) << \"Adapter Off Help link pressed.\";\n       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));\n      PostErrorCallback(blink::mojom::WebBluetoothResult::CHOOSER_CANCELLED);\n       break;\n     case BluetoothChooser::Event::SHOW_NEED_LOCATION_HELP:\n       DVLOG(1) << \"Need Location Help link pressed.\";\n       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));\n      PostErrorCallback(blink::mojom::WebBluetoothResult::CHOOSER_CANCELLED);\n       break;\n     case BluetoothChooser::Event::SELECTED:\n       RecordNumOfDevices(options_->accept_all_devices, device_ids_.size());\n      PostSuccessCallback(device_address);\n      break;\n  }\n  chooser_.reset();\n}\n", "target": 1, "flaw_line_index": "19,20,24,29,34,39"}
{"idx": 7605, "func": "static int cirrus_vga_read_gr(CirrusVGAState * s, unsigned reg_index)\n{\n    switch (reg_index) {\n    case 0x00: \n        return s->cirrus_shadow_gr0;\n    case 0x01: \n        return s->cirrus_shadow_gr1;\n    case 0x02:\t\t\t\n    case 0x03:\t\t\t\n    case 0x04:\t\t\t\n    case 0x06:\t\t\t\n    case 0x07:\t\t\t\n    case 0x08:\t\t\t\n        return s->vga.gr[s->vga.gr_index];\n    case 0x05:\t\t\t\n    default:\n\tbreak;\n    }\n\n    if (reg_index < 0x3a) {\n\treturn s->vga.gr[reg_index];\n    } else {\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: inport gr_index %02x\\n\", reg_index);\n#endif\n\treturn 0xff;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7409, "func": "static void end_read(TsHashTable *ht)\n{\n#ifdef ZTS\n\ttsrm_mutex_lock(ht->mx_reader);\n\tif ((--(ht->reader)) == 0) {\n\t\ttsrm_mutex_unlock(ht->mx_writer);\n\t}\n\ttsrm_mutex_unlock(ht->mx_reader);\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8041, "func": "static void vnc_release_modifiers(VncState *vs)\n{\n    static const int keycodes[] = {\n        0x2a, 0x36, 0x1d, 0x9d, 0x38, 0xb8,\n    };\n    int i, keycode;\n\n    if (!qemu_console_is_graphic(NULL)) {\n        return;\n    }\n    for (i = 0; i < ARRAY_SIZE(keycodes); i++) {\n        keycode = keycodes[i];\n        if (!vs->modifiers_state[keycode]) {\n            continue;\n        }\n        qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8233, "func": "static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)\n{\n    int err = 1;\n    if (f->fid_type == P9_FID_FILE) {\n        if (f->fs.fd == -1) {\n            do {\n                err = v9fs_co_open(pdu, f, f->open_flags);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    } else if (f->fid_type == P9_FID_DIR) {\n        if (f->fs.dir.stream == NULL) {\n            do {\n                err = v9fs_co_opendir(pdu, f);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    }\n    return err;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7780, "func": "static inline __maybe_unused void h2_set_frame_size(void *frame, uint32_t len)\n{\n\tuint8_t *out = frame;\n\n\t*out = len >> 16;\n\twrite_n16(out + 1, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186811, "func": " void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n          static_cast<jint>(\n              mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION)))) {\n    auto sensor_fusion_algorithm =\n        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(\n            true \n);\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n", "target": 1, "flaw_line_index": "3,16,24"}
{"idx": 186723, "func": "void EmulationHandler::SetRenderer(RenderProcessHost* process_host,\n                                    RenderFrameHostImpl* frame_host) {\n   if (host_ == frame_host)\n     return;\n\n  host_ = frame_host;\n  if (touch_emulation_enabled_)\n    UpdateTouchEventEmulationState();\n  UpdateDeviceEmulationState();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7692, "func": "static void handle_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    rewinddir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8008, "func": "void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n{\n    uint8_t r, g, b;\n\n#if VNC_SERVER_FB_FORMAT == PIXMAN_FORMAT(32, PIXMAN_TYPE_ARGB, 0, 8, 8, 8)\n    r = (((v & 0x00ff0000) >> 16) << vs->client_pf.rbits) >> 8;\n    g = (((v & 0x0000ff00) >>  8) << vs->client_pf.gbits) >> 8;\n    b = (((v & 0x000000ff) >>  0) << vs->client_pf.bbits) >> 8;\n#else\n# error need some bits here if you change VNC_SERVER_FB_FORMAT\n#endif\n    v = (r << vs->client_pf.rshift) |\n        (g << vs->client_pf.gshift) |\n        (b << vs->client_pf.bshift);\n    switch (vs->client_pf.bytes_per_pixel) {\n    case 1:\n        buf[0] = v;\n        break;\n    case 2:\n        if (vs->client_be) {\n            buf[0] = v >> 8;\n            buf[1] = v;\n        } else {\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    default:\n    case 4:\n        if (vs->client_be) {\n            buf[0] = v >> 24;\n            buf[1] = v >> 16;\n            buf[2] = v >> 8;\n            buf[3] = v;\n        } else {\n            buf[3] = v >> 24;\n            buf[2] = v >> 16;\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8086, "func": "void Gfx::doSoftMask(Object *str, GBool alpha,\n\t\t     GfxColorSpace *blendingColorSpace,\n\t\t     GBool isolated, GBool knockout,\n\t\t     Function *transferFunc, GfxColor *backdropColor) {\n  Dict *dict, *resDict;\n  double m[6], bbox[4];\n  Object obj1, obj2;\n  int i;\n\n  if (formDepth > 20) {\n    return;\n  }\n\n  dict = str->streamGetDict();\n\n  dict->lookup(\"FormType\", &obj1);\n  if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {\n    error(getPos(), \"Unknown form type\");\n  }\n  obj1.free();\n\n  dict->lookup(\"BBox\", &obj1);\n  if (!obj1.isArray()) {\n    obj1.free();\n    error(getPos(), \"Bad form bounding box\");\n    return;\n  }\n  for (i = 0; i < 4; ++i) {\n    obj1.arrayGet(i, &obj2);\n    bbox[i] = obj2.getNum();\n    obj2.free();\n  }\n  obj1.free();\n\n  dict->lookup(\"Matrix\", &obj1);\n  if (obj1.isArray()) {\n    for (i = 0; i < 6; ++i) {\n      obj1.arrayGet(i, &obj2);\n      m[i] = obj2.getNum();\n      obj2.free();\n    }\n  } else {\n    m[0] = 1; m[1] = 0;\n    m[2] = 0; m[3] = 1;\n    m[4] = 0; m[5] = 0;\n  }\n  obj1.free();\n\n  dict->lookup(\"Resources\", &obj1);\n  resDict = obj1.isDict() ? obj1.getDict() : (Dict *)NULL;\n\n  ++formDepth;\n  doForm1(str, resDict, m, bbox, gTrue, gTrue,\n\t  blendingColorSpace, isolated, knockout,\n\t  alpha, transferFunc, backdropColor);\n  --formDepth;\n\n  if (blendingColorSpace) {\n    delete blendingColorSpace;\n  }\n  obj1.free();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186740, "func": "void NetworkHandler::SetRenderer(RenderProcessHost* process_host,\n                                  RenderFrameHostImpl* frame_host) {\n  process_ = process_host;\n   host_ = frame_host;\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187282, "func": "void ChunkedUploadDataStream::AppendData(\n    const char* data, int data_len, bool is_done) {\n  DCHECK(!all_data_appended_);\n  DCHECK(data_len > 0 || is_done);\n   if (data_len > 0) {\n     DCHECK(data);\n     upload_data_.push_back(\n        base::MakeUnique<std::vector<char>>(data, data + data_len));\n   }\n   all_data_appended_ = is_done;\n \n  if (!read_buffer_.get())\n    return;\n\n  int result = ReadChunk(read_buffer_.get(), read_buffer_len_);\n  DCHECK_GE(result, 0);\n  read_buffer_ = NULL;\n  read_buffer_len_ = 0;\n  OnReadCompleted(result);\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 186881, "func": " BaseRenderingContext2D::BaseRenderingContext2D()\n    : clip_antialiasing_(kNotAntiAliased) {\n   state_stack_.push_back(CanvasRenderingContext2DState::Create());\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186315, "func": " void MediaControlsProgressView::OnGestureEvent(ui::GestureEvent* event) {\n  gfx::Point location_in_bar(event->location());\n  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);\n  if (event->type() != ui::ET_GESTURE_TAP ||\n      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {\n     return;\n   }\n \n  HandleSeeking(location_in_bar);\n   event->SetHandled();\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,9"}
{"idx": 186969, "func": "  void StoreNewGroup() {\n    PushNextTask(base::BindOnce(&AppCacheStorageImplTest::Verify_StoreNewGroup,\n                                base::Unretained(this)));\n\n     group_ =\n         new AppCacheGroup(storage(), kManifestUrl, storage()->NewGroupId());\n     cache_ = new AppCache(storage(), storage()->NewCacheId());\n    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT, 1,\n                                              kDefaultEntrySize));\n \n    mock_quota_manager_proxy_->mock_manager_->async_ = true;\n\n    storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());\n    EXPECT_FALSE(delegate()->stored_group_success_);\n  }\n", "target": 1, "flaw_line_index": "11,12"}
{"idx": 7525, "func": "  tt_synth_sfnt_checksum( FT_Stream  stream,\n                          FT_ULong   length )\n  {\n    FT_Error   error;\n    FT_UInt32  checksum = 0;\n    FT_UInt    i;\n\n\n    if ( FT_FRAME_ENTER( length ) )\n      return 0;\n\n    for ( ; length > 3; length -= 4 )\n      checksum += (FT_UInt32)FT_GET_ULONG();\n\n    for ( i = 3; length > 0; length--, i-- )\n      checksum += (FT_UInt32)FT_GET_BYTE() << ( i * 8 );\n\n    FT_FRAME_EXIT();\n\n    return checksum;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7816, "func": "static inline __maybe_unused int h2s_id(const struct h2s *h2s)\n{\n\treturn h2s ? h2s->id : 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186576, "func": "void UnacceleratedStaticBitmapImage::Draw(cc::PaintCanvas* canvas,\n                                          const cc::PaintFlags& flags,\n                                          const FloatRect& dst_rect,\n                                          const FloatRect& src_rect,\n                                           RespectImageOrientationEnum,\n                                           ImageClampingMode clamp_mode,\n                                           ImageDecodingMode) {\n   StaticBitmapImage::DrawHelper(canvas, flags, dst_rect, src_rect, clamp_mode,\n                                 PaintImageForCurrentFrame());\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186466, "func": "void UkmPageLoadMetricsObserver::RecordTimingMetrics(\n     const page_load_metrics::mojom::PageLoadTiming& timing,\n     const page_load_metrics::PageLoadExtraInfo& info) {\n   ukm::builders::PageLoad builder(info.source_id);\n  bool is_user_initiated_navigation =\n      info.user_initiated_info.browser_initiated ||\n      timing.input_to_navigation_start;\n  builder.SetExperimental_Navigation_UserInitiated(\n      is_user_initiated_navigation);\n   if (timing.input_to_navigation_start) {\n     builder.SetExperimental_InputToNavigationStart(\n         timing.input_to_navigation_start.value().InMilliseconds());\n  }\n  if (timing.parse_timing->parse_start) {\n    builder.SetParseTiming_NavigationToParseStart(\n        timing.parse_timing->parse_start.value().InMilliseconds());\n  }\n  if (timing.document_timing->dom_content_loaded_event_start) {\n    builder.SetDocumentTiming_NavigationToDOMContentLoadedEventFired(\n        timing.document_timing->dom_content_loaded_event_start.value()\n            .InMilliseconds());\n  }\n  if (timing.document_timing->load_event_start) {\n    builder.SetDocumentTiming_NavigationToLoadEventFired(\n        timing.document_timing->load_event_start.value().InMilliseconds());\n  }\n  if (timing.paint_timing->first_paint) {\n    builder.SetPaintTiming_NavigationToFirstPaint(\n        timing.paint_timing->first_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->first_contentful_paint) {\n    builder.SetPaintTiming_NavigationToFirstContentfulPaint(\n        timing.paint_timing->first_contentful_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->first_meaningful_paint) {\n    builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(\n        timing.paint_timing->first_meaningful_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->largest_image_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->largest_image_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(\n        timing.paint_timing->largest_image_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->last_image_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->last_image_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLastImagePaint(\n        timing.paint_timing->last_image_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->largest_text_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->largest_text_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLargestTextPaint(\n        timing.paint_timing->largest_text_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->last_text_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->last_text_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLastTextPaint(\n        timing.paint_timing->last_text_paint.value().InMilliseconds());\n  }\n  base::Optional<base::TimeDelta> largest_content_paint_time;\n  uint64_t largest_content_paint_size;\n  AssignTimeAndSizeForLargestContentfulPaint(largest_content_paint_time,\n                                             largest_content_paint_size,\n                                             timing.paint_timing);\n  if (largest_content_paint_size > 0 &&\n      WasStartedInForegroundOptionalEventInForeground(\n          largest_content_paint_time, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLargestContentPaint(\n        largest_content_paint_time.value().InMilliseconds());\n  }\n  if (timing.interactive_timing->interactive) {\n    base::TimeDelta time_to_interactive =\n        timing.interactive_timing->interactive.value();\n    if (!timing.interactive_timing->first_invalidating_input ||\n        timing.interactive_timing->first_invalidating_input.value() >\n            time_to_interactive) {\n      builder.SetExperimental_NavigationToInteractive(\n          time_to_interactive.InMilliseconds());\n    }\n  }\n  if (timing.interactive_timing->first_input_delay) {\n    base::TimeDelta first_input_delay =\n        timing.interactive_timing->first_input_delay.value();\n    builder.SetInteractiveTiming_FirstInputDelay2(\n        first_input_delay.InMilliseconds());\n  }\n  if (timing.interactive_timing->first_input_timestamp) {\n    base::TimeDelta first_input_timestamp =\n        timing.interactive_timing->first_input_timestamp.value();\n    builder.SetInteractiveTiming_FirstInputTimestamp2(\n        first_input_timestamp.InMilliseconds());\n  }\n\n  if (timing.interactive_timing->longest_input_delay) {\n    base::TimeDelta longest_input_delay =\n        timing.interactive_timing->longest_input_delay.value();\n    builder.SetInteractiveTiming_LongestInputDelay2(\n        longest_input_delay.InMilliseconds());\n  }\n  if (timing.interactive_timing->longest_input_timestamp) {\n    base::TimeDelta longest_input_timestamp =\n        timing.interactive_timing->longest_input_timestamp.value();\n    builder.SetInteractiveTiming_LongestInputTimestamp2(\n        longest_input_timestamp.InMilliseconds());\n  }\n\n  builder.SetNet_CacheBytes(ukm::GetExponentialBucketMin(cache_bytes_, 1.3));\n  builder.SetNet_NetworkBytes(\n      ukm::GetExponentialBucketMin(network_bytes_, 1.3));\n\n  if (main_frame_timing_)\n    ReportMainResourceTimingMetrics(timing, &builder);\n\n  builder.Record(ukm::UkmRecorder::Get());\n}\n", "target": 1, "flaw_line_index": "5,6,7,8,9,10,11,12"}
{"idx": 186505, "func": "ScriptValue WebGLRenderingContextBase::getProgramParameter(\n    ScriptState* script_state,\n    WebGLProgram* program,\n    GLenum pname) {\n  if (!ValidateWebGLProgramOrShader(\"getProgramParamter\", program)) {\n    return ScriptValue::CreateNull(script_state);\n  }\n\n  GLint value = 0;\n  switch (pname) {\n    case GL_DELETE_STATUS:\n      return WebGLAny(script_state, program->MarkedForDeletion());\n    case GL_VALIDATE_STATUS:\n      ContextGL()->GetProgramiv(ObjectOrZero(program), pname, &value);\n      return WebGLAny(script_state, static_cast<bool>(value));\n    case GL_LINK_STATUS:\n      return WebGLAny(script_state, program->LinkStatus(this));\n    case GL_COMPLETION_STATUS_KHR:\n      if (!ExtensionEnabled(kKHRParallelShaderCompileName)) {\n        SynthesizeGLError(GL_INVALID_ENUM, \"getProgramParameter\",\n                           \"invalid parameter name\");\n         return ScriptValue::CreateNull(script_state);\n       }\n       return WebGLAny(script_state, program->CompletionStatus(this));\n     case GL_ACTIVE_UNIFORM_BLOCKS:\n     case GL_TRANSFORM_FEEDBACK_VARYINGS:\n      if (!IsWebGL2OrHigher()) {\n        SynthesizeGLError(GL_INVALID_ENUM, \"getProgramParameter\",\n                          \"invalid parameter name\");\n        return ScriptValue::CreateNull(script_state);\n      }\n      FALLTHROUGH;\n    case GL_ATTACHED_SHADERS:\n    case GL_ACTIVE_ATTRIBUTES:\n    case GL_ACTIVE_UNIFORMS:\n      ContextGL()->GetProgramiv(ObjectOrZero(program), pname, &value);\n      return WebGLAny(script_state, value);\n    case GL_TRANSFORM_FEEDBACK_BUFFER_MODE:\n      if (!IsWebGL2OrHigher()) {\n        SynthesizeGLError(GL_INVALID_ENUM, \"getProgramParameter\",\n                          \"invalid parameter name\");\n        return ScriptValue::CreateNull(script_state);\n      }\n      ContextGL()->GetProgramiv(ObjectOrZero(program), pname, &value);\n      return WebGLAny(script_state, static_cast<unsigned>(value));\n    case GL_ACTIVE_ATOMIC_COUNTER_BUFFERS:\n      if (context_type_ == Platform::kWebGL2ComputeContextType) {\n        ContextGL()->GetProgramiv(ObjectOrZero(program), pname, &value);\n        return WebGLAny(script_state, static_cast<unsigned>(value));\n      }\n      FALLTHROUGH;\n    default:\n      SynthesizeGLError(GL_INVALID_ENUM, \"getProgramParameter\",\n                        \"invalid parameter name\");\n      return ScriptValue::CreateNull(script_state);\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186975, "func": " void AppCacheUpdateJob::OnManifestDataWriteComplete(int result) {\n   if (result > 0) {\n     AppCacheEntry entry(AppCacheEntry::MANIFEST,\n        manifest_response_writer_->response_id(),\n        manifest_response_writer_->amount_written());\n     if (!inprogress_cache_->AddOrModifyEntry(manifest_url_, entry))\n       duplicate_response_ids_.push_back(entry.response_id());\n     StoreGroupAndCache();\n  } else {\n    HandleCacheFailure(\n        blink::mojom::AppCacheErrorDetails(\n            \"Failed to write the manifest data to storage\",\n            blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR, GURL(),\n            0, false \n),\n        DISKCACHE_ERROR, GURL());\n  }\n}\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 8239, "func": "static void v9fs_version(void *opaque)\n{\n    ssize_t err;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsString version;\n    size_t offset = 7;\n\n    v9fs_string_init(&version);\n    err = pdu_unmarshal(pdu, offset, \"ds\", &s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    trace_v9fs_version(pdu->tag, pdu->id, s->msize, version.data);\n\n    virtfs_reset(pdu);\n\n    if (!strcmp(version.data, \"9P2000.u\")) {\n        s->proto_version = V9FS_PROTO_2000U;\n    } else if (!strcmp(version.data, \"9P2000.L\")) {\n        s->proto_version = V9FS_PROTO_2000L;\n    } else {\n        v9fs_string_sprintf(&version, \"unknown\");\n    }\n\n    err = pdu_marshal(pdu, offset, \"ds\", s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    offset += err;\n    trace_v9fs_version_return(pdu->tag, pdu->id, s->msize, version.data);\nout:\n    pdu_complete(pdu, offset);\n    v9fs_string_free(&version);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187167, "func": "DataPipeConsumerDispatcher::Deserialize(const void* data,\n                                        size_t num_bytes,\n                                        const ports::PortName* ports,\n                                        size_t num_ports,\n                                        PlatformHandle* handles,\n                                        size_t num_handles) {\n  if (num_ports != 1 || num_handles != 1 ||\n      num_bytes != sizeof(SerializedState)) {\n    return nullptr;\n  }\n \n   const SerializedState* state = static_cast<const SerializedState*>(data);\n   if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||\n      state->options.capacity_num_bytes < state->options.element_num_bytes) {\n     return nullptr;\n   }\n \n  NodeController* node_controller = Core::Get()->GetNodeController();\n  ports::PortRef port;\n  if (node_controller->node()->GetPort(ports[0], &port) != ports::OK)\n    return nullptr;\n\n  auto region_handle = CreateSharedMemoryRegionHandleFromPlatformHandles(\n      std::move(handles[0]), PlatformHandle());\n  auto region = base::subtle::PlatformSharedMemoryRegion::Take(\n      std::move(region_handle),\n      base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe,\n      state->options.capacity_num_bytes,\n      base::UnguessableToken::Deserialize(state->buffer_guid_high,\n                                          state->buffer_guid_low));\n  auto ring_buffer =\n      base::UnsafeSharedMemoryRegion::Deserialize(std::move(region));\n  if (!ring_buffer.IsValid()) {\n    DLOG(ERROR) << \"Failed to deserialize shared buffer handle.\";\n    return nullptr;\n  }\n\n  scoped_refptr<DataPipeConsumerDispatcher> dispatcher =\n      new DataPipeConsumerDispatcher(node_controller, port,\n                                     std::move(ring_buffer), state->options,\n                                     state->pipe_id);\n\n  {\n    base::AutoLock lock(dispatcher->lock_);\n    dispatcher->read_offset_ = state->read_offset;\n    dispatcher->bytes_available_ = state->bytes_available;\n    dispatcher->new_data_available_ = state->bytes_available > 0;\n     dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;\n     if (!dispatcher->InitializeNoLock())\n       return nullptr;\n     dispatcher->UpdateSignalsStateNoLock();\n   }\n \n  return dispatcher;\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 8082, "func": "void Gfx::doPatternFill(GBool eoFill) {\n  GfxPattern *pattern;\n\n  if (!out->needNonText()) {\n    return;\n  }\n\n  if (!(pattern = state->getFillPattern())) {\n    return;\n  }\n  switch (pattern->getType()) {\n  case 1:\n    doTilingPatternFill((GfxTilingPattern *)pattern, gFalse, eoFill);\n    break;\n  case 2:\n    doShadingPatternFill((GfxShadingPattern *)pattern, gFalse, eoFill);\n    break;\n  default:\n    error(getPos(), \"Unimplemented pattern type (%d) in fill\",\n\t  pattern->getType());\n    break;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186819, "func": " void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n  switch (type) {\n    case mojom::SensorType::LINEAR_ACCELERATION:\n      fusion_algorithm = std::make_unique<\n          LinearAccelerationFusionAlgorithmUsingAccelerometer>();\n      break;\n    case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n      fusion_algorithm = std::make_unique<\n          RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n      break;\n    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION:\n      fusion_algorithm = std::make_unique<\n          OrientationQuaternionFusionAlgorithmUsingEulerAngles>(\n          false \n);\n      break;\n    default:\n      NOTREACHED();\n   }\n \n   DCHECK(fusion_algorithm);\n  PlatformSensorFusion::Create(std::move(mapping), this,\n                                std::move(fusion_algorithm), callback);\n }\n", "target": 1, "flaw_line_index": "3,27"}
{"idx": 186437, "func": "InspectorPageAgent::ResourceType InspectorPageAgent::CachedResourceType(\n    const Resource& cached_resource) {\n  switch (cached_resource.GetType()) {\n     case Resource::kImage:\n       return InspectorPageAgent::kImageResource;\n     case Resource::kFont:\n      return InspectorPageAgent::kFontResource;\n    case Resource::kMedia:\n      return InspectorPageAgent::kMediaResource;\n    case Resource::kManifest:\n      return InspectorPageAgent::kManifestResource;\n    case Resource::kTextTrack:\n      return InspectorPageAgent::kTextTrackResource;\n    case Resource::kCSSStyleSheet:\n    case Resource::kXSLStyleSheet:\n      return InspectorPageAgent::kStylesheetResource;\n    case Resource::kScript:\n      return InspectorPageAgent::kScriptResource;\n    case Resource::kImportResource:\n    case Resource::kMainResource:\n      return InspectorPageAgent::kDocumentResource;\n    default:\n      break;\n  }\n  return InspectorPageAgent::kOtherResource;\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 7832, "func": "static void XBZRLE_cache_lock(void)\n{\n    if (migrate_use_xbzrle())\n        qemu_mutex_lock(&XBZRLE.lock);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7491, "func": "generate_many_bodies (DBusMessageDataIter   *iter,\n                      DBusString            *data,\n                      DBusValidity          *expected_validity)\n{\n  return generate_outer (iter, data, expected_validity,\n                         generate_many_bodies_inner);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186806, "func": "  Factory(mojo::ScopedSharedBufferMapping mapping,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n        mapping_(std::move(mapping)),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n    DCHECK(mapping_);\n     DCHECK(provider_);\n   }\n", "target": 1, "flaw_line_index": "7,14"}
{"idx": 186966, "func": "  void Reinitialize(ReinitTestCase test_case) {\n    feature_list_.InitAndEnableFeature(network::features::kNetworkService);\n\n    ASSERT_TRUE(temp_directory_.CreateUniqueTempDir());\n\n    AppCacheDatabase db(temp_directory_.GetPath().AppendASCII(\"Index\"));\n    EXPECT_TRUE(db.LazyOpen(true));\n\n    if (test_case == CORRUPT_CACHE_ON_INSTALL ||\n        test_case == CORRUPT_CACHE_ON_LOAD_EXISTING) {\n      const std::string kCorruptData(\"deadbeef\");\n      base::FilePath disk_cache_directory =\n          temp_directory_.GetPath().AppendASCII(\"Cache\");\n      ASSERT_TRUE(base::CreateDirectory(disk_cache_directory));\n      base::FilePath index_file = disk_cache_directory.AppendASCII(\"index\");\n      EXPECT_EQ(static_cast<int>(kCorruptData.length()),\n                base::WriteFile(index_file, kCorruptData.data(),\n                                kCorruptData.length()));\n\n      base::FilePath entry_file =\n          disk_cache_directory.AppendASCII(\"01234567_0\");\n      EXPECT_EQ(static_cast<int>(kCorruptData.length()),\n                base::WriteFile(entry_file, kCorruptData.data(),\n                                kCorruptData.length()));\n    }\n\n    if (test_case == CORRUPT_CACHE_ON_LOAD_EXISTING) {\n      AppCacheDatabase db(temp_directory_.GetPath().AppendASCII(\"Index\"));\n      GURL manifest_url = GetMockUrl(\"manifest\");\n\n      AppCacheDatabase::GroupRecord group_record;\n      group_record.group_id = 1;\n      group_record.manifest_url = manifest_url;\n      group_record.origin = url::Origin::Create(manifest_url);\n      EXPECT_TRUE(db.InsertGroup(&group_record));\n      AppCacheDatabase::CacheRecord cache_record;\n      cache_record.cache_id = 1;\n      cache_record.group_id = 1;\n       cache_record.online_wildcard = false;\n       cache_record.update_time = kZeroTime;\n       cache_record.cache_size = kDefaultEntrySize;\n       EXPECT_TRUE(db.InsertCache(&cache_record));\n       AppCacheDatabase::EntryRecord entry_record;\n       entry_record.cache_id = 1;\n       entry_record.url = manifest_url;\n       entry_record.flags = AppCacheEntry::MANIFEST;\n       entry_record.response_id = 1;\n       entry_record.response_size = kDefaultEntrySize;\n       EXPECT_TRUE(db.InsertEntry(&entry_record));\n     }\n \n    service_.reset(new AppCacheServiceImpl(nullptr));\n    auto loader_factory_getter = base::MakeRefCounted<URLLoaderFactoryGetter>();\n    loader_factory_getter->SetNetworkFactoryForTesting(\n        &mock_url_loader_factory_, \n true);\n    service_->set_url_loader_factory_getter(loader_factory_getter.get());\n\n    service_->Initialize(temp_directory_.GetPath());\n    mock_quota_manager_proxy_ = new MockQuotaManagerProxy();\n    service_->quota_manager_proxy_ = mock_quota_manager_proxy_;\n    delegate_.reset(new MockStorageDelegate(this));\n\n    observer_.reset(new MockServiceObserver(this));\n    service_->AddObserver(observer_.get());\n\n    FlushAllTasks();\n    base::SequencedTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&AppCacheStorageImplTest::Continue_Reinitialize,\n                       base::Unretained(this), test_case));\n  }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8276, "func": "XRenderExtRemoveDisplay (XRenderExtInfo *extinfo, Display *dpy)\n{\n    XRenderExtDisplayInfo *dpyinfo, *prev;\n\n    _XLockMutex(_Xglobal_lock);\n    prev = NULL;\n    for (dpyinfo = extinfo->head; dpyinfo; dpyinfo = dpyinfo->next) {\n\tif (dpyinfo->display == dpy) break;\n\tprev = dpyinfo;\n    }\n    if (!dpyinfo) {\n\t_XUnlockMutex(_Xglobal_lock);\n\treturn 0;\t\t\n    }\n\n    if (prev)\n\tprev->next = dpyinfo->next;\n    else\n\textinfo->head = dpyinfo->next;\n\n    extinfo->ndisplays--;\n    if (dpyinfo == extinfo->cur) extinfo->cur = NULL;  \n    _XUnlockMutex(_Xglobal_lock);\n\n    Xfree ((char *) dpyinfo);\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7594, "func": "static int cirrus_post_load(void *opaque, int version_id)\n{\n    CirrusVGAState *s = opaque;\n\n    s->vga.gr[0x00] = s->cirrus_shadow_gr0 & 0x0f;\n    s->vga.gr[0x01] = s->cirrus_shadow_gr1 & 0x0f;\n\n    cirrus_update_memory_access(s);\n    s->vga.graphic_mode = -1;\n    cirrus_update_bank_ptr(s, 0);\n    cirrus_update_bank_ptr(s, 1);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7422, "func": "ZEND_API zval *zend_ts_hash_find(TsHashTable *ht, zend_string *key)\n{\n\tzval *retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_find(TS_HASH(ht), key);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8088, "func": "void Gfx::drawAnnot(Object *str, AnnotBorder *border, AnnotColor *aColor,\n\t\t    double xMin, double yMin, double xMax, double yMax) {\n  Dict *dict, *resDict;\n  Object matrixObj, bboxObj, resObj;\n  Object obj1;\n  double m[6], bbox[4], ictm[6];\n  double *ctm;\n  double formX0, formY0, formX1, formY1;\n  double annotX0, annotY0, annotX1, annotY1;\n  double det, x, y, sx, sy;\n  double r, g, b;\n  GfxColor color;\n  double *dash, *dash2;\n  int dashLength;\n  int i;\n\n\n  ctm = state->getCTM();\n  det = 1 / (ctm[0] * ctm[3] - ctm[1] * ctm[2]);\n  ictm[0] = ctm[3] * det;\n  ictm[1] = -ctm[1] * det;\n  ictm[2] = -ctm[2] * det;\n  ictm[3] = ctm[0] * det;\n  ictm[4] = (ctm[2] * ctm[5] - ctm[3] * ctm[4]) * det;\n  ictm[5] = (ctm[1] * ctm[4] - ctm[0] * ctm[5]) * det;\n  x = baseMatrix[0] * xMin + baseMatrix[2] * yMin + baseMatrix[4];\n  y = baseMatrix[1] * xMin + baseMatrix[3] * yMin + baseMatrix[5];\n  annotX0 = ictm[0] * x + ictm[2] * y + ictm[4];\n  annotY0 = ictm[1] * x + ictm[3] * y + ictm[5];\n  x = baseMatrix[0] * xMax + baseMatrix[2] * yMax + baseMatrix[4];\n  y = baseMatrix[1] * xMax + baseMatrix[3] * yMax + baseMatrix[5];\n  annotX1 = ictm[0] * x + ictm[2] * y + ictm[4];\n  annotY1 = ictm[1] * x + ictm[3] * y + ictm[5];\n  if (annotX0 > annotX1) {\n    x = annotX0; annotX0 = annotX1; annotX1 = x;\n  }\n  if (annotY0 > annotY1) {\n    y = annotY0; annotY0 = annotY1; annotY1 = y;\n  }\n\n  if (str->isStream()) {\n\n    dict = str->streamGetDict();\n\n    dict->lookup(\"BBox\", &bboxObj);\n    if (!bboxObj.isArray()) {\n      bboxObj.free();\n      error(getPos(), \"Bad form bounding box\");\n      return;\n    }\n    for (i = 0; i < 4; ++i) {\n      bboxObj.arrayGet(i, &obj1);\n      bbox[i] = obj1.getNum();\n      obj1.free();\n    }\n    bboxObj.free();\n\n    dict->lookup(\"Matrix\", &matrixObj);\n    if (matrixObj.isArray() && matrixObj.arrayGetLength() >= 6) {\n      for (i = 0; i < 6; ++i) {\n\tmatrixObj.arrayGet(i, &obj1);\n\tm[i] = obj1.getNum();\n\tobj1.free();\n      }\n    } else {\n      m[0] = 1; m[1] = 0;\n      m[2] = 0; m[3] = 1;\n      m[4] = 0; m[5] = 0;\n    }\n    matrixObj.free();\n\n    formX0 = bbox[0] * m[0] + bbox[1] * m[2] + m[4];\n    formY0 = bbox[0] * m[1] + bbox[1] * m[3] + m[5];\n    formX1 = bbox[2] * m[0] + bbox[3] * m[2] + m[4];\n    formY1 = bbox[2] * m[1] + bbox[3] * m[3] + m[5];\n    if (formX0 > formX1) {\n      x = formX0; formX0 = formX1; formX1 = x;\n    }\n    if (formY0 > formY1) {\n      y = formY0; formY0 = formY1; formY1 = y;\n    }\n\n    if (formX1 == formX0) {\n      sx = 1;\n    } else {\n      sx = (annotX1 - annotX0) / (formX1 - formX0);\n    }\n    if (formY1 == formY0) {\n      sy = 1;\n    } else {\n      sy = (annotY1 - annotY0) / (formY1 - formY0);\n    }\n    m[0] *= sx;\n    m[2] *= sx;\n    m[4] = (m[4] - formX0) * sx + annotX0;\n    m[1] *= sy;\n    m[3] *= sy;\n    m[5] = (m[5] - formY0) * sy + annotY0;\n\n    dict->lookup(\"Resources\", &resObj);\n    resDict = resObj.isDict() ? resObj.getDict() : (Dict *)NULL;\n\n    doForm1(str, resDict, m, bbox);\n\n    resObj.free();\n  }\n\n  if (border && border->getWidth() > 0) {\n    if (state->getStrokeColorSpace()->getMode() != csDeviceRGB) {\n      state->setStrokePattern(NULL);\n      state->setStrokeColorSpace(new GfxDeviceRGBColorSpace());\n      out->updateStrokeColorSpace(state);\n    }\n    if (aColor && (aColor->getSpace() == AnnotColor::colorRGB)) {\n      const double *values = aColor->getValues();\n      r = values[0];\n      g = values[1];\n      b = values[2];\n    } else {\n      r = g = b = 0;\n    };\n    color.c[0] = dblToCol(r);\n    color.c[1] = dblToCol(g);\n    color.c[2] = dblToCol(b);\n    state->setStrokeColor(&color);\n    out->updateStrokeColor(state);\n    x = (baseMatrix[0] + baseMatrix[2]) * ictm[0] +\n        (baseMatrix[1] + baseMatrix[3]) * ictm[2];\n    y = (baseMatrix[0] + baseMatrix[2]) * ictm[1] +\n        (baseMatrix[1] + baseMatrix[3]) * ictm[3];\n    x = sqrt(0.5 * (x * x + y * y));\n    state->setLineWidth(x * border->getWidth());\n    out->updateLineWidth(state);\n    dashLength = border->getDashLength();\n    dash = border->getDash();\n    if (border->getStyle() == AnnotBorder::borderDashed && dashLength > 0) {\n      dash2 = (double *)gmallocn(dashLength, sizeof(double));\n      for (i = 0; i < dashLength; ++i) {\n\tdash2[i] = x * dash[i];\n      }\n      state->setLineDash(dash2, dashLength, 0);\n      out->updateLineDash(state);\n    }\n    state->clearPath();\n    state->moveTo(annotX0, out->upsideDown() ? annotY0 : annotY1);\n    state->lineTo(annotX1, out->upsideDown() ? annotY0 : annotY1);\n    if (border->getStyle() != AnnotBorder::borderUnderlined) {\n      state->lineTo(annotX1, out->upsideDown() ? annotY1 : annotY0);\n      state->lineTo(annotX0, out->upsideDown() ? annotY1 : annotY0);\n      state->closePath();\n    }\n    out->stroke(state);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187041, "func": "void DocumentLoader::InstallNewDocument(\n    const KURL& url,\n    Document* owner_document,\n    WebGlobalObjectReusePolicy global_object_reuse_policy,\n    const AtomicString& mime_type,\n    const AtomicString& encoding,\n    InstallNewDocumentReason reason,\n    ParserSynchronizationPolicy parsing_policy,\n    const KURL& overriding_url) {\n  DCHECK(!frame_->GetDocument() || !frame_->GetDocument()->IsActive());\n  DCHECK_EQ(frame_->Tree().ChildCount(), 0u);\n  if (GetFrameLoader().StateMachine()->IsDisplayingInitialEmptyDocument()) {\n    GetFrameLoader().StateMachine()->AdvanceTo(\n        FrameLoaderStateMachine::kCommittedFirstRealLoad);\n   }\n \n   const SecurityOrigin* previous_security_origin = nullptr;\n  const ContentSecurityPolicy* previous_csp = nullptr;\n   if (frame_->GetDocument()) {\n     previous_security_origin = frame_->GetDocument()->GetSecurityOrigin();\n    previous_csp = frame_->GetDocument()->GetContentSecurityPolicy();\n   }\n \n  if (global_object_reuse_policy != WebGlobalObjectReusePolicy::kUseExisting)\n    frame_->SetDOMWindow(LocalDOMWindow::Create(*frame_));\n\n  if (reason == InstallNewDocumentReason::kNavigation)\n    WillCommitNavigation();\n\n  Document* document = frame_->DomWindow()->InstallNewDocument(\n      mime_type,\n      DocumentInit::Create()\n           .WithDocumentLoader(this)\n           .WithURL(url)\n           .WithOwnerDocument(owner_document)\n          .WithNewRegistrationContext()\n          .WithPreviousDocumentCSP(previous_csp),\n       false);\n \n  if (frame_->IsMainFrame())\n    frame_->ClearActivation();\n\n  if (frame_->HasReceivedUserGestureBeforeNavigation() !=\n      had_sticky_activation_) {\n    frame_->SetDocumentHasReceivedUserGestureBeforeNavigation(\n        had_sticky_activation_);\n    GetLocalFrameClient().SetHasReceivedUserGestureBeforeNavigation(\n        had_sticky_activation_);\n  }\n\n  if (ShouldClearWindowName(*frame_, previous_security_origin, *document)) {\n    frame_->Tree().ExperimentalSetNulledName();\n  }\n \n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n  DidInstallNewDocument(document, previous_csp);\n \n  if (reason == InstallNewDocumentReason::kNavigation)\n    DidCommitNavigation(global_object_reuse_policy);\n\n  if (GetFrameLoader().StateMachine()->CommittedFirstRealDocumentLoad()) {\n    if (document->GetSettings()\n            ->GetForceTouchEventFeatureDetectionForInspector()) {\n      OriginTrialContext::FromOrCreate(document)->AddFeature(\n          \"ForceTouchEventFeatureDetectionForInspector\");\n    }\n    OriginTrialContext::AddTokensFromHeader(\n        document, response_.HttpHeaderField(http_names::kOriginTrial));\n  }\n  bool stale_while_revalidate_enabled =\n      origin_trials::StaleWhileRevalidateEnabled(document);\n  fetcher_->SetStaleWhileRevalidateEnabled(stale_while_revalidate_enabled);\n\n  if (stale_while_revalidate_enabled &&\n      !RuntimeEnabledFeatures::StaleWhileRevalidateEnabledByRuntimeFlag())\n    UseCounter::Count(frame_, WebFeature::kStaleWhileRevalidateEnabled);\n\n  parser_ = document->OpenForNavigation(parsing_policy, mime_type, encoding);\n\n  ScriptableDocumentParser* scriptable_parser =\n      parser_->AsScriptableDocumentParser();\n  if (scriptable_parser && GetResource()) {\n    scriptable_parser->SetInlineScriptCacheHandler(\n        ToRawResource(GetResource())->InlineScriptCacheHandler());\n  }\n\n  WTF::String feature_policy(\n      response_.HttpHeaderField(http_names::kFeaturePolicy));\n  MergeFeaturesFromOriginPolicy(feature_policy, request_.GetOriginPolicy());\n  document->ApplyFeaturePolicyFromHeader(feature_policy);\n\n  GetFrameLoader().DispatchDidClearDocumentOfWindowObject();\n}\n", "target": 1, "flaw_line_index": "18,21,44,45,75"}
{"idx": 7645, "func": "static struct dirent *proxy_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    return readdir(fs->dir.stream);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186582, "func": "String TextCodecUTF8::Decode(const char* bytes,\n                             wtf_size_t length,\n                             FlushBehavior flush,\n                             bool stop_on_error,\n                             bool& saw_error) {\n  const bool do_flush = flush != FlushBehavior::kDoNotFlush;\n  StringBuffer<LChar> buffer(partial_sequence_size_ + length);\n \n   const uint8_t* source = reinterpret_cast<const uint8_t*>(bytes);\n   const uint8_t* end = source + length;\n  const uint8_t* aligned_end = AlignToMachineWord(end);\n  LChar* destination = buffer.Characters();\n\n  do {\n    if (partial_sequence_size_) {\n      LChar* destination_for_handle_partial_sequence = destination;\n      const uint8_t* source_for_handle_partial_sequence = source;\n      if (HandlePartialSequence(destination_for_handle_partial_sequence,\n                                source_for_handle_partial_sequence, end,\n                                do_flush, stop_on_error, saw_error)) {\n        source = source_for_handle_partial_sequence;\n        goto upConvertTo16Bit;\n      }\n      destination = destination_for_handle_partial_sequence;\n      source = source_for_handle_partial_sequence;\n      if (partial_sequence_size_)\n        break;\n    }\n\n    while (source < end) {\n      if (IsASCII(*source)) {\n        if (IsAlignedToMachineWord(source)) {\n          while (source < aligned_end) {\n            MachineWord chunk =\n                *reinterpret_cast_ptr<const MachineWord*>(source);\n            if (!IsAllASCII<LChar>(chunk))\n              break;\n            CopyASCIIMachineWord(destination, source);\n            source += sizeof(MachineWord);\n            destination += sizeof(MachineWord);\n          }\n          if (source == end)\n            break;\n          if (!IsASCII(*source))\n            continue;\n        }\n        *destination++ = *source++;\n        continue;\n      }\n      int count = NonASCIISequenceLength(*source);\n      int character;\n      if (count == 0) {\n        character = kNonCharacter1;\n      } else {\n        if (count > end - source) {\n          SECURITY_DCHECK(end - source <\n                          static_cast<ptrdiff_t>(sizeof(partial_sequence_)));\n          DCHECK(!partial_sequence_size_);\n          partial_sequence_size_ = static_cast<wtf_size_t>(end - source);\n          memcpy(partial_sequence_, source, partial_sequence_size_);\n          source = end;\n          break;\n        }\n        character = DecodeNonASCIISequence(source, count);\n      }\n      if (IsNonCharacter(character)) {\n        saw_error = true;\n        if (stop_on_error)\n          break;\n\n        goto upConvertTo16Bit;\n      }\n      if (character > 0xff)\n        goto upConvertTo16Bit;\n\n      source += count;\n      *destination++ = static_cast<LChar>(character);\n    }\n  } while (do_flush && partial_sequence_size_);\n\n  buffer.Shrink(static_cast<wtf_size_t>(destination - buffer.Characters()));\n\n   return String::Adopt(buffer);\n \n upConvertTo16Bit:\n  StringBuffer<UChar> buffer16(partial_sequence_size_ + length);\n \n   UChar* destination16 = buffer16.Characters();\n \n  for (LChar* converted8 = buffer.Characters(); converted8 < destination;)\n    *destination16++ = *converted8++;\n\n  do {\n    if (partial_sequence_size_) {\n      UChar* destination_for_handle_partial_sequence = destination16;\n      const uint8_t* source_for_handle_partial_sequence = source;\n      HandlePartialSequence(destination_for_handle_partial_sequence,\n                            source_for_handle_partial_sequence, end, do_flush,\n                            stop_on_error, saw_error);\n      destination16 = destination_for_handle_partial_sequence;\n      source = source_for_handle_partial_sequence;\n      if (partial_sequence_size_)\n        break;\n    }\n\n    while (source < end) {\n      if (IsASCII(*source)) {\n        if (IsAlignedToMachineWord(source)) {\n          while (source < aligned_end) {\n            MachineWord chunk =\n                *reinterpret_cast_ptr<const MachineWord*>(source);\n            if (!IsAllASCII<LChar>(chunk))\n              break;\n            CopyASCIIMachineWord(destination16, source);\n            source += sizeof(MachineWord);\n            destination16 += sizeof(MachineWord);\n          }\n          if (source == end)\n            break;\n          if (!IsASCII(*source))\n            continue;\n        }\n        *destination16++ = *source++;\n        continue;\n      }\n      int count = NonASCIISequenceLength(*source);\n      int character;\n      if (count == 0) {\n        character = kNonCharacter1;\n      } else {\n        if (count > end - source) {\n          SECURITY_DCHECK(end - source <\n                          static_cast<ptrdiff_t>(sizeof(partial_sequence_)));\n          DCHECK(!partial_sequence_size_);\n          partial_sequence_size_ = static_cast<wtf_size_t>(end - source);\n          memcpy(partial_sequence_, source, partial_sequence_size_);\n          source = end;\n          break;\n        }\n        character = DecodeNonASCIISequence(source, count);\n      }\n      if (IsNonCharacter(character)) {\n        saw_error = true;\n        if (stop_on_error)\n          break;\n        *destination16++ = kReplacementCharacter;\n        source -= character;\n        continue;\n      }\n      source += count;\n      destination16 = AppendCharacter(destination16, character);\n    }\n  } while (do_flush && partial_sequence_size_);\n\n  buffer16.Shrink(\n      static_cast<wtf_size_t>(destination16 - buffer16.Characters()));\n\n  return String::Adopt(buffer16);\n}\n", "target": 1, "flaw_line_index": "10,93"}
{"idx": 187151, "func": "gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {\n  if (ShouldApplyDisplayCentering())\n    return CalculatePaddingForDisplayCentering();\n \n   const int icons_size = shelf_view_->GetSizeOfAppIcons(\n       shelf_view_->number_of_visible_apps(), false);\n  gfx::Insets padding_insets(\n 0,\n ShelfConfig::Get()->app_icon_group_margin());\n \n   const int available_size_for_app_icons =\n       (GetShelf()->IsHorizontalAlignment() ? width() : height()) -\n      2 * ShelfConfig::Get()->app_icon_group_margin();\n\n  int gap =\n      layout_strategy_ == kNotShowArrowButtons\n           ? available_size_for_app_icons - icons_size  \n           : CalculateOverflowPadding(available_size_for_app_icons);  \n \n  padding_insets.set_left(padding_insets.left() + gap / 2);\n  padding_insets.set_right(padding_insets.right() +\n                           (gap % 2 ? gap / 2 + 1 : gap / 2));\n \n   return padding_insets;\n }\n", "target": 1, "flaw_line_index": "8,9,10,21,22,23"}
{"idx": 7515, "func": "  tt_glyphzone_done( TT_GlyphZone  zone )\n  {\n    FT_Memory  memory = zone->memory;\n\n\n    if ( memory )\n    {\n      FT_FREE( zone->contours );\n      FT_FREE( zone->tags );\n      FT_FREE( zone->cur );\n      FT_FREE( zone->org );\n      FT_FREE( zone->orus );\n\n      zone->max_points   = zone->n_points   = 0;\n      zone->max_contours = zone->n_contours = 0;\n      zone->memory       = NULL;\n    }\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7784, "func": "static inline __maybe_unused void h2_skip_frame_hdr(struct buffer *b)\n{\n\tbi_del(b, 9);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186683, "func": "void HeapAllocator::backingFree(void* address) {\n  if (!address)\n    return;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return;\n  ASSERT(!state->isInGC());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   state->promptlyFreed(header->gcInfoIndex());\n   arena->promptlyFreeObject(header);\n}\n", "target": 1, "flaw_line_index": "17"}
{"idx": 186343, "func": "PreconnectedRequestStats::PreconnectedRequestStats(const GURL& origin,\n                                                    bool was_preconnected)\n    : origin(origin),\n      was_preconnected(was_preconnected) {}\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 186859, "func": "MojoResult Core::UnwrapPlatformSharedBufferHandle(\n    MojoHandle mojo_handle,\n    MojoPlatformHandle* platform_handle,\n    size_t* size,\n    MojoSharedBufferGuid* guid,\n    MojoPlatformSharedBufferHandleFlags* flags) {\n  scoped_refptr<Dispatcher> dispatcher;\n  MojoResult result = MOJO_RESULT_OK;\n  {\n    base::AutoLock lock(handles_->GetLock());\n    result = handles_->GetAndRemoveDispatcher(mojo_handle, &dispatcher);\n    if (result != MOJO_RESULT_OK)\n      return result;\n  }\n\n  if (dispatcher->GetType() != Dispatcher::Type::SHARED_BUFFER) {\n    dispatcher->Close();\n    return MOJO_RESULT_INVALID_ARGUMENT;\n  }\n\n  SharedBufferDispatcher* shm_dispatcher =\n      static_cast<SharedBufferDispatcher*>(dispatcher.get());\n  scoped_refptr<PlatformSharedBuffer> platform_shared_buffer =\n      shm_dispatcher->PassPlatformSharedBuffer();\n  DCHECK(platform_shared_buffer);\n\n  DCHECK(size);\n  *size = platform_shared_buffer->GetNumBytes();\n\n  base::UnguessableToken token = platform_shared_buffer->GetGUID();\n  guid->high = token.GetHighForSerialization();\n  guid->low = token.GetLowForSerialization();\n\n   DCHECK(flags);\n   *flags = MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;\n   if (platform_shared_buffer->IsReadOnly())\n    *flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n \n   ScopedPlatformHandle handle = platform_shared_buffer->PassPlatformHandle();\n   return ScopedPlatformHandleToMojoPlatformHandle(std::move(handle),\n                                                  platform_handle);\n}\n", "target": 1, "flaw_line_index": "37"}
{"idx": 8284, "func": "XRRScreenSize *XRRConfigSizes(XRRScreenConfiguration *config, int *nsizes)\n{\n   *nsizes = config->nsizes;\n  return config->sizes;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187105, "func": "bool BrowserCommandController::ExecuteCommandWithDisposition(\n    int id, WindowOpenDisposition disposition) {\n  if (!SupportsCommand(id) || !IsCommandEnabled(id))\n    return false;\n\n  if (browser_->tab_strip_model()->active_index() == TabStripModel::kNoTab)\n    return true;\n\n  DCHECK(command_updater_.IsCommandEnabled(id)) << \"Invalid/disabled command \"\n                                                << id;\n\n  switch (id) {\n    case IDC_BACK:\n      GoBack(browser_, disposition);\n      break;\n    case IDC_FORWARD:\n      GoForward(browser_, disposition);\n      break;\n    case IDC_RELOAD:\n      Reload(browser_, disposition);\n      break;\n    case IDC_RELOAD_CLEARING_CACHE:\n      ClearCache(browser_);\n      FALLTHROUGH;\n    case IDC_RELOAD_BYPASSING_CACHE:\n      ReloadBypassingCache(browser_, disposition);\n      break;\n    case IDC_HOME:\n      Home(browser_, disposition);\n      break;\n    case IDC_OPEN_CURRENT_URL:\n      OpenCurrentURL(browser_);\n      break;\n    case IDC_STOP:\n      Stop(browser_);\n      break;\n\n    case IDC_NEW_WINDOW:\n      NewWindow(browser_);\n      break;\n    case IDC_NEW_INCOGNITO_WINDOW:\n      NewIncognitoWindow(profile());\n      break;\n    case IDC_CLOSE_WINDOW:\n      base::RecordAction(base::UserMetricsAction(\"CloseWindowByKey\"));\n      CloseWindow(browser_);\n      break;\n    case IDC_NEW_TAB: {\n      NewTab(browser_);\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      auto* new_tab_tracker =\n          feature_engagement::NewTabTrackerFactory::GetInstance()\n              ->GetForProfile(profile());\n\n      new_tab_tracker->OnNewTabOpened();\n      new_tab_tracker->CloseBubble();\n#endif\n      break;\n    }\n    case IDC_CLOSE_TAB:\n      base::RecordAction(base::UserMetricsAction(\"CloseTabByKey\"));\n      CloseTab(browser_);\n      break;\n    case IDC_SELECT_NEXT_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNextTab\"));\n      SelectNextTab(browser_);\n      break;\n    case IDC_SELECT_PREVIOUS_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectPreviousTab\"));\n      SelectPreviousTab(browser_);\n      break;\n    case IDC_MOVE_TAB_NEXT:\n      MoveTabNext(browser_);\n      break;\n    case IDC_MOVE_TAB_PREVIOUS:\n      MoveTabPrevious(browser_);\n      break;\n    case IDC_SELECT_TAB_0:\n    case IDC_SELECT_TAB_1:\n    case IDC_SELECT_TAB_2:\n    case IDC_SELECT_TAB_3:\n    case IDC_SELECT_TAB_4:\n    case IDC_SELECT_TAB_5:\n    case IDC_SELECT_TAB_6:\n    case IDC_SELECT_TAB_7:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNumberedTab\"));\n      SelectNumberedTab(browser_, id - IDC_SELECT_TAB_0);\n      break;\n    case IDC_SELECT_LAST_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNumberedTab\"));\n      SelectLastTab(browser_);\n      break;\n    case IDC_DUPLICATE_TAB:\n      DuplicateTab(browser_);\n      break;\n    case IDC_RESTORE_TAB:\n      RestoreTab(browser_);\n      break;\n    case IDC_SHOW_AS_TAB:\n      ConvertPopupToTabbedBrowser(browser_);\n      break;\n    case IDC_FULLSCREEN:\n      chrome::ToggleFullscreenMode(browser_);\n      break;\n    case IDC_OPEN_IN_PWA_WINDOW:\n      base::RecordAction(base::UserMetricsAction(\"OpenActiveTabInPwaWindow\"));\n      ReparentSecureActiveTabIntoPwaWindow(browser_);\n      break;\n\n#if defined(OS_CHROMEOS)\n    case IDC_VISIT_DESKTOP_OF_LRU_USER_2:\n    case IDC_VISIT_DESKTOP_OF_LRU_USER_3:\n      ExecuteVisitDesktopCommand(id, window()->GetNativeWindow());\n      break;\n#endif\n\n#if defined(OS_LINUX) && !defined(OS_CHROMEOS)\n    case IDC_MINIMIZE_WINDOW:\n      browser_->window()->Minimize();\n      break;\n    case IDC_MAXIMIZE_WINDOW:\n      browser_->window()->Maximize();\n      break;\n    case IDC_RESTORE_WINDOW:\n      browser_->window()->Restore();\n      break;\n    case IDC_USE_SYSTEM_TITLE_BAR: {\n      PrefService* prefs = profile()->GetPrefs();\n      prefs->SetBoolean(prefs::kUseCustomChromeFrame,\n                        !prefs->GetBoolean(prefs::kUseCustomChromeFrame));\n      break;\n    }\n#endif\n\n#if defined(OS_MACOSX)\n    case IDC_TOGGLE_FULLSCREEN_TOOLBAR:\n       chrome::ToggleFullscreenToolbar(browser_);\n       break;\n     case IDC_TOGGLE_JAVASCRIPT_APPLE_EVENTS: {\n      PrefService* prefs = profile()->GetPrefs();\n      prefs->SetBoolean(prefs::kAllowJavascriptAppleEvents,\n                        !prefs->GetBoolean(prefs::kAllowJavascriptAppleEvents));\n       break;\n     }\n #endif\n    case IDC_EXIT:\n      Exit();\n      break;\n\n    case IDC_SAVE_PAGE:\n      SavePage(browser_);\n      break;\n    case IDC_BOOKMARK_PAGE:\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      feature_engagement::BookmarkTrackerFactory::GetInstance()\n          ->GetForProfile(profile())\n          ->OnBookmarkAdded();\n#endif\n      BookmarkCurrentPageAllowingExtensionOverrides(browser_);\n      break;\n    case IDC_BOOKMARK_ALL_TABS:\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      feature_engagement::BookmarkTrackerFactory::GetInstance()\n          ->GetForProfile(profile())\n          ->OnBookmarkAdded();\n#endif\n      BookmarkAllTabs(browser_);\n      break;\n    case IDC_VIEW_SOURCE:\n      browser_->tab_strip_model()\n          ->GetActiveWebContents()\n          ->GetMainFrame()\n          ->ViewSource();\n      break;\n    case IDC_EMAIL_PAGE_LOCATION:\n      EmailPageLocation(browser_);\n      break;\n    case IDC_PRINT:\n      Print(browser_);\n      break;\n\n#if BUILDFLAG(ENABLE_PRINTING)\n    case IDC_BASIC_PRINT:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Advanced_Print\"));\n      BasicPrint(browser_);\n      break;\n#endif  \n\n    case IDC_SAVE_CREDIT_CARD_FOR_PAGE:\n      SaveCreditCard(browser_);\n      break;\n    case IDC_MIGRATE_LOCAL_CREDIT_CARD_FOR_PAGE:\n      MigrateLocalCards(browser_);\n      break;\n    case IDC_TRANSLATE_PAGE:\n      Translate(browser_);\n      break;\n    case IDC_MANAGE_PASSWORDS_FOR_PAGE:\n      ManagePasswordsForPage(browser_);\n      break;\n\n    case IDC_CUT:\n    case IDC_COPY:\n    case IDC_PASTE:\n      CutCopyPaste(browser_, id);\n      break;\n\n    case IDC_FIND:\n      Find(browser_);\n      break;\n    case IDC_FIND_NEXT:\n      FindNext(browser_);\n      break;\n    case IDC_FIND_PREVIOUS:\n      FindPrevious(browser_);\n      break;\n\n    case IDC_ZOOM_PLUS:\n      Zoom(browser_, content::PAGE_ZOOM_IN);\n      break;\n    case IDC_ZOOM_NORMAL:\n      Zoom(browser_, content::PAGE_ZOOM_RESET);\n      break;\n    case IDC_ZOOM_MINUS:\n      Zoom(browser_, content::PAGE_ZOOM_OUT);\n      break;\n\n    case IDC_FOCUS_TOOLBAR:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Toolbar\"));\n      FocusToolbar(browser_);\n      break;\n    case IDC_FOCUS_LOCATION:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Location\"));\n      FocusLocationBar(browser_);\n      break;\n    case IDC_FOCUS_SEARCH:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Search\"));\n      FocusSearch(browser_);\n      break;\n    case IDC_FOCUS_MENU_BAR:\n      FocusAppMenu(browser_);\n      break;\n    case IDC_FOCUS_BOOKMARKS:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Bookmarks\"));\n      FocusBookmarksToolbar(browser_);\n      break;\n    case IDC_FOCUS_INACTIVE_POPUP_FOR_ACCESSIBILITY:\n      FocusInactivePopupForAccessibility(browser_);\n      break;\n    case IDC_FOCUS_NEXT_PANE:\n      FocusNextPane(browser_);\n      break;\n    case IDC_FOCUS_PREVIOUS_PANE:\n      FocusPreviousPane(browser_);\n      break;\n\n    case IDC_OPEN_FILE:\n      browser_->OpenFile();\n      break;\n    case IDC_CREATE_SHORTCUT:\n      CreateBookmarkAppFromCurrentWebContents(browser_,\n                                              true \n);\n      break;\n    case IDC_INSTALL_PWA:\n      CreateBookmarkAppFromCurrentWebContents(browser_,\n                                              false \n);\n      break;\n    case IDC_DEV_TOOLS:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Show());\n      break;\n    case IDC_DEV_TOOLS_CONSOLE:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::ShowConsolePanel());\n      break;\n    case IDC_DEV_TOOLS_DEVICES:\n      InspectUI::InspectDevices(browser_);\n      break;\n    case IDC_DEV_TOOLS_INSPECT:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Inspect());\n      break;\n    case IDC_DEV_TOOLS_TOGGLE:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Toggle());\n      break;\n    case IDC_TASK_MANAGER:\n      OpenTaskManager(browser_);\n      break;\n#if defined(OS_CHROMEOS)\n    case IDC_TAKE_SCREENSHOT:\n      TakeScreenshot();\n      break;\n#endif\n#if defined(GOOGLE_CHROME_BUILD)\n    case IDC_FEEDBACK:\n      OpenFeedbackDialog(browser_, kFeedbackSourceBrowserCommand);\n      break;\n#endif\n    case IDC_SHOW_BOOKMARK_BAR:\n      ToggleBookmarkBar(browser_);\n      break;\n    case IDC_PROFILING_ENABLED:\n      Profiling::Toggle();\n      break;\n\n    case IDC_SHOW_BOOKMARK_MANAGER:\n      ShowBookmarkManager(browser_);\n      break;\n    case IDC_SHOW_APP_MENU:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Show_App_Menu\"));\n      ShowAppMenu(browser_);\n      break;\n    case IDC_SHOW_AVATAR_MENU:\n      ShowAvatarMenu(browser_);\n      break;\n    case IDC_SHOW_HISTORY:\n      ShowHistory(browser_);\n      break;\n    case IDC_SHOW_DOWNLOADS:\n      ShowDownloads(browser_);\n      break;\n    case IDC_MANAGE_EXTENSIONS:\n      ShowExtensions(browser_, std::string());\n      break;\n    case IDC_OPTIONS:\n      ShowSettings(browser_);\n      break;\n    case IDC_EDIT_SEARCH_ENGINES:\n      ShowSearchEngineSettings(browser_);\n      break;\n    case IDC_VIEW_PASSWORDS:\n      ShowPasswordManager(browser_);\n      break;\n    case IDC_CLEAR_BROWSING_DATA:\n      ShowClearBrowsingDataDialog(browser_);\n      break;\n    case IDC_IMPORT_SETTINGS:\n      ShowImportDialog(browser_);\n      break;\n    case IDC_TOGGLE_REQUEST_TABLET_SITE:\n      ToggleRequestTabletSite(browser_);\n      break;\n    case IDC_ABOUT:\n      ShowAboutChrome(browser_);\n      break;\n    case IDC_UPGRADE_DIALOG:\n      OpenUpdateChromeDialog(browser_);\n      break;\n    case IDC_HELP_PAGE_VIA_KEYBOARD:\n      ShowHelp(browser_, HELP_SOURCE_KEYBOARD);\n      break;\n    case IDC_HELP_PAGE_VIA_MENU:\n      ShowHelp(browser_, HELP_SOURCE_MENU);\n      break;\n    case IDC_SHOW_BETA_FORUM:\n      ShowBetaForum(browser_);\n      break;\n    case IDC_SHOW_SIGNIN:\n      ShowBrowserSigninOrSettings(\n          browser_, signin_metrics::AccessPoint::ACCESS_POINT_MENU);\n      break;\n    case IDC_DISTILL_PAGE:\n      DistillCurrentPage(browser_);\n      break;\n    case IDC_ROUTE_MEDIA:\n      RouteMedia(browser_);\n      break;\n    case IDC_WINDOW_MUTE_SITE:\n      MuteSite(browser_);\n      break;\n    case IDC_WINDOW_PIN_TAB:\n      PinTab(browser_);\n      break;\n\n    case IDC_COPY_URL:\n      CopyURL(browser_);\n      break;\n    case IDC_OPEN_IN_CHROME:\n      OpenInChrome(browser_);\n      break;\n    case IDC_SITE_SETTINGS:\n      ShowSiteSettings(\n          browser_,\n          browser_->tab_strip_model()->GetActiveWebContents()->GetVisibleURL());\n      break;\n    case IDC_HOSTED_APP_MENU_APP_INFO:\n      ShowPageInfoDialog(browser_->tab_strip_model()->GetActiveWebContents(),\n                         bubble_anchor_util::kAppMenuButton);\n      break;\n\n    default:\n      LOG(WARNING) << \"Received Unimplemented Command: \" << id;\n      break;\n  }\n\n  return true;\n}\n", "target": 1, "flaw_line_index": "158,159,160"}
{"idx": 186443, "func": " void WorkerFetchContext::DispatchDidBlockRequest(\n     const ResourceRequest& resource_request,\n     const FetchInitiatorInfo& fetch_initiator_info,\n    ResourceRequestBlockedReason blocked_reason) const {\n   probe::didBlockRequest(global_scope_, resource_request, nullptr,\n                         fetch_initiator_info, blocked_reason);\n }\n", "target": 1, "flaw_line_index": "4,6"}
{"idx": 7940, "func": "static void label(JF, int inst)\n{\n\tlabelto(J, F, inst, F->codelen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186727, "func": " void IOHandler::Read(\n    const std::string& handle,\n    Maybe<int> offset,\n    Maybe<int> max_size,\n    std::unique_ptr<ReadCallback> callback) {\n  static const size_t kDefaultChunkSize = 10 * 1024 * 1024;\n  static const char kBlobPrefix[] = \"blob:\";\n \n   scoped_refptr<DevToolsIOContext::ROStream> stream =\n       io_context_->GetByHandle(handle);\n  if (!stream && process_host_ &&\n       StartsWith(handle, kBlobPrefix, base::CompareCase::SENSITIVE)) {\n    BrowserContext* browser_context = process_host_->GetBrowserContext();\n     ChromeBlobStorageContext* blob_context =\n        ChromeBlobStorageContext::GetFor(browser_context);\n    StoragePartition* storage_partition = process_host_->GetStoragePartition();\n     std::string uuid = handle.substr(strlen(kBlobPrefix));\n     stream =\n        io_context_->OpenBlob(blob_context, storage_partition, handle, uuid);\n   }\n \n   if (!stream) {\n    callback->sendFailure(Response::InvalidParams(\"Invalid stream handle\"));\n    return;\n  }\n  stream->Read(\n      offset.fromMaybe(-1), max_size.fromMaybe(kDefaultChunkSize),\n      base::BindOnce(&IOHandler::ReadComplete, weak_factory_.GetWeakPtr(),\n                     base::Passed(std::move(callback))));\n}\n", "target": 1, "flaw_line_index": "11,13,15,16,19"}
{"idx": 186465, "func": "void UkmPageLoadMetricsObserver::RecordPageLoadExtraInfoMetrics(\n    const page_load_metrics::PageLoadExtraInfo& info,\n    base::TimeTicks app_background_time) {\n  ukm::builders::PageLoad builder(info.source_id);\n  base::Optional<base::TimeDelta> foreground_duration =\n      page_load_metrics::GetInitialForegroundDuration(info,\n                                                      app_background_time);\n  if (foreground_duration) {\n    builder.SetPageTiming_ForegroundDuration(\n         foreground_duration.value().InMilliseconds());\n   }\n \n   metrics::SystemProfileProto::Network::EffectiveConnectionType\n      proto_effective_connection_type =\n          metrics::ConvertEffectiveConnectionType(effective_connection_type_);\n  if (proto_effective_connection_type !=\n      metrics::SystemProfileProto::Network::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {\n    builder.SetNet_EffectiveConnectionType2_OnNavigationStart(\n        static_cast<int64_t>(proto_effective_connection_type));\n  }\n\n  if (http_response_code_) {\n    builder.SetNet_HttpResponseCode(\n        static_cast<int64_t>(http_response_code_.value()));\n  }\n  if (http_rtt_estimate_) {\n    builder.SetNet_HttpRttEstimate_OnNavigationStart(\n        static_cast<int64_t>(http_rtt_estimate_.value().InMilliseconds()));\n  }\n  if (transport_rtt_estimate_) {\n    builder.SetNet_TransportRttEstimate_OnNavigationStart(\n        static_cast<int64_t>(transport_rtt_estimate_.value().InMilliseconds()));\n  }\n  if (downstream_kbps_estimate_) {\n    builder.SetNet_DownstreamKbpsEstimate_OnNavigationStart(\n        static_cast<int64_t>(downstream_kbps_estimate_.value()));\n  }\n  builder.SetNavigation_PageTransition(static_cast<int64_t>(page_transition_));\n  builder.SetNavigation_PageEndReason(\n      static_cast<int64_t>(info.page_end_reason));\n  if (info.did_commit && was_cached_) {\n    builder.SetWasCached(1);\n  }\n  builder.Record(ukm::UkmRecorder::Get());\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8279, "func": "Bool XRenderQueryExtension (Display *dpy, int *event_basep, int *error_basep)\n{\n    XRenderExtDisplayInfo *info = XRenderFindDisplay (dpy);\n\n    if (RenderHasExtension(info)) {\n\t*event_basep = info->codes->first_event;\n\t*error_basep = info->codes->first_error;\n\treturn True;\n    } else {\n\treturn False;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7535, "func": "void doMergeNameDict(PDFDoc *doc, XRef *srcXRef, XRef *countRef, int oldRefNum, int newRefNum, Dict *srcNameDict, Dict *mergeNameDict, int numOffset) {\n  for (int i = 0; i < mergeNameDict->getLength(); i++) {\n    const char *key = mergeNameDict->getKey(i);\n    Object mergeNameTree;\n    Object srcNameTree;\n    mergeNameDict->lookup(key, &mergeNameTree);\n    srcNameDict->lookup(key, &srcNameTree);\n    if (srcNameTree.isDict() && mergeNameTree.isDict()) {\n      doMergeNameTree(doc, srcXRef, countRef, oldRefNum, newRefNum, srcNameTree.getDict(), mergeNameTree.getDict(), numOffset);\n    } else if (srcNameTree.isNull() && mergeNameTree.isDict()) {\n      Object *newNameTree = new Object();\n      newNameTree->initDict(srcXRef);\n      doMergeNameTree(doc, srcXRef, countRef, oldRefNum, newRefNum, newNameTree->getDict(), mergeNameTree.getDict(), numOffset);\n      srcNameDict->add(copyString(key), newNameTree);\n    }\n    srcNameTree.free();\n    mergeNameTree.free();\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7887, "func": "uint64_t xbzrle_mig_pages_transferred(void)\n{\n    return acct_info.xbzrle_pages;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7802, "func": "static inline __maybe_unused int h2c_mux_busy(const struct h2c *h2c, const struct h2s *h2s)\n{\n\tif (h2c->msi < 0)\n\t\treturn 0;\n\n\tif (h2c->msi == h2s_id(h2s))\n\t\treturn 0;\n\n\treturn 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187085, "func": " void MediaStreamManager::CancelRequest(int render_process_id,\n                                        int render_frame_id,\n                                        int page_request_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   for (const LabeledDeviceRequest& labeled_request : requests_) {\n     DeviceRequest* const request = labeled_request.second;\n     if (request->requesting_process_id == render_process_id &&\n         request->requesting_frame_id == render_frame_id &&\n         request->page_request_id == page_request_id) {\n       CancelRequest(labeled_request.first);\n       return;\n    }\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186468, "func": "static PassRefPtr<Uint8Array> copySkImageData(SkImage* input,\n                                               const SkImageInfo& info) {\n  size_t width = static_cast<size_t>(input->width());\n   RefPtr<ArrayBuffer> dstBuffer =\n       ArrayBuffer::createOrNull(width * input->height(), info.bytesPerPixel());\n   if (!dstBuffer)\n    return nullptr;\n  RefPtr<Uint8Array> dstPixels =\n      Uint8Array::create(dstBuffer, 0, dstBuffer->byteLength());\n  input->readPixels(info, dstPixels->data(), width * info.bytesPerPixel(), 0,\n                    0);\n  return dstPixels;\n}\n", "target": 1, "flaw_line_index": "5,6"}
{"idx": 8305, "func": "XFixesCreateRegionFromPicture (Display *dpy, XID picture)\n{\n    XFixesExtDisplayInfo\t\t*info = XFixesFindDisplay (dpy);\n    xXFixesCreateRegionFromPictureReq\t*req;\n    XserverRegion\t\t\tregion;\n\n    XFixesCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (XFixesCreateRegionFromPicture, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesCreateRegionFromPicture;\n    region = req->region = XAllocID (dpy);\n    req->picture = picture;\n    UnlockDisplay (dpy);\n    SyncHandle();\n    return region;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187120, "func": " void GCInfoTable::Resize() {\n  static const int kGcInfoZapValue = 0x33;\n  const size_t kInitialSize = 512;\n  size_t new_size =\n      gc_info_table_size_ ? 2 * gc_info_table_size_ : kInitialSize;\n  DCHECK(new_size < GCInfoTable::kMaxIndex);\n  g_gc_info_table =\n      reinterpret_cast<GCInfo const**>(WTF::Partitions::FastRealloc(\n          g_gc_info_table, new_size * sizeof(GCInfo), \"GCInfo\"));\n  DCHECK(g_gc_info_table);\n  memset(reinterpret_cast<uint8_t*>(g_gc_info_table) +\n             gc_info_table_size_ * sizeof(GCInfo),\n         kGcInfoZapValue, (new_size - gc_info_table_size_) * sizeof(GCInfo));\n  gc_info_table_size_ = new_size;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"}
{"idx": 8275, "func": "XRenderExtFindDisplay (XRenderExtInfo *extinfo,\n                       Display        *dpy)\n{\n    XRenderExtDisplayInfo *dpyinfo;\n\n    if ((dpyinfo = extinfo->cur) && dpyinfo->display == dpy)\n        return dpyinfo;\n\n    _XLockMutex(_Xglobal_lock);\n    for (dpyinfo = extinfo->head; dpyinfo; dpyinfo = dpyinfo->next) {\n        if (dpyinfo->display == dpy) {\n            extinfo->cur = dpyinfo;     \n            _XUnlockMutex(_Xglobal_lock);\n            return dpyinfo;\n        }\n    }\n    _XUnlockMutex(_Xglobal_lock);\n\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7651, "func": "static void proxy_seekdir(FsContext *ctx, V9fsFidOpenState *fs, off_t off)\n{\n    seekdir(fs->dir.stream, off);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187287, "func": "bool GetNetworkList(NetworkInterfaceList* networks, int policy) {\n  if (networks == NULL)\n    return false;\n\n  base::ThreadRestrictions::AssertIOAllowed();\n\n  ifaddrs* interfaces;\n  if (getifaddrs(&interfaces) < 0) {\n    PLOG(ERROR) << \"getifaddrs\";\n    return false;\n  }\n\n   std::unique_ptr<internal::IPAttributesGetter> ip_attributes_getter;\n \n #if defined(OS_MACOSX) && !defined(OS_IOS)\n  ip_attributes_getter = base::MakeUnique<internal::IPAttributesGetterMac>();\n #endif\n \n   bool result = internal::IfaddrsToNetworkInterfaceList(\n      policy, interfaces, ip_attributes_getter.get(), networks);\n  freeifaddrs(interfaces);\n  return result;\n}\n", "target": 1, "flaw_line_index": "17"}
{"idx": 186314, "func": " MediaControlsProgressView::MediaControlsProgressView(\n     base::RepeatingCallback<void(double)> seek_callback)\n     : seek_callback_(std::move(seek_callback)) {\n   SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical, kProgressViewInsets));\n \n  progress_bar_ = AddChildView(std::make_unique<views::ProgressBar>(5, false));\n  progress_bar_->SetBorder(views::CreateEmptyBorder(kProgressBarInsets));\n \n   gfx::Font default_font;\n  int font_size_delta = kProgressTimeFontSize - default_font.GetFontSize();\n  gfx::Font font = default_font.Derive(font_size_delta, gfx::Font::NORMAL,\n                                       gfx::Font::Weight::NORMAL);\n  gfx::FontList font_list(font);\n\n  auto time_view = std::make_unique<views::View>();\n  auto* time_view_layout =\n      time_view->SetLayoutManager(std::make_unique<views::FlexLayout>());\n  time_view_layout->SetOrientation(views::LayoutOrientation::kHorizontal)\n      .SetMainAxisAlignment(views::LayoutAlignment::kCenter)\n      .SetCrossAxisAlignment(views::LayoutAlignment::kCenter)\n      .SetCollapseMargins(true);\n\n  auto progress_time = std::make_unique<views::Label>();\n  progress_time->SetFontList(font_list);\n  progress_time->SetEnabledColor(SK_ColorWHITE);\n  progress_time->SetAutoColorReadabilityEnabled(false);\n  progress_time_ = time_view->AddChildView(std::move(progress_time));\n\n  auto time_spacing = std::make_unique<views::View>();\n  time_spacing->SetPreferredSize(kTimeSpacingSize);\n  time_spacing->SetProperty(views::kFlexBehaviorKey,\n                            views::FlexSpecification::ForSizeRule(\n                                views::MinimumFlexSizeRule::kPreferred,\n                                views::MaximumFlexSizeRule::kUnbounded));\n  time_view->AddChildView(std::move(time_spacing));\n\n  auto duration = std::make_unique<views::Label>();\n  duration->SetFontList(font_list);\n  duration->SetEnabledColor(SK_ColorWHITE);\n  duration->SetAutoColorReadabilityEnabled(false);\n  duration_ = time_view->AddChildView(std::move(duration));\n\n  AddChildView(std::move(time_view));\n}\n", "target": 1, "flaw_line_index": "5,7,8"}
{"idx": 186765, "func": " BrowserContext* SharedWorkerDevToolsAgentHost::GetBrowserContext() {\n  RenderProcessHost* rph = GetProcess();\n   return rph ? rph->GetBrowserContext() : nullptr;\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 186854, "func": "void MojoAudioInputStream::OnStreamCreated(\n    int stream_id,\n    const base::SharedMemory* shared_memory,\n    std::unique_ptr<base::CancelableSyncSocket> foreign_socket,\n    bool initially_muted) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(stream_created_callback_);\n  DCHECK(shared_memory);\n  DCHECK(foreign_socket);\n\n  base::SharedMemoryHandle foreign_memory_handle =\n      shared_memory->GetReadOnlyHandle();\n  if (!base::SharedMemory::IsHandleValid(foreign_memory_handle)) {\n    OnStreamError(\n 0);\n    return;\n  }\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n       foreign_memory_handle, shared_memory->requested_size(),\n true);\n   mojo::ScopedHandle socket_handle =\n       mojo::WrapPlatformFile(foreign_socket->Release());\n \n  DCHECK(buffer_handle.is_valid());\n  DCHECK(socket_handle.is_valid());\n\n  base::ResetAndReturn(&stream_created_callback_)\n      .Run(std::move(buffer_handle), std::move(socket_handle), initially_muted);\n}\n", "target": 1, "flaw_line_index": "21"}
{"idx": 186650, "func": "bool IsSensitiveURL(const GURL& url,\n                    bool is_request_from_browser_or_webui_renderer) {\n  bool sensitive_chrome_url = false;\n  const char kGoogleCom[] = \"google.com\";\n  const char kClient[] = \"clients\";\n  url::Origin origin = url::Origin::Create(url);\n  if (origin.DomainIs(kGoogleCom)) {\n    base::StringPiece host = url.host_piece();\n    while (host.ends_with(\".\"))\n      host.remove_suffix(1u);\n    if (is_request_from_browser_or_webui_renderer) {\n      base::StringPiece::size_type pos = host.rfind(kClient);\n      if (pos != base::StringPiece::npos) {\n        bool match = true;\n        if (pos > 0 && host[pos - 1] != '.') {\n          match = false;\n        } else {\n          for (base::StringPiece::const_iterator\n                   i = host.begin() + pos + strlen(kClient),\n                   end = host.end() - (strlen(kGoogleCom) + 1);\n               i != end; ++i) {\n            if (!isdigit(*i)) {\n              match = false;\n              break;\n            }\n          }\n        }\n        sensitive_chrome_url = sensitive_chrome_url || match;\n      }\n    }\n\n    sensitive_chrome_url = sensitive_chrome_url ||\n                           (url.DomainIs(\"chrome.google.com\") &&\n                             base::StartsWith(url.path_piece(), \"/webstore\",\n                                              base::CompareCase::SENSITIVE));\n   }\n   return sensitive_chrome_url || extension_urls::IsWebstoreUpdateUrl(url) ||\n          extension_urls::IsBlacklistUpdateUrl(url) ||\n          extension_urls::IsSafeBrowsingUrl(origin, url.path_piece());\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186353, "func": " void SaveCardBubbleControllerImpl::ShowBubbleForLocalSave(\n     const CreditCard& card,\n     const base::Closure& save_card_callback) {\n   is_uploading_ = false;\n   is_reshow_ = false;\n   should_cvc_be_requested_ = false;\n  legal_message_lines_.clear();\n\n  AutofillMetrics::LogSaveCardPromptMetric(\n      AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,\n      is_reshow_,\n      pref_service_->GetInteger(\n          prefs::kAutofillAcceptSaveCreditCardPromptState));\n\n  card_ = card;\n  save_card_callback_ = save_card_callback;\n  ShowBubble();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7710, "func": "static int coroutine_fn stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                                       const struct stat *stbuf,\n                                       V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7446, "func": "ZEND_API int zend_ts_hash_del_key_or_index(TsHashTable *ht, char *arKey, uint nKeyLength, ulong h, int flag)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_del_key_or_index(TS_HASH(ht), arKey, nKeyLength, h, flag);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7796, "func": "static int h2c_handle_goaway(struct h2c *h2c)\n{\n\tint error;\n\tint last;\n\n\tif (h2c->dsi != 0) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->dfl < 8) {\n\t\terror = H2_ERR_FRAME_SIZE_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->dbuf->i < h2c->dfl)\n\t\treturn 0;\n\n\tlast = h2_get_n32(h2c->dbuf, 0);\n\th2c->errcode = h2_get_n32(h2c->dbuf, 4);\n\th2_wake_some_streams(h2c, last, CS_FL_ERROR);\n\tif (h2c->last_sid < 0)\n\t\th2c->last_sid = last;\n\treturn 1;\n\n conn_err:\n\th2c_error(h2c, error);\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8188, "func": "static void coroutine_fn v9fs_open(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int32_t mode;\n    V9fsQID qid;\n    int iounit = 0;\n    ssize_t err = 0;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    if (s->proto_version == V9FS_PROTO_2000L) {\n        err = pdu_unmarshal(pdu, offset, \"dd\", &fid, &mode);\n    } else {\n        uint8_t modebyte;\n        err = pdu_unmarshal(pdu, offset, \"db\", &fid, &modebyte);\n        mode = modebyte;\n    }\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_open(pdu->tag, pdu->id, fid, mode);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    if (S_ISDIR(stbuf.st_mode)) {\n        err = v9fs_co_opendir(pdu, fidp);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_DIR;\n        err = pdu_marshal(pdu, offset, \"Qd\", &qid, 0);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    } else {\n        if (s->proto_version == V9FS_PROTO_2000L) {\n            flags = get_dotl_openflags(s, mode);\n        } else {\n            flags = omode_to_uflags(mode);\n        }\n        if (is_ro_export(&s->ctx)) {\n            if (mode & O_WRONLY || mode & O_RDWR ||\n                mode & O_APPEND || mode & O_TRUNC) {\n                err = -EROFS;\n                goto out;\n            }\n        }\n        err = v9fs_co_open(pdu, fidp, flags);\n        if (err < 0) {\n            goto out;\n        }\n        fidp->fid_type = P9_FID_FILE;\n        fidp->open_flags = flags;\n        if (flags & O_EXCL) {\n            fidp->flags |= FID_NON_RECLAIMABLE;\n        }\n        iounit = get_iounit(pdu, &fidp->path);\n        err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    }\n    trace_v9fs_open_return(pdu->tag, pdu->id,\n                           qid.type, qid.version, qid.path, iounit);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186893, "func": " void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n         bool success, uint64_t dump_guid,\n         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, {},\n                           true \n, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7908, "func": "static void cexp(JF, js_Ast *exp)\n{\n\tint then, end;\n\tint n;\n\n\tswitch (exp->type) {\n\tcase EXP_STRING: emitstring(J, F, OP_STRING, exp->string); break;\n\tcase EXP_NUMBER: emitnumber(J, F, exp->number); break;\n\tcase EXP_UNDEF: emit(J, F, OP_UNDEF); break;\n\tcase EXP_NULL: emit(J, F, OP_NULL); break;\n\tcase EXP_TRUE: emit(J, F, OP_TRUE); break;\n\tcase EXP_FALSE: emit(J, F, OP_FALSE); break;\n\tcase EXP_THIS: emit(J, F, OP_THIS); break;\n\n\tcase EXP_REGEXP:\n\t\temit(J, F, OP_NEWREGEXP);\n\t\temitraw(J, F, addstring(J, F, exp->string));\n\t\temitraw(J, F, exp->number);\n\t\tbreak;\n\n\tcase EXP_OBJECT:\n\t\temit(J, F, OP_NEWOBJECT);\n\t\tcobject(J, F, exp->a);\n\t\tbreak;\n\n\tcase EXP_ARRAY:\n\t\temit(J, F, OP_NEWARRAY);\n\t\tcarray(J, F, exp->a);\n\t\tbreak;\n\n\tcase EXP_FUN:\n\t\temitfunction(J, F, newfun(J, exp->a, exp->b, exp->c, 0));\n\t\tbreak;\n\n\tcase EXP_IDENTIFIER:\n\t\temitlocal(J, F, OP_GETLOCAL, OP_GETVAR, exp);\n\t\tbreak;\n\n\tcase EXP_INDEX:\n\t\tcexp(J, F, exp->a);\n\t\tcexp(J, F, exp->b);\n\t\temit(J, F, OP_GETPROP);\n\t\tbreak;\n\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, exp->a);\n\t\temitstring(J, F, OP_GETPROP_S, exp->b->string);\n\t\tbreak;\n\n\tcase EXP_CALL:\n\t\tccall(J, F, exp->a, exp->b);\n\t\tbreak;\n\n\tcase EXP_NEW:\n\t\tcexp(J, F, exp->a);\n\t\tn = cargs(J, F, exp->b);\n\t\temit(J, F, OP_NEW);\n\t\temitraw(J, F, n);\n\t\tbreak;\n\n\tcase EXP_DELETE:\n\t\tcdelete(J, F, exp->a);\n\t\tbreak;\n\n\tcase EXP_PREINC:\n\t\tcassignop1(J, F, exp->a);\n\t\temit(J, F, OP_INC);\n\t\tcassignop2(J, F, exp->a, 0);\n\t\tbreak;\n\n\tcase EXP_PREDEC:\n\t\tcassignop1(J, F, exp->a);\n\t\temit(J, F, OP_DEC);\n\t\tcassignop2(J, F, exp->a, 0);\n\t\tbreak;\n\n\tcase EXP_POSTINC:\n\t\tcassignop1(J, F, exp->a);\n\t\temit(J, F, OP_POSTINC);\n\t\tcassignop2(J, F, exp->a, 1);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\n\tcase EXP_POSTDEC:\n\t\tcassignop1(J, F, exp->a);\n\t\temit(J, F, OP_POSTDEC);\n\t\tcassignop2(J, F, exp->a, 1);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\n\tcase EXP_VOID:\n\t\tcexp(J, F, exp->a);\n\t\temit(J, F, OP_POP);\n\t\temit(J, F, OP_UNDEF);\n\t\tbreak;\n\n\tcase EXP_TYPEOF: ctypeof(J, F, exp->a); break;\n\tcase EXP_POS: cunary(J, F, exp, OP_POS); break;\n\tcase EXP_NEG: cunary(J, F, exp, OP_NEG); break;\n\tcase EXP_BITNOT: cunary(J, F, exp, OP_BITNOT); break;\n\tcase EXP_LOGNOT: cunary(J, F, exp, OP_LOGNOT); break;\n\n\tcase EXP_BITOR: cbinary(J, F, exp, OP_BITOR); break;\n\tcase EXP_BITXOR: cbinary(J, F, exp, OP_BITXOR); break;\n\tcase EXP_BITAND: cbinary(J, F, exp, OP_BITAND); break;\n\tcase EXP_EQ: cbinary(J, F, exp, OP_EQ); break;\n\tcase EXP_NE: cbinary(J, F, exp, OP_NE); break;\n\tcase EXP_STRICTEQ: cbinary(J, F, exp, OP_STRICTEQ); break;\n\tcase EXP_STRICTNE: cbinary(J, F, exp, OP_STRICTNE); break;\n\tcase EXP_LT: cbinary(J, F, exp, OP_LT); break;\n\tcase EXP_GT: cbinary(J, F, exp, OP_GT); break;\n\tcase EXP_LE: cbinary(J, F, exp, OP_LE); break;\n\tcase EXP_GE: cbinary(J, F, exp, OP_GE); break;\n\tcase EXP_INSTANCEOF: cbinary(J, F, exp, OP_INSTANCEOF); break;\n\tcase EXP_IN: cbinary(J, F, exp, OP_IN); break;\n\tcase EXP_SHL: cbinary(J, F, exp, OP_SHL); break;\n\tcase EXP_SHR: cbinary(J, F, exp, OP_SHR); break;\n\tcase EXP_USHR: cbinary(J, F, exp, OP_USHR); break;\n\tcase EXP_ADD: cbinary(J, F, exp, OP_ADD); break;\n\tcase EXP_SUB: cbinary(J, F, exp, OP_SUB); break;\n\tcase EXP_MUL: cbinary(J, F, exp, OP_MUL); break;\n\tcase EXP_DIV: cbinary(J, F, exp, OP_DIV); break;\n\tcase EXP_MOD: cbinary(J, F, exp, OP_MOD); break;\n\n\tcase EXP_ASS: cassign(J, F, exp); break;\n\tcase EXP_ASS_MUL: cassignop(J, F, exp, OP_MUL); break;\n\tcase EXP_ASS_DIV: cassignop(J, F, exp, OP_DIV); break;\n\tcase EXP_ASS_MOD: cassignop(J, F, exp, OP_MOD); break;\n\tcase EXP_ASS_ADD: cassignop(J, F, exp, OP_ADD); break;\n\tcase EXP_ASS_SUB: cassignop(J, F, exp, OP_SUB); break;\n\tcase EXP_ASS_SHL: cassignop(J, F, exp, OP_SHL); break;\n\tcase EXP_ASS_SHR: cassignop(J, F, exp, OP_SHR); break;\n\tcase EXP_ASS_USHR: cassignop(J, F, exp, OP_USHR); break;\n\tcase EXP_ASS_BITAND: cassignop(J, F, exp, OP_BITAND); break;\n\tcase EXP_ASS_BITXOR: cassignop(J, F, exp, OP_BITXOR); break;\n\tcase EXP_ASS_BITOR: cassignop(J, F, exp, OP_BITOR); break;\n\n\tcase EXP_COMMA:\n\t\tcexp(J, F, exp->a);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tbreak;\n\n\tcase EXP_LOGOR:\n\t\tcexp(J, F, exp->a);\n\t\temit(J, F, OP_DUP);\n\t\tend = emitjump(J, F, OP_JTRUE);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tcase EXP_LOGAND:\n\t\tcexp(J, F, exp->a);\n\t\temit(J, F, OP_DUP);\n\t\tend = emitjump(J, F, OP_JFALSE);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tcase EXP_COND:\n\t\tcexp(J, F, exp->a);\n\t\tthen = emitjump(J, F, OP_JTRUE);\n\t\tcexp(J, F, exp->c);\n\t\tend = emitjump(J, F, OP_JUMP);\n\t\tlabel(J, F, then);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tdefault:\n\t\tjsC_error(J, exp, \"unknown expression: (%s)\", jsP_aststring(exp->type));\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7427, "func": "ZEND_API void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge_ex(TS_HASH(target), TS_HASH(source), pCopyConstructor, pMergeSource, pParam);\n\tend_write(target);\n\tend_read(source);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187006, "func": "ResourceRequestInfoImpl* ResourceDispatcherHostImpl::CreateRequestInfo(\n     int child_id,\n     int render_view_route_id,\n     int render_frame_route_id,\n     PreviewsState previews_state,\n     bool download,\n     ResourceContext* context) {\n   return new ResourceRequestInfoImpl(\n       ResourceRequesterInfo::CreateForDownloadOrPageSave(child_id),\n      render_view_route_id,\n      -1,                                  \n       ChildProcessHost::kInvalidUniqueID,  \n       MakeRequestID(), render_frame_route_id,\n       false,  \n      {},     \n      RESOURCE_TYPE_SUB_RESOURCE, ui::PAGE_TRANSITION_LINK,\n      download,  \n      false,     \n      download,  \n      false,     \n      false,     \n      false,     \n      false,     \n      false,     \n      network::mojom::ReferrerPolicy::kDefault,\n      false,  \n      context,\n      false,           \n      false,           \n      true,            \n      previews_state,  \n      nullptr,         \n      false);          \n}\n", "target": 1, "flaw_line_index": "10,11"}
{"idx": 186813, "func": " void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n          static_cast<jint>(\n              mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION)))) {\n    auto sensor_fusion_algorithm =\n        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(\n            false \n);\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);\n  }\n}\n", "target": 1, "flaw_line_index": "3,16"}
{"idx": 186622, "func": "extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  if (size > 512)\n    return 0;\n \n   net::ProxyBypassRules rules;\n   std::string input(data, data + size);\n  rules.ParseFromString(input);\n  rules.ParseFromStringUsingSuffixMatching(input);\n   return 0;\n }\n", "target": 1, "flaw_line_index": "11"}
{"idx": 186526, "func": "void DataReductionProxySettings::MaybeActivateDataReductionProxy(\n    bool at_startup) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  PrefService* prefs = GetOriginalProfilePrefs();\n   if (!prefs)\n     return;\n \n  if (spdy_proxy_auth_enabled_.GetValue() && at_startup) {\n     int64_t last_enabled_time =\n         prefs->GetInt64(prefs::kDataReductionProxyLastEnabledTime);\n    if (last_enabled_time != 0) {\n      RecordDaysSinceEnabledMetric(\n          (clock_->Now() - base::Time::FromInternalValue(last_enabled_time))\n              .InDays());\n    }\n\n    int64_t last_savings_cleared_time = prefs->GetInt64(\n        prefs::kDataReductionProxySavingsClearedNegativeSystemClock);\n    if (last_savings_cleared_time != 0) {\n      int32_t days_since_savings_cleared =\n          (clock_->Now() -\n           base::Time::FromInternalValue(last_savings_cleared_time))\n              .InDays();\n\n      if (days_since_savings_cleared == 0)\n        days_since_savings_cleared = 1;\n      UMA_HISTOGRAM_CUSTOM_COUNTS(\n          \"DataReductionProxy.DaysSinceSavingsCleared.NegativeSystemClock\",\n          days_since_savings_cleared, 1, 365, 50);\n     }\n   }\n \n  if (spdy_proxy_auth_enabled_.GetValue() &&\n       !prefs->GetBoolean(prefs::kDataReductionProxyWasEnabledBefore)) {\n     prefs->SetBoolean(prefs::kDataReductionProxyWasEnabledBefore, true);\n     ResetDataReductionStatistics();\n  }\n  if (!at_startup) {\n    if (IsDataReductionProxyEnabled()) {\n      RecordSettingsEnabledState(DATA_REDUCTION_SETTINGS_ACTION_OFF_TO_ON);\n\n      prefs->SetInt64(prefs::kDataReductionProxyLastEnabledTime,\n                      clock_->Now().ToInternalValue());\n      RecordDaysSinceEnabledMetric(0);\n    } else {\n      RecordSettingsEnabledState(DATA_REDUCTION_SETTINGS_ACTION_ON_TO_OFF);\n    }\n  }\n  if (at_startup && !data_reduction_proxy_service_->Initialized())\n    deferred_initialization_ = true;\n  else\n    UpdateIOData(at_startup);\n}\n", "target": 1, "flaw_line_index": "11,40"}
{"idx": 8146, "func": "void Gfx::opSetFillGray(Object args[], int numArgs) {\n  GfxColor color;\n\n  if (textHaveCSPattern && drawText) {\n    GBool needFill = out->deviceHasTextClip(state);\n    out->endTextObject(state);\n    if (needFill) {\n      doPatternFill(gTrue);\n    }\n    out->restoreState(state);\n  }\n  state->setFillPattern(NULL);\n  state->setFillColorSpace(new GfxDeviceGrayColorSpace());\n  out->updateFillColorSpace(state);\n  color.c[0] = dblToCol(args[0].getNum());\n  state->setFillColor(&color);\n  out->updateFillColor(state);\n  if (textHaveCSPattern) {\n    out->beginTextObject(state);\n    out->updateRender(state);\n    out->updateTextMat(state);\n    out->updateTextPos(state);\n    textHaveCSPattern = gFalse;\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186726, "func": " IOHandler::IOHandler(DevToolsIOContext* io_context)\n     : DevToolsDomainHandler(IO::Metainfo::domainName),\n       io_context_(io_context),\n      process_host_(nullptr),\n       weak_factory_(this) {}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 7901, "func": "static void cassignop1(JF, js_Ast *lhs)\n{\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitlocal(J, F, OP_GETLOCAL, OP_GETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\temit(J, F, OP_DUP2);\n\t\temit(J, F, OP_GETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\temit(J, F, OP_DUP);\n\t\temitstring(J, F, OP_GETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7619, "func": "static void map_linear_vram_bank(CirrusVGAState *s, unsigned bank)\n{\n    MemoryRegion *mr = &s->cirrus_bank[bank];\n    bool enabled = !(s->cirrus_srcptr != s->cirrus_srcptr_end)\n        && !((s->vga.sr[0x07] & 0x01) == 0)\n        && !((s->vga.gr[0x0B] & 0x14) == 0x14)\n        && !(s->vga.gr[0x0B] & 0x02);\n\n    memory_region_set_enabled(mr, enabled);\n    memory_region_set_alias_offset(mr, s->cirrus_bank_base[bank]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7649, "func": "static int proxy_renameat(FsContext *ctx, V9fsPath *olddir,\n                          const char *old_name, V9fsPath *newdir,\n                          const char *new_name)\n{\n    int ret;\n    V9fsString old_full_name, new_full_name;\n\n    v9fs_string_init(&old_full_name);\n    v9fs_string_init(&new_full_name);\n\n    v9fs_string_sprintf(&old_full_name, \"%s/%s\", olddir->data, old_name);\n    v9fs_string_sprintf(&new_full_name, \"%s/%s\", newdir->data, new_name);\n\n    ret = proxy_rename(ctx, old_full_name.data, new_full_name.data);\n    v9fs_string_free(&old_full_name);\n    v9fs_string_free(&new_full_name);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186519, "func": " DataReductionProxySettings::DataReductionProxySettings()\n     : unreachable_(false),\n       deferred_initialization_(false),\n       prefs_(nullptr),\n       config_(nullptr),\n       clock_(base::DefaultClock::GetInstance()) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187249, "func": " scoped_refptr<Image> CSSPaintValue::GetImage(\n     const ImageResourceObserver& client,\n     const Document& document,\n    const ComputedStyle&,\n     const FloatSize& target_size) {\n   if (!generator_) {\n     generator_ = CSSPaintImageGenerator::Create(\n         GetName(), document, paint_image_generator_observer_);\n  }\n\n  if (!ParseInputArguments(document))\n    return nullptr;\n\n  return generator_->Paint(client, RoundedIntSize(target_size),\n                           parsed_input_arguments_);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187308, "func": " exsltCryptoPopString (xmlXPathParserContextPtr ctxt, int nargs,\n\t\t      xmlChar ** str) {\n\n    int str_len = 0;\n\n    if ((nargs < 1) || (nargs > 2)) {\n\txmlXPathSetArityError (ctxt);\n\treturn 0;\n     }\n \n     *str = xmlXPathPopString (ctxt);\n    str_len = xmlUTF8Strlen (*str);\n \n     if (str_len == 0) {\n \txmlXPathReturnEmptyString (ctxt);\n\txmlFree (*str);\n\treturn 0;\n    }\n\n    return str_len;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 187178, "func": "void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {\n  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8199, "func": "static void serial_update_irq(SerialState *s)\n{\n    uint8_t tmp_iir = UART_IIR_NO_INT;\n\n    if ((s->ier & UART_IER_RLSI) && (s->lsr & UART_LSR_INT_ANY)) {\n        tmp_iir = UART_IIR_RLSI;\n    } else if ((s->ier & UART_IER_RDI) && s->timeout_ipending) {\n        tmp_iir = UART_IIR_CTI;\n    } else if ((s->ier & UART_IER_RDI) && (s->lsr & UART_LSR_DR) &&\n               (!(s->fcr & UART_FCR_FE) ||\n                s->recv_fifo.num >= s->recv_fifo_itl)) {\n        tmp_iir = UART_IIR_RDI;\n    } else if ((s->ier & UART_IER_THRI) && s->thr_ipending) {\n        tmp_iir = UART_IIR_THRI;\n    } else if ((s->ier & UART_IER_MSI) && (s->msr & UART_MSR_ANY_DELTA)) {\n        tmp_iir = UART_IIR_MSI;\n    }\n\n    s->iir = tmp_iir | (s->iir & 0xF0);\n\n    if (tmp_iir != UART_IIR_NO_INT) {\n        qemu_irq_raise(s->irq);\n    } else {\n        qemu_irq_lower(s->irq);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7952, "func": "void buffer_append(Buffer *buffer, const void *data, size_t len)\n{\n    memcpy(buffer->buffer + buffer->offset, data, len);\n    buffer->offset += len;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187230, "func": "static int hid_init(int sub_api, struct libusb_context *ctx)\n{\n\tDLL_LOAD(hid.dll, HidD_GetAttributes, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetHidGuid, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetPreparsedData, TRUE);\n\tDLL_LOAD(hid.dll, HidD_FreePreparsedData, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetManufacturerString, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetProductString, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetSerialNumberString, TRUE);\n\tDLL_LOAD(hid.dll, HidP_GetCaps, TRUE);\n\tDLL_LOAD(hid.dll, HidD_SetNumInputBuffers, TRUE);\n\tDLL_LOAD(hid.dll, HidD_SetFeature, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetFeature, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetPhysicalDescriptor, TRUE);\n\tDLL_LOAD(hid.dll, HidD_GetInputReport, FALSE);\n\tDLL_LOAD(hid.dll, HidD_SetOutputReport, FALSE);\n\tDLL_LOAD(hid.dll, HidD_FlushQueue, TRUE);\n\tDLL_LOAD(hid.dll, HidP_GetValueCaps, TRUE);\n\tapi_hid_available = true;\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21"}
{"idx": 186390, "func": " void SecureProxyChecker::CheckIfSecureProxyIsAllowed(\n     SecureProxyCheckerCallback fetcher_callback) {\n   net::NetworkTrafficAnnotationTag traffic_annotation =\n       net::DefineNetworkTrafficAnnotation(\n           \"data_reduction_proxy_secure_proxy_check\", R\"(\n            semantics {\n              sender: \"Data Reduction Proxy\"\n              description:\n                \"Sends a request to the Data Reduction Proxy server. Proceeds \"\n                \"with using a secure connection to the proxy only if the \"\n                \"response is not blocked or modified by an intermediary.\"\n              trigger:\n                \"A request can be sent whenever the browser is determining how \"\n                \"to configure its connection to the data reduction proxy. This \"\n                \"happens on startup and network changes.\"\n              data: \"A specific URL, not related to user data.\"\n              destination: GOOGLE_OWNED_SERVICE\n            }\n            policy {\n              cookies_allowed: NO\n              setting:\n                \"Users can control Data Saver on Android via the 'Data Saver' \"\n                \"setting. Data Saver is not available on iOS, and on desktop \"\n                \"it is enabled by installing the Data Saver extension.\"\n              policy_exception_justification: \"Not implemented.\"\n            })\");\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n  resource_request->url = params::GetSecureProxyCheckURL();\n  resource_request->load_flags =\n      net::LOAD_DISABLE_CACHE | net::LOAD_BYPASS_PROXY;\n  resource_request->allow_credentials = false;\n  url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),\n                                                 traffic_annotation);\n\n  static const int kMaxRetries = 5;\n  url_loader_->SetRetryOptions(\n      kMaxRetries, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE |\n                       network::SimpleURLLoader::RETRY_ON_5XX);\n  url_loader_->SetOnRedirectCallback(base::BindRepeating(\n      &SecureProxyChecker::OnURLLoaderRedirect, base::Unretained(this)));\n\n  fetcher_callback_ = fetcher_callback;\n  secure_proxy_check_start_time_ = base::Time::Now();\n\n  url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(\n      url_loader_factory_.get(),\n      base::BindOnce(&SecureProxyChecker::OnURLLoadComplete,\n                     base::Unretained(this)));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8265, "func": "XRecordIdBaseMask(Display *dpy)\n{\n    return 0x1fffffff & ~dpy->resource_mask;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187004, "func": "void NavigateOnUIThread(\n    const GURL& url,\n    const std::vector<GURL> url_chain,\n    const Referrer& referrer,\n    bool has_user_gesture,\n    const ResourceRequestInfo::WebContentsGetter& wc_getter) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n \n   WebContents* web_contents = wc_getter.Run();\n  if (web_contents) {\n    NavigationController::LoadURLParams params(url);\n     params.has_user_gesture = has_user_gesture;\n     params.referrer = referrer;\n     params.redirect_chain = url_chain;\n     web_contents->GetController().LoadURLWithParams(params);\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 7860, "func": "TargetInfo *qmp_query_target(Error **errp)\n{\n    TargetInfo *info = g_malloc0(sizeof(*info));\n\n    info->arch = g_strdup(TARGET_NAME);\n\n    return info;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187198, "func": "WindowOpenDisposition BrowserView::GetDispositionForPopupBounds(\n    const gfx::Rect& bounds) {\n  return WindowOpenDisposition::NEW_POPUP;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 187130, "func": "void MediaElementAudioSourceNode::OnCurrentSrcChanged(const KURL& current_src) {\n  GetMediaElementAudioSourceHandler().OnCurrentSrcChanged(current_src);\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 7513, "func": "  tt_face_init( FT_Stream      stream,\n                FT_Face        ttface,      \n                FT_Int         face_index,\n                FT_Int         num_params,\n                FT_Parameter*  params )\n  {\n    FT_Error      error;\n    FT_Library    library;\n    SFNT_Service  sfnt;\n    TT_Face       face = (TT_Face)ttface;\n\n\n    FT_TRACE2(( \"TTF driver\\n\" ));\n\n    library = ttface->driver->root.library;\n\n    sfnt = (SFNT_Service)FT_Get_Module_Interface( library, \"sfnt\" );\n    if ( !sfnt )\n    {\n      FT_ERROR(( \"tt_face_init: cannot access `sfnt' module\\n\" ));\n      error = FT_THROW( Missing_Module );\n      goto Exit;\n    }\n\n    if ( FT_STREAM_SEEK( 0 ) )\n      goto Exit;\n\n    FT_TRACE2(( \"  \" ));\n    error = sfnt->init_face( stream, face, face_index, num_params, params );\n\n    stream = face->root.stream;\n\n    if ( error )\n      goto Exit;\n\n    if ( face->format_tag != 0x00010000L &&    \n         face->format_tag != 0x00020000L &&    \n         face->format_tag != TTAG_true   )     \n    {\n      FT_TRACE2(( \"  not a TTF font\\n\" ));\n      goto Bad_Format;\n    }\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    ttface->face_flags |= FT_FACE_FLAG_HINTER;\n#endif\n\n    if ( face_index < 0 )\n      return FT_Err_Ok;\n\n    error = sfnt->load_face( stream, face, face_index, num_params, params );\n    if ( error )\n      goto Exit;\n\n    if ( tt_check_trickyness( ttface ) )\n      ttface->face_flags |= FT_FACE_FLAG_TRICKY;\n\n    error = tt_face_load_hdmx( face, stream );\n    if ( error )\n      goto Exit;\n\n    if ( FT_IS_SCALABLE( ttface ) )\n    {\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n      if ( !ttface->internal->incremental_interface )\n#endif\n      {\n        error = tt_face_load_loca( face, stream );\n\n        if ( face->glyf_len && FT_ERR_EQ( error, Table_Missing ) )\n          goto Exit;\n        if ( error )\n          goto Exit;\n      }\n\n      error = tt_face_load_cvt( face, stream );\n      if ( error && FT_ERR_NEQ( error, Table_Missing ) )\n        goto Exit;\n\n      error = tt_face_load_fpgm( face, stream );\n      if ( error && FT_ERR_NEQ( error, Table_Missing ) )\n        goto Exit;\n\n      error = tt_face_load_prep( face, stream );\n      if ( error && FT_ERR_NEQ( error, Table_Missing ) )\n        goto Exit;\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n      if ( !ttface->internal->incremental_interface )\n#endif\n      {\n        if ( ttface->num_fixed_sizes          &&\n             face->glyph_locations            &&\n             tt_check_single_notdef( ttface ) )\n        {\n          FT_TRACE5(( \"tt_face_init:\"\n                      \" Only the `.notdef' glyph has an outline.\\n\"\n                      \"             \"\n                      \" Resetting scalable flag to FALSE.\\n\" ));\n\n          ttface->face_flags &= ~FT_FACE_FLAG_SCALABLE;\n        }\n      }\n    }\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n\n    {\n      FT_Int  instance_index = face_index >> 16;\n\n\n      if ( FT_HAS_MULTIPLE_MASTERS( ttface ) &&\n           instance_index > 0                )\n      {\n        error = TT_Get_MM_Var( face, NULL );\n        if ( error )\n          goto Exit;\n\n        if ( face->blend->mmvar->namedstyle )\n        {\n          FT_Memory  memory = ttface->memory;\n\n          FT_Var_Named_Style*  named_style;\n          FT_String*           style_name;\n\n\n          named_style = face->blend->mmvar->namedstyle + instance_index - 1;\n          error = sfnt->get_name( face,\n                                  (FT_UShort)named_style->strid,\n                                  &style_name );\n          if ( error )\n            goto Exit;\n\n          if ( face->root.style_name )\n            FT_FREE( face->root.style_name );\n          face->root.style_name = style_name;\n\n          error = TT_Set_Var_Design( face,\n                                     face->blend->mmvar->num_axis,\n                                     named_style->coords );\n          if ( error )\n            goto Exit;\n\n          tt_apply_mvar( face );\n        }\n      }\n    }\n\n#endif \n\n    TT_Init_Glyph_Loading( face );\n\n  Exit:\n    return error;\n\n  Bad_Format:\n    error = FT_THROW( Unknown_File_Format );\n    goto Exit;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 7950, "func": "static void audio_capture_notify(void *opaque, audcnotification_e cmd)\n{\n    VncState *vs = opaque;\n\n    switch (cmd) {\n    case AUD_CNOTIFY_DISABLE:\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_END);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n\n    case AUD_CNOTIFY_ENABLE:\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_BEGIN);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186475, "func": " static void swizzleImageData(unsigned char* srcAddr,\n                             size_t height,\n                             size_t bytesPerRow,\n                              bool flipY) {\n   if (flipY) {\n    for (size_t i = 0; i < height / 2; i++) {\n      size_t topRowStartPosition = i * bytesPerRow;\n      size_t bottomRowStartPosition = (height - 1 - i) * bytesPerRow;\n       if (kN32_SkColorType == kBGRA_8888_SkColorType) {  \n        for (size_t j = 0; j < bytesPerRow; j += 4) {\n           std::swap(srcAddr[topRowStartPosition + j],\n                     srcAddr[bottomRowStartPosition + j + 2]);\n           std::swap(srcAddr[topRowStartPosition + j + 1],\n                    srcAddr[bottomRowStartPosition + j + 1]);\n          std::swap(srcAddr[topRowStartPosition + j + 2],\n                    srcAddr[bottomRowStartPosition + j]);\n          std::swap(srcAddr[topRowStartPosition + j + 3],\n                    srcAddr[bottomRowStartPosition + j + 3]);\n        }\n      } else {\n        std::swap_ranges(srcAddr + topRowStartPosition,\n                         srcAddr + topRowStartPosition + bytesPerRow,\n                         srcAddr + bottomRowStartPosition);\n      }\n     }\n   } else {\n     if (kN32_SkColorType == kBGRA_8888_SkColorType)  \n      for (size_t i = 0; i < height * bytesPerRow; i += 4)\n         std::swap(srcAddr[i], srcAddr[i + 2]);\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,6,7,8,10,28"}
{"idx": 187320, "func": "xsltParseStylesheetAttributeSet(xsltStylesheetPtr style, xmlNodePtr cur) {\n    const xmlChar *ncname;\n    const xmlChar *prefix;\n    xmlChar *value;\n    xmlNodePtr child;\n    xsltAttrElemPtr attrItems;\n\n    if ((cur == NULL) || (style == NULL) || (cur->type != XML_ELEMENT_NODE))\n \treturn;\n \n     value = xmlGetNsProp(cur, (const xmlChar *)\"name\", NULL);\n    if (value == NULL) {\n \txsltGenericError(xsltGenericErrorContext,\n \t     \"xsl:attribute-set : name is missing\\n\");\n \treturn;\n     }\n \n    ncname = xsltSplitQName(style->dict, value, &prefix);\n    xmlFree(value);\n    value = NULL;\n\n    if (style->attributeSets == NULL) {\n#ifdef WITH_XSLT_DEBUG_ATTRIBUTES\n\txsltGenericDebug(xsltGenericDebugContext,\n\t    \"creating attribute set table\\n\");\n#endif\n\tstyle->attributeSets = xmlHashCreate(10);\n    }\n    if (style->attributeSets == NULL)\n\treturn;\n\n    attrItems = xmlHashLookup2(style->attributeSets, ncname, prefix);\n\n    child = cur->children;\n    while (child != NULL) {\n\tif ((child->type != XML_ELEMENT_NODE) ||\n\t    (child->ns == NULL) ||\n\t    (! IS_XSLT_ELEM(child)))\n\t{\n\t    if (child->type == XML_ELEMENT_NODE)\n\t\txsltTransformError(NULL, style, child,\n\t\t\t\"xsl:attribute-set : unexpected child %s\\n\",\n\t\t                 child->name);\n\t    else\n\t\txsltTransformError(NULL, style, child,\n\t\t\t\"xsl:attribute-set : child of unexpected type\\n\");\n\t} else if (!IS_XSLT_NAME(child, \"attribute\")) {\n\t    xsltTransformError(NULL, style, child,\n\t\t\"xsl:attribute-set : unexpected child xsl:%s\\n\",\n\t\tchild->name);\n\t} else {\n#ifdef XSLT_REFACTORED\n\t    xsltAttrElemPtr nextAttr, curAttr;\n\n\n#ifdef WITH_XSLT_DEBUG_ATTRIBUTES\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"add attribute to list %s\\n\", ncname);\n#endif\n\t    if (attrItems == NULL) {\n\t\tattrItems = xsltNewAttrElem(child);\n\t    } else {\n\t\tcurAttr = attrItems;\n\t\twhile (curAttr != NULL) {\n\t\t    nextAttr = curAttr->next;\n\t\t    if (curAttr->attr == child) {\n\t\t\tattrItems = curAttr;\n\t\t\tgoto next_child;\n\t\t    }\n\t\t    if (curAttr->next == NULL)\n\t\t\tcurAttr->next = xsltNewAttrElem(child);\n\t\t    curAttr = nextAttr;\n\t\t}\n\t    }\n\t    xsltParseAnyXSLTElem(XSLT_CCTXT(style), child);\n#else\n#ifdef WITH_XSLT_DEBUG_ATTRIBUTES\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"add attribute to list %s\\n\", ncname);\n#endif\n\t    attrItems = xsltAddAttrElemList(attrItems, child);\n#endif\n\t}\n\n#ifdef XSLT_REFACTORED\nnext_child:\n#endif\n\tchild = child->next;\n    }\n\n    value = xmlGetNsProp(cur, (const xmlChar *)\"use-attribute-sets\",\n\tNULL);\n    if (value != NULL) {\n\tconst xmlChar *curval, *endval;\n\tcurval = value;\n\twhile (*curval != 0) {\n\t    while (IS_BLANK(*curval)) curval++;\n\t    if (*curval == 0)\n\t\tbreak;\n\t    endval = curval;\n\t    while ((*endval != 0) && (!IS_BLANK(*endval))) endval++;\n\t    curval = xmlDictLookup(style->dict, curval, endval - curval);\n\t    if (curval) {\n\t\tconst xmlChar *ncname2 = NULL;\n\t\tconst xmlChar *prefix2 = NULL;\n\t\txsltAttrElemPtr refAttrItems;\n\n#ifdef WITH_XSLT_DEBUG_ATTRIBUTES\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t    \"xsl:attribute-set : %s adds use %s\\n\", ncname, curval);\n#endif\n\t\tncname2 = xsltSplitQName(style->dict, curval, &prefix2);\n\t\trefAttrItems = xsltNewAttrElem(NULL);\n\t\tif (refAttrItems != NULL) {\n\t\t    refAttrItems->set = ncname2;\n\t\t    refAttrItems->ns = prefix2;\n\t\t    attrItems = xsltMergeAttrElemList(style,\n\t\t\tattrItems, refAttrItems);\n\t\t    xsltFreeAttrElem(refAttrItems);\n\t\t}\n\t    }\n\t    curval = endval;\n\t}\n\txmlFree(value);\n\tvalue = NULL;\n    }\n\n    if (attrItems == NULL)\n\tattrItems = xsltNewAttrElem(NULL);\n    xmlHashUpdateEntry2(style->attributeSets, ncname, prefix, attrItems, NULL);\n#ifdef WITH_XSLT_DEBUG_ATTRIBUTES\n    xsltGenericDebug(xsltGenericDebugContext,\n\t\"updated attribute list %s\\n\", ncname);\n#endif\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 7682, "func": "static int handle_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n                        int flags, FsCred *credp, V9fsFidOpenState *fs)\n{\n    int ret;\n    int dirfd, fd;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    fd = openat(dirfd, name, flags | O_NOFOLLOW, credp->fc_mode);\n    if (fd >= 0) {\n        ret = handle_update_file_cred(dirfd, name, credp);\n        if (ret < 0) {\n            close(fd);\n            fd = ret;\n        } else {\n            fs->fd = fd;\n        }\n    }\n    close(dirfd);\n    return fd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8175, "func": "void Gfx::popMarkedContent() {\n  MarkedContentStack *mc = mcStack;\n  mcStack = mc->next;\n  delete mc;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186861, "func": "MojoResult UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,\n                                    base::SharedMemoryHandle* memory_handle,\n                                    size_t* size,\n                                    bool* read_only) {\n   if (!handle.is_valid())\n     return MOJO_RESULT_INVALID_ARGUMENT;\n   MojoPlatformHandle platform_handle;\n  platform_handle.struct_size = sizeof(MojoPlatformHandle);\n\n  MojoPlatformSharedBufferHandleFlags flags;\n  size_t num_bytes;\n  MojoSharedBufferGuid mojo_guid;\n  MojoResult result = MojoUnwrapPlatformSharedBufferHandle(\n      handle.release().value(), &platform_handle, &num_bytes, &mojo_guid,\n      &flags);\n  if (result != MOJO_RESULT_OK)\n    return result;\n\n   if (size)\n     *size = num_bytes;\n \n  if (read_only)\n    *read_only = flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n \n   base::UnguessableToken guid =\n       base::UnguessableToken::Deserialize(mojo_guid.high, mojo_guid.low);\n#if defined(OS_MACOSX) && !defined(OS_IOS)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_MACH_PORT);\n  *memory_handle = base::SharedMemoryHandle(\n      static_cast<mach_port_t>(platform_handle.value), num_bytes, guid);\n#elif defined(OS_FUCHSIA)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_FUCHSIA_HANDLE);\n  *memory_handle = base::SharedMemoryHandle(\n      static_cast<zx_handle_t>(platform_handle.value), num_bytes, guid);\n#elif defined(OS_POSIX)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR);\n  *memory_handle = base::SharedMemoryHandle(\n      base::FileDescriptor(static_cast<int>(platform_handle.value), false),\n      num_bytes, guid);\n#elif defined(OS_WIN)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_WINDOWS_HANDLE);\n  *memory_handle = base::SharedMemoryHandle(\n      reinterpret_cast<HANDLE>(platform_handle.value), num_bytes, guid);\n#endif\n\n  return MOJO_RESULT_OK;\n}\n", "target": 1, "flaw_line_index": "2,3,4,22,23"}
{"idx": 7673, "func": "static int handle_link(FsContext *ctx, V9fsPath *oldpath,\n                       V9fsPath *dirpath, const char *name)\n{\n    int oldfd, newdirfd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    oldfd = open_by_handle(data->mountfd, oldpath->data, O_PATH);\n    if (oldfd < 0) {\n        return oldfd;\n    }\n    newdirfd = open_by_handle(data->mountfd, dirpath->data, O_PATH);\n    if (newdirfd < 0) {\n        close(oldfd);\n        return newdirfd;\n    }\n    ret = linkat(oldfd, \"\", newdirfd, name, AT_EMPTY_PATH);\n    close(newdirfd);\n    close(oldfd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186957, "func": "bool AppCacheDatabase::InsertCache(const CacheRecord* record) {\n  if (!LazyOpen(kCreateIfNeeded))\n    return false;\n \n   static const char kSql[] =\n       \"INSERT INTO Caches (cache_id, group_id, online_wildcard,\"\n      \"                    update_time, cache_size)\"\n      \"  VALUES(?, ?, ?, ?, ?)\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n   statement.BindInt64(0, record->cache_id);\n   statement.BindInt64(1, record->group_id);\n   statement.BindBool(2, record->online_wildcard);\n   statement.BindInt64(3, record->update_time.ToInternalValue());\n   statement.BindInt64(4, record->cache_size);\n \n   return statement.Run();\n }\n", "target": 1, "flaw_line_index": "7,8"}
{"idx": 186721, "func": "void DevToolsDomainHandler::SetRenderer(RenderProcessHost* process_host,\n                                         RenderFrameHostImpl* frame_host) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7505, "func": "simple_method_return (void)\n{\n  DBusMessage *message;\n  message =  dbus_message_new (DBUS_MESSAGE_TYPE_METHOD_RETURN);\n  if (message == NULL)\n    _dbus_assert_not_reached (\"oom\");\n\n  set_reply_serial (message);\n  \n  return message;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7910, "func": "static void cfundecs(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *stm = list->a;\n\t\tif (stm->type == AST_FUNDEC) {\n\t\t\temitfunction(J, F, newfun(J, stm->a, stm->b, stm->c, 0));\n\t\t\temitstring(J, F, OP_INITVAR, stm->a->string);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186699, "func": "void DOMWindow::focus(LocalDOMWindow* incumbent_window) {\n  if (!GetFrame())\n    return;\n\n  Page* page = GetFrame()->GetPage();\n  if (!page)\n    return;\n\n  DCHECK(incumbent_window);\n  ExecutionContext* incumbent_execution_context =\n      incumbent_window->GetExecutionContext();\n\n  bool allow_focus = incumbent_execution_context->IsWindowInteractionAllowed();\n  if (allow_focus) {\n    incumbent_execution_context->ConsumeWindowInteraction();\n  } else {\n    DCHECK(IsMainThread());\n    allow_focus =\n        opener() && (opener() != this) &&\n        (ToDocument(incumbent_execution_context)->domWindow() == opener());\n  }\n \n   if (GetFrame()->IsMainFrame() && allow_focus)\n    page->GetChromeClient().Focus();\n \n   page->GetFocusController().FocusDocumentView(GetFrame(),\n                                                true \n);\n}\n", "target": 1, "flaw_line_index": "25"}
{"idx": 186581, "func": "MediaRecorder::MediaRecorder(ExecutionContext* context,\n                             MediaStream* stream,\n                             const MediaRecorderOptions* options,\n                             ExceptionState& exception_state)\n    : PausableObject(context),\n      stream_(stream),\n      mime_type_(options->hasMimeType() ? options->mimeType()\n                                        : kDefaultMimeType),\n      stopped_(true),\n      audio_bits_per_second_(0),\n      video_bits_per_second_(0),\n      state_(State::kInactive),\n      dispatch_scheduled_event_runner_(AsyncMethodRunner<MediaRecorder>::Create(\n           this,\n           &MediaRecorder::DispatchScheduledEvent,\n           context->GetTaskRunner(TaskType::kDOMManipulation))) {\n  DCHECK(stream_->getTracks().size());\n \n   recorder_handler_ = Platform::Current()->CreateMediaRecorderHandler(\n       context->GetTaskRunner(TaskType::kInternalMediaRealTime));\n   DCHECK(recorder_handler_);\n\n  if (!recorder_handler_) {\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"No MediaRecorder handler can be created.\");\n    return;\n  }\n\n  AllocateVideoAndAudioBitrates(exception_state, context, options, stream,\n                                &audio_bits_per_second_,\n                                &video_bits_per_second_);\n\n  const ContentType content_type(mime_type_);\n  if (!recorder_handler_->Initialize(\n          this, stream->Descriptor(), content_type.GetType(),\n          content_type.Parameter(\"codecs\"), audio_bits_per_second_,\n          video_bits_per_second_)) {\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"Failed to initialize native MediaRecorder the type provided (\" +\n            mime_type_ + \") is not supported.\");\n    return;\n  }\n  if (options->mimeType().IsEmpty()) {\n    const String actual_mime_type = recorder_handler_->ActualMimeType();\n    if (!actual_mime_type.IsEmpty())\n      mime_type_ = actual_mime_type;\n  }\n  stopped_ = false;\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 186506, "func": "void WebGLRenderingContextBase::linkProgram(WebGLProgram* program) {\n  if (!ValidateWebGLProgramOrShader(\"linkProgram\", program))\n    return;\n\n  if (program->ActiveTransformFeedbackCount() > 0) {\n    SynthesizeGLError(\n        GL_INVALID_OPERATION, \"linkProgram\",\n        \"program being used by one or more active transform feedback objects\");\n     return;\n   }\n \n   ContextGL()->LinkProgram(ObjectOrZero(program));\n   program->IncreaseLinkCount();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186834, "func": "  base::SharedMemoryHandle CreateMSKPInSharedMemory() {\n    SkDynamicMemoryWStream stream;\n    sk_sp<SkDocument> doc = SkMakeMultiPictureDocument(&stream);\n    cc::SkiaPaintCanvas canvas(doc->beginPage(800, 600));\n    SkRect rect = SkRect::MakeXYWH(10, 10, 250, 250);\n    cc::PaintFlags flags;\n    flags.setAntiAlias(false);\n    flags.setColor(SK_ColorRED);\n    flags.setStyle(cc::PaintFlags::kFill_Style);\n    canvas.drawRect(rect, flags);\n    doc->endPage();\n    doc->close();\n\n    size_t len = stream.bytesWritten();\n    base::SharedMemoryCreateOptions options;\n    options.size = len;\n    options.share_read_only = true;\n\n     base::SharedMemory shared_memory;\n     if (shared_memory.Create(options) && shared_memory.Map(len)) {\n       stream.copyTo(shared_memory.memory());\n      return base::SharedMemory::DuplicateHandle(shared_memory.handle());\n     }\n     return base::SharedMemoryHandle();\n   }\n", "target": 1, "flaw_line_index": "22"}
{"idx": 187121, "func": "void ThreadHeap::TakeSnapshot(SnapshotType type) {\n  DCHECK(thread_state_->InAtomicMarkingPause());\n \n  ThreadState::GCSnapshotInfo info(GCInfoTable::GcInfoIndex() + 1);\n   String thread_dump_name =\n       String::Format(\"blink_gc/thread_%lu\",\n                      static_cast<unsigned long>(thread_state_->ThreadId()));\n  const String heaps_dump_name = thread_dump_name + \"/heaps\";\n  const String classes_dump_name = thread_dump_name + \"/classes\";\n\n  int number_of_heaps_reported = 0;\n#define SNAPSHOT_HEAP(ArenaType)                                          \\\n  {                                                                       \\\n    number_of_heaps_reported++;                                           \\\n    switch (type) {                                                       \\\n      case SnapshotType::kHeapSnapshot:                                   \\\n        arenas_[BlinkGC::k##ArenaType##ArenaIndex]->TakeSnapshot(         \\\n            heaps_dump_name + \"/\" #ArenaType, info);                      \\\n        break;                                                            \\\n      case SnapshotType::kFreelistSnapshot:                               \\\n        arenas_[BlinkGC::k##ArenaType##ArenaIndex]->TakeFreelistSnapshot( \\\n            heaps_dump_name + \"/\" #ArenaType);                            \\\n        break;                                                            \\\n      default:                                                            \\\n        NOTREACHED();                                                     \\\n    }                                                                     \\\n  }\n\n  SNAPSHOT_HEAP(NormalPage1);\n  SNAPSHOT_HEAP(NormalPage2);\n  SNAPSHOT_HEAP(NormalPage3);\n  SNAPSHOT_HEAP(NormalPage4);\n  SNAPSHOT_HEAP(EagerSweep);\n  SNAPSHOT_HEAP(Vector1);\n  SNAPSHOT_HEAP(Vector2);\n  SNAPSHOT_HEAP(Vector3);\n  SNAPSHOT_HEAP(Vector4);\n  SNAPSHOT_HEAP(InlineVector);\n  SNAPSHOT_HEAP(HashTable);\n  SNAPSHOT_HEAP(LargeObject);\n  FOR_EACH_TYPED_ARENA(SNAPSHOT_HEAP);\n\n  DCHECK_EQ(number_of_heaps_reported, BlinkGC::kNumberOfArenas);\n\n#undef SNAPSHOT_HEAP\n\n  if (type == SnapshotType::kFreelistSnapshot)\n    return;\n\n  size_t total_live_count = 0;\n   size_t total_dead_count = 0;\n   size_t total_live_size = 0;\n   size_t total_dead_size = 0;\n  for (size_t gc_info_index = 1; gc_info_index <= GCInfoTable::GcInfoIndex();\n       ++gc_info_index) {\n     total_live_count += info.live_count[gc_info_index];\n     total_dead_count += info.dead_count[gc_info_index];\n     total_live_size += info.live_size[gc_info_index];\n    total_dead_size += info.dead_size[gc_info_index];\n  }\n\n  base::trace_event::MemoryAllocatorDump* thread_dump =\n      BlinkGCMemoryDumpProvider::Instance()\n          ->CreateMemoryAllocatorDumpForCurrentGC(thread_dump_name);\n  thread_dump->AddScalar(\"live_count\", \"objects\", total_live_count);\n  thread_dump->AddScalar(\"dead_count\", \"objects\", total_dead_count);\n  thread_dump->AddScalar(\"live_size\", \"bytes\", total_live_size);\n  thread_dump->AddScalar(\"dead_size\", \"bytes\", total_dead_size);\n\n  base::trace_event::MemoryAllocatorDump* heaps_dump =\n      BlinkGCMemoryDumpProvider::Instance()\n          ->CreateMemoryAllocatorDumpForCurrentGC(heaps_dump_name);\n  base::trace_event::MemoryAllocatorDump* classes_dump =\n      BlinkGCMemoryDumpProvider::Instance()\n          ->CreateMemoryAllocatorDumpForCurrentGC(classes_dump_name);\n  BlinkGCMemoryDumpProvider::Instance()\n      ->CurrentProcessMemoryDump()\n      ->AddOwnershipEdge(classes_dump->guid(), heaps_dump->guid());\n}\n", "target": 1, "flaw_line_index": "6,56,57"}
{"idx": 186558, "func": "  static void Unregister(const GURL& url) {\n    EXPECT_TRUE(\n        content::BrowserThread::CurrentlyOn(content::BrowserThread::IO));\n    net::URLRequestFilter::GetInstance()->RemoveUrlHandler(url);\n   }\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 186573, "func": " void AcceleratedStaticBitmapImage::RetainOriginalSkImage() {\n   DCHECK(texture_holder_->IsSkiaTextureHolder());\n   original_skia_image_ = texture_holder_->GetSkImage();\n   original_skia_image_context_provider_wrapper_ = ContextProviderWrapper();\n   DCHECK(original_skia_image_);\n   Thread* thread = Platform::Current()->CurrentThread();\n  original_skia_image_thread_id_ = thread->ThreadId();\n   original_skia_image_task_runner_ = thread->GetTaskRunner();\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 186416, "func": "ScriptPromise Bluetooth::requestDevice(ScriptState* script_state,\n                                       const RequestDeviceOptions* options,\n                                       ExceptionState& exception_state) {\n  ExecutionContext* context = ExecutionContext::From(script_state);\n\n#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID) && !defined(OS_MACOSX) && \\\n    !defined(OS_WIN)\n  context->AddConsoleMessage(ConsoleMessage::Create(\n      mojom::ConsoleMessageSource::kJavaScript,\n      mojom::ConsoleMessageLevel::kInfo,\n      \"Web Bluetooth is experimental on this platform. See \"\n      \"https:\n      \"implementation-status.md\"));\n#endif\n\n  CHECK(context->IsSecureContext());\n\n  auto& doc = *To<Document>(context);\n  auto* frame = doc.GetFrame();\n  if (!frame) {\n    return ScriptPromise::Reject(\n        script_state, V8ThrowException::CreateTypeError(\n                          script_state->GetIsolate(), \"Document not active\"));\n  }\n\n  if (!LocalFrame::HasTransientUserActivation(frame)) {\n    return ScriptPromise::RejectWithDOMException(\n        script_state,\n        MakeGarbageCollected<DOMException>(\n            DOMExceptionCode::kSecurityError,\n             \"Must be handling a user gesture to show a permission request.\"));\n   }\n \n  if (!service_) {\n      frame->GetInterfaceProvider().GetInterface(mojo::MakeRequest(\n          &service_, context->GetTaskRunner(TaskType::kMiscPlatformAPI)));\n  }\n \n  auto device_options = mojom::blink::WebBluetoothRequestDeviceOptions::New();\n  ConvertRequestDeviceOptions(options, device_options, exception_state);\n\n  if (exception_state.HadException())\n    return ScriptPromise();\n\n  Platform::Current()->RecordRapporURL(\"Bluetooth.APIUsage.Origin\", doc.Url());\n\n  auto* resolver = MakeGarbageCollected<ScriptPromiseResolver>(script_state);\n  ScriptPromise promise = resolver->Promise();\n\n  service_->RequestDevice(\n      std::move(device_options),\n      WTF::Bind(&Bluetooth::RequestDeviceCallback, WrapPersistent(this),\n                WrapPersistent(resolver)));\n  return promise;\n}\n", "target": 1, "flaw_line_index": "37,38,39,40,41"}
{"idx": 186902, "func": "void SandboxIPCHandler::HandleLocaltime(\n     int fd,\n     base::PickleIterator iter,\n     const std::vector<base::ScopedFD>& fds) {\n \n   std::string time_string;\n   if (!iter.ReadString(&time_string) || time_string.size() != sizeof(time_t))\n     return;\n \n   time_t time;\n   memcpy(&time, time_string.data(), sizeof(time));\n   const struct tm* expanded_time = localtime(&time);\n \n  std::string result_string;\n  const char* time_zone_string = \"\";\n   if (expanded_time) {\n    result_string = std::string(reinterpret_cast<const char*>(expanded_time),\n                                sizeof(struct tm));\n    time_zone_string = expanded_time->tm_zone;\n   }\n  base::Pickle reply;\n  reply.WriteString(result_string);\n  reply.WriteString(time_zone_string);\n   SendRendererReply(fds, reply, -1);\n }\n", "target": 1, "flaw_line_index": "5,13,17,18,20,21,22,24,25,26"}
{"idx": 187322, "func": "xsltRegisterExtModuleElement(const xmlChar * name, const xmlChar * URI,\n                              xsltPreComputeFunction precomp,\n                              xsltTransformFunction transform)\n {\n    int ret;\n \n     xsltExtElementPtr ext;\n \n    if ((name == NULL) || (URI == NULL) || (transform == NULL))\n        return (-1);\n\n    if (xsltElementsHash == NULL)\n        xsltElementsHash = xmlHashCreate(10);\n    if (xsltElementsHash == NULL)\n        return (-1);\n\n    xmlMutexLock(xsltExtMutex);\n\n    ext = xsltNewExtElement(precomp, transform);\n    if (ext == NULL) {\n        ret = -1;\n        goto done;\n    }\n\n    xmlHashUpdateEntry2(xsltElementsHash, name, URI, (void *) ext,\n                        (xmlHashDeallocator) xsltFreeExtElement);\n\n done:\n     xmlMutexUnlock(xsltExtMutex);\n \n    return (0);\n }\n", "target": 1, "flaw_line_index": "5,31"}
{"idx": 186646, "func": "bool ExtensionApiTest::InitializeEmbeddedTestServer() {\n  if (!embedded_test_server()->InitializeAndListen())\n    return false;\n\n  test_config_->SetInteger(kEmbeddedTestServerPort,\n                           embedded_test_server()->port());\n \n   return true;\n }\n", "target": 1, "flaw_line_index": "8,9"}
{"idx": 8204, "func": "static void pdu_complete(V9fsPDU *pdu, ssize_t len)\n{\n    int8_t id = pdu->id + 1; \n    V9fsState *s = pdu->s;\n\n    if (len < 0) {\n        int err = -len;\n        len = 7;\n\n        if (s->proto_version != V9FS_PROTO_2000L) {\n            V9fsString str;\n\n            str.data = strerror(err);\n            str.size = strlen(str.data);\n\n            len += pdu_marshal(pdu, len, \"s\", &str);\n            id = P9_RERROR;\n        }\n\n        len += pdu_marshal(pdu, len, \"d\", err);\n\n        if (s->proto_version == V9FS_PROTO_2000L) {\n            id = P9_RLERROR;\n        }\n        trace_v9fs_rerror(pdu->tag, pdu->id, err); \n    }\n\n    pdu_marshal(pdu, 0, \"dbw\", (int32_t)len, id, pdu->tag);\n\n    pdu->size = len;\n    pdu->id = id;\n\n    pdu_push_and_notify(pdu);\n\n    qemu_co_queue_next(&pdu->complete);\n\n    pdu_free(pdu);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186940, "func": "void ImageCapture::SetMediaTrackConstraints(\n    ScriptPromiseResolver* resolver,\n    const HeapVector<MediaTrackConstraintSet>& constraints_vector) {\n  DCHECK_GT(constraints_vector.size(), 0u);\n  if (!service_) {\n    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));\n    return;\n  }\n  auto constraints = constraints_vector[0];\n\n  if ((constraints.hasWhiteBalanceMode() &&\n       !capabilities_.hasWhiteBalanceMode()) ||\n      (constraints.hasExposureMode() && !capabilities_.hasExposureMode()) ||\n      (constraints.hasFocusMode() && !capabilities_.hasFocusMode()) ||\n      (constraints.hasExposureCompensation() &&\n       !capabilities_.hasExposureCompensation()) ||\n      (constraints.hasColorTemperature() &&\n       !capabilities_.hasColorTemperature()) ||\n      (constraints.hasIso() && !capabilities_.hasIso()) ||\n      (constraints.hasBrightness() && !capabilities_.hasBrightness()) ||\n      (constraints.hasContrast() && !capabilities_.hasContrast()) ||\n      (constraints.hasSaturation() && !capabilities_.hasSaturation()) ||\n      (constraints.hasSharpness() && !capabilities_.hasSharpness()) ||\n      (constraints.hasZoom() && !capabilities_.hasZoom()) ||\n      (constraints.hasTorch() && !capabilities_.hasTorch())) {\n    resolver->Reject(\n        DOMException::Create(kNotSupportedError, \"Unsupported constraint(s)\"));\n    return;\n  }\n\n  auto settings = media::mojom::blink::PhotoSettings::New();\n  MediaTrackConstraintSet temp_constraints = current_constraints_;\n\n  settings->has_white_balance_mode = constraints.hasWhiteBalanceMode() &&\n                                     constraints.whiteBalanceMode().IsString();\n  if (settings->has_white_balance_mode) {\n    const auto white_balance_mode =\n        constraints.whiteBalanceMode().GetAsString();\n    if (capabilities_.whiteBalanceMode().Find(white_balance_mode) ==\n        kNotFound) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"Unsupported whiteBalanceMode.\"));\n      return;\n    }\n    temp_constraints.setWhiteBalanceMode(constraints.whiteBalanceMode());\n    settings->white_balance_mode = ParseMeteringMode(white_balance_mode);\n  }\n  settings->has_exposure_mode =\n      constraints.hasExposureMode() && constraints.exposureMode().IsString();\n  if (settings->has_exposure_mode) {\n    const auto exposure_mode = constraints.exposureMode().GetAsString();\n    if (capabilities_.exposureMode().Find(exposure_mode) == kNotFound) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"Unsupported exposureMode.\"));\n      return;\n    }\n    temp_constraints.setExposureMode(constraints.exposureMode());\n    settings->exposure_mode = ParseMeteringMode(exposure_mode);\n  }\n\n  settings->has_focus_mode =\n      constraints.hasFocusMode() && constraints.focusMode().IsString();\n  if (settings->has_focus_mode) {\n    const auto focus_mode = constraints.focusMode().GetAsString();\n    if (capabilities_.focusMode().Find(focus_mode) == kNotFound) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"Unsupported focusMode.\"));\n      return;\n    }\n    temp_constraints.setFocusMode(constraints.focusMode());\n    settings->focus_mode = ParseMeteringMode(focus_mode);\n  }\n\n  if (constraints.hasPointsOfInterest() &&\n      constraints.pointsOfInterest().IsPoint2DSequence()) {\n    for (const auto& point :\n         constraints.pointsOfInterest().GetAsPoint2DSequence()) {\n      auto mojo_point = media::mojom::blink::Point2D::New();\n      mojo_point->x = point.x();\n      mojo_point->y = point.y();\n      settings->points_of_interest.push_back(std::move(mojo_point));\n    }\n    temp_constraints.setPointsOfInterest(constraints.pointsOfInterest());\n  }\n\n  settings->has_exposure_compensation =\n      constraints.hasExposureCompensation() &&\n      constraints.exposureCompensation().IsDouble();\n  if (settings->has_exposure_compensation) {\n    const auto exposure_compensation =\n        constraints.exposureCompensation().GetAsDouble();\n    if (exposure_compensation < capabilities_.exposureCompensation()->min() ||\n        exposure_compensation > capabilities_.exposureCompensation()->max()) {\n      resolver->Reject(DOMException::Create(\n          kNotSupportedError, \"exposureCompensation setting out of range\"));\n      return;\n    }\n    temp_constraints.setExposureCompensation(\n        constraints.exposureCompensation());\n    settings->exposure_compensation = exposure_compensation;\n  }\n  settings->has_color_temperature = constraints.hasColorTemperature() &&\n                                    constraints.colorTemperature().IsDouble();\n  if (settings->has_color_temperature) {\n    const auto color_temperature = constraints.colorTemperature().GetAsDouble();\n    if (color_temperature < capabilities_.colorTemperature()->min() ||\n        color_temperature > capabilities_.colorTemperature()->max()) {\n      resolver->Reject(DOMException::Create(\n          kNotSupportedError, \"colorTemperature setting out of range\"));\n      return;\n    }\n    temp_constraints.setColorTemperature(constraints.colorTemperature());\n    settings->color_temperature = color_temperature;\n  }\n  settings->has_iso = constraints.hasIso() && constraints.iso().IsDouble();\n  if (settings->has_iso) {\n    const auto iso = constraints.iso().GetAsDouble();\n    if (iso < capabilities_.iso()->min() || iso > capabilities_.iso()->max()) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"iso setting out of range\"));\n      return;\n    }\n    temp_constraints.setIso(constraints.iso());\n    settings->iso = iso;\n  }\n\n  settings->has_brightness =\n      constraints.hasBrightness() && constraints.brightness().IsDouble();\n  if (settings->has_brightness) {\n    const auto brightness = constraints.brightness().GetAsDouble();\n    if (brightness < capabilities_.brightness()->min() ||\n        brightness > capabilities_.brightness()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"brightness setting out of range\"));\n      return;\n    }\n    temp_constraints.setBrightness(constraints.brightness());\n    settings->brightness = brightness;\n  }\n  settings->has_contrast =\n      constraints.hasContrast() && constraints.contrast().IsDouble();\n  if (settings->has_contrast) {\n    const auto contrast = constraints.contrast().GetAsDouble();\n    if (contrast < capabilities_.contrast()->min() ||\n        contrast > capabilities_.contrast()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"contrast setting out of range\"));\n      return;\n    }\n    temp_constraints.setContrast(constraints.contrast());\n    settings->contrast = contrast;\n  }\n  settings->has_saturation =\n      constraints.hasSaturation() && constraints.saturation().IsDouble();\n  if (settings->has_saturation) {\n    const auto saturation = constraints.saturation().GetAsDouble();\n    if (saturation < capabilities_.saturation()->min() ||\n        saturation > capabilities_.saturation()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"saturation setting out of range\"));\n      return;\n    }\n    temp_constraints.setSaturation(constraints.saturation());\n    settings->saturation = saturation;\n  }\n  settings->has_sharpness =\n      constraints.hasSharpness() && constraints.sharpness().IsDouble();\n  if (settings->has_sharpness) {\n    const auto sharpness = constraints.sharpness().GetAsDouble();\n    if (sharpness < capabilities_.sharpness()->min() ||\n        sharpness > capabilities_.sharpness()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"sharpness setting out of range\"));\n      return;\n    }\n    temp_constraints.setSharpness(constraints.sharpness());\n    settings->sharpness = sharpness;\n  }\n\n  settings->has_zoom = constraints.hasZoom() && constraints.zoom().IsDouble();\n  if (settings->has_zoom) {\n    const auto zoom = constraints.zoom().GetAsDouble();\n    if (zoom < capabilities_.zoom()->min() ||\n        zoom > capabilities_.zoom()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"zoom setting out of range\"));\n      return;\n    }\n    temp_constraints.setZoom(constraints.zoom());\n    settings->zoom = zoom;\n  }\n\n  settings->has_torch =\n      constraints.hasTorch() && constraints.torch().IsBoolean();\n  if (settings->has_torch) {\n    const auto torch = constraints.torch().GetAsBoolean();\n    if (torch && !capabilities_.torch()) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"torch not supported\"));\n      return;\n    }\n    temp_constraints.setTorch(constraints.torch());\n    settings->torch = torch;\n  }\n\n  current_constraints_ = temp_constraints;\n\n  service_requests_.insert(resolver);\n \n   MediaTrackConstraints resolver_constraints;\n   resolver_constraints.setAdvanced(constraints_vector);\n  auto resolver_cb = WTF::Bind(&ImageCapture::ResolveWithMediaTrackConstraints,\n                               WrapPersistent(this), resolver_constraints);\n \n   service_->SetOptions(\n       stream_track_->Component()->Source()->Id(), std::move(settings),\n      ConvertToBaseCallback(WTF::Bind(\n          &ImageCapture::OnMojoSetOptions, WrapPersistent(this),\n          WrapPersistent(resolver), WTF::Passed(std::move(resolver_cb)),\n          false \n)));\n}\n", "target": 1, "flaw_line_index": "218,219"}
{"idx": 8000, "func": "static long vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n                                size_t datalen)\n{\n    long ret = gnutls_read(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7712, "func": "static int coroutine_fn v9fs_complete_rename(V9fsPDU *pdu, V9fsFidState *fidp,\n                                             int32_t newdirfid,\n                                             V9fsString *name)\n{\n    char *end;\n    int err = 0;\n    V9fsPath new_path;\n    V9fsFidState *tfidp;\n    V9fsState *s = pdu->s;\n    V9fsFidState *dirfidp = NULL;\n    char *old_name, *new_name;\n\n    v9fs_path_init(&new_path);\n    if (newdirfid != -1) {\n        dirfidp = get_fid(pdu, newdirfid);\n        if (dirfidp == NULL) {\n            err = -ENOENT;\n            goto out_nofid;\n        }\n        if (fidp->fid_type != P9_FID_NONE) {\n            err = -EINVAL;\n            goto out;\n        }\n        v9fs_co_name_to_path(pdu, &dirfidp->path, name->data, &new_path);\n    } else {\n        old_name = fidp->path.data;\n        end = strrchr(old_name, '/');\n        if (end) {\n            end++;\n        } else {\n            end = old_name;\n        }\n        new_name = g_malloc0(end - old_name + name->size + 1);\n        strncat(new_name, old_name, end - old_name);\n        strncat(new_name + (end - old_name), name->data, name->size);\n        v9fs_co_name_to_path(pdu, NULL, new_name, &new_path);\n        g_free(new_name);\n    }\n    err = v9fs_co_rename(pdu, &fidp->path, &new_path);\n    if (err < 0) {\n        goto out;\n    }\n    for (tfidp = s->fid_list; tfidp; tfidp = tfidp->next) {\n        if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {\n            v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));\n        }\n    }\nout:\n    if (dirfidp) {\n        put_fid(pdu, dirfidp);\n    }\n    v9fs_path_free(&new_path);\nout_nofid:\n    return err;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8108, "func": "void Gfx::opBeginMarkedContent(Object args[], int numArgs) {\n  pushMarkedContent();\n  \n  OCGs *contentConfig = catalog->getOptContentConfig();\n  char* name0 = args[0].getName();\n  if ( strncmp( name0, \"OC\", 2) == 0 && contentConfig) {\n    if ( numArgs >= 2 ) {\n      if (!args[1].isName()) {\n\terror(getPos(), \"Unexpected MC Type: %i\", args[1].getType());\n      }\n      char* name1 = args[1].getName();\n      Object markedContent;\n      if ( res->lookupMarkedContentNF( name1, &markedContent ) ) {\n\tif ( markedContent.isRef() ) {\n\t  bool visible = contentConfig->optContentIsVisible( &markedContent );\n\t  MarkedContentStack *mc = mcStack;\n\t  mc->ocSuppressed = !(visible);\n       }\n      } else {\n\terror(getPos(), \"DID NOT find %s\", name1);\n      }\n    } else {\n      error(getPos(), \"insufficient arguments for Marked Content\");\n    }\n  }\n\n  if (printCommands) {\n    printf(\"  marked content: %s \", args[0].getName());\n    if (numArgs == 2)\n      args[1].print(stdout);\n    printf(\"\\n\");\n    fflush(stdout);\n  }\n\n  if(numArgs == 2 && args[1].isDict ()) {\n    out->beginMarkedContent(args[0].getName(),args[1].getDict());\n  } else if(numArgs == 1) {\n    out->beginMarkedContent(args[0].getName(),NULL);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7585, "func": "static void cirrus_linear_bitblt_write(void *opaque,\n                                       hwaddr addr,\n                                       uint64_t val,\n                                       unsigned size)\n{\n    CirrusVGAState *s = opaque;\n\n    if (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n\t*s->cirrus_srcptr++ = (uint8_t) val;\n\tif (s->cirrus_srcptr >= s->cirrus_srcptr_end) {\n\t    cirrus_bitblt_cputovideo_next(s);\n\t}\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187066, "func": "void PaymentRequest::Init(mojom::PaymentRequestClientPtr client,\n                          std::vector<mojom::PaymentMethodDataPtr> method_data,\n                           mojom::PaymentDetailsPtr details,\n                           mojom::PaymentOptionsPtr options) {\n   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n   client_ = std::move(client);\n \n   const GURL last_committed_url = delegate_->GetLastCommittedURL();\n   if (!OriginSecurityChecker::IsOriginSecure(last_committed_url)) {\n    LOG(ERROR) << \"Not in a secure origin\";\n     OnConnectionTerminated();\n     return;\n   }\n\n  bool allowed_origin =\n       OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) ||\n       OriginSecurityChecker::IsOriginLocalhostOrFile(last_committed_url);\n   if (!allowed_origin) {\n    LOG(ERROR) << \"Only localhost, file:\n                  \"allowed\";\n   }\n \n   bool invalid_ssl =\n       OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) &&\n       !delegate_->IsSslCertificateValid();\n  if (invalid_ssl)\n    LOG(ERROR) << \"SSL certificate is not valid\";\n \n   if (!allowed_origin || invalid_ssl) {\n     return;\n   }\n \n   std::string error;\n   if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {\n    LOG(ERROR) << error;\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (!details->total) {\n    LOG(ERROR) << \"Missing total\";\n     OnConnectionTerminated();\n     return;\n   }\n\n  spec_ = std::make_unique<PaymentRequestSpec>(\n      std::move(options), std::move(details), std::move(method_data), this,\n      delegate_->GetApplicationLocale());\n  state_ = std::make_unique<PaymentRequestState>(\n      web_contents_, top_level_origin_, frame_origin_, spec_.get(), this,\n      delegate_->GetApplicationLocale(), delegate_->GetPersonalDataManager(),\n      delegate_.get(), &journey_logger_);\n\n  journey_logger_.SetRequestedInformation(\n      spec_->request_shipping(), spec_->request_payer_email(),\n      spec_->request_payer_phone(), spec_->request_payer_name());\n\n  GURL google_pay_url(kGooglePayMethodName);\n  GURL android_pay_url(kAndroidPayMethodName);\n  auto non_google_it =\n      std::find_if(spec_->url_payment_method_identifiers().begin(),\n                   spec_->url_payment_method_identifiers().end(),\n                   [google_pay_url, android_pay_url](const GURL& url) {\n                     return url != google_pay_url && url != android_pay_url;\n                   });\n  journey_logger_.SetRequestedPaymentMethodTypes(\n!spec_->supported_card_networks().empty(),\n      base::ContainsValue(spec_->url_payment_method_identifiers(),\n                          google_pay_url) ||\n          base::ContainsValue(spec_->url_payment_method_identifiers(),\n                              android_pay_url),\nnon_google_it !=\n          spec_->url_payment_method_identifiers().end());\n }\n", "target": 1, "flaw_line_index": "10,19,20,26,27,30,31,37,43"}
{"idx": 7927, "func": "static void emitjumpto(JF, int opcode, int dest)\n{\n\temit(J, F, opcode);\n\tif (dest != (js_Instruction)dest)\n\t\tjs_syntaxerror(J, \"jump address integer overflow\");\n\temitraw(J, F, dest);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7732, "func": "static void __attribute__((__constructor__)) v9fs_set_fd_limit(void)\n{\n    struct rlimit rlim;\n    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        error_report(\"Failed to get the resource limit\");\n        exit(1);\n    }\n    open_fd_hw = rlim.rlim_cur - MIN(400, rlim.rlim_cur/3);\n    open_fd_rc = rlim.rlim_cur/2;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186693, "func": " void HeapObjectHeader::zapMagic() {\n  ASSERT(checkHeader());\n   m_magic = zappedMagic;\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 7706, "func": "ssize_t pdu_marshal(V9fsPDU *pdu, size_t offset, const char *fmt, ...)\n{\n    ssize_t ret;\n    va_list ap;\n\n    va_start(ap, fmt);\n    ret = virtio_pdu_vmarshal(pdu, offset, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8120, "func": "void Gfx::opEOFillStroke(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    return;\n  }\n  if (state->isPath() && !contentIsHidden()) {\n    if (state->getFillColorSpace()->getMode() == csPattern) {\n      doPatternFill(gTrue);\n    } else {\n      out->eoFill(state);\n    }\n    if (state->getStrokeColorSpace()->getMode() == csPattern) {\n      doPatternStroke();\n    } else {\n      out->stroke(state);\n    }\n  }\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7452, "func": "ZEND_API int zend_ts_hash_index_find(TsHashTable *ht, ulong h, void **pData)\n{\n\tint retval;\n\n\tbegin_read(ht);\n\tretval = zend_hash_index_find(TS_HASH(ht), h, pData);\n\tend_read(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7448, "func": "void zend_ts_hash_display_pListTail(TsHashTable *ht)\n{\n\tbegin_read(ht);\n\tzend_hash_display_pListTail(TS_HASH(ht));\n\tend_read(ht);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7779, "func": "static int h2_send_empty_data_es(struct h2s *h2s)\n{\n\tstruct h2c *h2c = h2s->h2c;\n\tstruct buffer *res;\n\tchar str[9];\n\tint ret;\n\n\tif (h2s->st == H2_SS_HLOC || h2s->st == H2_SS_ERROR || h2s->st == H2_SS_CLOSED)\n\t\treturn 1;\n\n\tif (h2c_mux_busy(h2c, h2s)) {\n\t\th2s->flags |= H2_SF_BLK_MBUSY;\n\t\treturn 0;\n\t}\n\n\tres = h2_get_buf(h2c, &h2c->mbuf);\n\tif (!res) {\n\t\th2c->flags |= H2_CF_MUX_MALLOC;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\treturn 0;\n\t}\n\n\tmemcpy(str, \"\\x00\\x00\\x00\\x00\\x01\", 5);\n\twrite_n32(str + 5, h2s->id);\n\tret = bo_istput(res, ist2(str, 9));\n\tif (likely(ret > 0)) {\n\t\th2s->flags |= H2_SF_ES_SENT;\n\t}\n\telse if (!ret) {\n\t\th2c->flags |= H2_CF_MUX_MFULL;\n\t\th2s->flags |= H2_SF_BLK_MROOM;\n\t\treturn 0;\n\t}\n\telse {\n\t\th2c_error(h2c, H2_ERR_INTERNAL_ERROR);\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7507, "func": "  tt_check_single_notdef( FT_Face  ttface )\n  {\n    FT_Bool   result = FALSE;\n\n    TT_Face   face = (TT_Face)ttface;\n    FT_UInt   asize;\n    FT_ULong  i;\n    FT_ULong  glyph_index = 0;\n    FT_UInt   count       = 0;\n\n\n    for( i = 0; i < face->num_locations; i++ )\n    {\n      tt_face_get_location( face, i, &asize );\n      if ( asize > 0 )\n      {\n        count += 1;\n        if ( count > 1 )\n          break;\n        glyph_index = i;\n      }\n    }\n\n    if ( count == 1 )\n    {\n      if ( glyph_index == 0 )\n        result = TRUE;\n      else\n      {\n        FT_Error error;\n        char buf[8];\n\n\n        error = FT_Get_Glyph_Name( ttface, glyph_index, buf, 8 );\n        if ( !error                                            &&\n             buf[0] == '.' && !ft_strncmp( buf, \".notdef\", 8 ) )\n          result = TRUE;\n      }\n    }\n\n    return result;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 187257, "func": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (session->restricted() && !IsFrameHostAllowedForRestrictedSessions())\n    return false;\n  session->SetRenderer(frame_host_ ? frame_host_->GetProcess()->GetID()\n                                   : ChildProcessHost::kInvalidUniqueID,\n                       frame_host_);\n\n  protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(\n      base::WrapUnique(new protocol::TargetHandler(false \n)));\n   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n       protocol::TracingHandler::Renderer,\n       frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,\n      GetIOContext())));\n  session->AddHandler(\n      base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n\n  if (EnsureAgent())\n    session->AttachToAgent(agent_ptr_);\n\n  if (sessions().size() == 1) {\n    if (!base::FeatureList::IsEnabled(features::kVizDisplayCompositor) &&\n        !base::FeatureList::IsEnabled(\n            features::kUseVideoCaptureApiForDevToolsSnapshots)) {\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    }\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}\n", "target": 1, "flaw_line_index": "22,24"}
{"idx": 187025, "func": "void ExtensionsGuestViewMessageFilter::MimeHandlerViewGuestCreatedCallback(\n    int element_instance_id,\n    int embedder_render_process_id,\n    int embedder_render_frame_id,\n    int32_t plugin_frame_routing_id,\n    const gfx::Size& element_size,\n    mime_handler::BeforeUnloadControlPtrInfo before_unload_control,\n    bool is_full_page_plugin,\n    WebContents* web_contents) {\n  auto* guest_view = MimeHandlerViewGuest::FromWebContents(web_contents);\n  if (!guest_view)\n    return;\n\n  guest_view->SetBeforeUnloadController(std::move(before_unload_control));\n  int guest_instance_id = guest_view->guest_instance_id();\n  auto* rfh = RenderFrameHost::FromID(embedder_render_process_id,\n                                      embedder_render_frame_id);\n  if (!rfh)\n    return;\n\n  guest_view->SetEmbedderFrame(embedder_render_process_id,\n                               embedder_render_frame_id);\n\n  base::DictionaryValue attach_params;\n  attach_params.SetInteger(guest_view::kElementWidth, element_size.width());\n  attach_params.SetInteger(guest_view::kElementHeight, element_size.height());\n  auto* manager = GuestViewManager::FromBrowserContext(browser_context_);\n  if (!manager) {\n    guest_view::bad_message::ReceivedBadMessage(\n        this,\n        guest_view::bad_message::GVMF_UNEXPECTED_MESSAGE_BEFORE_GVM_CREATION);\n    guest_view->Destroy(true);\n    return;\n  }\n  manager->AttachGuest(embedder_render_process_id, element_instance_id,\n                       guest_instance_id, attach_params);\n\n  if (!content::MimeHandlerViewMode::UsesCrossProcessFrame()) {\n    rfh->Send(new ExtensionsGuestViewMsg_CreateMimeHandlerViewGuestACK(\n         element_instance_id));\n     return;\n   }\n  auto* plugin_rfh = RenderFrameHost::FromID(embedder_render_process_id,\n                                             plugin_frame_routing_id);\n  if (!plugin_rfh) {\n    plugin_rfh = RenderFrameHost::FromPlaceholderId(embedder_render_process_id,\n                                                    plugin_frame_routing_id);\n  }\n  if (!plugin_rfh) {\n    guest_view->GetEmbedderFrame()->Send(\n        new ExtensionsGuestViewMsg_RetryCreatingMimeHandlerViewGuest(\n            element_instance_id));\n    guest_view->Destroy(true);\n    return;\n  }\n  if (guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh)) {\n    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,\n                                              is_full_page_plugin);\n  } else {\n    frame_navigation_helpers_[element_instance_id] =\n        std::make_unique<FrameNavigationHelper>(\n            plugin_rfh, guest_view->guest_instance_id(), element_instance_id,\n            is_full_page_plugin, this);\n  }\n}\n", "target": 1, "flaw_line_index": "43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66"}
{"idx": 186950, "func": "void AppCache::ToDatabaseRecords(\n    const AppCacheGroup* group,\n    AppCacheDatabase::CacheRecord* cache_record,\n    std::vector<AppCacheDatabase::EntryRecord>* entries,\n    std::vector<AppCacheDatabase::NamespaceRecord>* intercepts,\n    std::vector<AppCacheDatabase::NamespaceRecord>* fallbacks,\n    std::vector<AppCacheDatabase::OnlineWhiteListRecord>* whitelists) {\n  DCHECK(group && cache_record && entries && fallbacks && whitelists);\n  DCHECK(entries->empty() && fallbacks->empty() && whitelists->empty());\n\n  cache_record->cache_id = cache_id_;\n  cache_record->group_id = group->group_id();\n   cache_record->online_wildcard = online_whitelist_all_;\n   cache_record->update_time = update_time_;\n   cache_record->cache_size = cache_size_;\n \n   for (const auto& pair : entries_) {\n     entries->push_back(AppCacheDatabase::EntryRecord());\n    AppCacheDatabase::EntryRecord& record = entries->back();\n    record.url = pair.first;\n    record.cache_id = cache_id_;\n     record.flags = pair.second.types();\n     record.response_id = pair.second.response_id();\n     record.response_size = pair.second.response_size();\n   }\n \n   const url::Origin origin = url::Origin::Create(group->manifest_url());\n\n  for (size_t i = 0; i < intercept_namespaces_.size(); ++i) {\n    intercepts->push_back(AppCacheDatabase::NamespaceRecord());\n    AppCacheDatabase::NamespaceRecord& record = intercepts->back();\n    record.cache_id = cache_id_;\n    record.origin = origin;\n    record.namespace_ = intercept_namespaces_[i];\n  }\n\n  for (size_t i = 0; i < fallback_namespaces_.size(); ++i) {\n    fallbacks->push_back(AppCacheDatabase::NamespaceRecord());\n    AppCacheDatabase::NamespaceRecord& record = fallbacks->back();\n    record.cache_id = cache_id_;\n    record.origin = origin;\n    record.namespace_ = fallback_namespaces_[i];\n  }\n\n  for (size_t i = 0; i < online_whitelist_namespaces_.size(); ++i) {\n    whitelists->push_back(AppCacheDatabase::OnlineWhiteListRecord());\n    AppCacheDatabase::OnlineWhiteListRecord& record = whitelists->back();\n    record.cache_id = cache_id_;\n    record.namespace_url = online_whitelist_namespaces_[i].namespace_url;\n    record.is_pattern = online_whitelist_namespaces_[i].is_pattern;\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187250, "func": "  bool IsAllowed(const scoped_refptr<const Extension>& extension,\n                 const GURL& url,\n                 PermittedFeature feature,\n                 int tab_id) {\n    const PermissionsData* permissions_data = extension->permissions_data();\n    bool script = permissions_data->CanAccessPage(extension.get(), url, tab_id,\n                                                   nullptr) &&\n                   permissions_data->CanRunContentScriptOnPage(\n                       extension.get(), url, tab_id, nullptr);\n    bool capture = HasTabsPermission(extension, tab_id) &&\n                   permissions_data->CanCaptureVisiblePage(tab_id, NULL);\n     switch (feature) {\n       case PERMITTED_SCRIPT_ONLY:\n         return script && !capture;\n      case PERMITTED_CAPTURE_ONLY:\n        return capture && !script;\n      case PERMITTED_BOTH:\n        return script && capture;\n      case PERMITTED_NONE:\n        return !script && !capture;\n    }\n    NOTREACHED();\n    return false;\n  }\n", "target": 1, "flaw_line_index": "10,11"}
{"idx": 187175, "func": "GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n                                 const GURL& real_url) {\n  if (real_url.SchemeIs(kGuestScheme))\n    return real_url;\n\n  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);\n  url::Origin origin = url::Origin::Create(url);\n\n  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();\n  url::Origin isolated_origin;\n  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))\n    return isolated_origin.GetURL();\n\n  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {\n    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(\n        origin.host(),\n        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);\n    std::string site = origin.scheme();\n    site += url::kStandardSchemeSeparator;\n    site += domain.empty() ? origin.host() : domain;\n    return GURL(site);\n  }\n\n   if (!origin.unique()) {\n     DCHECK(!origin.scheme().empty());\n     return GURL(origin.scheme() + \":\");\n   } else if (url.has_scheme()) {\n     DCHECK(!url.scheme().empty());\n     return GURL(url.scheme() + \":\");\n   }\n\n  DCHECK(!url.is_valid()) << url;\n  return GURL();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8191, "func": "static int coroutine_fn v9fs_xattr_fid_clunk(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    int retval = 0;\n\n    if (fidp->fs.xattr.copied_len == -1) {\n        goto free_value;\n    }\n    if (fidp->fs.xattr.len != fidp->fs.xattr.copied_len) {\n        retval = -EINVAL;\n        goto free_out;\n    }\n    if (fidp->fs.xattr.len) {\n        retval = v9fs_co_lsetxattr(pdu, &fidp->path, &fidp->fs.xattr.name,\n                                   fidp->fs.xattr.value,\n                                   fidp->fs.xattr.len,\n                                   fidp->fs.xattr.flags);\n    } else {\n        retval = v9fs_co_lremovexattr(pdu, &fidp->path, &fidp->fs.xattr.name);\n    }\nfree_out:\n    v9fs_string_free(&fidp->fs.xattr.name);\nfree_value:\n    g_free(fidp->fs.xattr.value);\n    return retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186342, "func": "void PreconnectManager::FinishPreresolveJob(PreresolveJobId job_id,\n                                            bool success) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  PreresolveJob* job = preresolve_jobs_.Lookup(job_id);\n  DCHECK(job);\n\n  bool need_preconnect = success && job->need_preconnect();\n  if (need_preconnect) {\n    PreconnectUrl(job->url, job->num_sockets, job->allow_credentials,\n                  job->network_isolation_key);\n   }\n \n   PreresolveInfo* info = job->info;\n  if (info)\n    info->stats->requests_stats.emplace_back(job->url, need_preconnect);\n   preresolve_jobs_.Remove(job_id);\n   --inflight_preresolves_count_;\n   if (info) {\n    DCHECK_LE(1u, info->inflight_count);\n    --info->inflight_count;\n  }\n  if (info && info->is_done())\n    AllPreresolvesForUrlFinished(info);\n  TryToLaunchPreresolveJobs();\n}\n", "target": 1, "flaw_line_index": "14,15"}
{"idx": 187020, "func": "void ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameDeleted(\n    RenderFrameHost* render_frame_host) {\n  if (render_frame_host->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                 MSG_ROUTING_NONE \n);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,7,8,9"}
{"idx": 7870, "func": "static int ram_save_iterate(QEMUFile *f, void *opaque)\n{\n    int ret;\n    int i;\n    int64_t t0;\n    int total_sent = 0;\n\n    qemu_mutex_lock_ramlist();\n\n    if (ram_list.version != last_version) {\n        reset_ram_globals();\n    }\n\n    ram_control_before_iterate(f, RAM_CONTROL_ROUND);\n\n    t0 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n    i = 0;\n    while ((ret = qemu_file_rate_limit(f)) == 0) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, false);\n        if (bytes_sent == 0) {\n            break;\n        }\n        total_sent += bytes_sent;\n        acct_info.iterations++;\n        check_guest_throttling();\n        if ((i & 63) == 0) {\n            uint64_t t1 = (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - t0) / 1000000;\n            if (t1 > MAX_WAIT) {\n                DPRINTF(\"big wait: %\" PRIu64 \" milliseconds, %d iterations\\n\",\n                        t1, i);\n                break;\n            }\n        }\n        i++;\n    }\n\n    qemu_mutex_unlock_ramlist();\n\n    ram_control_after_iterate(f, RAM_CONTROL_ROUND);\n\n    bytes_transferred += total_sent;\n\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n    bytes_transferred += 8;\n\n    ret = qemu_file_get_error(f);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return total_sent;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7408, "func": "static void begin_write(TsHashTable *ht)\n{\n#ifdef ZTS\n\ttsrm_mutex_lock(ht->mx_writer);\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186717, "func": " void DevToolsSession::AddHandler(\n     std::unique_ptr<protocol::DevToolsDomainHandler> handler) {\n   handler->Wire(dispatcher_.get());\n  handler->SetRenderer(process_, host_);\n   handlers_[handler->name()] = std::move(handler);\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 186577, "func": " UnacceleratedStaticBitmapImage::MakeAccelerated(\n     base::WeakPtr<WebGraphicsContext3DProviderWrapper> context_wrapper) {\n   if (!context_wrapper)\n     return nullptr;  \n \n  GrContext* grcontext = context_wrapper->ContextProvider()->GetGrContext();\n  if (!grcontext)\n    return nullptr;  \n\n  sk_sp<SkImage> sk_image = paint_image_.GetSkImage();\n  sk_sp<SkImage> gpu_skimage =\n      sk_image->makeTextureImage(grcontext, sk_image->colorSpace());\n  if (!gpu_skimage)\n    return nullptr;\n\n  return AcceleratedStaticBitmapImage::CreateFromSkImage(\n      std::move(gpu_skimage), std::move(context_wrapper));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187233, "func": "static int hid_reset_device(int sub_api, struct libusb_device_handle *dev_handle)\n{\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n\tHANDLE hid_handle;\n\tint current_interface;\n\tCHECK_HID_AVAILABLE;\n\tfor (current_interface = 0; current_interface < USB_MAXINTERFACES; current_interface++) {\n\t\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\t\tif ((hid_handle != 0) && (hid_handle != INVALID_HANDLE_VALUE)) {\n\t\t\tHidD_FlushQueue(hid_handle);\n\t\t}\n\t}\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15"}
{"idx": 8030, "func": "static void vnc_listen_read(void *opaque, bool websocket)\n{\n    VncDisplay *vs = opaque;\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof(addr);\n    int csock;\n\n    graphic_hw_update(NULL);\n#ifdef CONFIG_VNC_WS\n    if (websocket) {\n        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);\n    } else\n#endif \n    {\n        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);\n    }\n\n    if (csock != -1) {\n        socket_set_nodelay(csock);\n        vnc_connect(vs, csock, false, websocket);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186340, "func": " void ReportPreconnectAccuracy(\n     const PreconnectStats& stats,\n    const std::map<GURL, OriginRequestSummary>& requests) {\n   if (stats.requests_stats.empty())\n     return;\n \n  int preresolve_hits_count = 0;\n  int preresolve_misses_count = 0;\n  int preconnect_hits_count = 0;\n  int preconnect_misses_count = 0;\n\n  for (const auto& request_stats : stats.requests_stats) {\n    bool hit = requests.find(request_stats.origin) != requests.end();\n    bool preconnect = request_stats.was_preconnected;\n\n    preresolve_hits_count += hit;\n    preresolve_misses_count += !hit;\n    preconnect_hits_count += preconnect && hit;\n    preconnect_misses_count += preconnect && !hit;\n  }\n\n  int total_preresolves = preresolve_hits_count + preresolve_misses_count;\n  int total_preconnects = preconnect_hits_count + preconnect_misses_count;\n  DCHECK_EQ(static_cast<int>(stats.requests_stats.size()),\n            preresolve_hits_count + preresolve_misses_count);\n  DCHECK_GT(total_preresolves, 0);\n\n  size_t preresolve_hits_percentage =\n      (100 * preresolve_hits_count) / total_preresolves;\n\n  if (total_preconnects > 0) {\n    size_t preconnect_hits_percentage =\n        (100 * preconnect_hits_count) / total_preconnects;\n    UMA_HISTOGRAM_PERCENTAGE(\n        internal::kLoadingPredictorPreconnectHitsPercentage,\n        preconnect_hits_percentage);\n  }\n\n  UMA_HISTOGRAM_PERCENTAGE(internal::kLoadingPredictorPreresolveHitsPercentage,\n                           preresolve_hits_percentage);\n  UMA_HISTOGRAM_COUNTS_100(internal::kLoadingPredictorPreresolveCount,\n                           total_preresolves);\n  UMA_HISTOGRAM_COUNTS_100(internal::kLoadingPredictorPreconnectCount,\n                           total_preconnects);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8208, "func": "static void v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err += offset;\n    memcpy(&s->root_qid, &qid, sizeof(qid));\n    trace_v9fs_attach_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path);\n    if (!s->migration_blocker) {\n        s->root_fid = fid;\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        migrate_add_blocker(s->migration_blocker);\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186330, "func": "void ContentSecurityPolicy::postViolationReport(\n    const SecurityPolicyViolationEventInit& violationData,\n    LocalFrame* contextFrame,\n    const Vector<String>& reportEndpoints) {\n  Document* document =\n      contextFrame ? contextFrame->document() : this->document();\n  if (!document)\n    return;\n\n \n   std::unique_ptr<JSONObject> cspReport = JSONObject::create();\n   cspReport->setString(\"document-uri\", violationData.documentURI());\n  cspReport->setString(\"referrer\", violationData.referrer());\n  cspReport->setString(\"violated-directive\", violationData.violatedDirective());\n  cspReport->setString(\"effective-directive\",\n                       violationData.effectiveDirective());\n  cspReport->setString(\"original-policy\", violationData.originalPolicy());\n  cspReport->setString(\"disposition\", violationData.disposition());\n  cspReport->setString(\"blocked-uri\", violationData.blockedURI());\n  if (violationData.lineNumber())\n    cspReport->setInteger(\"line-number\", violationData.lineNumber());\n  if (violationData.columnNumber())\n    cspReport->setInteger(\"column-number\", violationData.columnNumber());\n  if (!violationData.sourceFile().isEmpty())\n    cspReport->setString(\"source-file\", violationData.sourceFile());\n  cspReport->setInteger(\"status-code\", violationData.statusCode());\n\n  if (experimentalFeaturesEnabled())\n    cspReport->setString(\"sample\", violationData.sample());\n\n  std::unique_ptr<JSONObject> reportObject = JSONObject::create();\n  reportObject->setObject(\"csp-report\", std::move(cspReport));\n  String stringifiedReport = reportObject->toJSONString();\n\n  if (shouldSendViolationReport(stringifiedReport)) {\n    didSendViolationReport(stringifiedReport);\n\n    RefPtr<EncodedFormData> report =\n        EncodedFormData::create(stringifiedReport.utf8());\n\n    LocalFrame* frame = document->frame();\n    if (!frame)\n      return;\n\n    for (const String& endpoint : reportEndpoints) {\n      DCHECK(!contextFrame || !m_executionContext);\n      DCHECK(!contextFrame ||\n             getDirectiveType(violationData.effectiveDirective()) ==\n                 DirectiveType::FrameAncestors);\n      KURL url =\n          contextFrame\n              ? frame->document()->completeURLWithOverride(\n                    endpoint, KURL(ParsedURLString, violationData.blockedURI()))\n              : completeURL(endpoint);\n      PingLoader::sendViolationReport(\n          frame, url, report, PingLoader::ContentSecurityPolicyViolationReport);\n    }\n  }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186691, "func": " void NormalPageArena::promptlyFreeObject(HeapObjectHeader* header) {\n   ASSERT(!getThreadState()->sweepForbidden());\n  ASSERT(header->checkHeader());\n   Address address = reinterpret_cast<Address>(header);\n   Address payload = header->payload();\n   size_t size = header->size();\n  size_t payloadSize = header->payloadSize();\n  ASSERT(size > 0);\n  ASSERT(pageFromObject(address) == findPageFromAddress(address));\n\n  {\n    ThreadState::SweepForbiddenScope forbiddenScope(getThreadState());\n    header->finalize(payload, payloadSize);\n    if (address + size == m_currentAllocationPoint) {\n      m_currentAllocationPoint = address;\n      setRemainingAllocationSize(m_remainingAllocationSize + size);\n      SET_MEMORY_INACCESSIBLE(address, size);\n      return;\n    }\n    SET_MEMORY_INACCESSIBLE(payload, payloadSize);\n    header->markPromptlyFreed();\n  }\n\n  m_promptlyFreedSize += size;\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 7761, "func": "static int h2_frt_transfer_data(struct h2s *h2s, struct buffer *buf, int count)\n{\n\tstruct h2c *h2c = h2s->h2c;\n\tint block1, block2;\n\tunsigned int flen = h2c->dfl;\n\n\th2s->cs->flags &= ~CS_FL_RCV_MORE;\n\th2c->flags &= ~H2_CF_DEM_SFULL;\n\n\tif (h2c->dff & H2_F_DATA_PADDED) {\n\t\tif (h2c->dbuf->i < 1)\n\t\t\treturn 0;\n\n\t\th2c->dpl = *(uint8_t *)bi_ptr(h2c->dbuf);\n\t\tif (h2c->dpl >= h2c->dfl) {\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbi_del(h2c->dbuf, 1);\n\t\th2c->dfl--;\n\t\th2c->rcvd_c++; h2c->rcvd_s++;\n\t\th2c->dff &= ~H2_F_DATA_PADDED;\n\t}\n\n\tflen = h2c->dfl - h2c->dpl;\n\tif (!flen)\n\t\tgoto end_transfer;\n\n\tif (flen > h2c->dbuf->i) {\n\t\tflen = h2c->dbuf->i;\n\t\tif (!flen)\n\t\t\treturn 0;\n\t}\n\n\tif (flen > count) {\n\t\tflen = count;\n\t\tif (!flen) {\n\t\t\th2c->flags |= H2_CF_DEM_SFULL;\n\t\t\th2s->cs->flags |= CS_FL_RCV_MORE;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tblock1 = bi_contig_data(h2c->dbuf);\n\tif (block1 > flen)\n\t\tblock1 = flen;\n\tblock2 = flen - block1;\n\n\tif (block1)\n\t\tbi_putblk(buf, b_ptr(h2c->dbuf, 0), block1);\n\n\tif (block2)\n\t\tbi_putblk(buf, b_ptr(h2c->dbuf, block1), block2);\n\n\tbi_del(h2c->dbuf, flen);\n\th2c->dfl    -= flen;\n\th2c->rcvd_c += flen;\n\th2c->rcvd_s += flen;  \n\n\tif (h2c->dfl > h2c->dpl) {\n\t\th2c->flags |= H2_CF_DEM_SFULL;\n\t\th2s->cs->flags |= CS_FL_RCV_MORE;\n\t\treturn flen;\n\t}\n\n end_transfer:\n\th2c->rcvd_c += h2c->dpl;\n\th2c->rcvd_s += h2c->dpl;\n\th2c->dpl = 0;\n\th2c->st0 = H2_CS_FRAME_A; \n\n\tif (h2c->dff & H2_F_DATA_END_STREAM) {\n\t\th2s->cs->flags |= CS_FL_EOS;\n\t\th2s->flags |= H2_SF_ES_RCVD;\n\t}\n\n\treturn flen;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7661, "func": "static int v9fs_receive_status(V9fsProxy *proxy,\n                               struct iovec *reply, int *status)\n{\n    int retval;\n    ProxyHeader header;\n\n    *status = 0;\n    reply->iov_len = 0;\n    retval = socket_read(proxy->sockfd, reply->iov_base, PROXY_HDR_SZ);\n    if (retval < 0) {\n        return retval;\n    }\n    reply->iov_len = PROXY_HDR_SZ;\n    proxy_unmarshal(reply, 0, \"dd\", &header.type, &header.size);\n    if (header.size != sizeof(int)) {\n        *status = -ENOBUFS;\n        return 0;\n    }\n    retval = socket_read(proxy->sockfd,\n                         reply->iov_base + PROXY_HDR_SZ, header.size);\n    if (retval < 0) {\n        return retval;\n    }\n    reply->iov_len += header.size;\n    proxy_unmarshal(reply, PROXY_HDR_SZ, \"d\", status);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186408, "func": "PageInfoUI::GetSecurityDescription(const IdentityInfo& identity_info) const {\n   std::unique_ptr<PageInfoUI::SecurityDescription> security_description(\n       new PageInfoUI::SecurityDescription());\n \n  switch (identity_info.safe_browsing_status) {\n    case PageInfo::SAFE_BROWSING_STATUS_NONE:\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_MALWARE:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_MALWARE_SUMMARY,\n                                       IDS_PAGE_INFO_MALWARE_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING:\n      return CreateSecurityDescription(\n          SecuritySummaryColor::RED, IDS_PAGE_INFO_SOCIAL_ENGINEERING_SUMMARY,\n          IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_SUMMARY,\n                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE:\n#if defined(FULL_SAFE_BROWSING)\n      return CreateSecurityDescriptionForPasswordReuse(\nfalse);\n#endif\n      NOTREACHED();\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE:\n#if defined(FULL_SAFE_BROWSING)\n      return CreateSecurityDescriptionForPasswordReuse(\ntrue);\n#endif\n      NOTREACHED();\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_BILLING:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_BILLING_SUMMARY,\n                                       IDS_PAGE_INFO_BILLING_DETAILS);\n  }\n   switch (identity_info.identity_status) {\n     case PageInfo::SITE_IDENTITY_STATUS_INTERNAL_PAGE:\n #if defined(OS_ANDROID)\n      return CreateSecurityDescription(SecuritySummaryColor::GREEN,\n                                       IDS_PAGE_INFO_INTERNAL_PAGE,\n                                       IDS_PAGE_INFO_INTERNAL_PAGE);\n#else\n      NOTREACHED();\n      FALLTHROUGH;\n#endif\n    case PageInfo::SITE_IDENTITY_STATUS_EV_CERT:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_CERT:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_CERT_REVOCATION_UNKNOWN:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_ADMIN_PROVIDED_CERT:\n      switch (identity_info.connection_status) {\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_ACTIVE_SUBRESOURCE:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_NOT_SECURE_SUMMARY,\n                                           IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_FORM_ACTION:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,\n                                           IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_PASSIVE_SUBRESOURCE:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_DETAILS);\n        default:\n          return CreateSecurityDescription(SecuritySummaryColor::GREEN,\n                                            IDS_PAGE_INFO_SECURE_SUMMARY,\n                                            IDS_PAGE_INFO_SECURE_DETAILS);\n       }\n     case PageInfo::SITE_IDENTITY_STATUS_DEPRECATED_SIGNATURE_ALGORITHM:\n     case PageInfo::SITE_IDENTITY_STATUS_UNKNOWN:\n     case PageInfo::SITE_IDENTITY_STATUS_NO_CERT:\n    default:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_NOT_SECURE_SUMMARY,\n                                       IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n  }\n}\n", "target": 1, "flaw_line_index": "5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38"}
{"idx": 186987, "func": "  void GrantActiveTab(const GURL& url) {\n     APIPermissionSet tab_api_permissions;\n     tab_api_permissions.insert(APIPermission::kTab);\n     URLPatternSet tab_hosts;\n    tab_hosts.AddOrigin(UserScript::ValidUserScriptSchemes(),\n                        url::Origin::Create(url).GetURL());\n     PermissionSet tab_permissions(std::move(tab_api_permissions),\n                                   ManifestPermissionSet(), tab_hosts,\n                                   tab_hosts);\n    active_tab_->permissions_data()->UpdateTabSpecificPermissions(\n        kTabId, tab_permissions);\n   }\n", "target": 1, "flaw_line_index": "10,11"}
{"idx": 7932, "func": "static void emitstring(JF, int opcode, const char *str)\n{\n\temit(J, F, opcode);\n\temitraw(J, F, addstring(J, F, str));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186419, "func": "void DevToolsUIBindings::CallClientFunction(const std::string& function_name,\n                                            const base::Value* arg1,\n                                            const base::Value* arg2,\n                                             const base::Value* arg3) {\n   if (!web_contents_->GetURL().SchemeIs(content::kChromeDevToolsScheme))\n     return;\n   std::string javascript = function_name + \"(\";\n   if (arg1) {\n     std::string json;\n    base::JSONWriter::Write(*arg1, &json);\n    javascript.append(json);\n    if (arg2) {\n      base::JSONWriter::Write(*arg2, &json);\n      javascript.append(\", \").append(json);\n      if (arg3) {\n        base::JSONWriter::Write(*arg3, &json);\n        javascript.append(\", \").append(json);\n      }\n    }\n  }\n  javascript.append(\");\");\n  web_contents_->GetMainFrame()->ExecuteJavaScript(\n      base::UTF8ToUTF16(javascript));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8122, "func": "void Gfx::opEndImage(Object args[], int numArgs) {\n  error(getPos(), \"Internal: got 'EI' operator\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187081, "func": " void MediaStreamDispatcherHost::StopStreamDevice(const std::string& device_id,\n                                                  int32_t session_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   media_stream_manager_->StopStreamDevice(render_process_id_, render_frame_id_,\n                                          device_id, session_id);\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 7938, "func": "js_Function *jsC_compilefunction(js_State *J, js_Ast *prog)\n{\n\treturn newfun(J, prog->a, prog->b, prog->c, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7916, "func": "static void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\n\tcexp(J, F, ref);\n\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\n\tif (end)\n\t\tlabel(J, F, end);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187214, "func": "static int _hid_get_hid_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n{\n\tstruct libusb_hid_descriptor d;\n\tuint8_t tmp[MAX_HID_DESCRIPTOR_SIZE];\n\tsize_t report_len = MAX_HID_DESCRIPTOR_SIZE;\n\t_hid_get_report_descriptor(dev, tmp, &report_len);\n\td.bLength = LIBUSB_DT_HID_SIZE;\n\td.bDescriptorType = LIBUSB_DT_HID;\n\td.bcdHID = 0x0110; \n\td.bCountryCode = 0;\n\td.bNumDescriptors = 1;\n\td.bClassDescriptorType = LIBUSB_DT_REPORT;\n\td.wClassDescriptorLength = (uint16_t)report_len;\n\tif (*size > LIBUSB_DT_HID_SIZE)\n\t\t*size = LIBUSB_DT_HID_SIZE;\n\tmemcpy(data, &d, *size);\n\treturn LIBUSB_COMPLETED;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18"}
{"idx": 7895, "func": "static js_Ast *breaktarget(JF, js_Ast *node, const char *label)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\tbreak;\n\t\tif (!label) {\n\t\t\tif (isloop(node->type) || node->type == STM_SWITCH)\n\t\t\t\treturn node;\n\t\t} else {\n\t\t\tif (matchlabel(node->parent, label))\n\t\t\t\treturn node;\n\t\t}\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7720, "func": "static void v9fs_fsync(void *opaque)\n{\n    int err;\n    int32_t fid;\n    int datasync;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"dd\", &fid, &datasync);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_fsync(pdu->tag, pdu->id, fid, datasync);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fsync(pdu, fidp, datasync);\n    if (!err) {\n        err = offset;\n    }\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187014, "func": "void NavigationRequest::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    const scoped_refptr<network::ResourceResponse>& response) {\n  response_ = response;\n  ssl_info_ = response->head.ssl_info;\n#if defined(OS_ANDROID)\n  base::WeakPtr<NavigationRequest> this_ptr(weak_factory_.GetWeakPtr());\n\n  bool should_override_url_loading = false;\n  if (!GetContentClient()->browser()->ShouldOverrideUrlLoading(\n          frame_tree_node_->frame_tree_node_id(), browser_initiated_,\n          redirect_info.new_url, redirect_info.new_method,\n          false, true, frame_tree_node_->IsMainFrame(),\n          common_params_.transition, &should_override_url_loading)) {\n    return;\n  }\n\n  if (!this_ptr)\n    return;\n\n  if (should_override_url_loading) {\n    navigation_handle_->set_net_error_code(net::ERR_ABORTED);\n    common_params_.url = redirect_info.new_url;\n    common_params_.method = redirect_info.new_method;\n    navigation_handle_->UpdateStateFollowingRedirect(\n        GURL(redirect_info.new_referrer),\n        base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                   base::Unretained(this)));\n    frame_tree_node_->ResetNavigationRequest(false, true);\n    return;\n  }\n#endif\n  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanRedirectToURL(\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);\n    frame_tree_node_->ResetNavigationRequest(false, true);\n     return;\n   }\n \n  if (!browser_initiated_ && source_site_instance() &&\n      !ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(\n          source_site_instance()->GetProcess()->GetID(),\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied unauthorized redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);\n    frame_tree_node_->ResetNavigationRequest(false, true);\n     return;\n   }\n \n  if (redirect_info.new_method != \"POST\")\n    common_params_.post_data = nullptr;\n\n  if (commit_params_.navigation_timing.redirect_start.is_null()) {\n    commit_params_.navigation_timing.redirect_start =\n        commit_params_.navigation_timing.fetch_start;\n  }\n  commit_params_.navigation_timing.redirect_end = base::TimeTicks::Now();\n  commit_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  commit_params_.redirect_response.push_back(response->head);\n  commit_params_.redirect_infos.push_back(redirect_info);\n\n  if (commit_params_.origin_to_commit)\n    commit_params_.origin_to_commit.reset();\n\n  commit_params_.redirects.push_back(common_params_.url);\n  common_params_.url = redirect_info.new_url;\n  common_params_.method = redirect_info.new_method;\n  common_params_.referrer.url = GURL(redirect_info.new_referrer);\n  common_params_.referrer =\n      Referrer::SanitizeForRequest(common_params_.url, common_params_.referrer);\n\n  net::Error net_error =\n      CheckContentSecurityPolicy(true \n,\n                                 redirect_info.insecure_scheme_was_upgraded,\n                                 false \n);\n  if (net_error != net::OK) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net_error), false \n,\n        base::nullopt \n);\n\n    return;\n  }\n\n  if (CheckCredentialedSubresource() ==\n          CredentialedSubresourceCheckResult::BLOCK_REQUEST ||\n      CheckLegacyProtocolInSubresource() ==\n          LegacyProtocolInSubresourceCheckResult::BLOCK_REQUEST) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net::ERR_ABORTED),\n        false \n,\n        false \n);\n\n    return;\n  }\n\n  scoped_refptr<SiteInstance> site_instance =\n      frame_tree_node_->render_manager()->GetSiteInstanceForNavigationRequest(\n          *this);\n  speculative_site_instance_ =\n      site_instance->HasProcess() ? site_instance : nullptr;\n\n  if (!site_instance->HasProcess()) {\n    RenderProcessHostImpl::NotifySpareManagerAboutRecentlyUsedBrowserContext(\n        site_instance->GetBrowserContext());\n  }\n\n  common_params_.previews_state =\n      GetContentClient()->browser()->DetermineAllowedPreviews(\n          common_params_.previews_state, navigation_handle_.get(),\n          common_params_.url);\n\n  RenderProcessHost* expected_process =\n      site_instance->HasProcess() ? site_instance->GetProcess() : nullptr;\n\n  navigation_handle_->WillRedirectRequest(\n      common_params_.referrer.url, expected_process,\n      base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                 base::Unretained(this)));\n}\n", "target": 1, "flaw_line_index": "47,48,61,62"}
{"idx": 7587, "func": "static void cirrus_linear_write(void *opaque, hwaddr addr,\n                                uint64_t val, unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    unsigned mode;\n\n    addr &= s->cirrus_addr_mask;\n\n    if (((s->vga.sr[0x17] & 0x44) == 0x44) &&\n        ((addr & s->linear_mmio_mask) ==  s->linear_mmio_mask)) {\n\tcirrus_mmio_blt_write(s, addr & 0xff, val);\n    } else if (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n\t*s->cirrus_srcptr++ = (uint8_t) val;\n\tif (s->cirrus_srcptr >= s->cirrus_srcptr_end) {\n\t    cirrus_bitblt_cputovideo_next(s);\n\t}\n    } else {\n\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\t    addr <<= 4;\n\t} else if (s->vga.gr[0x0B] & 0x02) {\n\t    addr <<= 3;\n\t}\n\taddr &= s->cirrus_addr_mask;\n\n\tmode = s->vga.gr[0x05] & 0x7;\n\tif (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {\n\t    *(s->vga.vram_ptr + addr) = (uint8_t) val;\n            memory_region_set_dirty(&s->vga.vram, addr, 1);\n\t} else {\n\t    if ((s->vga.gr[0x0B] & 0x14) != 0x14) {\n\t\tcirrus_mem_writeb_mode4and5_8bpp(s, mode, addr, val);\n\t    } else {\n\t\tcirrus_mem_writeb_mode4and5_16bpp(s, mode, addr, val);\n\t    }\n\t}\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8261, "func": "XRecordCreateContext(Display *dpy, int datum_flags,\n\t\t     XRecordClientSpec *clients, int nclients,\n\t\t     XRecordRange **ranges, int nranges)\n{\n    XExtDisplayInfo \t*info = find_display (dpy);\n    register xRecordCreateContextReq \t*req;\n    int\t\t\tclen = 4 * nclients;\n\n    XRecordCheckExtension (dpy, info, 0);\n    LockDisplay(dpy);\n    GetReq(RecordCreateContext, req);\n\n    req->reqType = info->codes->major_opcode;\n    req->recordReqType = X_RecordCreateContext;\n    req->context = XAllocID(dpy);\n    req->length += (nclients * 4 +\n\t\t    nranges * SIZEOF(xRecordRange)) >> 2;\n    req->elementHeader = datum_flags;\n    req->nClients = nclients;\n    req->nRanges = nranges;\n\n    Data32(dpy, (long *)clients, clen);\n    SendRange(dpy, ranges, nranges);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return req->context;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186959, "func": "void AppCacheDatabase::ReadCacheRecord(\n    const sql::Statement& statement, CacheRecord* record) {\n  record->cache_id = statement.ColumnInt64(0);\n  record->group_id = statement.ColumnInt64(1);\n  record->online_wildcard = statement.ColumnBool(2);\n   record->update_time =\n       base::Time::FromInternalValue(statement.ColumnInt64(3));\n   record->cache_size = statement.ColumnInt64(4);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186493, "func": "void GM2TabStyle::PaintTab(gfx::Canvas* canvas, const SkPath& clip) const {\n  int active_tab_fill_id = 0;\n  int active_tab_y_inset = 0;\n  if (tab_->GetThemeProvider()->HasCustomImage(IDR_THEME_TOOLBAR)) {\n    active_tab_fill_id = IDR_THEME_TOOLBAR;\n    active_tab_y_inset = GetStrokeThickness(true);\n   }\n \n   if (tab_->IsActive()) {\n    PaintTabBackground(canvas, true \n, active_tab_fill_id,\n                        active_tab_y_inset, nullptr \n);\n   } else {\n     PaintInactiveTabBackground(canvas, clip);\n\n    const float throb_value = GetThrobValue();\n     if (throb_value > 0) {\n       canvas->SaveLayerAlpha(gfx::ToRoundedInt(throb_value * 0xff),\n                              tab_->GetLocalBounds());\n      PaintTabBackground(canvas, true \n, active_tab_fill_id,\n                          active_tab_y_inset, nullptr \n);\n       canvas->Restore();\n     }\n  }\n}\n", "target": 1, "flaw_line_index": "11,22"}
{"idx": 186738, "func": " void NetworkHandler::SetCookies(\n     std::unique_ptr<protocol::Array<Network::CookieParam>> cookies,\n     std::unique_ptr<SetCookiesCallback> callback) {\n  if (!process_) {\n     callback->sendFailure(Response::InternalError());\n     return;\n   }\n\n  BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(\n           &SetCookiesOnIO,\n          base::Unretained(\n              process_->GetStoragePartition()->GetURLRequestContext()),\n           std::move(cookies),\n           base::BindOnce(&CookiesSetOnIO, std::move(callback))));\n }\n", "target": 1, "flaw_line_index": "4,13,14"}
{"idx": 186643, "func": "bool DownloadItemImpl::CanOpenDownload() {\n   const bool is_complete = GetState() == DownloadItem::COMPLETE;\n   return (!IsDone() || is_complete) && !IsTemporary() &&\n         !file_externally_removed_;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187310, "func": " exsltCryptoRc4EncryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n \n    int key_len = 0, key_size = 0;\n     int str_len = 0, bin_len = 0, hex_len = 0;\n     xmlChar *key = NULL, *str = NULL, *padkey = NULL;\n     xmlChar *bin = NULL, *hex = NULL;\n    xsltTransformContextPtr tctxt = NULL;\n\n    if (nargs != 2) {\n\txmlXPathSetArityError (ctxt);\n\treturn;\n    }\n     tctxt = xsltXPathGetTransformContext(ctxt);\n \n     str = xmlXPathPopString (ctxt);\n    str_len = xmlUTF8Strlen (str);\n \n     if (str_len == 0) {\n \txmlXPathReturnEmptyString (ctxt);\n\txmlFree (str);\n\treturn;\n     }\n \n     key = xmlXPathPopString (ctxt);\n    key_len = xmlUTF8Strlen (key);\n \n     if (key_len == 0) {\n \txmlXPathReturnEmptyString (ctxt);\n\txmlFree (key);\n\txmlFree (str);\n\treturn;\n    }\n\n    padkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);\n    if (padkey == NULL) {\n\txsltTransformError(tctxt, NULL, tctxt->inst,\n\t    \"exsltCryptoRc4EncryptFunction: Failed to allocate padkey\\n\");\n\ttctxt->state = XSLT_STATE_STOPPED;\n\txmlXPathReturnEmptyString (ctxt);\n\tgoto done;\n     }\n     memset(padkey, 0, RC4_KEY_LENGTH + 1);\n \n    key_size = xmlUTF8Strsize (key, key_len);\n    if ((key_size > RC4_KEY_LENGTH) || (key_size < 0)) {\n \txsltTransformError(tctxt, NULL, tctxt->inst,\n \t    \"exsltCryptoRc4EncryptFunction: key size too long or key broken\\n\");\n \ttctxt->state = XSLT_STATE_STOPPED;\n \txmlXPathReturnEmptyString (ctxt);\n \tgoto done;\n     }\n    memcpy (padkey, key, key_size);\n \n     bin_len = str_len;\n    bin = xmlStrdup (str);\n    if (bin == NULL) {\n\txsltTransformError(tctxt, NULL, tctxt->inst,\n\t    \"exsltCryptoRc4EncryptFunction: Failed to allocate string\\n\");\n\ttctxt->state = XSLT_STATE_STOPPED;\n\txmlXPathReturnEmptyString (ctxt);\n\tgoto done;\n    }\n    PLATFORM_RC4_ENCRYPT (ctxt, padkey, str, str_len, bin, bin_len);\n\n    hex_len = str_len * 2 + 1;\n    hex = xmlMallocAtomic (hex_len);\n    if (hex == NULL) {\n\txsltTransformError(tctxt, NULL, tctxt->inst,\n\t    \"exsltCryptoRc4EncryptFunction: Failed to allocate result\\n\");\n\ttctxt->state = XSLT_STATE_STOPPED;\n\txmlXPathReturnEmptyString (ctxt);\n\tgoto done;\n    }\n\n    exsltCryptoBin2Hex (bin, str_len, hex, hex_len);\n    xmlXPathReturnString (ctxt, hex);\n\ndone:\n    if (key != NULL)\n\txmlFree (key);\n    if (str != NULL)\n\txmlFree (str);\n    if (padkey != NULL)\n\txmlFree (padkey);\n    if (bin != NULL)\n\txmlFree (bin);\n}\n", "target": 1, "flaw_line_index": "3,16,25,44,45,52"}
{"idx": 8213, "func": "static int v9fs_do_readdir(V9fsPDU *pdu,\n                           V9fsFidState *fidp, int32_t max_count)\n{\n    size_t size;\n    V9fsQID qid;\n    V9fsString name;\n    int len, err = 0;\n    int32_t count = 0;\n    off_t saved_dir_pos;\n    struct dirent *dent;\n\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n    if (saved_dir_pos < 0) {\n        return saved_dir_pos;\n    }\n\n    while (1) {\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n        if (err || !dent) {\n            break;\n        }\n        v9fs_string_init(&name);\n        v9fs_string_sprintf(&name, \"%s\", dent->d_name);\n        if ((count + v9fs_readdir_data_size(&name)) > max_count) {\n            v9fs_readdir_unlock(&fidp->fs.dir);\n\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_string_free(&name);\n            return count;\n        }\n        size = MIN(sizeof(dent->d_ino), sizeof(qid.path));\n        memcpy(&qid.path, &dent->d_ino, size);\n        qid.type = 0;\n        qid.version = 0;\n\n        len = pdu_marshal(pdu, 11 + count, \"Qqbs\",\n                          &qid, dent->d_off,\n                          dent->d_type, &name);\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n        if (len < 0) {\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_string_free(&name);\n            return len;\n        }\n        count += len;\n        v9fs_string_free(&name);\n        saved_dir_pos = dent->d_off;\n    }\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n    if (err < 0) {\n        return err;\n    }\n    return count;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187154, "func": "int ScrollableShelfView::CalculateScrollUpperBound() const {\n  if (layout_strategy_ == kNotShowArrowButtons)\n     return 0;\n \n  int available_length = space_for_icons_ - 2 * GetAppIconEndPadding();\n \n   const gfx::Size shelf_preferred_size(\n      shelf_container_view_->GetPreferredSize());\n  const int preferred_length =\n      (GetShelf()->IsHorizontalAlignment() ? shelf_preferred_size.width()\n                                           : shelf_preferred_size.height());\n\n  return std::max(0, preferred_length - available_length);\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8037, "func": "static void vnc_rect_updated(VncDisplay *vd, int x, int y, struct timeval * tv)\n{\n    VncRectStat *rect;\n\n    rect = vnc_stat_rect(vd, x, y);\n    if (rect->updated) {\n        return ;\n    }\n    rect->times[rect->idx] = *tv;\n    rect->idx = (rect->idx + 1) % ARRAY_SIZE(rect->times);\n    rect->updated = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7797, "func": "static int h2c_handle_ping(struct h2c *h2c)\n{\n\tif (h2c->dfl != 8) {\n\t\th2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n\t\treturn 0;\n\t}\n\n\tif (!(h2c->dff & H2_F_PING_ACK))\n\t\th2c->st0 = H2_CS_FRAME_A;\n\treturn 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7672, "func": "static ssize_t handle_lgetxattr(FsContext *ctx, V9fsPath *fs_path,\n                                const char *name, void *value, size_t size)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fgetxattr(fd, name, value, size);\n    close(fd);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7639, "func": "static int proxy_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    if (dir_path) {\n        v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n        v9fs_path_sprintf(target, \"%s\", name);\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7762, "func": "static inline struct buffer *h2_get_buf(struct h2c *h2c, struct buffer **bptr)\n{\n\tstruct buffer *buf = NULL;\n\n\tif (likely(LIST_ISEMPTY(&h2c->buf_wait.list)) &&\n\t    unlikely((buf = b_alloc_margin(bptr, 0)) == NULL)) {\n\t\th2c->buf_wait.target = h2c;\n\t\th2c->buf_wait.wakeup_cb = h2_buf_available;\n\t\tHA_SPIN_LOCK(BUF_WQ_LOCK, &buffer_wq_lock);\n\t\tLIST_ADDQ(&buffer_wq, &h2c->buf_wait.list);\n\t\tHA_SPIN_UNLOCK(BUF_WQ_LOCK, &buffer_wq_lock);\n\t\t__conn_xprt_stop_recv(h2c->conn);\n\t}\n\treturn buf;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187239, "func": "static void windows_clear_transfer_priv(struct usbi_transfer *itransfer)\n{\n \tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n \n \tusbi_free_fd(&transfer_priv->pollable_fd);\n\tsafe_free(transfer_priv->hid_buffer);\n \tauto_release(itransfer);\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 186613, "func": " base::string16 GetAppForProtocolUsingRegistry(const GURL& url) {\n  base::string16 command_to_launch;\n \n  base::string16 cmd_key_path = base::ASCIIToUTF16(url.scheme());\n  base::win::RegKey cmd_key_name(HKEY_CLASSES_ROOT, cmd_key_path.c_str(),\n                                  KEY_READ);\n   if (cmd_key_name.ReadValue(NULL, &command_to_launch) == ERROR_SUCCESS &&\n       !command_to_launch.empty()) {\n    return command_to_launch;\n  }\n \n  cmd_key_path = base::ASCIIToUTF16(url.scheme() + \"\\\\shell\\\\open\\\\command\");\n   base::win::RegKey cmd_key_exe(HKEY_CLASSES_ROOT, cmd_key_path.c_str(),\n                                 KEY_READ);\n   if (cmd_key_exe.ReadValue(NULL, &command_to_launch) == ERROR_SUCCESS) {\n    base::CommandLine command_line(\n        base::CommandLine::FromString(command_to_launch));\n    return command_line.GetProgram().BaseName().value();\n  }\n\n  return base::string16();\n}\n", "target": 1, "flaw_line_index": "2,5,6,15"}
{"idx": 186513, "func": "bool NavigatorImpl::NavigateToEntry(\n    FrameTreeNode* frame_tree_node,\n    const FrameNavigationEntry& frame_entry,\n    const NavigationEntryImpl& entry,\n    ReloadType reload_type,\n    bool is_same_document_history_load,\n    bool is_history_navigation_in_new_child,\n    bool is_pending_entry,\n    const scoped_refptr<ResourceRequestBodyImpl>& post_body) {\n  TRACE_EVENT0(\"browser,navigation\", \"NavigatorImpl::NavigateToEntry\");\n\n  GURL dest_url = frame_entry.url();\n  Referrer dest_referrer = frame_entry.referrer();\n  if (reload_type == ReloadType::ORIGINAL_REQUEST_URL &&\n      entry.GetOriginalRequestURL().is_valid() && !entry.GetHasPostData()) {\n    dest_url = entry.GetOriginalRequestURL();\n     dest_referrer = Referrer();\n   }\n \n   if (!dest_url.is_valid() && !dest_url.is_empty()) {\n     LOG(WARNING) << \"Refusing to load invalid URL: \"\n                 << dest_url.possibly_invalid_spec();\n    return false;\n  }\n\n  if (dest_url.spec().size() > url::kMaxURLChars) {\n    LOG(WARNING) << \"Refusing to load URL as it exceeds \" << url::kMaxURLChars\n                 << \" characters.\";\n    return false;\n  }\n\n  base::TimeTicks navigation_start = base::TimeTicks::Now();\n  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(\n      \"navigation,rail\", \"NavigationTiming navigationStart\",\n      TRACE_EVENT_SCOPE_GLOBAL, navigation_start);\n\n  LoFiState lofi_state = LOFI_UNSPECIFIED;\n  if (!frame_tree_node->IsMainFrame()) {\n    lofi_state = frame_tree_node->frame_tree()\n                     ->root()\n                     ->current_frame_host()\n                     ->last_navigation_lofi_state();\n  } else if (reload_type == ReloadType::DISABLE_LOFI_MODE) {\n    lofi_state = LOFI_OFF;\n  }\n\n  if (IsBrowserSideNavigationEnabled()) {\n    navigation_data_.reset(new NavigationMetricsData(navigation_start, dest_url,\n                                                     entry.restore_type()));\n    RequestNavigation(frame_tree_node, dest_url, dest_referrer, frame_entry,\n                      entry, reload_type, lofi_state,\n                      is_same_document_history_load,\n                      is_history_navigation_in_new_child, navigation_start);\n    if (frame_tree_node->IsMainFrame() &&\n        frame_tree_node->navigation_request()) {\n      TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1(\n          \"navigation\", \"Navigation timeToNetworkStack\",\n          frame_tree_node->navigation_request()->navigation_handle(),\n          navigation_start,\n          \"FrameTreeNode id\", frame_tree_node->frame_tree_node_id());\n    }\n\n  } else {\n    RenderFrameHostImpl* dest_render_frame_host =\n        frame_tree_node->render_manager()->Navigate(\n            dest_url, frame_entry, entry, reload_type != ReloadType::NONE);\n    if (!dest_render_frame_host)\n      return false;  \n\n    if (is_pending_entry)\n      CHECK_EQ(controller_->GetPendingEntry(), &entry);\n\n    CheckWebUIRendererDoesNotDisplayNormalURL(dest_render_frame_host, dest_url);\n\n    bool is_transfer = entry.transferred_global_request_id().child_id != -1;\n    if (is_transfer)\n      dest_render_frame_host->set_is_loading(true);\n\n    if (is_pending_entry && controller_->GetPendingEntryIndex() != -1)\n      DCHECK(frame_entry.page_state().IsValid());\n\n    bool is_transfer_to_same =\n        is_transfer &&\n        entry.transferred_global_request_id().child_id ==\n            dest_render_frame_host->GetProcess()->GetID();\n    if (!is_transfer_to_same) {\n      navigation_data_.reset(new NavigationMetricsData(\n          navigation_start, dest_url, entry.restore_type()));\n      FrameMsg_Navigate_Type::Value navigation_type = GetNavigationType(\n          controller_->GetBrowserContext(), entry, reload_type);\n      dest_render_frame_host->Navigate(\n          entry.ConstructCommonNavigationParams(\n              frame_entry, post_body, dest_url, dest_referrer, navigation_type,\n              lofi_state, navigation_start),\n          entry.ConstructStartNavigationParams(),\n          entry.ConstructRequestNavigationParams(\n              frame_entry, is_same_document_history_load,\n              is_history_navigation_in_new_child,\n              entry.GetSubframeUniqueNames(frame_tree_node),\n              frame_tree_node->has_committed_real_load(),\n              controller_->GetPendingEntryIndex() == -1,\n              controller_->GetIndexOfEntry(&entry),\n              controller_->GetLastCommittedEntryIndex(),\n              controller_->GetEntryCount()));\n    }\n  }\n\n  if (is_pending_entry)\n    CHECK_EQ(controller_->GetPendingEntry(), &entry);\n\n  if (controller_->GetPendingEntryIndex() == -1 &&\n      dest_url.SchemeIs(url::kJavaScriptScheme)) {\n    return false;\n  }\n\n  if (delegate_ && is_pending_entry)\n    delegate_->DidStartNavigationToPendingEntry(dest_url, reload_type);\n\n  return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186623, "func": "InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {\n   if (!profile)\n     return nullptr;\n   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(\n      profile->GetOriginalProfile());\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 186882, "func": "void BaseRenderingContext2D::ClearResolvedFilters() {\n   for (auto& state : state_stack_)\n     state->ClearResolvedFilter();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8061, "func": "char *FoFiType1::getName() {\n  if (!parsed) {\n    parse();\n  }\n  return name;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187059, "func": "   void ProcessStateChangesUnifiedPlan(\n       WebRtcSetDescriptionObserver::States states) {\n     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kUnifiedPlan);\n    handler_->OnModifyTransceivers(\n        std::move(states.transceiver_states),\n        action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);\n   }\n", "target": 1, "flaw_line_index": "4,5,6"}
{"idx": 7432, "func": "ZEND_API int zend_ts_hash_sort(TsHashTable *ht, sort_func_t sort_func, compare_func_t compare_func, int renumber)\n{\n\tint retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_sort(TS_HASH(ht), sort_func, compare_func, renumber);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7684, "func": " static int handle_parse_opts(QemuOpts *opts, struct FsDriverEntry *fse)\n {\n     const char *sec_model = qemu_opt_get(opts, \"security_model\");\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8046, "func": "static VncServerInfo *vnc_server_info_get(void)\n{\n    VncServerInfo *info;\n    VncBasicInfo *bi = vnc_basic_info_get_from_server_addr(vnc_display->lsock);\n    if (!bi) {\n        return NULL;\n    }\n\n    info = g_malloc(sizeof(*info));\n    info->base = bi;\n    info->has_auth = true;\n    info->auth = g_strdup(vnc_auth_name(vnc_display));\n    return info;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7411, "func": "ZEND_API zval *zend_ts_hash_add_empty_element(TsHashTable *ht, zend_string *key)\n{\n\tzval *retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_add_empty_element(TS_HASH(ht), key);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8121, "func": "void Gfx::opEndIgnoreUndef(Object args[], int numArgs) {\n  if (ignoreUndef > 0)\n    --ignoreUndef;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186369, "func": " void TabletModeWindowManager::Init() {\n\n  {\n    ScopedObserveWindowAnimation scoped_observe(GetTopWindow(), this,\nfalse);\n    ArrangeWindowsForTabletMode();\n  }\n  AddWindowCreationObservers();\n  display::Screen::GetScreen()->AddObserver(this);\n  Shell::Get()->AddShellObserver(this);\n  Shell::Get()->session_controller()->AddObserver(this);\n  Shell::Get()->overview_controller()->AddObserver(this);\n  accounts_since_entering_tablet_.insert(\n      Shell::Get()->session_controller()->GetActiveAccountId());\n  event_handler_ = std::make_unique<wm::TabletModeEventHandler>();\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186538, "func": " void Compositor::OnFirstSurfaceActivation(\n     const viz::SurfaceInfo& surface_info) {\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8253, "func": "Status _xvmc_create_context (\n    Display *dpy,\n    XvMCContext *context,\n    int *priv_count,\n    CARD32 **priv_data\n)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcCreateContextReply rep;\n    xvmcCreateContextReq  *req;\n\n    *priv_count = 0;\n    *priv_data = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (CreateContext, req);\n    context->context_id = XAllocID(dpy);\n    req->context_id = context->context_id;\n    req->port = context->port;\n    req->surface_type_id = context->surface_type_id;\n    req->width = context->width;\n    req->height = context->height;\n    req->flags = context->flags;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n        return BadImplementation;\n    }\n    context->width = rep.width_actual;\n    context->height = rep.height_actual;\n    context->flags = rep.flags_return;\n\n    if(rep.length) {\n\tif (rep.length < (INT_MAX >> 2))\n\t    *priv_data = Xmalloc(rep.length << 2);\n\tif(*priv_data) {\n            _XRead(dpy, (char*)(*priv_data), rep.length << 2);\n\t    *priv_count = rep.length;\n\t} else\n\t    _XEatDataWords(dpy, rep.length);\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return Success;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186845, "func": "CommandBufferProxyImpl::AllocateAndMapSharedMemory(size_t size) {\n  mojo::ScopedSharedBufferHandle handle =\n      mojo::SharedBufferHandle::Create(size);\n  if (!handle.is_valid()) {\n    DLOG(ERROR) << \"AllocateAndMapSharedMemory: Create failed\";\n    return nullptr;\n  }\n \n   base::SharedMemoryHandle platform_handle;\n   size_t shared_memory_size;\n  bool readonly;\n   MojoResult result = mojo::UnwrapSharedMemoryHandle(\n      std::move(handle), &platform_handle, &shared_memory_size, &readonly);\n   if (result != MOJO_RESULT_OK) {\n     DLOG(ERROR) << \"AllocateAndMapSharedMemory: Unwrap failed\";\n     return nullptr;\n   }\n   DCHECK_EQ(shared_memory_size, size);\n \n  auto shm = std::make_unique<base::SharedMemory>(platform_handle, readonly);\n   if (!shm->Map(size)) {\n     DLOG(ERROR) << \"AllocateAndMapSharedMemory: Map failed\";\n     return nullptr;\n  }\n\n  return shm;\n}\n", "target": 1, "flaw_line_index": "11,13,20"}
{"idx": 7799, "func": "static int h2c_handle_rst_stream(struct h2c *h2c, struct h2s *h2s)\n{\n\tint error;\n\n\tif (h2c->dsi == 0) {\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->dfl != 4) {\n\t\terror = H2_ERR_FRAME_SIZE_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->dbuf->i < h2c->dfl)\n\t\treturn 0;\n\n\tif (h2s->st == H2_SS_CLOSED)\n\t\treturn 1;\n\n\th2s->errcode = h2_get_n32(h2c->dbuf, 0);\n\th2s_close(h2s);\n\n\tif (h2s->cs) {\n\t\th2s->cs->flags |= CS_FL_EOS | CS_FL_ERROR;\n\t\th2s->cs->data_cb->recv(h2s->cs);\n\t\th2s->cs->data_cb->wake(h2s->cs);\n\t}\n\n\th2s->flags |= H2_SF_RST_RCVD;\n\treturn 1;\n\n conn_err:\n\th2c_error(h2c, error);\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7546, "func": "tm_diff (struct tm const *a, struct tm const *b)\n{\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7929, "func": "static void emitlocal(JF, int oploc, int opvar, js_Ast *ident)\n{\n\tint i;\n\tif (J->strict && oploc == OP_SETLOCAL) {\n\t\tif (!strcmp(ident->string, \"arguments\"))\n\t\t\tjsC_error(J, ident, \"'arguments' is read-only in strict mode\");\n\t\tif (!strcmp(ident->string, \"eval\"))\n\t\t\tjsC_error(J, ident, \"'eval' is read-only in strict mode\");\n\t}\n\tif (F->lightweight) {\n\t\ti = findlocal(J, F, ident->string);\n\t\tif (i >= 0) {\n\t\t\temit(J, F, oploc);\n\t\t\temitraw(J, F, i);\n\t\t\treturn;\n\t\t}\n\t}\n\temitstring(J, F, opvar, ident->string);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186705, "func": " bool IDNToUnicodeOneComponent(const base::char16* comp,\n                               size_t comp_len,\n                              bool is_tld_ascii,\n                               bool enable_spoof_checks,\n                               base::string16* out,\n                               bool* has_idn_component) {\n  DCHECK(out);\n  DCHECK(has_idn_component);\n  *has_idn_component = false;\n  if (comp_len == 0)\n    return false;\n\n  static const base::char16 kIdnPrefix[] = {'x', 'n', '-', '-'};\n  if (comp_len <= base::size(kIdnPrefix) ||\n      memcmp(comp, kIdnPrefix, sizeof(kIdnPrefix)) != 0) {\n    out->append(comp, comp_len);\n    return false;\n  }\n\n  UIDNA* uidna = g_uidna.Get().value;\n  DCHECK(uidna != nullptr);\n  size_t original_length = out->length();\n  int32_t output_length = 64;\n  UIDNAInfo info = UIDNA_INFO_INITIALIZER;\n  UErrorCode status;\n  do {\n    out->resize(original_length + output_length);\n    status = U_ZERO_ERROR;\n    output_length = uidna_labelToUnicode(\n        uidna, comp, static_cast<int32_t>(comp_len), &(*out)[original_length],\n        output_length, &info, &status);\n  } while ((status == U_BUFFER_OVERFLOW_ERROR && info.errors == 0));\n\n  if (U_SUCCESS(status) && info.errors == 0) {\n    *has_idn_component = true;\n    out->resize(original_length + output_length);\n    if (!enable_spoof_checks) {\n      return true;\n    }\n     if (IsIDNComponentSafe(\n             base::StringPiece16(out->data() + original_length,\n                                 base::checked_cast<size_t>(output_length)),\n            is_tld_ascii)) {\n       return true;\n     }\n   }\n\n  out->resize(original_length);\n  out->append(comp, comp_len);\n  return false;\n}\n", "target": 1, "flaw_line_index": "3,49"}
{"idx": 186795, "func": " void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n", "target": 1, "flaw_line_index": "3,7"}
{"idx": 187015, "func": "ChromeContentBrowserClient::CreateThrottlesForNavigation(\n    content::NavigationHandle* handle) {\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n\n  if (handle->IsInMainFrame()) {\n    throttles.push_back(\n        page_load_metrics::MetricsNavigationThrottle::Create(handle));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  std::unique_ptr<content::NavigationThrottle> flash_url_throttle =\n      FlashDownloadInterception::MaybeCreateThrottleFor(handle);\n  if (flash_url_throttle)\n    throttles.push_back(std::move(flash_url_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_throttle =\n      SupervisedUserNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (supervised_user_throttle)\n    throttles.push_back(std::move(supervised_user_throttle));\n#endif\n\n#if defined(OS_ANDROID)\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(handle->GetWebContents());\n  if (!prerender_contents && handle->IsInMainFrame()) {\n    throttles.push_back(\n        navigation_interception::InterceptNavigationDelegate::CreateThrottleFor(\n            handle));\n  }\n  throttles.push_back(InterceptOMADownloadNavigationThrottle::Create(handle));\n#elif BUILDFLAG(ENABLE_EXTENSIONS)\n  if (handle->IsInMainFrame()) {\n    auto url_to_app_throttle =\n        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);\n    if (url_to_app_throttle)\n      throttles.push_back(std::move(url_to_app_throttle));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {\n    if (base::FeatureList::IsEnabled(features::kDesktopPWAsLinkCapturing)) {\n      auto bookmark_app_experimental_throttle =\n          extensions::BookmarkAppExperimentalNavigationThrottle::\n              MaybeCreateThrottleFor(handle);\n      if (bookmark_app_experimental_throttle)\n        throttles.push_back(std::move(bookmark_app_experimental_throttle));\n    } else if (!base::FeatureList::IsEnabled(\n                   features::kDesktopPWAsStayInWindow)) {\n      auto bookmark_app_throttle =\n          extensions::BookmarkAppNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n      if (bookmark_app_throttle)\n        throttles.push_back(std::move(bookmark_app_throttle));\n    }\n  }\n   if (base::FeatureList::IsEnabled(\n           features::kMimeHandlerViewInCrossProcessFrame)) {\n     auto plugin_frame_attach_throttle =\n        extensions::ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\n            handle);\n     if (plugin_frame_attach_throttle)\n       throttles.push_back(std::move(plugin_frame_attach_throttle));\n   }\n#endif\n\n#if defined(OS_CHROMEOS)\n  if (handle->IsInMainFrame()) {\n    if (merge_session_throttling_utils::ShouldAttachNavigationThrottle() &&\n        !merge_session_throttling_utils::AreAllSessionMergedAlready() &&\n        handle->GetURL().SchemeIsHTTPOrHTTPS()) {\n      throttles.push_back(MergeSessionNavigationThrottle::Create(handle));\n    }\n\n    auto url_to_apps_throttle =\n        chromeos::AppsNavigationThrottle::MaybeCreate(handle);\n    if (url_to_apps_throttle)\n      throttles.push_back(std::move(url_to_apps_throttle));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  throttles.push_back(\n      std::make_unique<extensions::ExtensionNavigationThrottle>(handle));\n\n  std::unique_ptr<content::NavigationThrottle> user_script_throttle =\n      extensions::ExtensionsBrowserClient::Get()\n          ->GetUserScriptListener()\n          ->CreateNavigationThrottle(handle);\n  if (user_script_throttle)\n    throttles.push_back(std::move(user_script_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_nav_throttle =\n      SupervisedUserGoogleAuthNavigationThrottle::MaybeCreate(handle);\n  if (supervised_user_nav_throttle)\n    throttles.push_back(std::move(supervised_user_nav_throttle));\n#endif\n\n  content::WebContents* web_contents = handle->GetWebContents();\n  if (auto* subresource_filter_client =\n          ChromeSubresourceFilterClient::FromWebContents(web_contents)) {\n    subresource_filter_client->MaybeAppendNavigationThrottles(handle,\n                                                              &throttles);\n  }\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle>\n      background_tab_navigation_throttle = resource_coordinator::\n          BackgroundTabNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (background_tab_navigation_throttle)\n    throttles.push_back(std::move(background_tab_navigation_throttle));\n#endif\n\n#if defined(SAFE_BROWSING_DB_LOCAL)\n  std::unique_ptr<content::NavigationThrottle>\n      password_protection_navigation_throttle =\n          safe_browsing::MaybeCreateNavigationThrottle(handle);\n  if (password_protection_navigation_throttle) {\n    throttles.push_back(std::move(password_protection_navigation_throttle));\n  }\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> pdf_iframe_throttle =\n      PDFIFrameNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (pdf_iframe_throttle)\n    throttles.push_back(std::move(pdf_iframe_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> tab_under_throttle =\n      TabUnderNavigationThrottle::MaybeCreate(handle);\n  if (tab_under_throttle)\n    throttles.push_back(std::move(tab_under_throttle));\n\n  throttles.push_back(std::make_unique<PolicyBlacklistNavigationThrottle>(\n      handle, handle->GetWebContents()->GetBrowserContext()));\n\n  if (base::FeatureList::IsEnabled(features::kSSLCommittedInterstitials)) {\n    throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(\n        handle,\n        std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n        base::Bind(&SSLErrorHandler::HandleSSLError)));\n  }\n\n  std::unique_ptr<content::NavigationThrottle> https_upgrade_timing_throttle =\n      TypedNavigationTimingThrottle::MaybeCreateThrottleFor(handle);\n  if (https_upgrade_timing_throttle)\n    throttles.push_back(std::move(https_upgrade_timing_throttle));\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle> devtools_throttle =\n      DevToolsWindow::MaybeCreateNavigationThrottle(handle);\n  if (devtools_throttle)\n    throttles.push_back(std::move(devtools_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> new_tab_page_throttle =\n      NewTabPageNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (new_tab_page_throttle)\n    throttles.push_back(std::move(new_tab_page_throttle));\n\n  std::unique_ptr<content::NavigationThrottle>\n      google_password_manager_throttle =\n          GooglePasswordManagerNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n  if (google_password_manager_throttle)\n    throttles.push_back(std::move(google_password_manager_throttle));\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> previews_lite_page_throttle =\n      PreviewsLitePageDecider::MaybeCreateThrottleFor(handle);\n  if (previews_lite_page_throttle)\n    throttles.push_back(std::move(previews_lite_page_throttle));\n  if (base::FeatureList::IsEnabled(safe_browsing::kCommittedSBInterstitials)) {\n    throttles.push_back(\n        std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(\n            handle));\n  }\n\n#if defined(OS_WIN) || defined(OS_MACOSX) || \\\n    (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n  std::unique_ptr<content::NavigationThrottle> browser_switcher_throttle =\n      browser_switcher::BrowserSwitcherNavigationThrottle ::\n          MaybeCreateThrottleFor(handle);\n  if (browser_switcher_throttle)\n    throttles.push_back(std::move(browser_switcher_throttle));\n#endif\n\n  return throttles;\n}\n", "target": 1, "flaw_line_index": "72,73"}
{"idx": 186642, "func": "bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n  DCHECK(!defer_page_unload_);\n  defer_page_unload_ = true;\n  bool rv = false;\n  switch (event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      rv = OnMouseDown(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      rv = OnMouseUp(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      rv = OnMouseMove(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n      rv = OnKeyDown(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      rv = OnKeyUp(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      rv = OnChar(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHSTART: {\n      KillTouchTimer(next_touch_timer_id_);\n\n      pp::TouchInputEvent touch_event(event);\n      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)\n        ScheduleTouchTimer(touch_event);\n      break;\n    }\n    case PP_INPUTEVENT_TYPE_TOUCHEND:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHMOVE:\n      KillTouchTimer(next_touch_timer_id_);\n    default:\n      break;\n  }\n \n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n  for (int page_index : deferred_page_unloads_)\n     pages_[page_index]->Unload();\n  deferred_page_unloads_.clear();\n   return rv;\n }\n", "target": 1, "flaw_line_index": "45,47"}
{"idx": 7768, "func": "static int h2_parse_header_table_size(char **args, int section_type, struct proxy *curpx,\n                                      struct proxy *defpx, const char *file, int line,\n                                      char **err)\n{\n\tif (too_many_args(1, args, err, NULL))\n\t\treturn -1;\n\n\th2_settings_header_table_size = atoi(args[1]);\n\tif (h2_settings_header_table_size < 4096 || h2_settings_header_table_size > 65536) {\n\t\tmemprintf(err, \"'%s' expects a numeric value between 4096 and 65536.\", args[0]);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187170, "func": "void WebMediaPlayerImpl::OnError(PipelineStatus status) {\n  DVLOG(1) << __func__;\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n  DCHECK_NE(status, PIPELINE_OK);\n\n  if (suppress_destruction_errors_)\n    return;\n \n #if defined(OS_ANDROID)\n   if (status == PipelineStatus::DEMUXER_ERROR_DETECTED_HLS) {\n     renderer_factory_selector_->SetUseMediaPlayer(true);\n \n     pipeline_controller_.Stop();\n    SetMemoryReportingState(false);\n\n    main_task_runner_->PostTask(\n        FROM_HERE, base::Bind(&WebMediaPlayerImpl::StartPipeline, AsWeakPtr()));\n    return;\n  }\n#endif\n\n  ReportPipelineError(load_type_, status, media_log_.get());\n  media_log_->AddEvent(media_log_->CreatePipelineErrorEvent(status));\n  media_metrics_provider_->OnError(status);\n  if (watch_time_reporter_)\n    watch_time_reporter_->OnError(status);\n\n  if (ready_state_ == WebMediaPlayer::kReadyStateHaveNothing) {\n    SetNetworkState(WebMediaPlayer::kNetworkStateFormatError);\n  } else {\n    SetNetworkState(PipelineErrorToNetworkState(status));\n  }\n\n  pipeline_controller_.Stop();\n\n  UpdatePlayState();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 7742, "func": "static void coroutine_fn v9fs_xattrwalk(void *opaque)\n{\n    int64_t size;\n    V9fsString name;\n    ssize_t err = 0;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrwalk(pdu->tag, pdu->id, fid, newfid, name.data);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    xattr_fidp = alloc_fid(s, newfid);\n    if (xattr_fidp == NULL) {\n        err = -EINVAL;\n        goto out;\n    }\n    v9fs_path_copy(&xattr_fidp->path, &file_fidp->path);\n    if (!v9fs_string_size(&name)) {\n        size = v9fs_co_llistxattr(pdu, &xattr_fidp->path, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.xattrwalk_fid = true;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_llistxattr(pdu, &xattr_fidp->path,\n                                     xattr_fidp->fs.xattr.value,\n                                     xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        err = pdu_marshal(pdu, offset, \"q\", size);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    } else {\n        size = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                 &name, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.xattrwalk_fid = true;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                    &name, xattr_fidp->fs.xattr.value,\n                                    xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        err = pdu_marshal(pdu, offset, \"q\", size);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset;\n    }\n    trace_v9fs_xattrwalk_return(pdu->tag, pdu->id, size);\nout:\n    put_fid(pdu, file_fidp);\n    if (xattr_fidp) {\n        put_fid(pdu, xattr_fidp);\n    }\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8221, "func": "static void v9fs_lock(void *opaque)\n{\n    int8_t status;\n    V9fsFlock flock;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n\n    status = P9_LOCK_ERROR;\n    v9fs_string_init(&flock.client_id);\n    err = pdu_unmarshal(pdu, offset, \"dbdqqds\", &fid, &flock.type,\n                        &flock.flags, &flock.start, &flock.length,\n                        &flock.proc_id, &flock.client_id);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_lock(pdu->tag, pdu->id, fid,\n                    flock.type, flock.start, flock.length);\n\n\n    if (flock.flags & ~P9_LOCK_FLAGS_BLOCK) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    status = P9_LOCK_SUCCESS;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    err = pdu_marshal(pdu, offset, \"b\", status);\n    if (err > 0) {\n        err += offset;\n    }\n    trace_v9fs_lock_return(pdu->tag, pdu->id, status);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&flock.client_id);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187228, "func": "static int hid_copy_transfer_data(int sub_api, struct usbi_transfer *itransfer, uint32_t io_size) {\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);\n\tstruct windows_transfer_priv *transfer_priv = usbi_transfer_get_os_priv(itransfer);\n\tint r = LIBUSB_TRANSFER_COMPLETED;\n\tuint32_t corrected_size = io_size;\n\tif (transfer_priv->hid_buffer != NULL) {\n\t\tif (transfer_priv->hid_dest != NULL) {\t\n\t\t\tif (corrected_size > transfer_priv->hid_expected_size) {\n\t\t\t\tusbi_err(ctx, \"OVERFLOW!\");\n\t\t\t\tcorrected_size = (uint32_t)transfer_priv->hid_expected_size;\n\t\t\t\tr = LIBUSB_TRANSFER_OVERFLOW;\n\t\t\t}\n\t\t\tif (transfer_priv->hid_buffer[0] == 0) {\n\t\t\t\tcorrected_size--;\n\t\t\t\tmemcpy(transfer_priv->hid_dest, transfer_priv->hid_buffer+1, corrected_size);\n\t\t\t} else {\n\t\t\t\tmemcpy(transfer_priv->hid_dest, transfer_priv->hid_buffer, corrected_size);\n\t\t\t}\n\t\t\ttransfer_priv->hid_dest = NULL;\n\t\t}\n\t\tsafe_free(transfer_priv->hid_buffer);\n\t}\n\titransfer->transferred += corrected_size;\n\treturn r;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27"}
{"idx": 8306, "func": "XFixesCreateRegionFromWindow (Display *dpy, Window window, int kind)\n{\n    XFixesExtDisplayInfo\t\t*info = XFixesFindDisplay (dpy);\n    xXFixesCreateRegionFromWindowReq\t*req;\n    XserverRegion\t\t\tregion;\n\n    XFixesCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (XFixesCreateRegionFromWindow, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesCreateRegionFromWindow;\n    region = req->region = XAllocID (dpy);\n    req->window = window;\n    req->kind = kind;\n    UnlockDisplay (dpy);\n    SyncHandle();\n    return region;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7506, "func": "simple_signal (void)\n{\n  DBusMessage *message;\n  message = dbus_message_new_signal (\"/f/b\",\n                                     \"o.b.Z\",\n                                     \"Fro\");\n  if (message == NULL)\n    _dbus_assert_not_reached (\"oom\");\n  return message;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187268, "func": "void DevToolsAgentHostImpl::InnerAttachClient(DevToolsAgentHostClient* client) {\n   scoped_refptr<DevToolsAgentHostImpl> protect(this);\n  DevToolsSession* session = new DevToolsSession(this, client);\n   sessions_.insert(session);\n   session_by_client_[client].reset(session);\n  AttachSession(session);\n   if (sessions_.size() == 1)\n     NotifyAttached();\n   DevToolsManager* manager = DevToolsManager::GetInstance();\n   if (manager->delegate())\n     manager->delegate()->ClientAttached(this, client);\n }\n", "target": 1, "flaw_line_index": "3,6"}
{"idx": 7863, "func": "uint64_t ram_bytes_transferred(void)\n{\n    return bytes_transferred;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186776, "func": " VaapiVideoDecodeAccelerator::VaapiVP9Accelerator::CreateVP9Picture() {\n   scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n   if (!va_surface)\n     return nullptr;\n\n  return new VaapiVP9Picture(std::move(va_surface));\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 186822, "func": " void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  DCHECK(sensor_device);\n\n  if (!StartPollingThread()) {\n    callback.Run(nullptr);\n    return;\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n", "target": 1, "flaw_line_index": "3,15"}
{"idx": 187126, "func": "void ProcessHeap::Init() {\n  total_allocated_space_ = 0;\n   total_allocated_object_size_ = 0;\n   total_marked_object_size_ = 0;\n \n  GCInfoTable::Init();\n   base::SamplingHeapProfiler::SetHooksInstallCallback([]() {\n     HeapAllocHooks::SetAllocationHook(&BlinkGCAllocHook);\n     HeapAllocHooks::SetFreeHook(&BlinkGCFreeHook);\n  });\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 7704, "func": "static inline bool is_read_only_op(V9fsPDU *pdu)\n{\n    switch (pdu->id) {\n    case P9_TREADDIR:\n    case P9_TSTATFS:\n    case P9_TGETATTR:\n    case P9_TXATTRWALK:\n    case P9_TLOCK:\n    case P9_TGETLOCK:\n    case P9_TREADLINK:\n    case P9_TVERSION:\n    case P9_TLOPEN:\n    case P9_TATTACH:\n    case P9_TSTAT:\n    case P9_TWALK:\n    case P9_TCLUNK:\n    case P9_TFSYNC:\n    case P9_TOPEN:\n    case P9_TREAD:\n    case P9_TAUTH:\n    case P9_TFLUSH:\n        return 1;\n    default:\n        return 0;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7530, "func": "  woff_open_font( FT_Stream  stream,\n                  TT_Face    face )\n  {\n    FT_Memory       memory = stream->memory;\n    FT_Error        error  = FT_Err_Ok;\n\n    WOFF_HeaderRec  woff;\n    WOFF_Table      tables  = NULL;\n    WOFF_Table*     indices = NULL;\n\n    FT_ULong        woff_offset;\n\n    FT_Byte*        sfnt        = NULL;\n    FT_Stream       sfnt_stream = NULL;\n\n    FT_Byte*        sfnt_header;\n    FT_ULong        sfnt_offset;\n\n    FT_Int          nn;\n    FT_ULong        old_tag = 0;\n\n    static const FT_Frame_Field  woff_header_fields[] =\n    {\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  WOFF_HeaderRec\n\n      FT_FRAME_START( 44 ),\n        FT_FRAME_ULONG ( signature ),\n        FT_FRAME_ULONG ( flavor ),\n        FT_FRAME_ULONG ( length ),\n        FT_FRAME_USHORT( num_tables ),\n        FT_FRAME_USHORT( reserved ),\n        FT_FRAME_ULONG ( totalSfntSize ),\n        FT_FRAME_USHORT( majorVersion ),\n        FT_FRAME_USHORT( minorVersion ),\n        FT_FRAME_ULONG ( metaOffset ),\n        FT_FRAME_ULONG ( metaLength ),\n        FT_FRAME_ULONG ( metaOrigLength ),\n        FT_FRAME_ULONG ( privOffset ),\n        FT_FRAME_ULONG ( privLength ),\n      FT_FRAME_END\n    };\n\n\n    FT_ASSERT( stream == face->root.stream );\n    FT_ASSERT( FT_STREAM_POS() == 0 );\n\n    if ( FT_STREAM_READ_FIELDS( woff_header_fields, &woff ) )\n      return error;\n\n    if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )\n      return FT_THROW( Invalid_Table );\n\n    if ( woff.length != stream->size                              ||\n         woff.num_tables == 0                                     ||\n         44 + woff.num_tables * 20UL >= woff.length               ||\n         12 + woff.num_tables * 16UL >= woff.totalSfntSize        ||\n         ( woff.totalSfntSize & 3 ) != 0                          ||\n         ( woff.metaOffset == 0 && ( woff.metaLength != 0     ||\n                                     woff.metaOrigLength != 0 ) ) ||\n         ( woff.metaLength != 0 && woff.metaOrigLength == 0 )     ||\n         ( woff.privOffset == 0 && woff.privLength != 0 )         )\n    {\n      FT_ERROR(( \"woff_font_open: invalid WOFF header\\n\" ));\n      return FT_THROW( Invalid_Table );\n    }\n\n    if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||\n         FT_NEW( sfnt_stream )                         )\n      goto Exit;\n\n    sfnt_header = sfnt;\n\n    {\n      FT_UInt  searchRange, entrySelector, rangeShift, x;\n\n\n      x             = woff.num_tables;\n      entrySelector = 0;\n      while ( x )\n      {\n        x            >>= 1;\n        entrySelector += 1;\n      }\n      entrySelector--;\n\n      searchRange = ( 1 << entrySelector ) * 16;\n      rangeShift  = woff.num_tables * 16 - searchRange;\n\n      WRITE_ULONG ( sfnt_header, woff.flavor );\n      WRITE_USHORT( sfnt_header, woff.num_tables );\n      WRITE_USHORT( sfnt_header, searchRange );\n      WRITE_USHORT( sfnt_header, entrySelector );\n      WRITE_USHORT( sfnt_header, rangeShift );\n    }\n\n\n    if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||\n         FT_NEW_ARRAY( indices, woff.num_tables ) )\n      goto Exit;\n\n    FT_TRACE2(( \"\\n\"\n                \"  tag    offset    compLen  origLen  checksum\\n\"\n                \"  -------------------------------------------\\n\" ));\n\n    if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )\n      goto Exit;\n\n    for ( nn = 0; nn < woff.num_tables; nn++ )\n    {\n      WOFF_Table  table = tables + nn;\n\n      table->Tag        = FT_GET_TAG4();\n      table->Offset     = FT_GET_ULONG();\n      table->CompLength = FT_GET_ULONG();\n      table->OrigLength = FT_GET_ULONG();\n      table->CheckSum   = FT_GET_ULONG();\n\n      FT_TRACE2(( \"  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\\n\",\n                  (FT_Char)( table->Tag >> 24 ),\n                  (FT_Char)( table->Tag >> 16 ),\n                  (FT_Char)( table->Tag >> 8  ),\n                  (FT_Char)( table->Tag       ),\n                  table->Offset,\n                  table->CompLength,\n                  table->OrigLength,\n                  table->CheckSum ));\n\n      if ( table->Tag <= old_tag )\n      {\n        FT_FRAME_EXIT();\n\n        FT_ERROR(( \"woff_font_open: table tags are not sorted\\n\" ));\n        error = FT_THROW( Invalid_Table );\n        goto Exit;\n      }\n\n      old_tag     = table->Tag;\n      indices[nn] = table;\n    }\n\n    FT_FRAME_EXIT();\n\n\n    ft_qsort( indices,\n              woff.num_tables,\n              sizeof ( WOFF_Table ),\n              compare_offsets );\n\n\n    woff_offset = 44 + woff.num_tables * 20L;\n    sfnt_offset = 12 + woff.num_tables * 16L;\n\n    for ( nn = 0; nn < woff.num_tables; nn++ )\n    {\n      WOFF_Table  table = indices[nn];\n\n\n      if ( table->Offset != woff_offset                         ||\n           table->CompLength > woff.length                      ||\n           table->Offset > woff.length - table->CompLength      ||\n           table->OrigLength > woff.totalSfntSize               ||\n           sfnt_offset > woff.totalSfntSize - table->OrigLength ||\n           table->CompLength > table->OrigLength                )\n      {\n        FT_ERROR(( \"woff_font_open: invalid table offsets\\n\" ));\n        error = FT_THROW( Invalid_Table );\n        goto Exit;\n      }\n\n      table->OrigOffset = sfnt_offset;\n\n      woff_offset += ( table->CompLength + 3 ) & ~3U;\n      sfnt_offset += ( table->OrigLength + 3 ) & ~3U;\n    }\n\n\n    if ( woff.metaOffset )\n    {\n      if ( woff.metaOffset != woff_offset                  ||\n           woff.metaOffset + woff.metaLength > woff.length )\n      {\n        FT_ERROR(( \"woff_font_open:\"\n                   \" invalid `metadata' offset or length\\n\" ));\n        error = FT_THROW( Invalid_Table );\n        goto Exit;\n      }\n\n      woff_offset += woff.metaLength;\n    }\n\n    if ( woff.privOffset )\n    {\n      woff_offset = ( woff_offset + 3 ) & ~3U;\n\n      if ( woff.privOffset != woff_offset                  ||\n           woff.privOffset + woff.privLength > woff.length )\n      {\n        FT_ERROR(( \"woff_font_open: invalid `private' offset or length\\n\" ));\n        error = FT_THROW( Invalid_Table );\n        goto Exit;\n      }\n\n      woff_offset += woff.privLength;\n    }\n\n    if ( sfnt_offset != woff.totalSfntSize ||\n         woff_offset != woff.length        )\n    {\n      FT_ERROR(( \"woff_font_open: invalid `sfnt' table structure\\n\" ));\n      error = FT_THROW( Invalid_Table );\n      goto Exit;\n    }\n\n    if ( FT_REALLOC( sfnt,\n                     12 + woff.num_tables * 16UL,\n                     woff.totalSfntSize ) )\n      goto Exit;\n\n    sfnt_header = sfnt + 12;\n\n\n    for ( nn = 0; nn < woff.num_tables; nn++ )\n    {\n      WOFF_Table  table = tables + nn;\n\n\n      WRITE_ULONG( sfnt_header, table->Tag );\n      WRITE_ULONG( sfnt_header, table->CheckSum );\n      WRITE_ULONG( sfnt_header, table->OrigOffset );\n      WRITE_ULONG( sfnt_header, table->OrigLength );\n\n      if ( FT_STREAM_SEEK( table->Offset )     ||\n           FT_FRAME_ENTER( table->CompLength ) )\n        goto Exit;\n\n      if ( table->CompLength == table->OrigLength )\n      {\n        ft_memcpy( sfnt + table->OrigOffset,\n                   stream->cursor,\n                   table->OrigLength );\n      }\n      else\n      {\n#ifdef FT_CONFIG_OPTION_USE_ZLIB\n\n        FT_ULong  output_len = table->OrigLength;\n\n\n        error = FT_Gzip_Uncompress( memory,\n                                    sfnt + table->OrigOffset, &output_len,\n                                    stream->cursor, table->CompLength );\n        if ( error )\n          goto Exit;\n        if ( output_len != table->OrigLength )\n        {\n          FT_ERROR(( \"woff_font_open: compressed table length mismatch\\n\" ));\n          error = FT_THROW( Invalid_Table );\n          goto Exit;\n        }\n\n#else \n\n        error = FT_THROW( Unimplemented_Feature );\n        goto Exit;\n\n#endif \n      }\n\n      FT_FRAME_EXIT();\n\n      sfnt_offset = table->OrigOffset + table->OrigLength;\n      while ( sfnt_offset & 3 )\n      {\n        sfnt[sfnt_offset] = '\\0';\n        sfnt_offset++;\n      }\n    }\n\n    FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );\n    sfnt_stream->memory = stream->memory;\n    sfnt_stream->close  = sfnt_stream_close;\n\n    FT_Stream_Free(\n      face->root.stream,\n      ( face->root.face_flags & FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );\n\n    face->root.stream = sfnt_stream;\n\n    face->root.face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;\n\n  Exit:\n    FT_FREE( tables );\n    FT_FREE( indices );\n\n    if ( error )\n    {\n      FT_FREE( sfnt );\n      FT_Stream_Close( sfnt_stream );\n      FT_FREE( sfnt_stream );\n    }\n\n    return error;\n  }\n", "target": 0, "flaw_line_index": ""}
{"idx": 186321, "func": "std::string GetDMToken() {\n  std::string dm_token = *GetTestingDMToken();\n \n #if !defined(OS_CHROMEOS)\n \n  if (dm_token.empty() &&\n       policy::ChromeBrowserCloudManagementController::IsEnabled()) {\n    dm_token = policy::BrowserDMTokenStorage::Get()->RetrieveDMToken();\n   }\n #endif\n \n  return dm_token;\n}\n", "target": 1, "flaw_line_index": "2,10,12"}
{"idx": 186543, "func": "  void CreateOAuth2ServiceDelegate(\n       signin::AccountConsistencyMethod account_consistency) {\n    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(\n         client_.get(), &signin_error_controller_, &account_tracker_service_,\n         token_web_data_, account_consistency, revoke_all_tokens_on_load_,\n        true \n));\n     base::RunLoop().RunUntilIdle();\n     oauth2_service_delegate_->AddObserver(this);\n   }\n", "target": 1, "flaw_line_index": "3,7,8"}
{"idx": 186698, "func": "void WebViewTestClient::DidFocus() {\n   test_runner()->SetFocus(web_view_test_proxy_base_->web_view(), true);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186509, "func": "SendTabToSelfInfoBarDelegate::Create(const SendTabToSelfEntry* entry) {\n  return base::WrapUnique(new SendTabToSelfInfoBarDelegate(entry));\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8240, "func": "static void v9fs_walk(void *opaque)\n{\n    int name_idx;\n    V9fsQID *qids = NULL;\n    int i, err = 0;\n    V9fsPath dpath, path;\n    uint16_t nwnames;\n    struct stat stbuf;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsString *wnames = NULL;\n    V9fsFidState *fidp;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsQID qid;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n    offset += err;\n\n    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);\n\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        wnames = g_malloc0(sizeof(wnames[0]) * nwnames);\n        qids   = g_malloc0(sizeof(qids[0]) * nwnames);\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        goto out;\n    }\n\n    v9fs_path_copy(&dpath, &fidp->path);\n    v9fs_path_copy(&path, &fidp->path);\n    for (name_idx = 0; name_idx < nwnames; name_idx++) {\n        if (not_same_qid(&pdu->s->root_qid, &qid) ||\n            strcmp(\"..\", wnames[name_idx].data)) {\n            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,\n                                       &path);\n            if (err < 0) {\n                goto out;\n            }\n\n            err = v9fs_co_lstat(pdu, &path, &stbuf);\n            if (err < 0) {\n                goto out;\n            }\n            stat_to_qid(&stbuf, &qid);\n            v9fs_path_copy(&dpath, &path);\n        }\n        memcpy(&qids[name_idx], &qid, sizeof(qid));\n    }\n    if (fid == newfid) {\n        BUG_ON(fidp->fid_type != P9_FID_NONE);\n        v9fs_path_copy(&fidp->path, &path);\n    } else {\n        newfidp = alloc_fid(s, newfid);\n        if (newfidp == NULL) {\n            err = -EINVAL;\n            goto out;\n        }\n        newfidp->uid = fidp->uid;\n        v9fs_path_copy(&newfidp->path, &path);\n    }\n    err = v9fs_walk_marshal(pdu, nwnames, qids);\n    trace_v9fs_walk_return(pdu->tag, pdu->id, nwnames, qids);\nout:\n    put_fid(pdu, fidp);\n    if (newfidp) {\n        put_fid(pdu, newfidp);\n    }\n    v9fs_path_free(&dpath);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        for (name_idx = 0; name_idx < nwnames; name_idx++) {\n            v9fs_string_free(&wnames[name_idx]);\n        }\n        g_free(wnames);\n        g_free(qids);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186919, "func": "PushMessagingServiceImpl::PushMessagingServiceImpl(Profile* profile)\n    : profile_(profile),\n       push_subscription_count_(0),\n       pending_push_subscription_count_(0),\n       notification_manager_(profile),\n      push_messaging_service_observer_(PushMessagingServiceObserver::Create()),\n       weak_factory_(this) {\n   DCHECK(profile);\n   HostContentSettingsMapFactory::GetForProfile(profile_)->AddObserver(this);\n\n  registrar_.Add(this, chrome::NOTIFICATION_APP_TERMINATING,\n                 content::NotificationService::AllSources());\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 7680, "func": "static int handle_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    char *buffer;\n    struct file_handle *fh;\n    int dirfd, ret, mnt_id;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    if (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n        errno = EINVAL;\n        return -1;\n\n    }\n    if (dir_path) {\n        dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    } else {\n        buffer = rpath(ctx, \".\");\n        dirfd = open(buffer, O_DIRECTORY);\n        g_free(buffer);\n    }\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    fh = g_malloc(sizeof(struct file_handle) + data->handle_bytes);\n    fh->handle_bytes = data->handle_bytes;\n    buffer = g_strdup_printf(\"./%s\", name);\n    ret = name_to_handle(dirfd, buffer, fh, &mnt_id, 0);\n    if (!ret) {\n        target->data = (char *)fh;\n        target->size = sizeof(struct file_handle) + data->handle_bytes;\n    } else {\n        g_free(fh);\n    }\n    close(dirfd);\n    g_free(buffer);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186802, "func": " PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n    mojo::ScopedSharedBufferMapping mapping,\n     PlatformSensorProvider* provider)\n    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n", "target": 1, "flaw_line_index": "2,4"}
{"idx": 186803, "func": " PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n    : PlatformSensor(type, std::move(mapping), provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n \n  Java_PlatformSensor_initPlatformSensorAndroid(env, j_object_,\n                                                reinterpret_cast<jlong>(this));\n}\n", "target": 1, "flaw_line_index": "3,6"}
{"idx": 7399, "func": "init_file_tables(void)\n{\n\tstatic int done = 0;\n\tconst struct type_tbl_s *p;\n\n\tif (done)\n\t\treturn;\n\tdone++;\n\n\tfor (p = type_tbl; p->len; p++) {\n\t\tassert(p->type < FILE_NAMES_SIZE);\n\t\tfile_names[p->type] = p->name;\n\t\tfile_formats[p->type] = p->format;\n\t}\n\tassert(p - type_tbl == FILE_NAMES_SIZE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7613, "func": "static void cirrus_write_bitblt(CirrusVGAState * s, unsigned reg_value)\n{\n    unsigned old_value;\n\n    old_value = s->vga.gr[0x31];\n    s->vga.gr[0x31] = reg_value;\n\n    if (((old_value & CIRRUS_BLT_RESET) != 0) &&\n\t((reg_value & CIRRUS_BLT_RESET) == 0)) {\n\tcirrus_bitblt_reset(s);\n    } else if (((old_value & CIRRUS_BLT_START) == 0) &&\n\t       ((reg_value & CIRRUS_BLT_START) != 0)) {\n\tcirrus_bitblt_start(s);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186597, "func": "bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186933, "func": "  void TestAppInstancesHelper(const std::string& app_name) {\n    LOG(INFO) << \"Start of test.\";\n\n    extensions::ProcessMap* process_map =\n        extensions::ProcessMap::Get(browser()->profile());\n\n    ASSERT_TRUE(LoadExtension(\n        test_data_dir_.AppendASCII(app_name)));\n    const Extension* extension = GetSingleLoadedExtension();\n\n    GURL base_url = GetTestBaseURL(app_name);\n\n    ui_test_utils::NavigateToURLWithDisposition(\n        browser(), base_url.Resolve(\"path1/empty.html\"),\n        WindowOpenDisposition::NEW_FOREGROUND_TAB,\n        ui_test_utils::BROWSER_TEST_WAIT_FOR_NAVIGATION);\n    LOG(INFO) << \"Nav 1.\";\n    EXPECT_TRUE(process_map->Contains(\n        browser()->tab_strip_model()->GetWebContentsAt(1)->\n            GetRenderProcessHost()->GetID()));\n    EXPECT_FALSE(browser()->tab_strip_model()->GetWebContentsAt(1)->GetWebUI());\n\n    content::WindowedNotificationObserver tab_added_observer(\n        chrome::NOTIFICATION_TAB_ADDED,\n        content::NotificationService::AllSources());\n    chrome::NewTab(browser());\n    tab_added_observer.Wait();\n    LOG(INFO) << \"New tab.\";\n    ui_test_utils::NavigateToURL(browser(),\n                                 base_url.Resolve(\"path2/empty.html\"));\n    LOG(INFO) << \"Nav 2.\";\n    EXPECT_TRUE(process_map->Contains(\n        browser()->tab_strip_model()->GetWebContentsAt(2)->\n            GetRenderProcessHost()->GetID()));\n    EXPECT_FALSE(browser()->tab_strip_model()->GetWebContentsAt(2)->GetWebUI());\n\n    ASSERT_EQ(3, browser()->tab_strip_model()->count());\n    WebContents* tab1 = browser()->tab_strip_model()->GetWebContentsAt(1);\n    WebContents* tab2 = browser()->tab_strip_model()->GetWebContentsAt(2);\n    EXPECT_NE(tab1->GetRenderProcessHost(), tab2->GetRenderProcessHost());\n\n     ASSERT_EQ(1u, chrome::GetBrowserCount(browser()->profile()));\n    OpenWindow(tab1, base_url.Resolve(\"path1/empty.html\"), true, NULL);\n     LOG(INFO) << \"WindowOpenHelper 1.\";\n    OpenWindow(tab2, base_url.Resolve(\"path2/empty.html\"), true, NULL);\n     LOG(INFO) << \"End of test.\";\n     UnloadExtension(extension->id());\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 186442, "func": "void FrameFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n     const FetchInitiatorInfo& initiator_info) {\n   if (IsDetached())\n     return;\n\n  if (redirect_response.IsNull()) {\n    GetFrame()->Loader().Progress().WillStartLoading(identifier,\n                                                     request.Priority());\n   }\n   probe::willSendRequest(GetFrame()->GetDocument(), identifier,\n                          MasterDocumentLoader(), request, redirect_response,\n                         initiator_info);\n   if (IdlenessDetector* idleness_detector = GetFrame()->GetIdlenessDetector())\n     idleness_detector->OnWillSendRequest();\n   if (GetFrame()->FrameScheduler())\n    GetFrame()->FrameScheduler()->DidStartLoading(identifier);\n}\n", "target": 1, "flaw_line_index": "17"}
{"idx": 186445, "func": " void FetchContext::DispatchWillSendRequest(unsigned long,\n                                            ResourceRequest&,\n                                            const ResourceResponse&,\n                                            const FetchInitiatorInfo&) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8257, "func": "Status _xvmc_destroy_surface (\n    Display *dpy,\n    XvMCSurface *surface\n)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcDestroySurfaceReq  *req;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (DestroySurface, req);\n    req->surface_id = surface->surface_id;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return Success;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8211, "func": "static int v9fs_complete_renameat(V9fsPDU *pdu, int32_t olddirfid,\n                                  V9fsString *old_name, int32_t newdirfid,\n                                  V9fsString *new_name)\n{\n    int err = 0;\n    V9fsState *s = pdu->s;\n    V9fsFidState *newdirfidp = NULL, *olddirfidp = NULL;\n\n    olddirfidp = get_fid(pdu, olddirfid);\n    if (olddirfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    if (newdirfid != -1) {\n        newdirfidp = get_fid(pdu, newdirfid);\n        if (newdirfidp == NULL) {\n            err = -ENOENT;\n            goto out;\n        }\n    } else {\n        newdirfidp = get_fid(pdu, olddirfid);\n    }\n\n    err = v9fs_co_renameat(pdu, &olddirfidp->path, old_name,\n                           &newdirfidp->path, new_name);\n    if (err < 0) {\n        goto out;\n    }\n    if (s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT) {\n        v9fs_fix_fid_paths(pdu, &olddirfidp->path, old_name,\n                           &newdirfidp->path, new_name);\n    }\nout:\n    if (olddirfidp) {\n        put_fid(pdu, olddirfidp);\n    }\n    if (newdirfidp) {\n        put_fid(pdu, newdirfidp);\n    }\n    return err;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8238, "func": "static void v9fs_unlinkat(void *opaque)\n{\n    int err = 0;\n    V9fsString name;\n    int32_t dfid, flags;\n    size_t offset = 7;\n    V9fsPath path;\n    V9fsFidState *dfidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsd\", &dfid, &name, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data)) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\"..\", name.data)) {\n        err = -ENOTEMPTY;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    v9fs_path_init(&path);\n    err = v9fs_co_name_to_path(pdu, &dfidp->path, name.data, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_mark_fids_unreclaim(pdu, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_unlinkat(pdu, &dfidp->path, &name, flags);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    put_fid(pdu, dfidp);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187223, "func": "static int get_valid_interface(struct libusb_device_handle *dev_handle, int api_id)\n{\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n \tstruct windows_device_priv *priv = _device_priv(dev_handle->dev);\n \tint i;\n \n\tif ((api_id < USB_API_WINUSBX) || (api_id > USB_API_HID)) {\n \t\tusbi_dbg(\"unsupported API ID\");\n \t\treturn -1;\n \t}\n\n\tfor (i=0; i<USB_MAXINTERFACES; i++) {\n\t\tif ( (handle_priv->interface_handle[i].dev_handle != 0)\n\t\t  && (handle_priv->interface_handle[i].dev_handle != INVALID_HANDLE_VALUE)\n\t\t  && (handle_priv->interface_handle[i].api_handle != 0)\n\t\t  && (handle_priv->interface_handle[i].api_handle != INVALID_HANDLE_VALUE)\n\t\t  && (priv->usb_interface[i].apib->id == api_id) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 186359, "func": "base::string16 IDNToUnicodeWithAdjustments(\n    base::StringPiece host, base::OffsetAdjuster::Adjustments* adjustments) {\n  if (adjustments)\n    adjustments->clear();\n  base::string16 input16;\n   input16.reserve(host.length());\n   input16.insert(input16.end(), host.begin(), host.end());\n \n   base::string16 out16;\n  for (size_t component_start = 0, component_end;\n       component_start < input16.length();\n       component_start = component_end + 1) {\n    component_end = input16.find('.', component_start);\n    if (component_end == base::string16::npos)\n      component_end = input16.length();  \n    size_t component_length = component_end - component_start;\n    size_t new_component_start = out16.length();\n    bool converted_idn = false;\n    if (component_end > component_start) {\n       converted_idn =\n           IDNToUnicodeOneComponent(input16.data() + component_start,\n                                   component_length, &out16);\n     }\n     size_t new_component_length = out16.length() - new_component_start;\n \n    if (converted_idn && adjustments) {\n      adjustments->push_back(base::OffsetAdjuster::Adjustment(\n          component_start, component_length, new_component_length));\n    }\n\n    if (component_end < input16.length())\n      out16.push_back('.');\n  }\n  return out16;\n}\n", "target": 1, "flaw_line_index": "27"}
{"idx": 7767, "func": "static int h2_init(struct connection *conn)\n{\n\tif (conn->mux_ctx) {\n\t\treturn -1;\n\t}\n\n\treturn h2c_frt_init(conn);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186387, "func": "DataReductionProxyConfigServiceClient::DataReductionProxyConfigServiceClient(\n    const net::BackoffEntry::Policy& backoff_policy,\n    DataReductionProxyRequestOptions* request_options,\n    DataReductionProxyMutableConfigValues* config_values,\n    DataReductionProxyConfig* config,\n    DataReductionProxyIOData* io_data,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    ConfigStorer config_storer)\n    : request_options_(request_options),\n      config_values_(config_values),\n      config_(config),\n      io_data_(io_data),\n      network_connection_tracker_(network_connection_tracker),\n      config_storer_(config_storer),\n      backoff_policy_(backoff_policy),\n      backoff_entry_(&backoff_policy_),\n      config_service_url_(util::AddApiKeyToUrl(params::GetConfigServiceURL())),\n      enabled_(false),\n      remote_config_applied_(false),\n#if defined(OS_ANDROID)\n      foreground_fetch_pending_(false),\n#endif\n      previous_request_failed_authentication_(false),\n      failed_attempts_before_success_(0),\n      fetch_in_progress_(false),\n      client_config_override_used_(false) {\n  DCHECK(request_options);\n  DCHECK(config_values);\n   DCHECK(config);\n   DCHECK(io_data);\n   DCHECK(config_service_url_.is_valid());\n \n   const base::CommandLine& command_line =\n       *base::CommandLine::ForCurrentProcess();\n  client_config_override_ = command_line.GetSwitchValueASCII(\n      switches::kDataReductionProxyServerClientConfig);\n\n  thread_checker_.DetachFromThread();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187044, "func": "UseCounterPageLoadMetricsObserver::GetAllowedUkmFeatures() {\n  static base::NoDestructor<UseCounterPageLoadMetricsObserver::UkmFeatureList>\n      opt_in_features(std::initializer_list<WebFeature>({\n          WebFeature::kNavigatorVibrate,\n          WebFeature::kNavigatorVibrateSubFrame,\n          WebFeature::kTouchEventPreventedNoTouchAction,\n          WebFeature::kTouchEventPreventedForcedDocumentPassiveNoTouchAction,\n          WebFeature::kDataUriHasOctothorpe,\n          WebFeature::kApplicationCacheManifestSelectInsecureOrigin,\n          WebFeature::kApplicationCacheManifestSelectSecureOrigin,\n          WebFeature::kMixedContentAudio,\n          WebFeature::kMixedContentImage,\n          WebFeature::kMixedContentVideo,\n          WebFeature::kMixedContentPlugin,\n          WebFeature::kOpenerNavigationWithoutGesture,\n          WebFeature::kUsbRequestDevice,\n          WebFeature::kXMLHttpRequestSynchronous,\n          WebFeature::kPaymentHandler,\n          WebFeature::kPaymentRequestShowWithoutGesture,\n          WebFeature::kHTMLImports,\n          WebFeature::kHTMLImportsHasStyleSheets,\n          WebFeature::kElementCreateShadowRoot,\n          WebFeature::kDocumentRegisterElement,\n          WebFeature::kCredentialManagerCreatePublicKeyCredential,\n          WebFeature::kCredentialManagerGetPublicKeyCredential,\n          WebFeature::kCredentialManagerMakePublicKeyCredentialSuccess,\n          WebFeature::kCredentialManagerGetPublicKeyCredentialSuccess,\n          WebFeature::kV8AudioContext_Constructor,\n          WebFeature::kElementAttachShadow,\n          WebFeature::kElementAttachShadowOpen,\n          WebFeature::kElementAttachShadowClosed,\n          WebFeature::kCustomElementRegistryDefine,\n          WebFeature::kTextToSpeech_Speak,\n          WebFeature::kTextToSpeech_SpeakDisallowedByAutoplay,\n          WebFeature::kCSSEnvironmentVariable,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetTop,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetLeft,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetRight,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetBottom,\n          WebFeature::kMediaControlsDisplayCutoutGesture,\n          WebFeature::kPolymerV1Detected,\n          WebFeature::kPolymerV2Detected,\n          WebFeature::kFullscreenSecureOrigin,\n          WebFeature::kFullscreenInsecureOrigin,\n          WebFeature::kPrefixedVideoEnterFullscreen,\n          WebFeature::kPrefixedVideoExitFullscreen,\n          WebFeature::kPrefixedVideoEnterFullScreen,\n          WebFeature::kPrefixedVideoExitFullScreen,\n          WebFeature::kDocumentLevelPassiveDefaultEventListenerPreventedWheel,\n          WebFeature::kDocumentDomainBlockedCrossOriginAccess,\n          WebFeature::kDocumentDomainEnabledCrossOriginAccess,\n          WebFeature::kSuppressHistoryEntryWithoutUserGesture,\n          WebFeature::kCursorImageGT32x32,\n          WebFeature::kCursorImageLE32x32,\n          WebFeature::kHistoryPushState,\n          WebFeature::kHistoryReplaceState,\n          WebFeature::kCursorImageGT64x64,\n          WebFeature::kAdClick,\n          WebFeature::kUpdateWithoutShippingOptionOnShippingAddressChange,\n          WebFeature::kUpdateWithoutShippingOptionOnShippingOptionChange,\n          WebFeature::kSignedExchangeInnerResponseInMainFrame,\n          WebFeature::kSignedExchangeInnerResponseInSubFrame,\n          WebFeature::kWebShareShare,\n          WebFeature::kHTMLAnchorElementDownloadInSandboxWithUserGesture,\n          WebFeature::kHTMLAnchorElementDownloadInSandboxWithoutUserGesture,\n          WebFeature::kNavigationDownloadInSandboxWithUserGesture,\n          WebFeature::kNavigationDownloadInSandboxWithoutUserGesture,\n          WebFeature::kDownloadInAdFrameWithUserGesture,\n           WebFeature::kDownloadInAdFrameWithoutUserGesture,\n           WebFeature::kOpenWebDatabase,\n           WebFeature::kV8MediaCapabilities_DecodingInfo_Method,\n       }));\n   return *opt_in_features;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187144, "func": " ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n \n  auto params = bluetooth_socket::Send::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n \n  io_buffer_size_ = params->data.size();\n  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n \n  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n \n  socket->Send(io_buffer_,\n               io_buffer_size_,\n               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),\n               base::Bind(&BluetoothSocketSendFunction::OnError, this));\n  return did_respond() ? AlreadyResponded() : RespondLater();\n}\n", "target": 1, "flaw_line_index": "4,5,7,8,10"}
{"idx": 186732, "func": "void NetworkHandler::DeleteCookies(\n    const std::string& name,\n    Maybe<std::string> url,\n     Maybe<std::string> domain,\n     Maybe<std::string> path,\n     std::unique_ptr<DeleteCookiesCallback> callback) {\n  if (!process_) {\n     callback->sendFailure(Response::InternalError());\n     return;\n   }\n\n  if (!url.isJust() && !domain.isJust()) {\n    callback->sendFailure(Response::InvalidParams(\n        \"At least one of the url and domain needs to be specified\"));\n  }\n  BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(\n           &DeleteCookiesOnIO,\n          base::Unretained(\n              process_->GetStoragePartition()->GetURLRequestContext()),\n          name, url.fromMaybe(\"\"), domain.fromMaybe(\"\"), path.fromMaybe(\"\"),\n           base::BindOnce(&DeleteCookiesCallback::sendSuccess,\n                          std::move(callback))));\n }\n", "target": 1, "flaw_line_index": "7,20,21,22"}
{"idx": 7502, "func": "set_reply_serial (DBusMessage *message)\n{\n  if (message == NULL)\n    _dbus_assert_not_reached (\"oom\");\n  if (!dbus_message_set_reply_serial (message, 100))\n    _dbus_assert_not_reached (\"oom\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7731, "func": "void v9fs_reset(V9fsState *s)\n{\n    VirtfsCoResetData data = { .pdu = { .s = s }, .done = false };\n    Coroutine *co;\n\n    while (!QLIST_EMPTY(&s->active_list)) {\n        aio_poll(qemu_get_aio_context(), true);\n    }\n\n    co = qemu_coroutine_create(virtfs_co_reset, &data);\n    qemu_coroutine_enter(co);\n\n    while (!data.done) {\n        aio_poll(qemu_get_aio_context(), true);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186752, "func": " StorageHandler::StorageHandler()\n     : DevToolsDomainHandler(Storage::Metainfo::domainName),\n      process_(nullptr),\n       weak_ptr_factory_(this) {}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8090, "func": "void Gfx::fillPatch(GfxPatch *patch, int nComps, int depth) {\n  GfxPatch patch00, patch01, patch10, patch11;\n  double xx[4][8], yy[4][8];\n  double xxm, yym;\n  int i;\n\n  for (i = 0; i < nComps; ++i) {\n    if (abs(patch->color[0][0].c[i] - patch->color[0][1].c[i])\n\t  > patchColorDelta ||\n\tabs(patch->color[0][1].c[i] - patch->color[1][1].c[i])\n\t  > patchColorDelta ||\n\tabs(patch->color[1][1].c[i] - patch->color[1][0].c[i])\n\t  > patchColorDelta ||\n\tabs(patch->color[1][0].c[i] - patch->color[0][0].c[i])\n\t  > patchColorDelta) {\n      break;\n    }\n  }\n  if (i == nComps || depth == patchMaxDepth) {\n    state->setFillColor(&patch->color[0][0]);\n    out->updateFillColor(state);\n    state->moveTo(patch->x[0][0], patch->y[0][0]);\n    state->curveTo(patch->x[0][1], patch->y[0][1],\n\t\t   patch->x[0][2], patch->y[0][2],\n\t\t   patch->x[0][3], patch->y[0][3]);\n    state->curveTo(patch->x[1][3], patch->y[1][3],\n\t\t   patch->x[2][3], patch->y[2][3],\n\t\t   patch->x[3][3], patch->y[3][3]);\n    state->curveTo(patch->x[3][2], patch->y[3][2],\n\t\t   patch->x[3][1], patch->y[3][1],\n\t\t   patch->x[3][0], patch->y[3][0]);\n    state->curveTo(patch->x[2][0], patch->y[2][0],\n\t\t   patch->x[1][0], patch->y[1][0],\n\t\t   patch->x[0][0], patch->y[0][0]);\n    state->closePath();\n    if (!contentIsHidden())\n      out->fill(state);\n    state->clearPath();\n  } else {\n    for (i = 0; i < 4; ++i) {\n      xx[i][0] = patch->x[i][0];\n      yy[i][0] = patch->y[i][0];\n      xx[i][1] = 0.5 * (patch->x[i][0] + patch->x[i][1]);\n      yy[i][1] = 0.5 * (patch->y[i][0] + patch->y[i][1]);\n      xxm = 0.5 * (patch->x[i][1] + patch->x[i][2]);\n      yym = 0.5 * (patch->y[i][1] + patch->y[i][2]);\n      xx[i][6] = 0.5 * (patch->x[i][2] + patch->x[i][3]);\n      yy[i][6] = 0.5 * (patch->y[i][2] + patch->y[i][3]);\n      xx[i][2] = 0.5 * (xx[i][1] + xxm);\n      yy[i][2] = 0.5 * (yy[i][1] + yym);\n      xx[i][5] = 0.5 * (xxm + xx[i][6]);\n      yy[i][5] = 0.5 * (yym + yy[i][6]);\n      xx[i][3] = xx[i][4] = 0.5 * (xx[i][2] + xx[i][5]);\n      yy[i][3] = yy[i][4] = 0.5 * (yy[i][2] + yy[i][5]);\n      xx[i][7] = patch->x[i][3];\n      yy[i][7] = patch->y[i][3];\n    }\n    for (i = 0; i < 4; ++i) {\n      patch00.x[0][i] = xx[0][i];\n      patch00.y[0][i] = yy[0][i];\n      patch00.x[1][i] = 0.5 * (xx[0][i] + xx[1][i]);\n      patch00.y[1][i] = 0.5 * (yy[0][i] + yy[1][i]);\n      xxm = 0.5 * (xx[1][i] + xx[2][i]);\n      yym = 0.5 * (yy[1][i] + yy[2][i]);\n      patch10.x[2][i] = 0.5 * (xx[2][i] + xx[3][i]);\n      patch10.y[2][i] = 0.5 * (yy[2][i] + yy[3][i]);\n      patch00.x[2][i] = 0.5 * (patch00.x[1][i] + xxm);\n      patch00.y[2][i] = 0.5 * (patch00.y[1][i] + yym);\n      patch10.x[1][i] = 0.5 * (xxm + patch10.x[2][i]);\n      patch10.y[1][i] = 0.5 * (yym + patch10.y[2][i]);\n      patch00.x[3][i] = 0.5 * (patch00.x[2][i] + patch10.x[1][i]);\n      patch00.y[3][i] = 0.5 * (patch00.y[2][i] + patch10.y[1][i]);\n      patch10.x[0][i] = patch00.x[3][i];\n      patch10.y[0][i] = patch00.y[3][i];\n      patch10.x[3][i] = xx[3][i];\n      patch10.y[3][i] = yy[3][i];\n    }\n    for (i = 4; i < 8; ++i) {\n      patch01.x[0][i-4] = xx[0][i];\n      patch01.y[0][i-4] = yy[0][i];\n      patch01.x[1][i-4] = 0.5 * (xx[0][i] + xx[1][i]);\n      patch01.y[1][i-4] = 0.5 * (yy[0][i] + yy[1][i]);\n      xxm = 0.5 * (xx[1][i] + xx[2][i]);\n      yym = 0.5 * (yy[1][i] + yy[2][i]);\n      patch11.x[2][i-4] = 0.5 * (xx[2][i] + xx[3][i]);\n      patch11.y[2][i-4] = 0.5 * (yy[2][i] + yy[3][i]);\n      patch01.x[2][i-4] = 0.5 * (patch01.x[1][i-4] + xxm);\n      patch01.y[2][i-4] = 0.5 * (patch01.y[1][i-4] + yym);\n      patch11.x[1][i-4] = 0.5 * (xxm + patch11.x[2][i-4]);\n      patch11.y[1][i-4] = 0.5 * (yym + patch11.y[2][i-4]);\n      patch01.x[3][i-4] = 0.5 * (patch01.x[2][i-4] + patch11.x[1][i-4]);\n      patch01.y[3][i-4] = 0.5 * (patch01.y[2][i-4] + patch11.y[1][i-4]);\n      patch11.x[0][i-4] = patch01.x[3][i-4];\n      patch11.y[0][i-4] = patch01.y[3][i-4];\n      patch11.x[3][i-4] = xx[3][i];\n      patch11.y[3][i-4] = yy[3][i];\n    }\n    for (i = 0; i < nComps; ++i) {\n      patch00.color[0][0].c[i] = patch->color[0][0].c[i];\n      patch00.color[0][1].c[i] = (patch->color[0][0].c[i] +\n\t\t\t\t  patch->color[0][1].c[i]) / 2;\n      patch01.color[0][0].c[i] = patch00.color[0][1].c[i];\n      patch01.color[0][1].c[i] = patch->color[0][1].c[i];\n      patch01.color[1][1].c[i] = (patch->color[0][1].c[i] +\n\t\t\t\t  patch->color[1][1].c[i]) / 2;\n      patch11.color[0][1].c[i] = patch01.color[1][1].c[i];\n      patch11.color[1][1].c[i] = patch->color[1][1].c[i];\n      patch11.color[1][0].c[i] = (patch->color[1][1].c[i] +\n\t\t\t\t  patch->color[1][0].c[i]) / 2;\n      patch10.color[1][1].c[i] = patch11.color[1][0].c[i];\n      patch10.color[1][0].c[i] = patch->color[1][0].c[i];\n      patch10.color[0][0].c[i] = (patch->color[1][0].c[i] +\n\t\t\t\t  patch->color[0][0].c[i]) / 2;\n      patch00.color[1][0].c[i] = patch10.color[0][0].c[i];\n      patch00.color[1][1].c[i] = (patch00.color[1][0].c[i] +\n\t\t\t\t  patch01.color[1][1].c[i]) / 2;\n      patch01.color[1][0].c[i] = patch00.color[1][1].c[i];\n      patch11.color[0][0].c[i] = patch00.color[1][1].c[i];\n      patch10.color[0][1].c[i] = patch00.color[1][1].c[i];\n    }\n    fillPatch(&patch00, nComps, depth + 1);\n    fillPatch(&patch10, nComps, depth + 1);\n    fillPatch(&patch01, nComps, depth + 1);\n    fillPatch(&patch11, nComps, depth + 1);\n  }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7964, "func": "static void framebuffer_update_request(VncState *vs, int incremental,\n                                       int x, int y, int w, int h)\n{\n    int width = pixman_image_get_width(vs->vd->server);\n    int height = pixman_image_get_height(vs->vd->server);\n\n    vs->need_update = 1;\n\n    if (incremental) {\n        return;\n    }\n\n    vs->force_update = 1;\n    vnc_set_area_dirty(vs->dirty, width, height, x, y, w, h);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186679, "func": "void MimeHandlerViewContainer::OnReady() {\n  if (!render_frame() || !is_embedded_)\n    return;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n\n  blink::WebAssociatedURLLoaderOptions options;\n  DCHECK(!loader_);\n  loader_.reset(frame->CreateAssociatedURLLoader(options));\n\n   blink::WebURLRequest request(original_url_);\n   request.SetRequestContext(blink::WebURLRequest::kRequestContextObject);\n   loader_->LoadAsynchronously(request, this);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 7776, "func": "static void h2_release(struct connection *conn)\n{\n\tstruct h2c *h2c = conn->mux_ctx;\n\n\tLIST_DEL(&conn->list);\n\n\tif (h2c) {\n\t\thpack_dht_free(h2c->ddht);\n\n\t\tHA_SPIN_LOCK(BUF_WQ_LOCK, &buffer_wq_lock);\n\t\tLIST_DEL(&h2c->buf_wait.list);\n\t\tHA_SPIN_UNLOCK(BUF_WQ_LOCK, &buffer_wq_lock);\n\n\t\th2_release_buf(h2c, &h2c->dbuf);\n\t\th2_release_buf(h2c, &h2c->mbuf);\n\n\t\tif (h2c->task) {\n\t\t\th2c->task->context = NULL;\n\t\t\ttask_wakeup(h2c->task, TASK_WOKEN_OTHER);\n\t\t\th2c->task = NULL;\n\t\t}\n\n\t\tpool_free(pool_head_h2c, h2c);\n\t}\n\n\tconn->mux = NULL;\n\tconn->mux_ctx = NULL;\n\n\tconn_stop_tracking(conn);\n\tconn_full_close(conn);\n\tif (conn->destroy_cb)\n\t\tconn->destroy_cb(conn);\n\tconn_free(conn);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186535, "func": "  bool TryAddAxesButton(\n       vr::EVRButtonId button_id,\n       AxesRequirement requirement = AxesRequirement::kOptional) {\n     if (!IsInAxesData(button_id))\n       return false;\n \n    bool require_axes = (requirement == AxesRequirement::kRequired);\n     if (require_axes && !axes_data_[button_id].has_both_axes)\n       return false;\n \n    AddButton(axes_data_[button_id]);\n    used_axes_.insert(button_id);\n\n     return true;\n   }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 186815, "func": "void PlatformSensorProviderBase::CreateSensor(\n    mojom::SensorType type,\n    const CreateSensorCallback& callback) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n\n  if (!CreateSharedBufferIfNeeded()) {\n    callback.Run(nullptr);\n     return;\n   }\n \n  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n  if (!mapping) {\n     callback.Run(nullptr);\n     return;\n   }\n\n  auto it = requests_map_.find(type);\n  if (it != requests_map_.end()) {\n    it->second.push_back(callback);\n  } else {  \n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n        type, std::move(mapping),\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n}\n", "target": 1, "flaw_line_index": "11,12,24"}
{"idx": 187147, "func": "void HTMLMediaElement::NoneSupported(const String& message) {\n  BLINK_MEDIA_LOG << \"NoneSupported(\" << (void*)this << \", message='\" << message\n                  << \"')\";\n \n   StopPeriodicTimers();\n   load_state_ = kWaitingForSource;\n   current_source_node_ = nullptr;\n \n \n  error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);\n\n  ForgetResourceSpecificTracks();\n\n  SetNetworkState(kNetworkNoSource);\n\n  UpdateDisplayState();\n\n  ScheduleEvent(EventTypeNames::error);\n\n  ScheduleRejectPlayPromises(kNotSupportedError);\n\n  CloseMediaSource();\n\n  SetShouldDelayLoadEvent(false);\n\n  if (GetLayoutObject())\n    GetLayoutObject()->UpdateFromElement();\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 7406, "func": "ZEND_API zval *_zend_ts_hash_str_update(TsHashTable *ht, const char *key, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzval *retval;\n\n\tbegin_write(ht);\n\tretval = zend_hash_str_update(TS_HASH(ht), key, len, pData);\n\tend_write(ht);\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186797, "func": "mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n     mojom::SensorType type) {\n  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 186553, "func": "  MirrorMockJobInterceptor(const base::FilePath& root_http,\n                           ReportResponseHeadersOnUI report_on_ui)\n      : root_http_(root_http), report_on_ui_(report_on_ui) {}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8170, "func": "void Gfx::opStroke(Object args[], int numArgs) {\n  if (!state->isCurPt()) {\n    return;\n  }\n  if (state->isPath() && !contentIsHidden()) {\n    if (state->getStrokeColorSpace()->getMode() == csPattern) {\n      doPatternStroke();\n    } else {\n      out->stroke(state);\n    }\n  }\n  doEndPath();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186999, "func": " static uint64_t ReadBits(BitReader* reader, int num_bits) {\n   DCHECK_GE(reader->bits_available(), num_bits);\n   DCHECK((num_bits > 0) && (num_bits <= 64));\n  uint64_t value;\n  reader->ReadBits(num_bits, &value);\n   return value;\n }\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 7806, "func": "static int h2c_send_strm_wu(struct h2c *h2c)\n{\n\tint ret = 1;\n\n\tif (h2c->rcvd_s <= 0)\n\t\treturn 1;\n\n\tret = h2c_send_window_update(h2c, h2c->dsi, h2c->rcvd_s);\n\tif (ret > 0)\n\t\th2c->rcvd_s = 0;\n\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8280, "func": "SizeID XRRConfigCurrentConfiguration (XRRScreenConfiguration *config,\n\t\t\t      Rotation *rotation)\n{\n    *rotation = (Rotation) config->current_rotation;\n    return (SizeID) config->current_size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 186833, "func": "   void CallCompositorWithSuccess(mojom::PdfCompositorPtr ptr) {\n     auto handle = CreateMSKPInSharedMemory();\n     ASSERT_TRUE(handle.IsValid());\n    mojo::ScopedSharedBufferHandle buffer_handle =\n        mojo::WrapSharedMemoryHandle(handle, handle.GetSize(), true);\n     ASSERT_TRUE(buffer_handle->is_valid());\n     EXPECT_CALL(*this, CallbackOnSuccess(testing::_)).Times(1);\n     ptr->CompositePdf(std::move(buffer_handle),\n                      base::BindOnce(&PdfCompositorServiceTest::OnCallback,\n                                     base::Unretained(this)));\n    run_loop_->Run();\n  }\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 186687, "func": "bool NormalPageArena::expandObject(HeapObjectHeader* header, size_t newSize) {\n  ASSERT(header->checkHeader());\n   if (header->payloadSize() >= newSize)\n     return true;\n   size_t allocationSize = ThreadHeap::allocationSizeFromSize(newSize);\n  ASSERT(allocationSize > header->size());\n  size_t expandSize = allocationSize - header->size();\n  if (isObjectAllocatedAtAllocationPoint(header) &&\n      expandSize <= m_remainingAllocationSize) {\n    m_currentAllocationPoint += expandSize;\n    ASSERT(m_remainingAllocationSize >= expandSize);\n    setRemainingAllocationSize(m_remainingAllocationSize - expandSize);\n    SET_MEMORY_ACCESSIBLE(header->payloadEnd(), expandSize);\n    header->setSize(allocationSize);\n    ASSERT(findPageFromAddress(header->payloadEnd() - 1));\n    return true;\n  }\n  return false;\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 7881, "func": "int64_t xbzrle_cache_resize(int64_t new_size)\n{\n    PageCache *new_cache;\n    int64_t ret;\n\n    if (new_size < TARGET_PAGE_SIZE) {\n        return -1;\n    }\n\n    XBZRLE_cache_lock();\n\n    if (XBZRLE.cache != NULL) {\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n            goto out_new_size;\n        }\n        new_cache = cache_init(new_size / TARGET_PAGE_SIZE,\n                                        TARGET_PAGE_SIZE);\n        if (!new_cache) {\n            error_report(\"Error creating cache\");\n            ret = -1;\n            goto out;\n        }\n\n        cache_fini(XBZRLE.cache);\n        XBZRLE.cache = new_cache;\n    }\n\nout_new_size:\n    ret = pow2floor(new_size);\nout:\n    XBZRLE_cache_unlock();\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 7909, "func": "static void cfunbody(JF, js_Ast *name, js_Ast *params, js_Ast *body)\n{\n\tF->lightweight = 1;\n\tF->arguments = 0;\n\n\tif (F->script)\n\t\tF->lightweight = 0;\n\n\tif (body)\n\t\tanalyze(J, F, body);\n\n\tcparams(J, F, params);\n\n\tif (name) {\n\t\temit(J, F, OP_CURRENT);\n\t\tif (F->lightweight) {\n\t\t\taddlocal(J, F, name, 0);\n\t\t\temit(J, F, OP_INITLOCAL);\n\t\t\temitraw(J, F, findlocal(J, F, name->string));\n\t\t} else {\n\t\t\temitstring(J, F, OP_INITVAR, name->string);\n\t\t}\n\t}\n\n\tif (body) {\n\t\tcvardecs(J, F, body);\n\t\tcfundecs(J, F, body);\n\t}\n\n\tif (F->script) {\n\t\temit(J, F, OP_UNDEF);\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_RETURN);\n\t} else {\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_UNDEF);\n\t\temit(J, F, OP_RETURN);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8026, "func": "void vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                            int32_t encoding)\n{\n    vnc_write_u16(vs, x);\n    vnc_write_u16(vs, y);\n    vnc_write_u16(vs, w);\n    vnc_write_u16(vs, h);\n\n    vnc_write_s32(vs, encoding);\n}\n", "target": 0, "flaw_line_index": ""}
