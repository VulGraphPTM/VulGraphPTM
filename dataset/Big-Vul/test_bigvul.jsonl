{"idx": 8975, "func": "static void vmxnet3_activate_device(VMXNET3State *s)\n{\n    int i;\n    static const uint32_t VMXNET3_DEF_TX_THRESHOLD = 1;\n    PCIDevice *d = PCI_DEVICE(s);\n    hwaddr qdescr_table_pa;\n    uint64_t pa;\n    uint32_t size;\n\n    if (!vmxnet3_verify_driver_magic(d, s->drv_shmem)) {\n        VMW_ERPRN(\"Device configuration received from driver is invalid\");\n        return;\n    }\n\n    if (s->device_active) {\n        VMW_CFPRN(\"Vmxnet3 device is active\");\n        return;\n    }\n\n    vmxnet3_adjust_by_guest_type(s);\n    vmxnet3_update_features(s);\n    vmxnet3_update_pm_state(s);\n    vmxnet3_setup_rx_filtering(s);\n    s->mtu = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, devRead.misc.mtu);\n    VMW_CFPRN(\"MTU is %u\", s->mtu);\n\n    s->max_rx_frags =\n        VMXNET3_READ_DRV_SHARED16(d, s->drv_shmem, devRead.misc.maxNumRxSG);\n\n    if (s->max_rx_frags == 0) {\n        s->max_rx_frags = 1;\n    }\n\n    VMW_CFPRN(\"Max RX fragments is %u\", s->max_rx_frags);\n\n    s->event_int_idx =\n        VMXNET3_READ_DRV_SHARED8(d, s->drv_shmem, devRead.intrConf.eventIntrIdx);\n    assert(vmxnet3_verify_intx(s, s->event_int_idx));\n    VMW_CFPRN(\"Events interrupt line is %u\", s->event_int_idx);\n\n    s->auto_int_masking =\n        VMXNET3_READ_DRV_SHARED8(d, s->drv_shmem, devRead.intrConf.autoMask);\n    VMW_CFPRN(\"Automatic interrupt masking is %d\", (int)s->auto_int_masking);\n\n    s->txq_num =\n        VMXNET3_READ_DRV_SHARED8(d, s->drv_shmem, devRead.misc.numTxQueues);\n    s->rxq_num =\n        VMXNET3_READ_DRV_SHARED8(d, s->drv_shmem, devRead.misc.numRxQueues);\n\n    VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n    vmxnet3_validate_queues(s);\n\n    qdescr_table_pa =\n        VMXNET3_READ_DRV_SHARED64(d, s->drv_shmem, devRead.misc.queueDescPA);\n    VMW_CFPRN(\"TX queues descriptors table is at 0x%\" PRIx64, qdescr_table_pa);\n\n    s->max_tx_frags = 0;\n\n    for (i = 0; i < s->txq_num; i++) {\n        hwaddr qdescr_pa =\n            qdescr_table_pa + i * sizeof(struct Vmxnet3_TxQueueDesc);\n\n        s->txq_descr[i].intr_idx =\n            VMXNET3_READ_TX_QUEUE_DESCR8(d, qdescr_pa, conf.intrIdx);\n        assert(vmxnet3_verify_intx(s, s->txq_descr[i].intr_idx));\n\n        VMW_CFPRN(\"TX Queue %d interrupt: %d\", i, s->txq_descr[i].intr_idx);\n\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(d, qdescr_pa, conf.txRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(d, qdescr_pa, conf.txRingSize);\n\n        vmxnet3_ring_init(d, &s->txq_descr[i].tx_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxDesc), false);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TX\", i, &s->txq_descr[i].tx_ring);\n\n        s->max_tx_frags += size;\n\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(d, qdescr_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(d, qdescr_pa, conf.compRingSize);\n        vmxnet3_ring_init(d, &s->txq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxCompDesc), true);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TXC\", i, &s->txq_descr[i].comp_ring);\n\n        s->txq_descr[i].tx_stats_pa =\n            qdescr_pa + offsetof(struct Vmxnet3_TxQueueDesc, stats);\n\n        memset(&s->txq_descr[i].txq_stats, 0,\n               sizeof(s->txq_descr[i].txq_stats));\n\n        VMXNET3_WRITE_TX_QUEUE_DESCR32(d, qdescr_pa,\n                                       ctrl.txThreshold,\n                                       VMXNET3_DEF_TX_THRESHOLD);\n    }\n\n    VMW_CFPRN(\"Max TX fragments is %u\", s->max_tx_frags);\n    net_tx_pkt_init(&s->tx_pkt, PCI_DEVICE(s),\n                    s->max_tx_frags, s->peer_has_vhdr);\n    net_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    for (i = 0; i < s->rxq_num; i++) {\n        int j;\n        hwaddr qd_pa =\n            qdescr_table_pa + s->txq_num * sizeof(struct Vmxnet3_TxQueueDesc) +\n            i * sizeof(struct Vmxnet3_RxQueueDesc);\n\n        s->rxq_descr[i].intr_idx =\n            VMXNET3_READ_TX_QUEUE_DESCR8(d, qd_pa, conf.intrIdx);\n        assert(vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx));\n\n        VMW_CFPRN(\"RX Queue %d interrupt: %d\", i, s->rxq_descr[i].intr_idx);\n\n        for (j = 0; j < VMXNET3_RX_RINGS_PER_QUEUE; j++) {\n            pa = VMXNET3_READ_RX_QUEUE_DESCR64(d, qd_pa, conf.rxRingBasePA[j]);\n            size = VMXNET3_READ_RX_QUEUE_DESCR32(d, qd_pa, conf.rxRingSize[j]);\n            vmxnet3_ring_init(d, &s->rxq_descr[i].rx_ring[j], pa, size,\n                              sizeof(struct Vmxnet3_RxDesc), false);\n            VMW_CFPRN(\"RX queue %d:%d: Base: %\" PRIx64 \", Size: %d\",\n                      i, j, pa, size);\n        }\n\n        pa = VMXNET3_READ_RX_QUEUE_DESCR64(d, qd_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_RX_QUEUE_DESCR32(d, qd_pa, conf.compRingSize);\n        vmxnet3_ring_init(d, &s->rxq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_RxCompDesc), true);\n        VMW_CFPRN(\"RXC queue %d: Base: %\" PRIx64 \", Size: %d\", i, pa, size);\n\n        s->rxq_descr[i].rx_stats_pa =\n            qd_pa + offsetof(struct Vmxnet3_RxQueueDesc, stats);\n        memset(&s->rxq_descr[i].rxq_stats, 0,\n               sizeof(s->rxq_descr[i].rxq_stats));\n    }\n\n    vmxnet3_validate_interrupts(s);\n\n    smp_wmb();\n\n    vmxnet3_reset_mac(s);\n\n    s->device_active = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187356, "func": "PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)\n     : content::RenderFrameObserver(render_frame),\n       logging_state_active_(false),\n       was_username_autofilled_(false),\n      was_password_autofilled_(false),\n      weak_ptr_factory_(this) {\n   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));\n }\n", "target": 1, "flaw_line_index": "5,6"}
{"idx": 8907, "func": "GLint64 vrend_renderer_get_timestamp(void)\n{\n   GLint64 v;\n   glGetInteger64v(GL_TIMESTAMP, &v);\n   return v;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8501, "func": "UINT CSoundFile::WriteSample(FILE *f, MODINSTRUMENT *pins, UINT nFlags, UINT nMaxLen)\n{\n\tUINT len = 0, bufcount;\n\tsigned char buffer[4096];\n\tsigned char *pSample = (signed char *)pins->pSample;\n\tUINT nLen = pins->nLength;\n\n\tif ((nMaxLen) && (nLen > nMaxLen)) nLen = nMaxLen;\n\tif ((!pSample) || (f == NULL) || (!nLen)) return 0;\n\tswitch(nFlags)\n\t{\n#ifndef NO_PACKING\n\tcase RS_ADPCM4:\n\t\t{\n\t\t\tint pos;\n\t\t\tlen = (nLen + 1) / 2;\n\t\t\tfwrite(CompressionTable, 16, 1, f);\n\t\t\tbufcount = 0;\n\t\t\tpos = 0;\n\t\t\tfor (UINT j=0; j<len; j++)\n\t\t\t{\n\t\t\t\tBYTE b;\n\t\t\t\tb = PackSample(pos, (int)pSample[j*2]);\n\t\t\t\tb |= PackSample(pos, (int)pSample[j*2+1]) << 4;\n\t\t\t\tbuffer[bufcount++] = (signed char)b;\n\t\t\t\tif (bufcount >= sizeof(buffer))\n\t\t\t\t{\n\t\t\t\t\tfwrite(buffer, 1, bufcount, f);\n\t\t\t\t\tbufcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bufcount) fwrite(buffer, 1, bufcount, f);\n\t\t\tlen += 16;\n\t\t}\n\t\tbreak;\n#endif \n\n\tcase RS_PCM16U:\n\tcase RS_PCM16D:\n\tcase RS_PCM16S:\n\t\t{\n\t\t\tshort int *p = (short int *)pSample;\n\t\t\tint s_old = 0, s_ofs;\n\t\t\tlen = nLen * 2;\n\t\t\tbufcount = 0;\n\t\t\ts_ofs = (nFlags == RS_PCM16U) ? 0x8000 : 0;\n\t\t\tfor (UINT j=0; j<nLen; j++)\n\t\t\t{\n\t\t\t\tint s_new = *p;\n\t\t\t\tp++;\n\t\t\t\tif (pins->uFlags & CHN_STEREO)\n\t\t\t\t{\n\t\t\t\t\ts_new = (s_new + (*p) + 1) >> 1;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (nFlags == RS_PCM16D)\n\t\t\t\t{\n\t\t\t\t\t*((short *)(&buffer[bufcount])) = (short)(s_new - s_old);\n\t\t\t\t\ts_old = s_new;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t*((short *)(&buffer[bufcount])) = (short)(s_new + s_ofs);\n\t\t\t\t}\n\t\t\t\tbufcount += 2;\n\t\t\t\tif (bufcount >= sizeof(buffer) - 1)\n\t\t\t\t{\n\t\t\t\t\tfwrite(buffer, 1, bufcount, f);\n\t\t\t\t\tbufcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bufcount) fwrite(buffer, 1, bufcount, f);\n\t\t}\n\t\tbreak;\n\n\n\tcase RS_STPCM8S:\n\tcase RS_STPCM8U:\n\tcase RS_STPCM8D:\n\t\t{\n\t\t\tint s_ofs = (nFlags == RS_STPCM8U) ? 0x80 : 0;\n\t\t\tfor (UINT iCh=0; iCh<2; iCh++)\n\t\t\t{\n\t\t\t\tsigned char *p = pSample + iCh;\n\t\t\t\tint s_old = 0;\n\n\t\t\t\tbufcount = 0;\n\t\t\t\tfor (UINT j=0; j<nLen; j++)\n\t\t\t\t{\n\t\t\t\t\tint s_new = *p;\n\t\t\t\t\tp += 2;\n\t\t\t\t\tif (nFlags == RS_STPCM8D)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer[bufcount++] = (signed char)(s_new - s_old);\n\t\t\t\t\t\ts_old = s_new;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer[bufcount++] = (signed char)(s_new + s_ofs);\n\t\t\t\t\t}\n\t\t\t\t\tif (bufcount >= sizeof(buffer))\n\t\t\t\t\t{\n\t\t\t\t\t\tfwrite(buffer, 1, bufcount, f);\n\t\t\t\t\t\tbufcount = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bufcount) fwrite(buffer, 1, bufcount, f);\n\t\t\t}\n\t\t}\n\t\tlen = nLen * 2;\n\t\tbreak;\n\n\tcase RS_STPCM16S:\n\tcase RS_STPCM16U:\n\tcase RS_STPCM16D:\n\t\t{\n\t\t\tint s_ofs = (nFlags == RS_STPCM16U) ? 0x8000 : 0;\n\t\t\tfor (UINT iCh=0; iCh<2; iCh++)\n\t\t\t{\n\t\t\t\tsigned short *p = ((signed short *)pSample) + iCh;\n\t\t\t\tint s_old = 0;\n\n\t\t\t\tbufcount = 0;\n\t\t\t\tfor (UINT j=0; j<nLen; j++)\n\t\t\t\t{\n\t\t\t\t\tint s_new = *p;\n\t\t\t\t\tp += 2;\n\t\t\t\t\tif (nFlags == RS_STPCM16D)\n\t\t\t\t\t{\n\t\t\t\t\t\t*((short *)(&buffer[bufcount])) = (short)(s_new - s_old);\n\t\t\t\t\t\ts_old = s_new;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t*((short *)(&buffer[bufcount])) = (short)(s_new + s_ofs);\n\t\t\t\t\t}\n\t\t\t\t\tbufcount += 2;\n\t\t\t\t\tif (bufcount >= sizeof(buffer))\n\t\t\t\t\t{\n\t\t\t\t\t\tfwrite(buffer, 1, bufcount, f);\n\t\t\t\t\t\tbufcount = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bufcount) fwrite(buffer, 1, bufcount, f);\n\t\t\t}\n\t\t}\n\t\tlen = nLen*4;\n\t\tbreak;\n\n\tcase RS_STIPCM8S:\n\tcase RS_STIPCM16S:\n\t\tlen = nLen * 2;\n\t\tif (nFlags == RS_STIPCM16S) len *= 2;\n\t\tfwrite(pSample, 1, len, f);\n\t\tbreak;\n\n\tdefault:\n\t\tlen = nLen;\n\t\tbufcount = 0;\n\t\t{\n\t\t\tsigned char *p = pSample;\n\t\t\tint sinc = (pins->uFlags & CHN_16BIT) ? 2 : 1;\n\t\t\tint s_old = 0, s_ofs = (nFlags == RS_PCM8U) ? 0x80 : 0;\n\t\t\tif (pins->uFlags & CHN_16BIT) p++;\n\t\t\tfor (UINT j=0; j<len; j++)\n\t\t\t{\n\t\t\t\tint s_new = (signed char)(*p);\n\t\t\t\tp += sinc;\n\t\t\t\tif (pins->uFlags & CHN_STEREO)\n\t\t\t\t{\n\t\t\t\t\ts_new = (s_new + ((int)*p) + 1) >> 1;\n\t\t\t\t\tp += sinc;\n\t\t\t\t}\n\t\t\t\tif (nFlags == RS_PCM8D)\n\t\t\t\t{\n\t\t\t\t\tbuffer[bufcount++] = (signed char)(s_new - s_old);\n\t\t\t\t\ts_old = s_new;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tbuffer[bufcount++] = (signed char)(s_new + s_ofs);\n\t\t\t\t}\n\t\t\t\tif (bufcount >= sizeof(buffer))\n\t\t\t\t{\n\t\t\t\t\tfwrite(buffer, 1, bufcount, f);\n\t\t\t\t\tbufcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bufcount) fwrite(buffer, 1, bufcount, f);\n\t\t}\n\t}\n\treturn len;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8360, "func": "static void mptsas_fetch_requests(void *opaque)\n{\n    MPTSASState *s = opaque;\n\n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n        return;\n    }\n    while (!MPTSAS_FIFO_EMPTY(s, request_post)) {\n        mptsas_fetch_request(s);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8343, "func": "static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    XHCITRB trb;\n    int length = 0;\n    dma_addr_t dequeue = ring->dequeue;\n    bool ccs = ring->ccs;\n    bool control_td_set = 0;\n\n    while (1) {\n        TRBType type;\n        pci_dma_read(pci_dev, dequeue, &trb, TRB_SIZE);\n        le64_to_cpus(&trb.parameter);\n        le32_to_cpus(&trb.status);\n        le32_to_cpus(&trb.control);\n\n        if ((trb.control & TRB_C) != ccs) {\n            return -length;\n        }\n\n        type = TRB_TYPE(trb);\n\n        if (type == TR_LINK) {\n            dequeue = xhci_mask64(trb.parameter);\n            if (trb.control & TRB_LK_TC) {\n                ccs = !ccs;\n            }\n            continue;\n        }\n\n        length += 1;\n        dequeue += TRB_SIZE;\n\n        if (type == TR_SETUP) {\n            control_td_set = 1;\n        } else if (type == TR_STATUS) {\n            control_td_set = 0;\n        }\n\n        if (!control_td_set && !(trb.control & TRB_TR_CH)) {\n            return length;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8536, "func": "static void ssh2_log_incoming_packet(Ssh ssh, struct Packet *pkt)\n{\n    int nblanks = 0;\n    struct logblank_t blanks[4];\n    char *str;\n    int slen;\n\n    pkt->savedpos = 0;\n\n    if (ssh->logomitdata &&\n        (pkt->type == SSH2_MSG_CHANNEL_DATA ||\n         pkt->type == SSH2_MSG_CHANNEL_EXTENDED_DATA)) {\n        ssh_pkt_getuint32(pkt);    \n        if (pkt->type == SSH2_MSG_CHANNEL_EXTENDED_DATA)\n            ssh_pkt_getuint32(pkt);    \n        blanks[nblanks].offset = pkt->savedpos + 4;\n        blanks[nblanks].type = PKTLOG_OMIT;\n        ssh_pkt_getstring(pkt, &str, &slen);\n        if (str) {\n            blanks[nblanks].len = slen;\n            nblanks++;\n        }\n    }\n\n    log_packet(ssh->logctx, PKT_INCOMING, pkt->type,\n               ssh2_pkt_type(ssh->pkt_kctx, ssh->pkt_actx, pkt->type),\n               pkt->body, pkt->length, nblanks, blanks, &pkt->sequence,\n               0, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187410, "func": "void RilSapSocket::sendDisconnect() {\n size_t encoded_size = 0;\n uint32_t written_size;\n size_t buffer_size = 0;\n pb_ostream_t ostream;\n bool success = false;\n\n    RIL_SIM_SAP_DISCONNECT_REQ disconnectReq;\n\n\n    if ((success = pb_get_encoded_size(&encoded_size, RIL_SIM_SAP_DISCONNECT_REQ_fields,\n         &disconnectReq)) && encoded_size <= INT32_MAX) {\n         buffer_size = encoded_size + sizeof(uint32_t);\n        uint8_t buffer[buffer_size];\n         written_size = htonl((uint32_t) encoded_size);\n         ostream = pb_ostream_from_buffer(buffer, buffer_size);\n         pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));\n        success = pb_encode(&ostream, RIL_SIM_SAP_DISCONNECT_REQ_fields, buffer);\n\n if(success) {\n pb_bytes_array_t *payload = (pb_bytes_array_t *)calloc(1,\n sizeof(pb_bytes_array_t) + written_size);\n if (!payload) {\n                RLOGE(\"sendDisconnect: OOM\");\n return;\n }\n            memcpy(payload->bytes, buffer, written_size);\n            payload->size = written_size;\n MsgHeader *hdr = (MsgHeader *)malloc(sizeof(MsgHeader));\n if (!hdr) {\n                RLOGE(\"sendDisconnect: OOM\");\n                free(payload);\n return;\n }\n            hdr->payload = payload;\n            hdr->type = MsgType_REQUEST;\n            hdr->id = MsgId_RIL_SIM_SAP_DISCONNECT;\n            hdr->error = Error_RIL_E_SUCCESS;\n            dispatchDisconnect(hdr);\n }\n\n         else {\n             RLOGE(\"Encode failed in send disconnect!\");\n         }\n     }\n }\n", "target": 1, "flaw_line_index": "14"}
{"idx": 187392, "func": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n if (size < 3) {\n return ERROR_MALFORMED;\n }\n\n    offset += 2; \n    size -= 2;\n\n unsigned streamDependenceFlag = mData[offset] & 0x80;\n unsigned URL_Flag = mData[offset] & 0x40;\n unsigned OCRstreamFlag = mData[offset] & 0x20;\n\n ++offset;\n\n     --size;\n \n     if (streamDependenceFlag) {\n         offset += 2;\n         size -= 2;\n     }\n\n if (URL_Flag) {\n if (offset >= size) {\n\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n \n     if (OCRstreamFlag) {\n         offset += 2;\n         size -= 2;\n \n if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n && offset - 2 < size\n && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            offset -= 2;\n            size += 2;\n\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n }\n }\n\n if (offset >= size) {\n return ERROR_MALFORMED;\n }\n\n uint8_t tag;\n size_t sub_offset, sub_size;\n status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n\n if (err != OK) {\n return err;\n }\n\n if (tag != kTag_DecoderConfigDescriptor) {\n return ERROR_MALFORMED;\n }\n\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n\n return err;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8767, "func": "static int good_hostname(const char *name)\n{\n\n\tfor (;;) {\n\t\tname = valid_domain_label(name);\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tif (!name[0])\n\t\t\treturn 1;\n\t\tname++;\n\t\tif (*name == '\\0')\n\t\t\treturn 1; \n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187561, "func": "status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)\n\n {\n     ALOGV(\"setDataSource\");\n     status_t err = UNKNOWN_ERROR;\n    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(source))) {\n            player.clear();\n }\n        err = attachNewPlayer(player);\n }\n return err;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8524, "func": "static void s_wrpkt_defer(Ssh ssh, struct Packet *pkt)\n{\n    int len, offset;\n    len = s_wrpkt_prepare(ssh, pkt, &offset);\n    if (ssh->deferred_len + len > ssh->deferred_size) {\n\tssh->deferred_size = ssh->deferred_len + len + 128;\n\tssh->deferred_send_data = sresize(ssh->deferred_send_data,\n\t\t\t\t\t  ssh->deferred_size,\n\t\t\t\t\t  unsigned char);\n    }\n    memcpy(ssh->deferred_send_data + ssh->deferred_len,\n\t   pkt->data + offset, len);\n    ssh->deferred_len += len;\n    ssh_free_packet(pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8559, "func": "static int ssh_comp_none_disable(void *handle)\n{\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8978, "func": "static void vmxnet3_class_init(ObjectClass *class, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(class);\n    PCIDeviceClass *c = PCI_DEVICE_CLASS(class);\n    VMXNET3Class *vc = VMXNET3_DEVICE_CLASS(class);\n\n    c->realize = vmxnet3_pci_realize;\n    c->exit = vmxnet3_pci_uninit;\n    c->vendor_id = PCI_VENDOR_ID_VMWARE;\n    c->device_id = PCI_DEVICE_ID_VMWARE_VMXNET3;\n    c->revision = PCI_DEVICE_ID_VMWARE_VMXNET3_REVISION;\n    c->romfile = \"efi-vmxnet3.rom\";\n    c->class_id = PCI_CLASS_NETWORK_ETHERNET;\n    c->subsystem_vendor_id = PCI_VENDOR_ID_VMWARE;\n    c->subsystem_id = PCI_DEVICE_ID_VMWARE_VMXNET3;\n    vc->parent_dc_realize = dc->realize;\n    dc->realize = vmxnet3_realize;\n    dc->desc = \"VMWare Paravirtualized Ethernet v3\";\n    dc->reset = vmxnet3_qdev_reset;\n    dc->vmsd = &vmstate_vmxnet3;\n    dc->props = vmxnet3_properties;\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8426, "func": "pvscsi_on_cmd_setup_msg_ring(PVSCSIState *s)\n{\n    PVSCSICmdDescSetupMsgRing *rc =\n        (PVSCSICmdDescSetupMsgRing *) s->curr_cmd_data;\n\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_SETUP_MSG_RING\");\n\n    if (!s->use_msg) {\n        return PVSCSI_COMMAND_PROCESSING_FAILED;\n    }\n\n    if (s->rings_info_valid) {\n        if (pvscsi_ring_init_msg(&s->rings, rc) < 0) {\n            return PVSCSI_COMMAND_PROCESSING_FAILED;\n        }\n        s->msg_ring_info_valid = TRUE;\n    }\n    return sizeof(PVSCSICmdDescSetupMsgRing) / sizeof(uint32_t);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188573, "func": "  void RunInvAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        in[j] = src[j] - dst[j];\n       }\n \n       fwd_txfm_ref(in, coeff, pitch_, tx_type_);\n \n      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n        EXPECT_GE(1u, error)\n            << \"Error: 16x16 IDCT has error \" << error\n             << \" at index \" << j;\n       }\n     }\n }\n", "target": 1, "flaw_line_index": "4,5,6,7,10,12,13,14,19,24,25"}
{"idx": 188210, "func": "OMX_ERRORTYPE SoftAACEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = OMX_AUDIO_AACObjectMain;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8997, "func": "static void vmxnet3_get_ring_from_file(QEMUFile *f, Vmxnet3Ring *r)\n{\n    r->pa = qemu_get_be64(f);\n    r->size = qemu_get_be32(f);\n    r->cell_size = qemu_get_be32(f);\n    r->next = qemu_get_be32(f);\n    r->gen = qemu_get_byte(f);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9061, "func": "static void vmxnet3_set_events(VMXNET3State *s, uint32_t val)\n{\n    uint32_t events;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    VMW_CBPRN(\"Setting events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, ecr) | val;\n    VMXNET3_WRITE_DRV_SHARED32(d, s->drv_shmem, ecr, events);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8800, "func": "static void free_fence_locked(struct vrend_fence *fence)\n{\n   list_del(&fence->fences);\n   glDeleteSync(fence->syncobj);\n   free(fence);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8976, "func": "static void vmxnet3_adjust_by_guest_type(VMXNET3State *s)\n{\n    struct Vmxnet3_GOSInfo gos;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    VMXNET3_READ_DRV_SHARED(d, s->drv_shmem, devRead.misc.driverInfo.gos,\n                            &gos, sizeof(gos));\n    s->rx_packets_compound =\n        (gos.gosType == VMXNET3_GOS_TYPE_WIN) ? false : true;\n\n    VMW_CFPRN(\"Guest type specifics: RXCOMPOUND: %d\", s->rx_packets_compound);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8399, "func": "void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,\n                               unsigned int *out_bytes,\n                               unsigned max_in_bytes, unsigned max_out_bytes)\n{\n    unsigned int idx;\n    unsigned int total_bufs, in_total, out_total;\n\n    idx = vq->last_avail_idx;\n\n    total_bufs = in_total = out_total = 0;\n    while (virtqueue_num_heads(vq, idx)) {\n        VirtIODevice *vdev = vq->vdev;\n        unsigned int max, num_bufs, indirect = 0;\n        VRingDesc desc;\n        hwaddr desc_pa;\n        int i;\n\n        max = vq->vring.num;\n        num_bufs = total_bufs;\n        i = virtqueue_get_head(vq, idx++);\n        desc_pa = vq->vring.desc;\n        vring_desc_read(vdev, &desc, desc_pa, i);\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n            if (desc.len % sizeof(VRingDesc)) {\n                error_report(\"Invalid size for indirect buffer table\");\n                exit(1);\n            }\n\n            if (num_bufs >= max) {\n                error_report(\"Looped descriptor\");\n                exit(1);\n            }\n\n            indirect = 1;\n            max = desc.len / sizeof(VRingDesc);\n            desc_pa = desc.addr;\n            num_bufs = i = 0;\n            vring_desc_read(vdev, &desc, desc_pa, i);\n        }\n\n        do {\n            if (++num_bufs > max) {\n                error_report(\"Looped descriptor\");\n                exit(1);\n            }\n\n            if (desc.flags & VRING_DESC_F_WRITE) {\n                in_total += desc.len;\n            } else {\n                out_total += desc.len;\n            }\n            if (in_total >= max_in_bytes && out_total >= max_out_bytes) {\n                goto done;\n            }\n        } while ((i = virtqueue_read_next_desc(vdev, &desc, desc_pa, max)) != max);\n\n        if (!indirect)\n            total_bufs = num_bufs;\n        else\n            total_bufs++;\n    }\ndone:\n    if (in_bytes) {\n        *in_bytes = in_total;\n    }\n    if (out_bytes) {\n        *out_bytes = out_total;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9163, "func": "static GLuint blit_get_frag_tex_writedepth(struct vrend_blitter_ctx *blit_ctx, int pipe_tex_target, unsigned nr_samples)\n{\n   assert(pipe_tex_target < PIPE_MAX_TEXTURE_TYPES);\n\n   if (nr_samples > 1) {\n      GLuint *shader = &blit_ctx->fs_texfetch_depth_msaa[pipe_tex_target];\n\n      if (!*shader) {\n         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex_target, nr_samples);\n\n         *shader = blit_build_frag_blit_msaa_depth(blit_ctx, tgsi_tex);\n      }\n      return *shader;\n\n   } else {\n      GLuint *shader = &blit_ctx->fs_texfetch_depth[pipe_tex_target];\n\n      if (!*shader) {\n         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex_target, 0);\n\n         *shader = blit_build_frag_tex_writedepth(blit_ctx, tgsi_tex);\n      }\n      return *shader;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9190, "func": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187473, "func": "int send_event (int fd, uint16_t type, uint16_t code, int32_t value)\n{\n struct uinput_event event;\n    BTIF_TRACE_DEBUG(\"%s type:%u code:%u value:%d\", __FUNCTION__,\n        type, code, value);\n    memset(&event, 0, sizeof(event));\n    event.type  = type;\n\n     event.code  = code;\n     event.value = value;\n \n    return write(fd, &event, sizeof(event));\n }\n", "target": 1, "flaw_line_index": "12"}
{"idx": 188036, "func": "FLACParser::FLACParser(\n const sp<DataSource> &dataSource,\n const sp<MetaData> &fileMetadata,\n const sp<MetaData> &trackMetadata)\n : mDataSource(dataSource),\n      mFileMetadata(fileMetadata),\n      mTrackMetadata(trackMetadata),\n      mInitCheck(false),\n      mMaxBufferSize(0),\n      mGroup(NULL),\n      mCopy(copyTrespass),\n      mDecoder(NULL),\n      mCurrentPos(0LL),\n      mEOF(false),\n\n       mStreamInfoValid(false),\n       mWriteRequested(false),\n       mWriteCompleted(false),\n      mWriteBuffer(NULL),\n       mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)\n {\n     ALOGV(\"FLACParser::FLACParser\");\n    memset(&mStreamInfo, 0, sizeof(mStreamInfo));\n    memset(&mWriteHeader, 0, sizeof(mWriteHeader));\n    mInitCheck = init();\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 187648, "func": " image_transform_png_set_expand_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n return bit_depth < 16;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187890, "func": "long long mkvparser::UnserializeUInt(IMkvReader* pReader, long long pos,\n                                     long long size) {\n  assert(pReader);\n  assert(pos >= 0);\n  if ((size <= 0) || (size > 8))\n     return E_FILE_FORMAT_INVALID;\n \n   long long result = 0;\n\n for (long long i = 0; i < size; ++i) {\n unsigned char b;\n\n const long status = pReader->Read(pos, 1, &b);\n\n if (status < 0)\n return status;\n\n    result <<= 8;\n    result |= b;\n\n ++pos;\n }\n\n\n   return result;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 187893, "func": "void* H264SwDecMalloc(u32 size)\n {\n \n #if defined(CHECK_MEMORY_USAGE)\n     static u32 numBytes = 0;\n    numBytes += size;\n     DEBUG((\"Allocated %d bytes, total %d\\n\", size, numBytes));\n #endif\n \n    return malloc(size);\n }\n", "target": 1, "flaw_line_index": "6,10"}
{"idx": 187742, "func": "int validation_gamma(int argc, char **argv)\n{\n double gamma[9] = { 2.2, 1.8, 1.52, 1.45, 1., 1/1.45, 1/1.52, 1/1.8, 1/2.2 };\n double maxerr;\n int i, silent=0, onlygamma=0;\n\n while (--argc > 0)\n if (strcmp(*++argv, \"-s\") == 0)\n         silent = 1;\n else if (strcmp(*argv, \"-g\") == 0)\n         onlygamma = 1;\n else\n {\n         fprintf(stderr, \"unknown argument %s\\n\", *argv);\n return 1;\n }\n\n if (!onlygamma)\n {\n      maxerr = 0;\n for (i=0; i<256; ++i)\n {\n double correct = -log(i/255.)/log(2.)*65536;\n double error = png_log8bit(i) - correct;\n\n if (i != 0 && fabs(error) > maxerr)\n            maxerr = fabs(error);\n\n\n          if (i == 0 && png_log8bit(i) != 0xffffffff ||\n              i != 0 && png_log8bit(i) != floor(correct+.5))\n          {\n            fprintf(stderr, \"8 bit log error: %d: got %u, expected %f\\n\",\n                i, png_log8bit(i), correct);\n          }\n       }\n \n       if (!silent)\n         printf(\"maximum 8 bit log error = %f\\n\", maxerr);\n \n       maxerr = 0;\n       for (i=0; i<65536; ++i)\n {\n double correct = -log(i/65535.)/log(2.)*65536;\n double error = png_log16bit(i) - correct;\n\n if (i != 0 && fabs(error) > maxerr)\n            maxerr = fabs(error);\n\n if (i == 0 && png_log16bit(i) != 0xffffffff ||\n             i != 0 && png_log16bit(i) != floor(correct+.5))\n\n          {\n             if (error > .68) \n             {\n               fprintf(stderr, \"16 bit log error: %d: got %u, expected %f\"\n                   \" error: %f\\n\", i, png_log16bit(i), correct, error);\n             }\n          }\n       }\n \n       if (!silent)\n         printf(\"maximum 16 bit log error = %f\\n\", maxerr);\n \n       maxerr = 0;\n for (i=0; i<=0xfffff; ++i)\n {\n double correct = exp(-i/65536. * log(2.)) * (65536. * 65536);\n double error = png_exp(i) - correct;\n\n if (fabs(error) > maxerr)\n\n             maxerr = fabs(error);\n          if (fabs(error) > 1883) \n          {\n            fprintf(stderr, \"32 bit exp error: %d: got %u, expected %f\"\n                   \" error: %f\\n\", i, png_exp(i), correct, error);\n          }\n       }\n \n       if (!silent)\n         printf(\"maximum 32 bit exp error = %f\\n\", maxerr);\n \n       maxerr = 0;\n       for (i=0; i<=0xfffff; ++i)\n {\n double correct = exp(-i/65536. * log(2.)) * 255;\n double error = png_exp8bit(i) - correct;\n\n if (fabs(error) > maxerr)\n\n             maxerr = fabs(error);\n          if (fabs(error) > .50002) \n          {\n            fprintf(stderr, \"8 bit exp error: %d: got %u, expected %f\"\n                   \" error: %f\\n\", i, png_exp8bit(i), correct, error);\n          }\n       }\n \n       if (!silent)\n         printf(\"maximum 8 bit exp error = %f\\n\", maxerr);\n \n       maxerr = 0;\n       for (i=0; i<=0xfffff; ++i)\n {\n double correct = exp(-i/65536. * log(2.)) * 65535;\n double error = png_exp16bit(i) - correct;\n\n if (fabs(error) > maxerr)\n\n             maxerr = fabs(error);\n          if (fabs(error) > .524) \n          {\n            fprintf(stderr, \"16 bit exp error: %d: got %u, expected %f\"\n                   \" error: %f\\n\", i, png_exp16bit(i), correct, error);\n          }\n       }\n \n       if (!silent)\n         printf(\"maximum 16 bit exp error = %f\\n\", maxerr);\n    } \n \n for (i=0; i<9; ++i)\n {\n unsigned j;\n double g = gamma[i];\n      png_fixed_point gfp = floor(g * PNG_FP_1 + .5);\n\n if (!silent)\n         printf(\"Test gamma %f\\n\", g);\n\n      maxerr = 0;\n for (j=0; j<256; ++j)\n {\n double correct = pow(j/255., g) * 255;\n         png_byte out = png_gamma_8bit_correct(j, gfp);\n double error = out - correct;\n\n if (fabs(error) > maxerr)\n            maxerr = fabs(error);\n if (out != floor(correct+.5))\n {\n            fprintf(stderr, \"8bit %d ^ %f: got %d expected %f error %f\\n\",\n               j, g, out, correct, error);\n }\n\n       }\n \n       if (!silent)\n         printf(\"gamma %f: maximum 8 bit error %f\\n\", g, maxerr);\n \n       maxerr = 0;\n       for (j=0; j<65536; ++j)\n {\n double correct = pow(j/65535., g) * 65535;\n         png_uint_16 out = png_gamma_16bit_correct(j, gfp);\n double error = out - correct;\n\n if (fabs(error) > maxerr)\n            maxerr = fabs(error);\n if (fabs(error) > 1.62)\n {\n            fprintf(stderr, \"16bit %d ^ %f: got %d expected %f error %f\\n\",\n               j, g, out, correct, error);\n }\n\n       }\n \n       if (!silent)\n         printf(\"gamma %f: maximum 16 bit error %f\\n\", g, maxerr);\n    }\n \n    return 0;\n}\n", "target": 1, "flaw_line_index": "33,39,56,63,76,82,95,101,114,120,150,170"}
{"idx": 187823, "func": "void Segment::AppendCluster(Cluster* pCluster) {\n  assert(pCluster);\n  assert(pCluster->m_index >= 0);\n \n   const long count = m_clusterCount + m_clusterPreloadCount;\n \n   long& size = m_clusterSize;\n  assert(size >= count);\n   const long idx = pCluster->m_index;\n  assert(idx == m_clusterCount);\n \n   if (count >= size) {\n     const long n = (size <= 0) ? 2048 : 2 * size;\n \n    Cluster** const qq = new Cluster* [n];\n    Cluster** q = qq;\n \n     Cluster** p = m_clusters;\n     Cluster** const pp = p + count;\n \n while (p != pp)\n *q++ = *p++;\n\n delete[] m_clusters;\n\n    m_clusters = qq;\n    size = n;\n\n   }\n \n   if (m_clusterPreloadCount > 0) {\n    assert(m_clusters);\n     Cluster** const p = m_clusters + m_clusterCount;\n    assert(*p);\n    assert((*p)->m_index < 0);\n \n     Cluster** q = p + m_clusterPreloadCount;\n    assert(q < (m_clusters + size));\n \n     for (;;) {\n       Cluster** const qq = q - 1;\n      assert((*qq)->m_index < 0);\n \n       *q = *qq;\n       q = qq;\n\n if (q == p)\n break;\n }\n }\n\n \n   m_clusters[idx] = pCluster;\n   ++m_clusterCount;\n }\n", "target": 1, "flaw_line_index": "2,3,8,10,15,16,32,34,35,38,42"}
{"idx": 187540, "func": "status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n uint32_t cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n\n     if (mStatus != NO_ERROR) {\n         return mStatus;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187329, "func": "xsltNumberFormatAlpha(xmlBufferPtr buffer,\n\t\t      double number,\n\t\t      int is_upper)\n{\n    char temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 1];\n    char *pointer;\n    int i;\n     char *alpha_list;\n     double alpha_size = (double)(sizeof(alpha_upper_list) - 1);\n \n     pointer = &temp_string[sizeof(temp_string)];\n     *(--pointer) = 0;\n    alpha_list = (is_upper) ? alpha_upper_list : alpha_lower_list;\n\n    for (i = 1; i < (int)sizeof(temp_string); i++) {\n \tnumber--;\n \t*(--pointer) = alpha_list[((int)fmod(number, alpha_size))];\n \tnumber /= alpha_size;\n\tif (fabs(number) < 1.0)\n \t    break; \n     }\n     xmlBufferCCat(buffer, pointer);\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 187605, "func": " load_fake(png_charp param, png_bytepp profile)\n {\n    char *endptr = NULL;\n   unsigned long long int size = strtoull(param, &endptr, 0\n);\n \n    if (endptr != NULL && *endptr == '*')\n {\n size_t len = strlen(++endptr);\n size_t result = (size_t)size;\n\n if (len == 0) len = 1; \n\n if (result == size && (*profile = malloc(result)) != NULL)\n {\n         png_bytep out = *profile;\n\n if (len == 1)\n            memset(out, *endptr, result);\n\n else\n {\n while (size >= len)\n {\n               memcpy(out, endptr, len);\n               out += len;\n               size -= len;\n }\n            memcpy(out, endptr, size);\n }\n\n return result;\n }\n\n else\n {\n         fprintf(stderr, \"%s: size exceeds system limits\\n\", param);\n         exit(1);\n }\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "5"}
{"idx": 9126, "func": "static int vrend_decode_set_uniform_buffer(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != VIRGL_SET_UNIFORM_BUFFER_SIZE)\n      return EINVAL;\n\n   uint32_t shader = get_buf_entry(ctx, VIRGL_SET_UNIFORM_BUFFER_SHADER_TYPE);\n   uint32_t index = get_buf_entry(ctx, VIRGL_SET_UNIFORM_BUFFER_INDEX);\n   uint32_t offset = get_buf_entry(ctx, VIRGL_SET_UNIFORM_BUFFER_OFFSET);\n   uint32_t blength = get_buf_entry(ctx, VIRGL_SET_UNIFORM_BUFFER_LENGTH);\n   uint32_t handle = get_buf_entry(ctx, VIRGL_SET_UNIFORM_BUFFER_RES_HANDLE);\n\n   if (shader >= PIPE_SHADER_TYPES)\n      return EINVAL;\n\n   if (index >= PIPE_MAX_CONSTANT_BUFFERS)\n      return EINVAL;\n\n   vrend_set_uniform_buffer(ctx->grctx, shader, index, offset, blength, handle);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8622, "func": "static inline void vmsvga_update_rect(struct vmsvga_state_s *s,\n                                      int x, int y, int w, int h)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    int line;\n    int bypl;\n    int width;\n    int start;\n    uint8_t *src;\n    uint8_t *dst;\n\n    if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {\n        x = 0;\n        y = 0;\n        w = surface_width(surface);\n        h = surface_height(surface);\n    }\n\n    bypl = surface_stride(surface);\n    width = surface_bytes_per_pixel(surface) * w;\n    start = surface_bytes_per_pixel(surface) * x + bypl * y;\n    src = s->vga.vram_ptr + start;\n    dst = surface_data(surface) + start;\n\n    for (line = h; line > 0; line--, src += bypl, dst += bypl) {\n        memcpy(dst, src, width);\n    }\n    dpy_gfx_update(s->vga.con, x, y, w, h);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188092, "func": "WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)\n{\n    WORD32 ret = IV_SUCCESS;\n codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    WORD32 proc_idx = 0;\n    WORD32 prev_proc_idx = 0;\n\n    ps_codec->i4_error_code = 0;\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size; \n }\n if(ps_codec->i4_init_done != 1)\n {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;\n return IV_FAIL;\n }\n\n if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;\n return IV_FAIL;\n }\n\n if(ps_codec->i4_reset_flag)\n {\n        ps_codec->i4_flush_mode = 1;\n }\n\n if(0 == ps_codec->i4_flush_mode)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)\n {\n if((WORD32)ps_dec_ip->u4_num_Bytes > 0)\n                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;\n else\n                ps_dec_op->u4_num_bytes_consumed = 0;\n\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n\n#ifdef APPLY_CONCEALMENT\n {\n        WORD32 num_mbs;\n\n        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;\n        ps_codec->mb_count = 0;\n        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));\n }\n#endif\n\n if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)\n {\n        UWORD32 i;\n if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)\n {\n if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n    ps_codec->u4_ts = ps_dec_ip->u4_ts;\n if(ps_codec->i4_flush_mode)\n {\n\n        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;\n        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(\n (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);\n if((ps_codec->ps_disp_buf)\n && ((0 == ps_codec->i4_share_disp_buf)\n || (IV_YUV_420P\n == ps_codec->e_chroma_fmt)))\n {\n\n process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];\n if(0 == ps_proc->i4_init_done)\n {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n }\n\n            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,\n                                  ps_codec->i4_disp_ht);\n\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n }\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n if(1 == ps_dec_op->u4_output_present)\n {\n            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n if(ypos < 0)\n                ypos = 0;\n\n if(xpos < 0)\n                xpos = 0;\n\n            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                        xpos,\n                        ypos,\n                        ps_codec->e_chroma_fmt,\n                        ps_codec->i4_disp_wd,\n                        ps_codec->i4_disp_ht);\n }\n\n\n if(NULL == ps_codec->ps_disp_buf)\n {\n if(ps_codec->i4_reset_flag)\n {\n                ihevcd_init(ps_codec);\n }\n return (IV_FAIL);\n }\n\n return (IV_SUCCESS);\n\n }\n if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))\n {\n        WORD32 buf_status;\n        buf_status = 1;\n if(ps_codec->pv_pic_buf_mgr)\n            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);\n\n if(0 == buf_status)\n {\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return IV_FAIL;\n }\n }\n    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;\n    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;\n    ps_codec->s_parse.i4_end_of_frame = 0;\n\n    ps_codec->i4_pic_present = 0;\n    ps_codec->i4_slice_error = 0;\n    ps_codec->ps_disp_buf = NULL;\n\n if(ps_codec->i4_num_cores > 1)\n {\n        ithread_set_affinity(0);\n }\n while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)\n {\n        WORD32 nal_len;\n        WORD32 nal_ofst;\n        WORD32 bits_len;\n\n if(ps_codec->i4_slice_error)\n {\n slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;\n if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                ps_codec->i4_slice_error = 0;\n }\n\n if(ps_codec->pu1_bitsbuf_dynamic)\n {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;\n }\n else\n {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;\n }\n\n        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,\n                                                ps_codec->i4_bytes_remaining);\n\n        ps_codec->i4_nal_ofst = nal_ofst;\n {\n            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;\n\n            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);\n            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,\n                                        ps_codec->pu1_bitsbuf,\n                                        bytes_remaining,\n &nal_len, &bits_len);\n\n if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))\n {\n                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));\n }\n }\n        ps_codec->i4_num_emln_bytes = nal_len - bits_len;\n        ps_codec->i4_nal_len = nal_len;\n\n        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,\n                         bits_len);\n\n        ret = ihevcd_nal_unit(ps_codec);\n\n if(ps_codec->i4_pic_present &&\n (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))\n {\n if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||\n (ps_codec->i4_header_in_slice_mode))\n {\n slice_header_t *ps_slice_hdr_next;\n\n                ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n                ps_codec->i4_slice_error = 1;\n continue;\n }\n }\n\n \n         if(IHEVCD_IGNORE_SLICE == ret)\n         {\n             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n \n continue;\n }\n\n if((IVD_RES_CHANGED == ret) ||\n (IHEVCD_UNSUPPORTED_DIMENSIONS == ret))\n {\n break;\n }\n\n if(ret != IHEVCD_SLICE_IN_HEADER_MODE)\n {\n if((0 == ps_codec->i4_slice_error) ||\n (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))\n {\n                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n }\n if(ret != IHEVCD_SUCCESS)\n break;\n\n if(ps_codec->s_parse.i4_end_of_frame)\n break;\n }\n else\n {\n            ret = IHEVCD_SUCCESS;\n break;\n }\n\n if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)\n {\n            WORD32 ret;\n            ret = ihevcd_allocate_dynamic_bufs(ps_codec);\n if(ret != IV_SUCCESS)\n {\n                ihevcd_free_dynamic_bufs(ps_codec);\n                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;\n                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;\n\n return IV_FAIL;\n }\n }\n\n        BREAK_AFTER_SLICE_NAL();\n }\n\n if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))\n {\n        ps_codec->i4_error_code = ret;\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n return IV_FAIL;\n }\n\n if(1 == ps_codec->i4_pic_present)\n {\n        WORD32 i;\n sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n        ps_codec->i4_first_pic_done = 1;\n\n if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)\n {\n\n process_ctxt_t *ps_proc;\n\n            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n if((ps_codec->ps_disp_buf) &&\n ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))\n {\n if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||\n (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))\n for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)\n {\n proc_job_t s_job;\n                        IHEVCD_ERROR_T ret;\n                        s_job.i4_cmd = CMD_FMTCONV;\n                        s_job.i2_ctb_cnt = 0;\n                        s_job.i2_ctb_x = 0;\n                        s_job.i2_ctb_y = i;\n                        s_job.i2_slice_idx = 0;\n                        s_job.i4_tu_coeff_data_ofst = 0;\n                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,\n &s_job, sizeof(proc_job_t), 1);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n return (WORD32)ret;\n }\n }\n            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);\n\n while(1)\n {\n                IHEVCD_ERROR_T ret;\n proc_job_t s_job;\n process_ctxt_t *ps_proc;\n\n                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,\n sizeof(proc_job_t), 1);\n if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)\n break;\n\n                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;\n                ps_proc->i4_ctb_x = s_job.i2_ctb_x;\n                ps_proc->i4_ctb_y = s_job.i2_ctb_y;\n                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;\n\n if(CMD_PROCESS == s_job.i4_cmd)\n {\n                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);\n\n                    ihevcd_process(ps_proc);\n }\n else if(CMD_FMTCONV == s_job.i4_cmd)\n {\n sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;\n if(0 == ps_proc->i4_init_done)\n {\n                        ihevcd_init_proc_ctxt(ps_proc, 0);\n }\n\n                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));\n if(num_rows < 0)\n                        num_rows = 0;\n\n                    ihevcd_fmt_conv(ps_codec, ps_proc,\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,\n                                    num_rows);\n }\n }\n }\n else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||\n (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&\n (ps_codec->s_parse.i4_end_of_frame))\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];\n            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht\n - ps_codec->s_fmt_conv.i4_cur_row;\n if(0 == ps_proc->i4_init_done)\n {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n }\n\n if(ps_codec->s_fmt_conv.i4_num_rows < 0)\n                ps_codec->s_fmt_conv.i4_num_rows = 0;\n\n            ret = ihevcd_fmt_conv(ps_codec, ps_proc,\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                  ps_codec->s_fmt_conv.i4_cur_row,\n                                  ps_codec->s_fmt_conv.i4_num_rows);\n            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;\n\n }\n\n\n        DEBUG_DUMP_MV_MAP(ps_codec);\n\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,\n                                 BUF_MGR_REF);\n\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_REF);\n\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_DISP);\n\n        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,\n                                 ps_codec->as_process[proc_idx].ps_cur_pic,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);\n\n if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n\n for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)\n {\n if(ps_codec->ai4_process_thread_created[i])\n {\n                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);\n                ps_codec->ai4_process_thread_created[i] = 0;\n }\n }\n\n        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);\n if(ps_codec->u4_pic_cnt > 0)\n {\n            DEBUG_DUMP_PIC_PU(ps_codec);\n }\n        DEBUG_DUMP_PIC_BUFFERS(ps_codec);\n\n        ps_codec->u4_pic_cnt++;\n }\n    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n if(1 == ps_dec_op->u4_output_present)\n {\n        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n if(ypos < 0)\n            ypos = 0;\n\n if(xpos < 0)\n            xpos = 0;\n\n        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                    xpos,\n                    ypos,\n                    ps_codec->e_chroma_fmt,\n                    ps_codec->i4_disp_wd,\n                    ps_codec->i4_disp_ht);\n }\n\n\n return ret;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187980, "func": "status_t MPEG4Source::fragmentedRead(\n MediaBuffer **out, const ReadOptions *options) {\n\n    ALOGV(\"MPEG4Source::fragmentedRead\");\n\n    CHECK(mStarted);\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n\n int numSidxEntries = mSegments.size();\n if (numSidxEntries != 0) {\n int64_t totalTime = 0;\n off64_t totalOffset = mFirstMoofOffset;\n for (int i = 0; i < numSidxEntries; i++) {\n const SidxEntry *se = &mSegments[i];\n if (totalTime + se->mDurationUs > seekTimeUs) {\n if ((mode == ReadOptions::SEEK_NEXT_SYNC) ||\n (mode == ReadOptions::SEEK_CLOSEST_SYNC &&\n (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {\n                        totalTime += se->mDurationUs;\n                        totalOffset += se->mSize;\n }\n break;\n }\n                totalTime += se->mDurationUs;\n                totalOffset += se->mSize;\n }\n        mCurrentMoofOffset = totalOffset;\n        mCurrentSamples.clear();\n        mCurrentSampleIndex = 0;\n        parseChunk(&totalOffset);\n        mCurrentTime = totalTime * mTimescale / 1000000ll;\n }\n\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset = 0;\n size_t size;\n uint32_t cts = 0;\n bool isSyncSample = false;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n Sample lastSample = mCurrentSamples[mCurrentSamples.size() - 1];\n off64_t nextMoof = mNextMoofOffset; \n            mCurrentMoofOffset = nextMoof;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&nextMoof);\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n return ERROR_END_OF_STREAM;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n        offset = smpl->offset;\n        size = smpl->size;\n        cts = mCurrentTime;\n        mCurrentTime += smpl->duration;\n        isSyncSample = (mCurrentSampleIndex == 0); \n\n status_t err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n            ALOGV(\"acquire_buffer returned %d\", err);\n return err;\n }\n if (size > mBuffer->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());\n return ERROR_BUFFER_TOO_SMALL;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n const sp<MetaData> bufmeta = mBuffer->meta_data();\n    bufmeta->clear();\n if (smpl->encryptedsizes.size()) {\n        bufmeta->setData(kKeyPlainSizes, 0,\n                smpl->clearsizes.array(), smpl->clearsizes.size() * 4);\n        bufmeta->setData(kKeyEncryptedSizes, 0,\n                smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);\n        bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16); \n        bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);\n        bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);\n        bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);\n }\n\n if (!mIsAVC || mWantsNALFragments) {\n if (newBuffer) {\n if (!isInRange((size_t)0u, mBuffer->size(), size)) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"fragmentedRead ERROR_MALFORMED size %zu\", size);\n return ERROR_MALFORMED;\n }\n\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mNALLengthSize > SIZE_MAX - nal_size) {\n            ALOGE(\"b/24441553, b/24445122\");\n }\n\n if (mBuffer->range_length() - mNALLengthSize < nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n        ALOGV(\"whole NAL\");\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n void *data = NULL;\n bool isMalFormed = false;\n if (usesDRM) {\n if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) {\n                isMalFormed = true;\n } else {\n                data = mBuffer->data();\n }\n } else {\n int32_t max_size;\n if (mFormat == NULL\n || !mFormat->findInt32(kKeyMaxInputSize, &max_size)\n || !isInRange((size_t)0u, (size_t)max_size, size)) {\n                isMalFormed = true;\n } else {\n                data = mSrcBuffer;\n }\n }\n\n if (isMalFormed || data == NULL) {\n            ALOGE(\"isMalFormed size %zu\", size);\n if (mBuffer != NULL) {\n                mBuffer->release();\n                mBuffer = NULL;\n }\n return ERROR_MALFORMED;\n }\n        num_bytes_read = mDataSource->readAt(offset, data, size);\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n while (srcOffset < size) {\n                isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n size_t nalLength = 0;\n if (!isMalFormed) {\n                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                    srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength);\n }\n\n if (isMalFormed) {\n                    ALOGE(\"Video is malformed; nalLength %zu\", nalLength);\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                     continue;\n                 }\n \n                CHECK(dstOffset + 4 <= mBuffer->size());\n \n                 dstData[dstOffset++] = 0;\n                 dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n", "target": 1, "flaw_line_index": "268"}
{"idx": 188606, "func": " TileIndependenceTest()\n : EncoderTest(GET_PARAM(0)),\n        md5_fw_order_(),\n\n         md5_inv_order_(),\n         n_tiles_(GET_PARAM(1)) {\n     init_flags_ = VPX_CODEC_USE_PSNR;\n    vpx_codec_dec_cfg_t cfg;\n     cfg.w = 704;\n     cfg.h = 144;\n     cfg.threads = 1;\n    fw_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_->Control(VP9_INVERT_TILE_DECODE_ORDER, 1);\n }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 187464, "func": "static void *btif_hl_select_thread(void *arg){\n    fd_set org_set, curr_set;\n int r, max_curr_s, max_org_s;\n    UNUSED(arg);\n\n    BTIF_TRACE_DEBUG(\"entered btif_hl_select_thread\");\n    FD_ZERO(&org_set);\n    max_org_s = btif_hl_select_wakeup_init(&org_set);\n    BTIF_TRACE_DEBUG(\"max_s=%d \", max_org_s);\n\n for (;;)\n {\n        r = 0;\n\n         BTIF_TRACE_DEBUG(\"set curr_set = org_set \");\n         curr_set = org_set;\n         max_curr_s = max_org_s;\n        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);\n         BTIF_TRACE_DEBUG(\"select unblocked ret=%d\", ret);\n         if (ret == -1)\n         {\n            BTIF_TRACE_DEBUG(\"select() ret -1, exit the thread\");\n            btif_hl_thread_cleanup();\n            select_thread_id = -1;\n return 0;\n }\n else if (ret)\n {\n            BTIF_TRACE_DEBUG(\"btif_hl_select_wake_signaled, signal ret=%d\", ret);\n if (btif_hl_select_wake_signaled(&curr_set))\n {\n                r = btif_hl_select_wake_reset();\n                BTIF_TRACE_DEBUG(\"btif_hl_select_wake_signaled, signal:%d\", r);\n if (r == btif_hl_signal_select_wakeup || r == btif_hl_signal_select_close_connected )\n {\n                    btif_hl_select_wakeup_callback(&org_set, r);\n }\n else if( r == btif_hl_signal_select_exit)\n {\n                    btif_hl_thread_cleanup();\n                    BTIF_TRACE_DEBUG(\"Exit hl_select_thread for btif_hl_signal_select_exit\");\n return 0;\n }\n }\n\n            btif_hl_select_monitor_callback(&curr_set, &org_set);\n            max_org_s = btif_hl_update_maxfd(max_org_s);\n }\n else\n            BTIF_TRACE_DEBUG(\"no data, select ret: %d\\n\", ret);\n }\n    BTIF_TRACE_DEBUG(\"leaving hl_select_thread\");\n return 0;\n}\n", "target": 1, "flaw_line_index": "18"}
{"idx": 187586, "func": " int main(int argc __unused, char** argv)\n {\n     signal(SIGPIPE, SIG_IGN);\n     char value[PROPERTY_VALUE_MAX];\n     bool doLog = (property_get(\"ro.test_harness\", value, \"0\") > 0) && (atoi(value) == 1);\n pid_t childPid;\n if (doLog && (childPid = fork()) != 0) {\n        strcpy(argv[0], \"media.log\");\n        sp<ProcessState> proc(ProcessState::self());\n MediaLogService::instantiate();\n ProcessState::self()->startThreadPool();\n for (;;) {\n siginfo_t info;\n int ret = waitid(P_PID, childPid, &info, WEXITED | WSTOPPED | WCONTINUED);\n if (ret == EINTR) {\n continue;\n }\n if (ret < 0) {\n break;\n }\n char buffer[32];\n const char *code;\n switch (info.si_code) {\n case CLD_EXITED:\n                code = \"CLD_EXITED\";\n break;\n case CLD_KILLED:\n                code = \"CLD_KILLED\";\n break;\n case CLD_DUMPED:\n                code = \"CLD_DUMPED\";\n break;\n case CLD_STOPPED:\n                code = \"CLD_STOPPED\";\n break;\n case CLD_TRAPPED:\n                code = \"CLD_TRAPPED\";\n break;\n case CLD_CONTINUED:\n                code = \"CLD_CONTINUED\";\n break;\n default:\n                snprintf(buffer, sizeof(buffer), \"unknown (%d)\", info.si_code);\n                code = buffer;\n break;\n }\n struct rusage usage;\n            getrusage(RUSAGE_CHILDREN, &usage);\n            ALOG(LOG_ERROR, \"media.log\", \"pid %d status %d code %s user %ld.%03lds sys %ld.%03lds\",\n                    info.si_pid, info.si_status, code,\n                    usage.ru_utime.tv_sec, usage.ru_utime.tv_usec / 1000,\n                    usage.ru_stime.tv_sec, usage.ru_stime.tv_usec / 1000);\n            sp<IServiceManager> sm = defaultServiceManager();\n            sp<IBinder> binder = sm->getService(String16(\"media.log\"));\n if (binder != 0) {\n Vector<String16> args;\n                binder->dump(-1, args);\n }\n switch (info.si_code) {\n case CLD_EXITED:\n case CLD_KILLED:\n case CLD_DUMPED: {\n                ALOG(LOG_INFO, \"media.log\", \"exiting\");\n                _exit(0);\n }\n default:\n break;\n }\n }\n } else {\n if (doLog) {\n            prctl(PR_SET_PDEATHSIG, SIGKILL); \n            setpgid(0, 0); \n }\n InitializeIcuOrDie();\n        sp<ProcessState> proc(ProcessState::self());\n        sp<IServiceManager> sm = defaultServiceManager();\n        ALOGI(\"ServiceManager: %p\", sm.get());\n AudioFlinger::instantiate();\n MediaPlayerService::instantiate();\n ResourceManagerService::instantiate();\n CameraService::instantiate();\n AudioPolicyService::instantiate();\n SoundTriggerHwService::instantiate();\n RadioService::instantiate();\n        registerExtensions();\n ProcessState::self()->startThreadPool();\n IPCThreadState::self()->joinThreadPool();\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187445, "func": " static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)\n {\n    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);\n     if (ret < 0)\n     {\n         ERROR(\"ack failed (%s)\", strerror(errno));\n         if (errno == EINTR)\n         {\n            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);\n             if (ret < 0)\n             {\n                ERROR(\"ack failed (%s)\", strerror(errno));\n               skt_disconnect(common->ctrl_fd);\n               common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n return -1;\n }\n }\n else\n {\n               skt_disconnect(common->ctrl_fd);\n               common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n return -1;\n\n }\n }\n return ret;\n}\n", "target": 1, "flaw_line_index": "3,9"}
{"idx": 8447, "func": "pvscsi_ring_flush_cmp(PVSCSIRingInfo *mgr)\n{\n    smp_wmb();\n\n    trace_pvscsi_ring_flush_cmp(mgr->filled_cmp_ptr);\n\n    RS_SET_FIELD(mgr, cmpProdIdx, mgr->filled_cmp_ptr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8454, "func": "pvscsi_ring_pop_msg_descr(PVSCSIRingInfo *mgr)\n{\n    uint32_t free_msg_ptr =\n        mgr->filled_msg_ptr++ & mgr->msg_len_mask;\n    uint32_t free_msg_page =\n        free_msg_ptr / PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE;\n    uint32_t inpage_idx =\n        free_msg_ptr % PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE;\n    return mgr->msg_ring_pages_pa[free_msg_page] +\n           inpage_idx * sizeof(PVSCSIRingMsgDesc);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188173, "func": "asocket* find_local_socket(unsigned local_id, unsigned peer_id) {\n\n     asocket* s;\n     asocket* result = NULL;\n \n    adb_mutex_lock(&socket_list_lock);\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->id != local_id) {\n             continue;\n }\n if (peer_id == 0 || (s->peer && s->peer->id == peer_id)) {\n            result = s;\n\n         }\n         break;\n     }\n    adb_mutex_unlock(&socket_list_lock);\n \n     return result;\n }\n", "target": 1, "flaw_line_index": "6,17"}
{"idx": 187830, "func": "long Segment::DoLoadCluster(long long& pos, long& len) {\n if (m_pos < 0)\n return DoLoadClusterUnknownSize(pos, len);\n\n long long total, avail;\n\n long status = m_pReader->Length(&total, &avail);\n\n\n   if (status < 0)  \n     return status;\n \n  assert((total < 0) || (avail <= total));\n \n   const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n long long cluster_off = -1; \n long long cluster_size = -1; \n\n for (;;) {\n if ((total >= 0) && (m_pos >= total))\n return 1; \n\n if ((segment_stop >= 0) && (m_pos >= segment_stop))\n return 1; \n\n    pos = m_pos;\n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n\n       return E_BUFFER_NOT_FULL;\n \n     const long long idpos = pos;\n    const long long id = ReadUInt(m_pReader, idpos, len);\n \n    if (id < 0)  \n      return static_cast<long>(id);\n \n     pos += len;  \n \n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n    pos += len; \n\n\n if (size == 0) { \n      m_pos = pos;\n continue;\n }\n\n \n     const long long unknown_size = (1LL << (7 * len)) - 1;\n \n#if 0  \n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;  \n#endif\n     if ((segment_stop >= 0) && (size != unknown_size) &&\n         ((pos + size) > segment_stop)) {\n       return E_FILE_FORMAT_INVALID;\n     }\n \n#if 0  \n        len = static_cast<long>(size);\n        if ((pos + size) > avail)\n            return E_BUFFER_NOT_FULL;\n#endif\n     if (id == 0x0C53BB6B) {  \n       if (size == unknown_size)\n         return E_FILE_FORMAT_INVALID;  \n\n\n       if (m_pCues == NULL) {\n         const long long element_size = (pos - idpos) + size;\n \n        m_pCues = new Cues(this, pos, size, idpos, element_size);\n        assert(m_pCues);  \n       }\n \n       m_pos = pos + size;  \n continue;\n }\n\n if (id != 0x0F43B675) { \n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID; \n\n      m_pos = pos + size; \n continue;\n }\n\n\n    cluster_off = idpos - m_start; \n\n if (size != unknown_size)\n      cluster_size = size;\n\n\n     break;\n   }\n \n  assert(cluster_off >= 0);  \n \n   long long pos_;\n   long len_;\n\n  status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);\n\n if (status < 0) { \n    pos = pos_;\n    len = len_;\n\n return status;\n }\n\n\n\n\n   const long idx = m_clusterCount;\n \n   if (m_clusterPreloadCount > 0) {\n    assert(idx < m_clusterSize);\n \n     Cluster* const pCluster = m_clusters[idx];\n    assert(pCluster);\n    assert(pCluster->m_index < 0);\n \n     const long long off = pCluster->GetPosition();\n    assert(off >= 0);\n \n     if (off == cluster_off) {  \n       if (status == 0)  \n return E_FILE_FORMAT_INVALID;\n\n if (cluster_size >= 0)\n        pos += cluster_size;\n else {\n const long long element_size = pCluster->GetElementSize();\n\n if (element_size <= 0)\n return E_FILE_FORMAT_INVALID; \n\n        pos = pCluster->m_element_start + element_size;\n }\n\n      pCluster->m_index = idx; \n ++m_clusterCount;\n\n       --m_clusterPreloadCount;\n \n       m_pos = pos;  \n      assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n       return 0;  \n     }\n   }\n \n   if (status == 0) {  \n    if (cluster_size < 0)\n      return E_FILE_FORMAT_INVALID;  \n    pos += cluster_size;\n \n     if ((total >= 0) && (pos >= total)) {\n       m_pos = total;\n return 1; \n }\n\n if ((segment_stop >= 0) && (pos >= segment_stop)) {\n      m_pos = segment_stop;\n return 1; \n }\n\n    m_pos = pos;\n return 2; \n }\n\n\n \n   Cluster* const pCluster = Cluster::Create(this, idx, cluster_off);\n  assert(pCluster);\n \n  AppendCluster(pCluster);\n  assert(m_clusters);\n  assert(idx < m_clusterSize);\n  assert(m_clusters[idx] == pCluster);\n \n   if (cluster_size >= 0) {\n     pos += cluster_size;\n \n     m_pos = pos;\n    assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n     return 0;\n   }\n\n  m_pUnknownSize = pCluster;\n  m_pos = -pos;\n\n \n   return 0;  \n \n#if 0\n    if (cluster_size < 0) {  \n        const long long payload_pos = pos;  \n        for (;;) {  \n            if ((total >= 0) && (pos >= total))\n                break;\n            if ((segment_stop >= 0) && (pos >= segment_stop))\n                break;  \n            if ((pos + 1) > avail)\n            {\n                len = 1;\n                return E_BUFFER_NOT_FULL;\n            }\n            long long result = GetUIntLength(m_pReader, pos, len);\n            if (result < 0)  \n                return static_cast<long>(result);\n            if (result > 0)  \n                return E_BUFFER_NOT_FULL;\n            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n            if ((pos + len) > avail)\n                return E_BUFFER_NOT_FULL;\n            const long long idpos = pos;\n            const long long id = ReadUInt(m_pReader, idpos, len);\n            if (id < 0)  \n                return static_cast<long>(id);\n            if (id == 0x0F43B675)  \n                break;\n            if (id == 0x0C53BB6B)  \n                break;\n            switch (id)\n            {\n                case 0x20:  \n                case 0x23:  \n                case 0x67:  \n                case 0x2B:  \n                    break;\n                default:\n                    assert(false);\n                    break;\n            }\n            pos += len;  \n            if ((pos + 1) > avail)\n            {\n                len = 1;\n                return E_BUFFER_NOT_FULL;\n            }\n            result = GetUIntLength(m_pReader, pos, len);\n            if (result < 0)  \n                return static_cast<long>(result);\n            if (result > 0)  \n                return E_BUFFER_NOT_FULL;\n            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n            if ((pos + len) > avail)\n                return E_BUFFER_NOT_FULL;\n            const long long size = ReadUInt(m_pReader, pos, len);\n            if (size < 0)  \n                return static_cast<long>(size);\n            pos += len;  \n            if (size == 0)  \n                continue;\n            const long long unknown_size = (1LL << (7 * len)) - 1;\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;  \n            if ((segment_stop >= 0) && ((pos + size) > segment_stop))  \n                return E_FILE_FORMAT_INVALID;\n            pos += size;  \n            assert((segment_stop < 0) || (pos <= segment_stop));\n        }  \n        cluster_size = pos - payload_pos;\n        assert(cluster_size >= 0);\n        pos = payload_pos;  \n    }\n    if (m_clusterPreloadCount > 0)\n    {\n        assert(idx < m_clusterSize);\n        Cluster* const pCluster = m_clusters[idx];\n        assert(pCluster);\n        assert(pCluster->m_index < 0);\n        const long long off = pCluster->GetPosition();\n        assert(off >= 0);\n        if (off == cluster_off)  \n            return E_FILE_FORMAT_INVALID;  \n    }\n    m_pos = pos + cluster_size;  \n    assert((segment_stop < 0) || (m_pos <= segment_stop));\n    return 2;     \n#endif\n }\n", "target": 1, "flaw_line_index": "13,52,54,55,97,98,99,100,106,107,108,109,110,119,120,146,193,196,197,200,223,230,231,232,252,253,255,256,257,258,264,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332"}
{"idx": 8449, "func": "pvscsi_ring_flush_req(PVSCSIRingInfo *mgr)\n{\n    RS_SET_FIELD(mgr, reqConsIdx, mgr->consumed_ptr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188009, "func": " long vorbis_book_decodev_set(codebook *book,ogg_int32_t *a,\n\t\t\t     oggpack_buffer *b,int n,int point){\n   if(book->used_entries>0){\n     ogg_int32_t *v = book->dec_buf;\n     int i,j;\n\n\n     if (!v) return -1;\n     for(i=0;i<n;){\n       if(decode_map(book,b,v,point))return -1;\n      for (j=0;j<book->dim;j++)\n\ta[i++]=v[j];\n     }\n   }else{\n     int i,j;\n \n     for(i=0;i<n;){\n      for (j=0;j<book->dim;j++)\n\ta[i++]=0;\n     }\n   }\n \n return 0;\n}\n", "target": 1, "flaw_line_index": "2,11,12,18,19"}
{"idx": 8853, "func": "static void vrend_destroy_vertex_elements_object(void *obj_ptr)\n{\n   struct vrend_vertex_element_array *v = obj_ptr;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      glDeleteVertexArrays(1, &v->id);\n   }\n   FREE(v);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187656, "func": "image_transform_png_set_expand_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_expand(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9105, "func": "static int vrend_decode_destroy_object(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t handle = get_buf_entry(ctx, VIRGL_OBJ_DESTROY_HANDLE);\n\n   vrend_renderer_object_destroy(ctx->grctx, handle);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188501, "func": "int main(int argc, char *argv[]) {\n char *fin, *fout;\n FILE *fpin, *fpout;\n uint8_t *inbuf, *outbuf;\n uint8_t *inbuf_u, *outbuf_u;\n uint8_t *inbuf_v, *outbuf_v;\n\n   int f, frames;\n   int width, height, target_width, target_height;\n \n   if (argc < 5) {\n     printf(\"Incorrect parameters:\\n\");\n    usage(argv[0]);\n     return 1;\n   }\n \n  fin = argv[1];\n\n   fout = argv[4];\n   if (!parse_dim(argv[2], &width, &height)) {\n     printf(\"Incorrect parameters: %s\\n\", argv[2]);\n    usage(argv[0]);\n     return 1;\n   }\n   if (!parse_dim(argv[3], &target_width, &target_height)) {\n     printf(\"Incorrect parameters: %s\\n\", argv[3]);\n    usage(argv[0]);\n     return 1;\n   }\n \n   fpin = fopen(fin, \"rb\");\n   if (fpin == NULL) {\n     printf(\"Can't open file %s to read\\n\", fin);\n    usage(argv[0]);\n     return 1;\n   }\n   fpout = fopen(fout, \"wb\");\n   if (fpout == NULL) {\n     printf(\"Can't open file %s to write\\n\", fout);\n    usage(argv[0]);\n     return 1;\n   }\n   if (argc >= 6)\n    frames = atoi(argv[5]);\n else\n    frames = INT_MAX;\n\n  printf(\"Input size:  %dx%d\\n\",\n         width, height);\n  printf(\"Target size: %dx%d, Frames: \",\n         target_width, target_height);\n if (frames == INT_MAX)\n    printf(\"All\\n\");\n else\n    printf(\"%d\\n\", frames);\n\n  inbuf = (uint8_t*)malloc(width * height * 3 / 2);\n  outbuf = (uint8_t*)malloc(target_width * target_height * 3 / 2);\n  inbuf_u = inbuf + width * height;\n  inbuf_v = inbuf_u + width * height / 4;\n  outbuf_u = outbuf + target_width * target_height;\n  outbuf_v = outbuf_u + target_width * target_height / 4;\n  f = 0;\n while (f < frames) {\n if (fread(inbuf, width * height * 3 / 2, 1, fpin) != 1)\n break;\n    vp9_resize_frame420(inbuf, width, inbuf_u, inbuf_v, width / 2,\n                        height, width,\n                        outbuf, target_width, outbuf_u, outbuf_v,\n                        target_width / 2,\n                        target_height, target_width);\n    fwrite(outbuf, target_width * target_height * 3 / 2, 1, fpout);\n    f++;\n }\n  printf(\"%d frames processed\\n\", f);\n  fclose(fpin);\n  fclose(fpout);\n\n  free(inbuf);\n  free(outbuf);\n return 0;\n}\n", "target": 1, "flaw_line_index": "13,22,27,34,40"}
{"idx": 188298, "func": "bool Chapters::ExpandEditionsArray()\n{\n    if (m_editions_size > m_editions_count)\n        return true;  \n \n    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;\n \n    Edition* const editions = new (std::nothrow) Edition[size];\n \n    if (editions == NULL)\n        return false;\n \n    for (int idx = 0; idx < m_editions_count; ++idx)\n    {\n        m_editions[idx].ShallowCopy(editions[idx]);\n     }\n \n    delete[] m_editions;\n    m_editions = editions;\n \n    m_editions_size = size;\n    return true;\n }\n", "target": 1, "flaw_line_index": "2,3,4,6,8,10,11,13,14,15,18,19,21,22"}
{"idx": 8473, "func": "void CSoundFile::FreeSample(LPVOID p)\n{\n\tif (p)\n\t{\n\t\tGlobalFreePtr(((LPSTR)p)-16);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188243, "func": "OMX_ERRORTYPE SoftVorbis::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.vorbis\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioVorbis:\n {\n\n             const OMX_AUDIO_PARAM_VORBISTYPE *vorbisParams =\n                 (const OMX_AUDIO_PARAM_VORBISTYPE *)params;\n \n             if (vorbisParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8437, "func": "pvscsi_queue_pending_descriptor(PVSCSIState *s, SCSIDevice **d,\n                                struct PVSCSIRingReqDesc *descr)\n{\n    PVSCSIRequest *pvscsi_req;\n    uint8_t lun;\n\n    pvscsi_req = g_malloc0(sizeof(*pvscsi_req));\n    pvscsi_req->dev = s;\n    pvscsi_req->req = *descr;\n    pvscsi_req->cmp.context = pvscsi_req->req.context;\n    QTAILQ_INSERT_TAIL(&s->pending_queue, pvscsi_req, next);\n\n    *d = pvscsi_device_find(s, descr->bus, descr->target, descr->lun, &lun);\n    if (*d) {\n        pvscsi_req->lun = lun;\n    }\n\n    return pvscsi_req;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187763, "func": "zlib_end(struct zlib *zlib)\n{\n if (!zlib->global->quiet)\n {\n if (zlib->ok_bits < 16) \n {\n const char *reason;\n\n if (zlib->cksum)\n            reason = \"CHK\"; \n\n else if (zlib->ok_bits > zlib->file_bits)\n            reason = \"TFB\"; \n\n else if (zlib->ok_bits == zlib->file_bits)\n            reason = \"OK \";\n\n else\n            reason = \"OPT\"; \n\n         type_name(zlib->chunk->chunk_type, stdout);\n         printf(\" %s %s %d %d \", reason, zlib_flevel(zlib), zlib->file_bits,\n            zlib->ok_bits);\n         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);\n         putc(' ', stdout);\n         uarb_print(zlib->uncompressed_bytes, zlib->uncompressed_digits,\n            stdout);\n         putc(' ', stdout);\n         fputs(zlib->file->file_name, stdout);\n         putc('\\n', stdout);\n }\n\n else\n {\n          type_name(zlib->chunk->chunk_type, stdout);\n          printf(\" SKP %s %d %s \", zlib_flevel(zlib), zlib->file_bits,\n            zlib_rc(zlib));\n         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);\n         putc(' ', stdout);\n         emit_string(zlib->z.msg ? zlib->z.msg : \"[no_message]\", stdout);\n         putc(' ', stdout);\n         fputs(zlib->file->file_name, stdout);\n         putc('\\n', stdout);\n }\n }\n\n if (zlib->state >= 0)\n {\n      zlib->rc = inflateEnd(&zlib->z);\n\n if (zlib->rc != Z_OK)\n         zlib_message(zlib, 1\n);\n }\n\n   CLEAR(*zlib);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187895, "func": "int main(int argc, char **argv)\n{\n\n    u8 *byteStrmStart;\n    u8 *byteStrm;\n    u32 strmLen;\n    u32 picSize;\n    H264SwDecInst decInst;\n    H264SwDecRet ret;\n    H264SwDecInput decInput;\n    H264SwDecOutput decOutput;\n    H264SwDecPicture decPicture;\n    H264SwDecInfo decInfo;\n    u32 picNumber;\n\n FILE *finput;\n FILE *foutput;\n\n if (argc < 2)\n {\n        printf( \"Usage: %s file.h264\\n\", argv[0]);\n return -1;\n }\n\n    foutput = fopen(\"out.yuv\", \"wb\");\n if (foutput == NULL)\n {\n        printf(\"UNABLE TO OPEN OUTPUT FILE\\n\");\n return -1;\n }\n\n    finput = fopen(argv[argc-1], \"rb\");\n if (finput == NULL)\n {\n        printf(\"UNABLE TO OPEN INPUT FILE\\n\");\n return -1;\n }\n\n    fseek(finput, 0L, SEEK_END);\n    strmLen = (u32)ftell(finput);\n\n     rewind(finput);\n \n    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8)*strmLen);\n     if (byteStrm == NULL)\n     {\n         printf(\"UNABLE TO ALLOCATE MEMORY\\n\");\n return -1;\n }\n\n    fread(byteStrm, sizeof(u8), strmLen, finput);\n    fclose(finput);\n\n    ret = H264SwDecInit(&decInst, 0);\n if (ret != H264SWDEC_OK)\n {\n        printf(\"DECODER INITIALIZATION FAILED\\n\");\n return -1;\n }\n\n    decInput.pStream = byteStrmStart;\n    decInput.dataLen = strmLen;\n    decInput.intraConcealmentMethod = 0;\n\n    picNumber = 0;\n\n\n do\n {\n        ret = H264SwDecDecode(decInst, &decInput, &decOutput);\n\n switch(ret)\n {\n\n case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY:\n\n                ret = H264SwDecGetInfo(decInst, &decInfo);\n if (ret != H264SWDEC_OK)\n return -1;\n\n                picSize = decInfo.picWidth * decInfo.picHeight;\n                picSize = (3 * picSize)/2;\n\n                printf(\"Width %d Height %d\\n\",\n                    decInfo.picWidth, decInfo.picHeight);\n\n                decInput.dataLen -=\n (u32)(decOutput.pStrmCurrPos - decInput.pStream);\n                decInput.pStream = decOutput.pStrmCurrPos;\n break;\n\n case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY:\n case H264SWDEC_PIC_RDY:\n\n                decInput.dataLen -=\n (u32)(decOutput.pStrmCurrPos - decInput.pStream);\n                decInput.pStream = decOutput.pStrmCurrPos;\n\n while (H264SwDecNextPicture(decInst, &decPicture, 0) ==\n                    H264SWDEC_PIC_RDY) { picNumber++;\n\n                    printf(\"PIC %d, type %s, concealed %d\\n\", picNumber,\n                        decPicture.isIdrPicture ? \"IDR\" : \"NON-IDR\",\n                        decPicture.nbrOfErrMBs);\n                    fflush(stdout);\n\n\n WriteOutput(foutput, (u8*)decPicture.pOutputPicture,\n                        picSize);\n }\n\n break;\n\n case H264SWDEC_EVALUATION_LIMIT_EXCEEDED:\n                printf(\"EVALUATION LIMIT REACHED\\n\");\n goto end;\n\n default:\n                printf(\"UNRECOVERABLE ERROR\\n\");\n return -1;\n }\n } while (decInput.dataLen > 0);\n\nend:\n\n while (H264SwDecNextPicture(decInst, &decPicture, 1) ==\n        H264SWDEC_PIC_RDY) {\n\n        picNumber++;\n\n        printf(\"PIC %d, type %s, concealed %d\\n\", picNumber,\n            decPicture.isIdrPicture ? \"IDR\" : \"NON-IDR\",\n            decPicture.nbrOfErrMBs);\n        fflush(stdout);\n\n\n WriteOutput(foutput, (u8*)decPicture.pOutputPicture, picSize);\n }\n\n\n\n    H264SwDecRelease(decInst);\n\n    fclose(foutput);\n\n    free(byteStrmStart);\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": "44"}
{"idx": 187834, "func": "const Cluster* Segment::FindOrPreloadCluster(long long requested_pos) {\n if (requested_pos < 0)\n return 0;\n\n Cluster** const ii = m_clusters;\n Cluster** i = ii;\n\n const long count = m_clusterCount + m_clusterPreloadCount;\n\n Cluster** const jj = ii + count;\n Cluster** j = jj;\n\n while (i < j) {\n\n Cluster** const k = i + (j - i) / 2;\n    assert(k < jj);\n\n Cluster* const pCluster = *k;\n    assert(pCluster);\n\n\n const long long pos = pCluster->GetPosition();\n    assert(pos >= 0);\n\n if (pos < requested_pos)\n      i = k + 1;\n else if (pos > requested_pos)\n      j = k;\n else\n return pCluster;\n }\n\n  assert(i == j);\n\n \n   Cluster* const pCluster = Cluster::Create(this, -1, requested_pos);\n  assert(pCluster);\n \n   const ptrdiff_t idx = i - m_clusters;\n \n  PreloadCluster(pCluster, idx);\n   assert(m_clusters);\n   assert(m_clusterPreloadCount > 0);\n   assert(m_clusters[idx] == pCluster);\n\n return pCluster;\n}\n", "target": 1, "flaw_line_index": "45,46"}
{"idx": 8782, "func": "static void udhcp_run_script(struct dhcp_packet *packet, const char *name)\n{\n\tchar **envp, **curr;\n\tchar *argv[3];\n\n\tenvp = fill_envp(packet);\n\n\tlog1(\"executing %s %s\", client_config.script, name);\n\targv[0] = (char*) client_config.script;\n\targv[1] = (char*) name;\n\targv[2] = NULL;\n\tspawn_and_wait(argv);\n\n\tfor (curr = envp; *curr; curr++) {\n\t\tlog2(\" %s\", *curr);\n\t\tbb_unsetenv_and_free(*curr);\n\t}\n\tfree(envp);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8381, "func": "static void mptsas_request_cancelled(SCSIRequest *sreq)\n{\n    MPTSASRequest *req = sreq->hba_private;\n    MPIMsgSCSIIOReply reply;\n\n    memset(&reply, 0, sizeof(reply));\n    reply.TargetID          = req->scsi_io.TargetID;\n    reply.Bus               = req->scsi_io.Bus;\n    reply.MsgLength         = sizeof(reply) / 4;\n    reply.Function          = req->scsi_io.Function;\n    reply.CDBLength         = req->scsi_io.CDBLength;\n    reply.SenseBufferLength = req->scsi_io.SenseBufferLength;\n    reply.MsgFlags          = req->scsi_io.MsgFlags;\n    reply.MsgContext        = req->scsi_io.MsgContext;\n    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;\n    reply.IOCStatus         = MPI_IOCSTATUS_SCSI_TASK_TERMINATED;\n\n    mptsas_fix_scsi_io_reply_endianness(&reply);\n    mptsas_post_reply(req->dev, (MPIDefaultReply *)&reply);\n    mptsas_free_request(req);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8740, "func": "vcard_init_buffer_response(VCard *card, unsigned char *buf, int len)\n{\n    VCardResponse *response;\n    VCardBufferResponse *buffer_response;\n\n    buffer_response = vcard_get_buffer_response(card);\n    if (buffer_response) {\n        vcard_set_buffer_response(card, NULL);\n        vcard_buffer_response_delete(buffer_response);\n    }\n    buffer_response = vcard_buffer_response_new(buf, len);\n    if (buffer_response == NULL) {\n        return NULL;\n    }\n    response = vcard_response_new_status_bytes(VCARD7816_SW1_RESPONSE_BYTES,\n                                               len > 255 ? 0 : len);\n    if (response == NULL) {\n        return NULL;\n    }\n    vcard_set_buffer_response(card, buffer_response);\n    return response;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187599, "func": "main(void)\n{\n\n    fwrite(signature, sizeof signature, 1, stdout);\n    put_chunk(IHDR, sizeof IHDR);\n \n   for(;;)\n       put_chunk(unknown, sizeof unknown);\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 9025, "func": "vmxnet3_on_rx_done_update_stats(VMXNET3State *s,\n                                int qidx,\n                                Vmxnet3PktStatus status)\n{\n    struct UPT1_RxStats *stats = &s->rxq_descr[qidx].rxq_stats;\n    size_t tot_len = net_rx_pkt_get_total_len(s->rx_pkt);\n\n    switch (status) {\n    case VMXNET3_PKT_STATUS_OUT_OF_BUF:\n        stats->pktsRxOutOfBuf++;\n        break;\n\n    case VMXNET3_PKT_STATUS_ERROR:\n        stats->pktsRxError++;\n        break;\n    case VMXNET3_PKT_STATUS_OK:\n        switch (net_rx_pkt_get_packet_type(s->rx_pkt)) {\n        case ETH_PKT_BCAST:\n            stats->bcastPktsRxOK++;\n            stats->bcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_MCAST:\n            stats->mcastPktsRxOK++;\n            stats->mcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_UCAST:\n            stats->ucastPktsRxOK++;\n            stats->ucastBytesRxOK += tot_len;\n            break;\n        default:\n            g_assert_not_reached();\n        }\n\n        if (tot_len > s->mtu) {\n            stats->LROPktsRxOK++;\n            stats->LROBytesRxOK += tot_len;\n        }\n        break;\n    default:\n        g_assert_not_reached();\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187926, "func": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n off_t start;\n size_t length;\n void* memPtr;\n\n    assert(pMap != NULL);\n\n if (getFileStartAndLength(fd, &start, &length) < 0)\n return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n return -1;\n }\n\n    pMap->addr = memPtr;\n\n     pMap->length = length;\n     pMap->range_count = 1;\n     pMap->ranges = malloc(sizeof(MappedRange));\n     pMap->ranges[0].addr = memPtr;\n     pMap->ranges[0].length = length;\n \n return 0;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188189, "func": "void InputDispatcher::enqueueDispatchEntryLocked(\n const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget,\n int32_t dispatchMode) {\n int32_t inputTargetFlags = inputTarget->flags;\n if (!(inputTargetFlags & dispatchMode)) {\n return;\n }\n    inputTargetFlags = (inputTargetFlags & ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;\n\n DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, \n            inputTargetFlags, inputTarget->xOffset, inputTarget->yOffset,\n            inputTarget->scaleFactor);\n\n switch (eventEntry->type) {\n case EventEntry::TYPE_KEY: {\n KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);\n        dispatchEntry->resolvedAction = keyEntry->action;\n        dispatchEntry->resolvedFlags = keyEntry->flags;\n\n if (!connection->inputState.trackKey(keyEntry,\n                dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event\",\n                    connection->getInputChannelName());\n#endif\n delete dispatchEntry;\n return; \n }\n break;\n }\n\n case EventEntry::TYPE_MOTION: {\n MotionEntry* motionEntry = static_cast<MotionEntry*>(eventEntry);\n if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_CANCEL;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_DOWN;\n } else {\n            dispatchEntry->resolvedAction = motionEntry->action;\n }\n if (dispatchEntry->resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n && !connection->inputState.isHovering(\n                        motionEntry->deviceId, motionEntry->source, motionEntry->displayId)) {\n#if DEBUG_DISPATCH_CYCLE\n        ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter event\",\n                connection->getInputChannelName());\n#endif\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n }\n\n        dispatchEntry->resolvedFlags = motionEntry->flags;\n\n         if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_OBSCURED) {\n             dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;\n         }\n \n         if (!connection->inputState.trackMotion(motionEntry,\n                 dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion event\",\n                    connection->getInputChannelName());\n#endif\n delete dispatchEntry;\n return; \n }\n break;\n }\n }\n\n if (dispatchEntry->hasForegroundTarget()) {\n        incrementPendingForegroundDispatchesLocked(eventEntry);\n }\n\n    connection->outboundQueue.enqueueAtTail(dispatchEntry);\n    traceOutboundQueueLengthLocked(connection);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188547, "func": "  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8886, "func": "static void vrend_patch_blend_state(struct vrend_context *ctx)\n{\n   struct pipe_blend_state new_state = ctx->sub->blend_state;\n   struct pipe_blend_state *state = &ctx->sub->blend_state;\n   bool dest_alpha_only = false, dest_has_no_alpha = false;\n   struct pipe_blend_color blend_color = ctx->sub->blend_color;\n   int i;\n\n   if (ctx->sub->nr_cbufs == 0)\n      return;\n\n   for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n      if (!ctx->sub->surf[i])\n         continue;\n\n      if (vrend_format_is_emulated_alpha(ctx->sub->surf[i]->format)) {\n         dest_alpha_only = true;\n      }\n\n      if (!util_format_has_alpha(ctx->sub->surf[i]->format)) {\n         dest_has_no_alpha = true;\n      }\n   }\n\n   if (dest_alpha_only) {\n      for (i = 0; i < (state->independent_blend_enable ? PIPE_MAX_COLOR_BUFS : 1); i++) {\n         if (state->rt[i].blend_enable) {\n            new_state.rt[i].rgb_src_factor = conv_a8_blend(state->rt[i].alpha_src_factor);\n            new_state.rt[i].rgb_dst_factor = conv_a8_blend(state->rt[i].alpha_dst_factor);\n            new_state.rt[i].alpha_src_factor = PIPE_BLENDFACTOR_ZERO;\n            new_state.rt[i].alpha_dst_factor = PIPE_BLENDFACTOR_ZERO;\n         }\n         new_state.rt[i].colormask = 0;\n         if (state->rt[i].colormask & PIPE_MASK_A)\n            new_state.rt[i].colormask |= PIPE_MASK_R;\n      }\n      blend_color.color[0] = blend_color.color[3];\n      blend_color.color[1] = 0.0f;\n      blend_color.color[2] = 0.0f;\n      blend_color.color[3] = 0.0f;\n   } else if (dest_has_no_alpha) {\n      for (i = 0; i < (state->independent_blend_enable ? PIPE_MAX_COLOR_BUFS : 1); i++) {\n         if (!(is_dst_blend(state->rt[i].rgb_src_factor) ||\n               is_dst_blend(state->rt[i].rgb_dst_factor) ||\n               is_dst_blend(state->rt[i].alpha_src_factor) ||\n               is_dst_blend(state->rt[i].alpha_dst_factor)))\n            continue;\n         new_state.rt[i].rgb_src_factor = conv_dst_blend(state->rt[i].rgb_src_factor);\n         new_state.rt[i].rgb_dst_factor = conv_dst_blend(state->rt[i].rgb_dst_factor);\n         new_state.rt[i].alpha_src_factor = conv_dst_blend(state->rt[i].alpha_src_factor);\n         new_state.rt[i].alpha_dst_factor = conv_dst_blend(state->rt[i].alpha_dst_factor);\n      }\n   }\n\n   vrend_hw_emit_blend(ctx, &new_state);\n   glBlendColor(blend_color.color[0],\n                blend_color.color[1],\n                blend_color.color[2],\n                blend_color.color[3]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8783, "func": "int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n{\n\tuint8_t *message;\n\tconst char *str_V, *str_h, *str_F, *str_r;\n\tIF_FEATURE_UDHCPC_ARPING(const char *str_a = \"2000\";)\n\tIF_FEATURE_UDHCP_PORT(char *str_P;)\n\tvoid *clientid_mac_ptr;\n\tllist_t *list_O = NULL;\n\tllist_t *list_x = NULL;\n\tint tryagain_timeout = 20;\n\tint discover_timeout = 3;\n\tint discover_retries = 3;\n\tuint32_t server_addr = server_addr; \n\tuint32_t requested_ip = 0;\n\tuint32_t xid = xid; \n\tint packet_num;\n\tint timeout; \n\tunsigned already_waited_sec;\n\tunsigned opt;\n\tIF_FEATURE_UDHCPC_ARPING(unsigned arpping_ms;)\n\tint retval;\n\n\tsetup_common_bufsiz();\n\n\tIF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)\n\tIF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)\n\tclient_config.interface = \"eth0\";\n\tclient_config.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;\n\tstr_V = \"udhcp \"BB_VER;\n\n\topt = getopt32long(argv, \"^\"\n\t\t\"CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB\"\n\t\tUSE_FOR_MMU(\"b\")\n\t\tIF_FEATURE_UDHCPC_ARPING(\"a::\")\n\t\tIF_FEATURE_UDHCP_PORT(\"P:\")\n\t\t\"v\"\n\t\t\"\\0\" IF_UDHCP_VERBOSE(\"vv\") \n\t\t, udhcpc_longopts\n\t\t, &str_V, &str_h, &str_h, &str_F\n\t\t, &client_config.interface, &client_config.pidfile \n\t\t, &str_r \n\t\t, &client_config.script \n\t\t, &discover_timeout, &discover_retries, &tryagain_timeout \n\t\t, &list_O\n\t\t, &list_x\n\t\tIF_FEATURE_UDHCPC_ARPING(, &str_a)\n\t\tIF_FEATURE_UDHCP_PORT(, &str_P)\n\t\tIF_UDHCP_VERBOSE(, &dhcp_verbose)\n\t);\n\tif (opt & (OPT_h|OPT_H)) {\n\t\tbb_error_msg(\"option -h NAME is deprecated, use -x hostname:NAME\");\n\t\tclient_config.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);\n\t}\n\tif (opt & OPT_F) {\n\t\tclient_config.fqdn = alloc_dhcp_option(DHCP_FQDN, str_F, 3);\n\t\tclient_config.fqdn[OPT_DATA + 0] = 0x1;\n\t}\n\tif (opt & OPT_r)\n\t\trequested_ip = inet_addr(str_r);\n#if ENABLE_FEATURE_UDHCP_PORT\n\tif (opt & OPT_P) {\n\t\tCLIENT_PORT = xatou16(str_P);\n\t\tSERVER_PORT = CLIENT_PORT - 1;\n\t}\n#endif\n\tIF_FEATURE_UDHCPC_ARPING(arpping_ms = xatou(str_a);)\n\twhile (list_O) {\n\t\tchar *optstr = llist_pop(&list_O);\n\t\tunsigned n = bb_strtou(optstr, NULL, 0);\n\t\tif (errno || n > 254) {\n\t\t\tn = udhcp_option_idx(optstr, dhcp_option_strings);\n\t\t\tn = dhcp_optflags[n].code;\n\t\t}\n\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t}\n\tif (!(opt & OPT_o)) {\n\t\tunsigned i, n;\n\t\tfor (i = 0; (n = dhcp_optflags[i].code) != 0; i++) {\n\t\t\tif (dhcp_optflags[i].flags & OPTION_REQ) {\n\t\t\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t\t\t}\n\t\t}\n\t}\n\twhile (list_x) {\n\t\tchar *optstr = xstrdup(llist_pop(&list_x));\n\t\tudhcp_str2optset(optstr, &client_config.options,\n\t\t\t\tdhcp_optflags, dhcp_option_strings,\n 0\n\t\t);\n\t\tfree(optstr);\n\t}\n\n\tif (udhcp_read_interface(client_config.interface,\n\t\t\t&client_config.ifindex,\n\t\t\tNULL,\n\t\t\tclient_config.client_mac)\n\t) {\n\t\treturn 1;\n\t}\n\n\tclientid_mac_ptr = NULL;\n\tif (!(opt & OPT_C) && !udhcp_find_option(client_config.options, DHCP_CLIENT_ID)) {\n\t\tclient_config.clientid = alloc_dhcp_option(DHCP_CLIENT_ID, \"\", 7);\n\t\tclient_config.clientid[OPT_DATA] = 1; \n\t\tclientid_mac_ptr = client_config.clientid + OPT_DATA+1;\n\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\t}\n\tif (str_V[0] != '\\0') {\n\t\tclient_config.vendorclass = alloc_dhcp_option(DHCP_VENDOR, str_V, 0);\n\t}\n\n#if !BB_MMU\n\tif (!(opt & OPT_f)) {\n\t\tbb_daemonize_or_rexec(0 \n, argv);\n\t\tlogmode = LOGMODE_NONE;\n\t}\n#endif\n\tif (opt & OPT_S) {\n\t\topenlog(applet_name, LOG_PID, LOG_DAEMON);\n\t\tlogmode |= LOGMODE_SYSLOG;\n\t}\n\n\tbb_sanitize_stdio();\n\twrite_pidfile(client_config.pidfile);\n\tbb_error_msg(\"started, v\"BB_VER);\n\tudhcp_sp_setup();\n\tsrand(monotonic_us());\n\n\tstate = INIT_SELECTING;\n\tudhcp_run_script(NULL, \"deconfig\");\n\tchange_listen_mode(LISTEN_RAW);\n\tpacket_num = 0;\n\ttimeout = 0;\n\talready_waited_sec = 0;\n\n\tfor (;;) {\n\t\tint tv;\n\t\tstruct pollfd pfds[2];\n\t\tstruct dhcp_packet packet;\n\t\tunsigned timestamp_before_wait = timestamp_before_wait;\n\n\n\n\t\tudhcp_sp_fd_set(pfds, sockfd);\n\n\t\ttv = timeout - already_waited_sec;\n\t\tretval = 0;\n\t\tif (tv > 0) {\n\t\t\tlog1(\"waiting %u seconds\", tv);\n\t\t\ttimestamp_before_wait = (unsigned)monotonic_sec();\n\t\t\tretval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);\n\t\t\tif (retval < 0) {\n\t\t\t\tif (errno == EINTR) {\n\t\t\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbb_perror_msg_and_die(\"poll\");\n\t\t\t}\n\t\t}\n\n\t\tif (retval == 0) {\n\t\t\tif (udhcp_read_interface(client_config.interface,\n\t\t\t\t\t&client_config.ifindex,\n\t\t\t\t\tNULL,\n\t\t\t\t\tclient_config.client_mac)\n\t\t\t) {\n\t\t\t\tgoto ret0; \n\t\t\t}\n\t\t\tif (clientid_mac_ptr)\n\t\t\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\n\t\t\talready_waited_sec = 0;\n\n\t\t\tswitch (state) {\n\t\t\tcase INIT_SELECTING:\n\t\t\t\tif (!discover_retries || packet_num < discover_retries) {\n\t\t\t\t\tif (packet_num == 0)\n\t\t\t\t\t\txid = random_xid();\n\t\t\t\t\tsend_discover(xid, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n leasefail:\n\t\t\t\tudhcp_run_script(NULL, \"leasefail\");\n#if BB_MMU \n\t\t\t\tif (opt & OPT_b) { \n\t\t\t\t\tbb_error_msg(\"no lease, forking to background\");\n\t\t\t\t\tclient_background();\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t} else\n#endif\n\t\t\t\tif (opt & OPT_n) { \n\t\t\t\t\tbb_error_msg(\"no lease, failing\");\n\t\t\t\t\tretval = 1;\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\tcase REQUESTING:\n\t\t\t\tif (packet_num < 3) {\n\t\t\t\t\tsend_select(xid, server_addr, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tgoto leasefail;\n\t\t\tcase BOUND:\n\t\t\t\tstate = RENEWING;\n\t\t\t\tclient_config.first_secs = 0; \n\t\t\t\tchange_listen_mode(LISTEN_KERNEL);\n\t\t\t\tlog1(\"entering renew state\");\n\t\t\tcase RENEW_REQUESTED: \n\t\t\tcase_RENEW_REQUESTED:\n\t\t\tcase RENEWING:\n\t\t\t\tif (timeout >= 60) {\n\t\t\t\t\tif (send_renew(xid, server_addr, requested_ip) >= 0) {\n\t\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlog1(\"entering rebinding state\");\n\t\t\t\tstate = REBINDING;\n\t\t\tcase REBINDING:\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tif (timeout > 0) {\n\t\t\t\t\tsend_renew(xid, 0 \n, requested_ip);\n\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbb_error_msg(\"lease lost, entering init state\");\n\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; \n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue; \n\t\t} \n\n\n\t\tswitch (udhcp_sp_read()) {\n\t\tcase SIGUSR1:\n\t\t\tclient_config.first_secs = 0; \n\t\t\talready_waited_sec = 0;\n\t\t\tperform_renew();\n\t\t\tif (state == RENEW_REQUESTED) {\n\t\t\t\tif (timeout > 60)\n\t\t\t\t\ttimeout = 60;\n\t\t\t\tgoto case_RENEW_REQUESTED;\n\t\t\t}\n\t\t\tpacket_num = 0;\n\t\t\ttimeout = 0;\n\t\t\tcontinue;\n\t\tcase SIGUSR2:\n\t\t\tperform_release(server_addr, requested_ip);\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue;\n\t\tcase SIGTERM:\n\t\t\tbb_error_msg(\"received %s\", \"SIGTERM\");\n\t\t\tgoto ret0;\n\t\t}\n\n\t\tif (!pfds[1].revents)\n\t\t\tcontinue; \n\n\t\t{\n\t\t\tint len;\n\n\t\t\tif (listen_mode == LISTEN_KERNEL)\n\t\t\t\tlen = udhcp_recv_kernel_packet(&packet, sockfd);\n\t\t\telse\n\t\t\t\tlen = udhcp_recv_raw_packet(&packet, sockfd);\n\t\t\tif (len == -1) {\n\t\t\t\tbb_error_msg(\"read error: \"STRERROR_FMT\", reopening socket\" STRERROR_ERRNO);\n\t\t\t\tsleep(discover_timeout); \n\t\t\t\tchange_listen_mode(listen_mode); \n\t\t\t}\n\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\tif (len < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (packet.xid != xid) {\n\t\t\tlog1(\"xid %x (our is %x), ignoring packet\",\n\t\t\t\t(unsigned)packet.xid, (unsigned)xid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (packet.hlen != 6\n\t\t || memcmp(packet.chaddr, client_config.client_mac, 6) != 0\n\t\t) {\n\t\t\tlog1(\"chaddr does not match, ignoring packet\"); \n\t\t\tcontinue;\n\t\t}\n\n\t\tmessage = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);\n\t\tif (message == NULL) {\n\t\t\tbb_error_msg(\"no message type option, ignoring packet\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase INIT_SELECTING:\n\t\t\tif (*message == DHCPOFFER) {\n\t\t\t\tuint8_t *temp;\n\n * 10.34.25.254:67 > 10.34.25.202:68 \n * Server-IP 10.34.32.125   \n * Gateway-IP 10.34.25.254  \n * Server-ID Option 54, length 4: 10.34.255.7       \n * Default-Gateway Option 3, length 4: 10.34.25.254 \n\t\t\t\tserver_addr = 0;\n\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_SERVER_ID);\n\t\t\t\tif (!temp) {\n\t\t\t\t\tbb_error_msg(\"no server ID, using 0.0.0.0\");\n\t\t\t\t} else {\n\t\t\t\t\tmove_from_unaligned32(server_addr, temp);\n\t\t\t\t}\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\tstate = REQUESTING;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase REQUESTING:\n\t\tcase RENEWING:\n\t\tcase RENEW_REQUESTED:\n\t\tcase REBINDING:\n\t\t\tif (*message == DHCPACK) {\n\t\t\t\tunsigned start;\n\t\t\t\tuint32_t lease_seconds;\n\t\t\t\tstruct in_addr temp_addr;\n\t\t\t\tuint8_t *temp;\n\n\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);\n\t\t\t\tif (!temp) {\n\t\t\t\t\tbb_error_msg(\"no lease time with ACK, using 1 hour lease\");\n\t\t\t\t\tlease_seconds = 60 * 60;\n\t\t\t\t} else {\n\t\t\t\t\tmove_from_unaligned32(lease_seconds, temp);\n\t\t\t\t\tlease_seconds = ntohl(lease_seconds);\n\t\t\t\t\tif (lease_seconds < 2 * 61)\n\t\t\t\t\t\tlease_seconds = 2 * 61;\n\t\t\t\t}\n#if ENABLE_FEATURE_UDHCPC_ARPING\n\t\t\t\tif (opt & OPT_a) {\n\t\t\t\t\tif (!arpping(packet.yiaddr,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t(uint32_t) 0,\n\t\t\t\t\t\t\tclient_config.client_mac,\n\t\t\t\t\t\t\tclient_config.interface,\n\t\t\t\t\t\t\tarpping_ms)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbb_error_msg(\"offered address is in use \"\n\t\t\t\t\t\t\t\"(got ARP reply), declining\");\n\t\t\t\t\t\tsend_decline(\n server_addr, packet.yiaddr);\n\n\t\t\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\t\t\tclient_config.first_secs = 0; \n\t\t\t\t\t\trequested_ip = 0;\n\t\t\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\t\t\tpacket_num = 0;\n\t\t\t\t\t\talready_waited_sec = 0;\n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\ttemp_addr.s_addr = packet.yiaddr;\n\t\t\t\tbb_error_msg(\"lease of %s obtained, lease time %u\",\n\t\t\t\t\tinet_ntoa(temp_addr), (unsigned)lease_seconds);\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\tstart = monotonic_sec();\n\t\t\t\tudhcp_run_script(&packet, state == REQUESTING ? \"bound\" : \"renew\");\n\t\t\t\talready_waited_sec = (unsigned)monotonic_sec() - start;\n\t\t\t\ttimeout = lease_seconds / 2;\n\t\t\t\tif ((unsigned)timeout < already_waited_sec) {\n\t\t\t\t\ttimeout = already_waited_sec = 0;\n\t\t\t\t}\n\n\t\t\t\tstate = BOUND;\n\t\t\t\tchange_listen_mode(LISTEN_NONE);\n\t\t\t\tif (opt & OPT_q) { \n\t\t\t\t\tgoto ret0;\n\t\t\t\t}\n\t\t\t\topt &= ~OPT_n;\n#if BB_MMU \n\t\t\t\tif (!(opt & OPT_f)) {\n\t\t\t\t\tclient_background();\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t}\n#endif\n\n\t\t\t\tcontinue; \n\t\t\t}\n\t\t\tif (*message == DHCPNAK) {\n\t\t\t\tif (server_addr != 0) {\n\t\t\t\t\tuint32_t svid;\n\t\t\t\t\tuint8_t *temp;\n\n\t\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_SERVER_ID);\n\t\t\t\t\tif (!temp) {\n non_matching_svid:\n\t\t\t\t\t\tlog1(\"received DHCP NAK with wrong\"\n\t\t\t\t\t\t\t\" server ID, ignoring packet\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmove_from_unaligned32(svid, temp);\n\t\t\t\t\tif (svid != server_addr)\n\t\t\t\t\t\tgoto non_matching_svid;\n\t\t\t\t}\n\t\t\t\tbb_error_msg(\"received %s\", \"DHCP NAK\");\n\t\t\t\tudhcp_run_script(&packet, \"nak\");\n\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tsleep(3); \n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; \n\t\t\t\trequested_ip = 0;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t} \n\n ret0:\n\tif (opt & OPT_R) \n\t\tperform_release(server_addr, requested_ip);\n\tretval = 0;\n ret:\n\t\tremove_pidfile(client_config.pidfile);\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8415, "func": "pvscsi_init(PCIDevice *pci_dev)\n{\n    PVSCSIState *s = PVSCSI(pci_dev);\n\n    trace_pvscsi_state(\"init\");\n\n    if (PVSCSI_USE_OLD_PCI_CONFIGURATION(s)) {\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_ID, 0x1000);\n    } else {\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_VENDOR_ID,\n                     PCI_VENDOR_ID_VMWARE);\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_ID,\n                     PCI_DEVICE_ID_VMWARE_PVSCSI);\n        pci_config_set_revision(pci_dev->config, 0x2);\n    }\n\n    pci_dev->config[PCI_LATENCY_TIMER] = 0xff;\n\n    pci_config_set_interrupt_pin(pci_dev->config, 1);\n\n    memory_region_init_io(&s->io_space, OBJECT(s), &pvscsi_ops, s,\n                          \"pvscsi-io\", PVSCSI_MEM_SPACE_SIZE);\n    pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->io_space);\n\n    pvscsi_init_msi(s);\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus)) {\n        pcie_endpoint_cap_init(pci_dev, PVSCSI_EXP_EP_OFFSET);\n    }\n\n    s->completion_worker = qemu_bh_new(pvscsi_process_completion_queue, s);\n    if (!s->completion_worker) {\n        pvscsi_cleanup_msi(s);\n        return -ENOMEM;\n    }\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(pci_dev),\n                 &pvscsi_scsi_info, NULL);\n    qbus_set_hotplug_handler(BUS(&s->bus), DEVICE(s), &error_abort);\n    pvscsi_reset_state(s);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8329, "func": "static void usb_xhci_realize(struct PCIDevice *dev, Error **errp)\n{\n    int i, ret;\n    Error *err = NULL;\n\n    XHCIState *xhci = XHCI(dev);\n\n    dev->config[PCI_CLASS_PROG] = 0x30;    \n    dev->config[PCI_INTERRUPT_PIN] = 0x01; \n    dev->config[PCI_CACHE_LINE_SIZE] = 0x10;\n    dev->config[0x60] = 0x30; \n\n    usb_xhci_init(xhci);\n\n    if (xhci->msi != ON_OFF_AUTO_OFF) {\n        ret = msi_init(dev, 0x70, xhci->numintrs, true, false, &err);\n        assert(!ret || ret == -ENOTSUP);\n        if (ret && xhci->msi == ON_OFF_AUTO_ON) {\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n                    \"msi=off with this machine type.\\n\");\n            error_propagate(errp, err);\n            return;\n        }\n        assert(!err || xhci->msi == ON_OFF_AUTO_AUTO);\n        error_free(err);\n    }\n\n    if (xhci->numintrs > MAXINTRS) {\n        xhci->numintrs = MAXINTRS;\n    }\n    while (xhci->numintrs & (xhci->numintrs - 1)) {   \n        xhci->numintrs++;\n    }\n    if (xhci->numintrs < 1) {\n        xhci->numintrs = 1;\n    }\n    if (xhci->numslots > MAXSLOTS) {\n        xhci->numslots = MAXSLOTS;\n    }\n    if (xhci->numslots < 1) {\n        xhci->numslots = 1;\n    }\n    if (xhci_get_flag(xhci, XHCI_FLAG_ENABLE_STREAMS)) {\n        xhci->max_pstreams_mask = 7; \n    } else {\n        xhci->max_pstreams_mask = 0;\n    }\n\n    xhci->mfwrap_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, xhci_mfwrap_timer, xhci);\n\n    memory_region_init(&xhci->mem, OBJECT(xhci), \"xhci\", LEN_REGS);\n    memory_region_init_io(&xhci->mem_cap, OBJECT(xhci), &xhci_cap_ops, xhci,\n                          \"capabilities\", LEN_CAP);\n    memory_region_init_io(&xhci->mem_oper, OBJECT(xhci), &xhci_oper_ops, xhci,\n                          \"operational\", 0x400);\n    memory_region_init_io(&xhci->mem_runtime, OBJECT(xhci), &xhci_runtime_ops, xhci,\n                          \"runtime\", LEN_RUNTIME);\n    memory_region_init_io(&xhci->mem_doorbell, OBJECT(xhci), &xhci_doorbell_ops, xhci,\n                          \"doorbell\", LEN_DOORBELL);\n\n    memory_region_add_subregion(&xhci->mem, 0,            &xhci->mem_cap);\n    memory_region_add_subregion(&xhci->mem, OFF_OPER,     &xhci->mem_oper);\n    memory_region_add_subregion(&xhci->mem, OFF_RUNTIME,  &xhci->mem_runtime);\n    memory_region_add_subregion(&xhci->mem, OFF_DOORBELL, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        uint32_t offset = OFF_OPER + 0x400 + 0x10 * i;\n        port->xhci = xhci;\n        memory_region_init_io(&port->mem, OBJECT(xhci), &xhci_port_ops, port,\n                              port->name, 0x10);\n        memory_region_add_subregion(&xhci->mem, offset, &port->mem);\n    }\n\n    pci_register_bar(dev, 0,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64,\n                     &xhci->mem);\n\n    if (pci_bus_is_express(dev->bus) ||\n        xhci_get_flag(xhci, XHCI_FLAG_FORCE_PCIE_ENDCAP)) {\n        ret = pcie_endpoint_cap_init(dev, 0xa0);\n        assert(ret >= 0);\n    }\n\n    if (xhci->msix != ON_OFF_AUTO_OFF) {\n        msix_init(dev, xhci->numintrs,\n                  &xhci->mem, 0, OFF_MSIX_TABLE,\n                  &xhci->mem, 0, OFF_MSIX_PBA,\n                  0x90);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187417, "func": " int validate_camera_metadata_structure(const camera_metadata_t *metadata,\n                                        const size_t *expected_size) {\n \n if (metadata == NULL) {\n        ALOGE(\"%s: metadata is null!\", __FUNCTION__);\n return ERROR;\n }\n\n {\n static const struct {\n const char *name;\n size_t alignment;\n } alignments[] = {\n {\n .name = \"camera_metadata\",\n .alignment = METADATA_ALIGNMENT\n },\n {\n .name = \"camera_metadata_buffer_entry\",\n .alignment = ENTRY_ALIGNMENT\n },\n {\n .name = \"camera_metadata_data\",\n .alignment = DATA_ALIGNMENT\n },\n };\n\n for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {\n uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);\n\n if ((uintptr_t)metadata != aligned_ptr) {\n                ALOGE(\"%s: Metadata pointer is not aligned (actual %p, \"\n \"expected %p) to type %s\",\n                      __FUNCTION__, metadata,\n (void*)aligned_ptr, alignments[i].name);\n return ERROR;\n }\n }\n }\n\n\n if (expected_size != NULL && metadata->size > *expected_size) {\n        ALOGE(\"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\",\n              __FUNCTION__, metadata->size, *expected_size);\n return ERROR;\n }\n\n if (metadata->entry_count > metadata->entry_capacity) {\n        ALOGE(\"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \"\n \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->entry_count, metadata->entry_capacity);\n return ERROR;\n }\n\n const metadata_uptrdiff_t entries_end =\n        metadata->entries_start + metadata->entry_capacity;\n if (entries_end < metadata->entries_start || \n        entries_end > metadata->data_start) {\n\n        ALOGE(\"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->entries_start + metadata->entry_capacity),\n              metadata->data_start);\n return ERROR;\n }\n\n const metadata_uptrdiff_t data_end =\n        metadata->data_start + metadata->data_capacity;\n if (data_end < metadata->data_start || \n        data_end > metadata->size) {\n\n        ALOGE(\"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->data_start + metadata->data_capacity),\n              metadata->size);\n return ERROR;\n }\n\n const metadata_size_t entry_count = metadata->entry_count;\n camera_metadata_buffer_entry_t *entries = get_entries(metadata);\n\n for (size_t i = 0; i < entry_count; ++i) {\n\n if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {\n            ALOGE(\"%s: Entry index %zu had bad alignment (address %p),\"\n \" expected alignment %zu\",\n                  __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);\n return ERROR;\n }\n\n camera_metadata_buffer_entry_t entry = entries[i];\n\n if (entry.type >= NUM_TYPES) {\n            ALOGE(\"%s: Entry index %zu had a bad type %d\",\n                  __FUNCTION__, i, entry.type);\n return ERROR;\n }\n\n uint32_t tag_section = entry.tag >> 16;\n int tag_type = get_camera_metadata_tag_type(entry.tag);\n if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {\n            ALOGE(\"%s: Entry index %zu had tag type %d, but the type was %d\",\n                  __FUNCTION__, i, tag_type, entry.type);\n\n             return ERROR;\n         }\n \n        size_t data_size =\n                calculate_camera_metadata_entry_data_size(entry.type,\n                                                          entry.count);\n \n         if (data_size != 0) {\n             camera_metadata_data_t *data =\n (camera_metadata_data_t*) (get_data(metadata) +\n                                               entry.data.offset);\n\n if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {\n                ALOGE(\"%s: Entry index %zu had bad data alignment (address %p),\"\n \" expected align %zu, (tag name %s, data size %zu)\",\n                      __FUNCTION__, i, data, DATA_ALIGNMENT,\n                      get_camera_metadata_tag_name(entry.tag) ?: \"unknown\",\n                      data_size);\n return ERROR;\n }\n\n size_t data_entry_end = entry.data.offset + data_size;\n if (data_entry_end < entry.data.offset || \n                data_entry_end > metadata->data_capacity) {\n\n                ALOGE(\"%s: Entry index %zu data ends (%zu) beyond the capacity \"\n \"%\" PRIu32, __FUNCTION__, i, data_entry_end,\n                      metadata->data_capacity);\n return ERROR;\n }\n\n } else if (entry.count == 0) {\n if (entry.data.offset != 0) {\n                ALOGE(\"%s: Entry index %zu had 0 items, but offset was non-0 \"\n \"(%\" PRIu32 \"), tag name: %s\", __FUNCTION__, i, entry.data.offset,\n                        get_camera_metadata_tag_name(entry.tag) ?: \"unknown\");\n return ERROR;\n }\n } \n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "114,115,116"}
{"idx": 187468, "func": "int btpan_tap_send(int tap_fd, const BD_ADDR src, const BD_ADDR dst, UINT16 proto, const char* buf,\n                    UINT16 len, BOOLEAN ext, BOOLEAN forward)\n{\n    UNUSED(ext);\n    UNUSED(forward);\n if (tap_fd != INVALID_FD)\n {\n        tETH_HDR eth_hdr;\n        memcpy(&eth_hdr.h_dest, dst, ETH_ADDR_LEN);\n        memcpy(&eth_hdr.h_src, src, ETH_ADDR_LEN);\n        eth_hdr.h_proto = htons(proto);\n char packet[TAP_MAX_PKT_WRITE_LEN + sizeof(tETH_HDR)];\n        memcpy(packet, &eth_hdr, sizeof(tETH_HDR));\n if (len > TAP_MAX_PKT_WRITE_LEN)\n {\n            LOG_ERROR(\"btpan_tap_send eth packet size:%d is exceeded limit!\", len);\n return -1;\n }\n\n         memcpy(packet + sizeof(tETH_HDR), buf, len);\n \n        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));\n         BTIF_TRACE_DEBUG(\"ret:%d\", ret);\n         return ret;\n     }\n return -1;\n\n}\n", "target": 1, "flaw_line_index": "22"}
{"idx": 188538, "func": "   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n     }\n     if (cfg_.ts_number_layers > 1) {\n      if (video->frame() == 1) {\n         encoder->Control(VP9E_SET_SVC, 1);\n       }\n      vpx_svc_layer_id_t layer_id = {0, 0};\n       layer_id.spatial_layer_id = 0;\n       frame_flags_ = SetFrameFlags(video->frame(), cfg_.ts_number_layers);\n       layer_id.temporal_layer_id = SetLayerId(video->frame(),\n                                               cfg_.ts_number_layers);\n      if (video->frame() > 0) {\n       encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n      }\n     }\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) / tb.den;\n    duration_ = 0;\n }\n", "target": 1, "flaw_line_index": "3,7,10,15,16,17"}
{"idx": 187915, "func": "status_t BnOMX::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case LIVES_LOCALLY:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n return OK;\n }\n\n case LIST_NODES:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n }\n }\n\n return NO_ERROR;\n }\n\n case ALLOCATE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n if (err == OK) {\n                reply->writeInt32((int32_t)node);\n }\n\n return NO_ERROR;\n }\n\n case FREE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n return NO_ERROR;\n }\n\n case SEND_COMMAND:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n return NO_ERROR;\n }\n\n case GET_PARAMETER:\n case SET_PARAMETER:\n case GET_CONFIG:\n case SET_CONFIG:\n case SET_INTERNAL_OPTION:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n \n             size_t size = data.readInt64();\n \n            void *params = malloc(size);\n            data.read(params, size);\n \n            status_t err;\n            switch (code) {\n                case GET_PARAMETER:\n                    err = getParameter(node, index, params, size);\n                    break;\n                case SET_PARAMETER:\n                    err = setParameter(node, index, params, size);\n                    break;\n                case GET_CONFIG:\n                    err = getConfig(node, index, params, size);\n                    break;\n                case SET_CONFIG:\n                    err = setConfig(node, index, params, size);\n                    break;\n                case SET_INTERNAL_OPTION:\n                {\n                    InternalOptionType type =\n                        (InternalOptionType)data.readInt32();\n \n                    err = setInternalOption(node, index, type, params, size);\n                    break;\n                 }\n                default:\n                    TRESPASS();\n             }\n \n             reply->writeInt32(err);\n\n if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n                reply->write(params, size);\n }\n\n            free(params);\n            params = NULL;\n\n return NO_ERROR;\n }\n\n case GET_STATE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case ENABLE_GRAPHIC_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case GET_GRAPHIC_BUFFER_USAGE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n return NO_ERROR;\n }\n\n case USE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n\n            buffer_id buffer;\n status_t err = useBuffer(node, port_index, params, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case USE_GRAPHIC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case UPDATE_GRAPHIC_BUFFER_IN_META:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CREATE_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferProducer> bufferProducer;\n status_t err = createInputSurface(node, port_index,\n &bufferProducer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(bufferProducer->asBinder());\n }\n\n return NO_ERROR;\n }\n\n case SIGNAL_END_OF_INPUT_STREAM:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case STORE_META_DATA_IN_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = storeMetaDataInBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CONFIGURE_VIDEO_TUNNEL_MODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n            OMX_U32 audio_hw_sync = data.readInt32();\n\n native_handle_t *sideband_handle = NULL;\n status_t err = configureVideoTunnelMode(\n                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n            reply->writeInt32(err);\n if(err == OK){\n                reply->writeNativeHandle(sideband_handle);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n if (!isSecure(node) || port_index != 0 \n) {\n                ALOGE(\"b/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n return NO_ERROR;\n }\n\n size_t size = data.readInt64();\n\n            buffer_id buffer;\n void *buffer_data;\n status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER_WITH_BACKUP:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n\n            buffer_id buffer;\n status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case FREE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n return NO_ERROR;\n }\n\n case FILL_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(fillBuffer(node, buffer));\n\n return NO_ERROR;\n }\n\n case EMPTY_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n\n            reply->writeInt32(\n                    emptyBuffer(\n                        node, buffer, range_offset, range_length,\n                        flags, timestamp));\n\n return NO_ERROR;\n }\n\n case GET_EXTENSION_INDEX:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32(index);\n }\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "97,98,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,122,123"}
{"idx": 8528, "func": "static void ssh1_log_outgoing_packet(Ssh ssh, struct Packet *pkt)\n{\n    int nblanks = 0;\n    struct logblank_t blanks[4];\n    char *str;\n    int slen;\n\n    pkt->length -= (pkt->body - pkt->data);\n    pkt->savedpos = 0;\n\n    if (ssh->logomitdata &&\n        (pkt->type == SSH1_CMSG_STDIN_DATA ||\n         pkt->type == SSH1_MSG_CHANNEL_DATA)) {\n        if (pkt->type == SSH1_MSG_CHANNEL_DATA)\n            ssh_pkt_getuint32(pkt);    \n        blanks[nblanks].offset = pkt->savedpos + 4;\n        blanks[nblanks].type = PKTLOG_OMIT;\n        ssh_pkt_getstring(pkt, &str, &slen);\n        if (str) {\n            blanks[nblanks].len = slen;\n            nblanks++;\n        }\n    }\n\n    if ((pkt->type == SSH1_CMSG_AUTH_PASSWORD ||\n         pkt->type == SSH1_CMSG_AUTH_TIS_RESPONSE ||\n         pkt->type == SSH1_CMSG_AUTH_CCARD_RESPONSE) &&\n        conf_get_int(ssh->conf, CONF_logomitpass)) {\n        blanks[nblanks].offset = 0;\n        blanks[nblanks].len = pkt->length;\n        blanks[nblanks].type = PKTLOG_BLANK;\n        nblanks++;\n    } else if (pkt->type == SSH1_CMSG_X11_REQUEST_FORWARDING &&\n               conf_get_int(ssh->conf, CONF_logomitpass)) {\n        pkt->savedpos = 0;\n        ssh_pkt_getstring(pkt, &str, &slen);\n        blanks[nblanks].offset = pkt->savedpos;\n        blanks[nblanks].type = PKTLOG_BLANK;\n        ssh_pkt_getstring(pkt, &str, &slen);\n        if (str) {\n            blanks[nblanks].len = pkt->savedpos - blanks[nblanks].offset;\n            nblanks++;\n        }\n    }\n\n    log_packet(ssh->logctx, PKT_OUTGOING, pkt->data[12],\n               ssh1_pkt_type(pkt->data[12]),\n               pkt->body, pkt->length,\n               nblanks, blanks, NULL, 0, NULL);\n\n    pkt->length += (pkt->body - pkt->data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8417, "func": "pvscsi_io_read(void *opaque, hwaddr addr, unsigned size)\n{\n    PVSCSIState *s = opaque;\n\n    switch (addr) {\n    case PVSCSI_REG_OFFSET_INTR_STATUS:\n        trace_pvscsi_io_read(\"PVSCSI_REG_OFFSET_INTR_STATUS\",\n                             s->reg_interrupt_status);\n        return s->reg_interrupt_status;\n\n    case PVSCSI_REG_OFFSET_INTR_MASK:\n        trace_pvscsi_io_read(\"PVSCSI_REG_OFFSET_INTR_MASK\",\n                             s->reg_interrupt_status);\n        return s->reg_interrupt_enabled;\n\n    case PVSCSI_REG_OFFSET_COMMAND_STATUS:\n        trace_pvscsi_io_read(\"PVSCSI_REG_OFFSET_COMMAND_STATUS\",\n                             s->reg_interrupt_status);\n        return s->reg_command_status;\n\n    default:\n        trace_pvscsi_io_read_unknown(addr, size);\n        return 0;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8316, "func": "XFixesSetWindowShapeRegion (Display *dpy, Window win, int shape_kind,\n\t\t\t    int x_off, int y_off, XserverRegion region)\n{\n    XFixesExtDisplayInfo\t    *info = XFixesFindDisplay (dpy);\n    xXFixesSetWindowShapeRegionReq  *req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesSetWindowShapeRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesSetWindowShapeRegion;\n    req->dest = win;\n    req->destKind = shape_kind;\n    req->xOff = x_off;\n    req->yOff = y_off;\n    req->region = region;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8678, "func": "append_null (struct growable *dest)\n{\n  GROW (dest, 1);\n  *TAIL (dest) = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8429, "func": "pvscsi_on_cmd_unplug(PVSCSIState *s)\n{\n    trace_pvscsi_on_cmd_noimpl(\"PVSCSI_CMD_DEVICE_UNPLUG\");\n    return PVSCSI_COMMAND_PROCESSING_FAILED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8722, "func": "STACK_OF(X509) *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)\n{\n    if (!ctx->chain)\n        return NULL;\n    return X509_chain_up_ref(ctx->chain);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8441, "func": "pvscsi_register_types(void)\n{\n    type_register_static(&pvscsi_info);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187704, "func": "perform_gamma_threshold_tests(png_modifier *pm)\n{\n   png_byte colour_type = 0;\n   png_byte bit_depth = 0;\n unsigned int palette_number = 0;\n\n\n   while (next_format(&colour_type, &bit_depth, &palette_number, 1\n))\n      if (palette_number == 0)\n    {\n       double test_gamma = 1.0;\n       while (test_gamma >= .4)\n {\n         gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,\n            test_gamma, 1/test_gamma);\n         test_gamma *= .95;\n }\n\n      gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,\n .45455, 2.2);\n\n if (fail(pm))\n return;\n }\n\n }\n", "target": 1, "flaw_line_index": "9,10"}
{"idx": 9200, "func": "static void virtio_device_unrealize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(dev);\n    Error *err = NULL;\n\n    virtio_bus_device_unplugged(vdev);\n\n    if (vdc->unrealize != NULL) {\n        vdc->unrealize(dev, &err);\n        if (err != NULL) {\n            error_propagate(errp, err);\n            return;\n        }\n    }\n\n    g_free(vdev->bus_name);\n    vdev->bus_name = NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187342, "func": "xsltApplyTemplates(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t           xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemApplyTemplatesPtr comp =\n\t(xsltStyleItemApplyTemplatesPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    int i;\n     xmlNodePtr cur, delNode = NULL, oldContextNode;\n     xmlNodeSetPtr list = NULL, oldList;\n     xsltStackElemPtr withParams = NULL;\n    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n     const xmlChar *oldMode, *oldModeURI;\n     xmlDocPtr oldXPDoc;\n     xsltDocumentPtr oldDocInfo;\n     xmlXPathContextPtr xpctxt;\n    xmlNsPtr *oldXPNamespaces;\n \n     if (comp == NULL) {\n \txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:apply-templates : compilation failed\\n\");\n\treturn;\n    }\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n\treturn;\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if ((node != NULL) && (node->name != NULL))\n\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t     \"xsltApplyTemplates: node: '%s'\\n\", node->name));\n#endif\n\n    xpctxt = ctxt->xpathCtxt;\n    oldContextNode = ctxt->node;\n    oldMode = ctxt->mode;\n    oldModeURI = ctxt->modeURI;\n    oldDocInfo = ctxt->document;\n    oldList = ctxt->nodeList;\n\n     oldXPContextSize = xpctxt->contextSize;\n     oldXPProximityPosition = xpctxt->proximityPosition;\n     oldXPDoc = xpctxt->doc;\n    oldXPNsNr = xpctxt->nsNr;\n    oldXPNamespaces = xpctxt->namespaces;\n \n    ctxt->mode = comp->mode;\n    ctxt->modeURI = comp->modeURI;\n\n    if (comp->select != NULL) {\n\txmlXPathObjectPtr res = NULL;\n\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t \"xsl:apply-templates : compilation failed\\n\");\n\t    goto error;\n\t}\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n \t     \"xsltApplyTemplates: select %s\\n\", comp->select));\n #endif\n \n\txpctxt->node = node; \n#ifdef XSLT_REFACTORED\n\tif (comp->inScopeNs != NULL) {\n\t    xpctxt->namespaces = comp->inScopeNs->list;\n\t    xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n\t} else {\n\t    xpctxt->namespaces = NULL;\n\t    xpctxt->nsNr = 0;\n\t}\n#else\n\txpctxt->namespaces = comp->nsList;\n\txpctxt->nsNr = comp->nsNr;\n#endif\n\tres = xmlXPathCompiledEval(comp->comp, xpctxt);\n \n\txpctxt->contextSize = oldXPContextSize;\n\txpctxt->proximityPosition = oldXPProximityPosition;\n \tif (res != NULL) {\n \t    if (res->type == XPATH_NODESET) {\n \t\tlist = res->nodesetval; \n\t\tres->nodesetval = NULL;\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t    \"The 'select' expression did not evaluate to a \"\n\t\t    \"node set.\\n\");\n\t\tctxt->state = XSLT_STATE_STOPPED;\n\t\txmlXPathFreeObject(res);\n\t\tgoto error;\n\t    }\n\t    xmlXPathFreeObject(res);\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\"Failed to evaluate the 'select' expression.\\n\");\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t    goto error;\n\t}\n\tif (list == NULL) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"xsltApplyTemplates: select didn't evaluate to a node list\\n\"));\n#endif\n\t    goto exit;\n\t}\n#if 0\n\tif ((ctxt->nbKeys > 0) &&\n\t    (list->nodeNr != 0) &&\n\t    (list->nodeTab[0]->doc != NULL) &&\n\t    XSLT_IS_RES_TREE_FRAG(list->nodeTab[0]->doc))\n\t{\n\t    isRTF = 1;\n\t    effectiveDocInfo = list->nodeTab[0]->doc->_private;\n\t}\n#endif\n    } else {\n\tlist = xmlXPathNodeSetCreate(NULL);\n\tif (list == NULL)\n\t    goto error;\n\tif (node->type != XML_NAMESPACE_DECL)\n\t    cur = node->children;\n\telse\n\t    cur = NULL;\n\twhile (cur != NULL) {\n\t    switch (cur->type) {\n\t\tcase XML_TEXT_NODE:\n\t\t    if ((IS_BLANK_NODE(cur)) &&\n\t\t\t(cur->parent != NULL) &&\n\t\t\t(cur->parent->type == XML_ELEMENT_NODE) &&\n\t\t\t(ctxt->style->stripSpaces != NULL)) {\n\t\t\tconst xmlChar *val;\n\n\t\t\tif (cur->parent->ns != NULL) {\n\t\t\t    val = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t cur->parent->name,\n\t\t\t\t\t\t cur->parent->ns->href);\n\t\t\t    if (val == NULL) {\n\t\t\t\tval = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t BAD_CAST \"*\",\n\t\t\t\t\t\t cur->parent->ns->href);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    val = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t cur->parent->name, NULL);\n\t\t\t}\n\t\t\tif ((val != NULL) &&\n\t\t\t    (xmlStrEqual(val, (xmlChar *) \"strip\"))) {\n\t\t\t    delNode = cur;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\tcase XML_ELEMENT_NODE:\n\t\tcase XML_DOCUMENT_NODE:\n\t\tcase XML_HTML_DOCUMENT_NODE:\n\t\tcase XML_CDATA_SECTION_NODE:\n\t\tcase XML_PI_NODE:\n\t\tcase XML_COMMENT_NODE:\n\t\t    xmlXPathNodeSetAddUnique(list, cur);\n\t\t    break;\n\t\tcase XML_DTD_NODE:\n\t\t    if (cur->next != NULL)\n\t\t\tcur->next->prev = cur->prev;\n\t\t    if (cur->prev != NULL)\n\t\t\tcur->prev->next = cur->next;\n\t\t    break;\n\t\tcase XML_NAMESPACE_DECL:\n\t\t    break;\n\t\tdefault:\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\t    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltApplyTemplates: skipping cur type %d\\n\",\n\t\t\t\t     cur->type));\n#endif\n\t\t    delNode = cur;\n\t    }\n\t    cur = cur->next;\n\t    if (delNode != NULL) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltApplyTemplates: removing ignorable blank cur\\n\"));\n#endif\n\t\txmlUnlinkNode(delNode);\n\t\txmlFreeNode(delNode);\n\t\tdelNode = NULL;\n\t    }\n\t}\n    }\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if (list != NULL)\n    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\"xsltApplyTemplates: list of %d nodes\\n\", list->nodeNr));\n#endif\n\n    if ((list == NULL) || (list->nodeNr == 0))\n\tgoto exit;\n\n    ctxt->nodeList = list;\n    if (inst->children) {\n\txsltStackElemPtr param;\n\n\tcur = inst->children;\n\twhile (cur) {\n\n#ifdef WITH_DEBUGGER\n\t    if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n\t\txslHandleDebugger(cur, node, NULL, ctxt);\n#endif\n\t    if (ctxt->state == XSLT_STATE_STOPPED)\n\t\tbreak;\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tcur = cur->next;\n\t\tcontinue;\n\t    }\n\t    if (! IS_XSLT_ELEM(cur))\n\t\tbreak;\n\t    if (IS_XSLT_NAME(cur, \"with-param\")) {\n\t\tparam = xsltParseStylesheetCallerParam(ctxt, cur);\n\t\tif (param != NULL) {\n\t\t    param->next = withParams;\n\t\t    withParams = param;\n\t\t}\n\t    }\n\t    if (IS_XSLT_NAME(cur, \"sort\")) {\n\t\txsltTemplatePtr oldCurTempRule =\n\t\t    ctxt->currentTemplateRule;\n\t\tint nbsorts = 0;\n\t\txmlNodePtr sorts[XSLT_MAX_SORT];\n\n\t\tsorts[nbsorts++] = cur;\n\n\t\twhile (cur) {\n\n#ifdef WITH_DEBUGGER\n\t\t    if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n\t\t\txslHandleDebugger(cur, node, NULL, ctxt);\n#endif\n\t\t    if (ctxt->state == XSLT_STATE_STOPPED)\n\t\t\tbreak;\n\n\t\t    if (cur->type == XML_TEXT_NODE) {\n\t\t\tcur = cur->next;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    if (! IS_XSLT_ELEM(cur))\n\t\t\tbreak;\n\t\t    if (IS_XSLT_NAME(cur, \"with-param\")) {\n\t\t\tparam = xsltParseStylesheetCallerParam(ctxt, cur);\n\t\t\tif (param != NULL) {\n\t\t\t    param->next = withParams;\n\t\t\t    withParams = param;\n\t\t\t}\n\t\t    }\n\t\t    if (IS_XSLT_NAME(cur, \"sort\")) {\n\t\t\tif (nbsorts >= XSLT_MAX_SORT) {\n\t\t\t    xsltTransformError(ctxt, NULL, cur,\n\t\t\t\t\"The number (%d) of xsl:sort instructions exceeds the \"\n\t\t\t\t\"maximum allowed by this processor's settings.\\n\",\n\t\t\t\tnbsorts);\n\t\t\t    ctxt->state = XSLT_STATE_STOPPED;\n\t\t\t    break;\n\t\t\t} else {\n\t\t\t    sorts[nbsorts++] = cur;\n\t\t\t}\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n\t\tctxt->currentTemplateRule = NULL;\n\t\txsltDoSortFunction(ctxt, sorts, nbsorts);\n\t\tctxt->currentTemplateRule = oldCurTempRule;\n\t\tbreak;\n\t    }\n\t    cur = cur->next;\n\t}\n    }\n    xpctxt->contextSize = list->nodeNr;\n    for (i = 0; i < list->nodeNr; i++) {\n\tcur = list->nodeTab[i];\n\tctxt->node = cur;\n\tif ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n\t    xpctxt->doc = cur->doc;\n\n\txpctxt->proximityPosition = i + 1;\n\txsltProcessOneNode(ctxt, cur, withParams);\n    }\n\nexit:\nerror:\n    if (withParams != NULL)\n\txsltFreeStackElemList(withParams);\n    if (list != NULL)\n\txmlXPathFreeNodeSet(list);\n    xpctxt->nsNr = oldXPNsNr;\n    xpctxt->namespaces = oldXPNamespaces;\n     xpctxt->doc = oldXPDoc;\n     xpctxt->contextSize = oldXPContextSize;\n     xpctxt->proximityPosition = oldXPProximityPosition;\n\n    ctxt->document = oldDocInfo;\n    ctxt->nodeList = oldList;\n    ctxt->node = oldContextNode;\n    ctxt->mode = oldMode;\n    ctxt->modeURI = oldModeURI;\n}\n", "target": 1, "flaw_line_index": "14,19,45,46,63,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,79,80,298,299"}
{"idx": 188588, "func": "   virtual void Predict(MB_PREDICTION_MODE mode) {\n     mbptr_->mode_info_context->mbmi.mode = mode;\n    REGISTER_STATE_CHECK(pred_fn_(mbptr_,\n                                  data_ptr_[0] - kStride,\n                                  data_ptr_[0] - 1, kStride,\n                                  data_ptr_[0], kStride));\n   }\n", "target": 1, "flaw_line_index": "3,4,5,6"}
{"idx": 188559, "func": " void Encoder::Flush() {\n   const vpx_codec_err_t res = vpx_codec_encode(&encoder_, NULL, 0, 0, 0,\n                                                deadline_);\n  ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8565, "func": "static void ssh_free_packet(struct Packet *pkt)\n{\n    sfree(pkt->data);\n    sfree(pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9114, "func": "static int vrend_decode_set_clip_state(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_clip_state clip;\n   int i, j;\n\n   if (length != VIRGL_SET_CLIP_STATE_SIZE)\n      return EINVAL;\n\n   for (i = 0; i < 8; i++)\n      for (j = 0; j < 4; j++)\n         clip.ucp[i][j] = uif(get_buf_entry(ctx, VIRGL_SET_CLIP_STATE_C0 + (i * 4) + j));\n   vrend_set_clip_state(ctx->grctx, &clip);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9130, "func": "int vrend_renderer_context_create(uint32_t handle, uint32_t nlen, const char *debug_name)\n{\n   if (handle >= VREND_MAX_CTX)\n      return EINVAL;\n\n   if (handle == 0)\n      return EINVAL;\n\n   vrend_renderer_context_create_internal(handle, nlen, debug_name);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9109, "func": "static int vrend_decode_get_query_result(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 2)\n      return EINVAL;\n\n   uint32_t handle = get_buf_entry(ctx, VIRGL_QUERY_RESULT_HANDLE);\n   uint32_t wait = get_buf_entry(ctx, VIRGL_QUERY_RESULT_WAIT);\n\n   vrend_get_query_result(ctx->grctx, handle, wait);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8382, "func": "static void mptsas_reset(DeviceState *dev)\n{\n    MPTSASState *s = MPT_SAS(dev);\n\n    mptsas_hard_reset(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8523, "func": "static void s_wrpkt(Ssh ssh, struct Packet *pkt)\n{\n    int len, backlog, offset;\n    len = s_wrpkt_prepare(ssh, pkt, &offset);\n    backlog = s_write(ssh, pkt->data + offset, len);\n    if (backlog > SSH_MAX_BACKLOG)\n\tssh_throttle_all(ssh, 1, backlog);\n    ssh_free_packet(pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187791, "func": "bool ATSParser::PSISection::isCRCOkay() const {\n if (!isComplete()) {\n return false;\n }\n uint8_t* data = mBuffer->data();\n\n if ((data[1] & 0x80) == 0) {\n return true;\n }\n\n\n     unsigned sectionLength = U16_AT(data + 1) & 0xfff;\n     ALOGV(\"sectionLength %u, skip %u\", sectionLength, mSkipBytes);\n \n     sectionLength -= mSkipBytes;\n \n uint32_t crc = 0xffffffff;\n for(unsigned i = 0; i < sectionLength + 4 \n; i++) {\n uint8_t b = data[i];\n int index = ((crc >> 24) ^ (b & 0xff)) & 0xff;\n        crc = CRC_TABLE[index] ^ (crc << 8);\n }\n    ALOGV(\"crc: %08x\\n\", crc);\n return (crc == 0);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8988, "func": "static void vmxnet3_fill_stats(VMXNET3State *s)\n{\n    int i;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    if (!s->device_active)\n        return;\n\n    for (i = 0; i < s->txq_num; i++) {\n        pci_dma_write(d,\n                      s->txq_descr[i].tx_stats_pa,\n                      &s->txq_descr[i].txq_stats,\n                      sizeof(s->txq_descr[i].txq_stats));\n    }\n\n    for (i = 0; i < s->rxq_num; i++) {\n        pci_dma_write(d,\n                      s->rxq_descr[i].rx_stats_pa,\n                      &s->rxq_descr[i].rxq_stats,\n                      sizeof(s->rxq_descr[i].rxq_stats));\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8775, "func": "static NOINLINE int send_discover(uint32_t xid, uint32_t requested)\n{\n\tstruct dhcp_packet packet;\n\n\tinit_packet(&packet, DHCPDISCOVER);\n\n\tpacket.xid = xid;\n\tif (requested)\n\t\tudhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);\n\n\tadd_client_options(&packet);\n\n\tbb_error_msg(\"sending %s\", \"discover\");\n\treturn raw_bcast_from_client_config_ifindex(&packet, INADDR_ANY);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187778, "func": "static int fx_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n struct effect_s *effect = (struct effect_s *)self;\n\n if (effect == NULL)\n return -EINVAL;\n\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || *replySize != sizeof(int))\n return -EINVAL;\n\n *(int *)pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG: {\n if (pCmdData    == NULL||\n                    cmdSize     != sizeof(effect_config_t)||\n                    pReplyData  == NULL||\n *replySize  != sizeof(int)) {\n                ALOGV(\"fx_command() EFFECT_CMD_SET_CONFIG invalid args\");\n return -EINVAL;\n }\n *(int *)pReplyData = session_set_config(effect->session, (effect_config_t *)pCmdData);\n if (*(int *)pReplyData != 0)\n break;\n\n if (effect->state != EFFECT_STATE_ACTIVE)\n *(int *)pReplyData = effect_set_state(effect, EFFECT_STATE_CONFIG);\n\n } break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL ||\n *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"fx_command() EFFECT_CMD_GET_CONFIG invalid args\");\n return -EINVAL;\n }\n\n            session_get_config(effect->session, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n break;\n\n case EFFECT_CMD_GET_PARAM: {\n\n             if (pCmdData == NULL ||\n                     cmdSize < (int)sizeof(effect_param_t) ||\n                     pReplyData == NULL ||\n                    *replySize < (int)sizeof(effect_param_t)) {\n                 ALOGV(\"fx_command() EFFECT_CMD_GET_PARAM invalid args\");\n                 return -EINVAL;\n             }\n effect_param_t *p = (effect_param_t *)pCmdData;\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n            p = (effect_param_t *)pReplyData;\n            p->status = -ENOSYS;\n\n } break;\n\n case EFFECT_CMD_SET_PARAM: {\n if (pCmdData == NULL||\n                    cmdSize < (int)sizeof(effect_param_t) ||\n                    pReplyData == NULL ||\n *replySize != sizeof(int32_t)) {\n                ALOGV(\"fx_command() EFFECT_CMD_SET_PARAM invalid args\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)) {\n                ALOGV(\"fx_command() EFFECT_CMD_SET_PARAM invalid param format\");\n return -EINVAL;\n }\n *(int *)pReplyData = -ENOSYS;\n } break;\n\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"fx_command() EFFECT_CMD_ENABLE invalid args\");\n return -EINVAL;\n }\n *(int *)pReplyData = effect_set_state(effect, EFFECT_STATE_ACTIVE);\n break;\n\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"fx_command() EFFECT_CMD_DISABLE invalid args\");\n return -EINVAL;\n }\n *(int *)pReplyData  = effect_set_state(effect, EFFECT_STATE_CONFIG);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_INPUT_DEVICE:\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n if (pCmdData == NULL ||\n                    cmdSize != sizeof(uint32_t)) {\n                ALOGV(\"fx_command() %s invalid args\",\n                      cmdCode == EFFECT_CMD_SET_DEVICE ? \"EFFECT_CMD_SET_DEVICE\" :\n                      cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? \"EFFECT_CMD_SET_INPUT_DEVICE\" :\n                      cmdCode == EFFECT_CMD_SET_VOLUME ? \"EFFECT_CMD_SET_VOLUME\" :\n                      cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? \"EFFECT_CMD_SET_AUDIO_MODE\" :\n \"\");\n return -EINVAL;\n }\n            ALOGV(\"fx_command() %s value %08x\",\n                  cmdCode == EFFECT_CMD_SET_DEVICE ? \"EFFECT_CMD_SET_DEVICE\" :\n                  cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? \"EFFECT_CMD_SET_INPUT_DEVICE\" :\n                  cmdCode == EFFECT_CMD_SET_VOLUME ? \"EFFECT_CMD_SET_VOLUME\" :\n                  cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? \"EFFECT_CMD_SET_AUDIO_MODE\":\n \"\",\n *(int *)pCmdData);\n break;\n\n default:\n return -EINVAL;\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": "58"}
{"idx": 9016, "func": "vmxnet3_is_allowed_mcast_group(VMXNET3State *s, const uint8_t *group_mac)\n{\n    int i;\n    for (i = 0; i < s->mcast_list_len; i++) {\n        if (!memcmp(group_mac, s->mcast_list[i].a, sizeof(s->mcast_list[i]))) {\n            return true;\n        }\n    }\n    return false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187970, "func": "void impeg2d_dec_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n stream_t *ps_stream;\n\n    ps_stream    = &ps_dec->s_bit_stream;\n    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n\n\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n }\n}\n", "target": 1, "flaw_line_index": "13"}
{"idx": 8813, "func": "static inline GLenum to_gl_swizzle(int swizzle)\n{\n   switch (swizzle) {\n   case PIPE_SWIZZLE_RED: return GL_RED;\n   case PIPE_SWIZZLE_GREEN: return GL_GREEN;\n   case PIPE_SWIZZLE_BLUE: return GL_BLUE;\n   case PIPE_SWIZZLE_ALPHA: return GL_ALPHA;\n   case PIPE_SWIZZLE_ZERO: return GL_ZERO;\n   case PIPE_SWIZZLE_ONE: return GL_ONE;\n   default:\n      assert(0);\n      return 0;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8424, "func": "pvscsi_on_cmd_reset_bus(PVSCSIState *s)\n{\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_RESET_BUS\");\n\n    s->resetting++;\n    qbus_reset_all_fn(&s->bus);\n    s->resetting--;\n    return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8671, "func": "static int mptsas_phy_addr_get(MPTSASState *s, int address)\n{\n    int i;\n    if ((address >> MPI_SAS_PHY_PGAD_FORM_SHIFT) == 0) {\n        i = address & 255;\n    } else if ((address >> MPI_SAS_PHY_PGAD_FORM_SHIFT) == 1) {\n        i = address & 65535;\n    } else {\n        return -EINVAL;\n    }\n\n    if (i >= MPTSAS_NUM_PORTS) {\n        return -EINVAL;\n    }\n\n    return i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9171, "func": "void vrend_renderer_blit_gl(struct vrend_context *ctx,\n                            struct vrend_resource *src_res,\n                            struct vrend_resource *dst_res,\n                            const struct pipe_blit_info *info)\n{\n   struct vrend_blitter_ctx *blit_ctx = &vrend_blit_ctx;\n   GLuint prog_id;\n   GLuint fs_id;\n   GLint lret;\n   GLenum filter;\n   GLuint pos_loc, tc_loc;\n   GLuint samp_loc;\n   bool has_depth, has_stencil;\n   bool blit_stencil, blit_depth;\n   int dst_z;\n   const struct util_format_description *src_desc =\n      util_format_description(src_res->base.format);\n   const struct util_format_description *dst_desc =\n      util_format_description(dst_res->base.format);\n\n   has_depth = util_format_has_depth(src_desc) &&\n      util_format_has_depth(dst_desc);\n   has_stencil = util_format_has_stencil(src_desc) &&\n      util_format_has_stencil(dst_desc);\n\n   blit_depth = has_depth && (info->mask & PIPE_MASK_Z);\n   blit_stencil = has_stencil && (info->mask & PIPE_MASK_S) & 0;\n\n   filter = convert_mag_filter(info->filter);\n   vrend_renderer_init_blit_ctx(blit_ctx);\n\n   blitter_set_dst_dim(blit_ctx,\n                       u_minify(dst_res->base.width0, info->dst.level),\n                       u_minify(dst_res->base.height0, info->dst.level));\n\n   blitter_set_rectangle(blit_ctx, info->dst.box.x, info->dst.box.y,\n                         info->dst.box.x + info->dst.box.width,\n                         info->dst.box.y + info->dst.box.height, 0);\n\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, blit_ctx->vs);\n\n   if (blit_depth || blit_stencil)\n      fs_id = blit_get_frag_tex_writedepth(blit_ctx, src_res->base.target, src_res->base.nr_samples);\n   else if (vrend_format_is_emulated_alpha(info->dst.format))\n      fs_id = blit_get_frag_tex_col_emu_alpha(blit_ctx, src_res->base.target, src_res->base.nr_samples);\n   else\n      fs_id = blit_get_frag_tex_col(blit_ctx, src_res->base.target, src_res->base.nr_samples);\n   glAttachShader(prog_id, fs_id);\n\n   glLinkProgram(prog_id);\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      glDeleteProgram(prog_id);\n      return;\n   }\n\n   glUseProgram(prog_id);\n\n   glBindFramebuffer(GL_FRAMEBUFFER_EXT, blit_ctx->fb_id);\n   vrend_fb_bind_texture(dst_res, 0, info->dst.level, info->dst.box.z);\n\n   glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);\n\n   glBindTexture(src_res->target, src_res->id);\n\n   if (vrend_format_is_emulated_alpha(info->src.format))\n      glTexParameteri(src_res->target, GL_TEXTURE_SWIZZLE_R, GL_ALPHA);\n\n   glTexParameteri(src_res->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n   glTexParameteri(src_res->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n   glTexParameteri(src_res->target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n\n   glTexParameteri(src_res->target, GL_TEXTURE_BASE_LEVEL, info->src.level);\n   glTexParameteri(src_res->target, GL_TEXTURE_MAX_LEVEL, info->src.level);\n   glTexParameterf(src_res->target, GL_TEXTURE_MAG_FILTER, filter);\n   glTexParameterf(src_res->target, GL_TEXTURE_MIN_FILTER, filter);\n   pos_loc = glGetAttribLocation(prog_id, \"arg0\");\n   tc_loc = glGetAttribLocation(prog_id, \"arg1\");\n   samp_loc = glGetUniformLocation(prog_id, \"samp\");\n\n   glUniform1i(samp_loc, 0);\n\n   glVertexAttribPointer(pos_loc, 4, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void *)0);\n   glVertexAttribPointer(tc_loc, 4, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void *)(4 * sizeof(float)));\n\n   glEnableVertexAttribArray(pos_loc);\n   glEnableVertexAttribArray(tc_loc);\n\n   set_dsa_write_depth_keep_stencil();\n\n   for (dst_z = 0; dst_z < info->dst.box.depth; dst_z++) {\n      float dst2src_scale = info->src.box.depth / (float)info->dst.box.depth;\n      float dst_offset = ((info->src.box.depth - 1) -\n                          (info->dst.box.depth - 1) * dst2src_scale) * 0.5;\n      float src_z = (dst_z + dst_offset) * dst2src_scale;\n\n      glBindFramebuffer(GL_FRAMEBUFFER_EXT, blit_ctx->fb_id);\n      vrend_fb_bind_texture(dst_res, 0, info->dst.level, dst_z);\n\n      glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);\n      blitter_set_texcoords(blit_ctx, src_res, info->src.level,\n                            info->src.box.z + src_z, 0,\n                            info->src.box.x, info->src.box.y,\n                            info->src.box.x + info->src.box.width,\n                            info->src.box.y + info->src.box.height);\n\n      glBufferData(GL_ARRAY_BUFFER, sizeof(blit_ctx->vertices), blit_ctx->vertices, GL_STATIC_DRAW);\n      glDrawArrays(GL_TRIANGLE_FAN, 0, 4);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8902, "func": "void vrend_renderer_force_ctx_0(void)\n{\n   struct vrend_context *ctx0 = vrend_lookup_renderer_ctx(0);\n   vrend_state.current_ctx = NULL;\n   vrend_state.current_hw_ctx = NULL;\n   vrend_hw_switch_context(ctx0, true);\n   vrend_clicbs->make_current(0, ctx0->sub->gl_context);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9139, "func": "static boolean is_alpha_underscore( const char *cur )\n{\n   return\n      (*cur >= 'a' && *cur <= 'z') ||\n      (*cur >= 'A' && *cur <= 'Z') ||\n      *cur == '_';\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187720, "func": "standard_info_part1(standard_display *dp, png_structp pp, png_infop pi)\n{\n if (png_get_bit_depth(pp, pi) != dp->bit_depth)\n      png_error(pp, \"validate: bit depth changed\");\n\n if (png_get_color_type(pp, pi) != dp->colour_type)\n      png_error(pp, \"validate: color type changed\");\n\n if (png_get_filter_type(pp, pi) != PNG_FILTER_TYPE_BASE)\n      png_error(pp, \"validate: filter type changed\");\n\n if (png_get_interlace_type(pp, pi) != dp->interlace_type)\n      png_error(pp, \"validate: interlacing changed\");\n\n if (png_get_compression_type(pp, pi) != PNG_COMPRESSION_TYPE_BASE)\n      png_error(pp, \"validate: compression type changed\");\n\n   dp->w = png_get_image_width(pp, pi);\n\n if (dp->w != standard_width(pp, dp->id))\n      png_error(pp, \"validate: image width changed\");\n\n   dp->h = png_get_image_height(pp, pi);\n\n if (dp->h != standard_height(pp, dp->id))\n      png_error(pp, \"validate: image height changed\");\n\n {\n      png_color_8p sBIT = 0;\n\n if (png_get_sBIT(pp, pi, &sBIT) & PNG_INFO_sBIT)\n {\n int sBIT_invalid = 0;\n\n if (sBIT == 0)\n            png_error(pp, \"validate: unexpected png_get_sBIT result\");\n\n if (dp->colour_type & PNG_COLOR_MASK_COLOR)\n {\n if (sBIT->red == 0 || sBIT->red > dp->bit_depth)\n               sBIT_invalid = 1;\n else\n               dp->red_sBIT = sBIT->red;\n\n if (sBIT->green == 0 || sBIT->green > dp->bit_depth)\n               sBIT_invalid = 1;\n else\n               dp->green_sBIT = sBIT->green;\n\n if (sBIT->blue == 0 || sBIT->blue > dp->bit_depth)\n               sBIT_invalid = 1;\n else\n               dp->blue_sBIT = sBIT->blue;\n }\n\n else \n {\n if (sBIT->gray == 0 || sBIT->gray > dp->bit_depth)\n               sBIT_invalid = 1;\n else\n               dp->blue_sBIT = dp->green_sBIT = dp->red_sBIT = sBIT->gray;\n }\n\n if (dp->colour_type & PNG_COLOR_MASK_ALPHA)\n {\n if (sBIT->alpha == 0 || sBIT->alpha > dp->bit_depth)\n               sBIT_invalid = 1;\n else\n               dp->alpha_sBIT = sBIT->alpha;\n }\n\n if (sBIT_invalid)\n            png_error(pp, \"validate: sBIT value out of range\");\n }\n }\n\n if (png_get_rowbytes(pp, pi) != standard_rowsize(pp, dp->id))\n      png_error(pp, \"validate: row size changed\");\n\n   standard_palette_validate(dp, pp, pi);\n\n {\n      png_color_16p trans_color = 0;\n\n if (png_get_tRNS(pp, pi, 0, 0, &trans_color) & PNG_INFO_tRNS)\n {\n if (trans_color == 0)\n            png_error(pp, \"validate: unexpected png_get_tRNS (color) result\");\n\n switch (dp->colour_type)\n {\n\n          case 0:\n             dp->transparent.red = dp->transparent.green = dp->transparent.blue =\n                trans_color->gray;\n            dp->is_transparent = 1;\n             break;\n \n          case 2:\n             dp->transparent.red = trans_color->red;\n             dp->transparent.green = trans_color->green;\n             dp->transparent.blue = trans_color->blue;\n            dp->is_transparent = 1;\n             break;\n \n          case 3:\n            png_error(pp, \"validate: unexpected png_get_tRNS result\");\n break;\n\n default:\n            png_error(pp, \"validate: invalid tRNS chunk with alpha image\");\n }\n }\n }\n\n    dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type);\n   if (!dp->do_interlace && dp->npasses != png_set_interlace_handling(pp))\n      png_error(pp, \"validate: file changed interlace type\");\n \n}\n", "target": 1, "flaw_line_index": "96,103,117,118"}
{"idx": 188514, "func": "static void get_frame_stats(vpx_codec_ctx_t *ctx,\n                            const vpx_image_t *img,\n                            vpx_codec_pts_t pts,\n                            unsigned int duration,\n                            vpx_enc_frame_flags_t flags,\n                            unsigned int deadline,\n                            vpx_fixed_buf_t *stats) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\n                                               deadline);\n if (res != VPX_CODEC_OK)\n\n     die_codec(ctx, \"Failed to get frame stats.\");\n \n   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_STATS_PKT) {\n       const uint8_t *const pkt_buf = pkt->data.twopass_stats.buf;\n       const size_t pkt_size = pkt->data.twopass_stats.sz;\n      stats->buf = realloc(stats->buf, stats->sz + pkt_size);\n      memcpy((uint8_t *)stats->buf + stats->sz, pkt_buf, pkt_size);\n\n       stats->sz += pkt_size;\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 188211, "func": "OMX_ERRORTYPE SoftAACEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mBitRate = aacParams->nBitRate;\n            mNumChannels = aacParams->nChannels;\n            mSampleRate = aacParams->nSampleRate;\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9070, "func": "static void vmxnet3_update_interrupt_line_state(VMXNET3State *s, int lidx)\n{\n    if (!s->interrupt_states[lidx].is_pending &&\n       s->interrupt_states[lidx].is_asserted) {\n        VMW_IRPRN(\"New interrupt line state for index %d is DOWN\", lidx);\n        _vmxnet3_deassert_interrupt_line(s, lidx);\n        s->interrupt_states[lidx].is_asserted = false;\n        return;\n    }\n\n    if (s->interrupt_states[lidx].is_pending &&\n       !s->interrupt_states[lidx].is_masked &&\n       !s->interrupt_states[lidx].is_asserted) {\n        VMW_IRPRN(\"New interrupt line state for index %d is UP\", lidx);\n        s->interrupt_states[lidx].is_asserted =\n            _vmxnet3_assert_interrupt_line(s, lidx);\n        s->interrupt_states[lidx].is_pending = false;\n        return;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187369, "func": "int LE_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n LoudnessEnhancerContext * pContext = (LoudnessEnhancerContext *)self;\n int retsize;\n\n if (pContext == NULL || pContext->mState == LOUDNESS_ENHANCER_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = LE_init(pContext);\n\n         break;\n     case EFFECT_CMD_SET_CONFIG:\n         if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n                || pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         *(int *) pReplyData = LE_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL ||\n *replySize != sizeof(effect_config_t)) {\n return -EINVAL;\n }\n        LE_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n\n         LE_reset(pContext);\n         break;\n     case EFFECT_CMD_ENABLE:\n        if (pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         if (pContext->mState != LOUDNESS_ENHANCER_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pContext->mState = LOUDNESS_ENHANCER_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != LOUDNESS_ENHANCER_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pContext->mState = LOUDNESS_ENHANCER_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n\n     case EFFECT_CMD_GET_PARAM: {\n         if (pCmdData == NULL ||\n             cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL ||\n             *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {\n             return -EINVAL;\n         }\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));\n effect_param_t *p = (effect_param_t *)pReplyData;\n        p->status = 0;\n *replySize = sizeof(effect_param_t) + sizeof(uint32_t);\n if (p->psize != sizeof(uint32_t)) {\n            p->status = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:\n            ALOGV(\"get target gain(mB) = %d\", pContext->mTargetGainmB);\n *((int32_t *)p->data + 1) = pContext->mTargetGainmB;\n            p->vsize = sizeof(int32_t);\n *replySize += sizeof(int32_t);\n break;\n default:\n            p->status = -EINVAL;\n }\n } break;\n\n     case EFFECT_CMD_SET_PARAM: {\n         if (pCmdData == NULL ||\n             cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || *replySize != sizeof(int32_t)) {\n             return -EINVAL;\n         }\n         *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {\n *(int32_t *)pReplyData = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:\n            pContext->mTargetGainmB = *((int32_t *)p->data + 1);\n            ALOGV(\"set target gain(mB) = %d\", pContext->mTargetGainmB);\n            LE_reset(pContext); \n break;\n default:\n *(int32_t *)pReplyData = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n        ALOGW(\"LE_command invalid command %d\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "22,40,65,92"}
{"idx": 188512, "func": "void usage_exit() {\n   fprintf(stderr,\n           \"Usage: %s <codec> <width> <height> <infile> <outfile> \"\n               \"<keyframe-interval> [<error-resilient>]\\nSee comments in \"\n \"simple_encoder.c for more information.\\n\",\n          exec_name);\n\n   exit(EXIT_FAILURE);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187331, "func": "xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,\n\t\t\t\t xmlNodePtr node,\n \t\t\t\t xsltCompMatchPtr countPat,\n \t\t\t\t xsltCompMatchPtr fromPat,\n \t\t\t\t double *array,\n\t\t\t\t int max,\n\t\t\t\t xmlDocPtr doc,\n\t\t\t\t xmlNodePtr elem)\n {\n     int amount = 0;\n     int cnt;\n    xmlNodePtr ancestor;\n    xmlNodePtr preceding;\n    xmlXPathParserContextPtr parser;\n\n    context->xpathCtxt->node = node;\n    parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);\n    if (parser) {\n\tfor (ancestor = node;\n\t     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);\n\t     ancestor = xmlXPathNextAncestor(parser, ancestor)) {\n\n\t    if ((fromPat != NULL) &&\n \t\txsltTestCompMatchList(context, ancestor, fromPat))\n \t\tbreak; \n \n\t    if ((countPat == NULL && node->type == ancestor->type &&\n\t\txmlStrEqual(node->name, ancestor->name)) ||\n\t\txsltTestCompMatchList(context, ancestor, countPat)) {\n\t\tcnt = 0;\n\t\tfor (preceding = ancestor;\n \t\t     preceding != NULL;\n \t\t     preceding =\n \t\t        xmlXPathNextPrecedingSibling(parser, preceding)) {\n\t\t    if (countPat == NULL) {\n\t\t\tif ((preceding->type == ancestor->type) &&\n\t\t\t    xmlStrEqual(preceding->name, ancestor->name)){\n\t\t\t    if ((preceding->ns == ancestor->ns) ||\n\t\t\t        ((preceding->ns != NULL) &&\n\t\t\t\t (ancestor->ns != NULL) &&\n\t\t\t         (xmlStrEqual(preceding->ns->href,\n\t\t\t             ancestor->ns->href) )))\n\t\t\t        cnt++;\n\t\t\t}\n\t\t    } else {\n\t\t\tif (xsltTestCompMatchList(context, preceding,\n\t\t\t\t                  countPat))\n\t\t\t    cnt++;\n\t\t    }\n \t\t}\n \t\tarray[amount++] = (double)cnt;\n \t\tif (amount >= max)\n\t\t    break; \n\t    }\n\t}\n\txmlXPathFreeParserContext(parser);\n    }\n    return amount;\n}\n", "target": 1, "flaw_line_index": "6,7,8,27,28,29,30,31,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49"}
{"idx": 9203, "func": "VirtQueue *virtio_get_queue(VirtIODevice *vdev, int n)\n{\n    return vdev->vq + n;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188164, "func": " status_t OMXNodeInstance::updateNativeHandleInMeta(\n        OMX_U32 portIndex, const sp<NativeHandle>& nativeHandle, OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n if (header == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n\n if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n return BAD_VALUE;\n }\n\n\n     BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);\n     sp<ABuffer> data = bufferMeta->getBuffer(\n            header, portIndex == kPortIndexInput \n);\n     bufferMeta->setNativeHandle(nativeHandle);\n     if (mMetadataType[portIndex] == kMetadataBufferTypeNativeHandleSource\n             && data->capacity() >= sizeof(VideoNativeHandleMetadata)) {\n VideoNativeHandleMetadata &metadata = *(VideoNativeHandleMetadata *)(data->data());\n        metadata.eType = mMetadataType[portIndex];\n        metadata.pHandle =\n            nativeHandle == NULL ? NULL : const_cast<native_handle*>(nativeHandle->handle());\n } else {\n        CLOG_ERROR(updateNativeHandleInMeta, BAD_VALUE, \"%s:%u, %#x bad type (%d) or size (%zu)\",\n            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], data->capacity());\n return BAD_VALUE;\n }\n\n    CLOG_BUFFER(updateNativeHandleInMeta, \"%s:%u, %#x := %p\",\n            portString(portIndex), portIndex, buffer,\n            nativeHandle == NULL ? NULL : nativeHandle->handle());\n return OK;\n}\n", "target": 1, "flaw_line_index": "20"}
{"idx": 187698, "func": "static int output_quantization_factor(PNG_CONST png_modifier *pm, int in_depth,\n    int out_depth)\n {\n    if (out_depth == 16 && in_depth != 16 &&\n      pm->calculations_use_input_precision)\n return 257;\n else\n return 1;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9162, "func": "static GLuint blit_get_frag_tex_col_emu_alpha(struct vrend_blitter_ctx *blit_ctx, int pipe_tex_target, unsigned nr_samples)\n{\n   assert(pipe_tex_target < PIPE_MAX_TEXTURE_TYPES);\n\n   if (nr_samples > 1) {\n      return 0;\n   } else {\n      GLuint *shader = &blit_ctx->fs_texfetch_col_emu_alpha[pipe_tex_target];\n\n      if (!*shader) {\n         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex_target, 0);\n\n         *shader = blit_build_frag_tex_col_emu_alpha(blit_ctx, tgsi_tex);\n      }\n      return *shader;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188556, "func": " vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {\n   vpx_codec_err_t res_dec;\n   InitOnce();\n  REGISTER_STATE_CHECK(\n       res_dec = vpx_codec_decode(&decoder_,\n                                  cxdata, static_cast<unsigned int>(size),\n                                 NULL, 0));\n   return res_dec;\n }\n", "target": 1, "flaw_line_index": "4,7"}
{"idx": 187908, "func": "bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,\n\n                                uint8_t pin_len, bt_pin_code_t *pin_code)\n {\n     BTIF_TRACE_EVENT(\"%s: accept=%d\", __FUNCTION__, accept);\n    if (pin_code == NULL)\n         return BT_STATUS_FAIL;\n #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))\n \n if (pairing_cb.is_le_only)\n {\n int i;\n        UINT32 passkey = 0;\n int multi[] = {100000, 10000, 1000, 100, 10,1};\n        BD_ADDR remote_bd_addr;\n        bdcpy(remote_bd_addr, bd_addr->address);\n for (i = 0; i < 6; i++)\n {\n            passkey += (multi[i] * (pin_code->pin[i] - '0'));\n }\n        BTIF_TRACE_DEBUG(\"btif_dm_pin_reply: passkey: %d\", passkey);\n        BTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);\n\n }\n else\n {\n        BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n if (accept)\n            pairing_cb.pin_code_len = pin_len;\n }\n#else\n    BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n\n if (accept)\n        pairing_cb.pin_code_len = pin_len;\n#endif\n return BT_STATUS_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8945, "func": "void vrend_set_uniform_buffer(struct vrend_context *ctx,\n                              uint32_t shader,\n                              uint32_t index,\n                              uint32_t offset,\n                              uint32_t length,\n                              uint32_t res_handle)\n{\n   struct vrend_resource *res;\n\n   if (res_handle) {\n      res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n\n      if (!res) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n         return;\n      }\n      vrend_resource_reference((struct vrend_resource **)&ctx->sub->cbs[shader][index].buffer, res);\n      ctx->sub->cbs[shader][index].buffer_offset = offset;\n      ctx->sub->cbs[shader][index].buffer_size = length;\n\n      ctx->sub->const_bufs_used_mask[shader] |= (1 << index);\n   } else {\n      vrend_resource_reference((struct vrend_resource **)&ctx->sub->cbs[shader][index].buffer, NULL);\n      ctx->sub->cbs[shader][index].buffer_offset = 0;\n      ctx->sub->cbs[shader][index].buffer_size = 0;\n      ctx->sub->const_bufs_used_mask[shader] &= ~(1 << index);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9068, "func": "vmxnet3_unuse_msix_vectors(VMXNET3State *s, int num_vectors)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    int i;\n    for (i = 0; i < num_vectors; i++) {\n        msix_vector_unuse(d, i);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9117, "func": "static int vrend_decode_set_index_buffer(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1 && length != 3)\n      return EINVAL;\n   vrend_set_index_buffer(ctx->grctx,\n                          get_buf_entry(ctx, VIRGL_SET_INDEX_BUFFER_HANDLE),\n                          (length == 3) ? get_buf_entry(ctx, VIRGL_SET_INDEX_BUFFER_INDEX_SIZE) : 0,\n                          (length == 3) ? get_buf_entry(ctx, VIRGL_SET_INDEX_BUFFER_OFFSET) : 0);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187793, "func": "SampleTable::SampleTable(const sp<DataSource> &source)\n : mDataSource(source),\n      mChunkOffsetOffset(-1),\n      mChunkOffsetType(0),\n      mNumChunkOffsets(0),\n      mSampleToChunkOffset(-1),\n      mNumSampleToChunkOffsets(0),\n      mSampleSizeOffset(-1),\n\n       mSampleSizeFieldSize(0),\n       mDefaultSampleSize(0),\n       mNumSampleSizes(0),\n       mTimeToSampleCount(0),\n       mTimeToSample(),\n       mSampleTimeEntries(NULL),\n      mCompositionTimeDeltaEntries(NULL),\n      mNumCompositionTimeDeltaEntries(0),\n      mCompositionDeltaLookup(new CompositionDeltaLookup),\n      mSyncSampleOffset(-1),\n      mNumSyncSamples(0),\n      mSyncSamples(NULL),\n      mLastSyncSampleIndex(0),\n      mSampleToChunkEntries(NULL) {\n    mSampleIterator = new SampleIterator(this);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8983, "func": "vmxnet3_dec_rx_completion_counter(VMXNET3State *s, int qidx)\n{\n    vmxnet3_ring_dec(&s->rxq_descr[qidx].comp_ring);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187328, "func": "xsltNumberFormat(xsltTransformContextPtr ctxt,\n\t\t xsltNumberDataPtr data,\n\t\t xmlNodePtr node)\n{\n    xmlBufferPtr output = NULL;\n     int amount, i;\n     double number;\n     xsltFormat tokens;\n    int tempformat = 0;\n \n    if ((data->format == NULL) && (data->has_format != 0)) {\n\tdata->format = xsltEvalAttrValueTemplate(ctxt, data->node,\n \t\t\t\t\t     (const xmlChar *) \"format\",\n \t\t\t\t\t     XSLT_NAMESPACE);\n\ttempformat = 1;\n    }\n    if (data->format == NULL) {\n\treturn;\n     }\n \n     output = xmlBufferCreate();\n     if (output == NULL)\n \tgoto XSLT_NUMBER_FORMAT_END;\n \n    xsltNumberFormatTokenize(data->format, &tokens);\n    if (data->value) {\n\tamount = xsltNumberFormatGetValue(ctxt->xpathCtxt,\n\t\t\t\t\t  node,\n\t\t\t\t\t  data->value,\n\t\t\t\t\t  &number);\n\tif (amount == 1) {\n\t    xsltNumberFormatInsertNumbers(data,\n\t\t\t\t\t  &number,\n\t\t\t\t\t  1,\n\t\t\t\t\t  &tokens,\n\t\t\t\t\t  output);\n\t}\n\n    } else if (data->level) {\n\n\tif (xmlStrEqual(data->level, (const xmlChar *) \"single\")) {\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      &number,\n\t\t\t\t\t\t      1,\n\t\t\t\t\t\t      data->doc,\n\t\t\t\t\t\t      data->node);\n \t    if (amount == 1) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"multiple\")) {\n\t    double numarray[1024];\n\t    int max = sizeof(numarray)/sizeof(numarray[0]);\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      numarray,\n\t\t\t\t\t\t      max,\n\t\t\t\t\t\t      data->doc,\n\t\t\t\t\t\t      data->node);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      numarray,\n\t\t\t\t\t      amount,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"any\")) {\n\t    amount = xsltNumberFormatGetAnyLevel(ctxt,\n \t\t\t\t\t\t node,\n \t\t\t\t\t\t data->countPat,\n \t\t\t\t\t\t data->fromPat,\n\t\t\t\t\t\t &number,\n\t\t\t\t\t\t data->doc,\n\t\t\t\t\t\t data->node);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t}\n    }\n     xsltCopyTextString(ctxt, ctxt->insert, xmlBufferContent(output), 0);\n \n     if (tokens.start != NULL)\n \txmlFree(tokens.start);\n     if (tokens.end != NULL)\n\txmlFree(tokens.end);\n    for (i = 0;i < tokens.nTokens;i++) {\n \tif (tokens.tokens[i].separator != NULL)\n \t    xmlFree(tokens.tokens[i].separator);\n     }\nXSLT_NUMBER_FORMAT_END:\n    if (tempformat == 1) {\n\tdata->format = NULL;\n    }\n    if (output != NULL)\n\txmlBufferFree(output);\n }\n", "target": 1, "flaw_line_index": "9,11,12,15,16,17,18,25,47,48,49,65,66,67,80,81,82,102,103,103,104,105,106,107"}
{"idx": 188607, "func": " void VarianceTest<VarianceFunctionType>::OneQuarterTest() {\n  memset(src_, 255, block_size_);\n   const int half = block_size_ / 2;\n  memset(ref_, 255, half);\n  memset(ref_ + half, 0, half);\n   unsigned int sse;\n   unsigned int var;\n  REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n   const unsigned int expected = block_size_ * 255 * 255 / 4;\n   EXPECT_EQ(expected, var);\n }\n", "target": 1, "flaw_line_index": "2,4,5,8"}
{"idx": 187643, "func": "image_transform_default_ini(PNG_CONST image_transform *this,\n     transform_display *that)\n {\n    this->next->ini(this->next, that);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8830, "func": "int vrend_create_query(struct vrend_context *ctx, uint32_t handle,\n                       uint32_t query_type, uint32_t query_index,\n                       uint32_t res_handle, uint32_t offset)\n{\n   struct vrend_query *q;\n   struct vrend_resource *res;\n   uint32_t ret_handle;\n   res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n   if (!res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n      return EINVAL;\n   }\n\n   q = CALLOC_STRUCT(vrend_query);\n   if (!q)\n      return ENOMEM;\n\n   list_inithead(&q->waiting_queries);\n   q->type = query_type;\n   q->index = query_index;\n   q->ctx_id = ctx->ctx_id;\n\n   vrend_resource_reference(&q->res, res);\n\n   switch (q->type) {\n   case PIPE_QUERY_OCCLUSION_COUNTER:\n      q->gltype = GL_SAMPLES_PASSED_ARB;\n      break;\n   case PIPE_QUERY_OCCLUSION_PREDICATE:\n      q->gltype = GL_ANY_SAMPLES_PASSED;\n      break;\n   case PIPE_QUERY_TIMESTAMP:\n      q->gltype = GL_TIMESTAMP;\n      break;\n   case PIPE_QUERY_TIME_ELAPSED:\n      q->gltype = GL_TIME_ELAPSED;\n      break;\n   case PIPE_QUERY_PRIMITIVES_GENERATED:\n      q->gltype = GL_PRIMITIVES_GENERATED;\n      break;\n   case PIPE_QUERY_PRIMITIVES_EMITTED:\n      q->gltype = GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN;\n      break;\n   default:\n      fprintf(stderr,\"unknown query object received %d\\n\", q->type);\n      break;\n   }\n\n   glGenQueries(1, &q->id);\n\n   ret_handle = vrend_renderer_object_insert(ctx, q, sizeof(struct vrend_query), handle,\n                                             VIRGL_OBJECT_QUERY);\n   if (!ret_handle) {\n      FREE(q);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187847, "func": "void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision) {\n   major = 1;\n   minor = 0;\n   build = 0;\n  revision = 28;\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 187869, "func": "long Cluster::ParseBlockGroup(long long payload_size, long long& pos,\n long& len) {\n const long long payload_start = pos;\n const long long payload_stop = pos + payload_size;\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long total, avail;\n\n long status = pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n\n if ((total >= 0) && (payload_stop > total))\n return E_FILE_FORMAT_INVALID;\n\n if (payload_stop > avail) {\n    len = static_cast<long>(payload_size);\n return E_BUFFER_NOT_FULL;\n }\n\n long long discard_padding = 0;\n\n while (pos < payload_stop) {\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((pos + len) > payload_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long id = ReadUInt(pReader, pos, len);\n\n if (id < 0) \n return static_cast<long>(id);\n\n if (id == 0) \n return E_FILE_FORMAT_INVALID;\n\n    pos += len; \n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((pos + len) > payload_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n    pos += len; \n\n\n if (pos > payload_stop)\n return E_FILE_FORMAT_INVALID;\n\n if (size == 0) \n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID;\n\n if (id == 0x35A2) { \n      status = UnserializeInt(pReader, pos, size, discard_padding);\n\n if (status < 0) \n return status;\n }\n\n if (id != 0x21) { \n      pos += size; \n\n if (pos > payload_stop)\n return E_FILE_FORMAT_INVALID;\n\n continue;\n }\n\n const long long block_stop = pos + size;\n\n if (block_stop > payload_stop)\n return E_FILE_FORMAT_INVALID;\n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((pos + len) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long track = ReadUInt(pReader, pos, len);\n\n if (track < 0) \n return static_cast<long>(track);\n\n\n     if (track == 0)\n       return E_FILE_FORMAT_INVALID;\n \n#if 0\n        const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n        const long tn = static_cast<long>(track);\n        const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n        if (pTrack == NULL)\n            return E_FILE_FORMAT_INVALID;\n#endif\n     pos += len;  \n \n     if ((pos + 2) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + 2) > avail) {\n      len = 2;\n return E_BUFFER_NOT_FULL;\n }\n\n    pos += 2; \n\n if ((pos + 1) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n unsigned char flags;\n\n    status = pReader->Read(pos, 1, &flags);\n\n if (status < 0) { \n      len = 1;\n return status;\n }\n\n ++pos; \n    assert(pos <= avail);\n\n if (pos >= block_stop)\n return E_FILE_FORMAT_INVALID;\n\n const int lacing = int(flags & 0x06) >> 1;\n\n if ((lacing != 0) && (block_stop > avail)) {\n      len = static_cast<long>(block_stop - pos);\n return E_BUFFER_NOT_FULL;\n\n     }\n \n     pos = block_stop;  \n    assert(pos <= payload_stop);\n   }\n \n  assert(pos == payload_stop);\n \n   status = CreateBlock(0x20,  \n                        payload_start, payload_size, discard_padding);\n if (status != 0)\n return status;\n\n  m_pos = payload_stop;\n\n return 0; \n}\n", "target": 1, "flaw_line_index": "151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175"}
{"idx": 187449, "func": "static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,\n size_t bytes)\n{\n struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;\n int sent;\n\n    DEBUG(\"write %zu bytes (fd %d)\", bytes, out->common.audio_fd);\n\n    pthread_mutex_lock(&out->common.lock);\n\n if (out->common.state == AUDIO_A2DP_STATE_SUSPENDED)\n {\n        DEBUG(\"stream suspended\");\n        pthread_mutex_unlock(&out->common.lock);\n return -1;\n }\n\n if ((out->common.state == AUDIO_A2DP_STATE_STOPPED) ||\n (out->common.state == AUDIO_A2DP_STATE_STANDBY))\n {\n if (start_audio_datapath(&out->common) < 0)\n {\n\n int us_delay = calc_audiotime(out->common.cfg, bytes);\n\n \n             DEBUG(\"emulate a2dp write delay (%d us)\", us_delay);\n \n            usleep(us_delay);\n             pthread_mutex_unlock(&out->common.lock);\n             return -1;\n         }\n }\n else if (out->common.state != AUDIO_A2DP_STATE_STARTED)\n {\n        ERROR(\"stream not in stopped or standby\");\n        pthread_mutex_unlock(&out->common.lock);\n return -1;\n }\n\n    pthread_mutex_unlock(&out->common.lock);\n    sent = skt_write(out->common.audio_fd, buffer,  bytes);\n\n if (sent == -1) {\n        skt_disconnect(out->common.audio_fd);\n        out->common.audio_fd = AUDIO_SKT_DISCONNECTED;\n if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)\n            out->common.state = AUDIO_A2DP_STATE_STOPPED;\n else\n            ERROR(\"write failed : stream suspended, avoid resetting state\");\n } else {\n const size_t frames = bytes / audio_stream_out_frame_size(stream);\n        out->frames_rendered += frames;\n        out->frames_presented += frames;\n }\n\n    DEBUG(\"wrote %d bytes out of %zu bytes\", sent, bytes);\n return sent;\n}\n", "target": 1, "flaw_line_index": "29"}
{"idx": 187510, "func": " ssize_t socket_write_and_transfer_fd(const socket_t *socket, const void *buf, size_t count, int fd) {\n  assert(socket != NULL);\n  assert(buf != NULL);\n\n if (fd == INVALID_FD)\n return socket_write(socket, buf, count);\n\n struct msghdr msg;\n struct iovec iov;\n char control_buf[CMSG_SPACE(sizeof(int))];\n\n  iov.iov_base = (void *)buf;\n  iov.iov_len = count;\n\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = control_buf;\n  msg.msg_controllen = sizeof(control_buf);\n  msg.msg_name = NULL;\n  msg.msg_namelen = 0;\n\n struct cmsghdr *header = CMSG_FIRSTHDR(&msg);\n  header->cmsg_level = SOL_SOCKET;\n  header->cmsg_type = SCM_RIGHTS;\n\n   header->cmsg_len = CMSG_LEN(sizeof(int));\n   *(int *)CMSG_DATA(header) = fd;\n \n  ssize_t ret = sendmsg(socket->fd, &msg, MSG_DONTWAIT);\n   close(fd);\n   return ret;\n }\n", "target": 1, "flaw_line_index": "29"}
{"idx": 187703, "func": "static void perform_gamma_scale16_tests(png_modifier *pm)\n{\n\n #  ifndef PNG_MAX_GAMMA_8\n #     define PNG_MAX_GAMMA_8 11\n #  endif\n#  define SBIT_16_TO_8 PNG_MAX_GAMMA_8\n unsigned int i, j;\n for (i=0; i<pm->ngamma_tests; ++i)\n {\n for (j=0; j<pm->ngamma_tests; ++j)\n {\n if (i != j &&\n             fabs(pm->gammas[j]/pm->gammas[i]-1) >= PNG_GAMMA_THRESHOLD)\n {\n            gamma_transform_test(pm, 0, 16, 0, pm->interlace_type,\n 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 \n);\n\n if (fail(pm))\n return;\n\n            gamma_transform_test(pm, 2, 16, 0, pm->interlace_type,\n 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 \n);\n\n if (fail(pm))\n return;\n\n            gamma_transform_test(pm, 4, 16, 0, pm->interlace_type,\n 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 \n);\n\n if (fail(pm))\n return;\n\n            gamma_transform_test(pm, 6, 16, 0, pm->interlace_type,\n 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,\n               pm->use_input_precision_16to8, 1 \n);\n\n if (fail(pm))\n return;\n }\n }\n }\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 187748, "func": "void usage()\n{\n  fprintf (stderr, \"PNM2PNG\\n\");\n  fprintf (stderr, \"   by Willem van Schaik, 1999\\n\");\n#ifdef __TURBOC__\n  fprintf (stderr, \"   for Turbo-C and Borland-C compilers\\n\");\n#else\n  fprintf (stderr, \"   for Linux (and Unix) compilers\\n\");\n#endif\n  fprintf (stderr, \"Usage:  pnm2png [options] <file>.<pnm> [<file>.png]\\n\");\n\n   fprintf (stderr, \"   or:  ... | pnm2png [options]\\n\");\n   fprintf (stderr, \"Options:\\n\");\n   fprintf (stderr, \"   -i[nterlace]   write png-file with interlacing on\\n\");\n  fprintf (stderr, \"   -a[lpha] <file>.pgm read PNG alpha channel as pgm-file\\n\");\n   fprintf (stderr, \"   -h | -?  print this help-information\\n\");\n }\n", "target": 1, "flaw_line_index": "15"}
{"idx": 187465, "func": "static inline int btif_hl_select_wake_reset(void){\n\n     char sig_recv = 0;\n \n     BTIF_TRACE_DEBUG(\"btif_hl_select_wake_reset\");\n    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);\n     return(int)sig_recv;\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8925, "func": "void vrend_report_buffer_error(struct vrend_context *ctx, int cmd)\n{\n   report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_CMD_BUFFER, cmd);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187905, "func": "status_t Camera3Device::createDefaultRequest(int templateId,\n\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\"%s: for template %d\", __FUNCTION__, templateId);\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n \n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device is not initialized!\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n\n if (!mRequestTemplateCache[templateId].isEmpty()) {\n *request = mRequestTemplateCache[templateId];\n return OK;\n }\n\n const camera_metadata_t *rawRequest;\n    ATRACE_BEGIN(\"camera3->construct_default_request_settings\");\n    rawRequest = mHal3Device->ops->construct_default_request_settings(\n        mHal3Device, templateId);\n    ATRACE_END();\n if (rawRequest == NULL) {\n        ALOGI(\"%s: template %d is not supported on this camera device\",\n              __FUNCTION__, templateId);\n return BAD_VALUE;\n }\n *request = rawRequest;\n    mRequestTemplateCache[templateId] = rawRequest;\n\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188596, "func": "  unsigned int ReferenceSAD(unsigned int max_sad, int block_idx = 0) {\n     unsigned int sad = 0;\n    const uint8_t* const reference = GetReference(block_idx);\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        sad += abs(source_data_[h * source_stride_ + w]\n               - reference[h * reference_stride_ + w]);\n      }\n      if (sad > max_sad) {\n        break;\n       }\n     }\n     return sad;\n   }\n", "target": 1, "flaw_line_index": "3,6,7,8,9,10"}
{"idx": 187393, "func": "status_t SampleTable::setSampleToChunkParams(\n off64_t data_offset, size_t data_size) {\n if (mSampleToChunkOffset >= 0) {\n return ERROR_MALFORMED;\n }\n\n    mSampleToChunkOffset = data_offset;\n\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n\n if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n\n         return ERROR_MALFORMED;\n     }\n \n     mSampleToChunkEntries =\n         new SampleToChunkEntry[mNumSampleToChunkOffsets];\n \n for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n uint8_t buffer[12];\n if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n != (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n\n        CHECK(U32_AT(buffer) >= 1); \n\n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188103, "func": "static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {\n unsigned int cpy_len, rem_len;\n uint32_t list_len;\n uint8_t* p;\n uint8_t type;\n\n#if (SDP_DEBUG_RAW == TRUE)\n uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];\n uint32_t i;\n\n for (i = 0; i < p_ccb->list_len; i++) {\n    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, \"%02X\",\n (uint8_t)(p_ccb->rsp_list[i]));\n }\n  SDP_TRACE_WARNING(\"result :%s\", num_array);\n#endif\n\n if (p_ccb->p_db->raw_data) {\n    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;\n    list_len = p_ccb->list_len;\n\n     p = &p_ccb->rsp_list[0];\n \n     if (offset) {\n       type = *p++;\n       p = sdpu_get_len_from_type(p, type, &list_len);\n     }\n     if (list_len < cpy_len) {\n       cpy_len = list_len;\n }\n    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);\n if (cpy_len > rem_len) {\n      SDP_TRACE_WARNING(\"rem_len :%d less than cpy_len:%d\", rem_len, cpy_len);\n      cpy_len = rem_len;\n }\n    SDP_TRACE_WARNING(\n \"%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d \"\n \"raw_used:%d raw_data:%p\",\n        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,\n        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);\n    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);\n    p_ccb->p_db->raw_used += cpy_len;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9092, "func": "static int vrend_decode_clear(struct vrend_decode_ctx *ctx, int length)\n{\n   union pipe_color_union color;\n   double depth;\n   unsigned stencil, buffers;\n   int i;\n\n   if (length != VIRGL_OBJ_CLEAR_SIZE)\n      return EINVAL;\n   buffers = get_buf_entry(ctx, VIRGL_OBJ_CLEAR_BUFFERS);\n   for (i = 0; i < 4; i++)\n      color.ui[i] = get_buf_entry(ctx, VIRGL_OBJ_CLEAR_COLOR_0 + i);\n   depth = *(double *)(uint64_t *)get_buf_ptr(ctx, VIRGL_OBJ_CLEAR_DEPTH_0);\n   stencil = get_buf_entry(ctx, VIRGL_OBJ_CLEAR_STENCIL);\n\n   vrend_clear(ctx->grctx, buffers, &color, depth, stencil);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9219, "func": "uint16_t virtio_queue_get_last_avail_idx(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].last_avail_idx;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8461, "func": "pvscsi_write_sense(PVSCSIRequest *r, uint8_t *sense, int len)\n{\n    r->cmp.senseLen = MIN(r->req.senseLen, len);\n    r->sense_key = sense[(sense[0] & 2) ? 1 : 2];\n    cpu_physical_memory_write(r->req.senseAddr, sense, r->cmp.senseLen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8640, "func": "size_t mptsas_config_io_unit_3(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x01,\n                              \"*b*b*w*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187827, "func": "long Cluster::CreateBlock(long long id,\n long long pos, \n long long size, long long discard_padding) {\n  assert((id == 0x20) || (id == 0x23)); \n\n if (m_entries_count < 0) { \n    assert(m_entries == NULL);\n\n     assert(m_entries_size == 0);\n \n     m_entries_size = 1024;\n    m_entries = new BlockEntry* [m_entries_size];\n \n     m_entries_count = 0;\n   } else {\n    assert(m_entries);\n    assert(m_entries_size > 0);\n    assert(m_entries_count <= m_entries_size);\n\n\n     if (m_entries_count >= m_entries_size) {\n       const long entries_size = 2 * m_entries_size;\n \n      BlockEntry** const entries = new BlockEntry* [entries_size];\n      assert(entries);\n \n       BlockEntry** src = m_entries;\n       BlockEntry** const src_end = src + m_entries_count;\n\n BlockEntry** dst = entries;\n\n while (src != src_end)\n *dst++ = *src++;\n\n delete[] m_entries;\n\n      m_entries = entries;\n      m_entries_size = entries_size;\n }\n }\n\n if (id == 0x20) \n return CreateBlockGroup(pos, size, discard_padding);\n else \n return CreateSimpleBlock(pos, size);\n}\n", "target": 1, "flaw_line_index": "12,24,25"}
{"idx": 8634, "func": "static void xilinx_ethlite_register_types(void)\n{\n    type_register_static(&xilinx_ethlite_info);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188540, "func": " virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n\n     tot_frame_number_ = 0;\n     first_drop_ = 0;\n     num_drops_ = 0;\n     for (int i = 0; i < 3; ++i) {\n       bits_total_[i] = 0;\n     }\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187722, "func": "standard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,\n int bit_depth, unsigned int npalette, int interlace_type,\n\n     png_uint_32 w, png_uint_32 h, int do_interlace)\n {\n    pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);\n   if (npalette > 0)\n    {\n       pos = safecat(buffer, bufsize, pos, \"[\");\n       pos = safecatn(buffer, bufsize, pos, npalette);\n       pos = safecat(buffer, bufsize, pos, \"]\");\n    }\n    pos = safecat(buffer, bufsize, pos, \" \");\n    pos = safecatn(buffer, bufsize, pos, bit_depth);\n    pos = safecat(buffer, bufsize, pos, \" bit\");\n\n if (interlace_type != PNG_INTERLACE_NONE)\n {\n      pos = safecat(buffer, bufsize, pos, \" interlaced\");\n if (do_interlace)\n         pos = safecat(buffer, bufsize, pos, \"(pngvalid)\");\n else\n         pos = safecat(buffer, bufsize, pos, \"(libpng)\");\n }\n\n if (w > 0 || h > 0)\n {\n      pos = safecat(buffer, bufsize, pos, \" \");\n      pos = safecatn(buffer, bufsize, pos, w);\n      pos = safecat(buffer, bufsize, pos, \"x\");\n      pos = safecatn(buffer, bufsize, pos, h);\n }\n\n return pos;\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 8511, "func": "static struct Packet *construct_packet(Ssh ssh, int pkttype, va_list ap)\n{\n    int argtype;\n    Bignum bn;\n    struct Packet *pkt;\n\n    pkt = ssh1_pkt_init(pkttype);\n\n    while ((argtype = va_arg(ap, int)) != PKT_END) {\n\tunsigned char *argp, argchar;\n\tchar *sargp;\n\tunsigned long argint;\n\tint arglen;\n\tswitch (argtype) {\n\t  case PKT_INT:\n\t    argint = va_arg(ap, int);\n\t    ssh_pkt_adduint32(pkt, argint);\n\t    break;\n\t  case PKT_CHAR:\n\t    argchar = (unsigned char) va_arg(ap, int);\n\t    ssh_pkt_addbyte(pkt, argchar);\n\t    break;\n\t  case PKT_DATA:\n\t    argp = va_arg(ap, unsigned char *);\n\t    arglen = va_arg(ap, int);\n\t    ssh_pkt_adddata(pkt, argp, arglen);\n\t    break;\n\t  case PKT_STR:\n\t    sargp = va_arg(ap, char *);\n\t    ssh_pkt_addstring(pkt, sargp);\n\t    break;\n\t  case PKT_BIGNUM:\n\t    bn = va_arg(ap, Bignum);\n\t    ssh1_pkt_addmp(pkt, bn);\n\t    break;\n\t}\n    }\n\n    return pkt;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8845, "func": "static void vrend_destroy_shader_object(void *obj_ptr)\n{\n   struct vrend_shader_selector *state = obj_ptr;\n\n   vrend_shader_state_reference(&state, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187701, "func": "perform_gamma_composition_tests(png_modifier *pm, int do_background,\n int expand_16)\n{\n   png_byte colour_type = 0;\n   png_byte bit_depth = 0;\n unsigned int palette_number = 0;\n\n \n   while (next_format(&colour_type, &bit_depth, &palette_number, 1\n))\n      if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0)\n    {\n       unsigned int i, j;\n \n for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)\n {\n         gamma_composition_test(pm, colour_type, bit_depth, palette_number,\n            pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],\n            pm->use_input_precision, do_background, expand_16);\n\n if (fail(pm))\n return;\n }\n }\n}\n", "target": 1, "flaw_line_index": "10,11"}
{"idx": 8696, "func": "scheme_leading_string (enum url_scheme scheme)\n{\n  return supported_schemes[scheme].leading_string;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187628, "func": " chrm_modification_init(chrm_modification *me, png_modifier *pm,\n   PNG_CONST color_encoding *encoding)\n {\n    CIE_color white = white_point(encoding);\n \n   me->encoding = encoding;\n\n   me->wx = fix(chromaticity_x(white));\n   me->wy = fix(chromaticity_y(white));\n\n   me->rx = fix(chromaticity_x(encoding->red));\n   me->ry = fix(chromaticity_y(encoding->red));\n   me->gx = fix(chromaticity_x(encoding->green));\n   me->gy = fix(chromaticity_y(encoding->green));\n   me->bx = fix(chromaticity_x(encoding->blue));\n   me->by = fix(chromaticity_y(encoding->blue));\n\n   modification_init(&me->this);\n   me->this.chunk = CHUNK_cHRM;\n   me->this.modify_fn = chrm_modify;\n   me->this.add = CHUNK_PLTE;\n   me->this.next = pm->modifications;\n   pm->modifications = &me->this;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 9218, "func": "EventNotifier *virtio_queue_get_host_notifier(VirtQueue *vq)\n{\n    return &vq->host_notifier;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9086, "func": "static int vrend_decode_begin_query(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t handle = get_buf_entry(ctx, VIRGL_QUERY_BEGIN_HANDLE);\n\n   vrend_begin_query(ctx->grctx, handle);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9097, "func": "static int vrend_decode_create_rasterizer(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_rasterizer_state *rs_state;\n   uint32_t tmp;\n\n   if (length != VIRGL_OBJ_RS_SIZE)\n      return EINVAL;\n\n   rs_state = CALLOC_STRUCT(pipe_rasterizer_state);\n   if (!rs_state)\n      return ENOMEM;\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_RS_S0);\n#define ebit(name, bit) rs_state->name = (tmp >> bit) & 0x1\n#define emask(name, bit, mask) rs_state->name = (tmp >> bit) & mask\n\n   ebit(flatshade, 0);\n   ebit(depth_clip, 1);\n   ebit(clip_halfz, 2);\n   ebit(rasterizer_discard, 3);\n   ebit(flatshade_first, 4);\n   ebit(light_twoside, 5);\n   ebit(sprite_coord_mode, 6);\n   ebit(point_quad_rasterization, 7);\n   emask(cull_face, 8, 0x3);\n   emask(fill_front, 10, 0x3);\n   emask(fill_back, 12, 0x3);\n   ebit(scissor, 14);\n   ebit(front_ccw, 15);\n   ebit(clamp_vertex_color, 16);\n   ebit(clamp_fragment_color, 17);\n   ebit(offset_line, 18);\n   ebit(offset_point, 19);\n   ebit(offset_tri, 20);\n   ebit(poly_smooth, 21);\n   ebit(poly_stipple_enable, 22);\n   ebit(point_smooth, 23);\n   ebit(point_size_per_vertex, 24);\n   ebit(multisample, 25);\n   ebit(line_smooth, 26);\n   ebit(line_stipple_enable, 27);\n   ebit(line_last_pixel, 28);\n   ebit(half_pixel_center, 29);\n   ebit(bottom_edge_rule, 30);\n   rs_state->point_size = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_POINT_SIZE));\n   rs_state->sprite_coord_enable = get_buf_entry(ctx, VIRGL_OBJ_RS_SPRITE_COORD_ENABLE);\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_RS_S3);\n   emask(line_stipple_pattern, 0, 0xffff);\n   emask(line_stipple_factor, 16, 0xff);\n   emask(clip_plane_enable, 24, 0xff);\n\n   rs_state->line_width = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_LINE_WIDTH));\n   rs_state->offset_units = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_UNITS));\n   rs_state->offset_scale = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_SCALE));\n   rs_state->offset_clamp = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_CLAMP));\n\n   tmp = vrend_renderer_object_insert(ctx->grctx, rs_state, sizeof(struct pipe_rasterizer_state), handle,\n                                      VIRGL_OBJECT_RASTERIZER);\n   if (tmp == 0) {\n      FREE(rs_state);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187921, "func": "void SoftVPX::onQueueFilled(OMX_U32 \n) {\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n bool EOSseen = false;\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n EOSseen = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n                outQueue.erase(outQueue.begin());\n                outInfo->mOwnedByUs = false;\n                notifyFillBufferDone(outHeader);\n return;\n }\n }\n\n if (mImg == NULL) {\n if (vpx_codec_decode(\n (vpx_codec_ctx_t *)mCtx,\n                        inHeader->pBuffer + inHeader->nOffset,\n                        inHeader->nFilledLen,\n                        NULL,\n 0)) {\n                ALOGE(\"on2 decoder failed to decode frame.\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n vpx_codec_iter_t iter = NULL;\n            mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);\n\n         }\n \n         if (mImg != NULL) {\n            CHECK_EQ(mImg->fmt, IMG_FMT_I420);\n \n             uint32_t width = mImg->d_w;\n             uint32_t height = mImg->d_h;\n bool portWillReset = false;\n            handlePortSettingsChange(&portWillReset, width, height);\n if (portWillReset) {\n return;\n }\n\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n            outHeader->nFlags = EOSseen ? OMX_BUFFERFLAG_EOS : 0;\n\n             outHeader->nTimeStamp = inHeader->nTimeStamp;\n \n             uint8_t *dst = outHeader->pBuffer;\n            const uint8_t *srcY = (const uint8_t *)mImg->planes[PLANE_Y];\n            const uint8_t *srcU = (const uint8_t *)mImg->planes[PLANE_U];\n            const uint8_t *srcV = (const uint8_t *)mImg->planes[PLANE_V];\n            size_t srcYStride = mImg->stride[PLANE_Y];\n            size_t srcUStride = mImg->stride[PLANE_U];\n            size_t srcVStride = mImg->stride[PLANE_V];\n             copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);\n \n             mImg = NULL;\n            outInfo->mOwnedByUs = false;\n            outQueue.erase(outQueue.begin());\n            outInfo = NULL;\n            notifyFillBufferDone(outHeader);\n            outHeader = NULL;\n }\n\n        inInfo->mOwnedByUs = false;\n        inQueue.erase(inQueue.begin());\n        inInfo = NULL;\n        notifyEmptyBufferDone(inHeader);\n        inHeader = NULL;\n }\n}\n", "target": 1, "flaw_line_index": "53,70,71,72,73,74,75"}
{"idx": 187736, "func": "transform_image_validate(transform_display *dp, png_const_structp pp,\n\n    png_infop pi)\n {\n   PNG_CONST png_store* PNG_CONST ps = dp->this.ps;\n   PNG_CONST png_byte in_ct = dp->this.colour_type;\n   PNG_CONST png_byte in_bd = dp->this.bit_depth;\n   PNG_CONST png_uint_32 w = dp->this.w;\n   PNG_CONST png_uint_32 h = dp->this.h;\n   PNG_CONST png_byte out_ct = dp->output_colour_type;\n   PNG_CONST png_byte out_bd = dp->output_bit_depth;\n   PNG_CONST png_byte sample_depth = (png_byte)(out_ct ==\n       PNG_COLOR_TYPE_PALETTE ? 8 : out_bd);\n   PNG_CONST png_byte red_sBIT = dp->this.red_sBIT;\n   PNG_CONST png_byte green_sBIT = dp->this.green_sBIT;\n   PNG_CONST png_byte blue_sBIT = dp->this.blue_sBIT;\n   PNG_CONST png_byte alpha_sBIT = dp->this.alpha_sBIT;\n   PNG_CONST int have_tRNS = dp->this.is_transparent;\n    double digitization_error;\n \n    store_palette out_palette;\n   png_uint_32 y;\n\n   UNUSED(pi)\n\n   store_image_check(dp->this.ps, pp, 0);\n\n if (out_ct == PNG_COLOR_TYPE_PALETTE)\n {\n int npalette = (-1);\n\n (void)read_palette(out_palette, &npalette, pp, pi);\n if (npalette != dp->this.npalette)\n         png_error(pp, \"unexpected change in palette size\");\n\n      digitization_error = .5;\n }\n else\n {\n      png_byte in_sample_depth;\n\n      memset(out_palette, 0x5e, sizeof out_palette);\n\n if (in_ct == PNG_COLOR_TYPE_PALETTE || in_bd < 16)\n         in_sample_depth = 8;\n else\n         in_sample_depth = in_bd;\n\n if (sample_depth != 16 || in_sample_depth > 8 ||\n !dp->pm->calculations_use_input_precision)\n         digitization_error = .5;\n\n else\n         digitization_error = .5 * 257;\n }\n\n \n    for (y=0; y<h; ++y)\n    {\n      png_const_bytep PNG_CONST pRow = store_image_row(ps, pp, 0, y);\n       png_uint_32 x;\n \n      png_byte std[STANDARD_ROWMAX];\n\n      transform_row(pp, std, in_ct, in_bd, y);\n\n for (x=0; x<w; ++x)\n {\n         image_pixel in_pixel, out_pixel;\n\n          unsigned int r, g, b, a;\n \n         image_pixel_init(&in_pixel, std, in_ct, in_bd, x, dp->this.palette);\n \n          in_pixel.red_sBIT = red_sBIT;\n          in_pixel.green_sBIT = green_sBIT;\n          in_pixel.blue_sBIT = blue_sBIT;\n          in_pixel.alpha_sBIT = alpha_sBIT;\n         in_pixel.have_tRNS = have_tRNS;\n \n          r = in_pixel.red;\n         g = in_pixel.green;\n\n          b = in_pixel.blue;\n          a = in_pixel.alpha;\n \n          dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp);\n \n         image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette);\n \n if (in_ct == PNG_COLOR_TYPE_PALETTE &&\n            out_ct == PNG_COLOR_TYPE_PALETTE)\n {\n if (in_pixel.palette_index != out_pixel.palette_index)\n               png_error(pp, \"unexpected transformed palette index\");\n }\n\n if (in_pixel.red != out_pixel.red)\n            transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf,\n               out_pixel.red, sample_depth, in_pixel.rede,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.red_sBIT)-1)), \"red/gray\",\n               digitization_error);\n\n if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&\n            in_pixel.green != out_pixel.green)\n            transform_range_check(pp, r, g, b, a, in_pixel.green,\n               in_pixel.greenf, out_pixel.green, sample_depth, in_pixel.greene,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.green_sBIT)-1)), \"green\",\n               digitization_error);\n\n if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&\n            in_pixel.blue != out_pixel.blue)\n            transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef,\n               out_pixel.blue, sample_depth, in_pixel.bluee,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), \"blue\",\n               digitization_error);\n\n if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&\n            in_pixel.alpha != out_pixel.alpha)\n            transform_range_check(pp, r, g, b, a, in_pixel.alpha,\n               in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae,\n               dp->pm->limit + 1./(2*((1U<<in_pixel.alpha_sBIT)-1)), \"alpha\",\n               digitization_error);\n } \n } \n\n   dp->this.ps->validated = 1;\n}\n", "target": 1, "flaw_line_index": "5,6,7,8,9,10,11,12,14,15,16,17,18,60,73,79,89"}
{"idx": 8824, "func": "void vrend_bind_vertex_elements_state(struct vrend_context *ctx,\n                                      uint32_t handle)\n{\n   struct vrend_vertex_element_array *v;\n\n   if (!handle) {\n      ctx->sub->ve = NULL;\n      return;\n   }\n   v = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_VERTEX_ELEMENTS);\n   if (!v) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_HANDLE, handle);\n      return;\n   }\n\n   if (ctx->sub->ve != v)\n      ctx->sub->vbo_dirty = true;\n   ctx->sub->ve = v;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188627, "func": "void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pAudioBuffer;\n    EAS_I32 k;\n    EAS_I32 b1;\n    EAS_I32 b2;\n    EAS_I32 z1;\n    EAS_I32 z2;\n    EAS_I32 acc0;\n    EAS_I32 acc1;\n    EAS_I32 numSamples;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pAudioBuffer = pWTIntFrame->pAudioBuffer;\n\n    z1 = pFilter->z1;\n    z2 = pFilter->z2;\n    b1 = -pWTIntFrame->frame.b1;\n\n    b2 = -pWTIntFrame->frame.b2 >> 1;\n\n    k = pWTIntFrame->frame.k >> 1;\n\n while (numSamples--)\n {\n\n        acc0 = *pAudioBuffer;\n        acc1 = z1 * b1;\n        acc1 += z2 * b2;\n        acc0 = acc1 + k * acc0;\n        z2 = z1;\n\n        z1 = acc0 >> 14;\n *pAudioBuffer++ = (EAS_I16) z1;\n }\n\n    pFilter->z1 = (EAS_I16) z1;\n    pFilter->z2 = (EAS_I16) z2;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187600, "func": "find_insert(png_const_charp what, png_charp param)\n{\n   png_uint_32 chunk = 0;\n   png_charp parameter_list[1024];\n int i, nparams;\n\n for (i=0; i<4; ++i)\n {\n char ch = what[i];\n\n if ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))\n         chunk = (chunk << 8) + what[i];\n\n else\n break;\n }\n\n if (i < 4 || what[4] != 0)\n {\n      fprintf(stderr, \"makepng --insert \\\"%s\\\": invalid chunk name\\n\", what);\n      exit(1);\n }\n\n   nparams = find_parameters(what, param, parameter_list, 1024);\n\n#  define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))\n\n switch (chunk)\n {\n case CHUNK(105,67,67,80): \n if (nparams == 2)\n return make_insert(what, insert_iCCP, nparams, parameter_list);\n break;\n\n case CHUNK(116,69,88,116): \n if (nparams == 2)\n return make_insert(what, insert_tEXt, nparams, parameter_list);\n break;\n\n case CHUNK(122,84,88,116): \n if (nparams == 2)\n return make_insert(what, insert_zTXt, nparams, parameter_list);\n break;\n\n case CHUNK(105,84,88,116): \n if (nparams == 4)\n return make_insert(what, insert_iTXt, nparams, parameter_list);\n break;\n\n case CHUNK(104,73,83,84): \n if (nparams <= 256)\n\n             return make_insert(what, insert_hIST, nparams, parameter_list);\n          break;\n \n #if 0\n       case CHUNK(115,80,76,84):  \n          return make_insert(what, insert_sPLT, nparams, parameter_list);\n#endif\n\n default:\n         fprintf(stderr, \"makepng --insert \\\"%s\\\": unrecognized chunk name\\n\",\n            what);\n         exit(1);\n }\n\n   bad_parameter_count(what, nparams);\n\n    return NULL;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8615, "func": "static void vmsvga_invalidate_display(void *opaque)\n{\n    struct vmsvga_state_s *s = opaque;\n    if (!s->enable) {\n        s->vga.hw_ops->invalidate(&s->vga);\n        return;\n    }\n\n    s->invalidated = 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187875, "func": "long mkvparser::ParseElementHeader(IMkvReader* pReader, long long& pos,\n                                   long long stop, long long& id,\n                                   long long& size) {\n  if ((stop >= 0) && (pos >= stop))\n     return E_FILE_FORMAT_INVALID;\n \n   long len;\n \n  id = ReadUInt(pReader, pos, len);\n \n   if (id < 0)\n     return E_FILE_FORMAT_INVALID;\n \n   pos += len;  \n \n  if ((stop >= 0) && (pos >= stop))\n     return E_FILE_FORMAT_INVALID;\n \n   size = ReadUInt(pReader, pos, len);\n \n  if (size < 0)\n     return E_FILE_FORMAT_INVALID;\n \n   pos += len;  \n \n \n  if ((stop >= 0) && ((pos + size) > stop))\n     return E_FILE_FORMAT_INVALID;\n \n   return 0;  \n }\n", "target": 1, "flaw_line_index": "2,3,4,9,16,21,28"}
{"idx": 8317, "func": "XFixesSubtractRegion (Display *dpy, XserverRegion dst,\n\t\t      XserverRegion src1, XserverRegion src2)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesSubtractRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesSubtractRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesSubtractRegion;\n    req->source1 = src1;\n    req->source2 = src2;\n    req->destination = dst;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187707, "func": " pixel_copy(png_bytep toBuffer, png_uint_32 toIndex,\n   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize)\n {\n   toIndex *= pixelSize;\n   fromIndex *= pixelSize;\n\n    if (pixelSize < 8) \n    {\n      unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));\n       unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;\n       unsigned int sourceByte = fromBuffer[fromIndex >> 3];\n \n       fromIndex &= 7;\n      if (fromIndex > 0) sourceByte <<= fromIndex;\n      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;\n \n       toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));\n    }\n else \n      memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);\n}\n", "target": 1, "flaw_line_index": "2,9,14,15"}
{"idx": 188578, "func": " virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fht4x4_ref;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8499, "func": "BOOL CSoundFile::SetWaveConfig(UINT nRate,UINT nBits,UINT nChannels,BOOL bMMX)\n{\n\tBOOL bReset = FALSE;\n\tDWORD d = gdwSoundSetup & ~SNDMIX_ENABLEMMX;\n\tif (bMMX) d |= SNDMIX_ENABLEMMX;\n\tif ((gdwMixingFreq != nRate) || (gnBitsPerSample != nBits) || (gnChannels != nChannels) || (d != gdwSoundSetup)) bReset = TRUE;\n\tgnChannels = nChannels;\n\tgdwSoundSetup = d;\n\tgdwMixingFreq = nRate;\n\tgnBitsPerSample = nBits;\n\tInitPlayer(bReset);\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187824, "func": "int Track::Info::Copy(Info& dst) const {\n if (&dst == this)\n return 0;\n\n  dst.type = type;\n  dst.number = number;\n  dst.defaultDuration = defaultDuration;\n  dst.codecDelay = codecDelay;\n  dst.seekPreRoll = seekPreRoll;\n  dst.uid = uid;\n  dst.lacing = lacing;\n  dst.settings = settings;\n\n\n if (int status = CopyStr(&Info::nameAsUTF8, dst))\n return status;\n\n if (int status = CopyStr(&Info::language, dst))\n return status;\n\n if (int status = CopyStr(&Info::codecId, dst))\n return status;\n\n if (int status = CopyStr(&Info::codecNameAsUTF8, dst))\n return status;\n\n if (codecPrivateSize > 0) {\n if (codecPrivate == NULL)\n return -1;\n\n if (dst.codecPrivate)\n return -1;\n\n\n     if (dst.codecPrivateSize != 0)\n       return -1;\n \n    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];\n \n     if (dst.codecPrivate == NULL)\n       return -1;\n\n    memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);\n    dst.codecPrivateSize = codecPrivateSize;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "43"}
{"idx": 8704, "func": "unescape_single_char (char *str, char chr)\n{\n  const char c1 = XNUM_TO_DIGIT (chr >> 4);\n  const char c2 = XNUM_TO_DIGIT (chr & 0xf);\n  char *h = str;                \n  char *t = str;                \n  for (; *h; h++, t++)\n    {\n      if (h[0] == '%' && h[1] == c1 && h[2] == c2)\n        {\n          *t = chr;\n          h += 2;\n        }\n      else\n        *t = *h;\n    }\n  *t = '\\0';\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187978, "func": "WORD32 ih264d_parse_inter_slice_data_cabac(dec_struct_t * ps_dec,\n dec_slice_params_t * ps_slice,\n                                           UWORD16 u2_first_mb_in_slice)\n{\n    UWORD32 uc_more_data_flag;\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;\n    UWORD32 u1_mbaff;\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end = 0;\n    UWORD32 u1_tfr_n_mb = 0;\n    UWORD32 u1_decode_nmb = 0;\n\n\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n\n parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    UWORD32 u1_inter_mb_skip_type;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD32 u1_mb_threshold;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    WORD32 ret = OK;\n\n if(ps_slice->u1_slice_type == P_SLICE)\n {\n        u1_inter_mb_skip_type = CAB_P_SKIP;\n        u1_inter_mb_type = P_MB;\n        u1_deblk_mb_type = D_INTER_MB;\n        u1_mb_threshold = 5;\n }\n else \n {\n        u1_inter_mb_skip_type = CAB_B_SKIP;\n        u1_inter_mb_type = B_MB;\n        u1_deblk_mb_type = D_B_SLICE;\n        u1_mb_threshold = 23;\n }\n\n    i2_cur_mb_addr = u2_first_mb_in_slice;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    u1_num_mbs = u1_mb_idx;\n    u1_num_mbsNby2 = 0;\n    u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;\n    uc_more_data_flag = 1;\n\n if(ps_bitstrm->u4_ofst & 0x07)\n {\n        ps_bitstrm->u4_ofst += 8;\n        ps_bitstrm->u4_ofst &= 0xFFFFFFF8;\n }\n\n    ret = ih264d_init_cabac_dec_envirnoment(&(ps_dec->s_cab_dec_env), ps_bitstrm);\n if(ret != OK)\n return ret;\n\n    ps_dec->i1_prev_mb_qp_delta = 0;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n        UWORD32 u4_mb_skip;\n\n        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n {\n            ret = ERROR_MB_ADDRESS_T;\n break;\n }\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n        u4_mb_skip = ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 1);\n\n        ps_cur_mb_info->u1_tran_form8x8 = 0;\n        ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n\n if(u4_mb_skip)\n {\n\n            memset(ps_dec->ps_curr_ctxt_mb_info, 0, sizeof(ctxt_inc_mb_info_t));\n            ps_dec->ps_curr_ctxt_mb_info->u1_mb_type = u1_inter_mb_skip_type;\n\n            MEMSET_16BYTES(&ps_dec->pu1_left_mv_ctxt_inc[0][0], 0);\n\n *((UWORD32 *)ps_dec->pi1_left_ref_idx_ctxt_inc) = 0;\n *(ps_dec->pu1_left_yuv_dc_csbp) = 0;\n\n            ps_dec->i1_prev_mb_qp_delta = 0;\n            ps_cur_mb_info->u1_mb_type = MB_SKIP;\n            ps_cur_mb_info->u1_cbp = 0;\n\n {\n parse_part_params_t *ps_part_info = ps_dec->ps_part;\n                ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n                ps_part_info->u1_sub_mb_num = 0;\n                ps_dec->ps_part++;\n }\n\n            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CABAC);\n\n            ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n            ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n            ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n }\n else\n {\n\n            u1_mb_type = ih264d_parse_mb_type_cabac(ps_dec);\n            ps_cur_mb_info->u1_mb_type = u1_mb_type;\n if(u1_mb_type > (25 + u1_mb_threshold))\n return ERROR_MB_TYPE;\n\n if(u1_mb_type < u1_mb_threshold)\n {\n                ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n *(ps_dec->pu1_left_yuv_dc_csbp) &= 0x6;\n\n                ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,\n                                          u1_num_mbsNby2);\n if(ret != OK)\n return ret;\n                ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n                ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n }\n else\n {\n                ps_parse_mb_data->u1_num_part = 0;\n                ps_parse_mb_data->u1_isI_mb = 1;\n\n if((25 + u1_mb_threshold) == u1_mb_type)\n {\n                    ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;\n                    ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);\n if(ret != OK)\n return ret;\n                    ps_cur_deblk_mb->u1_mb_qp = 0;\n }\n else\n {\n if(u1_mb_type == u1_mb_threshold)\n                        ps_cur_mb_info->ps_curmb->u1_mb_type = I_4x4_MB;\n else\n                        ps_cur_mb_info->ps_curmb->u1_mb_type = I_16x16_MB;\n\n                    ret = ih264d_parse_imb_cabac(\n                                    ps_dec, ps_cur_mb_info,\n (UWORD8)(u1_mb_type - u1_mb_threshold));\n if(ret != OK)\n return ret;\n                    ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n }\n                ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;\n\n }\n\n }\n\n if(u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n        i2_cur_mb_addr++;\n\n if(ps_cur_mb_info->u1_topmb && u1_mbaff)\n            uc_more_data_flag = 1;\n else\n {\n            uc_more_data_flag = ih264d_decode_terminate(&ps_dec->s_cab_dec_env,\n                                                      ps_bitstrm);\n            uc_more_data_flag = !uc_more_data_flag;\n            COPYTHECONTEXT(\"Decode Sliceterm\",!uc_more_data_flag);\n\n         }\n \n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n         u1_num_mbsNby2++;\n         ps_parse_mb_data++;\n \n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !uc_more_data_flag;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n {\n                ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n                ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n }\n\n if(u1_decode_nmb)\n {\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n\n                                             u1_num_mbs_next, u1_tfr_n_mb,\n                                             u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n\n }\n }\n\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n\n - (u2_first_mb_in_slice << u1_mbaff);\n\n return ret;\n}\n", "target": 1, "flaw_line_index": "199"}
{"idx": 187765, "func": "zlib_run(struct zlib *zlib)\n{\n   zlib->extra_bytes = 0;\n\n if (zlib->idat != NULL)\n {\n struct IDAT_list *list = zlib->idat->idat_list_head;\n struct IDAT_list *last = zlib->idat->idat_list_tail;\n int        skip = 0;\n\n      assert(zlib->rewrite_offset == 0);\n\n for (;;)\n {\n const unsigned int count = list->count;\n unsigned int i;\n\n for (i = 0; i<count; ++i)\n {\n int rc;\n\n if (skip > 0) \n               skip_12(zlib->file);\n\n            skip = 12; \n\n            rc = zlib_advance(zlib, list->lengths[i]);\n\n switch (rc)\n {\n case ZLIB_OK: \n break;\n\n case ZLIB_STREAM_END: \n if (zlib->global->errors && zlib->extra_bytes == 0)\n {\n struct IDAT_list *check = list;\n int j = i+1, jcount = count;\n\n for (;;)\n {\n for (; j<jcount; ++j)\n if (check->lengths[j] > 0)\n {\n                              chunk_message(zlib->chunk,\n \"extra compressed data\");\n goto end_check;\n }\n\n if (check == last)\n break;\n\n                        check = check->next;\n                        jcount = check->count;\n                        j = 0;\n }\n }\n\n               end_check:\n list->lengths[i] -= zlib->extra_bytes;\n list->count = i+1;\n                  zlib->idat->idat_list_tail = list;\n\n default:\n return rc;\n }\n }\n\n if (list == last)\n return ZLIB_OK;\n\n list = list->next;\n }\n }\n\n else\n\n    {\n       struct chunk *chunk = zlib->chunk;\n       int rc;\n       assert(zlib->rewrite_offset < chunk->chunk_length);\n \n       rc = zlib_advance(zlib, chunk->chunk_length - zlib->rewrite_offset);\n\n      chunk->chunk_length -= zlib->extra_bytes;\n return rc;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187937, "func": "void ih264d_rest_of_residual_cav_chroma_dc_block(UWORD32 u4_total_coeff_trail_one,\n dec_bit_stream_t *ps_bitstrm)\n{\n    UWORD32 u4_total_zeroes;\n    WORD16 i;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n\n     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;\n     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;\n     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;\n    WORD16 i2_level_arr[4];\n \n     tu_sblk4x4_coeff_data_t *ps_tu_4x4;\n     WORD16 *pi2_coeff_data;\n dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;\n\n    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;\n    ps_tu_4x4->u2_sig_coeff_map = 0;\n    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];\n\n    i = u4_total_coeff - 1;\n if(u4_trailing_ones)\n {\n        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;\n        WORD16 (*ppi2_trlone_lkup)[3] =\n (WORD16 (*)[3])gai2_ih264d_trailing_one_level;\n        WORD16 *pi2_trlone_lkup;\n\n        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);\n\n        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];\n\n while(u4_cnt--)\n            i2_level_arr[i--] = *pi2_trlone_lkup++;\n }\n\n if(i >= 0)\n {\n        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;\n        UWORD16 u2_lev_code, u2_abs_value;\n        UWORD32 u4_lev_prefix;\n\n        FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                              pu4_bitstrm_buf);\n\n        u2_lev_code = MIN(15, u4_lev_prefix);\n\n        u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);\n\n if(14 == u4_lev_prefix)\n            u4_lev_suffix_size = 4;\n else if(15 <= u4_lev_prefix)\n {\n            u2_lev_code += 15;\n            u4_lev_suffix_size = u4_lev_prefix - 3;\n }\n else\n            u4_lev_suffix_size = 0;\n\n if(16 <= u4_lev_prefix)\n {\n            u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n if(u4_lev_suffix_size)\n {\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code += u4_lev_suffix;\n }\n\n        u2_abs_value = (u2_lev_code + 2) >> 1;\n        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;\n\n while(i >= 0)\n {\n\n            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                                  pu4_bitstrm_buf);\n\n            u4_lev_suffix_size =\n (15 <= u4_lev_prefix) ?\n (u4_lev_prefix - 3) : u4_suffix_len;\n\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code = (MIN(u4_lev_prefix,15) << u4_suffix_len)\n + u4_lev_suffix;\n\n if(16 <= u4_lev_prefix)\n {\n                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n            u2_abs_value = (u2_lev_code + 2) >> 1;\n\n            i2_level_arr[i--] =\n (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n            u4_suffix_len += (u2_abs_value > (3 << (u4_suffix_len - 1)));\n }\n\n }\n\n if(u4_total_coeff < 4)\n {\n        UWORD32 u4_max_ldz = (4 - u4_total_coeff);\n        FIND_ONE_IN_STREAM_LEN(u4_total_zeroes, u4_bitstream_offset,\n                               pu4_bitstrm_buf, u4_max_ldz);\n }\n else\n        u4_total_zeroes = 0;\n\n {\n const UWORD8 *pu1_table_runbefore;\n        UWORD32 u4_run;\n        UWORD32 u4_scan_pos = (u4_total_coeff + u4_total_zeroes - 1);\n        UWORD32 u4_zeroes_left = u4_total_zeroes;\n        i = u4_total_coeff - 1;\n\n        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;\n while(u4_zeroes_left && i)\n {\n            UWORD32 u4_code;\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];\n            u4_run = u4_code >> 2;\n\n            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[i--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n\n while(i >= 0)\n {\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[i--];\n            u4_scan_pos--;\n }\n }\n\n {\n        WORD32 offset;\n        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;\n        offset = ALIGN4(offset);\n        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);\n }\n\n    ps_bitstrm->u4_ofst = u4_bitstream_offset;\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 187982, "func": "void SoundPool::doLoad(sp<Sample>& sample)\n{\n    ALOGV(\"doLoad: loading sample sampleID=%d\", sample->sampleID());\n    sample->startLoad();\n    mDecodeThread->loadSample(sample->sampleID());\n }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 8810, "func": "static inline bool should_invert_viewport(struct vrend_context *ctx)\n{\n   return !(ctx->sub->viewport_is_negative ^ ctx->sub->inverted_fbo_content);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8520, "func": "static int nullstrcmp(const char *a, const char *b)\n{\n    if (a == NULL && b == NULL)\n\treturn 0;\n    if (a == NULL)\n\treturn -1;\n    if (b == NULL)\n\treturn +1;\n    return strcmp(a, b);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9060, "func": "vmxnet3_send_packet(VMXNET3State *s, uint32_t qidx)\n{\n    Vmxnet3PktStatus status = VMXNET3_PKT_STATUS_OK;\n\n    if (!vmxnet3_setup_tx_offloads(s)) {\n        status = VMXNET3_PKT_STATUS_ERROR;\n        goto func_exit;\n    }\n\n    vmxnet3_dump_virt_hdr(net_tx_pkt_get_vhdr(s->tx_pkt));\n    net_tx_pkt_dump(s->tx_pkt);\n\n    if (!net_tx_pkt_send(s->tx_pkt, qemu_get_queue(s->nic))) {\n        status = VMXNET3_PKT_STATUS_DISCARD;\n        goto func_exit;\n    }\n\nfunc_exit:\n    vmxnet3_on_tx_done_update_stats(s, qidx, status);\n    return (status == VMXNET3_PKT_STATUS_OK);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187357, "func": "bool UsbChooserContext::HasDevicePermission(\n    const GURL& requesting_origin,\n    const GURL& embedding_origin,\n    const device::mojom::UsbDeviceInfo& device_info) {\n   if (UsbBlocklist::Get().IsExcluded(device_info))\n     return false;\n \n   if (!CanRequestObjectPermission(requesting_origin, embedding_origin))\n     return false;\n \n  auto it = ephemeral_devices_.find(\n      std::make_pair(requesting_origin, embedding_origin));\n  if (it != ephemeral_devices_.end() &&\n      base::ContainsKey(it->second, device_info.guid)) {\n    return true;\n  }\n\n  std::vector<std::unique_ptr<base::DictionaryValue>> device_list =\n      GetGrantedObjects(requesting_origin, embedding_origin);\n  for (const std::unique_ptr<base::DictionaryValue>& device_dict :\n       device_list) {\n    int vendor_id;\n    int product_id;\n    base::string16 serial_number;\n    if (device_dict->GetInteger(kVendorIdKey, &vendor_id) &&\n        device_info.vendor_id == vendor_id &&\n        device_dict->GetInteger(kProductIdKey, &product_id) &&\n        device_info.product_id == product_id &&\n        device_dict->GetString(kSerialNumberKey, &serial_number) &&\n        device_info.serial_number == serial_number) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187573, "func": "static int enable(void) {\n  LOG_INFO(\"%s\", __func__);\n \n   if (!interface_ready())\n     return BT_STATUS_NOT_READY;\n\n  stack_manager_get_interface()->start_up_stack_async();\n return BT_STATUS_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 188584, "func": " virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 8;\n     fwd_txfm_ref = fdct8x8_ref;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8799, "func": "static void flush_eventfd(int fd)\n{\n    ssize_t len;\n    uint64_t value;\n    do {\n       len = read(fd, &value, sizeof(value));\n    } while ((len == -1 && errno == EINTR) || len == sizeof(value));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187421, "func": "status_t SoundTriggerHwService::Module::loadSoundModel(const sp<IMemory>& modelMemory,\n sound_model_handle_t *handle)\n{\n    ALOGV(\"loadSoundModel() handle\");\n if (!captureHotwordAllowed()) {\n return PERMISSION_DENIED;\n }\n\n if (modelMemory == 0 || modelMemory->pointer() == NULL) {\n        ALOGE(\"loadSoundModel() modelMemory is 0 or has NULL pointer()\");\n return BAD_VALUE;\n }\n\n     struct sound_trigger_sound_model *sound_model =\n             (struct sound_trigger_sound_model *)modelMemory->pointer();\n \n     AutoMutex lock(mLock);\n \n     if (mModels.size() >= mDescriptor.properties.max_sound_models) {\n        ALOGW(\"loadSoundModel(): Not loading, max number of models (%d) would be exceeded\",\n              mDescriptor.properties.max_sound_models);\n return INVALID_OPERATION;\n }\n\n status_t status = mHwDevice->load_sound_model(mHwDevice, sound_model,\n SoundTriggerHwService::soundModelCallback,\n this, handle);\n\n if (status != NO_ERROR) {\n return status;\n }\n audio_session_t session;\n audio_io_handle_t ioHandle;\n audio_devices_t device;\n\n    status = AudioSystem::acquireSoundTriggerSession(&session, &ioHandle, &device);\n if (status != NO_ERROR) {\n return status;\n }\n\n    sp<Model> model = new Model(*handle, session, ioHandle, device, sound_model->type);\n    mModels.replaceValueFor(*handle, model);\n\n return status;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8377, "func": "static void mptsas_process_scsi_task_mgmt(MPTSASState *s, MPIMsgSCSITaskMgmt *req)\n{\n    MPIMsgSCSITaskMgmtReply reply;\n    MPIMsgSCSITaskMgmtReply *reply_async;\n    int status, count;\n    SCSIDevice *sdev;\n    SCSIRequest *r, *next;\n    BusChild *kid;\n\n    mptsas_fix_scsi_task_mgmt_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    memset(&reply, 0, sizeof(reply));\n    reply.TargetID   = req->TargetID;\n    reply.Bus        = req->Bus;\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.Function   = req->Function;\n    reply.TaskType   = req->TaskType;\n    reply.MsgContext = req->MsgContext;\n\n    switch (req->TaskType) {\n    case MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK:\n    case MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK:\n        status = mptsas_scsi_device_find(s, req->Bus, req->TargetID,\n                                         req->LUN, &sdev);\n        if (status) {\n            reply.IOCStatus = status;\n            goto out;\n        }\n        if (sdev->lun != req->LUN[1]) {\n            reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN;\n            goto out;\n        }\n\n        QTAILQ_FOREACH_SAFE(r, &sdev->requests, next, next) {\n            MPTSASRequest *cmd_req = r->hba_private;\n            if (cmd_req && cmd_req->scsi_io.MsgContext == req->TaskMsgContext) {\n                break;\n            }\n        }\n        if (r) {\n            assert(r->hba_private);\n            if (req->TaskType == MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK) {\n                reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED;\n            } else {\n                MPTSASCancelNotifier *notifier;\n\n                reply_async = g_memdup(&reply, sizeof(MPIMsgSCSITaskMgmtReply));\n                reply_async->IOCLogInfo = INT_MAX;\n\n                count = 1;\n                notifier = g_new(MPTSASCancelNotifier, 1);\n                notifier->s = s;\n                notifier->reply = reply_async;\n                notifier->notifier.notify = mptsas_cancel_notify;\n                scsi_req_cancel_async(r, &notifier->notifier);\n                goto reply_maybe_async;\n            }\n        }\n        break;\n\n    case MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\n    case MPI_SCSITASKMGMT_TASKTYPE_CLEAR_TASK_SET:\n        status = mptsas_scsi_device_find(s, req->Bus, req->TargetID,\n                                         req->LUN, &sdev);\n        if (status) {\n            reply.IOCStatus = status;\n            goto out;\n        }\n        if (sdev->lun != req->LUN[1]) {\n            reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN;\n            goto out;\n        }\n\n        reply_async = g_memdup(&reply, sizeof(MPIMsgSCSITaskMgmtReply));\n        reply_async->IOCLogInfo = INT_MAX;\n\n        count = 0;\n        QTAILQ_FOREACH_SAFE(r, &sdev->requests, next, next) {\n            if (r->hba_private) {\n                MPTSASCancelNotifier *notifier;\n\n                count++;\n                notifier = g_new(MPTSASCancelNotifier, 1);\n                notifier->s = s;\n                notifier->reply = reply_async;\n                notifier->notifier.notify = mptsas_cancel_notify;\n                scsi_req_cancel_async(r, &notifier->notifier);\n            }\n        }\n\nreply_maybe_async:\n        if (reply_async->TerminationCount < count) {\n            reply_async->IOCLogInfo = count;\n            return;\n        }\n        g_free(reply_async);\n        reply.TerminationCount = count;\n        break;\n\n    case MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:\n        status = mptsas_scsi_device_find(s, req->Bus, req->TargetID,\n                                         req->LUN, &sdev);\n        if (status) {\n            reply.IOCStatus = status;\n            goto out;\n        }\n        if (sdev->lun != req->LUN[1]) {\n            reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN;\n            goto out;\n        }\n        qdev_reset_all(&sdev->qdev);\n        break;\n\n    case MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n        if (req->Bus != 0) {\n            reply.IOCStatus = MPI_IOCSTATUS_SCSI_INVALID_BUS;\n            goto out;\n        }\n        if (req->TargetID > s->max_devices) {\n            reply.IOCStatus = MPI_IOCSTATUS_SCSI_INVALID_TARGETID;\n            goto out;\n        }\n\n        QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n            sdev = SCSI_DEVICE(kid->child);\n            if (sdev->channel == 0 && sdev->id == req->TargetID) {\n                qdev_reset_all(kid->child);\n            }\n        }\n        break;\n\n    case MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS:\n        qbus_reset_all(&s->bus.qbus);\n        break;\n\n    default:\n        reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED;\n        break;\n    }\n\nout:\n    mptsas_fix_scsi_task_mgmt_reply_endianness(&reply);\n    mptsas_post_reply(s, (MPIDefaultReply *)&reply);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8828, "func": "static bool vrend_compile_shader(struct vrend_context *ctx,\n                                 struct vrend_shader *shader)\n{\n   GLint param;\n   glShaderSource(shader->id, 1, (const char **)&shader->glsl_prog, NULL);\n   glCompileShader(shader->id);\n   glGetShaderiv(shader->id, GL_COMPILE_STATUS, &param);\n   if (param == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetShaderInfoLog(shader->id, 65536, &len, infolog);\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"shader failed to compile\\n%s\\n\", infolog);\n      fprintf(stderr,\"GLSL:\\n%s\\n\", shader->glsl_prog);\n      return false;\n   }\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187678, "func": "image_transform_png_set_tRNS_to_alpha_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_tRNS_to_alpha(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188498, "func": "int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n const VpxInterface *decoder = NULL;\n VpxVideoReader *reader = NULL;\n const VpxVideoInfo *info = NULL;\n int n = 0;\n int m = 0;\n int is_range = 0;\n char *nptr = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 4)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  n = strtol(argv[3], &nptr, 0);\n  m = strtol(nptr + 1, NULL, 0);\n  is_range = (*nptr == '-');\n if (!n || !m || (*nptr != '-' && *nptr != '/'))\n    die(\"Couldn't parse pattern %s.\\n\", argv[3]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder.\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n int skip;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame.\");\n\n ++frame_cnt;\n\n    skip = (is_range && frame_cnt >= n && frame_cnt <= m) ||\n (!is_range && m - (frame_cnt - 1) % m <= n);\n\n if (!skip) {\n      putc('.', stdout);\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL)\n        vpx_img_write(img, outfile);\n } else {\n      putc('X', stdout);\n }\n\n    fflush(stdout);\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n         info->frame_width, info->frame_height, argv[2]);\n\n  vpx_video_reader_close(reader);\n  fclose(outfile);\n\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "38,40"}
{"idx": 188145, "func": " native_handle_t* native_handle_create(int numFds, int numInts)\n {\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n \n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;\n        h->numInts = numInts;\n }\n return h;\n}\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 8416, "func": "pvscsi_init_msi(PVSCSIState *s)\n{\n    int res;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,\n                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);\n    if (res < 0) {\n        trace_pvscsi_init_msi_fail(res);\n        s->msi_used = false;\n    } else {\n        s->msi_used = true;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187358, "func": "UsbChooserContext::UsbChooserContext(Profile* profile)\n    : ChooserContextBase(profile,\n                         CONTENT_SETTINGS_TYPE_USB_GUARD,\n                          CONTENT_SETTINGS_TYPE_USB_CHOOSER_DATA),\n       is_incognito_(profile->IsOffTheRecord()),\n       client_binding_(this),\n      weak_factory_(this) {}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 188597, "func": "  unsigned int SAD(unsigned int max_sad, int block_idx = 0) {\n    unsigned int ret;\n    const uint8_t* const reference = GetReference(block_idx);\n    REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,\n                                            reference, reference_stride_,\n                                            max_sad));\n    return ret;\n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8"}
{"idx": 8833, "func": "int vrend_create_shader(struct vrend_context *ctx,\n                        uint32_t handle,\n                        const struct pipe_stream_output_info *so_info,\n                        const char *shd_text, uint32_t offlen, uint32_t num_tokens,\n                        uint32_t type, uint32_t pkt_length)\n{\n   struct vrend_shader_selector *sel = NULL;\n   int ret_handle;\n   bool new_shader = true, long_shader = false;\n   bool finished = false;\n   int ret;\n\n   if (type > PIPE_SHADER_GEOMETRY)\n      return EINVAL;\n\n   if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)\n      new_shader = false;\n   else if (((offlen + 3) / 4) > pkt_length)\n      long_shader = true;\n\n   if (ctx->sub->long_shader_in_progress_handle[type]) {\n      if (new_shader == true)\n         return EINVAL;\n      if (handle != ctx->sub->long_shader_in_progress_handle[type])\n         return EINVAL;\n   }\n\n   if (new_shader) {\n     sel = vrend_create_shader_state(ctx, so_info, type);\n     if (sel == NULL)\n       return ENOMEM;\n\n     if (long_shader) {\n        sel->buf_len = ((offlen + 3) / 4) * 4; \n        sel->tmp_buf = malloc(sel->buf_len);\n        if (!sel->tmp_buf) {\n           ret = ENOMEM;\n           goto error;\n        }\n        memcpy(sel->tmp_buf, shd_text, pkt_length * 4);\n        sel->buf_offset = pkt_length * 4;\n        ctx->sub->long_shader_in_progress_handle[type] = handle;\n     } else\n        finished = true;\n   } else {\n      sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);\n      if (!sel) {\n         fprintf(stderr, \"got continuation without original shader %d\\n\", handle);\n         ret = EINVAL;\n         goto error;\n      }\n\n      offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;\n      if (offlen != sel->buf_offset) {\n         fprintf(stderr, \"Got mismatched shader continuation %d vs %d\\n\",\n                 offlen, sel->buf_offset);\n         ret = EINVAL;\n         goto error;\n      }\n\n      if (pkt_length * 4 < pkt_length ||\n          pkt_length * 4 + sel->buf_offset < pkt_length * 4 ||\n          pkt_length * 4 + sel->buf_offset < sel->buf_offset) {\n            ret = EINVAL;\n            goto error;\n          }\n\n      if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {\n         fprintf(stderr, \"Got too large shader continuation %d vs %d\\n\",\n                 pkt_length * 4 + sel->buf_offset, sel->buf_len);\n         ret = EINVAL;\n         goto error;\n      }\n\n      memcpy(sel->tmp_buf + sel->buf_offset, shd_text, pkt_length * 4);\n\n      sel->buf_offset += pkt_length * 4;\n      if (sel->buf_offset >= sel->buf_len) {\n         finished = true;\n         shd_text = sel->tmp_buf;\n      }\n   }\n\n   if (finished) {\n      struct tgsi_token *tokens;\n\n      tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));\n      if (!tokens) {\n         ret = ENOMEM;\n         goto error;\n      }\n\n      if (vrend_dump_shaders)\n         fprintf(stderr,\"shader\\n%s\\n\", shd_text);\n      if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      }\n\n      if (vrend_finish_shader(ctx, sel, tokens)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      } else {\n         free(sel->tmp_buf);\n         sel->tmp_buf = NULL;\n      }\n      free(tokens);\n      ctx->sub->long_shader_in_progress_handle[type] = 0;\n   }\n\n   if (new_shader) {\n      ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);\n      if (ret_handle == 0) {\n         ret = ENOMEM;\n         goto error;\n      }\n   }\n\n   return 0;\n\nerror:\n   if (new_shader)\n      vrend_destroy_shader_selector(sel);\n   else\n      vrend_renderer_object_destroy(ctx, handle);\n\n   return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8887, "func": "static void vrend_pause_render_condition(struct vrend_context *ctx, bool pause)\n{\n   if (pause) {\n      if (ctx->sub->cond_render_q_id)\n         glEndConditionalRenderNV();\n   } else {\n      if (ctx->sub->cond_render_q_id)\n         glBeginConditionalRender(ctx->sub->cond_render_q_id,\n                                  ctx->sub->cond_render_gl_mode);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188172, "func": "void close_all_sockets(atransport* t) {\n    asocket* s;\n\n\n    adb_mutex_lock(&socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close_locked(s);\n             goto restart;\n         }\n     }\n    adb_mutex_unlock(&socket_list_lock);\n }\n", "target": 1, "flaw_line_index": "5,9,13"}
{"idx": 9096, "func": "static int vrend_decode_create_query(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   uint32_t query_type;\n   uint32_t query_index;\n   uint32_t res_handle;\n   uint32_t offset;\n   uint32_t tmp;\n\n   if (length != VIRGL_OBJ_QUERY_SIZE)\n      return EINVAL;\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_QUERY_TYPE_INDEX);\n   query_type = VIRGL_OBJ_QUERY_TYPE(tmp);\n   query_index = VIRGL_OBJ_QUERY_INDEX(tmp);\n\n   offset = get_buf_entry(ctx, VIRGL_OBJ_QUERY_OFFSET);\n   res_handle = get_buf_entry(ctx, VIRGL_OBJ_QUERY_RES_HANDLE);\n\n   return vrend_create_query(ctx->grctx, handle, query_type, query_index, res_handle, offset);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187457, "func": "static void btif_fetch_local_bdaddr(bt_bdaddr_t *local_addr)\n{\n char val[PROPERTY_VALUE_MAX] = {0};\n uint8_t valid_bda = FALSE;\n int val_size = 0;\n const uint8_t null_bdaddr[BD_ADDR_LEN] = {0,0,0,0,0,0};\n\n if (property_get(PROPERTY_BT_BDADDR_PATH, val, NULL))\n {\n int addr_fd;\n\n \n         BTIF_TRACE_DEBUG(\"%s, local bdaddr is stored in %s\", __func__, val);\n \n        if ((addr_fd = open(val, O_RDONLY)) != -1)\n         {\n             memset(val, 0, sizeof(val));\n            read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);\n             if ((string_to_bdaddr(val, local_addr)) &&\n                 (memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0))\n {\n                valid_bda = TRUE;\n                BTIF_TRACE_DEBUG(\"%s: Got Factory BDA %s\", __func__, val);\n }\n            close(addr_fd);\n }\n }\n\n if(!valid_bda)\n {\n        val_size = sizeof(val);\n if(btif_config_get_str(\"Adapter\", \"Address\", val, &val_size))\n {\n            string_to_bdaddr(val, local_addr);\n            BTIF_TRACE_DEBUG(\"local bdaddr from bt_config.xml is  %s\", val);\n return;\n }\n }\n\n if (!valid_bda) {\n        valid_bda = btif_fetch_property(PERSIST_BDADDR_PROPERTY, local_addr);\n }\n\n if (!valid_bda) {\n        valid_bda = btif_fetch_property(FACTORY_BT_ADDR_PROPERTY, local_addr);\n }\n\n if (!valid_bda)\n {\n bdstr_t bdstr;\n        srand((unsigned int) (time(0)));\n\n        local_addr->address[0] = 0x22;\n        local_addr->address[1] = 0x22;\n        local_addr->address[2] = (uint8_t) ((rand() >> 8) & 0xFF);\n        local_addr->address[3] = (uint8_t) ((rand() >> 8) & 0xFF);\n        local_addr->address[4] = (uint8_t) ((rand() >> 8) & 0xFF);\n        local_addr->address[5] = (uint8_t) ((rand() >> 8) & 0xFF);\n\n        bdaddr_to_string(local_addr, bdstr, sizeof(bdstr));\n\n        BTIF_TRACE_DEBUG(\"No preset BDA. Generating BDA: %s for prop %s\",\n (char*)bdstr, PERSIST_BDADDR_PROPERTY);\n\n if (property_set(PERSIST_BDADDR_PROPERTY, (char*)bdstr) < 0)\n            BTIF_TRACE_ERROR(\"Failed to set random BDA in prop %s\",PERSIST_BDADDR_PROPERTY);\n }\n\n bdstr_t bdstr;\n    bdaddr_to_string(local_addr, bdstr, sizeof(bdstr));\n    val_size = sizeof(val);\n if (btif_config_get_str(\"Adapter\", \"Address\", val, &val_size))\n {\n if (strcmp(bdstr, val) ==0)\n {\n return;\n }\n }\n    btif_config_set_str(\"Adapter\", \"Address\", bdstr);\n}\n", "target": 1, "flaw_line_index": "15,18"}
{"idx": 8860, "func": "static inline void vrend_fill_shader_key(struct vrend_context *ctx,\n                                         struct vrend_shader_key *key)\n{\n   if (vrend_state.use_core_profile == true) {\n      int i;\n      bool add_alpha_test = true;\n      key->cbufs_are_a8_bitmask = 0;\n      for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n         if (!ctx->sub->surf[i])\n            continue;\n         if (vrend_format_is_emulated_alpha(ctx->sub->surf[i]->format))\n            key->cbufs_are_a8_bitmask |= (1 << i);\n         if (util_format_is_pure_integer(ctx->sub->surf[i]->format))\n            add_alpha_test = false;\n      }\n      if (add_alpha_test) {\n         key->add_alpha_test = ctx->sub->dsa_state.alpha.enabled;\n         key->alpha_test = ctx->sub->dsa_state.alpha.func;\n         key->alpha_ref_val = ctx->sub->dsa_state.alpha.ref_value;\n      }\n\n      key->pstipple_tex = ctx->sub->rs_state.poly_stipple_enable;\n      key->color_two_side = ctx->sub->rs_state.light_twoside;\n\n      key->clip_plane_enable = ctx->sub->rs_state.clip_plane_enable;\n      key->flatshade = ctx->sub->rs_state.flatshade ? true : false;\n   } else {\n      key->add_alpha_test = 0;\n      key->pstipple_tex = 0;\n   }\n   key->invert_fs_origin = !ctx->sub->inverted_fbo_content;\n   key->coord_replace = ctx->sub->rs_state.point_quad_rasterization ? ctx->sub->rs_state.sprite_coord_enable : 0;\n\n   if (ctx->sub->shaders[PIPE_SHADER_GEOMETRY])\n      key->gs_present = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187642, "func": " image_transform_default_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n    UNUSED(bit_depth)\n\n this->next = *that;\n *that = this;\n\n return 1;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8620, "func": "static void vmsvga_text_update(void *opaque, console_ch_t *chardata)\n{\n    struct vmsvga_state_s *s = opaque;\n\n    if (s->vga.hw_ops->text_update) {\n        s->vga.hw_ops->text_update(&s->vga, chardata);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9170, "func": "static void set_texcoords_in_vertices(const float coord[4],\n                                      float *out, unsigned stride)\n{\n   out[0] = coord[0]; \n   out[1] = coord[1]; \n   out += stride;\n   out[0] = coord[2]; \n   out[1] = coord[1]; \n   out += stride;\n   out[0] = coord[2]; \n   out[1] = coord[3]; \n   out += stride;\n   out[0] = coord[0]; \n   out[1] = coord[3]; \n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9134, "func": "void vmxnet_tx_pkt_uninit(struct VmxnetTxPkt *pkt)\n{\n    if (pkt) {\n        g_free(pkt->vec);\n        g_free(pkt->raw);\n        g_free(pkt);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187462, "func": " static inline int btif_hl_select_close_connected(void){\n     char sig_on = btif_hl_signal_select_close_connected;\n     BTIF_TRACE_DEBUG(\"btif_hl_select_close_connected\");\n    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187363, "func": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n\n \n     android::Parcel* p = android::parcelForJavaObject(env, parcel);\n \n     SkRegion* region = new SkRegion;\n    size_t size = p->readInt32();\n    region->readFromMemory(p->readInplace(size), size);\n \n     return reinterpret_cast<jlong>(region);\n }\n", "target": 1, "flaw_line_index": "11,12"}
{"idx": 8703, "func": "test_path_simplify (void)\n{\n  static const struct {\n    const char *test, *result;\n    enum url_scheme scheme;\n    bool should_modify;\n  } tests[] = {\n    { \"\",                       \"\",             SCHEME_HTTP, false },\n    { \".\",                      \"\",             SCHEME_HTTP, true },\n    { \"./\",                     \"\",             SCHEME_HTTP, true },\n    { \"..\",                     \"\",             SCHEME_HTTP, true },\n    { \"../\",                    \"\",             SCHEME_HTTP, true },\n    { \"..\",                     \"..\",           SCHEME_FTP,  false },\n    { \"../\",                    \"../\",          SCHEME_FTP,  false },\n    { \"foo\",                    \"foo\",          SCHEME_HTTP, false },\n    { \"foo/bar\",                \"foo/bar\",      SCHEME_HTTP, false },\n    { \"foo\n    { \"foo/.\",                  \"foo/\",         SCHEME_HTTP, true },\n    { \"foo/./\",                 \"foo/\",         SCHEME_HTTP, true },\n    { \"foo./\",                  \"foo./\",        SCHEME_HTTP, false },\n    { \"foo/../bar\",             \"bar\",          SCHEME_HTTP, true },\n    { \"foo/../bar/\",            \"bar/\",         SCHEME_HTTP, true },\n    { \"foo/bar/..\",             \"foo/\",         SCHEME_HTTP, true },\n    { \"foo/bar/../x\",           \"foo/x\",        SCHEME_HTTP, true },\n    { \"foo/bar/../x/\",          \"foo/x/\",       SCHEME_HTTP, true },\n    { \"foo/..\",                 \"\",             SCHEME_HTTP, true },\n    { \"foo/../..\",              \"\",             SCHEME_HTTP, true },\n    { \"foo/../../..\",           \"\",             SCHEME_HTTP, true },\n    { \"foo/../../bar/../../baz\", \"baz\",         SCHEME_HTTP, true },\n    { \"foo/../..\",              \"..\",           SCHEME_FTP,  true },\n    { \"foo/../../..\",           \"../..\",        SCHEME_FTP,  true },\n    { \"foo/../../bar/../../baz\", \"../../baz\",   SCHEME_FTP,  true },\n    { \"a/b/../../c\",            \"c\",            SCHEME_HTTP, true },\n    { \"./a/../b\",               \"b\",            SCHEME_HTTP, true }\n  };\n  unsigned i;\n\n  for (i = 0; i < countof (tests); i++)\n    {\n      const char *message;\n      const char *test = tests[i].test;\n      const char *expected_result = tests[i].result;\n      enum url_scheme scheme = tests[i].scheme;\n      bool  expected_change = tests[i].should_modify;\n\n      message = run_test (test, expected_result, scheme, expected_change);\n      if (message) return message;\n    }\n  return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188254, "func": " void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n    mCore->dump(result, prefix);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8420, "func": "pvscsi_msg_ring_put(PVSCSIState *s, struct PVSCSIRingMsgDesc *msg_desc)\n{\n    hwaddr msg_descr_pa;\n\n    msg_descr_pa = pvscsi_ring_pop_msg_descr(&s->rings);\n    trace_pvscsi_msg_ring_put(msg_descr_pa);\n    cpu_physical_memory_write(msg_descr_pa, (void *)msg_desc,\n                              sizeof(*msg_desc));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8891, "func": "static void vrend_renderer_blit_int(struct vrend_context *ctx,\n                                    struct vrend_resource *src_res,\n                                    struct vrend_resource *dst_res,\n                                    const struct pipe_blit_info *info)\n{\n   GLbitfield glmask = 0;\n   int src_y1, src_y2, dst_y1, dst_y2;\n   GLenum filter;\n   int n_layers = 1, i;\n   bool use_gl = false;\n\n   filter = convert_mag_filter(info->filter);\n\n   if (!vrend_format_can_render(src_res->base.format) &&\n       !vrend_format_is_ds(src_res->base.format))\n      use_gl = true;\n   if (!vrend_format_can_render(dst_res->base.format) &&\n       !vrend_format_is_ds(dst_res->base.format))\n      use_gl = true;\n\n   if (vrend_format_is_ds(src_res->base.format) &&\n       vrend_format_is_ds(dst_res->base.format)) {\n      if (src_res->base.format != dst_res->base.format) {\n         if (!(src_res->base.format == PIPE_FORMAT_S8_UINT_Z24_UNORM &&\n               (dst_res->base.format == PIPE_FORMAT_Z24X8_UNORM))) {\n            use_gl = true;\n         }\n      }\n   }\n   if ((info->mask & (PIPE_MASK_Z | PIPE_MASK_S)) && info->filter == PIPE_TEX_FILTER_LINEAR)\n      use_gl = true;\n\n   if (src_res->base.nr_samples > 1 &&\n       src_res->base.nr_samples != dst_res->base.nr_samples &&\n       (info->src.box.width != info->dst.box.width ||\n        info->src.box.height != info->dst.box.height)) {\n      if (vrend_state.have_ms_scaled_blit)\n         filter = GL_SCALED_RESOLVE_NICEST_EXT;\n      else\n         use_gl = true;\n   }\n\n   if (info->src.box.depth != info->dst.box.depth)\n      use_gl = true;\n\n   if (vrend_format_is_emulated_alpha(info->dst.format) ||\n       vrend_format_is_emulated_alpha(info->src.format))\n      use_gl = true;\n\n   if (use_gl) {\n      vrend_renderer_blit_gl(ctx, src_res, dst_res, info);\n      vrend_clicbs->make_current(0, ctx->sub->gl_context);\n      return;\n   }\n\n   if (info->mask & PIPE_MASK_Z)\n      glmask |= GL_DEPTH_BUFFER_BIT;\n   if (info->mask & PIPE_MASK_S)\n      glmask |= GL_STENCIL_BUFFER_BIT;\n   if (info->mask & PIPE_MASK_RGBA)\n      glmask |= GL_COLOR_BUFFER_BIT;\n\n   if (!dst_res->y_0_top) {\n      dst_y1 = info->dst.box.y + info->dst.box.height;\n      dst_y2 = info->dst.box.y;\n   } else {\n      dst_y1 = dst_res->base.height0 - info->dst.box.y - info->dst.box.height;\n      dst_y2 = dst_res->base.height0 - info->dst.box.y;\n   }\n\n   if (!src_res->y_0_top) {\n      src_y1 = info->src.box.y + info->src.box.height;\n      src_y2 = info->src.box.y;\n   } else {\n      src_y1 = src_res->base.height0 - info->src.box.y - info->src.box.height;\n      src_y2 = src_res->base.height0 - info->src.box.y;\n   }\n\n   if (info->scissor_enable) {\n      glScissor(info->scissor.minx, info->scissor.miny, info->scissor.maxx - info->scissor.minx, info->scissor.maxy - info->scissor.miny);\n      ctx->sub->scissor_state_dirty = (1 << 0);\n      glEnable(GL_SCISSOR_TEST);\n   } else\n      glDisable(GL_SCISSOR_TEST);\n\n   glBindFramebuffer(GL_FRAMEBUFFER_EXT, ctx->sub->blit_fb_ids[0]);\n   if (info->mask & PIPE_MASK_RGBA)\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_STENCIL_ATTACHMENT,\n                                GL_TEXTURE_2D, 0, 0);\n   else\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0,\n                                GL_TEXTURE_2D, 0, 0);\n   glBindFramebuffer(GL_FRAMEBUFFER_EXT, ctx->sub->blit_fb_ids[1]);\n   if (info->mask & PIPE_MASK_RGBA)\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_STENCIL_ATTACHMENT,\n                                GL_TEXTURE_2D, 0, 0);\n   else if (info->mask & (PIPE_MASK_Z | PIPE_MASK_S))\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0,\n                                GL_TEXTURE_2D, 0, 0);\n   if (info->src.box.depth == info->dst.box.depth)\n      n_layers = info->dst.box.depth;\n   for (i = 0; i < n_layers; i++) {\n      glBindFramebuffer(GL_FRAMEBUFFER_EXT, ctx->sub->blit_fb_ids[0]);\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_STENCIL_ATTACHMENT,\n                                GL_TEXTURE_2D, 0, 0);\n      vrend_fb_bind_texture(src_res, 0, info->src.level, info->src.box.z + i);\n\n      glBindFramebuffer(GL_FRAMEBUFFER_EXT, ctx->sub->blit_fb_ids[1]);\n\n      vrend_fb_bind_texture(dst_res, 0, info->dst.level, info->dst.box.z + i);\n      glBindFramebuffer(GL_DRAW_FRAMEBUFFER, ctx->sub->blit_fb_ids[1]);\n\n      glBindFramebuffer(GL_READ_FRAMEBUFFER, ctx->sub->blit_fb_ids[0]);\n\n      glBlitFramebuffer(info->src.box.x,\n                        src_y1,\n                        info->src.box.x + info->src.box.width,\n                        src_y2,\n                        info->dst.box.x,\n                        dst_y1,\n                        info->dst.box.x + info->dst.box.width,\n                        dst_y2,\n                        glmask, filter);\n   }\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187819, "func": "OMX_ERRORTYPE  omx_vdec::set_config(OMX_IN OMX_HANDLETYPE      hComp,\n        OMX_IN OMX_INDEXTYPE configIndex,\n        OMX_IN OMX_PTR        configData)\n{\n (void) hComp;\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"Get Config in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n\n    OMX_ERRORTYPE ret = OMX_ErrorNone;\n    OMX_VIDEO_CONFIG_NALSIZE *pNal;\n\n \n     DEBUG_PRINT_LOW(\"Set Config Called\");\n \n    if (configIndex == (OMX_INDEXTYPE)OMX_IndexVendorVideoExtraData) {\n        OMX_VENDOR_EXTRADATATYPE *config = (OMX_VENDOR_EXTRADATATYPE *) configData;\n        DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData called\");\n        if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.avc\") ||\n            !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mvc\")) {\n            DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData AVC\");\n            OMX_U32 extra_size;\n            nal_length = (config->pData[4] & 0x03) + 1;\n            extra_size = 0;\n            if (nal_length > 2) {\n                extra_size = (nal_length - 2) * 2;\n            }\n            OMX_U8 *pSrcBuf = (OMX_U8 *) (&config->pData[6]);\n            OMX_U8 *pDestBuf;\n            m_vendor_config.nPortIndex = config->nPortIndex;\n            m_vendor_config.nDataSize = config->nDataSize - 6 - 1 + extra_size;\n            m_vendor_config.pData = (OMX_U8 *) malloc(m_vendor_config.nDataSize);\n            OMX_U32 len;\n            OMX_U8 index = 0;\n            pDestBuf = m_vendor_config.pData;\n            DEBUG_PRINT_LOW(\"Rxd SPS+PPS nPortIndex[%u] len[%u] data[%p]\",\n                    (unsigned int)m_vendor_config.nPortIndex,\n                    (unsigned int)m_vendor_config.nDataSize,\n                    m_vendor_config.pData);\n            while (index < 2) {\n                uint8 *psize;\n                len = *pSrcBuf;\n                len = len << 8;\n                len |= *(pSrcBuf + 1);\n                psize = (uint8 *) & len;\n                memcpy(pDestBuf + nal_length, pSrcBuf + 2,len);\n                for (unsigned int i = 0; i < nal_length; i++) {\n                    pDestBuf[i] = psize[nal_length - 1 - i];\n                }\n                pDestBuf += len + nal_length;\n                pSrcBuf += len + 2;\n                index++;\n                pSrcBuf++;   \n                len = 0;\n            }\n        } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg4\") ||\n                !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg2\")) {\n            m_vendor_config.nPortIndex = config->nPortIndex;\n            m_vendor_config.nDataSize = config->nDataSize;\n            m_vendor_config.pData = (OMX_U8 *) malloc((config->nDataSize));\n            memcpy(m_vendor_config.pData, config->pData,config->nDataSize);\n        } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.vc1\")) {\n            if (m_vendor_config.pData) {\n                free(m_vendor_config.pData);\n                m_vendor_config.pData = NULL;\n                m_vendor_config.nDataSize = 0;\n            }\n            if (((*((OMX_U32 *) config->pData)) &\n                        VC1_SP_MP_START_CODE_MASK) ==\n                    VC1_SP_MP_START_CODE) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 simple/main profile\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize = config->nDataSize;\n                m_vendor_config.pData =\n                    (OMX_U8 *) malloc(config->nDataSize);\n                memcpy(m_vendor_config.pData, config->pData,\n                        config->nDataSize);\n                m_vc1_profile = VC1_SP_MP_RCV;\n            } else if (*((OMX_U32 *) config->pData) == VC1_AP_SEQ_START_CODE) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 Advance profile\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize = config->nDataSize;\n                m_vendor_config.pData =\n                    (OMX_U8 *) malloc((config->nDataSize));\n                memcpy(m_vendor_config.pData, config->pData,\n                        config->nDataSize);\n                m_vc1_profile = VC1_AP;\n            } else if ((config->nDataSize == VC1_STRUCT_C_LEN)) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 Simple/Main profile struct C only\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize  = config->nDataSize;\n                m_vendor_config.pData = (OMX_U8*)malloc(config->nDataSize);\n                memcpy(m_vendor_config.pData,config->pData,config->nDataSize);\n                m_vc1_profile = VC1_SP_MP_RCV;\n            } else {\n                DEBUG_PRINT_LOW(\"set_config - Error: Unknown VC1 profile\");\n            }\n        }\n        return ret;\n    } else if (configIndex == OMX_IndexConfigVideoNalSize) {\n         struct v4l2_control temp;\n         temp.id = V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT;\n \n        VALIDATE_OMX_PARAM_DATA(configData, OMX_VIDEO_CONFIG_NALSIZE);\n        pNal = reinterpret_cast < OMX_VIDEO_CONFIG_NALSIZE * >(configData);\n switch (pNal->nNaluBytes) {\n case 0:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_STARTCODES;\n break;\n case 2:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_TWO_BYTE_LENGTH;\n break;\n case 4:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_FOUR_BYTE_LENGTH;\n break;\n default:\n return OMX_ErrorUnsupportedSetting;\n }\n\n if (!arbitrary_bytes) {\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &temp)) {\n                DEBUG_PRINT_ERROR(\"Failed to set V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT\");\n return OMX_ErrorHardware;\n }\n }\n\n        nal_length = pNal->nNaluBytes;\n        m_frame_parser.init_nal_length(nal_length);\n\n        DEBUG_PRINT_LOW(\"OMX_IndexConfigVideoNalSize called with Size %d\", nal_length);\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexVendorVideoFrameRate) {\n        OMX_VENDOR_VIDEOFRAMERATE *config = (OMX_VENDOR_VIDEOFRAMERATE *) configData;\n        DEBUG_PRINT_HIGH(\"Index OMX_IndexVendorVideoFrameRate %u\", (unsigned int)config->nFps);\n\n if (config->nPortIndex == OMX_CORE_INPUT_PORT_INDEX) {\n if (config->bEnabled) {\n if ((config->nFps >> 16) > 0) {\n                    DEBUG_PRINT_HIGH(\"set_config: frame rate set by omx client : %u\",\n (unsigned int)config->nFps >> 16);\n                    Q16ToFraction(config->nFps, drv_ctx.frame_rate.fps_numerator,\n                            drv_ctx.frame_rate.fps_denominator);\n\n if (!drv_ctx.frame_rate.fps_numerator) {\n                        DEBUG_PRINT_ERROR(\"Numerator is zero setting to 30\");\n                        drv_ctx.frame_rate.fps_numerator = 30;\n }\n\n if (drv_ctx.frame_rate.fps_denominator) {\n                        drv_ctx.frame_rate.fps_numerator = (int)\n                            drv_ctx.frame_rate.fps_numerator / drv_ctx.frame_rate.fps_denominator;\n }\n\n                    drv_ctx.frame_rate.fps_denominator = 1;\n                    frm_int = drv_ctx.frame_rate.fps_denominator * 1e6 /\n                        drv_ctx.frame_rate.fps_numerator;\n\n struct v4l2_outputparm oparm;\n                    oparm.timeperframe.numerator = drv_ctx.frame_rate.fps_denominator;\n                    oparm.timeperframe.denominator = drv_ctx.frame_rate.fps_numerator;\n\n struct v4l2_streamparm sparm;\n                    sparm.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n                    sparm.parm.output = oparm;\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_PARM, &sparm)) {\n                        DEBUG_PRINT_ERROR(\"Unable to convey fps info to driver, \\\n                                performance might be affected\");\n                        ret = OMX_ErrorHardware;\n }\n                    client_set_fps = true;\n } else {\n                    DEBUG_PRINT_ERROR(\"Frame rate not supported.\");\n                    ret = OMX_ErrorUnsupportedSetting;\n }\n } else {\n                DEBUG_PRINT_HIGH(\"set_config: Disabled client's frame rate\");\n                client_set_fps = false;\n }\n } else {\n            DEBUG_PRINT_ERROR(\" Set_config: Bad Port idx %d\",\n (int)config->nPortIndex);\n            ret = OMX_ErrorBadPortIndex;\n }\n\n return ret;\n } else if ((int)configIndex == (int)OMX_QcomIndexConfigPerfLevel) {\n        OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =\n (OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;\n struct v4l2_control control;\n\n        DEBUG_PRINT_LOW(\"Set perf level: %d\", perf->ePerfLevel);\n\n        control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;\n\n switch (perf->ePerfLevel) {\n case OMX_QCOM_PerfLevelNominal:\n                control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL;\n break;\n case OMX_QCOM_PerfLevelTurbo:\n                control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO;\n break;\n default:\n                ret = OMX_ErrorUnsupportedSetting;\n break;\n }\n\n if (ret == OMX_ErrorNone) {\n            ret = (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control) < 0) ?\n                OMX_ErrorUnsupportedSetting : OMX_ErrorNone;\n }\n\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexConfigPriority) {\n        OMX_PARAM_U32TYPE *priority = (OMX_PARAM_U32TYPE *)configData;\n        DEBUG_PRINT_LOW(\"Set_config: priority %d\", priority->nU32);\n\n struct v4l2_control control;\n\n        control.id = V4L2_CID_MPEG_VIDC_VIDEO_PRIORITY;\n if (priority->nU32 == 0)\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_ENABLE;\n else\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_DISABLE;\n\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {\n            DEBUG_PRINT_ERROR(\"Failed to set Priority\");\n            ret = OMX_ErrorUnsupportedSetting;\n }\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexConfigOperatingRate) {\n        OMX_PARAM_U32TYPE *rate = (OMX_PARAM_U32TYPE *)configData;\n        DEBUG_PRINT_LOW(\"Set_config: operating-rate %u fps\", rate->nU32 >> 16);\n\n struct v4l2_control control;\n\n        control.id = V4L2_CID_MPEG_VIDC_VIDEO_OPERATING_RATE;\n        control.value = rate->nU32;\n\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {\n            ret = errno == -EBUSY ? OMX_ErrorInsufficientResources :\n                    OMX_ErrorUnsupportedSetting;\n            DEBUG_PRINT_ERROR(\"Failed to set operating rate %u fps (%s)\",\n                    rate->nU32 >> 16, errno == -EBUSY ? \"HW Overload\" : strerror(errno));\n }\n return ret;\n }\n\n return OMX_ErrorNotImplemented;\n}\n", "target": 1, "flaw_line_index": "17,18,19,20,21,22,23,24,25,26,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113"}
{"idx": 188526, "func": "   void SetConstantInput(int value) {\n     memset(input_, value, kInputBufferSize);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187413, "func": " bool FrameworkListener::onDataAvailable(SocketClient *c) {\n char buffer[CMD_BUF_SIZE];\n int len;\n\n    len = TEMP_FAILURE_RETRY(read(c->getSocket(), buffer, sizeof(buffer)));\n\n     if (len < 0) {\n         SLOGE(\"read() failed (%s)\", strerror(errno));\n         return false;\n    } else if (!len)\n         return false;\n   if(buffer[len-1] != '\\0')\n         SLOGW(\"String is not zero-terminated\");\n \n     int offset = 0;\n     int i;\n\n\n     for (i = 0; i < len; i++) {\n         if (buffer[i] == '\\0') {\n            dispatchCommand(c, buffer + offset);\n             offset = i + 1;\n         }\n     }\n \n     return true;\n }\n", "target": 1, "flaw_line_index": "10,12,21"}
{"idx": 187381, "func": "void OMXNodeInstance::invalidateBufferID(OMX::buffer_id buffer __unused) {\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8754, "func": "void FAST_FUNC udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt)\n{\n\tunsigned len;\n\tuint8_t *optionptr = packet->options;\n\tunsigned end = udhcp_end_option(optionptr);\n\n\tlen = OPT_DATA + addopt[OPT_LEN];\n\tif (end + len + 1 >= DHCP_OPTIONS_BUFSIZE) {\n\t\tbb_error_msg(\"option 0x%02x did not fit into the packet\",\n\t\t\t\taddopt[OPT_CODE]);\n\t\treturn;\n\t}\n\tlog_option(\"adding option\", addopt);\n\tmemcpy(optionptr + end, addopt, len);\n\toptionptr[end + len] = DHCP_END;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187433, "func": "void ASessionDescription::getFormatType(\n size_t index, unsigned long *PT,\n AString *desc, AString *params) const {\n AString format;\n    getFormat(index, &format);\n\n const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n char *end;\n unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n \n     *PT = x;\n \n    char key[20];\n    sprintf(key, \"a=rtpmap:%lu\", x);\n \n     CHECK(findAttribute(index, key, desc));\n \n    sprintf(key, \"a=fmtp:%lu\", x);\n     if (!findAttribute(index, key, params)) {\n         params->clear();\n     }\n}\n", "target": 1, "flaw_line_index": "18,19,23"}
{"idx": 8992, "func": "static uint64_t vmxnet3_get_mac_high(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[4]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[5]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8764, "func": "static int bcast_or_ucast(struct dhcp_packet *packet, uint32_t ciaddr, uint32_t server)\n{\n\tif (server)\n\t\treturn udhcp_send_kernel_packet(packet,\n\t\t\tciaddr, CLIENT_PORT,\n\t\t\tserver, SERVER_PORT);\n\treturn raw_bcast_from_client_config_ifindex(packet, ciaddr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187973, "func": "void impeg2d_peek_next_start_code(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }\n return;\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 187852, "func": " long Cluster::Load(long long& pos, long& len) const {\n   assert(m_pSegment);\n   assert(m_pos >= m_element_start);\n\n if (m_timecode >= 0) \n return 0;\n\n  assert(m_pos == m_element_start);\n  assert(m_element_size < 0);\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long total, avail;\n\n const int status = pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n  assert((total < 0) || (m_pos <= total)); \n\n  pos = m_pos;\n\n long long cluster_size = -1;\n\n {\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long id_ = ReadUInt(pReader, pos, len);\n\n if (id_ < 0) \n return static_cast<long>(id_);\n\n if (id_ != 0x0F43B675) \n return E_FILE_FORMAT_INVALID;\n\n    pos += len; \n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(cluster_size);\n\n if (size == 0)\n return E_FILE_FORMAT_INVALID; \n\n    pos += len; \n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size != unknown_size)\n\n       cluster_size = size;\n   }\n \n#if 0\n    len = static_cast<long>(size_);\n    if (cluster_stop > avail)\n        return E_BUFFER_NOT_FULL;\n#endif\n   long long timecode = -1;\n   long long new_pos = -1;\n   bool bBlock = false;\n\n long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;\n\n for (;;) {\n if ((cluster_stop >= 0) && (pos >= cluster_stop))\n break;\n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long id = ReadUInt(pReader, pos, len);\n\n if (id < 0) \n return static_cast<long>(id);\n\n if (id == 0)\n return E_FILE_FORMAT_INVALID;\n\n\n if (id == 0x0F43B675) \n break;\n\n if (id == 0x0C53BB6B) \n break;\n\n    pos += len; \n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID;\n\n    pos += len; \n\n if ((cluster_stop >= 0) && (pos > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n\n if (size == 0) \n continue;\n\n if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if (id == 0x67) { \n      len = static_cast<long>(size);\n\n if ((pos + size) > avail)\n return E_BUFFER_NOT_FULL;\n\n      timecode = UnserializeUInt(pReader, pos, size);\n\n if (timecode < 0) \n return static_cast<long>(timecode);\n\n      new_pos = pos + size;\n\n if (bBlock)\n break;\n } else if (id == 0x20) { \n      bBlock = true;\n break;\n } else if (id == 0x23) { \n      bBlock = true;\n break;\n\n     }\n \n     pos += size;  \n    assert((cluster_stop < 0) || (pos <= cluster_stop));\n   }\n \n  assert((cluster_stop < 0) || (pos <= cluster_stop));\n \n   if (timecode < 0)  \n     return E_FILE_FORMAT_INVALID;\n\n if (!bBlock)\n return E_FILE_FORMAT_INVALID;\n\n  m_pos = new_pos; \n  m_timecode = timecode; \n\n if (cluster_size >= 0)\n    m_element_size = cluster_stop - m_element_start;\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "95,96,97,98,99,100,221,224"}
{"idx": 8443, "func": "pvscsi_reset(DeviceState *dev)\n{\n    PCIDevice *d = PCI_DEVICE(dev);\n    PVSCSIState *s = PVSCSI(d);\n\n    trace_pvscsi_state(\"reset\");\n    pvscsi_reset_adapter(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187987, "func": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n\n     const size_t kGroupSize = 12;\n     const size_t kStartCharCodeOffset = 0;\n     const size_t kEndCharCodeOffset = 4;\n     if (kFirstGroupOffset > size) {\n         return false;\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n    if (kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {\n uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n        addRange(coverage, start, end + 1); \n }\n return true;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 187699, "func": "static double pcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n if (pm->assume_16_bit_calculations ||\n (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxpc16 * .01;\n else\n return pm->maxpc8 * .01;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187593, "func": "static void readpng2_warning_handler(png_structp png_ptr, png_const_charp msg)\n\n {\n     fprintf(stderr, \"readpng2 libpng warning: %s\\n\", msg);\n     fflush(stderr);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8479, "func": "UINT CSoundFile::GetMaxPosition() const\n{\n\tUINT max = 0;\n\tUINT i = 0;\n\n\twhile ((i < MAX_ORDERS) && (Order[i] != 0xFF))\n\t{\n\t\tif (Order[i] < MAX_PATTERNS) max += PatternSize[Order[i]];\n\t\ti++;\n\t}\n\treturn max;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9093, "func": "static int vrend_decode_create_blend(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_blend_state *blend_state;\n   uint32_t tmp;\n   int i;\n\n   if (length != VIRGL_OBJ_BLEND_SIZE) {\n      return EINVAL;\n   }\n\n   blend_state = CALLOC_STRUCT(pipe_blend_state);\n   if (!blend_state)\n      return ENOMEM;\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_BLEND_S0);\n   blend_state->independent_blend_enable = (tmp & 1);\n   blend_state->logicop_enable = (tmp >> 1) & 0x1;\n   blend_state->dither = (tmp >> 2) & 0x1;\n   blend_state->alpha_to_coverage = (tmp >> 3) & 0x1;\n   blend_state->alpha_to_one = (tmp >> 4) & 0x1;\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_BLEND_S1);\n   blend_state->logicop_func = tmp & 0xf;\n\n   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {\n      tmp = get_buf_entry(ctx, VIRGL_OBJ_BLEND_S2(i));\n      blend_state->rt[i].blend_enable = tmp & 0x1;\n      blend_state->rt[i].rgb_func = (tmp >> 1) & 0x7;\n      blend_state->rt[i].rgb_src_factor = (tmp >> 4) & 0x1f;\n      blend_state->rt[i].rgb_dst_factor = (tmp >> 9) & 0x1f;\n      blend_state->rt[i].alpha_func = (tmp >> 14) & 0x7;\n      blend_state->rt[i].alpha_src_factor = (tmp >> 17) & 0x1f;\n      blend_state->rt[i].alpha_dst_factor = (tmp >> 22) & 0x1f;\n      blend_state->rt[i].colormask = (tmp >> 27) & 0xf;\n   }\n\n   tmp = vrend_renderer_object_insert(ctx->grctx, blend_state, sizeof(struct pipe_blend_state), handle,\n                                      VIRGL_OBJECT_BLEND);\n   if (tmp == 0) {\n      FREE(blend_state);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188016, "func": "IHEVCD_ERROR_T ihevcd_parse_pps(codec_t *ps_codec)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 value;\n    WORD32 pps_id;\n\n pps_t *ps_pps;\n sps_t *ps_sps;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n\n\n if(0 == ps_codec->i4_sps_done)\n return IHEVCD_INVALID_HEADER;\n\n    UEV_PARSE(\"pic_parameter_set_id\", value, ps_bitstrm);\n\n    pps_id = value;\n if((pps_id >= MAX_PPS_CNT) || (pps_id < 0))\n {\n if(ps_codec->i4_pps_done)\n return IHEVCD_UNSUPPORTED_PPS_ID;\n else\n            pps_id = 0;\n }\n\n\n    ps_pps = (ps_codec->s_parse.ps_pps_base + MAX_PPS_CNT - 1);\n\n    ps_pps->i1_pps_id = pps_id;\n\n    UEV_PARSE(\"seq_parameter_set_id\", value, ps_bitstrm);\n    ps_pps->i1_sps_id = value;\n    ps_pps->i1_sps_id = CLIP3(ps_pps->i1_sps_id, 0, MAX_SPS_CNT - 2);\n\n    ps_sps = (ps_codec->s_parse.ps_sps_base + ps_pps->i1_sps_id);\n\n if(0 == ps_sps->i1_sps_valid)\n {\n return IHEVCD_INVALID_HEADER;\n\n }\n\n    BITS_PARSE(\"dependent_slices_enabled_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_dependent_slice_enabled_flag = value;\n\n    BITS_PARSE(\"output_flag_present_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_output_flag_present_flag = value;\n\n    BITS_PARSE(\"num_extra_slice_header_bits\", value, ps_bitstrm, 3);\n    ps_pps->i1_num_extra_slice_header_bits = value;\n\n\n    BITS_PARSE(\"sign_data_hiding_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_sign_data_hiding_flag = value;\n\n    BITS_PARSE(\"cabac_init_present_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_cabac_init_present_flag = value;\n\n    UEV_PARSE(\"num_ref_idx_l0_default_active_minus1\", value, ps_bitstrm);\n    ps_pps->i1_num_ref_idx_l0_default_active = value + 1;\n\n    UEV_PARSE(\"num_ref_idx_l1_default_active_minus1\", value, ps_bitstrm);\n    ps_pps->i1_num_ref_idx_l1_default_active = value + 1;\n\n    SEV_PARSE(\"pic_init_qp_minus26\", value, ps_bitstrm);\n    ps_pps->i1_pic_init_qp = value + 26;\n\n    BITS_PARSE(\"constrained_intra_pred_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_constrained_intra_pred_flag = value;\n\n    BITS_PARSE(\"transform_skip_enabled_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_transform_skip_enabled_flag = value;\n\n    BITS_PARSE(\"cu_qp_delta_enabled_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_cu_qp_delta_enabled_flag = value;\n\n if(ps_pps->i1_cu_qp_delta_enabled_flag)\n {\n        UEV_PARSE(\"diff_cu_qp_delta_depth\", value, ps_bitstrm);\n        ps_pps->i1_diff_cu_qp_delta_depth = value;\n }\n else\n {\n        ps_pps->i1_diff_cu_qp_delta_depth = 0;\n }\n    ps_pps->i1_log2_min_cu_qp_delta_size = ps_sps->i1_log2_ctb_size - ps_pps->i1_diff_cu_qp_delta_depth;\n    SEV_PARSE(\"cb_qp_offset\", value, ps_bitstrm);\n    ps_pps->i1_pic_cb_qp_offset = value;\n\n    SEV_PARSE(\"cr_qp_offset\", value, ps_bitstrm);\n    ps_pps->i1_pic_cr_qp_offset = value;\n\n    BITS_PARSE(\"slicelevel_chroma_qp_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag = value;\n\n    BITS_PARSE(\"weighted_pred_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_weighted_pred_flag = value;\n\n    BITS_PARSE(\"weighted_bipred_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_weighted_bipred_flag = value;\n\n    BITS_PARSE(\"transquant_bypass_enable_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_transquant_bypass_enable_flag = value;\n\n\n     BITS_PARSE(\"tiles_enabled_flag\", value, ps_bitstrm, 1);\n     ps_pps->i1_tiles_enabled_flag = value;\n \n     BITS_PARSE(\"entropy_coding_sync_enabled_flag\", value, ps_bitstrm, 1);\n     ps_pps->i1_entropy_coding_sync_enabled_flag = value;\n \n    ps_pps->i1_loop_filter_across_tiles_enabled_flag = 0;\n if(ps_pps->i1_tiles_enabled_flag)\n {\n        WORD32 wd = ALIGN64(ps_codec->i4_wd);\n        WORD32 ht = ALIGN64(ps_codec->i4_ht);\n\n        WORD32 max_tile_cols = (wd + MIN_TILE_WD - 1) / MIN_TILE_WD;\n        WORD32 max_tile_rows = (ht + MIN_TILE_HT - 1) / MIN_TILE_HT;\n\n        UEV_PARSE(\"num_tile_columns_minus1\", value, ps_bitstrm);\n        ps_pps->i1_num_tile_columns = value + 1;\n\n        UEV_PARSE(\"num_tile_rows_minus1\", value, ps_bitstrm);\n        ps_pps->i1_num_tile_rows = value + 1;\n\n if((ps_pps->i1_num_tile_columns < 1) ||\n (ps_pps->i1_num_tile_columns > max_tile_cols) ||\n (ps_pps->i1_num_tile_rows < 1) ||\n (ps_pps->i1_num_tile_rows > max_tile_rows))\n return IHEVCD_INVALID_HEADER;\n\n        BITS_PARSE(\"uniform_spacing_flag\", value, ps_bitstrm, 1);\n        ps_pps->i1_uniform_spacing_flag = value;\n\n\n {\n\n            WORD32 start;\n            WORD32 i, j;\n\n\n            start = 0;\n for(i = 0; i < ps_pps->i1_num_tile_columns; i++)\n {\n tile_t *ps_tile;\n if(!ps_pps->i1_uniform_spacing_flag)\n {\n if(i < (ps_pps->i1_num_tile_columns - 1))\n {\n                        UEV_PARSE(\"column_width_minus1[ i ]\", value, ps_bitstrm);\n                        value += 1;\n }\n else\n {\n                        value = ps_sps->i2_pic_wd_in_ctb - start;\n }\n }\n else\n {\n                    value = ((i + 1) * ps_sps->i2_pic_wd_in_ctb) / ps_pps->i1_num_tile_columns -\n (i * ps_sps->i2_pic_wd_in_ctb) / ps_pps->i1_num_tile_columns;\n }\n\n for(j = 0; j < ps_pps->i1_num_tile_rows; j++)\n {\n                    ps_tile = ps_pps->ps_tile + j * ps_pps->i1_num_tile_columns + i;\n                    ps_tile->u1_pos_x = start;\n                    ps_tile->u2_wd = value;\n }\n                start += value;\n\n if((start > ps_sps->i2_pic_wd_in_ctb) ||\n (value <= 0))\n return IHEVCD_INVALID_HEADER;\n }\n\n            start = 0;\n for(i = 0; i < (ps_pps->i1_num_tile_rows); i++)\n {\n tile_t *ps_tile;\n if(!ps_pps->i1_uniform_spacing_flag)\n {\n if(i < (ps_pps->i1_num_tile_rows - 1))\n {\n\n                        UEV_PARSE(\"row_height_minus1[ i ]\", value, ps_bitstrm);\n                        value += 1;\n }\n else\n {\n                        value = ps_sps->i2_pic_ht_in_ctb - start;\n }\n }\n else\n {\n                    value = ((i + 1) * ps_sps->i2_pic_ht_in_ctb) / ps_pps->i1_num_tile_rows -\n (i * ps_sps->i2_pic_ht_in_ctb) / ps_pps->i1_num_tile_rows;\n }\n\n for(j = 0; j < ps_pps->i1_num_tile_columns; j++)\n {\n                    ps_tile = ps_pps->ps_tile + i * ps_pps->i1_num_tile_columns + j;\n                    ps_tile->u1_pos_y = start;\n                    ps_tile->u2_ht = value;\n }\n                start += value;\n\n if((start > ps_sps->i2_pic_ht_in_ctb) ||\n (value <= 0))\n return IHEVCD_INVALID_HEADER;\n }\n }\n\n\n        BITS_PARSE(\"loop_filter_across_tiles_enabled_flag\", value, ps_bitstrm, 1);\n        ps_pps->i1_loop_filter_across_tiles_enabled_flag = value;\n\n }\n else\n {\n        ps_pps->i1_num_tile_columns = 1;\n        ps_pps->i1_num_tile_rows = 1;\n        ps_pps->i1_uniform_spacing_flag = 1;\n\n        ps_pps->ps_tile->u1_pos_x = 0;\n        ps_pps->ps_tile->u1_pos_y = 0;\n        ps_pps->ps_tile->u2_wd = ps_sps->i2_pic_wd_in_ctb;\n        ps_pps->ps_tile->u2_ht = ps_sps->i2_pic_ht_in_ctb;\n }\n\n    BITS_PARSE(\"loop_filter_across_slices_enabled_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_loop_filter_across_slices_enabled_flag = value;\n\n    BITS_PARSE(\"deblocking_filter_control_present_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_deblocking_filter_control_present_flag = value;\n\n    ps_pps->i1_pic_disable_deblocking_filter_flag = 0;\n    ps_pps->i1_deblocking_filter_override_enabled_flag = 0;\n    ps_pps->i1_beta_offset_div2 = 0;\n    ps_pps->i1_tc_offset_div2 = 0;\n\n if(ps_pps->i1_deblocking_filter_control_present_flag)\n {\n\n        BITS_PARSE(\"deblocking_filter_override_enabled_flag\", value, ps_bitstrm, 1);\n        ps_pps->i1_deblocking_filter_override_enabled_flag = value;\n\n        BITS_PARSE(\"pic_disable_deblocking_filter_flag\", value, ps_bitstrm, 1);\n        ps_pps->i1_pic_disable_deblocking_filter_flag = value;\n\n if(!ps_pps->i1_pic_disable_deblocking_filter_flag)\n {\n\n            SEV_PARSE(\"pps_beta_offset_div2\", value, ps_bitstrm);\n            ps_pps->i1_beta_offset_div2 = value;\n\n            SEV_PARSE(\"pps_tc_offset_div2\", value, ps_bitstrm);\n            ps_pps->i1_tc_offset_div2 = value;\n\n }\n }\n\n    BITS_PARSE(\"pps_scaling_list_data_present_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_pps_scaling_list_data_present_flag = value;\n\n if(ps_pps->i1_pps_scaling_list_data_present_flag)\n {\n        COPY_DEFAULT_SCALING_LIST(ps_pps->pi2_scaling_mat);\n        ihevcd_scaling_list_data(ps_codec, ps_pps->pi2_scaling_mat);\n }\n\n    BITS_PARSE(\"lists_modification_present_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_lists_modification_present_flag = value;\n    UEV_PARSE(\"log2_parallel_merge_level_minus2\", value, ps_bitstrm);\n    ps_pps->i1_log2_parallel_merge_level = value + 2;\n\n    BITS_PARSE(\"slice_header_extension_present_flag\", value, ps_bitstrm, 1);\n    ps_pps->i1_slice_header_extension_present_flag = value;\n    BITS_PARSE(\"pps_extension_flag\", value, ps_bitstrm, 1);\n\n if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)\n return IHEVCD_INVALID_PARAMETER;\n\n    ps_codec->i4_pps_done = 1;\n return ret;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9136, "func": "static void eat_opt_white( const char **pcur )\n{\n   while (**pcur == ' ' || **pcur == '\\t' || **pcur == '\\n')\n      (*pcur)++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8758, "func": "uint8_t* FAST_FUNC udhcp_get_option(struct dhcp_packet *packet, int code)\n{\n\tuint8_t *optionptr;\n\tint len;\n\tint rem;\n\tint overload = 0;\n\tenum {\n\t\tFILE_FIELD101  = FILE_FIELD  * 0x101,\n\t\tSNAME_FIELD101 = SNAME_FIELD * 0x101,\n\t};\n\n\toptionptr = packet->options;\n\trem = sizeof(packet->options);\n\twhile (1) {\n\t\tif (rem <= 0) {\n complain:\n\t\t\tbb_error_msg(\"bad packet, malformed option field\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (optionptr[OPT_CODE] == DHCP_PADDING) {\n\t\t\trem--;\n\t\t\toptionptr++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (optionptr[OPT_CODE] == DHCP_END) {\n\t\t\tif ((overload & FILE_FIELD101) == FILE_FIELD) {\n\t\t\t\toverload |= FILE_FIELD101; \n\t\t\t\toptionptr = packet->file;\n\t\t\t\trem = sizeof(packet->file);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((overload & SNAME_FIELD101) == SNAME_FIELD) {\n\t\t\t\toverload |= SNAME_FIELD101; \n\t\t\t\toptionptr = packet->sname;\n\t\t\t\trem = sizeof(packet->sname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rem <= OPT_LEN)\n\t\t\tgoto complain; \n\t\tlen = 2 + optionptr[OPT_LEN];\n\t\trem -= len;\n\t\tif (rem < 0)\n\t\t\tgoto complain; \n\n\t\tif (optionptr[OPT_CODE] == code) {\n\t\t\tif (optionptr[OPT_LEN] == 0) {\n\t\t\t\tgoto complain; \n\t\t\t}\n\t\t\tlog_option(\"option found\", optionptr);\n\t\t\treturn optionptr + OPT_DATA;\n\t\t}\n\n\t\tif (optionptr[OPT_CODE] == DHCP_OPTION_OVERLOAD) {\n\t\t\tif (len >= 3)\n\t\t\t\toverload |= optionptr[OPT_DATA];\n\t\t}\n\t\toptionptr += len;\n\t}\n\n\tlog3(\"option 0x%02x not found\", code);\n\treturn NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8939, "func": "void vrend_set_sample_mask(struct vrend_context *ctx, unsigned sample_mask)\n{\n   glSampleMaski(0, sample_mask);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187878, "func": "long long Segment::ParseHeaders() {\n long long total, available;\n\n const int status = m_pReader->Length(&total, &available);\n\n\n   if (status < 0)  \n     return status;\n \n  assert((total < 0) || (available <= total));\n \n   const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));\n  assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n   for (;;) {\n     if ((total >= 0) && (m_pos >= total))\n break;\n\n if ((segment_stop >= 0) && (m_pos >= segment_stop))\n break;\n\n\n     long long pos = m_pos;\n     const long long element_start = pos;\n \n     if ((pos + 1) > available)\n       return (pos + 1);\n \n long len;\n long long result = GetUIntLength(m_pReader, pos, len);\n\n\n     if (result < 0)  \n       return result;\n \n    if (result > 0)  \n       return (pos + 1);\n \n     if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n       return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > available)\n\n       return pos + len;\n \n     const long long idpos = pos;\n    const long long id = ReadUInt(m_pReader, idpos, len);\n \n    if (id < 0)  \n      return id;\n \n     if (id == 0x0F43B675)  \n       break;\n\n    pos += len; \n\n if ((pos + 1) > available)\n return (pos + 1);\n\n    result = GetUIntLength(m_pReader, pos, len);\n\n\n     if (result < 0)  \n       return result;\n \n    if (result > 0)  \n       return (pos + 1);\n \n     if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n       return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > available)\n return pos + len;\n\n \n     const long long size = ReadUInt(m_pReader, pos, len);\n \n    if (size < 0)  \n       return size;\n \n     pos += len;  \n \n     const long long element_size = size + pos - element_start;\n \n\n if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n\n if ((pos + size) > available)\n return pos + size;\n\n if (id == 0x0549A966) { \n if (m_pInfo)\n return E_FILE_FORMAT_INVALID;\n\n      m_pInfo = new (std::nothrow)\n SegmentInfo(this, pos, size, element_start, element_size);\n\n if (m_pInfo == NULL)\n return -1;\n\n const long status = m_pInfo->Parse();\n\n if (status)\n return status;\n } else if (id == 0x0654AE6B) { \n if (m_pTracks)\n return E_FILE_FORMAT_INVALID;\n\n      m_pTracks = new (std::nothrow)\n Tracks(this, pos, size, element_start, element_size);\n\n if (m_pTracks == NULL)\n return -1;\n\n const long status = m_pTracks->Parse();\n\n if (status)\n return status;\n } else if (id == 0x0C53BB6B) { \n if (m_pCues == NULL) {\n        m_pCues = new (std::nothrow)\n Cues(this, pos, size, element_start, element_size);\n\n if (m_pCues == NULL)\n return -1;\n }\n } else if (id == 0x014D9B74) { \n if (m_pSeekHead == NULL) {\n        m_pSeekHead = new (std::nothrow)\n SeekHead(this, pos, size, element_start, element_size);\n\n if (m_pSeekHead == NULL)\n return -1;\n\n const long status = m_pSeekHead->Parse();\n\n if (status)\n return status;\n }\n } else if (id == 0x0043A770) { \n if (m_pChapters == NULL) {\n        m_pChapters = new (std::nothrow)\n Chapters(this, pos, size, element_start, element_size);\n\n if (m_pChapters == NULL)\n return -1;\n\n const long status = m_pChapters->Parse();\n\n\n         if (status)\n           return status;\n       }\n     }\n \n     m_pos = pos + size;  \n   }\n \n  assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n   if (m_pInfo == NULL)  \n     return E_FILE_FORMAT_INVALID;\n\n if (m_pTracks == NULL)\n return E_FILE_FORMAT_INVALID;\n\n return 0; \n}\n", "target": 1, "flaw_line_index": "13,16,17,40,51,53,54,71,83,168"}
{"idx": 188058, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n if ((u2_width != ps_dec->u2_horizontal_size)\n || (u2_height != ps_dec->u2_vertical_size))\n {\n if (0 == ps_dec->u2_header_done)\n {\n            ps_dec->u2_horizontal_size = u2_width;\n            ps_dec->u2_vertical_size = u2_height;\n if (0 == ps_dec->u4_frm_buf_stride)\n {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);\n }\n }\n else\n {\n if((u2_width > ps_dec->u2_create_max_width)\n || (u2_height > ps_dec->u2_create_max_height))\n {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n return e_error;\n }\n else\n {\n return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n }\n }\n }\n\n if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n return SET_IVD_FATAL_ERROR(e_error);\n }\n\n\n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n\n     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n\n }\n else\n {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n }\n\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n }\n else\n {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n }\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187474, "func": "int uinput_create(char *name)\n{\n struct uinput_dev dev;\n int fd, x = 0;\n\n \n     for(x=0; x < MAX_UINPUT_PATHS; x++)\n     {\n        fd = open(uinput_dev_path[x], O_RDWR);\n         if (fd < 0)\n             continue;\n         break;\n }\n if (x == MAX_UINPUT_PATHS) {\n        BTIF_TRACE_ERROR(\"%s ERROR: uinput device open failed\", __FUNCTION__);\n return -1;\n }\n    memset(&dev, 0, sizeof(dev));\n if (name)\n        strncpy(dev.name, name, UINPUT_MAX_NAME_SIZE-1);\n\n    dev.id.bustype = BUS_BLUETOOTH;\n    dev.id.vendor  = 0x0000;\n\n     dev.id.product = 0x0000;\n     dev.id.version = 0x0000;\n \n    if (write(fd, &dev, sizeof(dev)) < 0) {\n         BTIF_TRACE_ERROR(\"%s Unable to write device information\", __FUNCTION__);\n         close(fd);\n         return -1;\n     }\n \n    ioctl(fd, UI_SET_EVBIT, EV_KEY);\n    ioctl(fd, UI_SET_EVBIT, EV_REL);\n    ioctl(fd, UI_SET_EVBIT, EV_SYN);\n \n     for (x = 0; key_map[x].name != NULL; x++)\n        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);\n \n    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {\n         BTIF_TRACE_ERROR(\"%s Unable to create uinput device\", __FUNCTION__);\n         close(fd);\n         return -1;\n }\n return fd;\n}\n", "target": 1, "flaw_line_index": "9,28,34,35,36,39,41"}
{"idx": 8393, "func": "int virtio_queue_ready(VirtQueue *vq)\n{\n    return vq->vring.avail != 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187521, "func": "static inline void uipc_wakeup_locked(void)\n\n {\n     char sig_on = 1;\n     BTIF_TRACE_EVENT(\"UIPC SEND WAKE UP\");\n    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8428, "func": "pvscsi_on_cmd_unknown(PVSCSIState *s)\n{\n    trace_pvscsi_on_cmd_unknown_data(s->curr_cmd_data[0]);\n    return PVSCSI_COMMAND_PROCESSING_FAILED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188089, "func": "void vp8_decoder_remove_threads(VP8D_COMP *pbi)\n{\n    if (pbi->b_multithreaded_rd)\n    {\n        int i;\n \n        pbi->b_multithreaded_rd = 0;\n        for (i = 0; i < pbi->allocated_decoding_thread_count; i++)\n        {\n            sem_post(&pbi->h_event_start_decoding[i]);\n            pthread_join(pbi->h_decoding_thread[i], NULL);\n        }\n        for (i = 0; i < pbi->allocated_decoding_thread_count; i++)\n        {\n            sem_destroy(&pbi->h_event_start_decoding[i]);\n        }\n        sem_destroy(&pbi->h_event_end_decoding);\n            vpx_free(pbi->h_decoding_thread);\n            pbi->h_decoding_thread = NULL;\n            vpx_free(pbi->h_event_start_decoding);\n            pbi->h_event_start_decoding = NULL;\n            vpx_free(pbi->mb_row_di);\n            pbi->mb_row_di = NULL ;\n            vpx_free(pbi->de_thread_data);\n            pbi->de_thread_data = NULL;\n     }\n }\n", "target": 1, "flaw_line_index": "2,2,3,4,5,7,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25"}
{"idx": 187646, "func": "image_transform_png_set_background_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->have_tRNS && that->colour_type != PNG_COLOR_TYPE_PALETTE)\n      image_pixel_add_alpha(that, &display->this);\n \n    if (that->alphaf < 1)\n {\n if (that->alphaf <= 0)\n {\n         that->redf = data.redf;\n         that->greenf = data.greenf;\n         that->bluef = data.bluef;\n\n         that->rede = data.rede;\n         that->greene = data.greene;\n         that->bluee = data.bluee;\n\n         that->red_sBIT= data.red_sBIT;\n         that->green_sBIT= data.green_sBIT;\n         that->blue_sBIT= data.blue_sBIT;\n }\n\n else \n {\n double alf = 1 - that->alphaf;\n\n         that->redf = that->redf * that->alphaf + data.redf * alf;\n         that->rede = that->rede * that->alphaf + data.rede * alf +\n            DBL_EPSILON;\n         that->greenf = that->greenf * that->alphaf + data.greenf * alf;\n         that->greene = that->greene * that->alphaf + data.greene * alf +\n            DBL_EPSILON;\n         that->bluef = that->bluef * that->alphaf + data.bluef * alf;\n         that->bluee = that->bluee * that->alphaf + data.bluee * alf +\n            DBL_EPSILON;\n }\n\n\n       that->alphaf = 1;\n       that->alphae = 0;\n      if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         that->colour_type = PNG_COLOR_TYPE_RGB;\n      else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n         that->colour_type = PNG_COLOR_TYPE_GRAY;\n    }\n \n    this->next->mod(this->next, that, pp, display);\n }\n", "target": 1, "flaw_line_index": "3,6,43,44,45,46,46"}
{"idx": 8636, "func": "static size_t fill(uint8_t *data, size_t size, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vfill(data, size, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8603, "func": "static void vmsvga_bios_write(void *opaque, uint32_t address, uint32_t data)\n{\n    printf(\"%s: what are we supposed to do with (%08x)?\\n\", __func__, data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8973, "func": "static void _vmxnet3_deassert_interrupt_line(VMXNET3State *s, int lidx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    assert(!s->msix_used || !msix_enabled(d));\n    assert(!msi_enabled(d));\n\n    VMW_IRPRN(\"Deasserting line for interrupt %u\", lidx);\n    pci_irq_deassert(d);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188152, "func": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n\n     }\n \n     Mutex::Autolock autoLock(mLock);\n    if (allottedSize > params->size()) {\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, portIndex, true);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n\n     }\n \n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n \n     *buffer = makeBufferID(header);\n \n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "11,15"}
{"idx": 8731, "func": "static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)\n{\n    int ret;\n    ret = X509_check_issued(issuer, x);\n    if (ret == X509_V_OK)\n        return 1;\n    if (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))\n        return 0;\n\n    ctx->error = ret;\n    ctx->current_cert = x;\n    ctx->current_issuer = issuer;\n    return ctx->verify_cb(0, ctx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187651, "func": " image_transform_png_set_expand_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187936, "func": "WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,\n                                               UWORD32 u4_total_coeff_trail_one, \n dec_bit_stream_t *ps_bitstrm)\n{\n    UWORD32 u4_total_zeroes;\n    WORD32 i;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n\n     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;\n     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;\n     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;\n    WORD16 i2_level_arr[16];\n \n     tu_sblk4x4_coeff_data_t *ps_tu_4x4;\n     WORD16 *pi2_coeff_data;\n dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;\n\n    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;\n    ps_tu_4x4->u2_sig_coeff_map = 0;\n    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];\n\n    i = u4_total_coeff - 1;\n\n if(u4_trailing_ones)\n {\n        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;\n        WORD16 (*ppi2_trlone_lkup)[3] =\n (WORD16 (*)[3])gai2_ih264d_trailing_one_level;\n        WORD16 *pi2_trlone_lkup;\n\n        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);\n\n        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];\n\n while(u4_cnt--)\n            i2_level_arr[i--] = *pi2_trlone_lkup++;\n }\n\n if(i >= 0)\n {\n        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;\n        WORD32 u2_lev_code, u2_abs_value;\n        UWORD32 u4_lev_prefix;\n\n        FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                              pu4_bitstrm_buf);\n\n        u2_lev_code = MIN(15, u4_lev_prefix);\n\n        u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;\n\n if(14 == u4_lev_prefix)\n            u4_lev_suffix_size = 4;\n else if(15 <= u4_lev_prefix)\n {\n            u2_lev_code += 15;\n            u4_lev_suffix_size = u4_lev_prefix - 3;\n }\n else\n            u4_lev_suffix_size = 0;\n\n if(16 <= u4_lev_prefix)\n {\n            u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n if(u4_lev_suffix_size)\n {\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code += u4_lev_suffix;\n }\n\n        u2_abs_value = (u2_lev_code + 2) >> 1;\n        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;\n\n while(i >= 0)\n {\n\n            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                                  pu4_bitstrm_buf);\n\n            u4_lev_suffix_size =\n (15 <= u4_lev_prefix) ?\n (u4_lev_prefix - 3) : u4_suffix_len;\n\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)\n + u4_lev_suffix;\n\n if(16 <= u4_lev_prefix)\n {\n                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n            u2_abs_value = (u2_lev_code + 2) >> 1;\n\n            i2_level_arr[i--] =\n (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n            u4_suffix_len +=\n (u4_suffix_len < 6) ?\n (u2_abs_value\n > (3\n << (u4_suffix_len\n - 1))) :\n 0;\n }\n\n }\n\n {\n        UWORD32 u4_index;\n const UWORD8 (*ppu1_total_zero_lkup)[64] =\n (const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;\n\n        NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);\n        u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];\n\n        FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));\n        u4_total_zeroes &= 0xf;\n }\n\n {\n const UWORD8 *pu1_table_runbefore;\n        UWORD32 u4_run;\n        WORD32 k;\n        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;\n        WORD32 u4_zeroes_left = u4_total_zeroes;\n        k = u4_total_coeff - 1;\n\n while((u4_zeroes_left > 6) && k)\n {\n            UWORD32 u4_code;\n\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n if(u4_code != 0)\n {\n                FLUSHBITS(u4_bitstream_offset, 3);\n                u4_run = (7 - u4_code);\n }\n else\n {\n\n                FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,\n                                       pu4_bitstrm_buf, 11);\n                u4_run = (4 + u4_code);\n }\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n\n        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;\n while((u4_zeroes_left > 0) && k)\n {\n            UWORD32 u4_code;\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];\n            u4_run = u4_code >> 2;\n\n            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n\n if(u4_zeroes_left < 0)\n return -1;\n while(k >= 0)\n {\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_scan_pos--;\n }\n }\n\n {\n        WORD32 offset;\n        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;\n        offset = ALIGN4(offset);\n        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);\n }\n\n    ps_bitstrm->u4_ofst = u4_bitstream_offset;\n return 0;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 188536, "func": "   virtual void SetUp() {\n     InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n   }\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 187733, "func": "transform_disable(PNG_CONST char *name)\n {\n    image_transform *list = image_transform_first;\n \n while (list != &image_transform_end)\n {\n if (strcmp(list->name, name) == 0)\n {\n list->enable = 0;\n return;\n }\n\n list = list->list;\n }\n\n   fprintf(stderr, \"pngvalid: --transform-disable=%s: unknown transform\\n\",\n      name);\n   exit(99);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187470, "func": "static int tap_if_down(const char *devname)\n{\n struct ifreq ifr;\n int sk;\n\n    sk = socket(AF_INET, SOCK_DGRAM, 0);\n if (sk < 0)\n return -1;\n\n    memset(&ifr, 0, sizeof(ifr));\n    strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);\n\n \n     ifr.ifr_flags &= ~IFF_UP;\n \n    ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n \n     close(sk);\n \n return 0;\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 188595, "func": "  virtual uint8_t* GetReference(int block_idx) {\n     return reference_data_ + block_idx * kDataBlockSize;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8507, "func": "static void c_write_stderr(int trusted, const char *buf, int len)\n{\n    int i;\n    for (i = 0; i < len; i++)\n\tif (buf[i] != '\\r' && (trusted || buf[i] == '\\n' || (buf[i] & 0x60)))\n\t    fputc(buf[i], stderr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9032, "func": "static void vmxnet3_pre_save(void *opaque)\n{\n    VMXNET3State *s = opaque;\n\n    s->mcast_list_buff_size = s->mcast_list_len * sizeof(MACAddr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8464, "func": "signed char* CSoundFile::AllocateSample(UINT nbytes)\n{\n\tsigned char * p = (signed char *)GlobalAllocPtr(GHND, (nbytes+39) & ~7);\n\tif (p) p += 16;\n\treturn p;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187624, "func": "image_transform_png_set_@_set(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n{\n   png_set_@(pp);\n   this->next->set(this->next, that, pp, pi);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 8863, "func": "static inline bool vrend_format_can_render(enum virgl_formats format)\n{\n   return tex_conv_table[format].bindings & VREND_BIND_RENDER;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187385, "func": "status_t MPEG4Source::read(\n MediaBuffer **out, const ReadOptions *options) {\n Mutex::Autolock autoLock(mLock);\n\n    CHECK(mStarted);\n\n if (mFirstMoofOffset > 0) {\n return fragmentedRead(out, options);\n }\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n uint32_t findFlags = 0;\n switch (mode) {\n case ReadOptions::SEEK_PREVIOUS_SYNC:\n                findFlags = SampleTable::kFlagBefore;\n break;\n case ReadOptions::SEEK_NEXT_SYNC:\n                findFlags = SampleTable::kFlagAfter;\n break;\n case ReadOptions::SEEK_CLOSEST_SYNC:\n case ReadOptions::SEEK_CLOSEST:\n                findFlags = SampleTable::kFlagClosest;\n break;\n default:\n                CHECK(!\"Should not be here.\");\n break;\n }\n\n uint32_t sampleIndex;\n status_t err = mSampleTable->findSampleAtTime(\n                seekTimeUs, 1000000, mTimescale,\n &sampleIndex, findFlags);\n\n if (mode == ReadOptions::SEEK_CLOSEST) {\n            findFlags = SampleTable::kFlagBefore;\n }\n\n uint32_t syncSampleIndex;\n if (err == OK) {\n            err = mSampleTable->findSyncSampleNear(\n                    sampleIndex, &syncSampleIndex, findFlags);\n }\n\n uint32_t sampleTime;\n if (err == OK) {\n            err = mSampleTable->getMetaDataForSample(\n                    sampleIndex, NULL, NULL, &sampleTime);\n }\n\n if (err != OK) {\n if (err == ERROR_OUT_OF_RANGE) {\n                err = ERROR_END_OF_STREAM;\n }\n            ALOGV(\"end of stream\");\n return err;\n }\n\n if (mode == ReadOptions::SEEK_CLOSEST) {\n            targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;\n }\n\n#if 0\n uint32_t syncSampleTime;\n        CHECK_EQ(OK, mSampleTable->getMetaDataForSample(\n                    syncSampleIndex, NULL, NULL, &syncSampleTime));\n\n        ALOGI(\"seek to time %lld us => sample at time %lld us, \"\n \"sync sample at time %lld us\",\n             seekTimeUs,\n             sampleTime * 1000000ll / mTimescale,\n             syncSampleTime * 1000000ll / mTimescale);\n#endif\n\n        mCurrentSampleIndex = syncSampleIndex;\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset;\n size_t size;\n uint32_t cts, stts;\n bool isSyncSample;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n status_t err =\n            mSampleTable->getMetaDataForSample(\n                    mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);\n\n if (err != OK) {\n return err;\n }\n\n        err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n return err;\n }\n }\n\n if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {\n if (newBuffer) {\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->clear();\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n            mBuffer->meta_data()->setInt64(\n                    kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC && !mIsHEVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mBuffer->range_length() < mNALLengthSize + nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n if (usesDRM) {\n            num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);\n } else {\n            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);\n }\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n\n             size_t dstOffset = 0;\n \n             while (srcOffset < size) {\n                bool isMalFormed = (srcOffset + mNALLengthSize > size);\n                 size_t nalLength = 0;\n                 if (!isMalFormed) {\n                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                     srcOffset += mNALLengthSize;\n                    isMalFormed = srcOffset + nalLength > size;\n                 }\n \n                 if (isMalFormed) {\n                    ALOGE(\"Video is malformed\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n continue;\n }\n\n                CHECK(dstOffset + 4 <= mBuffer->size());\n\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->clear();\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n        mBuffer->meta_data()->setInt64(\n                kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n", "target": 1, "flaw_line_index": "226,231"}
{"idx": 8531, "func": "static int ssh1_pkt_getrsakey(struct Packet *pkt, struct RSAKey *key,\n\t\t\t      const unsigned char **keystr)\n{\n    int j;\n\n    j = makekey(pkt->body + pkt->savedpos,\n\t\tpkt->length - pkt->savedpos,\n\t\tkey, keystr, 0);\n\n    if (j < 0)\n\treturn FALSE;\n    \n    pkt->savedpos += j;\n    assert(pkt->savedpos < pkt->length);\n\n    return TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9067, "func": "vmxnet3_tx_retrieve_metadata(VMXNET3State *s,\n                             const struct Vmxnet3_TxDesc *txd)\n{\n    s->offload_mode = txd->om;\n    s->cso_or_gso_size = txd->msscof;\n    s->tci = txd->tci;\n    s->needs_vlan = txd->ti;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188018, "func": "sp<ABuffer> decodeBase64(const AString &s) {\n size_t n = s.size();\n if ((n % 4) != 0) {\n return NULL;\n }\n\n size_t padding = 0;\n if (n >= 1 && s.c_str()[n - 1] == '=') {\n        padding = 1;\n\n if (n >= 2 && s.c_str()[n - 2] == '=') {\n            padding = 2;\n\n if (n >= 3 && s.c_str()[n - 3] == '=') {\n                padding = 3;\n }\n }\n }\n\n size_t outLen = (n / 4) * 3 - padding;\n\n    sp<ABuffer> buffer = new ABuffer(outLen);\n\n uint8_t *out = buffer->data();\n if (out == NULL || buffer->size() < outLen) {\n return NULL;\n }\n size_t j = 0;\n uint32_t accum = 0;\n for (size_t i = 0; i < n; ++i) {\n char c = s.c_str()[i];\n unsigned value;\n if (c >= 'A' && c <= 'Z') {\n            value = c - 'A';\n } else if (c >= 'a' && c <= 'z') {\n            value = 26 + c - 'a';\n } else if (c >= '0' && c <= '9') {\n            value = 52 + c - '0';\n } else if (c == '+') {\n            value = 62;\n } else if (c == '/') {\n            value = 63;\n } else if (c != '=') {\n return NULL;\n } else {\n if (i < n - padding) {\n return NULL;\n }\n\n            value = 0;\n }\n\n\n         accum = (accum << 6) | value;\n \n         if (((i + 1) % 4) == 0) {\n            out[j++] = (accum >> 16);\n             if (j < outLen) { out[j++] = (accum >> 8) & 0xff; }\n             if (j < outLen) { out[j++] = accum & 0xff; }\n \n            accum = 0;\n }\n }\n\n return buffer;\n}\n", "target": 1, "flaw_line_index": "59"}
{"idx": 9106, "func": "static int vrend_decode_destroy_sub_ctx(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t ctx_sub_id = get_buf_entry(ctx, 1);\n\n   vrend_renderer_destroy_sub_ctx(ctx->grctx, ctx_sub_id);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9094, "func": "static int vrend_decode_create_dsa(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   int i;\n   struct pipe_depth_stencil_alpha_state *dsa_state;\n   uint32_t tmp;\n\n   if (length != VIRGL_OBJ_DSA_SIZE)\n      return EINVAL;\n\n   dsa_state = CALLOC_STRUCT(pipe_depth_stencil_alpha_state);\n   if (!dsa_state)\n      return ENOMEM;\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_DSA_S0);\n   dsa_state->depth.enabled = tmp & 0x1;\n   dsa_state->depth.writemask = (tmp >> 1) & 0x1;\n   dsa_state->depth.func = (tmp >> 2) & 0x7;\n\n   dsa_state->alpha.enabled = (tmp >> 8) & 0x1;\n   dsa_state->alpha.func = (tmp >> 9) & 0x7;\n\n   for (i = 0; i < 2; i++) {\n      tmp = get_buf_entry(ctx, VIRGL_OBJ_DSA_S1 + i);\n      dsa_state->stencil[i].enabled = tmp & 0x1;\n      dsa_state->stencil[i].func = (tmp >> 1) & 0x7;\n      dsa_state->stencil[i].fail_op = (tmp >> 4) & 0x7;\n      dsa_state->stencil[i].zpass_op = (tmp >> 7) & 0x7;\n      dsa_state->stencil[i].zfail_op = (tmp >> 10) & 0x7;\n      dsa_state->stencil[i].valuemask = (tmp >> 13) & 0xff;\n      dsa_state->stencil[i].writemask = (tmp >> 21) & 0xff;\n   }\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_DSA_ALPHA_REF);\n   dsa_state->alpha.ref_value = uif(tmp);\n\n   tmp = vrend_renderer_object_insert(ctx->grctx, dsa_state, sizeof(struct pipe_depth_stencil_alpha_state), handle,\n                                      VIRGL_OBJECT_DSA);\n   if (tmp == 0) {\n      FREE(dsa_state);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8570, "func": "static void ssh_pkt_adddata(struct Packet *pkt, const void *data, int len)\n{\n    pkt->length += len;\n    ssh_pkt_ensure(pkt, pkt->length);\n    memcpy(pkt->data + pkt->length - len, data, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8542, "func": "static void ssh2_pkt_defer(Ssh ssh, struct Packet *pkt)\n{\n    if (ssh->queueing)\n\tssh2_pkt_queue(ssh, pkt);\n    else\n\tssh2_pkt_defer_noqueue(ssh, pkt, FALSE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8832, "func": "int vrend_create_sampler_view(struct vrend_context *ctx,\n                              uint32_t handle,\n                              uint32_t res_handle, uint32_t format,\n                              uint32_t val0, uint32_t val1, uint32_t swizzle_packed)\n{\n   struct vrend_sampler_view *view;\n   struct vrend_resource *res;\n   int ret_handle;\n   res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n   if (!res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n      return EINVAL;\n   }\n\n   view = CALLOC_STRUCT(vrend_sampler_view);\n   if (!view)\n      return ENOMEM;\n\n   pipe_reference_init(&view->reference, 1);\n   view->format = format;\n   view->val0 = val0;\n   view->val1 = val1;\n   view->swizzle_r = swizzle_packed & 0x7;\n   view->swizzle_g = (swizzle_packed >> 3) & 0x7;\n   view->swizzle_b = (swizzle_packed >> 6) & 0x7;\n   view->swizzle_a = (swizzle_packed >> 9) & 0x7;\n   view->cur_base = -1;\n   view->cur_max = 10000;\n\n   vrend_resource_reference(&view->texture, res);\n\n   view->srgb_decode = GL_DECODE_EXT;\n   if (view->format != view->texture->base.format) {\n      if (util_format_is_srgb(view->texture->base.format) &&\n          !util_format_is_srgb(view->format))\n         view->srgb_decode = GL_SKIP_DECODE_EXT;\n   }\n\n   view->gl_swizzle_a = to_gl_swizzle(view->swizzle_a);\n   view->gl_swizzle_r = to_gl_swizzle(view->swizzle_r);\n   view->gl_swizzle_g = to_gl_swizzle(view->swizzle_g);\n   view->gl_swizzle_b = to_gl_swizzle(view->swizzle_b);\n\n   if (!(util_format_has_alpha(format) || util_format_is_depth_or_stencil(format))) {\n       if (view->gl_swizzle_a == GL_ALPHA)\n           view->gl_swizzle_a = GL_ONE;\n       if (view->gl_swizzle_r == GL_ALPHA)\n           view->gl_swizzle_r = GL_ONE;\n       if (view->gl_swizzle_g == GL_ALPHA)\n           view->gl_swizzle_g = GL_ONE;\n       if (view->gl_swizzle_b == GL_ALPHA)\n           view->gl_swizzle_b = GL_ONE;\n   }\n\n   if (tex_conv_table[format].flags & VREND_BIND_NEED_SWIZZLE) {\n      view->gl_swizzle_r = to_gl_swizzle(tex_conv_table[format].swizzle[0]);\n      view->gl_swizzle_g = to_gl_swizzle(tex_conv_table[format].swizzle[1]);\n      view->gl_swizzle_b = to_gl_swizzle(tex_conv_table[format].swizzle[2]);\n      view->gl_swizzle_a = to_gl_swizzle(tex_conv_table[format].swizzle[3]);\n   }\n   ret_handle = vrend_renderer_object_insert(ctx, view, sizeof(*view), handle, VIRGL_OBJECT_SAMPLER_VIEW);\n   if (ret_handle == 0) {\n      FREE(view);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9104, "func": "static int vrend_decode_create_ve(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_vertex_element *ve = NULL;\n   int num_elements;\n   int i;\n   int ret;\n\n   if (length < 1)\n      return EINVAL;\n\n   if ((length - 1) % 4)\n      return EINVAL;\n\n   num_elements = (length - 1) / 4;\n\n   if (num_elements) {\n      ve = calloc(num_elements, sizeof(struct pipe_vertex_element));\n\n      if (!ve)\n         return ENOMEM;\n\n      for (i = 0; i < num_elements; i++) {\n         ve[i].src_offset = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_OFFSET(i));\n         ve[i].instance_divisor = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_INSTANCE_DIVISOR(i));\n         ve[i].vertex_buffer_index = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_VERTEX_BUFFER_INDEX(i));\n\n         if (ve[i].vertex_buffer_index >= PIPE_MAX_ATTRIBS)\n            return EINVAL;\n\n         ve[i].src_format = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_FORMAT(i));\n      }\n   }\n\n   ret = vrend_create_vertex_elements_state(ctx->grctx, handle, num_elements, ve);\n\n   FREE(ve);\n   return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187513, "func": " void *atomic_thread_inc_dec(void *context) {\n   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;\n   for (int i = 0; i < at->max_val; i++) {\n    usleep(1);\n     atomic_inc_prefix_s32(&at->data[i]);\n    usleep(1);\n     atomic_dec_prefix_s32(&at->data[i]);\n   }\n   return NULL;\n}\n", "target": 1, "flaw_line_index": "4,6"}
{"idx": 8838, "func": "bool vrend_destroy_context(struct vrend_context *ctx)\n{\n   bool switch_0 = (ctx == vrend_state.current_ctx);\n   struct vrend_context *cur = vrend_state.current_ctx;\n   struct vrend_sub_context *sub, *tmp;\n   if (switch_0) {\n      vrend_state.current_ctx = NULL;\n      vrend_state.current_hw_ctx = NULL;\n   }\n\n   if (vrend_state.use_core_profile) {\n      if (ctx->pstip_inited)\n         glDeleteTextures(1, &ctx->pstipple_tex_id);\n      ctx->pstip_inited = false;\n   }\n   vrend_set_framebuffer_state(ctx, 0, NULL, 0);\n\n   vrend_set_num_sampler_views(ctx, PIPE_SHADER_VERTEX, 0, 0);\n   vrend_set_num_sampler_views(ctx, PIPE_SHADER_FRAGMENT, 0, 0);\n   vrend_set_num_sampler_views(ctx, PIPE_SHADER_GEOMETRY, 0, 0);\n\n   vrend_set_streamout_targets(ctx, 0, 0, NULL);\n   vrend_set_num_vbo(ctx, 0);\n\n   vrend_set_index_buffer(ctx, 0, 0, 0);\n\n   vrend_renderer_force_ctx_0();\n   LIST_FOR_EACH_ENTRY_SAFE(sub, tmp, &ctx->sub_ctxs, head)\n      vrend_destroy_sub_context(sub);\n\n   vrend_object_fini_ctx_table(ctx->res_hash);\n\n   list_del(&ctx->ctx_entry);\n\n   FREE(ctx);\n\n   if (!switch_0 && cur)\n      vrend_hw_switch_context(cur, true);\n\n   return switch_0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188108, "func": "void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,\n impeg2d_video_decode_op_t *ps_op)\n{\n\n    UWORD32 u4_bits_read;\n dec_state_t *ps_dec;\n    UWORD32 u4_size = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n\n    ps_dec = (dec_state_t *)pv_dec;\n    ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;\n if (u4_size > MAX_BITSTREAM_BUFFER_SIZE)\n {\n        u4_size = MAX_BITSTREAM_BUFFER_SIZE;\n }\n\n    memcpy(ps_dec->pu1_input_buffer, ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer, u4_size);\n\n    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), ps_dec->pu1_input_buffer,\n        u4_size);\n\n {\n {\n            IMPEG2D_ERROR_CODES_T e_error;\n            e_error = impeg2d_process_video_header(ps_dec);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n                ps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;\n\n                u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n\n                ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n }\n if(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)\n                    ps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;\n\n if (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)\n {\n                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;\n                    ps_dec->u2_header_done = 0;\n\n                    ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;\n                    ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;\n }\n                impeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);\n return;\n }\n }\n        ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;\n        ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;\n\n        ps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;\n        ps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;\n\n        u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n\n             ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n         }\n         ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;\n         ps_dec->u2_header_done = 1;\n \n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8847, "func": "static void vrend_destroy_so_target(struct vrend_so_target *target)\n{\n   vrend_resource_reference(&target->buffer, NULL);\n   free(target);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8568, "func": "static struct Packet *ssh_new_packet(void)\n{\n    struct Packet *pkt = snew(struct Packet);\n\n    pkt->body = pkt->data = NULL;\n    pkt->maxlen = 0;\n\n    return pkt;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8550, "func": "static void ssh2_pkt_send_noqueue(Ssh ssh, struct Packet *pkt)\n{\n    int len;\n    int backlog;\n    if (ssh->cscipher != NULL && (ssh->cscipher->flags & SSH_CIPHER_IS_CBC)) {\n\tssh2_pkt_defer_noqueue(ssh, pkt, FALSE);\n\tssh_pkt_defersend(ssh);\n\treturn;\n    }\n    len = ssh2_pkt_construct(ssh, pkt);\n    backlog = s_write(ssh, pkt->body, len);\n    if (backlog > SSH_MAX_BACKLOG)\n\tssh_throttle_all(ssh, 1, backlog);\n\n    ssh->outgoing_data_size += pkt->encrypted_len;\n    if (!ssh->kex_in_progress &&\n        !ssh->bare_connection &&\n\tssh->max_data_size != 0 &&\n\tssh->outgoing_data_size > ssh->max_data_size)\n\tdo_ssh2_transport(ssh, \"too much data sent\", -1, NULL);\n\n    ssh_free_packet(pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9010, "func": "static void vmxnet3_instance_init(Object *obj)\n{\n    VMXNET3State *s = VMXNET3(obj);\n    device_add_bootindex_property(obj, &s->conf.bootindex,\n                                  \"bootindex\", \"/ethernet-phy@0\",\n                                  DEVICE(obj), NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187735, "func": "transform_enable(PNG_CONST char *name)\n {\n static int all_disabled = 0;\n int found_it = 0;\n   image_transform *list = image_transform_first;\n\n while (list != &image_transform_end)\n {\n if (strcmp(list->name, name) == 0)\n {\n list->enable = 1;\n         found_it = 1;\n }\n else if (!all_disabled)\n list->enable = 0;\n\n list = list->list;\n }\n\n   all_disabled = 1;\n\n if (!found_it)\n {\n      fprintf(stderr, \"pngvalid: --transform-enable=%s: unknown transform\\n\",\n         name);\n      exit(99);\n }\n\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8627, "func": "static int eth_can_rx(NetClientState *nc)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    return !(s->regs[rxbase + R_RX_CTRL0] & CTRL_S);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8425, "func": "pvscsi_on_cmd_reset_device(PVSCSIState *s)\n{\n    uint8_t target_lun = 0;\n    struct PVSCSICmdDescResetDevice *cmd =\n        (struct PVSCSICmdDescResetDevice *) s->curr_cmd_data;\n    SCSIDevice *sdev;\n\n    sdev = pvscsi_device_find(s, 0, cmd->target, cmd->lun, &target_lun);\n\n    trace_pvscsi_on_cmd_reset_dev(cmd->target, (int) target_lun, sdev);\n\n    if (sdev != NULL) {\n        s->resetting++;\n        device_reset(&sdev->qdev);\n        s->resetting--;\n        return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n    }\n\n    return PVSCSI_COMMAND_PROCESSING_FAILED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187490, "func": "int sock_recv_all(int sock_fd, uint8_t* buf, int len)\n{\n int r = len;\n\n     int ret = -1;\n     while(r)\n     {\n        do ret = recv(sock_fd, buf, r, MSG_WAITALL);\n         while(ret < 0 && errno == EINTR);\n         if(ret <= 0)\n         {\n            BTIF_TRACE_ERROR(\"sock fd:%d recv errno:%d, ret:%d\", sock_fd, errno, ret);\n return -1;\n }\n        buf += ret;\n        r -= ret;\n }\n return len;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 188590, "func": "  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n #if WRITE_COMPRESSED_STREAM\n     ++out_frames_;\n \n if (pkt->data.frame.pts == 0)\n      write_ivf_file_header(&cfg_, 0, outfile_);\n\n\n     write_ivf_frame_header(pkt, outfile_);\n     (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n#endif\n   }\n", "target": 1, "flaw_line_index": "13"}
{"idx": 187675, "func": "image_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_strip_alpha(pp);\n this->next->set(this->next, that, pp, pi);\n\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9178, "func": "VirtQueue *virtio_add_queue_aio(VirtIODevice *vdev, int queue_size,\n                                VirtIOHandleOutput handle_output)\n{\n    return virtio_add_queue_internal(vdev, queue_size, handle_output, true);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8684, "func": "full_path_write (const struct url *url, char *where)\n{\n#define FROB(el, chr) do {                      \\\n  char *f_el = url->el;                         \\\n  if (f_el) {                                   \\\n    int l = strlen (f_el);                      \\\n    *where++ = chr;                             \\\n    memcpy (where, f_el, l);                    \\\n    where += l;                                 \\\n  }                                             \\\n} while (0)\n\n  FROB (path, '/');\n  FROB (params, ';');\n  FROB (query, '?');\n\n#undef FROB\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9154, "func": "vrend_surface_reference(struct vrend_surface **ptr, struct vrend_surface *surf)\n{\n   struct vrend_surface *old_surf = *ptr;\n\n   if (pipe_reference(&(*ptr)->reference, &surf->reference))\n      vrend_destroy_surface(old_surf);\n   *ptr = surf;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8468, "func": "BOOL CSoundFile::Create(LPCBYTE lpStream, DWORD dwMemLength)\n{\n\tint i;\n\n\tm_nType = MOD_TYPE_NONE;\n\tm_dwSongFlags = 0;\n\tm_nChannels = 0;\n\tm_nMixChannels = 0;\n\tm_nSamples = 0;\n\tm_nInstruments = 0;\n\tm_nFreqFactor = m_nTempoFactor = 128;\n\tm_nMasterVolume = 128;\n\tm_nDefaultGlobalVolume = 256;\n\tm_nGlobalVolume = 256;\n\tm_nOldGlbVolSlide = 0;\n\tm_nDefaultSpeed = 6;\n\tm_nDefaultTempo = 125;\n\tm_nPatternDelay = 0;\n\tm_nFrameDelay = 0;\n\tm_nNextRow = 0;\n\tm_nRow = 0;\n\tm_nPattern = 0;\n\tm_nCurrentPattern = 0;\n\tm_nNextPattern = 0;\n\tm_nRestartPos = 0;\n\tm_nMinPeriod = 16;\n\tm_nMaxPeriod = 32767;\n\tm_nSongPreAmp = 0x30;\n\tm_nPatternNames = 0;\n\tm_nMaxOrderPosition = 0;\n\tm_lpszPatternNames = NULL;\n\tm_lpszSongComments = NULL;\n\tmemset(Ins, 0, sizeof(Ins));\n\tmemset(ChnMix, 0, sizeof(ChnMix));\n\tmemset(Chn, 0, sizeof(Chn));\n\tmemset(Headers, 0, sizeof(Headers));\n\tmemset(Order, 0xFF, sizeof(Order));\n\tmemset(Patterns, 0, sizeof(Patterns));\n\tmemset(m_szNames, 0, sizeof(m_szNames));\n\tmemset(m_MixPlugins, 0, sizeof(m_MixPlugins));\n\tResetMidiCfg();\n\tfor (UINT npt=0; npt<MAX_PATTERNS; npt++) PatternSize[npt] = 64;\n\tfor (UINT nch=0; nch<MAX_BASECHANNELS; nch++)\n\t{\n\t\tChnSettings[nch].nPan = 128;\n\t\tChnSettings[nch].nVolume = 64;\n\t\tChnSettings[nch].dwFlags = 0;\n\t\tChnSettings[nch].szName[0] = 0;\n\t}\n\tif (lpStream)\n\t{\n#ifdef MMCMP_SUPPORT\n\t\tBOOL bMMCmp = MMCMP_Unpack(&lpStream, &dwMemLength);\n#endif\n\t\tif ((!ReadXM(lpStream, dwMemLength))\n\t\t && (!ReadIT(lpStream, dwMemLength))\n\t\t && (!ReadS3M(lpStream, dwMemLength))\n\t\t && (!ReadWav(lpStream, dwMemLength))\n#ifndef MODPLUG_BASIC_SUPPORT\n\t\t && (!ReadSTM(lpStream, dwMemLength))\n\t\t && (!ReadMed(lpStream, dwMemLength))\n\t\t && (!ReadMTM(lpStream, dwMemLength))\n\t\t && (!ReadMDL(lpStream, dwMemLength))\n\t\t && (!ReadDBM(lpStream, dwMemLength))\n\t\t && (!Read669(lpStream, dwMemLength))\n\t\t && (!ReadFAR(lpStream, dwMemLength))\n\t\t && (!ReadAMS(lpStream, dwMemLength))\n\t\t && (!ReadOKT(lpStream, dwMemLength))\n\t\t && (!ReadPTM(lpStream, dwMemLength))\n\t\t && (!ReadUlt(lpStream, dwMemLength))\n\t\t && (!ReadDMF(lpStream, dwMemLength))\n\t\t && (!ReadDSM(lpStream, dwMemLength))\n\t\t && (!ReadUMX(lpStream, dwMemLength))\n\t\t && (!ReadAMF(lpStream, dwMemLength))\n\t\t && (!ReadPSM(lpStream, dwMemLength))\n\t\t && (!ReadMT2(lpStream, dwMemLength))\n#endif \n\t\t && (!ReadMod(lpStream, dwMemLength))) m_nType = MOD_TYPE_NONE;\n#ifdef MMCMP_SUPPORT\n\t\tif (bMMCmp)\n\t\t{\n\t\t\tGlobalFreePtr(lpStream);\n\t\t\tlpStream = NULL;\n\t\t}\n#endif\n\t}\n\tfor (i=0; i<MAX_SAMPLES; i++)\n\t{\n\t\tLPSTR p = m_szNames[i];\n\t\tint j = 31;\n\t\tp[j] = 0;\n\t\twhile ((j>=0) && (p[j]<=' ')) p[j--] = 0;\n\t\twhile (j>=0)\n\t\t{\n\t\t\tif (((BYTE)p[j]) < ' ') p[j] = ' ';\n\t\t\tj--;\n\t\t}\n\t}\n\tfor (i=0; i<MAX_BASECHANNELS; i++)\n\t{\n\t\tif (ChnSettings[i].nVolume > 64) ChnSettings[i].nVolume = 64;\n\t\tif (ChnSettings[i].nPan > 256) ChnSettings[i].nPan = 128;\n\t\tChn[i].nPan = ChnSettings[i].nPan;\n\t\tChn[i].nGlobalVol = ChnSettings[i].nVolume;\n\t\tChn[i].dwFlags = ChnSettings[i].dwFlags;\n\t\tChn[i].nVolume = 256;\n\t\tChn[i].nCutOff = 0x7F;\n\t}\n\tMODINSTRUMENT *pins = Ins;\n\n\tfor (i=0; i<MAX_INSTRUMENTS; i++, pins++)\n\t{\n\t\tif (pins->pSample)\n\t\t{\n\t\t\tif (pins->nLoopEnd > pins->nLength) pins->nLoopEnd = pins->nLength;\n\t\t\tif (pins->nLoopStart + 3 >= pins->nLoopEnd)\n\t\t\t{\n\t\t\t\tpins->nLoopStart = 0;\n\t\t\t\tpins->nLoopEnd = 0;\n\t\t\t}\n\t\t\tif (pins->nSustainEnd > pins->nLength) pins->nSustainEnd = pins->nLength;\n\t\t\tif (pins->nSustainStart + 3 >= pins->nSustainEnd)\n\t\t\t{\n\t\t\t\tpins->nSustainStart = 0;\n\t\t\t\tpins->nSustainEnd = 0;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpins->nLength = 0;\n\t\t\tpins->nLoopStart = 0;\n\t\t\tpins->nLoopEnd = 0;\n\t\t\tpins->nSustainStart = 0;\n\t\t\tpins->nSustainEnd = 0;\n\t\t}\n\t\tif (!pins->nLoopEnd) pins->uFlags &= ~CHN_LOOP;\n\t\tif (!pins->nSustainEnd) pins->uFlags &= ~CHN_SUSTAINLOOP;\n\t\tif (pins->nGlobalVol > 64) pins->nGlobalVol = 64;\n\t}\n\twhile ((m_nInstruments > 0) && (!Headers[m_nInstruments])) m_nInstruments--;\n\tif (m_nSongPreAmp < 0x20) m_nSongPreAmp = 0x20;\n\tif (m_nDefaultTempo < 32) m_nDefaultTempo = 125;\n\tif (!m_nDefaultSpeed) m_nDefaultSpeed = 6;\n\tm_nMusicSpeed = m_nDefaultSpeed;\n\tm_nMusicTempo = m_nDefaultTempo;\n\tm_nGlobalVolume = m_nDefaultGlobalVolume;\n\tm_nNextPattern = 0;\n\tm_nCurrentPattern = 0;\n\tm_nPattern = 0;\n\tm_nBufferCount = 0;\n\tm_nTickCount = m_nMusicSpeed;\n\tm_nNextRow = 0;\n\tm_nRow = 0;\n\tif ((m_nRestartPos >= MAX_ORDERS) || (Order[m_nRestartPos] >= MAX_PATTERNS)) m_nRestartPos = 0;\n\tif (gpMixPluginCreateProc)\n\t{\n\t\tfor (UINT iPlug=0; iPlug<MAX_MIXPLUGINS; iPlug++)\n\t\t{\n\t\t\tif ((m_MixPlugins[iPlug].Info.dwPluginId1)\n\t\t\t || (m_MixPlugins[iPlug].Info.dwPluginId2))\n\t\t\t{\n\t\t\t\tgpMixPluginCreateProc(&m_MixPlugins[iPlug]);\n\t\t\t\tif (m_MixPlugins[iPlug].pMixPlugin)\n\t\t\t\t{\n\t\t\t\t\tm_MixPlugins[iPlug].pMixPlugin->RestoreAllParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (m_nType)\n\t{\n\t\tUINT maxpreamp = 0x10+(m_nChannels*8);\n\t\tif (maxpreamp > 100) maxpreamp = 100;\n\t\tif (m_nSongPreAmp > maxpreamp) m_nSongPreAmp = maxpreamp;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8695, "func": "scheme_disable (enum url_scheme scheme)\n{\n  supported_schemes[scheme].flags |= scm_disabled;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9021, "func": "vmxnet3_msix_save(QEMUFile *f, void *opaque)\n{\n    PCIDevice *d = PCI_DEVICE(opaque);\n    msix_save(d, f);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8361, "func": "static void mptsas_free_request(MPTSASRequest *req)\n{\n    MPTSASState *s = req->dev;\n\n    if (req->sreq != NULL) {\n        req->sreq->hba_private = NULL;\n        scsi_req_unref(req->sreq);\n        req->sreq = NULL;\n        QTAILQ_REMOVE(&s->pending, req, next);\n    }\n    qemu_sglist_destroy(&req->qsg);\n    g_free(req);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187529, "func": " int venc_dev::venc_output_log_buffers(const char *buffer_addr, int buffer_len)\n {\n     if (!m_debug.outfile) {\n         int size = 0;\n         if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_MPEG4) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.m4v\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H264) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.264\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%ld_%ld_%p.265\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H263) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.263\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_VP8) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.ivf\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n }\n if ((size > PROPERTY_VALUE_MAX) && (size < 0)) {\n             DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging size:%d\",\n                                m_debug.outfile_name, size);\n }\n        m_debug.outfile = fopen(m_debug.outfile_name, \"ab\");\n if (!m_debug.outfile) {\n            DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging errno:%d\",\n                               m_debug.outfile_name, errno);\n            m_debug.outfile_name[0] = '\\0';\n return -1;\n }\n }\n if (m_debug.outfile && buffer_len) {\n        DEBUG_PRINT_LOW(\"%s buffer_len:%d\", __func__, buffer_len);\n        fwrite(buffer_addr, buffer_len, 1, m_debug.outfile);\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8601, "func": "static void pci_vmsvga_realize(PCIDevice *dev, Error **errp)\n{\n    struct pci_vmsvga_state_s *s = VMWARE_SVGA(dev);\n\n    dev->config[PCI_CACHE_LINE_SIZE] = 0x08;\n    dev->config[PCI_LATENCY_TIMER] = 0x40;\n    dev->config[PCI_INTERRUPT_LINE] = 0xff;          \n\n    memory_region_init_io(&s->io_bar, NULL, &vmsvga_io_ops, &s->chip,\n                          \"vmsvga-io\", 0x10);\n    memory_region_set_flush_coalesced(&s->io_bar);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->io_bar);\n\n    vmsvga_init(DEVICE(dev), &s->chip,\n                pci_address_space(dev), pci_address_space_io(dev));\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &s->chip.vga.vram);\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &s->chip.fifo_ram);\n\n    if (!dev->rom_bar) {\n        vga_init_vbe(&s->chip.vga, OBJECT(dev), pci_address_space(dev));\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8597, "func": "static int ssh_versioncmp(const char *a, const char *b)\n{\n    char *ae, *be;\n    unsigned long av, bv;\n\n    av = strtoul(a, &ae, 10);\n    bv = strtoul(b, &be, 10);\n    if (av != bv)\n\treturn (av < bv ? -1 : +1);\n    if (*ae == '.')\n\tae++;\n    if (*be == '.')\n\tbe++;\n    av = strtoul(ae, &ae, 10);\n    bv = strtoul(be, &be, 10);\n    if (av != bv)\n\treturn (av < bv ? -1 : +1);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9076, "func": "static void vmxnet3_validate_interrupt_idx(bool is_msix, int idx)\n{\n    int max_ints = is_msix ? VMXNET3_MAX_INTRS : VMXNET3_MAX_NMSIX_INTRS;\n    if (idx >= max_ints) {\n        hw_error(\"Bad interrupt index: %d\\n\", idx);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8553, "func": "static struct Packet *ssh2_rdpkt(Ssh ssh, const unsigned char **data,\n                                 int *datalen)\n{\n    struct rdpkt2_state_tag *st = &ssh->rdpkt2_state;\n\n    crBegin(ssh->ssh2_rdpkt_crstate);\n\n    st->pktin = ssh_new_packet();\n\n    st->pktin->type = 0;\n    st->pktin->length = 0;\n    if (ssh->sccipher)\n\tst->cipherblk = ssh->sccipher->blksize;\n    else\n\tst->cipherblk = 8;\n    if (st->cipherblk < 8)\n\tst->cipherblk = 8;\n    st->maclen = ssh->scmac ? ssh->scmac->len : 0;\n\n    if (ssh->sccipher && (ssh->sccipher->flags & SSH_CIPHER_IS_CBC) &&\n\tssh->scmac && !ssh->scmac_etm) {\n\n\tst->pktin->data = snewn(OUR_V2_PACKETLIMIT + st->maclen + APIEXTRA,\n\t\t\t\tunsigned char);\n\n\tfor (st->i = 0; st->i < st->maclen; st->i++) {\n\t    while ((*datalen) == 0)\n\t\tcrReturn(NULL);\n\t    st->pktin->data[st->i] = *(*data)++;\n\t    (*datalen)--;\n\t}\n\n\tst->packetlen = 0;\n\t{\n\t    unsigned char seq[4];\n\t    ssh->scmac->start(ssh->sc_mac_ctx);\n\t    PUT_32BIT(seq, st->incoming_sequence);\n\t    ssh->scmac->bytes(ssh->sc_mac_ctx, seq, 4);\n\t}\n\n\tfor (;;) { \n\t    for (st->i = 0; st->i < st->cipherblk; st->i++) {\n\t\twhile ((*datalen) == 0)\n\t\t    crReturn(NULL);\n\t\tst->pktin->data[st->packetlen+st->maclen+st->i] = *(*data)++;\n\t\t(*datalen)--;\n\t    }\n\t    ssh->sccipher->decrypt(ssh->sc_cipher_ctx,\n\t\t\t\t   st->pktin->data + st->packetlen,\n\t\t\t\t   st->cipherblk);\n\t    ssh->scmac->bytes(ssh->sc_mac_ctx,\n\t\t\t      st->pktin->data + st->packetlen, st->cipherblk);\n\t    st->packetlen += st->cipherblk;\n\t    if (ssh->scmac->verresult(ssh->sc_mac_ctx,\n\t\t\t\t      st->pktin->data + st->packetlen) &&\n\t\t((st->len = toint(GET_32BIT(st->pktin->data))) ==\n                 st->packetlen-4))\n\t\t    break;\n\t    if (st->packetlen >= OUR_V2_PACKETLIMIT) {\n\t\tbombout((\"No valid incoming packet found\"));\n\t\tssh_free_packet(st->pktin);\n\t\tcrStop(NULL);\n\t    }\t    \n\t}\n\tst->pktin->maxlen = st->packetlen + st->maclen;\n\tst->pktin->data = sresize(st->pktin->data,\n\t\t\t\t  st->pktin->maxlen + APIEXTRA,\n\t\t\t\t  unsigned char);\n    } else if (ssh->scmac && ssh->scmac_etm) {\n\tst->pktin->data = snewn(4 + APIEXTRA, unsigned char);\n\n\tfor (st->i = st->len = 0; st->i < 4; st->i++) {\n\t    while ((*datalen) == 0)\n\t\tcrReturn(NULL);\n\t    st->pktin->data[st->i] = *(*data)++;\n\t    (*datalen)--;\n\t}\n        if (ssh->sccipher && (ssh->sccipher->flags & SSH_CIPHER_SEPARATE_LENGTH)) {\n            unsigned char len[4];\n            memcpy(len, st->pktin->data, 4);\n            ssh->sccipher->decrypt_length(ssh->sc_cipher_ctx, len, 4, st->incoming_sequence);\n            st->len = toint(GET_32BIT(len));\n        } else {\n            st->len = toint(GET_32BIT(st->pktin->data));\n        }\n\n\tif (st->len < 0 || st->len > OUR_V2_PACKETLIMIT ||\n\t    st->len % st->cipherblk != 0) {\n\t    bombout((\"Incoming packet length field was garbled\"));\n\t    ssh_free_packet(st->pktin);\n\t    crStop(NULL);\n\t}\n\n\tst->packetlen = st->len + 4;\n\n\tst->pktin->maxlen = st->packetlen + st->maclen;\n\tst->pktin->data = sresize(st->pktin->data,\n\t\t\t\t  st->pktin->maxlen + APIEXTRA,\n\t\t\t\t  unsigned char);\n\n\tfor (st->i = 4; st->i < st->packetlen + st->maclen; st->i++) {\n\t    while ((*datalen) == 0)\n\t\tcrReturn(NULL);\n\t    st->pktin->data[st->i] = *(*data)++;\n\t    (*datalen)--;\n\t}\n\n\tif (ssh->scmac\n\t    && !ssh->scmac->verify(ssh->sc_mac_ctx, st->pktin->data,\n\t\t\t\t   st->len + 4, st->incoming_sequence)) {\n\t    bombout((\"Incorrect MAC received on packet\"));\n\t    ssh_free_packet(st->pktin);\n\t    crStop(NULL);\n\t}\n\n\tif (ssh->sccipher)\n\t    ssh->sccipher->decrypt(ssh->sc_cipher_ctx,\n\t\t\t\t   st->pktin->data + 4,\n\t\t\t\t   st->packetlen - 4);\n    } else {\n\tst->pktin->data = snewn(st->cipherblk + APIEXTRA, unsigned char);\n\n\tfor (st->i = st->len = 0; st->i < st->cipherblk; st->i++) {\n\t    while ((*datalen) == 0)\n\t\tcrReturn(NULL);\n\t    st->pktin->data[st->i] = *(*data)++;\n\t    (*datalen)--;\n\t}\n\n\tif (ssh->sccipher)\n\t    ssh->sccipher->decrypt(ssh->sc_cipher_ctx,\n\t\t\t\t   st->pktin->data, st->cipherblk);\n\n\tst->len = toint(GET_32BIT(st->pktin->data));\n\n\tif (st->len < 0 || st->len > OUR_V2_PACKETLIMIT ||\n\t    (st->len + 4) % st->cipherblk != 0) {\n\t    bombout((\"Incoming packet was garbled on decryption\"));\n\t    ssh_free_packet(st->pktin);\n\t    crStop(NULL);\n\t}\n\n\tst->packetlen = st->len + 4;\n\n\tst->pktin->maxlen = st->packetlen + st->maclen;\n\tst->pktin->data = sresize(st->pktin->data,\n\t\t\t\t  st->pktin->maxlen + APIEXTRA,\n\t\t\t\t  unsigned char);\n\n\tfor (st->i = st->cipherblk; st->i < st->packetlen + st->maclen;\n\t     st->i++) {\n\t    while ((*datalen) == 0)\n\t\tcrReturn(NULL);\n\t    st->pktin->data[st->i] = *(*data)++;\n\t    (*datalen)--;\n\t}\n\tif (ssh->sccipher)\n\t    ssh->sccipher->decrypt(ssh->sc_cipher_ctx,\n\t\t\t\t   st->pktin->data + st->cipherblk,\n\t\t\t\t   st->packetlen - st->cipherblk);\n\n\tif (ssh->scmac\n\t    && !ssh->scmac->verify(ssh->sc_mac_ctx, st->pktin->data,\n\t\t\t\t   st->len + 4, st->incoming_sequence)) {\n\t    bombout((\"Incorrect MAC received on packet\"));\n\t    ssh_free_packet(st->pktin);\n\t    crStop(NULL);\n\t}\n    }\n    st->pad = st->pktin->data[4];\n    if (st->pad < 4 || st->len - st->pad < 1) {\n\tbombout((\"Invalid padding length on received packet\"));\n\tssh_free_packet(st->pktin);\n\tcrStop(NULL);\n    }\n    st->payload = st->len - st->pad - 1;\n\n    st->pktin->length = st->payload + 5;\n    st->pktin->encrypted_len = st->packetlen;\n\n    st->pktin->sequence = st->incoming_sequence++;\n\n    st->pktin->length = st->packetlen - st->pad;\n    assert(st->pktin->length >= 0);\n\n    {\n\tunsigned char *newpayload;\n\tint newlen;\n\tif (ssh->sccomp &&\n\t    ssh->sccomp->decompress(ssh->sc_comp_ctx,\n\t\t\t\t    st->pktin->data + 5, st->pktin->length - 5,\n\t\t\t\t    &newpayload, &newlen)) {\n\t    if (st->pktin->maxlen < newlen + 5) {\n\t\tst->pktin->maxlen = newlen + 5;\n\t\tst->pktin->data = sresize(st->pktin->data,\n\t\t\t\t\t  st->pktin->maxlen + APIEXTRA,\n\t\t\t\t\t  unsigned char);\n\t    }\n\t    st->pktin->length = 5 + newlen;\n\t    memcpy(st->pktin->data + 5, newpayload, newlen);\n\t    sfree(newpayload);\n\t}\n    }\n\n    if (st->pktin->length <= 5) { \n        ssh2_msg_something_unimplemented(ssh, st->pktin);\n        crStop(NULL);\n    }\n    st->pktin->type = st->pktin->data[5];\n    st->pktin->body = st->pktin->data + 6;\n    st->pktin->length -= 6;\n    assert(st->pktin->length >= 0);    \n\n    if (ssh->logctx)\n        ssh2_log_incoming_packet(ssh, st->pktin);\n\n    st->pktin->savedpos = 0;\n\n    crFinish(st->pktin);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188602, "func": "   virtual void SetUp() {\n    svc_.encoding_mode = INTER_LAYER_PREDICTION_IP;\n     svc_.log_level = SVC_LOG_DEBUG;\n     svc_.log_print = 0;\n \n    codec_iface_ = vpx_codec_vp9_cx();\n const vpx_codec_err_t res =\n        vpx_codec_enc_config_default(codec_iface_, &codec_enc_, 0);\n    EXPECT_EQ(VPX_CODEC_OK, res);\n\n    codec_enc_.g_w = kWidth;\n    codec_enc_.g_h = kHeight;\n    codec_enc_.g_timebase.num = 1;\n    codec_enc_.g_timebase.den = 60;\n\n     codec_enc_.kf_min_dist = 100;\n     codec_enc_.kf_max_dist = 100;\n \n    vpx_codec_dec_cfg_t dec_cfg = {0};\n     VP9CodecFactory codec_factory;\n     decoder_ = codec_factory.CreateDecoder(dec_cfg, 0);\n   }\n", "target": 1, "flaw_line_index": "2,19"}
{"idx": 187397, "func": "status_t SampleTable::setCompositionTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n size_t numEntries = U32_AT(&header[4]);\n\n if (data_size != (numEntries + 1) * 8) {\n return ERROR_MALFORMED;\n\n     }\n \n     mNumCompositionTimeDeltaEntries = numEntries;\n     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n \n     if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n < (ssize_t)numEntries * 8) {\n delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187989, "func": " static uint32_t readU32(const uint8_t* data, size_t offset) {\n    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187741, "func": "read_png(FILE *fp)\n{\n   png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);\n   png_infop info_ptr = NULL;\n   png_bytep row = NULL, display = NULL;\n\n if (png_ptr == NULL)\n return 0;\n\n if (setjmp(png_jmpbuf(png_ptr)))\n {\n      png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n if (row != NULL) free(row);\n if (display != NULL) free(display);\n return 0;\n }\n\n   png_init_io(png_ptr, fp);\n\n   info_ptr = png_create_info_struct(png_ptr);\n if (info_ptr == NULL)\n      png_error(png_ptr, \"OOM allocating info structure\");\n\n   png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_ALWAYS, NULL, 0);\n\n   png_read_info(png_ptr, info_ptr);\n\n\n    {\n       png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n \n       row = malloc(rowbytes);\n       display = malloc(rowbytes);\n \n if (row == NULL || display == NULL)\n         png_error(png_ptr, \"OOM allocating row buffers\");\n\n \n       {\n          png_uint_32 height = png_get_image_height(png_ptr, info_ptr);\n         int passes = png_set_interlace_handling(png_ptr);\n          int pass;\n \n          png_start_read_image(png_ptr);\n\n for (pass = 0; pass < passes; ++pass)\n\n          {\n             png_uint_32 y = height;\n \n while (y-- > 0)\n               png_read_row(png_ptr, row, display);\n }\n }\n }\n\n   png_read_end(png_ptr, info_ptr);\n   png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n   free(row);\n   free(display);\n return 1;\n}\n", "target": 1, "flaw_line_index": "41"}
{"idx": 187863, "func": "long Chapters::Display::Parse(IMkvReader* pReader, long long pos,\n long long size) {\n const long long stop = pos + size;\n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (size == 0) \n continue;\n\n if (id == 0x05) { \n      status = UnserializeString(pReader, pos, size, m_string);\n\n if (status)\n return status;\n } else if (id == 0x037C) { \n      status = UnserializeString(pReader, pos, size, m_language);\n\n if (status)\n return status;\n } else if (id == 0x037E) { \n      status = UnserializeString(pReader, pos, size, m_country);\n\n if (status)\n return status;\n\n     }\n \n     pos += size;\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n   return 0;\n }\n", "target": 1, "flaw_line_index": "35,38"}
{"idx": 187849, "func": "void Cues::Init() const {\n   if (m_cue_points)\n    return;\n \n  assert(m_count == 0);\n  assert(m_preload_count == 0);\n \n   IMkvReader* const pReader = m_pSegment->m_pReader;\n \n const long long stop = m_start + m_size;\n long long pos = m_start;\n\n long cue_points_size = 0;\n\n while (pos < stop) {\n const long long idpos = pos;\n\n \n     long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  \n    assert((pos + len) <= stop);\n \n     pos += len;  \n \n     const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert((pos + len) <= stop);\n \n     pos += len;  \n    assert((pos + size) <= stop);\n \n    if (id == 0x3B)  \n      PreloadCuePoint(cue_points_size, idpos);\n \n    pos += size;  \n    assert(pos <= stop);\n   }\n }\n", "target": 1, "flaw_line_index": "3,5,6,21,22,23,28,29,32,34,35,37,38"}
{"idx": 187471, "func": "static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)\n{\n struct ifreq ifr;\n int sk, err;\n\n    sk = socket(AF_INET, SOCK_DGRAM, 0);\n if (sk < 0)\n return -1;\n\n\n     memset(&ifr, 0, sizeof(ifr));\n     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);\n    err = ioctl(sk, SIOCGIFHWADDR, &ifr);\n     if (err < 0)\n     {\n         BTIF_TRACE_ERROR(\"Could not get network hardware for interface:%s, errno:%s\", devname, strerror(errno));\n        close(sk);\n return -1;\n }\n\n    strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);\n    memcpy(ifr.ifr_hwaddr.sa_data, addr->address, 6);\n\n if (ifr.ifr_hwaddr.sa_data[0] & 0x01) {\n        BTIF_TRACE_WARNING(\"Not a unicast MAC address, force multicast bit flipping\");\n\n         ifr.ifr_hwaddr.sa_data[0] &= ~0x01;\n     }\n \n    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);\n \n     if (err < 0) {\n         BTIF_TRACE_ERROR(\"Could not set bt address for interface:%s, errno:%s\", devname, strerror(errno));\n        close(sk);\n return -1;\n }\n\n    memset(&ifr, 0, sizeof(ifr));\n    strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);\n\n\n     ifr.ifr_flags |= IFF_UP;\n     ifr.ifr_flags |= IFF_MULTICAST;\n \n    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n \n \n     if (err < 0) {\n        BTIF_TRACE_ERROR(\"Could not bring up network interface:%s, errno:%d\", devname, errno);\n        close(sk);\n return -1;\n }\n    close(sk);\n    BTIF_TRACE_DEBUG(\"network interface: %s is up\", devname);\n return 0;\n}\n", "target": 1, "flaw_line_index": "14,31,47"}
{"idx": 188020, "func": " WORD32 ihevcd_ref_list(codec_t *ps_codec, pps_t *ps_pps, sps_t *ps_sps, slice_header_t *ps_slice_hdr)\n {\n    WORD32 i;\n     WORD32 st_rps_idx;\n     WORD32 num_neg_pics, num_pos_pics;\n     WORD8 *pi1_used;\n    WORD16 *pi2_delta_poc;\n    UWORD32 u4_max_poc_lsb;\n pic_buf_t *ps_pic_buf;\n mv_buf_t *ps_mv_buf;\n    UWORD32 r_idx;\n\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;\n\n    WORD32 ai4_poc_st_curr_before[MAX_DPB_SIZE], ai4_poc_st_foll[MAX_DPB_SIZE], ai4_poc_st_curr_after[MAX_DPB_SIZE];\n    WORD32 ai4_poc_lt_curr[MAX_DPB_SIZE], ai4_poc_lt_foll[MAX_DPB_SIZE];\n    UWORD32 u4_num_st_curr_before, u4_num_st_foll, u4_num_st_curr_after, u4_num_lt_curr, u4_num_lt_foll;\n    UWORD32 u4_num_total_curr;\n\n    WORD8 ai1_curr_delta_poc_msb_present_flag[MAX_DPB_SIZE], ai1_foll_delta_poc_msb_present_flag[MAX_DPB_SIZE];\n\n pic_buf_t *as_ref_pic_lt_curr[MAX_DPB_SIZE];\n pic_buf_t *as_ref_pic_lt_foll[MAX_DPB_SIZE];\n pic_buf_t *as_ref_pic_st_curr_after[MAX_DPB_SIZE];\n pic_buf_t *as_ref_pic_st_curr_before[MAX_DPB_SIZE];\n pic_buf_t *as_ref_pic_st_foll[MAX_DPB_SIZE];\n\n pic_buf_t *as_ref_pic_list_temp0[MAX_DPB_SIZE], *as_ref_pic_list_temp1[MAX_DPB_SIZE];\n\n    UWORD32 u4_num_rps_curr_temp_list0, u4_num_rps_curr_temp_list1;\n\n    WORD32 i4_pic_order_cnt_val;\n    WORD32 i4_poc_lt;\n    UNUSED(as_ref_pic_lt_foll);\n    UNUSED(as_ref_pic_st_foll);\n    UNUSED(ps_pps);\n\n    RETURN_IF_NAL_INFO;\n\n    u4_max_poc_lsb = (1 << ps_sps->i1_log2_max_pic_order_cnt_lsb);\n\n    i4_pic_order_cnt_val = ps_slice_hdr->i4_abs_pic_order_cnt;\n\n if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)\n {\n        st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;\n        num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;\n        num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;\n        pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;\n        pi2_delta_poc = ps_sps->as_stref_picset[st_rps_idx].ai2_delta_poc;\n }\n else\n {\n        st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;\n        num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;\n        num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;\n        pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;\n        pi2_delta_poc = ps_slice_hdr->s_stref_picset.ai2_delta_poc;\n }\n\n    u4_num_st_curr_before = 0;\n    u4_num_st_foll = 0;\n for(i = 0; i < num_neg_pics; i++)\n {\n if(pi1_used[i])\n {\n            ai4_poc_st_curr_before[u4_num_st_curr_before] = i4_pic_order_cnt_val + pi2_delta_poc[i];\n            u4_num_st_curr_before++;\n }\n else\n {\n            ai4_poc_st_foll[u4_num_st_foll] = i4_pic_order_cnt_val + pi2_delta_poc[i];\n            u4_num_st_foll++;\n }\n }\n    u4_num_st_curr_after = 0;\n for(i = num_neg_pics; i < num_neg_pics + num_pos_pics; i++)\n {\n if(pi1_used[i])\n {\n            ai4_poc_st_curr_after[u4_num_st_curr_after] = i4_pic_order_cnt_val + pi2_delta_poc[i];\n            u4_num_st_curr_after++;\n }\n else\n {\n            ai4_poc_st_foll[u4_num_st_foll] = i4_pic_order_cnt_val + pi2_delta_poc[i];\n            u4_num_st_foll++;\n }\n }\n\n    u4_num_lt_curr = 0;\n    u4_num_lt_foll = 0;\n for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)\n {\n        i4_poc_lt = ps_slice_hdr->ai4_poc_lsb_lt[i];\n if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])\n {\n            i4_poc_lt += i4_pic_order_cnt_val - ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] * u4_max_poc_lsb - ps_slice_hdr->i4_pic_order_cnt_lsb;\n }\n\n if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])\n {\n            ai4_poc_lt_curr[u4_num_lt_curr] = i4_poc_lt;\n            ai1_curr_delta_poc_msb_present_flag[u4_num_lt_curr] = ps_slice_hdr->ai1_delta_poc_msb_present_flag[i];\n            u4_num_lt_curr++;\n }\n else\n {\n            ai4_poc_lt_foll[u4_num_lt_foll] = i4_poc_lt;\n            ai1_foll_delta_poc_msb_present_flag[u4_num_lt_foll] = ps_slice_hdr->ai1_delta_poc_msb_present_flag[i];\n            u4_num_lt_foll++;\n }\n }\n\n    u4_num_total_curr = u4_num_lt_curr + u4_num_st_curr_after + u4_num_st_curr_before;\n\n\n\n\n if(0 == ps_codec->i4_pic_present)\n {\n for(i = 0; i < MAX_DPB_BUFS; i++)\n {\n if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)\n                ps_dpb_mgr->as_dpb_info[i].ps_pic_buf->u1_used_as_ref = UNUSED_FOR_REF;\n }\n }\n\n for(i = 0; i < (WORD32)u4_num_lt_curr; i++)\n {\n if(0 == ai1_curr_delta_poc_msb_present_flag[i])\n {\n            ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb(ps_dpb_mgr, ai4_poc_lt_curr[i]);\n if(NULL != ps_pic_buf)\n                ps_pic_buf->u1_used_as_ref = LONG_TERM_REF;\n\n            as_ref_pic_lt_curr[i] = ps_pic_buf;\n }\n else\n {\n            ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc(ps_dpb_mgr, ai4_poc_lt_curr[i]);\n if(NULL != ps_pic_buf)\n                ps_pic_buf->u1_used_as_ref = LONG_TERM_REF;\n\n            as_ref_pic_lt_curr[i] = ps_pic_buf;\n }\n }\n\n for(i = 0; i < (WORD32)u4_num_lt_foll; i++)\n {\n if(0 == ai1_foll_delta_poc_msb_present_flag[i])\n {\n            ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb(ps_dpb_mgr, ai4_poc_lt_foll[i]);\n if(NULL != ps_pic_buf)\n                ps_pic_buf->u1_used_as_ref = LONG_TERM_REF;\n\n            as_ref_pic_lt_foll[i] = ps_pic_buf;\n }\n else\n {\n            ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc(ps_dpb_mgr, ai4_poc_lt_foll[i]);\n if(NULL != ps_pic_buf)\n                ps_pic_buf->u1_used_as_ref = LONG_TERM_REF;\n\n            as_ref_pic_lt_foll[i] = ps_pic_buf;\n }\n }\n\n\n for(i = 0; i < (WORD32)u4_num_st_curr_before; i++)\n {\n\n        ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc(ps_dpb_mgr, ai4_poc_st_curr_before[i]);\n if(NULL != ps_pic_buf)\n            ps_pic_buf->u1_used_as_ref = SHORT_TERM_REF;\n\n        as_ref_pic_st_curr_before[i] = ps_pic_buf;\n }\n\n for(i = 0; i < (WORD32)u4_num_st_curr_after; i++)\n {\n        ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc(ps_dpb_mgr, ai4_poc_st_curr_after[i]);\n if(NULL != ps_pic_buf)\n            ps_pic_buf->u1_used_as_ref = SHORT_TERM_REF;\n\n        as_ref_pic_st_curr_after[i] = ps_pic_buf;\n }\n\n for(i = 0; i < (WORD32)u4_num_st_foll; i++)\n {\n        ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc(ps_dpb_mgr, ai4_poc_st_foll[i]);\n if(NULL != ps_pic_buf)\n            ps_pic_buf->u1_used_as_ref = SHORT_TERM_REF;\n\n        as_ref_pic_st_foll[i] = ps_pic_buf;\n }\n\n\n    u4_num_rps_curr_temp_list0 = (WORD32)u4_num_total_curr > ps_slice_hdr->i1_num_ref_idx_l0_active ? (WORD32)u4_num_total_curr : ps_slice_hdr->i1_num_ref_idx_l0_active;\n\n    r_idx = 0;\n if((PSLICE == ps_slice_hdr->i1_slice_type) ||\n (BSLICE == ps_slice_hdr->i1_slice_type))\n {\n while(r_idx < u4_num_rps_curr_temp_list0)\n {\n for(i = 0; (i < (WORD32)u4_num_st_curr_before) && (r_idx < u4_num_rps_curr_temp_list0); r_idx++, i++)\n {\n if(NULL == as_ref_pic_st_curr_before[i])\n {\n                    as_ref_pic_st_curr_before[i] = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ai4_poc_st_curr_before[i]);\n }\n                as_ref_pic_list_temp0[r_idx] = as_ref_pic_st_curr_before[i];\n }\n\n for(i = 0; (i < (WORD32)u4_num_st_curr_after) && (r_idx < u4_num_rps_curr_temp_list0); r_idx++, i++)\n {\n if(NULL == as_ref_pic_st_curr_after[i])\n {\n                    as_ref_pic_st_curr_after[i] = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ai4_poc_st_curr_after[i]);\n }\n                as_ref_pic_list_temp0[r_idx] = as_ref_pic_st_curr_after[i];\n }\n\n for(i = 0; (i < (WORD32)u4_num_lt_curr) && (r_idx < u4_num_rps_curr_temp_list0); r_idx++, i++)\n {\n if(NULL == as_ref_pic_lt_curr[i])\n {\n                    as_ref_pic_lt_curr[i] = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ai4_poc_lt_curr[i]);\n }\n                as_ref_pic_list_temp0[r_idx] = as_ref_pic_lt_curr[i];\n }\n }\n\n for(r_idx = 0; (WORD32)r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)\n {\n pic_buf_t *ps_pic_buf;\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 ? (void *)as_ref_pic_list_temp0[ps_slice_hdr->s_rplm.i1_list_entry_l0[r_idx]] : (void *)as_ref_pic_list_temp0[r_idx];\n            ps_pic_buf = (pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf;\n\n if(ps_pic_buf == NULL)\n return IHEVCD_REF_PIC_NOT_FOUND;\n\n            ps_mv_buf = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf->i4_abs_poc);\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = ps_mv_buf;\n }\n\n\n if(ps_slice_hdr->i1_slice_type  == BSLICE)\n {\n            u4_num_rps_curr_temp_list1 = (WORD32)u4_num_total_curr > ps_slice_hdr->i1_num_ref_idx_l1_active ? (WORD32)u4_num_total_curr : ps_slice_hdr->i1_num_ref_idx_l1_active;\n\n            r_idx = 0;\n while(r_idx < u4_num_rps_curr_temp_list1)\n {\n for(i = 0; (i < (WORD32)u4_num_st_curr_after) && (r_idx < u4_num_rps_curr_temp_list1); r_idx++, i++)\n {\n if(NULL == as_ref_pic_st_curr_after[i])\n {\n                        as_ref_pic_st_curr_after[i] = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ai4_poc_st_curr_after[i]);\n }\n                    as_ref_pic_list_temp1[r_idx] = as_ref_pic_st_curr_after[i];\n }\n\n for(i = 0; (i < (WORD32)u4_num_st_curr_before) && (r_idx < u4_num_rps_curr_temp_list1); r_idx++, i++)\n {\n if(NULL == as_ref_pic_st_curr_before[i])\n {\n                        as_ref_pic_st_curr_before[i] = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ai4_poc_st_curr_before[i]);\n }\n                    as_ref_pic_list_temp1[r_idx] = as_ref_pic_st_curr_before[i];\n }\n\n for(i = 0; (i < (WORD32)u4_num_lt_curr) && (r_idx < u4_num_rps_curr_temp_list1); r_idx++, i++)\n {\n if(NULL == as_ref_pic_lt_curr[i])\n {\n                        as_ref_pic_lt_curr[i] = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ai4_poc_lt_curr[i]);\n }\n                    as_ref_pic_list_temp1[r_idx] = as_ref_pic_lt_curr[i];\n }\n }\n\n for(r_idx = 0; (WORD32)r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)\n {\n pic_buf_t *ps_pic_buf;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 ? (void *)as_ref_pic_list_temp1[ps_slice_hdr->s_rplm.i1_list_entry_l1[r_idx]] : (void *)as_ref_pic_list_temp1[r_idx];\n                ps_pic_buf = (pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf;\n\n if(ps_pic_buf == NULL)\n return IHEVCD_REF_PIC_NOT_FOUND;\n\n                ps_mv_buf = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf->i4_abs_poc);\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = ps_mv_buf;\n }\n }\n }\n\n    DEBUG_PRINT_REF_LIST_POCS(i4_pic_order_cnt_val, ps_slice_hdr, ps_dpb_mgr, u4_num_st_curr_before, u4_num_st_curr_after, u4_num_st_foll, u4_num_lt_curr, u4_num_lt_foll, ai4_poc_st_curr_before, ai4_poc_st_curr_after, ai4_poc_st_foll, ai4_poc_lt_curr, ai4_poc_lt_foll);\n for(i = 0; i < MAX_DPB_BUFS; i++)\n {\n if((ps_dpb_mgr->as_dpb_info[i].ps_pic_buf) && (UNUSED_FOR_REF == ps_dpb_mgr->as_dpb_info[i].ps_pic_buf->u1_used_as_ref))\n {\n pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;\n mv_buf_t *ps_mv_buf;\n\n            ihevc_dpb_mgr_del_ref(ps_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);\n\n\n \n             ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;\n            for(i = 0; i < BUF_MGR_MAX_CNT; i++)\n             {\n                 if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)\n                 {\n                    ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, i, BUF_MGR_REF);\n                     break;\n                 }\n                 ps_mv_buf++;\n }\n }\n\n }\n\n return IHEVCD_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "3,314,318"}
{"idx": 188245, "func": "OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()) {\n                 return OMX_ErrorBadPortIndex;\n             }\n if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUnsupportedSetting;\n }\n\n PortInfo *port =\n &mPorts.editItemAt(defParams->nPortIndex);\n\n if (defParams->nBufferSize > port->mDef.nBufferSize) {\n                port->mDef.nBufferSize = defParams->nBufferSize;\n }\n\n if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {\n                ALOGW(\"component requires at least %u buffers (%u requested)\",\n                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);\n return OMX_ErrorUnsupportedSetting;\n }\n\n            port->mDef.nBufferCountActual = defParams->nBufferCountActual;\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8748, "func": "vcard_response_new_status_bytes(unsigned char sw1, unsigned char sw2)\n{\n    VCardResponse *new_response;\n\n    new_response = g_new(VCardResponse, 1);\n    new_response->b_data = &new_response->b_sw1;\n    new_response->b_len = 0;\n    new_response->b_total_len = 2;\n    new_response->b_type = VCARD_MALLOC_STRUCT;\n    vcard_response_set_status_bytes(new_response, sw1, sw2);\n    return new_response;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188177, "func": "bool SoftVPX::outputBuffers(bool flushDecoder, bool display, bool eos, bool *portWillReset) {\n List<BufferInfo *> &outQueue = getPortQueue(1);\n BufferInfo *outInfo = NULL;\n    OMX_BUFFERHEADERTYPE *outHeader = NULL;\n vpx_codec_iter_t iter = NULL;\n\n if (flushDecoder && mFrameParallelMode) {\n if (vpx_codec_decode((vpx_codec_ctx_t *)mCtx, NULL, 0, NULL, 0)) {\n            ALOGE(\"Failed to flush on2 decoder.\");\n return false;\n }\n }\n\n if (!display) {\n if (!flushDecoder) {\n            ALOGE(\"Invalid operation.\");\n return false;\n }\n while ((mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter))) {\n }\n return true;\n }\n\n while (!outQueue.empty()) {\n if (mImg == NULL) {\n            mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);\n if (mImg == NULL) {\n break;\n }\n }\n uint32_t width = mImg->d_w;\n uint32_t height = mImg->d_h;\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        CHECK_EQ(mImg->fmt, VPX_IMG_FMT_I420);\n        handlePortSettingsChange(portWillReset, width, height);\n if (*portWillReset) {\n return true;\n }\n\n        outHeader->nOffset = 0;\n\n         outHeader->nFlags = 0;\n         outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n         outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv;\n        if (outHeader->nAllocLen >= outHeader->nFilledLen) {\n             uint8_t *dst = outHeader->pBuffer;\n             const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];\n             const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];\n const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V];\n size_t srcYStride = mImg->stride[VPX_PLANE_Y];\n size_t srcUStride = mImg->stride[VPX_PLANE_U];\n\n             size_t srcVStride = mImg->stride[VPX_PLANE_V];\n             copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);\n         } else {\n            ALOGE(\"b/27597103, buffer too small\");\n            android_errorWriteLog(0x534e4554, \"27597103\");\n             outHeader->nFilledLen = 0;\n         }\n \n        mImg = NULL;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n\n if (!eos) {\n return true;\n }\n\n if (!outQueue.empty()) {\n        outInfo = *outQueue.begin();\n        outQueue.erase(outQueue.begin());\n        outHeader = outInfo->mHeader;\n        outHeader->nTimeStamp = 0;\n        outHeader->nFilledLen = 0;\n        outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n        outInfo->mOwnedByUs = false;\n        notifyFillBufferDone(outHeader);\n        mEOSStatus = OUTPUT_FRAMES_FLUSHED;\n }\n\n     return true;\n }\n", "target": 1, "flaw_line_index": "49,60,61"}
{"idx": 188611, "func": "   virtual void SetUp() {\n    const tuple<int, int, VarianceFunctionType>& params = this->GetParam();\n     log2width_  = get<0>(params);\n     width_ = 1 << log2width_;\n     log2height_ = get<1>(params);\n     height_ = 1 << log2height_;\n     variance_ = get<2>(params);\n \n    rnd(ACMRandom::DeterministicSeed());\n     block_size_ = width_ * height_;\n    src_ = new uint8_t[block_size_];\n    ref_ = new uint8_t[block_size_];\n     ASSERT_TRUE(src_ != NULL);\n     ASSERT_TRUE(ref_ != NULL);\n   }\n", "target": 1, "flaw_line_index": "2,9,11,12"}
{"idx": 187344, "func": "xsltCopyOf(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t           xmlNodePtr inst, xsltStylePreCompPtr castedComp) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemCopyOfPtr comp = (xsltStyleItemCopyOfPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n     xmlXPathObjectPtr res = NULL;\n     xmlNodeSetPtr list = NULL;\n     int i;\n    xmlDocPtr oldXPContextDoc;\n    xmlNsPtr *oldXPNamespaces;\n    xmlNodePtr oldXPContextNode;\n    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n    xmlXPathContextPtr xpctxt;\n \n     if ((ctxt == NULL) || (node == NULL) || (inst == NULL))\n \treturn;\n    if ((comp == NULL) || (comp->select == NULL) || (comp->comp == NULL)) {\n\txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:copy-of : compilation failed\\n\");\n\treturn;\n    }\n\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n\t \"xsltCopyOf: select %s\\n\", comp->select));\n#endif\n\n    xpctxt = ctxt->xpathCtxt;\n    oldXPContextDoc = xpctxt->doc;\n    oldXPContextNode = xpctxt->node;\n    oldXPProximityPosition = xpctxt->proximityPosition;\n    oldXPContextSize = xpctxt->contextSize;\n    oldXPNsNr = xpctxt->nsNr;\n    oldXPNamespaces = xpctxt->namespaces;\n    xpctxt->node = node;\n    if (comp != NULL) {\n#ifdef XSLT_REFACTORED\n\tif (comp->inScopeNs != NULL) {\n\t    xpctxt->namespaces = comp->inScopeNs->list;\n\t    xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n\t} else {\n\t    xpctxt->namespaces = NULL;\n\t    xpctxt->nsNr = 0;\n\t}\n#else\n\txpctxt->namespaces = comp->nsList;\n\txpctxt->nsNr = comp->nsNr;\n#endif\n    } else {\n\txpctxt->namespaces = NULL;\n\txpctxt->nsNr = 0;\n    }\n    res = xmlXPathCompiledEval(comp->comp, xpctxt);\n    xpctxt->doc = oldXPContextDoc;\n    xpctxt->node = oldXPContextNode;\n    xpctxt->contextSize = oldXPContextSize;\n    xpctxt->proximityPosition = oldXPProximityPosition;\n    xpctxt->nsNr = oldXPNsNr;\n    xpctxt->namespaces = oldXPNamespaces;\n \n     if (res != NULL) {\n \tif (res->type == XPATH_NODESET) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n\t\t \"xsltCopyOf: result is a node set\\n\"));\n#endif\n\t    list = res->nodesetval;\n\t    if (list != NULL) {\n\t\txmlNodePtr cur;\n\t\tfor (i = 0;i < list->nodeNr;i++) {\n\t\t    cur = list->nodeTab[i];\n\t\t    if (cur == NULL)\n\t\t\tcontinue;\n\t\t    if ((cur->type == XML_DOCUMENT_NODE) ||\n\t\t\t(cur->type == XML_HTML_DOCUMENT_NODE))\n\t\t    {\n\t\t\txsltCopyTreeList(ctxt, inst,\n\t\t\t    cur->children, ctxt->insert, 0, 0);\n\t\t    } else if (cur->type == XML_ATTRIBUTE_NODE) {\n\t\t\txsltShallowCopyAttr(ctxt, inst,\n\t\t\t    ctxt->insert, (xmlAttrPtr) cur);\n\t\t    } else {\n\t\t\txsltCopyTreeInternal(ctxt, inst,\n\t\t\t    cur, ctxt->insert, 0, 0);\n\t\t    }\n\t\t}\n\t    }\n\t} else if (res->type == XPATH_XSLT_TREE) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n\t\t \"xsltCopyOf: result is a result tree fragment\\n\"));\n#endif\n\t    list = res->nodesetval;\n\t    if ((list != NULL) && (list->nodeTab != NULL) &&\n\t\t(list->nodeTab[0] != NULL) &&\n\t\t(IS_XSLT_REAL_NODE(list->nodeTab[0])))\n\t    {\n\t\txsltCopyTreeList(ctxt, inst,\n\t\t    list->nodeTab[0]->children, ctxt->insert, 0, 0);\n\t    }\n\t} else {\n\t    xmlChar *value = NULL;\n\t    value = xmlXPathCastToString(res);\n\t    if (value == NULL) {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t    \"Internal error in xsltCopyOf(): \"\n\t\t    \"failed to cast an XPath object to string.\\n\");\n\t\tctxt->state = XSLT_STATE_STOPPED;\n\t    } else {\n\t\tif (value[0] != 0) {\n\t\t    xsltCopyTextString(ctxt, ctxt->insert, value, 0);\n\t\t}\n\t\txmlFree(value);\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\tXSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n\t\t    \"xsltCopyOf: result %s\\n\", res->stringval));\n#endif\n\t    }\n\t}\n    } else {\n\tctxt->state = XSLT_STATE_STOPPED;\n    }\n\n    if (res != NULL)\n\txmlXPathFreeObject(res);\n}\n", "target": 1, "flaw_line_index": "11,12,13,14,15,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62"}
{"idx": 188624, "func": "void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n const EAS_I8 *pLoopEnd;\n const EAS_I8 *pCurrentPhaseInt;\n    EAS_I32 numSamples;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 currentPhaseFrac;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I8 *pLoopStart;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n\n    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n    pCurrentPhaseInt = pWTVoice->pPhaseAccum;\n    currentPhaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->phaseIncrement;\n\n    pLoopStart = pWTVoice->pLoopStart;\n    pLoopEnd = pWTVoice->pLoopEnd + 1;\n\nInterpolationLoop:\n    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);\n if (tmp0 >= 0)\n        pCurrentPhaseInt = pLoopStart + tmp0;\n\n    tmp0 = *pCurrentPhaseInt;\n    tmp1 = *(pCurrentPhaseInt + 1);\n\n    tmp2 = phaseInc + currentPhaseFrac;\n\n    tmp1 = tmp1 - tmp0;\n    tmp1 = tmp1 * currentPhaseFrac;\n\n    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);\n\n    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);\n    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;\n\n    gain += gainIncrement;\n    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n\n    tmp0 = *pMixBuffer;\n    tmp2 = tmp1 * tmp2;\n    tmp2 = (tmp2 >> 9);\n    tmp0 = tmp2 + tmp0;\n *pMixBuffer++ = tmp0;\n\n    numSamples--;\n if (numSamples > 0)\n goto InterpolationLoop;\n\n    pWTVoice->pPhaseAccum = pCurrentPhaseInt;\n    pWTVoice->phaseFrac = currentPhaseFrac;\n    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9224, "func": "hwaddr virtio_queue_get_used_size(VirtIODevice *vdev, int n)\n{\n    return offsetof(VRingUsed, ring) +\n        sizeof(VRingUsedElem) * vdev->vq[n].vring.num;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9062, "func": "static void vmxnet3_set_link_status(NetClientState *nc)\n{\n    VMXNET3State *s = qemu_get_nic_opaque(nc);\n\n    if (nc->link_down) {\n        s->link_status_and_speed &= ~VMXNET3_LINK_STATUS_UP;\n    } else {\n        s->link_status_and_speed |= VMXNET3_LINK_STATUS_UP;\n    }\n\n    vmxnet3_set_events(s, VMXNET3_ECR_LINK);\n    vmxnet3_trigger_interrupt(s, s->event_int_idx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8505, "func": "static void bomb_out(Ssh ssh, char *text)\n{\n    ssh_do_close(ssh, FALSE);\n    logevent(text);\n    connection_fatal(ssh->frontend, \"%s\", text);\n    sfree(text);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9013, "func": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n{\n    VMXNET3State *s = opaque;\n\n    if (!s->device_active) {\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                        VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n        int tx_queue_idx =\n            VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_TXPROD,\n                                     VMXNET3_REG_ALIGN);\n        assert(tx_queue_idx <= s->txq_num);\n        vmxnet3_process_tx_queue(s, tx_queue_idx);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8806, "func": "static struct vrend_linked_shader_program *lookup_shader_program(struct vrend_context *ctx,\n                                                                 GLuint vs_id, GLuint fs_id, GLuint gs_id, bool dual_src)\n{\n   struct vrend_linked_shader_program *ent;\n   LIST_FOR_EACH_ENTRY(ent, &ctx->sub->programs, head) {\n      if (ent->dual_src_linked != dual_src)\n         continue;\n      if (ent->ss[PIPE_SHADER_VERTEX]->id == vs_id && ent->ss[PIPE_SHADER_FRAGMENT]->id == fs_id) {\n         if (!ent->ss[PIPE_SHADER_GEOMETRY] && gs_id == 0)\n            return ent;\n         if (ent->ss[PIPE_SHADER_GEOMETRY] && ent->ss[PIPE_SHADER_GEOMETRY]->id == gs_id)\n            return ent;\n      }\n   }\n   return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187518, "func": "static void uipc_check_interrupt_locked(void)\n{\n if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))\n\n     {\n         char sig_recv = 0;\n        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);\n     }\n }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 8436, "func": "pvscsi_process_request_descriptor(PVSCSIState *s,\n                                  struct PVSCSIRingReqDesc *descr)\n{\n    SCSIDevice *d;\n    PVSCSIRequest *r = pvscsi_queue_pending_descriptor(s, &d, descr);\n    int64_t n;\n\n    trace_pvscsi_process_req_descr(descr->cdb[0], descr->context);\n\n    if (!d) {\n        r->cmp.hostStatus = BTSTAT_SELTIMEO;\n        trace_pvscsi_process_req_descr_unknown_device();\n        pvscsi_complete_request(s, r);\n        return;\n    }\n\n    if (descr->flags & PVSCSI_FLAG_CMD_WITH_SG_LIST) {\n        r->sg.elemAddr = descr->dataAddr;\n    }\n\n    r->sreq = scsi_req_new(d, descr->context, r->lun, descr->cdb, r);\n    if (r->sreq->cmd.mode == SCSI_XFER_FROM_DEV &&\n        (descr->flags & PVSCSI_FLAG_CMD_DIR_TODEVICE)) {\n        r->cmp.hostStatus = BTSTAT_BADMSG;\n        trace_pvscsi_process_req_descr_invalid_dir();\n        scsi_req_cancel(r->sreq);\n        return;\n    }\n    if (r->sreq->cmd.mode == SCSI_XFER_TO_DEV &&\n        (descr->flags & PVSCSI_FLAG_CMD_DIR_TOHOST)) {\n        r->cmp.hostStatus = BTSTAT_BADMSG;\n        trace_pvscsi_process_req_descr_invalid_dir();\n        scsi_req_cancel(r->sreq);\n        return;\n    }\n\n    pvscsi_build_sglist(s, r);\n    n = scsi_req_enqueue(r->sreq);\n\n    if (n) {\n        scsi_req_continue(r->sreq);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187456, "func": "void bta_hl_co_put_rx_data (UINT8 app_id, tBTA_HL_MDL_HANDLE mdl_handle,\n                            UINT16 data_size, UINT8 *p_data, UINT16 evt)\n{\n    UINT8 app_idx, mcl_idx, mdl_idx;\n btif_hl_mdl_cb_t *p_dcb;\n    tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL;\n int            r;\n    BTIF_TRACE_DEBUG(\"%s app_id=%d mdl_handle=0x%x data_size=%d\",\n                      __FUNCTION__,app_id, mdl_handle, data_size);\n\n if (btif_hl_find_mdl_idx_using_handle(mdl_handle, &app_idx, &mcl_idx, &mdl_idx))\n {\n        p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);\n\n if ((p_dcb->p_rx_pkt = (UINT8 *)btif_hl_get_buf(data_size)) != NULL)\n {\n            memcpy(p_dcb->p_rx_pkt, p_data, data_size);\n if (p_dcb->p_scb)\n\n             {\n                 BTIF_TRACE_DEBUG(\"app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d\",\n                                   app_idx, mcl_idx, mdl_idx, data_size);\n                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);\n \n                 if (r == data_size)\n                 {\n                    BTIF_TRACE_DEBUG(\"socket send success data_size=%d\",  data_size);\n                    status = BTA_HL_STATUS_OK;\n }\n else\n {\n                    BTIF_TRACE_ERROR(\"socket send failed r=%d data_size=%d\",r, data_size);\n }\n\n\n }\n            btif_hl_free_buf((void **) &p_dcb->p_rx_pkt);\n }\n }\n\n    bta_hl_ci_put_rx_data(mdl_handle,  status, evt);\n}\n", "target": 1, "flaw_line_index": "23"}
{"idx": 188178, "func": " void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187477, "func": "int bta_co_rfc_data_outgoing(void *user_data, uint8_t *buf, uint16_t size) {\n  pthread_mutex_lock(&slot_lock);\n\n uint32_t id = (uintptr_t)user_data;\n int ret = false;\n rfc_slot_t *slot = find_rfc_slot_by_id(id);\n\n   if (!slot)\n     goto out;\n \n  int received = recv(slot->fd, buf, size, 0);\n   if(received == size) {\n     ret = true;\n   } else {\n    LOG_ERROR(\"%s error receiving RFCOMM data from app: %s\", __func__, strerror(errno));\n    cleanup_rfc_slot(slot);\n }\n\nout:;\n  pthread_mutex_unlock(&slot_lock);\n return ret;\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 8701, "func": "test_append_uri_pathel(void)\n{\n  unsigned i;\n  static const struct {\n    const char *original_url;\n    const char *input;\n    bool escaped;\n    const char *expected_result;\n  } test_array[] = {\n    { \"http:\n  };\n\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      struct growable dest;\n      const char *p = test_array[i].input;\n\n      memset (&dest, 0, sizeof (dest));\n\n      append_string (test_array[i].original_url, &dest);\n      append_uri_pathel (p, p + strlen(p), test_array[i].escaped, &dest);\n\n      mu_assert (\"test_append_uri_pathel: wrong result\",\n                 strcmp (dest.base, test_array[i].expected_result) == 0);\n      xfree (dest.base);\n    }\n\n  return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188010, "func": " long vorbis_book_decodevs_add(codebook *book,ogg_int32_t *a,\n\t\t\t      oggpack_buffer *b,int n,int point){\n   if(book->used_entries>0){\n     int step=n/book->dim;\n     ogg_int32_t *v = book->dec_buf;\n int i,j,o;\n if (!v) return -1;\n\n\n     for (j=0;j<step;j++){\n       if(decode_map(book,b,v,point))return -1;\n       for(i=0,o=j;i<book->dim;i++,o+=step)\n\ta[o]+=v[i];\n     }\n   }\n   return 0;\n }\n", "target": 1, "flaw_line_index": "2,13"}
{"idx": 8631, "func": "static void xilinx_ethlite_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    dc->realize = xilinx_ethlite_realize;\n    dc->reset = xilinx_ethlite_reset;\n    dc->props = xilinx_ethlite_properties;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188202, "func": "void SoftAVC::setDecodeArgs(\n         ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n        OMX_BUFFERHEADERTYPE *outHeader,\n\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer =\n            inHeader->pBuffer + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY / 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n", "target": 1, "flaw_line_index": "10,29,30,31,32,33,43"}
{"idx": 8773, "func": "static int raw_bcast_from_client_config_ifindex(struct dhcp_packet *packet, uint32_t src_nip)\n{\n\treturn udhcp_send_raw_packet(packet,\n src_nip, CLIENT_PORT,\n INADDR_BROADCAST, SERVER_PORT, MAC_BCAST_ADDR,\n\t\tclient_config.ifindex);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8651, "func": "size_t mptsas_config_manufacturing_3(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n    return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"wb*b*l\",\n                              pcic->device_id, pcic->revision);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187487, "func": "static int process_cmd_sock(int h)\n\n {\n     sock_cmd_t cmd = {-1, 0, 0, 0, 0};\n     int fd = ts[h].cmd_fdr;\n    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))\n     {\n         APPL_TRACE_ERROR(\"recv cmd errno:%d\", errno);\n         return FALSE;\n }\n    APPL_TRACE_DEBUG(\"cmd.id:%d\", cmd.id);\n switch(cmd.id)\n {\n case CMD_ADD_FD:\n            add_poll(h, cmd.fd, cmd.type, cmd.flags, cmd.user_id);\n break;\n case CMD_REMOVE_FD:\n for (int i = 1; i < MAX_POLL; ++i)\n {\n poll_slot_t *poll_slot = &ts[h].ps[i];\n if (poll_slot->pfd.fd == cmd.fd)\n {\n                    remove_poll(h, poll_slot, poll_slot->flags);\n break;\n }\n }\n            close(cmd.fd);\n break;\n case CMD_WAKEUP:\n break;\n case CMD_USER_PRIVATE:\n            asrt(ts[h].cmd_callback);\n if(ts[h].cmd_callback)\n                ts[h].cmd_callback(fd, cmd.type, cmd.flags, cmd.user_id);\n break;\n case CMD_EXIT:\n return FALSE;\n default:\n            APPL_TRACE_DEBUG(\"unknown cmd: %d\", cmd.id);\n break;\n }\n return TRUE;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 188251, "func": "long ParseElementHeader(IMkvReader* pReader, long long& pos,\n long long stop, long long& id,\n long long& size) {\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n long len;\n\n  id = ReadID(pReader, pos, len);\n\n if (id < 0)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; \n\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n  size = ReadUInt(pReader, pos, len);\n\n if (size < 0 || len < 1 || len > 8) {\n return E_FILE_FORMAT_INVALID;\n }\n\n const unsigned long long rollover_check =\n static_cast<unsigned long long>(pos) + len;\n if (rollover_check > LONG_LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; \n\n \n \n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n \n   return 0;  \n}\n", "target": 1, "flaw_line_index": "38"}
{"idx": 9091, "func": "int vrend_decode_block(uint32_t ctx_id, uint32_t *block, int ndw)\n{\n   struct vrend_decode_ctx *gdctx;\n   bool bret;\n   int ret;\n   if (ctx_id >= VREND_MAX_CTX)\n      return EINVAL;\n\n   if (dec_ctx[ctx_id] == NULL)\n      return EINVAL;\n\n   gdctx = dec_ctx[ctx_id];\n\n   bret = vrend_hw_switch_context(gdctx->grctx, true);\n   if (bret == false)\n      return EINVAL;\n\n   gdctx->ds->buf = block;\n   gdctx->ds->buf_total = ndw;\n   gdctx->ds->buf_offset = 0;\n\n   while (gdctx->ds->buf_offset < gdctx->ds->buf_total) {\n      uint32_t header = gdctx->ds->buf[gdctx->ds->buf_offset];\n      uint32_t len = header >> 16;\n\n      ret = 0;\n      if (gdctx->ds->buf_offset + len + 1 > gdctx->ds->buf_total) {\n         vrend_report_buffer_error(gdctx->grctx, 0);\n         break;\n      }\n\n      switch (header & 0xff) {\n      case VIRGL_CCMD_CREATE_OBJECT:\n         ret = vrend_decode_create_object(gdctx, len);\n         break;\n      case VIRGL_CCMD_BIND_OBJECT:\n         ret = vrend_decode_bind_object(gdctx, len);\n         break;\n      case VIRGL_CCMD_DESTROY_OBJECT:\n         ret = vrend_decode_destroy_object(gdctx, len);\n         break;\n      case VIRGL_CCMD_CLEAR:\n         ret = vrend_decode_clear(gdctx, len);\n         break;\n      case VIRGL_CCMD_DRAW_VBO:\n         ret = vrend_decode_draw_vbo(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_FRAMEBUFFER_STATE:\n         ret = vrend_decode_set_framebuffer_state(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_VERTEX_BUFFERS:\n         ret = vrend_decode_set_vertex_buffers(gdctx, len);\n         break;\n      case VIRGL_CCMD_RESOURCE_INLINE_WRITE:\n         ret = vrend_decode_resource_inline_write(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_VIEWPORT_STATE:\n         ret = vrend_decode_set_viewport_state(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_SAMPLER_VIEWS:\n         ret = vrend_decode_set_sampler_views(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_INDEX_BUFFER:\n         ret = vrend_decode_set_index_buffer(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_CONSTANT_BUFFER:\n         ret = vrend_decode_set_constant_buffer(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_STENCIL_REF:\n         ret = vrend_decode_set_stencil_ref(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_BLEND_COLOR:\n         ret = vrend_decode_set_blend_color(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_SCISSOR_STATE:\n         ret = vrend_decode_set_scissor_state(gdctx, len);\n         break;\n      case VIRGL_CCMD_BLIT:\n         ret = vrend_decode_blit(gdctx, len);\n         break;\n      case VIRGL_CCMD_RESOURCE_COPY_REGION:\n         ret = vrend_decode_resource_copy_region(gdctx, len);\n         break;\n      case VIRGL_CCMD_BIND_SAMPLER_STATES:\n         ret = vrend_decode_bind_sampler_states(gdctx, len);\n         break;\n      case VIRGL_CCMD_BEGIN_QUERY:\n         ret = vrend_decode_begin_query(gdctx, len);\n         break;\n      case VIRGL_CCMD_END_QUERY:\n         ret = vrend_decode_end_query(gdctx, len);\n         break;\n      case VIRGL_CCMD_GET_QUERY_RESULT:\n         ret = vrend_decode_get_query_result(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_POLYGON_STIPPLE:\n         ret = vrend_decode_set_polygon_stipple(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_CLIP_STATE:\n         ret = vrend_decode_set_clip_state(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_SAMPLE_MASK:\n         ret = vrend_decode_set_sample_mask(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_STREAMOUT_TARGETS:\n         ret = vrend_decode_set_streamout_targets(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_RENDER_CONDITION:\n         ret = vrend_decode_set_render_condition(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_UNIFORM_BUFFER:\n         ret = vrend_decode_set_uniform_buffer(gdctx, len);\n         break;\n      case VIRGL_CCMD_SET_SUB_CTX:\n         ret = vrend_decode_set_sub_ctx(gdctx, len);\n         break;\n      case VIRGL_CCMD_CREATE_SUB_CTX:\n         ret = vrend_decode_create_sub_ctx(gdctx, len);\n         break;\n      case VIRGL_CCMD_DESTROY_SUB_CTX:\n         ret = vrend_decode_destroy_sub_ctx(gdctx, len);\n         break;\n      case VIRGL_CCMD_BIND_SHADER:\n         ret = vrend_decode_bind_shader(gdctx, len);\n         break;\n      default:\n         ret = EINVAL;\n      }\n\n      if (ret == EINVAL) {\n         vrend_report_buffer_error(gdctx->grctx, header);\n         goto out;\n      }\n      if (ret == ENOMEM)\n         goto out;\n      gdctx->ds->buf_offset += (len) + 1;\n   }\n   return 0;\n out:\n   return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188154, "func": "status_t OMXNodeInstance::createGraphicBufferSource(\n\n         OMX_U32 portIndex, sp<IGraphicBufferConsumer> bufferConsumer, MetadataBufferType *type) {\n     status_t err;\n \n    const sp<GraphicBufferSource>& surfaceCheck = getGraphicBufferSource();\n     if (surfaceCheck != NULL) {\n         if (portIndex < NELEM(mMetadataType) && type != NULL) {\n             *type = mMetadataType[portIndex];\n }\n return ALREADY_EXISTS;\n }\n\n if (type != NULL) {\n *type = kMetadataBufferTypeANWBuffer;\n }\n    err = storeMetaDataInBuffers_l(portIndex, OMX_TRUE, type);\n if (err != OK) {\n return err;\n }\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n    OMX_ERRORTYPE oerr = OMX_GetParameter(\n            mHandle, OMX_IndexParamPortDefinition, &def);\n if (oerr != OMX_ErrorNone) {\n        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;\n        CLOG_ERROR(getParameter, oerr, \"%s(%#x): %s:%u\",\n                asString(index), index, portString(portIndex), portIndex);\n return UNKNOWN_ERROR;\n }\n\n if (def.format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque) {\n        CLOGW(\"createInputSurface requires COLOR_FormatSurface \"\n \"(AndroidOpaque) color format instead of %s(%#x)\",\n                asString(def.format.video.eColorFormat), def.format.video.eColorFormat);\n return INVALID_OPERATION;\n }\n\n uint32_t usageBits;\n    oerr = OMX_GetParameter(\n            mHandle, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits, &usageBits);\n if (oerr != OMX_ErrorNone) {\n        usageBits = 0;\n }\n\n    sp<GraphicBufferSource> bufferSource = new GraphicBufferSource(this,\n            def.format.video.nFrameWidth,\n            def.format.video.nFrameHeight,\n            def.nBufferCountActual,\n            usageBits,\n            bufferConsumer);\n\n if ((err = bufferSource->initCheck()) != OK) {\n return err;\n }\n    setGraphicBufferSource(bufferSource);\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 188255, "func": "bool CmapCoverage::getCoverage(SparseBitSet& coverage, const uint8_t* cmap_data, size_t cmap_size) {\n vector<uint32_t> coverageVec;\n const size_t kHeaderSize = 4;\n const size_t kNumTablesOffset = 2;\n const size_t kTableSize = 8;\n\n     const size_t kPlatformIdOffset = 0;\n     const size_t kEncodingIdOffset = 2;\n     const size_t kOffsetOffset = 4;\n    const int kMicrosoftPlatformId = 3;\n    const int kUnicodeBmpEncodingId = 1;\n    const int kUnicodeUcs4EncodingId = 10;\n     if (kHeaderSize > cmap_size) {\n         return false;\n     }\n    int numTables = readU16(cmap_data, kNumTablesOffset);\n     if (kHeaderSize + numTables * kTableSize > cmap_size) {\n         return false;\n     }\n    int bestTable = -1;\n    for (int i = 0; i < numTables; i++) {\n         uint16_t platformId = readU16(cmap_data, kHeaderSize + i * kTableSize + kPlatformIdOffset);\n         uint16_t encodingId = readU16(cmap_data, kHeaderSize + i * kTableSize + kEncodingIdOffset);\n         if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeUcs4EncodingId) {\n            bestTable = i;\n break;\n } else if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeBmpEncodingId) {\n            bestTable = i;\n }\n }\n\n #ifdef PRINTF_DEBUG\n     printf(\"best table = %d\\n\", bestTable);\n #endif\n    if (bestTable < 0) {\n         return false;\n     }\n     uint32_t offset = readU32(cmap_data, kHeaderSize + bestTable * kTableSize + kOffsetOffset);\n    if (offset + 2 > cmap_size) {\n         return false;\n     }\n     uint16_t format = readU16(cmap_data, offset);\n bool success = false;\n const uint8_t* tableData = cmap_data + offset;\n const size_t tableSize = cmap_size - offset;\n if (format == 4) {\n        success = getCoverageFormat4(coverageVec, tableData, tableSize);\n } else if (format == 12) {\n        success = getCoverageFormat12(coverageVec, tableData, tableSize);\n }\n if (success) {\n        coverage.initFromRanges(&coverageVec.front(), coverageVec.size() >> 1);\n }\n#ifdef PRINTF_DEBUG\n for (int i = 0; i < coverageVec.size(); i += 2) {\n        printf(\"%x:%x\\n\", coverageVec[i], coverageVec[i + 1]);\n }\n#endif\n return success;\n}\n", "target": 1, "flaw_line_index": "10,11,12,16,20,21,35,39"}
{"idx": 8852, "func": "static void vrend_destroy_surface_object(void *obj_ptr)\n{\n   struct vrend_surface *surface = obj_ptr;\n\n   vrend_surface_reference(&surface, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8892, "func": "void vrend_renderer_check_fences(void)\n{\n   struct vrend_fence *fence, *stor;\n   uint32_t latest_id = 0;\n   GLenum glret;\n\n   if (!vrend_state.inited)\n      return;\n\n   if (vrend_state.sync_thread) {\n      flush_eventfd(vrend_state.eventfd);\n      pipe_mutex_lock(vrend_state.fence_mutex);\n      LIST_FOR_EACH_ENTRY_SAFE(fence, stor, &vrend_state.fence_list, fences) {\n         if (fence->fence_id > latest_id)\n            latest_id = fence->fence_id;\n         free_fence_locked(fence);\n      }\n      pipe_mutex_unlock(vrend_state.fence_mutex);\n   } else {\n      vrend_renderer_force_ctx_0();\n\n      LIST_FOR_EACH_ENTRY_SAFE(fence, stor, &vrend_state.fence_list, fences) {\n         glret = glClientWaitSync(fence->syncobj, 0, 0);\n         if (glret == GL_ALREADY_SIGNALED){\n            latest_id = fence->fence_id;\n            free_fence_locked(fence);\n         }\n         else if (glret == GL_TIMEOUT_EXPIRED) {\n            break;\n         }\n      }\n   }\n\n   if (latest_id == 0)\n      return;\n   vrend_clicbs->write_fence(latest_id);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8340, "func": "static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)\n{\n    XHCITRB *trb_setup, *trb_status;\n    uint8_t bmRequestType;\n\n    trb_setup = &xfer->trbs[0];\n    trb_status = &xfer->trbs[xfer->trb_count-1];\n\n    trace_usb_xhci_xfer_start(xfer, xfer->slotid, xfer->epid, xfer->streamid);\n\n    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {\n        trb_status--;\n    }\n\n    if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n        DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\",\n                TRB_TYPE(*trb_setup));\n        return -1;\n    }\n    if (TRB_TYPE(*trb_status) != TR_STATUS) {\n        DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\",\n                TRB_TYPE(*trb_status));\n        return -1;\n    }\n    if (!(trb_setup->control & TRB_TR_IDT)) {\n        DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\");\n        return -1;\n    }\n    if ((trb_setup->status & 0x1ffff) != 8) {\n        DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\",\n                (trb_setup->status & 0x1ffff));\n        return -1;\n    }\n\n    bmRequestType = trb_setup->parameter;\n\n    xfer->in_xfer = bmRequestType & USB_DIR_IN;\n    xfer->iso_xfer = false;\n    xfer->timed_xfer = false;\n\n    if (xhci_setup_packet(xfer) < 0) {\n        return -1;\n    }\n    xfer->packet.parameter = trb_setup->parameter;\n\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n    xhci_complete_packet(xfer);\n    if (!xfer->running_async && !xfer->running_retry) {\n        xhci_kick_ep(xhci, xfer->slotid, xfer->epid, 0);\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187686, "func": "make_size_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,\n    png_byte PNG_CONST bit_depth, int PNG_CONST interlace_type,\n    png_uint_32 PNG_CONST w, png_uint_32 PNG_CONST h,\n    int PNG_CONST do_interlace)\n {\n    context(ps, fault);\n \n    check_interlace_type(interlace_type);\n \n    Try\n {\n      png_infop pi;\n      png_structp pp;\n unsigned int pixel_size;\n\n \n       char name[FILE_NAME_SIZE];\n      PNG_CONST png_uint_32 id = FILEID(colour_type, bit_depth, 0\n,\n          interlace_type, w, h, do_interlace);\n \n       standard_name_from_id(name, sizeof name, 0, id);\n      pp = set_store_for_write(ps, &pi, name);\n\n if (pp == NULL)\n Throw ps;\n\n      png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,\n         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n\n#ifdef PNG_TEXT_SUPPORTED\n {\n static char key[] = \"image name\"; \n size_t pos;\n         png_text text;\n char copy[FILE_NAME_SIZE];\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         pos = safecat(copy, sizeof copy, 0, ps->wname);\n         text.text = copy;\n         text.text_length = pos;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n\n         png_set_text(pp, pi, &text, 1);\n }\n#endif\n\n if (colour_type == 3) \n         init_standard_palette(ps, pp, pi, 1U << bit_depth, 0\n);\n\n      png_write_info(pp, pi);\n\n       pixel_size = bit_size(pp, colour_type, bit_depth);\n       if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)\n         png_error(pp, \"row size incorrect\");\n \n       else\n       {\n int npasses = npasses_from_interlace_type(pp, interlace_type);\n         png_uint_32 y;\n int pass;\n#        ifdef PNG_WRITE_FILTER_SUPPORTED\n int nfilter = PNG_FILTER_VALUE_LAST;\n#        endif\n         png_byte image[16][SIZE_ROWMAX];\n\n          memset(image, 0xff, sizeof image);\n \n         if (!do_interlace && npasses != png_set_interlace_handling(pp))\n             png_error(pp, \"write: png_set_interlace_handling failed\");\n \n for (y=0; y<h; ++y)\n            size_row(image[y], w * pixel_size, y);\n\n\n          for (pass=0; pass<npasses; ++pass)\n          {\n            PNG_CONST png_uint_32 wPass = PNG_PASS_COLS(w, pass);\n \n for (y=0; y<h; ++y)\n {\n               png_const_bytep row = image[y];\n               png_byte tempRow[SIZE_ROWMAX];\n\n if (do_interlace && interlace_type == PNG_INTERLACE_ADAM7)\n {\n if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0)\n {\n                      memset(tempRow, 0xff, sizeof tempRow);\n                     interlace_row(tempRow, row, pixel_size, w, pass);\n                      row = tempRow;\n                   }\n                   else\n continue;\n }\n\n#           ifdef PNG_WRITE_FILTER_SUPPORTED\n               png_set_filter(pp, 0\n,\n                  nfilter >= PNG_FILTER_VALUE_LAST ? PNG_ALL_FILTERS : nfilter);\n\n if (nfilter-- == 0)\n                  nfilter = PNG_FILTER_VALUE_LAST-1;\n#           endif\n\n               png_write_row(pp, row);\n }\n }\n }\n\n#ifdef PNG_TEXT_SUPPORTED\n {\n static char key[] = \"end marker\";\n static char comment[] = \"end\";\n         png_text text;\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         text.text = comment;\n         text.text_length = (sizeof comment)-1;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n\n         png_set_text(pp, pi, &text, 1);\n }\n#endif\n\n      png_write_end(pp, pi);\n\n      store_storefile(ps, id);\n\n      store_write_reset(ps);\n }\n\n Catch(fault)\n {\n      store_write_reset(fault);\n }\n\n }\n", "target": 1, "flaw_line_index": "2,3,4,7,7,19,59,73,82,94"}
{"idx": 187611, "func": "main(const int argc, const char * const * const argv)\n{\n int option_end, ilog = 0;\n struct display d;\n\n   validate_T();\n   display_init(&d);\n\n for (option_end=1; option_end<argc; ++option_end)\n {\n const char *name = argv[option_end];\n\n if (strcmp(name, \"--verbose\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | VERBOSE;\n\n else if (strcmp(name, \"--warnings\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | WARNINGS;\n\n else if (strcmp(name, \"--errors\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | ERRORS;\n\n else if (strcmp(name, \"--quiet\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | QUIET;\n\n else if (strcmp(name, \"--exhaustive\") == 0)\n         d.options |= EXHAUSTIVE;\n\n else if (strcmp(name, \"--fast\") == 0)\n         d.options &= ~EXHAUSTIVE;\n\n else if (strcmp(name, \"--strict\") == 0)\n         d.options |= STRICT;\n\n else if (strcmp(name, \"--relaxed\") == 0)\n         d.options &= ~STRICT;\n\n else if (strcmp(name, \"--log\") == 0)\n {\n         ilog = option_end; \n         d.options |= LOG;\n }\n\n else if (strcmp(name, \"--nolog\") == 0)\n         d.options &= ~LOG;\n\n else if (strcmp(name, \"--continue\") == 0)\n         d.options |= CONTINUE;\n\n else if (strcmp(name, \"--stop\") == 0)\n         d.options &= ~CONTINUE;\n\n else if (strcmp(name, \"--skip-bugs\") == 0)\n         d.options |= SKIP_BUGS;\n\n else if (strcmp(name, \"--test-all\") == 0)\n         d.options &= ~SKIP_BUGS;\n\n else if (strcmp(name, \"--log-skipped\") == 0)\n         d.options |= LOG_SKIPPED;\n\n else if (strcmp(name, \"--nolog-skipped\") == 0)\n         d.options &= ~LOG_SKIPPED;\n\n else if (strcmp(name, \"--find-bad-combos\") == 0)\n         d.options |= FIND_BAD_COMBOS;\n\n\n       else if (strcmp(name, \"--nofind-bad-combos\") == 0)\n          d.options &= ~FIND_BAD_COMBOS;\n \n       else if (name[0] == '-' && name[1] == '-')\n       {\n          fprintf(stderr, \"pngimage: %s: unknown option\\n\", name);\n return 99;\n }\n\n else\n break; \n }\n\n {\n int i;\n int errors = 0;\n\n for (i=option_end; i<argc; ++i)\n {\n {\n int ret = do_test(&d, argv[i]);\n\n if (ret > QUIET) \n return 99;\n }\n\n {\n const int pass = (d.options & STRICT) ?\n               RESULT_STRICT(d.results) : RESULT_RELAXED(d.results);\n\n if (!pass)\n ++errors;\n\n if (d.options & LOG)\n {\n int j;\n\n               printf(\"%s: pngimage \", pass ? \"PASS\" : \"FAIL\");\n\n for (j=1; j<option_end; ++j) if (j != ilog)\n                  printf(\"%s \", argv[j]);\n\n               printf(\"%s\\n\", d.filename);\n }\n }\n\n\n          display_clean(&d);\n       }\n \n       return errors != 0;\n    }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8894, "func": "int vrend_renderer_create_fence(int client_fence_id, uint32_t ctx_id)\n{\n   struct vrend_fence *fence;\n\n   fence = malloc(sizeof(struct vrend_fence));\n   if (!fence)\n      return ENOMEM;\n\n   fence->ctx_id = ctx_id;\n   fence->fence_id = client_fence_id;\n   fence->syncobj = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);\n\n   if (fence->syncobj == NULL)\n      goto fail;\n\n   if (vrend_state.sync_thread) {\n      pipe_mutex_lock(vrend_state.fence_mutex);\n      list_addtail(&fence->fences, &vrend_state.fence_wait_list);\n      pipe_mutex_unlock(vrend_state.fence_mutex);\n      pipe_condvar_signal(vrend_state.fence_cond);\n   } else\n      list_addtail(&fence->fences, &vrend_state.fence_list);\n   return 0;\n\n fail:\n   fprintf(stderr, \"failed to create fence sync object\\n\");\n   free(fence);\n   return ENOMEM;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8993, "func": "static uint64_t vmxnet3_get_mac_low(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[0]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[1]) |\n           VMXNET3_MAKE_BYTE(2, addr->a[2]) |\n           VMXNET3_MAKE_BYTE(3, addr->a[3]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9125, "func": "static int vrend_decode_set_sub_ctx(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t ctx_sub_id = get_buf_entry(ctx, 1);\n\n   vrend_renderer_set_sub_ctx(ctx->grctx, ctx_sub_id);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187854, "func": "bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,\n                      long long& val) {\n  assert(pReader);\n  assert(pos >= 0);\n  long long total, available;\n  const long status = pReader->Length(&total, &available);\n  assert(status >= 0);\n  assert((total < 0) || (available <= total));\n  if (status < 0)\n     return false;\n \n  long len;\n \n  const long long id = ReadUInt(pReader, pos, len);\n  assert(id >= 0);\n  assert(len > 0);\n  assert(len <= 8);\n  assert((pos + len) <= available);\n \n  if ((unsigned long)id != id_)\n     return false;\n \n   pos += len;  \n \n   const long long size = ReadUInt(pReader, pos, len);\n  assert(size >= 0);\n  assert(size <= 8);\n  assert(len > 0);\n  assert(len <= 8);\n  assert((pos + len) <= available);\n \n   pos += len;  \n \n   val = UnserializeUInt(pReader, pos, size);\n  assert(val >= 0);\n \n   pos += size;  \n \n   return true;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,12,14,15,16,17,18,20,26,27,28,29,30,35"}
{"idx": 187486, "func": " int btsock_thread_wakeup(int h)\n {\n if(h < 0 || h >= MAX_THREAD)\n {\n        APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\n return FALSE;\n }\n if(ts[h].cmd_fdw == -1)\n {\n        APPL_TRACE_ERROR(\"thread handle:%d, cmd socket is not created\", h);\n\n         return FALSE;\n     }\n     sock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};\n    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n }\n", "target": 1, "flaw_line_index": "15"}
{"idx": 188548, "func": "   void RunMemCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j) {\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n       }\n      if (i == 0)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = 255;\n      if (i == 1)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = -255;\n \n       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n                                      output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         EXPECT_EQ(output_block[j], output_ref_block[j]);\n        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n             << \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n       }\n     }\n   }\n", "target": 1, "flaw_line_index": "4,5,6,7,10,12,13,15,17,18,20,23,24,29"}
{"idx": 8900, "func": "void vrend_renderer_fill_caps(uint32_t set, uint32_t version,\n                              union virgl_caps *caps)\n{\n   int i;\n   GLint max;\n   int gl_ver = epoxy_gl_version();\n\n   if (!caps)\n      return;\n\n   memset(caps, 0, sizeof(*caps));\n\n   if (set != 1 && set != 0) {\n      caps->max_version = 0;\n      return;\n   }\n\n   caps->max_version = 1;\n\n   caps->v1.bset.occlusion_query = 1;\n   if (gl_ver >= 30) {\n      caps->v1.bset.indep_blend_enable = 1;\n      caps->v1.bset.conditional_render = 1;\n   } else {\n      if (epoxy_has_gl_extension(\"GL_EXT_draw_buffers2\"))\n         caps->v1.bset.indep_blend_enable = 1;\n      if (epoxy_has_gl_extension(\"GL_NV_conditional_render\"))\n         caps->v1.bset.conditional_render = 1;\n   }\n\n   if (vrend_state.use_core_profile) {\n      caps->v1.bset.poly_stipple = 0;\n      caps->v1.bset.color_clamping = 0;\n   } else {\n      caps->v1.bset.poly_stipple = 1;\n      caps->v1.bset.color_clamping = 1;\n   }\n   if (gl_ver >= 31) {\n      caps->v1.bset.instanceid = 1;\n      glGetIntegerv(GL_MAX_VERTEX_UNIFORM_BLOCKS, &max);\n      vrend_state.max_uniform_blocks = max;\n      caps->v1.max_uniform_blocks = max + 1;\n   } else {\n      if (epoxy_has_gl_extension(\"GL_ARB_draw_instanced\"))\n         caps->v1.bset.instanceid = 1;\n   }\n\n   if (vrend_state.have_nv_prim_restart || vrend_state.have_gl_prim_restart)\n      caps->v1.bset.primitive_restart = 1;\n\n   if (gl_ver >= 32) {\n      caps->v1.bset.fragment_coord_conventions = 1;\n      caps->v1.bset.depth_clip_disable = 1;\n      caps->v1.bset.seamless_cube_map = 1;\n   } else {\n      if (epoxy_has_gl_extension(\"GL_ARB_fragment_coord_conventions\"))\n         caps->v1.bset.fragment_coord_conventions = 1;\n      if (epoxy_has_gl_extension(\"GL_ARB_seamless_cube_map\"))\n         caps->v1.bset.seamless_cube_map = 1;\n   }\n\n   if (epoxy_has_gl_extension(\"GL_AMD_seamless_cube_map_per_texture\"))\n      caps->v1.bset.seamless_cube_map_per_texture = 1;\n\n   if (epoxy_has_gl_extension(\"GL_ARB_texture_multisample\")) {\n      caps->v1.bset.texture_multisample = 1;\n   }\n   if (gl_ver >= 40) {\n      caps->v1.bset.indep_blend_func = 1;\n      caps->v1.bset.cube_map_array = 1;\n      caps->v1.bset.texture_query_lod = 1;\n   } else {\n      if (epoxy_has_gl_extension(\"GL_ARB_draw_buffers_blend\"))\n         caps->v1.bset.indep_blend_func = 1;\n      if (epoxy_has_gl_extension(\"GL_ARB_texture_cube_map_array\"))\n         caps->v1.bset.cube_map_array = 1;\n      if (epoxy_has_gl_extension(\"GL_ARB_texture_query_lod\"))\n         caps->v1.bset.texture_query_lod = 1;\n   }\n\n   if (gl_ver >= 42) {\n      caps->v1.bset.start_instance = 1;\n   } else {\n      if (epoxy_has_gl_extension(\"GL_ARB_base_instance\"))\n         caps->v1.bset.start_instance = 1;\n   }\n   if (epoxy_has_gl_extension(\"GL_ARB_shader_stencil_export\"))\n      caps->v1.bset.shader_stencil_export = 1;\n\n   caps->v1.glsl_level = 130;\n   if (vrend_state.use_core_profile) {\n      if (gl_ver == 31)\n         caps->v1.glsl_level = 140;\n      else if (gl_ver == 32)\n         caps->v1.glsl_level = 150;\n      else if (gl_ver >= 33)\n         caps->v1.glsl_level = 330;\n   }\n\n   if (epoxy_has_gl_extension(\"GL_EXT_texture_mirror_clamp\"))\n      caps->v1.bset.mirror_clamp = true;\n\n   if (epoxy_has_gl_extension(\"GL_EXT_texture_array\")) {\n      glGetIntegerv(GL_MAX_ARRAY_TEXTURE_LAYERS, &max);\n      caps->v1.max_texture_array_layers = max;\n   }\n\n   if (epoxy_has_gl_extension(\"GL_ARB_transform_feedback2\")) {\n      caps->v1.bset.streamout_pause_resume = 1;\n   }\n\n   if (epoxy_has_gl_extension(\"GL_ARB_transform_feedback3\")) {\n      glGetIntegerv(GL_MAX_TRANSFORM_FEEDBACK_BUFFERS, &max);\n      caps->v1.max_streamout_buffers = max;\n   } else if (epoxy_has_gl_extension(\"GL_EXT_transform_feedback\"))\n      caps->v1.max_streamout_buffers = 4;\n   if (epoxy_has_gl_extension(\"GL_ARB_blend_func_extended\")) {\n      glGetIntegerv(GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, &max);\n      caps->v1.max_dual_source_render_targets = max;\n   } else\n      caps->v1.max_dual_source_render_targets = 0;\n\n   glGetIntegerv(GL_MAX_DRAW_BUFFERS, &max);\n   caps->v1.max_render_targets = max;\n\n   glGetIntegerv(GL_MAX_SAMPLES, &max);\n   caps->v1.max_samples = max;\n\n   if (epoxy_has_gl_extension(\"GL_ARB_texture_buffer_object\")) {\n      glGetIntegerv(GL_MAX_TEXTURE_BUFFER_SIZE, &max);\n      caps->v1.max_tbo_size = max;\n   }\n\n   if (epoxy_has_gl_extension(\"GL_ARB_texture_gather\")) {\n      glGetIntegerv(GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB, &max);\n      caps->v1.max_texture_gather_components = max;\n   }\n\n   if (epoxy_has_gl_extension(\"GL_ARB_viewport_array\")) {\n      glGetIntegerv(GL_MAX_VIEWPORTS, &max);\n      caps->v1.max_viewports = max;\n   } else\n      caps->v1.max_viewports = 1;\n\n   caps->v1.prim_mask = (1 << PIPE_PRIM_POINTS) | (1 << PIPE_PRIM_LINES) | (1 << PIPE_PRIM_LINE_STRIP) | (1 << PIPE_PRIM_LINE_LOOP) | (1 << PIPE_PRIM_TRIANGLES) | (1 << PIPE_PRIM_TRIANGLE_STRIP) | (1 << PIPE_PRIM_TRIANGLE_FAN);\n   if (vrend_state.use_core_profile == false) {\n      caps->v1.prim_mask |= (1 << PIPE_PRIM_QUADS) | (1 << PIPE_PRIM_QUAD_STRIP) | (1 << PIPE_PRIM_POLYGON);\n   }\n   if (caps->v1.glsl_level >= 150)\n      caps->v1.prim_mask |= (1 << PIPE_PRIM_LINES_ADJACENCY) |\n         (1 << PIPE_PRIM_LINE_STRIP_ADJACENCY) |\n         (1 << PIPE_PRIM_TRIANGLES_ADJACENCY) |\n         (1 << PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY);\n\n\n   if (epoxy_has_gl_extension(\"GL_ARB_vertex_type_10f_11f_11f_rev\")) {\n      int val = VIRGL_FORMAT_R11G11B10_FLOAT;\n      uint32_t offset = val / 32;\n      uint32_t index = val % 32;\n\n      caps->v1.vertexbuffer.bitmask[offset] |= (1 << index);\n   }\n\n   for (i = 0; i < VIRGL_FORMAT_MAX; i++) {\n      uint32_t offset = i / 32;\n      uint32_t index = i % 32;\n\n      if (tex_conv_table[i].internalformat != 0) {\n         if (vrend_format_can_sample(i)) {\n            caps->v1.sampler.bitmask[offset] |= (1 << index);\n            if (vrend_format_can_render(i))\n               caps->v1.render.bitmask[offset] |= (1 << index);\n         }\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8632, "func": "static void xilinx_ethlite_init(Object *obj)\n{\n    struct xlx_ethlite *s = XILINX_ETHLITE(obj);\n\n    sysbus_init_irq(SYS_BUS_DEVICE(obj), &s->irq);\n\n    memory_region_init_io(&s->mmio, obj, &eth_ops, s,\n                          \"xlnx.xps-ethernetlite\", R_MAX * 4);\n    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &s->mmio);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8829, "func": "struct vrend_context *vrend_create_context(int id, uint32_t nlen, const char *debug_name)\n{\n   struct vrend_context *grctx = CALLOC_STRUCT(vrend_context);\n\n   if (!grctx)\n      return NULL;\n\n   if (nlen && debug_name) {\n      strncpy(grctx->debug_name, debug_name, 64);\n   }\n\n   grctx->ctx_id = id;\n\n   list_inithead(&grctx->sub_ctxs);\n   list_inithead(&grctx->active_nontimer_query_list);\n\n   grctx->res_hash = vrend_object_init_ctx_table();\n\n   grctx->shader_cfg.use_core_profile = vrend_state.use_core_profile;\n   grctx->shader_cfg.use_explicit_locations = vrend_state.use_explicit_locations;\n   vrend_renderer_create_sub_ctx(grctx, 0);\n   vrend_renderer_set_sub_ctx(grctx, 0);\n\n   vrender_get_glsl_version(&grctx->shader_cfg.glsl_version);\n\n   list_addtail(&grctx->ctx_entry, &vrend_state.active_ctx_list);\n   return grctx;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8370, "func": "static void mptsas_post_reply(MPTSASState *s, MPIDefaultReply *reply)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    uint32_t addr_lo;\n\n    if (MPTSAS_FIFO_EMPTY(s, reply_free) || MPTSAS_FIFO_FULL(s, reply_post)) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);\n        return;\n    }\n\n    addr_lo = MPTSAS_FIFO_GET(s, reply_free);\n\n    pci_dma_write(pci, addr_lo | s->host_mfa_high_addr, reply,\n                  MIN(s->reply_frame_size, 4 * reply->MsgLength));\n\n    MPTSAS_FIFO_PUT(s, reply_post, MPI_ADDRESS_REPLY_A_BIT | (addr_lo >> 1));\n\n    s->intr_status |= MPI_HIS_REPLY_MESSAGE_INTERRUPT;\n    if (s->doorbell_state == DOORBELL_WRITE) {\n        s->doorbell_state = DOORBELL_NONE;\n        s->intr_status |= MPI_HIS_DOORBELL_INTERRUPT;\n    }\n    mptsas_update_interrupt(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9083, "func": "static inline uint32_t get_buf_entry(struct vrend_decode_ctx *ctx, uint32_t offset)\n{\n   return ctx->ds->buf[ctx->ds->buf_offset + offset];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187547, "func": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size()) {\n\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, true);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 8657, "func": "size_t mptsas_config_manufacturing_9(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(9, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187945, "func": "EAS_BOOL WT_CheckSampleEnd (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame, EAS_BOOL update)\n{\n    EAS_U32 endPhaseAccum;\n    EAS_U32 endPhaseFrac;\n    EAS_I32 numSamples;\n    EAS_BOOL done = EAS_FALSE;\n\n    endPhaseFrac = pWTVoice->phaseFrac + (pWTIntFrame->frame.phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS);\n    endPhaseAccum = pWTVoice->phaseAccum + GET_PHASE_INT_PART(endPhaseFrac);\n if (endPhaseAccum >= pWTVoice->loopEnd)\n {\n        numSamples = (EAS_I32) (pWTVoice->loopEnd - pWTVoice->phaseAccum);\n\n        numSamples = (EAS_I32) ((numSamples << NUM_PHASE_FRAC_BITS) - pWTVoice->phaseFrac);\n if (pWTIntFrame->frame.phaseIncrement) {\n            pWTIntFrame->numSamples = 1 + (numSamples / pWTIntFrame->frame.phaseIncrement);\n\n         } else {\n             pWTIntFrame->numSamples = numSamples;\n         }\n \n         done = EAS_TRUE;\n }\n\n if (update)\n {\n        pWTVoice->phaseFrac = endPhaseFrac;\n        pWTVoice->phaseAccum = endPhaseAccum;\n }\n\n return done;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187874, "func": " long Segment::ParseCues(long long off, long long& pos, long& len) {\n   if (m_pCues)\n     return 0;  \n\n if (off < 0)\n return -1;\n\n long long total, avail;\n\n const int status = m_pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n\n  pos = m_start + off;\n\n if ((total < 0) || (pos >= total))\n return 1; \n\n const long long element_start = pos;\n const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n \n   const long long idpos = pos;\n \n  const long long id = ReadUInt(m_pReader, idpos, len);\n \n   if (id != 0x0C53BB6B)  \n     return E_FILE_FORMAT_INVALID;\n\n  pos += len; \n  assert((segment_stop < 0) || (pos <= segment_stop));\n\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n  result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n if (size == 0) \n return 1; \n\n  pos += len; \n  assert((segment_stop < 0) || (pos <= segment_stop));\n\n\n const long long element_stop = pos + size;\n\n if ((segment_stop >= 0) && (element_stop > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((total >= 0) && (element_stop > total))\n return 1; \n\n  len = static_cast<long>(size);\n\n if (element_stop > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long element_size = element_stop - element_start;\n\n \n   m_pCues =\n       new (std::nothrow) Cues(this, pos, size, element_start, element_size);\n  assert(m_pCues);  \n \n   return 0;  \n }\n", "target": 1, "flaw_line_index": "50,113"}
{"idx": 8750, "func": "vcard_response_set_status_bytes(VCardResponse *response,\n                               unsigned char sw1, unsigned char sw2)\n{\n    response->b_status = sw1 << 8 | sw2;\n    response->b_sw1 = sw1;\n    response->b_sw2 = sw2;\n    response->b_data[response->b_len] = sw1;\n    response->b_data[response->b_len+1] = sw2;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187940, "func": "void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n const EAS_I8 *pLoopEnd;\n const EAS_I8 *pCurrentPhaseInt;\n    EAS_I32 numSamples;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 currentPhaseFrac;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n\n     EAS_I8 *pLoopStart;\n \n     numSamples = pWTIntFrame->numSamples;\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n \n    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n    pCurrentPhaseInt = pWTVoice->pPhaseAccum;\n    currentPhaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->phaseIncrement;\n\n    pLoopStart = pWTVoice->pLoopStart;\n    pLoopEnd = pWTVoice->pLoopEnd + 1;\n\nInterpolationLoop:\n    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);\n if (tmp0 >= 0)\n        pCurrentPhaseInt = pLoopStart + tmp0;\n\n    tmp0 = *pCurrentPhaseInt;\n    tmp1 = *(pCurrentPhaseInt + 1);\n\n    tmp2 = phaseInc + currentPhaseFrac;\n\n    tmp1 = tmp1 - tmp0;\n    tmp1 = tmp1 * currentPhaseFrac;\n\n    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);\n\n    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);\n    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;\n\n    gain += gainIncrement;\n    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n\n    tmp0 = *pMixBuffer;\n    tmp2 = tmp1 * tmp2;\n    tmp2 = (tmp2 >> 9);\n    tmp0 = tmp2 + tmp0;\n *pMixBuffer++ = tmp0;\n\n    numSamples--;\n if (numSamples > 0)\n goto InterpolationLoop;\n\n    pWTVoice->pPhaseAccum = pCurrentPhaseInt;\n    pWTVoice->phaseFrac = currentPhaseFrac;\n    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8874, "func": "static void vrend_hw_emit_rs(struct vrend_context *ctx)\n{\n   struct pipe_rasterizer_state *state = &ctx->sub->rs_state;\n   int i;\n\n   if (state->depth_clip) {\n      glDisable(GL_DEPTH_CLAMP);\n   } else {\n      glEnable(GL_DEPTH_CLAMP);\n   }\n\n   if (state->point_size_per_vertex) {\n      glEnable(GL_PROGRAM_POINT_SIZE);\n   } else {\n      glDisable(GL_PROGRAM_POINT_SIZE);\n      if (state->point_size)\n         glPointSize(state->point_size);\n   }\n\n   if (state->rasterizer_discard != ctx->sub->hw_rs_state.rasterizer_discard) {\n      ctx->sub->hw_rs_state.rasterizer_discard = state->rasterizer_discard;\n      if (state->rasterizer_discard)\n         glEnable(GL_RASTERIZER_DISCARD);\n      else\n         glDisable(GL_RASTERIZER_DISCARD);\n   }\n\n   if (vrend_state.use_core_profile == false) {\n      glPolygonMode(GL_FRONT, translate_fill(state->fill_front));\n      glPolygonMode(GL_BACK, translate_fill(state->fill_back));\n   } else if (state->fill_front == state->fill_back) {\n      glPolygonMode(GL_FRONT_AND_BACK, translate_fill(state->fill_front));\n   } else\n      report_core_warn(ctx, CORE_PROFILE_WARN_POLYGON_MODE, 0);\n\n   if (state->offset_tri)\n      glEnable(GL_POLYGON_OFFSET_FILL);\n   else\n      glDisable(GL_POLYGON_OFFSET_FILL);\n\n   if (state->offset_line)\n      glEnable(GL_POLYGON_OFFSET_LINE);\n   else\n      glDisable(GL_POLYGON_OFFSET_LINE);\n\n   if (state->offset_point)\n      glEnable(GL_POLYGON_OFFSET_POINT);\n   else\n      glDisable(GL_POLYGON_OFFSET_POINT);\n\n\n   if (state->flatshade != ctx->sub->hw_rs_state.flatshade) {\n      ctx->sub->hw_rs_state.flatshade = state->flatshade;\n      if (vrend_state.use_core_profile == false) {\n         if (state->flatshade) {\n            glShadeModel(GL_FLAT);\n         } else {\n            glShadeModel(GL_SMOOTH);\n         }\n      }\n   }\n\n   if (state->flatshade_first != ctx->sub->hw_rs_state.flatshade_first) {\n      ctx->sub->hw_rs_state.flatshade_first = state->flatshade_first;\n      if (state->flatshade_first)\n         glProvokingVertexEXT(GL_FIRST_VERTEX_CONVENTION_EXT);\n      else\n         glProvokingVertexEXT(GL_LAST_VERTEX_CONVENTION_EXT);\n   }\n   glPolygonOffset(state->offset_scale, state->offset_units);\n\n   if (vrend_state.use_core_profile == false) {\n      if (state->poly_stipple_enable)\n         glEnable(GL_POLYGON_STIPPLE);\n      else\n         glDisable(GL_POLYGON_STIPPLE);\n   } else if (state->poly_stipple_enable) {\n      if (!ctx->pstip_inited)\n         vrend_init_pstipple_texture(ctx);\n   }\n\n   if (state->point_quad_rasterization) {\n      if (vrend_state.use_core_profile == false)\n         glEnable(GL_POINT_SPRITE);\n\n      glPointParameteri(GL_POINT_SPRITE_COORD_ORIGIN, state->sprite_coord_mode ? GL_UPPER_LEFT : GL_LOWER_LEFT);\n   } else {\n      if (vrend_state.use_core_profile == false)\n         glDisable(GL_POINT_SPRITE);\n   }\n   if (state->cull_face != PIPE_FACE_NONE) {\n      switch (state->cull_face) {\n      case PIPE_FACE_FRONT:\n         glCullFace(GL_FRONT);\n         break;\n      case PIPE_FACE_BACK:\n         glCullFace(GL_BACK);\n         break;\n      case PIPE_FACE_FRONT_AND_BACK:\n         glCullFace(GL_FRONT_AND_BACK);\n         break;\n      default:\n         fprintf(stderr, \"unhandled cull-face: %x\\n\", state->cull_face);\n      }\n      glEnable(GL_CULL_FACE);\n   } else\n      glDisable(GL_CULL_FACE);\n\n   if (vrend_state.use_core_profile == false) {\n      if (state->light_twoside)\n         glEnable(GL_VERTEX_PROGRAM_TWO_SIDE);\n      else\n         glDisable(GL_VERTEX_PROGRAM_TWO_SIDE);\n   }\n\n   if (state->clip_plane_enable != ctx->sub->hw_rs_state.clip_plane_enable) {\n      ctx->sub->hw_rs_state.clip_plane_enable = state->clip_plane_enable;\n      for (i = 0; i < 8; i++) {\n         if (state->clip_plane_enable & (1 << i))\n            glEnable(GL_CLIP_PLANE0 + i);\n         else\n            glDisable(GL_CLIP_PLANE0 + i);\n      }\n   }\n   if (vrend_state.use_core_profile == false) {\n      glLineStipple(state->line_stipple_factor, state->line_stipple_pattern);\n      if (state->line_stipple_enable)\n         glEnable(GL_LINE_STIPPLE);\n      else\n         glDisable(GL_LINE_STIPPLE);\n   } else if (state->line_stipple_enable)\n      report_core_warn(ctx, CORE_PROFILE_WARN_STIPPLE, 0);\n\n   if (state->line_smooth)\n      glEnable(GL_LINE_SMOOTH);\n   else\n      glDisable(GL_LINE_SMOOTH);\n\n   if (state->poly_smooth)\n      glEnable(GL_POLYGON_SMOOTH);\n   else\n      glDisable(GL_POLYGON_SMOOTH);\n\n   if (vrend_state.use_core_profile == false) {\n      if (state->clamp_vertex_color)\n         glClampColor(GL_CLAMP_VERTEX_COLOR_ARB, GL_TRUE);\n      else\n         glClampColor(GL_CLAMP_VERTEX_COLOR_ARB, GL_FALSE);\n\n      if (state->clamp_fragment_color)\n         glClampColor(GL_CLAMP_FRAGMENT_COLOR_ARB, GL_TRUE);\n      else\n         glClampColor(GL_CLAMP_FRAGMENT_COLOR_ARB, GL_FALSE);\n   } else {\n      if (state->clamp_vertex_color || state->clamp_fragment_color)\n         report_core_warn(ctx, CORE_PROFILE_WARN_CLAMP, 0);\n   }\n\n   if (vrend_state.have_multisample) {\n      if (state->multisample) {\n         glEnable(GL_MULTISAMPLE);\n         glEnable(GL_SAMPLE_MASK);\n      } else {\n         glDisable(GL_MULTISAMPLE);\n         glDisable(GL_SAMPLE_MASK);\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8400, "func": "static unsigned int virtqueue_get_head(VirtQueue *vq, unsigned int idx)\n{\n    unsigned int head;\n\n    head = vring_avail_ring(vq, idx % vq->vring.num);\n\n    if (head >= vq->vring.num) {\n        error_report(\"Guest says index %u is available\", head);\n        exit(1);\n    }\n\n    return head;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187920, "func": "status_t BnOMX::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case LIVES_LOCALLY:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n return OK;\n }\n\n case LIST_NODES:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n }\n }\n\n return NO_ERROR;\n }\n\n case ALLOCATE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n if (err == OK) {\n                reply->writeInt32((int32_t)node);\n }\n\n return NO_ERROR;\n }\n\n case FREE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n return NO_ERROR;\n }\n\n case SEND_COMMAND:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n return NO_ERROR;\n }\n\n case GET_PARAMETER:\n case SET_PARAMETER:\n case GET_CONFIG:\n case SET_CONFIG:\n case SET_INTERNAL_OPTION:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n size_t size = data.readInt64();\n\n void *params = malloc(size);\n            data.read(params, size);\n\n status_t err;\n switch (code) {\n case GET_PARAMETER:\n                    err = getParameter(node, index, params, size);\n break;\n case SET_PARAMETER:\n                    err = setParameter(node, index, params, size);\n break;\n case GET_CONFIG:\n                    err = getConfig(node, index, params, size);\n break;\n case SET_CONFIG:\n                    err = setConfig(node, index, params, size);\n break;\n case SET_INTERNAL_OPTION:\n {\n InternalOptionType type =\n (InternalOptionType)data.readInt32();\n\n                    err = setInternalOption(node, index, type, params, size);\n break;\n }\n\n default:\n                    TRESPASS();\n }\n\n            reply->writeInt32(err);\n\n if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n                reply->write(params, size);\n }\n\n            free(params);\n            params = NULL;\n\n return NO_ERROR;\n }\n\n case GET_STATE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case ENABLE_GRAPHIC_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case GET_GRAPHIC_BUFFER_USAGE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n return NO_ERROR;\n }\n\n case USE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n\n            buffer_id buffer;\n status_t err = useBuffer(node, port_index, params, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case USE_GRAPHIC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case UPDATE_GRAPHIC_BUFFER_IN_META:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CREATE_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferProducer> bufferProducer;\n status_t err = createInputSurface(node, port_index,\n &bufferProducer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(bufferProducer->asBinder());\n }\n\n return NO_ERROR;\n }\n\n case SIGNAL_END_OF_INPUT_STREAM:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case STORE_META_DATA_IN_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = storeMetaDataInBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CONFIGURE_VIDEO_TUNNEL_MODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n             OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n             OMX_U32 audio_hw_sync = data.readInt32();\n \n            native_handle_t *sideband_handle;\n             status_t err = configureVideoTunnelMode(\n                     node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n             reply->writeInt32(err);\n            reply->writeNativeHandle(sideband_handle);\n \n             return NO_ERROR;\n         }\n\n case ALLOC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n if (!isSecure(node) || port_index != 0 \n) {\n                ALOGE(\"b/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n return NO_ERROR;\n }\n\n size_t size = data.readInt64();\n\n            buffer_id buffer;\n void *buffer_data;\n status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER_WITH_BACKUP:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n\n            buffer_id buffer;\n status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case FREE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n return NO_ERROR;\n }\n\n case FILL_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(fillBuffer(node, buffer));\n\n return NO_ERROR;\n }\n\n case EMPTY_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n\n            reply->writeInt32(\n                    emptyBuffer(\n                        node, buffer, range_offset, range_length,\n                        flags, timestamp));\n\n return NO_ERROR;\n }\n\n case GET_EXTENSION_INDEX:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32(index);\n }\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "312,316"}
{"idx": 187924, "func": "void btm_sec_pin_code_request (UINT8 *p_bda)\n{\n\n     tBTM_SEC_DEV_REC *p_dev_rec;\n     tBTM_CB          *p_cb = &btm_cb;\n \n#ifdef PORCHE_PAIRING_CONFLICT\n    UINT8 default_pin_code_len = 4;\n    PIN_CODE default_pin_code = {0x30, 0x30, 0x30, 0x30};\n#endif\n     BTM_TRACE_EVENT (\"btm_sec_pin_code_request()  State: %s, BDA:%04x%08x\",\n                       btm_pair_state_descr(btm_cb.pairing_state),\n                       (p_bda[0]<<8)+p_bda[1], (p_bda[2]<<24)+(p_bda[3]<<16)+(p_bda[4]<<8)+p_bda[5] );\n\n if (btm_cb.pairing_state != BTM_PAIR_STATE_IDLE)\n {\n\n         if ( (memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) == 0)  &&\n              (btm_cb.pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE) )\n         {\n             if(! btm_cb.pin_code_len_saved)\n             {\n                 btsnd_hcic_pin_code_neg_reply (p_bda);\n                 return;\n             }\n             else\n             {\n                 btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);\n      \t         return;\n             }\n         }\n         else if ((btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ)\n                  || memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)\n {\n\n             BTM_TRACE_WARNING (\"btm_sec_pin_code_request() rejected - state: %s\",\n                                 btm_pair_state_descr(btm_cb.pairing_state));\n \n#ifdef PORCHE_PAIRING_CONFLICT\n            BTM_TRACE_EVENT (\"btm_sec_pin_code_request from remote dev. for local initiated pairing\");\n            if(! btm_cb.pin_code_len_saved)\n            {\n                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n                btsnd_hcic_pin_code_req_reply (p_bda, default_pin_code_len, default_pin_code);\n            }\n            else\n            {\n                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n                btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);\n            }\n#else\n             btsnd_hcic_pin_code_neg_reply (p_bda);\n#endif\n             return;\n         }\n     }\n\n    p_dev_rec = btm_find_or_alloc_dev (p_bda);\n    p_dev_rec->sm4 = BTM_SM4_KNOWN;\n\n if (btm_cb.pairing_state == BTM_PAIR_STATE_IDLE)\n {\n        memcpy (btm_cb.pairing_bda, p_bda, BD_ADDR_LEN);\n\n        btm_cb.pairing_flags = BTM_PAIR_FLAGS_PEER_STARTED_DD;\n        BTM_SEC_CLR_TRUSTED_DEVICE(p_dev_rec->trusted_mask);\n }\n\n if (!p_cb->pairing_disabled && (p_cb->cfg.pin_type == HCI_PIN_TYPE_FIXED))\n {\n        BTM_TRACE_EVENT (\"btm_sec_pin_code_request fixed pin replying\");\n        btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n        btsnd_hcic_pin_code_req_reply (p_bda, p_cb->cfg.pin_code_len, p_cb->cfg.pin_code);\n return;\n }\n\n if ( (!memcmp (p_bda, p_cb->connecting_bda, BD_ADDR_LEN))\n && (p_cb->connecting_dc[0] || p_cb->connecting_dc[1] || p_cb->connecting_dc[2]) )\n        memcpy (p_dev_rec->dev_class, p_cb->connecting_dc, DEV_CLASS_LEN);\n\n if (btm_cb.pin_code_len != 0)\n {\n\n         BTM_TRACE_EVENT (\"btm_sec_pin_code_request bonding sending reply\");\n         btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len, p_cb->pin_code);\n \n#ifdef PORCHE_PAIRING_CONFLICT\n        btm_cb.pin_code_len_saved = btm_cb.pin_code_len;\n#endif\n         btm_cb.pin_code_len = 0;\n \n\n        btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n }\n\n else if (p_cb->pairing_disabled\n || (p_cb->api.p_pin_callback == NULL)\n\n || (!p_dev_rec->is_originator\n && ((p_dev_rec->dev_class[1] & BTM_COD_MAJOR_CLASS_MASK) == BTM_COD_MAJOR_PERIPHERAL)\n && (p_dev_rec->dev_class[2] & BTM_COD_MINOR_KEYBOARD)) )\n {\n        BTM_TRACE_WARNING(\"btm_sec_pin_code_request(): Pairing disabled:%d; PIN callback:%x, Dev Rec:%x!\",\n                           p_cb->pairing_disabled, p_cb->api.p_pin_callback, p_dev_rec);\n\n        btsnd_hcic_pin_code_neg_reply (p_bda);\n }\n\n     else\n     {\n        btm_cb.pin_code_len_saved = 0;\n         btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_LOCAL_PIN);\n         memcpy (p_cb->connecting_bda, p_bda, BD_ADDR_LEN);\n        memcpy (p_cb->connecting_dc,  p_dev_rec->dev_class, DEV_CLASS_LEN);\n\n if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN)\n {\n            BTM_TRACE_EVENT (\"btm_sec_pin_code_request going for callback\");\n\n            btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;\n if (p_cb->api.p_pin_callback)\n (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);\n }\n else\n {\n            BTM_TRACE_EVENT (\"btm_sec_pin_code_request going for remote name\");\n\n if (!btsnd_hcic_rmt_name_req (p_dev_rec->bd_addr,\n                                          HCI_PAGE_SCAN_REP_MODE_R1,\n                                          HCI_MANDATARY_PAGE_SCAN_MODE, 0))\n {\n                p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;\n                p_dev_rec->sec_bd_name[0] = 'f';\n                p_dev_rec->sec_bd_name[1] = '0';\n                BTM_TRACE_ERROR (\"can not send rmt_name_req?? fake a name and call callback\");\n\n                btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;\n if (p_cb->api.p_pin_callback)\n (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);\n }\n }\n }\n\n return;\n}\n", "target": 1, "flaw_line_index": "7,8,9,10,20,21,22,23,24,25,26,27,28,29,30,31,39,40,41,42,43,44,45,46,47,48,49,50,51,52,54,88,89,89,112"}
{"idx": 188600, "func": "   static void SetUpTestCase() {\n    source_data_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBlockSize));\n    reference_data_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBufferSize));\n   }\n", "target": 1, "flaw_line_index": "2,4"}
{"idx": 8638, "func": "size_t mptsas_config_io_unit_1(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x02, \"l\",\n                              0x41 \n );\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8484, "func": "UINT CSoundFile::GetRawSongComments(LPSTR s, UINT len, UINT linesize)\n{\n\tLPCSTR p = m_lpszSongComments;\n\tif (!p) return 0;\n\tUINT i = 0, ln=0;\n\twhile ((*p)\t&& (i < len-1))\n\t{\n\t\tBYTE c = (BYTE)*p++;\n\t\tif ((c == 0x0D)\t|| (c == 0x0A))\n\t\t{\n\t\t\tif (ln)\n\t\t\t{\n\t\t\t\twhile (ln < linesize) { if (s) s[i] = ' '; i++; ln++; }\n\t\t\t\tln = 0;\n\t\t\t}\n\t\t} else\n\t\tif ((c == ' ') && (!ln))\n\t\t{\n\t\t\tUINT k=0;\n\t\t\twhile ((p[k]) && (p[k] >= ' '))\tk++;\n\t\t\tif (k <= linesize)\n\t\t\t{\n\t\t\t\tif (s) s[i] = ' ';\n\t\t\t\ti++;\n\t\t\t\tln++;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tif (s) s[i] = c;\n\t\t\ti++;\n\t\t\tln++;\n\t\t\tif (ln == linesize) ln = 0;\n\t\t}\n\t}\n\tif (ln)\n\t{\n\t\twhile ((ln < linesize) && (i < len))\n\t\t{\n\t\t\tif (s) s[i] = ' ';\n\t\t\ti++;\n\t\t\tln++;\n\t\t}\n\t}\n\tif (s) s[i] = 0;\n\treturn i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8633, "func": "static void xilinx_ethlite_realize(DeviceState *dev, Error **errp)\n{\n    struct xlx_ethlite *s = XILINX_ETHLITE(dev);\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_xilinx_ethlite_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8492, "func": "void CSoundFile::ResetMidiCfg()\n{\n\tmemset(&m_MidiCfg, 0, sizeof(m_MidiCfg));\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_START*32], \"FF\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_STOP*32], \"FC\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_NOTEON*32], \"9c n v\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_NOTEOFF*32], \"9c n 0\");\n\tlstrcpy(&m_MidiCfg.szMidiGlb[MIDIOUT_PROGRAM*32], \"Cc p\");\n\tlstrcpy(&m_MidiCfg.szMidiSFXExt[0], \"F0F000z\");\n\tfor (int iz=0; iz<16; iz++) wsprintf(&m_MidiCfg.szMidiZXXExt[iz*32], \"F0F001%02X\", iz*8);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188621, "func": "   virtual void SetUp() {\n    vp9_worker_init(&worker_);\n   }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8442, "func": "pvscsi_request_cancelled(SCSIRequest *req)\n{\n    PVSCSIRequest *pvscsi_req = req->hba_private;\n    PVSCSIState *s = pvscsi_req->dev;\n\n    if (pvscsi_req->completed) {\n        return;\n    }\n\n   if (pvscsi_req->dev->resetting) {\n       pvscsi_req->cmp.hostStatus = BTSTAT_BUSRESET;\n    } else {\n       pvscsi_req->cmp.hostStatus = BTSTAT_ABORTQUEUE;\n    }\n\n    pvscsi_complete_request(s, pvscsi_req);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187898, "func": "u32 h264bsdInit(storage_t *pStorage, u32 noOutputReordering)\n{\n\n    u32 size;\n\n    ASSERT(pStorage);\n\n    h264bsdInitStorage(pStorage);\n\n     size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;\n \n    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);\n     if (!pStorage->mbLayer)\n         return HANTRO_NOK;\n \n if (noOutputReordering)\n        pStorage->noReordering = HANTRO_TRUE;\n\n return HANTRO_OK;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 8453, "func": "pvscsi_ring_pop_cmp_descr(PVSCSIRingInfo *mgr)\n{\n\n    uint32_t free_cmp_ptr =\n        mgr->filled_cmp_ptr++ & mgr->rxr_len_mask;\n    uint32_t free_cmp_page =\n        free_cmp_ptr / PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n    uint32_t inpage_idx =\n        free_cmp_ptr % PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n    return mgr->cmp_ring_pages_pa[free_cmp_page] +\n           inpage_idx * sizeof(PVSCSIRingCmpDesc);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8397, "func": "void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,\n                    unsigned int len, unsigned int idx)\n{\n    VRingUsedElem uelem;\n\n    trace_virtqueue_fill(vq, elem, len, idx);\n\n    virtqueue_unmap_sg(vq, elem, len);\n\n    idx = (idx + vq->used_idx) % vq->vring.num;\n\n    uelem.id = elem->index;\n    uelem.len = len;\n    vring_used_write(vq, &uelem, idx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8500, "func": "DWORD CSoundFile::TransposeToFrequency(int transp, int ftune)\n{\n\treturn (DWORD)(8363*pow(2.0, (transp*128+ftune)/(1536)));\n\n#ifdef MSC_VER\n\tconst float _fbase = 8363;\n\tconst float _factor = 1.0f/(12.0f*128.0f);\n\tint result;\n\tDWORD freq;\n\n\ttransp = (transp << 7) + ftune;\n\t_asm {\n\tfild transp\n\tfld _factor\n\tfmulp st(1), st(0)\n\tfist result\n\tfisub result\n\tf2xm1\n\tfild result\n\tfld _fbase\n\tfscale\n\tfstp st(1)\n\tfmul st(1), st(0)\n\tfaddp st(1), st(0)\n\tfistp freq\n\t}\n\tUINT derr = freq % 11025;\n\tif (derr <= 8) freq -= derr;\n\tif (derr >= 11015) freq += 11025-derr;\n\tderr = freq % 1000;\n\tif (derr <= 5) freq -= derr;\n\tif (derr >= 995) freq += 1000-derr;\n\treturn freq;\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8796, "func": "static inline GLenum convert_min_filter(unsigned int filter, unsigned int mip_filter)\n{\n   if (mip_filter == PIPE_TEX_MIPFILTER_NONE)\n      return convert_mag_filter(filter);\n   else if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {\n      if (filter == PIPE_TEX_FILTER_NEAREST)\n         return GL_NEAREST_MIPMAP_LINEAR;\n      else\n         return GL_LINEAR_MIPMAP_LINEAR;\n   } else if (mip_filter == PIPE_TEX_MIPFILTER_NEAREST) {\n      if (filter == PIPE_TEX_FILTER_NEAREST)\n         return GL_NEAREST_MIPMAP_NEAREST;\n      else\n         return GL_LINEAR_MIPMAP_NEAREST;\n   }\n   assert(0);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8543, "func": "static void ssh2_pkt_defer_noqueue(Ssh ssh, struct Packet *pkt, int noignore)\n{\n    int len;\n    if (ssh->cscipher != NULL && (ssh->cscipher->flags & SSH_CIPHER_IS_CBC) &&\n\tssh->deferred_len == 0 && !noignore &&\n\t!(ssh->remote_bugs & BUG_CHOKES_ON_SSH2_IGNORE)) {\n\tstruct Packet *ipkt = ssh2_pkt_init(SSH2_MSG_IGNORE);\n\tssh2_pkt_addstring_start(ipkt);\n\tssh2_pkt_defer_noqueue(ssh, ipkt, TRUE);\n    }\n    len = ssh2_pkt_construct(ssh, pkt);\n    if (ssh->deferred_len + len > ssh->deferred_size) {\n\tssh->deferred_size = ssh->deferred_len + len + 128;\n\tssh->deferred_send_data = sresize(ssh->deferred_send_data,\n\t\t\t\t\t  ssh->deferred_size,\n\t\t\t\t\t  unsigned char);\n    }\n    memcpy(ssh->deferred_send_data + ssh->deferred_len, pkt->body, len);\n    ssh->deferred_len += len;\n    ssh->deferred_data_size += pkt->encrypted_len;\n    ssh_free_packet(pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9157, "func": "static GLuint blit_build_frag_tex_col(struct vrend_blitter_ctx *blit_ctx, int tgsi_tex_target)\n{\n   GLuint fs_id;\n   char shader_buf[4096];\n   int is_shad;\n   const char *twm;\n   const char *ext_str = \"\";\n   switch (tgsi_tex_target) {\n   case TGSI_TEXTURE_1D:\n   case TGSI_TEXTURE_BUFFER:\n      twm = \".x\";\n      break;\n   case TGSI_TEXTURE_1D_ARRAY:\n   case TGSI_TEXTURE_2D:\n   case TGSI_TEXTURE_RECT:\n   case TGSI_TEXTURE_2D_MSAA:\n   default:\n      twm = \".xy\";\n      break;\n   case TGSI_TEXTURE_SHADOW1D:\n   case TGSI_TEXTURE_SHADOW2D:\n   case TGSI_TEXTURE_SHADOW1D_ARRAY:\n   case TGSI_TEXTURE_SHADOWRECT:\n   case TGSI_TEXTURE_3D:\n   case TGSI_TEXTURE_CUBE:\n   case TGSI_TEXTURE_2D_ARRAY:\n   case TGSI_TEXTURE_2D_ARRAY_MSAA:\n      twm = \".xyz\";\n      break;\n   case TGSI_TEXTURE_SHADOWCUBE:\n   case TGSI_TEXTURE_SHADOW2D_ARRAY:\n   case TGSI_TEXTURE_SHADOWCUBE_ARRAY:\n   case TGSI_TEXTURE_CUBE_ARRAY:\n      twm = \"\";\n      break;\n   }\n\n   if (tgsi_tex_target == TGSI_TEXTURE_CUBE_ARRAY ||\n       tgsi_tex_target == TGSI_TEXTURE_SHADOWCUBE_ARRAY)\n      ext_str = \"#extension GL_ARB_texture_cube_map_array : require\\n\";\n\n   snprintf(shader_buf, 4096, FS_TEXFETCH_COL, ext_str, vrend_shader_samplertypeconv(tgsi_tex_target, &is_shad), twm, \"\");\n\n   fs_id = glCreateShader(GL_FRAGMENT_SHADER);\n\n   if (!build_and_check(fs_id, shader_buf)) {\n      glDeleteShader(fs_id);\n      return 0;\n   }\n\n   return fs_id;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188188, "func": " status_t NuPlayer::GenericSource::setBuffers(\n         bool audio, Vector<MediaBuffer *> &buffers) {\n    if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {\n         return mVideoTrack.mSource->setBuffers(buffers);\n     }\n     return INVALID_OPERATION;\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8659, "func": "static size_t mptsas_config_pack_ext(uint8_t **data, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vpack(data, fmt, ap);\n    va_end(ap);\n\n    if (data) {\n        assert(ret < 65536 && (ret % 4) == 0);\n        stw_le_p(*data + 4, ret / 4);\n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8869, "func": "static bool vrend_get_one_query_result(GLuint query_id, bool use_64, uint64_t *result)\n{\n   GLint ready;\n   GLuint passed;\n   GLuint64 pass64;\n\n   glGetQueryObjectiv(query_id, GL_QUERY_RESULT_AVAILABLE_ARB, &ready);\n\n   if (!ready)\n      return false;\n\n   if (use_64) {\n      glGetQueryObjectui64v(query_id, GL_QUERY_RESULT_ARB, &pass64);\n      *result = pass64;\n   } else {\n      glGetQueryObjectuiv(query_id, GL_QUERY_RESULT_ARB, &passed);\n      *result = passed;\n   }\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8965, "func": "void net_tx_pkt_reset(struct NetTxPkt *pkt)\n{\n    int i;\n\n    if (!pkt) {\n        return;\n    }\n\n    memset(&pkt->virt_hdr, 0, sizeof(pkt->virt_hdr));\n\n    assert(pkt->vec);\n\n    pkt->payload_len = 0;\n    pkt->payload_frags = 0;\n\n    assert(pkt->raw);\n    for (i = 0; i < pkt->raw_frags; i++) {\n        assert(pkt->raw[i].iov_base);\n        pci_dma_unmap(pkt->pci_dev, pkt->raw[i].iov_base, pkt->raw[i].iov_len,\n                      DMA_DIRECTION_TO_DEVICE, 0);\n    }\n    pkt->raw_frags = 0;\n\n    pkt->hdr_len = 0;\n    pkt->l4proto = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187899, "func": "status_t BnGraphicBufferConsumer::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n case ACQUIRE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n BufferItem item;\n int64_t presentWhen = data.readInt64();\n uint64_t maxFrameNumber = data.readUint64();\n status_t result = acquireBuffer(&item, presentWhen, maxFrameNumber);\n status_t err = reply->write(item);\n if (err) return err;\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n int slot = data.readInt32();\n int result = detachBuffer(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case ATTACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<GraphicBuffer> buffer = new GraphicBuffer();\n            data.read(*buffer.get());\n int slot = -1;\n int result = attachBuffer(&slot, buffer);\n            reply->writeInt32(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case RELEASE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n int buf = data.readInt32();\n uint64_t frameNumber = static_cast<uint64_t>(data.readInt64());\n            sp<Fence> releaseFence = new Fence();\n status_t err = data.read(*releaseFence);\n if (err) return err;\n status_t result = releaseBuffer(buf, frameNumber,\n                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case CONSUMER_CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );\n bool controlledByApp = data.readInt32();\n status_t result = consumerConnect(consumer, controlledByApp);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case CONSUMER_DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n status_t result = consumerDisconnect();\n            reply->writeInt32(result);\n return NO_ERROR;\n\n         }\n         case GET_RELEASED_BUFFERS: {\n             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint64_t slotMask;\n             status_t result = getReleasedBuffers(&slotMask);\n             reply->writeInt64(static_cast<int64_t>(slotMask));\n             reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_DEFAULT_BUFFER_SIZE: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t width = data.readUint32();\n uint32_t height = data.readUint32();\n status_t result = setDefaultBufferSize(width, height);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_DEFAULT_MAX_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n int bufferCount = data.readInt32();\n status_t result = setDefaultMaxBufferCount(bufferCount);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DISABLE_ASYNC_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n status_t result = disableAsyncBuffer();\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_MAX_ACQUIRED_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n int maxAcquiredBuffers = data.readInt32();\n status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            setConsumerName( data.readString8() );\n return NO_ERROR;\n }\n case SET_DEFAULT_BUFFER_FORMAT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n PixelFormat defaultFormat = static_cast<PixelFormat>(data.readInt32());\n status_t result = setDefaultBufferFormat(defaultFormat);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_DEFAULT_BUFFER_DATA_SPACE: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            android_dataspace defaultDataSpace =\n static_cast<android_dataspace>(data.readInt32());\n status_t result = setDefaultBufferDataSpace(defaultDataSpace);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_CONSUMER_USAGE_BITS: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t usage = data.readUint32();\n status_t result = setConsumerUsageBits(usage);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_TRANSFORM_HINT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t hint = data.readUint32();\n status_t result = setTransformHint(hint);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case GET_SIDEBAND_STREAM: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<NativeHandle> stream = getSidebandStream();\n            reply->writeInt32(static_cast<int32_t>(stream != NULL));\n if (stream != NULL) {\n                reply->writeNativeHandle(stream->handle());\n }\n return NO_ERROR;\n }\n case DUMP: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n String8 result = data.readString8();\n String8 prefix = data.readString8();\n static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);\n            reply->writeString8(result);\n return NO_ERROR;\n }\n }\n return BBinder::onTransact(code, data, reply, flags);\n}\n", "target": 1, "flaw_line_index": "62"}
{"idx": 8984, "func": "vmxnet3_dump_conf_descr(const char *name,\n                        struct Vmxnet3_VariableLenConfDesc *pm_descr)\n{\n    VMW_CFPRN(\"%s descriptor dump: Version %u, Length %u\",\n              name, pm_descr->confVer, pm_descr->confLen);\n\n};\n", "target": 0, "flaw_line_index": ""}
{"idx": 188111, "func": "VOID ixheaacd_shiftrountine_with_rnd_hq(WORD32 *qmf_real, WORD32 *qmf_imag,\n                                        WORD32 *filter_states, WORD32 len,\n                                        WORD32 shift) {\n  WORD32 *filter_states_rev = filter_states + len;\n  WORD32 treal, timag;\n  WORD32 j;\n\n for (j = (len - 1); j >= 0; j -= 2) {\n    WORD32 r1, r2, i1, i2;\n    i2 = qmf_imag[j];\n    r2 = qmf_real[j];\n\n     r1 = *qmf_real++;\n     i1 = *qmf_imag++;\n \n    timag = ixheaacd_add32(i1, r1);\n     timag = (ixheaacd_shl32_sat(timag, shift));\n     filter_states_rev[j] = timag;\n \n    treal = ixheaacd_sub32(i2, r2);\n     treal = (ixheaacd_shl32_sat(treal, shift));\n     filter_states[j] = treal;\n \n    treal = ixheaacd_sub32(i1, r1);\n     treal = (ixheaacd_shl32_sat(treal, shift));\n     *filter_states++ = treal;\n \n    timag = ixheaacd_add32(i2, r2);\n     timag = (ixheaacd_shl32_sat(timag, shift));\n     *filter_states_rev++ = timag;\n   }\n}\n", "target": 1, "flaw_line_index": "16,20,24,28"}
{"idx": 8843, "func": "static void vrend_destroy_sampler_view(struct vrend_sampler_view *samp)\n{\n   vrend_resource_reference(&samp->texture, NULL);\n   free(samp);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187508, "func": "ssize_t socket_read(const socket_t *socket, void *buf, size_t count) {\n\n   assert(socket != NULL);\n   assert(buf != NULL);\n \n  return recv(socket->fd, buf, count, MSG_DONTWAIT);\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 188503, "func": "static void encode_frame(vpx_codec_ctx_t *codec,\n                         vpx_image_t *img,\n                         int frame_index,\n                         VpxVideoWriter *writer) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,\n                                               VPX_DL_GOOD_QUALITY);\n if (res != VPX_CODEC_OK)\n\n     die_codec(codec, \"Failed to encode frame\");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n                                        pkt->data.frame.buf,\n                                        pkt->data.frame.sz,\n                                        pkt->data.frame.pts)) {\n        die_codec(codec, \"Failed to write compressed frame\");\n }\n\n      printf(keyframe ? \"K\" : \".\");\n\n       fflush(stdout);\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 187676, "func": " image_transform_png_set_tRNS_to_alpha_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n \n   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;\n }\n", "target": 1, "flaw_line_index": "2,10"}
{"idx": 188551, "func": "void fdct16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct16x16_c(in, out, stride);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8582, "func": "static int ssh_portcmp(void *av, void *bv)\n{\n    struct ssh_portfwd *a = (struct ssh_portfwd *) av;\n    struct ssh_portfwd *b = (struct ssh_portfwd *) bv;\n    int i;\n    if (a->type > b->type)\n\treturn +1;\n    if (a->type < b->type)\n\treturn -1;\n    if (a->addressfamily > b->addressfamily)\n\treturn +1;\n    if (a->addressfamily < b->addressfamily)\n\treturn -1;\n    if ( (i = nullstrcmp(a->saddr, b->saddr)) != 0)\n\treturn i < 0 ? -1 : +1;\n    if (a->sport > b->sport)\n\treturn +1;\n    if (a->sport < b->sport)\n\treturn -1;\n    if (a->type != 'D') {\n\tif ( (i = nullstrcmp(a->daddr, b->daddr)) != 0)\n\t    return i < 0 ? -1 : +1;\n\tif (a->dport > b->dport)\n\t    return +1;\n\tif (a->dport < b->dport)\n\t    return -1;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9064, "func": "static void vmxnet3_setup_rx_filtering(VMXNET3State *s)\n{\n    vmxnet3_update_rx_mode(s);\n    vmxnet3_update_vlan_filters(s);\n    vmxnet3_update_mcast_filters(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188579, "func": "void fdct4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct4x4_c(in, out, stride);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8692, "func": "rewrite_shorthand_url (const char *url)\n{\n  const char *p;\n  char *ret;\n\n  if (url_scheme (url) != SCHEME_INVALID)\n    return NULL;\n\n  p = strpbrk (url, \":/\");\n  if (p == url)\n    return NULL;\n\n  /* If we're looking at \":\n     don't support, which may include \"https\" when compiled without\n  if (p && p[0] == ':' && p[1] == '/' && p[2] == '/')\n    return NULL;\n\n  if (p && *p == ':')\n    {\n      int digits = strspn (p + 1, \"0123456789\");\n      if (digits && (p[1 + digits] == '/' || p[1 + digits] == '\\0'))\n        goto http;\n\n      /* Turn \"foo.bar.com:path\" to \"ftp:\n      if ((ret = aprintf (\"ftp:\n        ret[6 + (p - url)] = '/';\n    }\n  else\n    {\n    http:\n      /* Just prepend \"http:\n      ret = aprintf (\"http:\n    }\n  return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187744, "func": "int main(int argc, char *argv[])\n{\n FILE *fp_rd = stdin;\n FILE *fp_wr = stdout;\n FILE *fp_al = NULL;\n  BOOL raw = TRUE;\n  BOOL alpha = FALSE;\n int argi;\n\n for (argi = 1; argi < argc; argi++)\n {\n if (argv[argi][0] == '-')\n {\n switch (argv[argi][1])\n {\n case 'n':\n          raw = FALSE;\n break;\n case 'r':\n          raw = TRUE;\n break;\n case 'a':\n          alpha = TRUE;\n          argi++;\n\n           if ((fp_al = fopen (argv[argi], \"wb\")) == NULL)\n           {\n             fprintf (stderr, \"PNM2PNG\\n\");\n            fprintf (stderr, \"Error:  can not create alpha-channel file %s\\n\", argv[argi]);\n             exit (1);\n           }\n           break;\n case 'h':\n case '?':\n          usage();\n          exit(0);\n break;\n default:\n          fprintf (stderr, \"PNG2PNM\\n\");\n          fprintf (stderr, \"Error:  unknown option %s\\n\", argv[argi]);\n          usage();\n          exit(1);\n break;\n } \n }\n else if (fp_rd == stdin)\n {\n if ((fp_rd = fopen (argv[argi], \"rb\")) == NULL)\n {\n             fprintf (stderr, \"PNG2PNM\\n\");\n            fprintf (stderr, \"Error:  file %s does not exist\\n\", argv[argi]);\n            exit (1);\n }\n }\n else if (fp_wr == stdout)\n {\n if ((fp_wr = fopen (argv[argi], \"wb\")) == NULL)\n {\n        fprintf (stderr, \"PNG2PNM\\n\");\n        fprintf (stderr, \"Error:  can not create file %s\\n\", argv[argi]);\n        exit (1);\n }\n }\n else\n {\n      fprintf (stderr, \"PNG2PNM\\n\");\n      fprintf (stderr, \"Error:  too many parameters\\n\");\n      usage();\n      exit(1);\n }\n } \n\n#ifdef __TURBOC__\n if (fp_rd == stdin)\n {\n    setmode (STDIN, O_BINARY);\n }\n if ((raw) && (fp_wr == stdout))\n {\n    setmode (STDOUT, O_BINARY);\n }\n#endif\n\n if (png2pnm (fp_rd, fp_wr, fp_al, raw, alpha) == FALSE)\n {\n    fprintf (stderr, \"PNG2PNM\\n\");\n    fprintf (stderr, \"Error:  unsuccessful conversion of PNG-image\\n\");\n    exit(1);\n }\n\n  fclose (fp_rd);\n  fclose (fp_wr);\n if (alpha)\n    fclose (fp_al);\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "29"}
{"idx": 8458, "func": "pvscsi_update_irq_status(PVSCSIState *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    bool should_raise = s->reg_interrupt_enabled & s->reg_interrupt_status;\n\n    trace_pvscsi_update_irq_level(should_raise, s->reg_interrupt_enabled,\n                                  s->reg_interrupt_status);\n\n    if (msi_enabled(d)) {\n        if (should_raise) {\n            trace_pvscsi_update_irq_msi();\n            msi_notify(d, PVSCSI_VECTOR_COMPLETION);\n        }\n        return;\n    }\n\n    pci_set_irq(d, !!should_raise);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188207, "func": "status_t BnOMX::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case LIVES_LOCALLY:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n return OK;\n }\n\n case LIST_NODES:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n }\n }\n\n return NO_ERROR;\n }\n\n case ALLOCATE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n if (err == OK) {\n                reply->writeInt32((int32_t)node);\n }\n\n return NO_ERROR;\n }\n\n case FREE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n return NO_ERROR;\n }\n\n case SEND_COMMAND:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n return NO_ERROR;\n }\n\n case GET_PARAMETER:\n case SET_PARAMETER:\n case GET_CONFIG:\n case SET_CONFIG:\n case SET_INTERNAL_OPTION:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n \n             size_t size = data.readInt64();\n \n            status_t err = NO_MEMORY;\n            void *params = calloc(size, 1);\n            if (params) {\n                err = data.read(params, size);\n                if (err != OK) {\n                    android_errorWriteLog(0x534e4554, \"26914474\");\n                 } else {\n                    switch (code) {\n                        case GET_PARAMETER:\n                            err = getParameter(node, index, params, size);\n                            break;\n                        case SET_PARAMETER:\n                            err = setParameter(node, index, params, size);\n                            break;\n                        case GET_CONFIG:\n                            err = getConfig(node, index, params, size);\n                            break;\n                        case SET_CONFIG:\n                            err = setConfig(node, index, params, size);\n                            break;\n                        case SET_INTERNAL_OPTION:\n                        {\n                            InternalOptionType type =\n                                (InternalOptionType)data.readInt32();\n \n                            err = setInternalOption(node, index, type, params, size);\n                            break;\n                         }\n                        default:\n                            TRESPASS();\n                     }\n                 }\n             }\n \n            reply->writeInt32(err);\n\n if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n\n                 reply->write(params, size);\n             }\n \n            free(params);\n             params = NULL;\n \n             return NO_ERROR;\n }\n\n case GET_STATE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case ENABLE_GRAPHIC_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case GET_GRAPHIC_BUFFER_USAGE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n return NO_ERROR;\n }\n\n case USE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = useBuffer(node, port_index, params, &buffer, allottedSize);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case USE_GRAPHIC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case UPDATE_GRAPHIC_BUFFER_IN_META:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CREATE_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferProducer> bufferProducer;\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = createInputSurface(node, port_index, &bufferProducer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n }\n\n return NO_ERROR;\n }\n\n case CREATE_PERSISTENT_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            sp<IGraphicBufferProducer> bufferProducer;\n            sp<IGraphicBufferConsumer> bufferConsumer;\n status_t err = createPersistentInputSurface(\n &bufferProducer, &bufferConsumer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n                reply->writeStrongBinder(IInterface::asBinder(bufferConsumer));\n }\n\n return NO_ERROR;\n }\n\n case SET_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferConsumer> bufferConsumer =\n                    interface_cast<IGraphicBufferConsumer>(data.readStrongBinder());\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = setInputSurface(node, port_index, bufferConsumer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n return NO_ERROR;\n }\n\n case SIGNAL_END_OF_INPUT_STREAM:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case STORE_META_DATA_IN_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = storeMetaDataInBuffers(node, port_index, enable, &type);\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CONFIGURE_VIDEO_TUNNEL_MODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n            OMX_U32 audio_hw_sync = data.readInt32();\n\n native_handle_t *sideband_handle = NULL;\n status_t err = configureVideoTunnelMode(\n                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n            reply->writeInt32(err);\n if(err == OK){\n                reply->writeNativeHandle(sideband_handle);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n if (!isSecure(node) || port_index != 0 \n) {\n                ALOGE(\"b/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n return NO_ERROR;\n }\n\n size_t size = data.readInt64();\n\n            buffer_id buffer;\n void *buffer_data;\n status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER_WITH_BACKUP:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer, allottedSize);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case FREE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n return NO_ERROR;\n }\n\n case FILL_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(fillBuffer(node, buffer, fenceFd));\n\n return NO_ERROR;\n }\n\n case EMPTY_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(emptyBuffer(\n                    node, buffer, range_offset, range_length, flags, timestamp, fenceFd));\n\n return NO_ERROR;\n }\n\n case GET_EXTENSION_INDEX:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32(index);\n }\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "97,98,99,100,101,102,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,122,123,125,126,138"}
{"idx": 8430, "func": "pvscsi_on_command(PVSCSIState *s, uint64_t cmd_id)\n{\n    if ((cmd_id > PVSCSI_CMD_FIRST) && (cmd_id < PVSCSI_CMD_LAST)) {\n        s->curr_cmd = cmd_id;\n    } else {\n        s->curr_cmd = PVSCSI_CMD_FIRST;\n        trace_pvscsi_on_cmd_unknown(cmd_id);\n    }\n\n    s->curr_cmd_data_cntr = 0;\n    s->reg_command_status = PVSCSI_COMMAND_NOT_ENOUGH_DATA;\n\n    pvscsi_do_command_processing(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8481, "func": "UINT CSoundFile::GetNumInstruments() const\n{\n\tUINT n=0;\n\tfor (UINT i=0; i<MAX_INSTRUMENTS; i++) if (Ins[i].pSample) n++;\n\treturn n;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187730, "func": "store_pool_error(png_store *ps, png_const_structp pp, PNG_CONST char *msg)\n {\n    if (pp != NULL)\n       png_error(pp, msg);\n\n   store_log(ps, pp, msg, 1 \n);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8878, "func": "static void vrend_init_pstipple_texture(struct vrend_context *ctx)\n{\n   glGenTextures(1, &ctx->pstipple_tex_id);\n   glBindTexture(GL_TEXTURE_2D, ctx->pstipple_tex_id);\n   glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, 32, 32, 0, GL_RED, GL_UNSIGNED_BYTE, NULL);\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n   ctx->pstip_inited = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8513, "func": "static int do_ssh_connection_init(Ssh ssh, unsigned char c)\n{\n    static const char protoname[] =\n        \"SSHCONNECTION@putty.projects.tartarus.org-\";\n\n    struct do_ssh_connection_init_state {\n\tint crLine;\n\tint vslen;\n\tchar version[10];\n\tchar *vstring;\n\tint vstrsize;\n\tint i;\n    };\n    crState(do_ssh_connection_init_state);\n    \n    crBeginState;\n\n    for (;;) {\n        for (s->i = 0; protoname[s->i]; s->i++) {\n            if ((char)c != protoname[s->i]) goto no;\n            crReturn(1);\n        }\n\tbreak;\n      no:\n\twhile (c != '\\012')\n\t    crReturn(1);\n\tcrReturn(1);\n    }\n\n    s->vstrsize = sizeof(protoname) + 16;\n    s->vstring = snewn(s->vstrsize, char);\n    strcpy(s->vstring, protoname);\n    s->vslen = strlen(protoname);\n    s->i = 0;\n    while (1) {\n\tif (s->vslen >= s->vstrsize - 1) {\n\t    s->vstrsize += 16;\n\t    s->vstring = sresize(s->vstring, s->vstrsize, char);\n\t}\n\ts->vstring[s->vslen++] = c;\n\tif (s->i >= 0) {\n\t    if (c == '-') {\n\t\ts->version[s->i] = '\\0';\n\t\ts->i = -1;\n\t    } else if (s->i < sizeof(s->version) - 1)\n\t\ts->version[s->i++] = c;\n\t} else if (c == '\\012')\n\t    break;\n\tcrReturn(1);\t\t       \n    }\n\n    ssh->agentfwd_enabled = FALSE;\n    ssh->rdpkt2_bare_state.incoming_sequence = 0;\n\n    s->vstring[s->vslen] = 0;\n    s->vstring[strcspn(s->vstring, \"\\015\\012\")] = '\\0';\n    logeventf(ssh, \"Server version: %s\", s->vstring);\n    ssh_detect_bugs(ssh, s->vstring);\n\n    if (ssh_versioncmp(s->version, \"2.0\") < 0) {\n\tbombout((\"Server announces compatibility with SSH-1 in bare ssh-connection protocol\"));\n        crStop(0);\n    }\n    if (conf_get_int(ssh->conf, CONF_sshprot) == 0) {\n\tbombout((\"Bare ssh-connection protocol cannot be run in SSH-1-only mode\"));\n\tcrStop(0);\n    }\n\n    ssh->version = 2;\n\n    logeventf(ssh, \"Using bare ssh-connection protocol\");\n\n    ssh_send_verstring(ssh, protoname, s->version);\n\n    ssh->protocol = ssh2_bare_connection_protocol;\n    ssh2_bare_connection_protocol_setup(ssh);\n    ssh->s_rdpkt = ssh2_bare_connection_rdpkt;\n\n    update_specials_menu(ssh->frontend);\n    ssh->state = SSH_STATE_BEFORE_SIZE;\n    ssh->pinger = pinger_new(ssh->conf, &ssh_backend, ssh);\n\n    do_ssh2_authconn(ssh, NULL, 0, NULL);\n\n    sfree(s->vstring);\n\n    crFinish(0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9216, "func": "hwaddr virtio_queue_get_desc_size(VirtIODevice *vdev, int n)\n{\n    return sizeof(VRingDesc) * vdev->vq[n].vring.num;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8599, "func": "int agent_exists(void)\n{\n    HWND hwnd;\n    hwnd = FindWindow(\"Pageant\", \"Pageant\");\n    if (!hwnd)\n\treturn FALSE;\n    else\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8656, "func": "size_t mptsas_config_manufacturing_8(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(8, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188155, "func": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n\n         OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexInput);\n     if (header == NULL) {\n         ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    sp<ABuffer> backup = buffer_meta->getBuffer(header, true \n);\n    sp<ABuffer> codec = buffer_meta->getBuffer(header, false \n);\n\n if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource\n && backup->capacity() >= sizeof(VideoNativeMetadata)\n && codec->capacity() >= sizeof(VideoGrallocMetadata)\n && ((VideoNativeMetadata *)backup->base())->eType\n == kMetadataBufferTypeANWBuffer) {\n VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();\n VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();\n        CLOG_BUFFER(emptyBuffer, \"converting ANWB %p to handle %p\",\n                backupMeta.pBuffer, backupMeta.pBuffer->handle);\n        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;\n        codecMeta.eType = kMetadataBufferTypeGrallocSource;\n        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;\n        header->nOffset = 0;\n } else {\n if (rangeOffset > header->nAllocLen\n || rangeLength > header->nAllocLen - rangeOffset) {\n            CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));\n if (fenceFd >= 0) {\n ::close(fenceFd);\n }\n return BAD_VALUE;\n }\n        header->nFilledLen = rangeLength;\n        header->nOffset = rangeOffset;\n\n        buffer_meta->CopyToOMX(header);\n }\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188141, "func": "xmlParse3986Port(xmlURIPtr uri, const char **str)\n{\n const char *cur = *str;\n unsigned port = 0; \n\n if (ISA_DIGIT(cur)) {\n while (ISA_DIGIT(cur)) {\n\t    port = port * 10 + (*cur - '0');\n\n\n \t    cur++;\n \t}\n \tif (uri != NULL)\n\t    uri->port = port & INT_MAX; \n \t*str = cur;\n \treturn(0);\n     }\n return(1);\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 8859, "func": "void vrend_fb_bind_texture(struct vrend_resource *res,\n                           int idx,\n                           uint32_t level, uint32_t layer)\n{\n   const struct util_format_description *desc = util_format_description(res->base.format);\n   GLenum attachment = GL_COLOR_ATTACHMENT0_EXT + idx;\n\n   if (vrend_format_is_ds(res->base.format)) { {\n         if (util_format_has_stencil(desc)) {\n            if (util_format_has_depth(desc))\n               attachment = GL_DEPTH_STENCIL_ATTACHMENT;\n            else\n               attachment = GL_STENCIL_ATTACHMENT;\n         } else\n            attachment = GL_DEPTH_ATTACHMENT;\n      }\n   }\n\n   switch (res->target) {\n   case GL_TEXTURE_1D_ARRAY:\n   case GL_TEXTURE_2D_ARRAY:\n   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:\n   case GL_TEXTURE_CUBE_MAP_ARRAY:\n      if (layer == 0xffffffff)\n         glFramebufferTexture(GL_FRAMEBUFFER_EXT, attachment,\n                              res->id, level);\n      else\n         glFramebufferTextureLayer(GL_FRAMEBUFFER_EXT, attachment,\n                                   res->id, level, layer);\n      break;\n   case GL_TEXTURE_3D:\n      if (layer == 0xffffffff)\n         glFramebufferTexture(GL_FRAMEBUFFER_EXT, attachment,\n                              res->id, level);\n      else\n         glFramebufferTexture3DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                   res->target, res->id, level, layer);\n      break;\n   case GL_TEXTURE_CUBE_MAP:\n      if (layer == 0xffffffff)\n         glFramebufferTexture(GL_FRAMEBUFFER_EXT, attachment,\n                              res->id, level);\n      else\n         glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                   GL_TEXTURE_CUBE_MAP_POSITIVE_X + layer, res->id, level);\n      break;\n   case GL_TEXTURE_1D:\n      glFramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                res->target, res->id, level);\n      break;\n   case GL_TEXTURE_2D:\n   default:\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                res->target, res->id, level);\n      break;\n   }\n\n   if (attachment == GL_DEPTH_ATTACHMENT) {\n      switch (res->target) {\n      case GL_TEXTURE_1D:\n         glFramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT,\n                                   GL_TEXTURE_1D, 0, 0);\n         break;\n      case GL_TEXTURE_2D:\n      default:\n         glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT,\n                                   GL_TEXTURE_2D, 0, 0);\n         break;\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187503, "func": "static void inbound_data_waiting(void *context) {\n eager_reader_t *reader = (eager_reader_t *)context;\n\n data_buffer_t *buffer = (data_buffer_t *)reader->allocator->alloc(reader->buffer_size + sizeof(data_buffer_t));\n if (!buffer) {\n    LOG_ERROR(\"%s couldn't aquire memory for inbound data buffer.\", __func__);\n return;\n }\n\n\n   buffer->length = 0;\n   buffer->offset = 0;\n \n  int bytes_read = read(reader->inbound_fd, buffer->data, reader->buffer_size);\n   if (bytes_read > 0) {\n     buffer->length = bytes_read;\n    fixed_queue_enqueue(reader->buffers, buffer);\n\n    eventfd_write(reader->bytes_available_fd, bytes_read);\n } else {\n if (bytes_read == 0)\n      LOG_WARN(\"%s fd said bytes existed, but none were found.\", __func__);\n else\n      LOG_WARN(\"%s unable to read from file descriptor: %s\", __func__, strerror(errno));\n\n    reader->allocator->free(buffer);\n }\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 8491, "func": "void CSoundFile::ResetChannels()\n{\n\tm_dwSongFlags &= ~(SONG_CPUVERYHIGH|SONG_FADINGSONG|SONG_ENDREACHED|SONG_GLOBALFADE);\n\tm_nBufferCount = 0;\n\tfor (UINT i=0; i<MAX_CHANNELS; i++)\n\t{\n\t\tChn[i].nROfs = Chn[i].nLOfs = 0;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8964, "func": "static void net_tx_pkt_rebuild_payload(struct NetTxPkt *pkt)\n{\n    pkt->payload_len = iov_size(pkt->raw, pkt->raw_frags) - pkt->hdr_len;\n    pkt->payload_frags = iov_copy(&pkt->vec[NET_TX_PKT_PL_START_FRAG],\n                                pkt->max_payload_frags,\n                                pkt->raw, pkt->raw_frags,\n                                pkt->hdr_len, pkt->payload_len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8915, "func": "void vrend_renderer_resource_destroy(struct vrend_resource *res, bool remove)\n{\n   if (res->readback_fb_id)\n      glDeleteFramebuffers(1, &res->readback_fb_id);\n\n   if (res->ptr)\n      free(res->ptr);\n   if (res->id) {\n      if (res->target == GL_ELEMENT_ARRAY_BUFFER_ARB ||\n          res->target == GL_ARRAY_BUFFER_ARB ||\n          res->target == GL_UNIFORM_BUFFER||\n          res->target == GL_TEXTURE_BUFFER||\n          res->target == GL_TRANSFORM_FEEDBACK_BUFFER) {\n         glDeleteBuffers(1, &res->id);\n         if (res->target == GL_TEXTURE_BUFFER)\n            glDeleteTextures(1, &res->tbo_tex_id);\n      } else\n         glDeleteTextures(1, &res->id);\n   }\n\n   if (res->handle && remove)\n      vrend_resource_remove(res->handle);\n   free(res);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187916, "func": "void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n const IPCThreadState* ipc = IPCThreadState::self();\n const pid_t pid = ipc->getCallingPid();\n const uid_t uid = ipc->getCallingUid();\n if ((uid != AID_SHELL)\n && !PermissionCache::checkPermission(String16(\n\n             \"android.permission.DUMP\"), pid, uid)) {\n         result.appendFormat(\"Permission Denial: can't dump BufferQueueConsumer \"\n                 \"from pid=%d, uid=%d\\n\", pid, uid);\n     } else {\n         mCore->dump(result, prefix);\n     }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8670, "func": "static const MPTSASConfigPage *mptsas_find_config_page(int type, int number)\n{\n    const MPTSASConfigPage *page;\n    int i;\n\n    for (i = 0; i < ARRAY_SIZE(mptsas_config_pages); i++) {\n        page = &mptsas_config_pages[i];\n        if (page->type == type && page->number == number) {\n            return page;\n        }\n    }\n\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8666, "func": "size_t mptsas_config_sas_io_unit_1(MPTSASState *s, uint8_t **data, int address)\n{\n    size_t size = MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x07,\n                                         \"*w*w*w*wb*b*b*b\"\n                                         repl(MPTSAS_NUM_PORTS, \"*s12\"),\n                                         MPTSAS_NUM_PORTS);\n\n    if (data) {\n        size_t ofs = size - MPTSAS_NUM_PORTS * MPTSAS_CONFIG_SAS_IO_UNIT_1_SIZE;\n        int i;\n\n        for (i = 0; i < MPTSAS_NUM_PORTS; i++) {\n            SCSIDevice *dev = mptsas_phy_get_device(s, i, NULL, NULL);\n            fill(*data + ofs, MPTSAS_CONFIG_SAS_IO_UNIT_1_SIZE,\n                 \"bbbblww\", i, 0, 0,\n                 (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5,\n                 (dev\n                  ? MPI_SAS_DEVICE_INFO_END_DEVICE | MPI_SAS_DEVICE_INFO_SSP_TARGET\n                  : MPI_SAS_DEVICE_INFO_NO_DEVICE),\n                 0, 0);\n            ofs += MPTSAS_CONFIG_SAS_IO_UNIT_1_SIZE;\n        }\n        assert(ofs == size);\n    }\n    return size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187845, "func": "long Track::GetNext(const BlockEntry* pCurrEntry,\n const BlockEntry*& pNextEntry) const {\n  assert(pCurrEntry);\n  assert(!pCurrEntry->EOS()); \n\n const Block* const pCurrBlock = pCurrEntry->GetBlock();\n  assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);\n if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)\n return -1;\n\n const Cluster* pCluster = pCurrEntry->GetCluster();\n  assert(pCluster);\n  assert(!pCluster->EOS());\n\n long status = pCluster->GetNext(pCurrEntry, pNextEntry);\n\n if (status < 0) \n return status;\n\n for (int i = 0;;) {\n while (pNextEntry) {\n const Block* const pNextBlock = pNextEntry->GetBlock();\n      assert(pNextBlock);\n\n if (pNextBlock->GetTrackNumber() == m_info.number)\n return 0;\n\n      pCurrEntry = pNextEntry;\n\n      status = pCluster->GetNext(pCurrEntry, pNextEntry);\n\n if (status < 0) \n return status;\n }\n\n    pCluster = m_pSegment->GetNext(pCluster);\n\n if (pCluster == NULL) {\n      pNextEntry = GetEOS();\n return 1;\n\n     }\n \n     if (pCluster->EOS()) {\n#if 0\n            if (m_pSegment->Unparsed() <= 0)   \n            {\n                pNextEntry = GetEOS();\n                return 1;\n            }\n#else\n       if (m_pSegment->DoneParsing()) {\n         pNextEntry = GetEOS();\n         return 1;\n       }\n#endif\n \n\n      pNextEntry = NULL;\n return E_BUFFER_NOT_FULL;\n }\n\n    status = pCluster->GetFirst(pNextEntry);\n\n if (status < 0) \n return status;\n\n if (pNextEntry == NULL) \n continue;\n\n ++i;\n\n if (i >= 100)\n break;\n }\n\n\n  pNextEntry = GetEOS(); \n return 1;\n}\n", "target": 1, "flaw_line_index": "45,46,47,48,49,50,51,56"}
{"idx": 8625, "func": "static uint32_t vmsvga_value_read(void *opaque, uint32_t address)\n{\n    uint32_t caps;\n    struct vmsvga_state_s *s = opaque;\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    PixelFormat pf;\n    uint32_t ret;\n\n    switch (s->index) {\n    case SVGA_REG_ID:\n        ret = s->svgaid;\n        break;\n\n    case SVGA_REG_ENABLE:\n        ret = s->enable;\n        break;\n\n    case SVGA_REG_WIDTH:\n        ret = s->new_width ? s->new_width : surface_width(surface);\n        break;\n\n    case SVGA_REG_HEIGHT:\n        ret = s->new_height ? s->new_height : surface_height(surface);\n        break;\n\n    case SVGA_REG_MAX_WIDTH:\n        ret = SVGA_MAX_WIDTH;\n        break;\n\n    case SVGA_REG_MAX_HEIGHT:\n        ret = SVGA_MAX_HEIGHT;\n        break;\n\n    case SVGA_REG_DEPTH:\n        ret = (s->new_depth == 32) ? 24 : s->new_depth;\n        break;\n\n    case SVGA_REG_BITS_PER_PIXEL:\n    case SVGA_REG_HOST_BITS_PER_PIXEL:\n        ret = s->new_depth;\n        break;\n\n    case SVGA_REG_PSEUDOCOLOR:\n        ret = 0x0;\n        break;\n\n    case SVGA_REG_RED_MASK:\n        pf = qemu_default_pixelformat(s->new_depth);\n        ret = pf.rmask;\n        break;\n\n    case SVGA_REG_GREEN_MASK:\n        pf = qemu_default_pixelformat(s->new_depth);\n        ret = pf.gmask;\n        break;\n\n    case SVGA_REG_BLUE_MASK:\n        pf = qemu_default_pixelformat(s->new_depth);\n        ret = pf.bmask;\n        break;\n\n    case SVGA_REG_BYTES_PER_LINE:\n        if (s->new_width) {\n            ret = (s->new_depth * s->new_width) / 8;\n        } else {\n            ret = surface_stride(surface);\n        }\n        break;\n\n    case SVGA_REG_FB_START: {\n        struct pci_vmsvga_state_s *pci_vmsvga\n            = container_of(s, struct pci_vmsvga_state_s, chip);\n        ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 1);\n        break;\n    }\n\n    case SVGA_REG_FB_OFFSET:\n        ret = 0x0;\n        break;\n\n    case SVGA_REG_VRAM_SIZE:\n        ret = s->vga.vram_size; \n        break;\n\n    case SVGA_REG_FB_SIZE:\n        ret = s->vga.vram_size;\n        break;\n\n    case SVGA_REG_CAPABILITIES:\n        caps = SVGA_CAP_NONE;\n#ifdef HW_RECT_ACCEL\n        caps |= SVGA_CAP_RECT_COPY;\n#endif\n#ifdef HW_FILL_ACCEL\n        caps |= SVGA_CAP_RECT_FILL;\n#endif\n#ifdef HW_MOUSE_ACCEL\n        if (dpy_cursor_define_supported(s->vga.con)) {\n            caps |= SVGA_CAP_CURSOR | SVGA_CAP_CURSOR_BYPASS_2 |\n                    SVGA_CAP_CURSOR_BYPASS;\n        }\n#endif\n        ret = caps;\n        break;\n\n    case SVGA_REG_MEM_START: {\n        struct pci_vmsvga_state_s *pci_vmsvga\n            = container_of(s, struct pci_vmsvga_state_s, chip);\n        ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 2);\n        break;\n    }\n\n    case SVGA_REG_MEM_SIZE:\n        ret = s->fifo_size;\n        break;\n\n    case SVGA_REG_CONFIG_DONE:\n        ret = s->config;\n        break;\n\n    case SVGA_REG_SYNC:\n    case SVGA_REG_BUSY:\n        ret = s->syncing;\n        break;\n\n    case SVGA_REG_GUEST_ID:\n        ret = s->guest;\n        break;\n\n    case SVGA_REG_CURSOR_ID:\n        ret = s->cursor.id;\n        break;\n\n    case SVGA_REG_CURSOR_X:\n        ret = s->cursor.x;\n        break;\n\n    case SVGA_REG_CURSOR_Y:\n        ret = s->cursor.y;\n        break;\n\n    case SVGA_REG_CURSOR_ON:\n        ret = s->cursor.on;\n        break;\n\n    case SVGA_REG_SCRATCH_SIZE:\n        ret = s->scratch_size;\n        break;\n\n    case SVGA_REG_MEM_REGS:\n    case SVGA_REG_NUM_DISPLAYS:\n    case SVGA_REG_PITCHLOCK:\n    case SVGA_PALETTE_BASE ... SVGA_PALETTE_END:\n        ret = 0;\n        break;\n\n    default:\n        if (s->index >= SVGA_SCRATCH_BASE &&\n            s->index < SVGA_SCRATCH_BASE + s->scratch_size) {\n            ret = s->scratch[s->index - SVGA_SCRATCH_BASE];\n            break;\n        }\n        printf(\"%s: Bad register %02x\\n\", __func__, s->index);\n        ret = 0;\n        break;\n    }\n\n    if (s->index >= SVGA_SCRATCH_BASE) {\n        trace_vmware_scratch_read(s->index, ret);\n    } else if (s->index >= SVGA_PALETTE_BASE) {\n        trace_vmware_palette_read(s->index, ret);\n    } else {\n        trace_vmware_value_read(s->index, ret);\n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8354, "func": "static void mptsas_cancel_notify(Notifier *notifier, void *data)\n{\n    MPTSASCancelNotifier *n = container_of(notifier,\n                                           MPTSASCancelNotifier,\n                                           notifier);\n\n    if (++n->reply->TerminationCount == n->reply->IOCLogInfo) {\n        n->reply->IOCLogInfo = 0;\n        mptsas_fix_scsi_task_mgmt_reply_endianness(n->reply);\n        mptsas_post_reply(n->s, (MPIDefaultReply *)n->reply);\n        g_free(n->reply);\n    }\n    g_free(n);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187669, "func": "image_transform_png_set_scale_16_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_scale_16(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187914, "func": "status_t BnOMX::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case LIVES_LOCALLY:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n return OK;\n }\n\n case LIST_NODES:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n }\n }\n\n return NO_ERROR;\n }\n\n case ALLOCATE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n if (err == OK) {\n                reply->writeInt32((int32_t)node);\n }\n\n return NO_ERROR;\n }\n\n case FREE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n return NO_ERROR;\n }\n\n case SEND_COMMAND:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n return NO_ERROR;\n }\n\n case GET_PARAMETER:\n case SET_PARAMETER:\n case GET_CONFIG:\n case SET_CONFIG:\n case SET_INTERNAL_OPTION:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n size_t size = data.readInt64();\n\n void *params = malloc(size);\n            data.read(params, size);\n\n status_t err;\n switch (code) {\n case GET_PARAMETER:\n                    err = getParameter(node, index, params, size);\n break;\n case SET_PARAMETER:\n                    err = setParameter(node, index, params, size);\n break;\n case GET_CONFIG:\n                    err = getConfig(node, index, params, size);\n break;\n case SET_CONFIG:\n                    err = setConfig(node, index, params, size);\n break;\n case SET_INTERNAL_OPTION:\n {\n InternalOptionType type =\n (InternalOptionType)data.readInt32();\n\n                    err = setInternalOption(node, index, type, params, size);\n break;\n }\n\n default:\n                    TRESPASS();\n }\n\n            reply->writeInt32(err);\n\n if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n                reply->write(params, size);\n }\n\n            free(params);\n            params = NULL;\n\n return NO_ERROR;\n }\n\n case GET_STATE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case ENABLE_GRAPHIC_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case GET_GRAPHIC_BUFFER_USAGE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n return NO_ERROR;\n }\n\n case USE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = useBuffer(node, port_index, params, &buffer, allottedSize);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case USE_GRAPHIC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case UPDATE_GRAPHIC_BUFFER_IN_META:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CREATE_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n             OMX_U32 port_index = data.readInt32();\n \n             sp<IGraphicBufferProducer> bufferProducer;\n            MetadataBufferType type;\n             status_t err = createInputSurface(node, port_index, &bufferProducer, &type);\n \n             reply->writeInt32(type);\n             reply->writeInt32(err);\n \n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n }\n\n return NO_ERROR;\n }\n\n case CREATE_PERSISTENT_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            sp<IGraphicBufferProducer> bufferProducer;\n            sp<IGraphicBufferConsumer> bufferConsumer;\n status_t err = createPersistentInputSurface(\n &bufferProducer, &bufferConsumer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n                reply->writeStrongBinder(IInterface::asBinder(bufferConsumer));\n }\n\n return NO_ERROR;\n }\n\n case SET_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n\n             sp<IGraphicBufferConsumer> bufferConsumer =\n                     interface_cast<IGraphicBufferConsumer>(data.readStrongBinder());\n \n            MetadataBufferType type;\n             status_t err = setInputSurface(node, port_index, bufferConsumer, &type);\n \n             reply->writeInt32(type);\n             reply->writeInt32(err);\n             return NO_ERROR;\n }\n\n case SIGNAL_END_OF_INPUT_STREAM:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case STORE_META_DATA_IN_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n             OMX_U32 port_index = data.readInt32();\n             OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n \n            MetadataBufferType type;\n             status_t err = storeMetaDataInBuffers(node, port_index, enable, &type);\n             reply->writeInt32(type);\n             reply->writeInt32(err);\n \n return NO_ERROR;\n }\n\n case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CONFIGURE_VIDEO_TUNNEL_MODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n            OMX_U32 audio_hw_sync = data.readInt32();\n\n native_handle_t *sideband_handle = NULL;\n status_t err = configureVideoTunnelMode(\n                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n            reply->writeInt32(err);\n if(err == OK){\n                reply->writeNativeHandle(sideband_handle);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n if (!isSecure(node) || port_index != 0 \n) {\n                ALOGE(\"b/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n return NO_ERROR;\n }\n\n size_t size = data.readInt64();\n\n            buffer_id buffer;\n void *buffer_data;\n status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER_WITH_BACKUP:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer, allottedSize);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case FREE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n return NO_ERROR;\n }\n\n case FILL_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(fillBuffer(node, buffer, fenceFd));\n\n return NO_ERROR;\n }\n\n case EMPTY_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(emptyBuffer(\n                    node, buffer, range_offset, range_length, flags, timestamp, fenceFd));\n\n return NO_ERROR;\n }\n\n case GET_EXTENSION_INDEX:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32(index);\n }\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "249,292,321"}
{"idx": 188631, "func": "void impeg2d_dec_p_mb_params(dec_state_t *ps_dec)\n {\n     stream_t *ps_stream = &ps_dec->s_bit_stream;\n     UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n const dec_mb_params_t *ps_dec_mb_params;\n if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n }\n else\n {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n if(0 == ps_dec->u2_first_mb)\n {\n if(ps_dec->u2_is_mpeg2 && ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb) )\n {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n }\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n }\n\n }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n }\n {\n if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n {\n            WORD32 i4_motion_type;\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len        += MB_MOTION_TYPE_LEN;\n            u4_next_word        = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n if((i4_motion_type == 0) ||\n (i4_motion_type == 4) ||\n (i4_motion_type > 7))\n {\n                i4_motion_type = 1;\n }\n\n }\n }\n {\n if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n }\n }\n if(u2_mb_type & MB_QUANT)\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n if(u2_mb_type & MB_FORW_OR_BACK)\n {\n\n        UWORD16 refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = (e_pred_direction_t)refPic;\n         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n \n     }\n else if(u2_mb_type & MB_TYPE_INTRA)\n {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n }\n else\n {\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n }\n\n if((u2_mb_type & MB_TYPE_INTRA))\n {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n }\n else\n {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n if((ps_dec->u2_coded_mb))\n {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n }\n else\n {\n\n             ps_dec->u2_cbp  = 0;\n         }\n     }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8567, "func": "static void ssh_hostport_setup(const char *host, int port, Conf *conf,\n                               char **savedhost, int *savedport,\n                               char **loghost_ret)\n{\n    char *loghost = conf_get_str(conf, CONF_loghost);\n    if (loghost_ret)\n        *loghost_ret = loghost;\n\n    if (*loghost) {\n\tchar *tmphost;\n        char *colon;\n\n        tmphost = dupstr(loghost);\n\t*savedport = 22;\t       \n\n\tcolon = host_strrchr(tmphost, ':');\n\tif (colon && colon == host_strchr(tmphost, ':')) {\n\t    *colon++ = '\\0';\n\t    if (*colon)\n\t\t*savedport = atoi(colon);\n\t}\n\n        *savedhost = host_strduptrim(tmphost);\n        sfree(tmphost);\n    } else {\n\t*savedhost = host_strduptrim(host);\n\tif (port < 0)\n\t    port = 22;\t\t       \n\t*savedport = port;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187873, "func": "long Track::ParseContentEncodingsEntry(long long start, long long size) {\n IMkvReader* const pReader = m_pSegment->m_pReader;\n  assert(pReader);\n\n long long pos = start;\n const long long stop = start + size;\n\n int count = 0;\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) \n return status;\n\n if (id == 0x2240) \n\n       ++count;\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n   if (count <= 0)\n     return -1;\n \n  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];\n   if (!content_encoding_entries_)\n     return -1;\n \n  content_encoding_entries_end_ = content_encoding_entries_;\n\n  pos = start;\n while (pos < stop) {\n long long id, size;\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) \n return status;\n\n if (id == 0x2240) { \n ContentEncoding* const content_encoding =\n new (std::nothrow) ContentEncoding();\n if (!content_encoding)\n return -1;\n\n      status = content_encoding->ParseContentEncodingEntry(pos, size, pReader);\n if (status) {\n delete content_encoding;\n return status;\n }\n\n *content_encoding_entries_end_++ = content_encoding;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   return 0;\n }\n", "target": 1, "flaw_line_index": "22,28,59,62"}
{"idx": 188218, "func": "OMX_ERRORTYPE SoftAMRWBEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAMR;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->nBitRate = mBitRate;\n\n            amrParams->eAMRBandMode =\n (OMX_AUDIO_AMRBANDMODETYPE)(mMode + OMX_AUDIO_AMRBandModeWB0);\n\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelCF;\n\n            pcmParams->nChannels = 1;\n            pcmParams->nSamplingRate = kSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8718, "func": "static int stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                            const struct stat *stbuf,\n                            V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_null(&v9stat->uid);\n    v9fs_string_null(&v9stat->gid);\n    v9fs_string_null(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_null(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187531, "func": "void CameraSource::releaseQueuedFrames() {\n\n     List<sp<IMemory> >::iterator it;\n     while (!mFramesReceived.empty()) {\n         it = mFramesReceived.begin();\n         releaseRecordingFrame(*it);\n         mFramesReceived.erase(it);\n         ++mNumFramesDropped;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188011, "func": " long vorbis_book_decodevv_add(codebook *book,ogg_int32_t **a,\n\t\t\t      long offset,int ch,\n\t\t\t      oggpack_buffer *b,int n,int point){\n   if(book->used_entries>0){\n \n     ogg_int32_t *v = book->dec_buf;\n long i,j;\n int chptr=0;\n\n\n     if (!v) return -1;\n     for(i=offset;i<offset+n;){\n       if(decode_map(book,b,v,point))return -1;\n      for (j=0;j<book->dim;j++){\n\ta[chptr++][i]+=v[j];\n\tif(chptr==ch){\n\t  chptr=0;\n\t  i++;\n\t}\n       }\n     }\n   }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "2,3,14,15,16,17,18,19"}
{"idx": 187866, "func": "long AudioTrack::Parse(Segment* pSegment, const Info& info,\n long long element_start, long long element_size,\n AudioTrack*& pResult) {\n if (pResult)\n return -1;\n\n if (info.type != Track::kAudio)\n return -1;\n\n IMkvReader* const pReader = pSegment->m_pReader;\n\n const Settings& s = info.settings;\n  assert(s.start >= 0);\n  assert(s.size >= 0);\n\n long long pos = s.start;\n  assert(pos >= 0);\n\n const long long stop = pos + s.size;\n\n double rate = 8000.0; \n long long channels = 1;\n long long bit_depth = 0;\n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (id == 0x35) { \n      status = UnserializeFloat(pReader, pos, size, rate);\n\n if (status < 0)\n return status;\n\n if (rate <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x1F) { \n      channels = UnserializeUInt(pReader, pos, size);\n\n if (channels <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x2264) { \n      bit_depth = UnserializeUInt(pReader, pos, size);\n\n if (bit_depth <= 0)\n return E_FILE_FORMAT_INVALID;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   AudioTrack* const pTrack =\n       new (std::nothrow) AudioTrack(pSegment, element_start, element_size);\n\n if (pTrack == NULL)\n return -1; \n\n const int status = info.Copy(pTrack->m_info);\n\n if (status) {\n delete pTrack;\n return status;\n }\n\n  pTrack->m_rate = rate;\n  pTrack->m_channels = channels;\n  pTrack->m_bitDepth = bit_depth;\n\n  pResult = pTrack;\n return 0; \n}\n", "target": 1, "flaw_line_index": "55,58"}
{"idx": 187460, "func": "static void toggle_os_keylockstates(int fd, int changedlockstates)\n{\n    BTIF_TRACE_EVENT(\"%s: fd = %d, changedlockstates = 0x%x\",\n        __FUNCTION__, fd, changedlockstates);\n    UINT8 hidreport[9];\n int reportIndex;\n    memset(hidreport,0,9);\n    hidreport[0]=1;\n    reportIndex=4;\n\n if (changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK) {\n        BTIF_TRACE_DEBUG(\"%s Setting CAPSLOCK\", __FUNCTION__);\n        hidreport[reportIndex++] = (UINT8)HID_REPORT_CAPSLOCK;\n }\n\n if (changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK) {\n        BTIF_TRACE_DEBUG(\"%s Setting NUMLOCK\", __FUNCTION__);\n        hidreport[reportIndex++] = (UINT8)HID_REPORT_NUMLOCK;\n }\n\n if (changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK) {\n        BTIF_TRACE_DEBUG(\"%s Setting SCROLLLOCK\", __FUNCTION__);\n        hidreport[reportIndex++] = (UINT8) HID_REPORT_SCROLLLOCK;\n }\n\n     BTIF_TRACE_DEBUG(\"Writing hidreport #1 to os: \"\\\n \"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[0], hidreport[1], hidreport[2]);\n    BTIF_TRACE_DEBUG(\"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[3], hidreport[4], hidreport[5]);\n\n     BTIF_TRACE_DEBUG(\"%s:  %x %x %x\", __FUNCTION__,\n          hidreport[6], hidreport[7], hidreport[8]);\n     bta_hh_co_write(fd , hidreport, sizeof(hidreport));\n    usleep(200000);\n     memset(hidreport,0,9);\n     hidreport[0]=1;\n     BTIF_TRACE_DEBUG(\"Writing hidreport #2 to os: \"\\\n \"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[0], hidreport[1], hidreport[2]);\n    BTIF_TRACE_DEBUG(\"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[3], hidreport[4], hidreport[5]);\n    BTIF_TRACE_DEBUG(\"%s:  %x %x %x \", __FUNCTION__,\n         hidreport[6], hidreport[7], hidreport[8]);\n    bta_hh_co_write(fd , hidreport, sizeof(hidreport));\n}\n", "target": 1, "flaw_line_index": "35"}
{"idx": 187479, "func": "void btsock_rfc_signaled(UNUSED_ATTR int fd, int flags, uint32_t user_id) {\n  pthread_mutex_lock(&slot_lock);\n\n rfc_slot_t *slot = find_rfc_slot_by_id(user_id);\n if (!slot)\n goto out;\n\n bool need_close = false;\n\n if (flags & SOCK_THREAD_FD_RD && !slot->f.server) {\n\n     if (slot->f.connected) {\n       int size = 0;\n      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(slot->fd, FIONREAD, &size) == 0 && size))\n        pthread_mutex_unlock(&slot_lock);\n         BTA_JvRfcommWrite(slot->rfc_handle, slot->id);\n     } else {\n       LOG_ERROR(\"%s socket signaled for read while disconnected, slot: %d, channel: %d\", __func__, slot->id, slot->scn);\n       need_close = true;\n }\n }\n\n if (flags & SOCK_THREAD_FD_WR) {\n if (!slot->f.connected || !flush_incoming_que_on_wr_signal(slot)) {\n      LOG_ERROR(\"%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d\", __func__, slot->id, slot->scn);\n      need_close = true;\n }\n }\n\n\n   if (need_close || (flags & SOCK_THREAD_FD_EXCEPTION)) {\n     int size = 0;\n    if (need_close || ioctl(slot->fd, FIONREAD, &size) != 0 || !size)\n       cleanup_rfc_slot(slot);\n   }\n \nout:;\n  pthread_mutex_unlock(&slot_lock);\n}\n", "target": 1, "flaw_line_index": "16,17,18,19,39"}
{"idx": 187942, "func": " void WT_NoiseGenerator (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n {\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 nInterpolatedSample;\n    EAS_I32 numSamples;\n\n \n     numSamples = pWTIntFrame->numSamples;\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n     phaseInc = pWTIntFrame->frame.phaseIncrement;\n \n    tmp0 = (EAS_I32) (pWTVoice->phaseAccum) >> 18;\n    tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;\n\n while (numSamples--) {\n        nInterpolatedSample = MULT_AUDIO_COEF( tmp0, (PHASE_ONE - pWTVoice->phaseFrac));\n        nInterpolatedSample += MULT_AUDIO_COEF( tmp1, pWTVoice->phaseFrac);\n *pOutputBuffer++ = (EAS_PCM) nInterpolatedSample;\n\n        pWTVoice->phaseFrac += (EAS_U32) phaseInc;\n if (GET_PHASE_INT_PART(pWTVoice->phaseFrac)) {\n            tmp0 = tmp1;\n            pWTVoice->phaseAccum = pWTVoice->loopEnd;\n            pWTVoice->loopEnd = (5 * pWTVoice->loopEnd + 1);\n            tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;\n            pWTVoice->phaseFrac = GET_PHASE_FRAC_PART(pWTVoice->phaseFrac);\n }\n\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8395, "func": "int virtqueue_avail_bytes(VirtQueue *vq, unsigned int in_bytes,\n                          unsigned int out_bytes)\n{\n    unsigned int in_total, out_total;\n\n    virtqueue_get_avail_bytes(vq, &in_total, &out_total, in_bytes, out_bytes);\n    return in_bytes <= in_total && out_bytes <= out_total;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188256, "func": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n const size_t kGroupSize = 12;\n const size_t kStartCharCodeOffset = 0;\n const size_t kEndCharCodeOffset = 4;\n const size_t kMaxNGroups = 0xfffffff0 / kGroupSize; \n if (kFirstGroupOffset > size) {\n return false;\n }\n uint32_t nGroups = readU32(data, kNGroupsOffset);\n if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n return false;\n }\n for (uint32_t i = 0; i < nGroups; i++) {\n\n         uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n         uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n         addRange(coverage, start, end + 1);  \n     }\n     return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187657, "func": " image_transform_png_set_gray_to_rgb_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n return (colour_type & PNG_COLOR_MASK_COLOR) == 0;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187432, "func": "bool ASessionDescription::getDimensions(\n size_t index, unsigned long PT,\n int32_t *width, int32_t *height) const {\n\n     *width = 0;\n     *height = 0;\n \n    char key[20];\n    sprintf(key, \"a=framesize:%lu\", PT);\n     AString value;\n     if (!findAttribute(index, key, &value)) {\n         return false;\n }\n\n const char *s = value.c_str();\n char *end;\n *width = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '-');\n\n    s = end + 1;\n *height = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '\\0');\n\n return true;\n}\n", "target": 1, "flaw_line_index": "8,9"}
{"idx": 9207, "func": "int virtio_load(VirtIODevice *vdev, QEMUFile *f, int version_id)\n{\n    int i, ret;\n    int32_t config_len;\n    uint32_t num;\n    uint32_t features;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    vdev->device_endian = VIRTIO_DEVICE_ENDIAN_UNKNOWN;\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n    qemu_get_8s(f, &vdev->status);\n    qemu_get_8s(f, &vdev->isr);\n    qemu_get_be16s(f, &vdev->queue_sel);\n    if (vdev->queue_sel >= VIRTIO_QUEUE_MAX) {\n        return -1;\n    }\n    qemu_get_be32s(f, &features);\n\n    vdev->guest_features = features;\n\n    config_len = qemu_get_be32(f);\n\n    qemu_get_buffer(f, vdev->config, MIN(config_len, vdev->config_len));\n\n    while (config_len > vdev->config_len) {\n        qemu_get_byte(f);\n        config_len--;\n    }\n\n    num = qemu_get_be32(f);\n\n    if (num > VIRTIO_QUEUE_MAX) {\n        error_report(\"Invalid number of virtqueues: 0x%x\", num);\n        return -1;\n    }\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].vring.desc = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].vring.desc) {\n            virtio_queue_update_rings(vdev, i);\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n\n    if (vdc->load != NULL) {\n        ret = vdc->load(vdev, f, version_id);\n        if (ret) {\n            return ret;\n        }\n    }\n\n    ret = vmstate_load_state(f, &vmstate_virtio, vdev, 1);\n    if (ret) {\n        return ret;\n    }\n\n    if (vdev->device_endian == VIRTIO_DEVICE_ENDIAN_UNKNOWN) {\n        vdev->device_endian = virtio_default_endian();\n    }\n\n    if (virtio_64bit_features_needed(vdev)) {\n        uint64_t features64 = vdev->guest_features;\n        if (virtio_set_features_nocheck(vdev, features64) < 0) {\n            error_report(\"Features 0x%\" PRIx64 \" unsupported. \"\n                         \"Allowed features: 0x%\" PRIx64,\n                         features64, vdev->host_features);\n            return -1;\n        }\n    } else {\n        if (virtio_set_features_nocheck(vdev, features) < 0) {\n            error_report(\"Features 0x%x unsupported. \"\n                         \"Allowed features: 0x%\" PRIx64,\n                         features, vdev->host_features);\n            return -1;\n        }\n    }\n\n    for (i = 0; i < num; i++) {\n        if (vdev->vq[i].vring.desc) {\n            uint16_t nheads;\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n            vdev->vq[i].used_idx = vring_used_idx(&vdev->vq[i]);\n            vdev->vq[i].shadow_avail_idx = vring_avail_idx(&vdev->vq[i]);\n        }\n    }\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187745, "func": "BOOL png2pnm (FILE *png_file, FILE *pnm_file, FILE *alpha_file, BOOL raw, BOOL alpha)\n {\n   png_struct    *png_ptr = NULL;\n   png_info        *info_ptr = NULL;\n  png_byte      buf[8];\n  png_byte      *png_pixels = NULL;\n  png_byte      **row_pointers = NULL;\n  png_byte      *pix_ptr = NULL;\n  png_uint_32   row_bytes;\n\n  png_uint_32   width;\n  png_uint_32   height;\n int           bit_depth;\n int           channels;\n int           color_type;\n int           alpha_present;\n int           row, col;\n int           ret;\n int           i;\n long          dep_16;\n\n  ret = fread (buf, 1, 8, png_file);\n if (ret != 8)\n return FALSE;\n\n  ret = png_sig_cmp (buf, 0, 8);\n if (ret)\n return FALSE;\n\n \n \n  png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING,\n     NULL, NULL, NULL);\n   if (!png_ptr)\n     return FALSE;   \n\n  info_ptr = png_create_info_struct (png_ptr);\n if (!info_ptr)\n {\n    png_destroy_read_struct (&png_ptr, NULL, NULL);\n return FALSE; \n }\n\n if (setjmp (png_jmpbuf(png_ptr)))\n {\n    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);\n return FALSE;\n }\n\n  png_init_io (png_ptr, png_file);\n  png_set_sig_bytes (png_ptr, 8); \n\n  png_read_info (png_ptr, info_ptr);\n\n  png_get_IHDR (png_ptr, info_ptr,\n &width, &height, &bit_depth, &color_type,\n    NULL, NULL, NULL);\n\n\n if (color_type == PNG_COLOR_TYPE_PALETTE)\n    png_set_expand (png_ptr);\n if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\n    png_set_expand (png_ptr);\n if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS))\n\n     png_set_expand (png_ptr);\n \n #ifdef NJET\n   if (bit_depth == 16)\n     png_set_strip_16 (png_ptr);\n if (color_type == PNG_COLOR_TYPE_GRAY ||\n    color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    png_set_gray_to_rgb (png_ptr);\n if (png_get_gAMA (png_ptr, info_ptr, &file_gamma))\n    png_set_gamma (png_ptr, (double) 2.2, file_gamma);\n#endif\n\n\n  png_read_update_info (png_ptr, info_ptr);\n\n  png_get_IHDR (png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\n    NULL, NULL, NULL);\n\n if (bit_depth == 16)\n {\n    raw = FALSE;\n#ifdef __TURBOC__\n    pnm_file->flags &= ~((unsigned) _F_BIN);\n#endif\n }\n\n if (color_type == PNG_COLOR_TYPE_GRAY)\n    channels = 1;\n else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    channels = 2;\n else if (color_type == PNG_COLOR_TYPE_RGB)\n    channels = 3;\n else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n    channels = 4;\n else\n    channels = 0; \n  alpha_present = (channels - 1) % 2;\n\n if (alpha && !alpha_present)\n {\n    fprintf (stderr, \"PNG2PNM\\n\");\n    fprintf (stderr, \"Error:  PNG-file doesn't contain alpha channel\\n\");\n    exit (1);\n }\n\n\n   row_bytes = png_get_rowbytes (png_ptr, info_ptr);\n \n  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL) {\n     png_destroy_read_struct (&png_ptr, &info_ptr, NULL);\n     return FALSE;\n   }\n \n  if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)\n   {\n     png_destroy_read_struct (&png_ptr, &info_ptr, NULL);\n     free (png_pixels);\n    png_pixels = NULL;\n return FALSE;\n\n   }\n \n  for (i = 0; i < (height); i++)\n     row_pointers[i] = png_pixels + i * row_bytes;\n \n  png_read_image (png_ptr, row_pointers);\n\n  png_read_end (png_ptr, info_ptr);\n\n  png_destroy_read_struct (&png_ptr, &info_ptr, (png_infopp) NULL);\n\n\n if ((color_type == PNG_COLOR_TYPE_GRAY) ||\n (color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n {\n    fprintf (pnm_file, \"%s\\n\", (raw) ? \"P5\" : \"P2\");\n    fprintf (pnm_file, \"%d %d\\n\", (int) width, (int) height);\n    fprintf (pnm_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));\n }\n else if ((color_type == PNG_COLOR_TYPE_RGB) ||\n (color_type == PNG_COLOR_TYPE_RGB_ALPHA))\n {\n    fprintf (pnm_file, \"%s\\n\", (raw) ? \"P6\" : \"P3\");\n    fprintf (pnm_file, \"%d %d\\n\", (int) width, (int) height);\n    fprintf (pnm_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));\n }\n\n\n if ((alpha) &&\n ((color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n (color_type == PNG_COLOR_TYPE_RGB_ALPHA)))\n {\n    fprintf (alpha_file, \"%s\\n\", (raw) ? \"P5\" : \"P2\");\n    fprintf (alpha_file, \"%d %d\\n\", (int) width, (int) height);\n    fprintf (alpha_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));\n }\n\n\n   pix_ptr = png_pixels;\n \n  for (row = 0; row < height; row++)\n   {\n    for (col = 0; col < width; col++)\n     {\n       for (i = 0; i < (channels - alpha_present); i++)\n       {\n if (raw)\n          fputc ((int) *pix_ptr++ , pnm_file);\n else\n if (bit_depth == 16){\n            dep_16 = (long) *pix_ptr++;\n            fprintf (pnm_file, \"%ld \", (dep_16 << 8) + ((long) *pix_ptr++));\n }\n else\n            fprintf (pnm_file, \"%ld \", (long) *pix_ptr++);\n }\n if (alpha_present)\n {\n if (!alpha)\n {\n          pix_ptr++; \n if (bit_depth == 16)\n            pix_ptr++;\n }\n else \n {\n if (raw)\n            fputc ((int) *pix_ptr++ , alpha_file);\n else\n if (bit_depth == 16){\n              dep_16 = (long) *pix_ptr++;\n              fprintf (alpha_file, \"%ld \", (dep_16 << 8) + (long) *pix_ptr++);\n }\n else\n              fprintf (alpha_file, \"%ld \", (long) *pix_ptr++);\n }\n } \n\n if (!raw)\n if (col % 4 == 3)\n          fprintf (pnm_file, \"\\n\");\n } \n\n if (!raw)\n if (col % 4 != 0)\n        fprintf (pnm_file, \"\\n\");\n } \n\n if (row_pointers != (unsigned char**) NULL)\n    free (row_pointers);\n if (png_pixels != (unsigned char*) NULL)\n    free (png_pixels);\n\n return TRUE;\n\n} \n", "target": 1, "flaw_line_index": "32,68,114,119,128,166,168"}
{"idx": 188335, "func": "ContentEncoding::GetEncryptionByIndex(unsigned long idx) const {\n   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;\n   assert(count >= 0);\n \n if (idx >= static_cast<unsigned long>(count))\n return NULL;\n\n return encryption_entries_[idx];\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188182, "func": "std::string utf16ToUtf8(const StringPiece16& utf16) {\n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());\n if (utf8Length <= 0) {\n return {};\n\n     }\n \n     std::string utf8;\n     utf8.resize(utf8Length);\n    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());\n     return utf8;\n }\n", "target": 1, "flaw_line_index": "10"}
{"idx": 8862, "func": "static int vrend_finish_shader(struct vrend_context *ctx,\n                               struct vrend_shader_selector *sel,\n                               const struct tgsi_token *tokens)\n{\n   int r;\n\n   sel->tokens = tgsi_dup_tokens(tokens);\n\n   r = vrend_shader_select(ctx, sel, NULL);\n   if (r) {\n      return EINVAL;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187842, "func": " const CuePoint* Cues::GetLast() const {\n  if (m_cue_points == NULL)\n     return NULL;\n \n  if (m_count <= 0)\n    return NULL;\n#if 0\n    LoadCuePoint();  \n    const size_t count = m_count + m_preload_count;\n    if (count == 0)  \n        return NULL;\n    const size_t index = count - 1;\n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    CuePoint* const pCP = pp[index];\n    assert(pCP);\n    pCP->Load(m_pSegment->m_pReader);\n    assert(pCP->GetTimeCode() >= 0);\n#else\n   const long index = m_count - 1;\n \n   CuePoint* const* const pp = m_cue_points;\n  assert(pp);\n \n   CuePoint* const pCP = pp[index];\n  assert(pCP);\n  assert(pCP->GetTimeCode() >= 0);\n#endif\n \n   return pCP;\n }\n", "target": 1, "flaw_line_index": "2,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,23,26,27,28"}
{"idx": 8719, "func": "static void v9fs_fix_path(V9fsPath *dst, V9fsPath *src, int len)\n{\n    V9fsPath str;\n    v9fs_path_init(&str);\n    v9fs_path_copy(&str, dst);\n    v9fs_string_sprintf((V9fsString *)dst, \"%s%s\", src->data, str.data+len);\n    v9fs_path_free(&str);\n    dst->size++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188510, "func": "static void encode_frame(vpx_codec_ctx_t *codec,\n                         vpx_image_t *img,\n                         int frame_index,\n                         int flags,\n                         VpxVideoWriter *writer) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,\n                                               flags, VPX_DL_GOOD_QUALITY);\n if (res != VPX_CODEC_OK)\n\n     die_codec(codec, \"Failed to encode frame\");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n                                        pkt->data.frame.buf,\n                                        pkt->data.frame.sz,\n\n                                         pkt->data.frame.pts)) {\n         die_codec(codec, \"Failed to write compressed frame\");\n       }\n       printf(keyframe ? \"K\" : \".\");\n       fflush(stdout);\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 8751, "func": "static NOINLINE void attach_option(\n\t\tstruct option_set **opt_list,\n\t\tconst struct dhcp_optflag *optflag,\n\t\tchar *buffer,\n\t\tint length,\n\t\tbool dhcpv6)\n{\n\tIF_NOT_UDHCPC6(bool dhcpv6 = 0;)\n\tstruct option_set *existing;\n\tchar *allocated = NULL;\n\n\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_BIN) {\n\t\tconst char *end;\n\t\tallocated = xstrdup(buffer); \n\t\tend = hex2bin(allocated, buffer, 255);\n\t\tif (errno)\n\t\t\tbb_error_msg_and_die(\"malformed hex string '%s'\", buffer);\n\t\tlength = end - allocated;\n\t\tbuffer = allocated;\n\t}\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_DNS_STRING) {\n\t\tallocated = buffer = (char *)dname_enc(NULL, 0, buffer, &length);\n\t}\n#endif\n\n\texisting = udhcp_find_option(*opt_list, optflag->code);\n\tif (!existing) {\n\t\tstruct option_set *new, **curr;\n\n\t\tlog2(\"attaching option %02x to list\", optflag->code);\n\t\tnew = xmalloc(sizeof(*new));\n\t\tif (!dhcpv6) {\n\t\t\tnew->data = xmalloc(length + OPT_DATA);\n\t\t\tnew->data[OPT_CODE] = optflag->code;\n\t\t\tnew->data[OPT_LEN] = length;\n\t\t\tmemcpy(new->data + OPT_DATA, buffer, length);\n\t\t} else {\n\t\t\tnew->data = xmalloc(length + D6_OPT_DATA);\n\t\t\tnew->data[D6_OPT_CODE] = optflag->code >> 8;\n\t\t\tnew->data[D6_OPT_CODE + 1] = optflag->code & 0xff;\n\t\t\tnew->data[D6_OPT_LEN] = length >> 8;\n\t\t\tnew->data[D6_OPT_LEN + 1] = length & 0xff;\n\t\t\tmemcpy(new->data + D6_OPT_DATA, buffer,\n\t\t\t\t\tlength);\n\t\t}\n\n\t\tcurr = opt_list;\n\t\twhile (*curr && (*curr)->data[OPT_CODE] < optflag->code)\n\t\t\tcurr = &(*curr)->next;\n\n\t\tnew->next = *curr;\n\t\t*curr = new;\n\t\tgoto ret;\n\t}\n\n\tif (optflag->flags & OPTION_LIST) {\n\t\tunsigned old_len;\n\n\t\tlog2(\"attaching option %02x to existing member of list\", optflag->code);\n\t\told_len = existing->data[OPT_LEN];\n\t\tif (old_len + length < 255) {\n\n\t\t\texisting->data = xrealloc(existing->data, OPT_DATA + 1 + old_len + length);\n#if 0\n\t\t\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_STRING\n\t\t\t || (optflag->flags & OPTION_TYPE_MASK) == OPTION_STRING_HOST\n\t\t\t) {\n\t\t\t\texisting->data[OPT_DATA + old_len] = ' ';\n\t\t\t\told_len++;\n\t\t\t}\n#endif\n\n\t\t\tmemcpy(existing->data + OPT_DATA + old_len, buffer, length);\n\t\t\texisting->data[OPT_LEN] = old_len + length;\n\t\t} \n\t} \n\n ret:\n\tfree(allocated);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187339, "func": "xsltGetQNameProperty(xsltStylesheetPtr style, xmlNodePtr inst,\n\t\t     const xmlChar *propName,\n\t\t     int mandatory,\n\t\t     int *hasProp, const xmlChar **nsName,\n\t\t     const xmlChar** localName)\n{\n    const xmlChar *prop;\n\n    if (nsName)\n\t*nsName = NULL;\n    if (localName)\n\t*localName = NULL;\n    if (hasProp)\n\t*hasProp = 0;\n\n    prop = xsltGetCNsProp(style, inst, propName, XSLT_NAMESPACE);\n    if (prop == NULL) {\n\tif (mandatory) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"The attribute '%s' is missing.\\n\", propName);\n\t    style->errors++;\n\t    return;\n\t}\n    } else {\n        const xmlChar *URI;\n\n\tif (xmlValidateQName(prop, 0)) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"The value '%s' of the attribute \"\n\t\t\"'%s' is not a valid QName.\\n\", prop, propName);\n\t    style->errors++;\n\t    return;\n\t} else {\n\t    URI = xsltGetQNameURI2(style, inst, &prop);\n \t    if (prop == NULL) {\n \t\tstyle->errors++;\n \t    } else {\n\t\t*localName = prop;\n \t\tif (hasProp)\n \t\t    *hasProp = 1;\n \t\tif (URI != NULL) {\n\t\t    if (nsName)\n\t\t\t*nsName = xmlDictLookup(style->dict, URI, -1);\n\t\t}\n\t    }\n\t}\n    }\n    return;\n}\n", "target": 1, "flaw_line_index": "38"}
{"idx": 8844, "func": "static void vrend_destroy_sampler_view_object(void *obj_ptr)\n{\n   struct vrend_sampler_view *samp = obj_ptr;\n\n   vrend_sampler_view_reference(&samp, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8822, "func": "void vrend_bind_sampler_states(struct vrend_context *ctx,\n                               uint32_t shader_type,\n                               uint32_t start_slot,\n                               uint32_t num_states,\n                               uint32_t *handles)\n{\n   int i;\n   struct vrend_sampler_state *state;\n\n   if (shader_type >= PIPE_SHADER_TYPES) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_CMD_BUFFER, shader_type);\n      return;\n   }\n\n   if (num_states > PIPE_MAX_SAMPLERS ||\n       start_slot > (PIPE_MAX_SAMPLERS - num_states)) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_CMD_BUFFER, num_states);\n      return;\n   }\n\n   ctx->sub->num_sampler_states[shader_type] = num_states;\n\n   for (i = 0; i < num_states; i++) {\n      if (handles[i] == 0)\n         state = NULL;\n      else\n         state = vrend_object_lookup(ctx->sub->object_hash, handles[i], VIRGL_OBJECT_SAMPLER_STATE);\n\n      ctx->sub->sampler_state[shader_type][i + start_slot] = state;\n   }\n   ctx->sub->sampler_state_dirty = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9115, "func": "static int vrend_decode_set_constant_buffer(struct vrend_decode_ctx *ctx, uint16_t length)\n{\n   uint32_t shader;\n   uint32_t index;\n   int nc = (length - 2);\n\n   if (length < 2)\n      return EINVAL;\n\n   shader = get_buf_entry(ctx, VIRGL_SET_CONSTANT_BUFFER_SHADER_TYPE);\n   index = get_buf_entry(ctx, VIRGL_SET_CONSTANT_BUFFER_INDEX);\n\n   if (shader >= PIPE_SHADER_TYPES)\n      return EINVAL;\n\n   vrend_set_constants(ctx->grctx, shader, index, nc, get_buf_ptr(ctx, VIRGL_SET_CONSTANT_BUFFER_DATA_START));\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187396, "func": "status_t GraphicBuffer::unflatten(\n void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n if (size < 8*sizeof(int)) return NO_MEMORY;\n\n int const* buf = static_cast<int const*>(buffer);\n if (buf[0] != 'GBFR') return BAD_TYPE;\n\n\n     const size_t numFds  = buf[8];\n     const size_t numInts = buf[9];\n \n     const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n     if (size < sizeNeeded) return NO_MEMORY;\n \n    size_t fdCountNeeded = 0;\n     if (count < fdCountNeeded) return NO_MEMORY;\n \n     if (handle) {\n        free_handle();\n }\n\n if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n\n         format = buf[4];\n         usage  = buf[5];\n         native_handle* h = native_handle_create(numFds, numInts);\n         memcpy(h->data,          fds,     numFds*sizeof(int));\n         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n         handle = h;\n } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n }\n\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n\n    mOwner = ownHandle;\n\n if (handle != 0) {\n status_t err = mBufferMapper.registerBuffer(handle);\n if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n return err;\n }\n }\n\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n\n return NO_ERROR;\n}\n", "target": 1, "flaw_line_index": "15"}
{"idx": 187375, "func": "int PreProcessingFx_Command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n preproc_effect_t * effect = (preproc_effect_t *) self;\n int retsize;\n int status;\n\n if (effect == NULL){\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || *replySize != sizeof(int)){\n return -EINVAL;\n }\n if (effect->ops->init) {\n                effect->ops->init(effect);\n }\n *(int *)pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG: {\n if (pCmdData    == NULL||\n                cmdSize     != sizeof(effect_config_t)||\n                pReplyData  == NULL||\n *replySize  != sizeof(int)){\n                ALOGV(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n#ifdef DUAL_MIC_TEST\n uint32_t enabledMsk = effect->session->enabledMsk;\n if (gDualMicEnabled) {\n                effect->session->enabledMsk = 0;\n }\n#endif\n *(int *)pReplyData = Session_SetConfig(effect->session, (effect_config_t *)pCmdData);\n#ifdef DUAL_MIC_TEST\n if (gDualMicEnabled) {\n                effect->session->enabledMsk = enabledMsk;\n }\n#endif\n if (*(int *)pReplyData != 0) {\n break;\n }\n if (effect->state != PREPROC_EFFECT_STATE_ACTIVE) {\n *(int *)pReplyData = Effect_SetState(effect, PREPROC_EFFECT_STATE_CONFIG);\n }\n } break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL ||\n *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n Session_GetConfig(effect->session, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_SET_CONFIG_REVERSE:\n if (pCmdData == NULL ||\n                cmdSize != sizeof(effect_config_t) ||\n                pReplyData == NULL ||\n *replySize != sizeof(int)) {\n                ALOGV(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG_REVERSE: ERROR\");\n return -EINVAL;\n }\n *(int *)pReplyData = Session_SetReverseConfig(effect->session,\n (effect_config_t *)pCmdData);\n if (*(int *)pReplyData != 0) {\n break;\n }\n break;\n\n case EFFECT_CMD_GET_CONFIG_REVERSE:\n if (pReplyData == NULL ||\n *replySize != sizeof(effect_config_t)){\n                ALOGV(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG_REVERSE: ERROR\");\n return -EINVAL;\n }\n Session_GetReverseConfig(effect->session, (effect_config_t *)pCmdData);\n break;\n\n case EFFECT_CMD_RESET:\n if (effect->ops->reset) {\n                effect->ops->reset(effect);\n\n             }\n             break;\n \n        case EFFECT_CMD_GET_PARAM:{\n            if (pCmdData == NULL ||\n                    cmdSize < (int)sizeof(effect_param_t) ||\n                    pReplyData == NULL ||\n                    *replySize < (int)sizeof(effect_param_t)){\n                 ALOGV(\"PreProcessingFx_Command cmdCode Case: \"\n                         \"EFFECT_CMD_GET_PARAM: ERROR\");\n                 return -EINVAL;\n             }\n            effect_param_t *p = (effect_param_t *)pCmdData;\n \n             memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n \n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n if (effect->ops->get_parameter) {\n                p->status = effect->ops->get_parameter(effect, p->data,\n &p->vsize,\n                                                       p->data + voffset);\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n }\n } break;\n\n \n         case EFFECT_CMD_SET_PARAM:{\n             if (pCmdData == NULL||\n                    cmdSize < (int)sizeof(effect_param_t) ||\n                    pReplyData == NULL ||\n                     *replySize != sizeof(int32_t)){\n                 ALOGV(\"PreProcessingFx_Command cmdCode Case: \"\n                         \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n if (effect->ops->set_parameter) {\n *(int *)pReplyData = effect->ops->set_parameter(effect,\n (void *)p->data,\n                                                                p->data + p->psize);\n }\n\n         } break;\n \n         case EFFECT_CMD_ENABLE:\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                 ALOGV(\"PreProcessingFx_Command cmdCode Case: EFFECT_CMD_ENABLE: ERROR\");\n                 return -EINVAL;\n             }\n *(int *)pReplyData = Effect_SetState(effect, PREPROC_EFFECT_STATE_ACTIVE);\n\n             break;\n \n         case EFFECT_CMD_DISABLE:\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                 ALOGV(\"PreProcessingFx_Command cmdCode Case: EFFECT_CMD_DISABLE: ERROR\");\n                 return -EINVAL;\n             }\n *(int *)pReplyData  = Effect_SetState(effect, PREPROC_EFFECT_STATE_CONFIG);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_INPUT_DEVICE:\n if (pCmdData == NULL ||\n                cmdSize != sizeof(uint32_t)) {\n                ALOGV(\"PreProcessingFx_Command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR\");\n return -EINVAL;\n }\n\n if (effect->ops->set_device) {\n                effect->ops->set_device(effect, *(uint32_t *)pCmdData);\n }\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n#ifdef DUAL_MIC_TEST\n case PREPROC_CMD_DUAL_MIC_ENABLE: {\n if (pCmdData == NULL|| cmdSize != sizeof(uint32_t) ||\n                    pReplyData == NULL || replySize == NULL) {\n                ALOGE(\"PreProcessingFx_Command cmdCode Case: \"\n \"PREPROC_CMD_DUAL_MIC_ENABLE: ERROR\");\n *replySize = 0;\n return -EINVAL;\n }\n            gDualMicEnabled = *(bool *)pCmdData;\n if (gDualMicEnabled) {\n                effect->aux_channels_on = sHasAuxChannels[effect->procId];\n } else {\n                effect->aux_channels_on = false;\n }\n            effect->cur_channel_config = (effect->session->inChannelCount == 1) ?\n                    CHANNEL_CFG_MONO : CHANNEL_CFG_STEREO;\n\n            ALOGV(\"PREPROC_CMD_DUAL_MIC_ENABLE: %s\", gDualMicEnabled ? \"enabled\" : \"disabled\");\n *replySize = sizeof(int);\n *(int *)pReplyData = 0;\n } break;\n case PREPROC_CMD_DUAL_MIC_PCM_DUMP_START: {\n if (pCmdData == NULL|| pReplyData == NULL || replySize == NULL) {\n                ALOGE(\"PreProcessingFx_Command cmdCode Case: \"\n \"PREPROC_CMD_DUAL_MIC_PCM_DUMP_START: ERROR\");\n *replySize = 0;\n return -EINVAL;\n }\n            pthread_mutex_lock(&gPcmDumpLock);\n if (gPcmDumpFh != NULL) {\n                fclose(gPcmDumpFh);\n                gPcmDumpFh = NULL;\n }\n char *path = strndup((char *)pCmdData, cmdSize);\n            gPcmDumpFh = fopen((char *)path, \"wb\");\n            pthread_mutex_unlock(&gPcmDumpLock);\n            ALOGV(\"PREPROC_CMD_DUAL_MIC_PCM_DUMP_START: path %s gPcmDumpFh %p\",\n                  path, gPcmDumpFh);\n            ALOGE_IF(gPcmDumpFh <= 0, \"gPcmDumpFh open error %d %s\", errno, strerror(errno));\n            free(path);\n *replySize = sizeof(int);\n *(int *)pReplyData = 0;\n } break;\n case PREPROC_CMD_DUAL_MIC_PCM_DUMP_STOP: {\n if (pReplyData == NULL || replySize == NULL) {\n                ALOGE(\"PreProcessingFx_Command cmdCode Case: \"\n \"PREPROC_CMD_DUAL_MIC_PCM_DUMP_STOP: ERROR\");\n *replySize = 0;\n return -EINVAL;\n }\n            pthread_mutex_lock(&gPcmDumpLock);\n if (gPcmDumpFh != NULL) {\n                fclose(gPcmDumpFh);\n                gPcmDumpFh = NULL;\n }\n            pthread_mutex_unlock(&gPcmDumpLock);\n            ALOGV(\"PREPROC_CMD_DUAL_MIC_PCM_DUMP_STOP\");\n *replySize = sizeof(int);\n *(int *)pReplyData = 0;\n } break;\n\n case EFFECT_CMD_GET_FEATURE_SUPPORTED_CONFIGS: {\n if(!gDualMicEnabled) {\n return -EINVAL;\n }\n if (pCmdData == NULL|| cmdSize != 2 * sizeof(uint32_t) ||\n                    pReplyData == NULL || replySize == NULL) {\n                ALOGE(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_GET_FEATURE_SUPPORTED_CONFIGS: ERROR\");\n *replySize = 0;\n return -EINVAL;\n }\n if (*(uint32_t *)pCmdData != EFFECT_FEATURE_AUX_CHANNELS ||\n !effect->aux_channels_on) {\n                ALOGV(\"PreProcessingFx_Command feature EFFECT_FEATURE_AUX_CHANNELS not supported by\"\n \" fx %d\", effect->procId);\n *(uint32_t *)pReplyData = -ENOSYS;\n *replySize = sizeof(uint32_t);\n break;\n }\n size_t num_configs = *((uint32_t *)pCmdData + 1);\n if (*replySize < (2 * sizeof(uint32_t) +\n                              num_configs * sizeof(channel_config_t))) {\n *replySize = 0;\n return -EINVAL;\n }\n\n *((uint32_t *)pReplyData + 1) = CHANNEL_CFG_CNT;\n if (num_configs < CHANNEL_CFG_CNT ||\n *replySize < (2 * sizeof(uint32_t) +\n                                     CHANNEL_CFG_CNT * sizeof(channel_config_t))) {\n *(uint32_t *)pReplyData = -ENOMEM;\n } else {\n                num_configs = CHANNEL_CFG_CNT;\n *(uint32_t *)pReplyData = 0;\n }\n            ALOGV(\"PreProcessingFx_Command EFFECT_CMD_GET_FEATURE_SUPPORTED_CONFIGS num config %d\",\n                  num_configs);\n\n *replySize = 2 * sizeof(uint32_t) + num_configs * sizeof(channel_config_t);\n *((uint32_t *)pReplyData + 1) = num_configs;\n            memcpy((uint32_t *)pReplyData + 2, &sDualMicConfigs, num_configs * sizeof(channel_config_t));\n } break;\n case EFFECT_CMD_GET_FEATURE_CONFIG:\n if(!gDualMicEnabled) {\n return -EINVAL;\n }\n if (pCmdData == NULL|| cmdSize != sizeof(uint32_t) ||\n                    pReplyData == NULL || replySize == NULL ||\n *replySize < sizeof(uint32_t) + sizeof(channel_config_t)) {\n                ALOGE(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_GET_FEATURE_CONFIG: ERROR\");\n return -EINVAL;\n }\n if (*(uint32_t *)pCmdData != EFFECT_FEATURE_AUX_CHANNELS || !effect->aux_channels_on) {\n *(uint32_t *)pReplyData = -ENOSYS;\n *replySize = sizeof(uint32_t);\n break;\n }\n            ALOGV(\"PreProcessingFx_Command EFFECT_CMD_GET_FEATURE_CONFIG\");\n *(uint32_t *)pReplyData = 0;\n *replySize = sizeof(uint32_t) + sizeof(channel_config_t);\n            memcpy((uint32_t *)pReplyData + 1,\n &sDualMicConfigs[effect->cur_channel_config],\n sizeof(channel_config_t));\n break;\n case EFFECT_CMD_SET_FEATURE_CONFIG: {\n            ALOGV(\"PreProcessingFx_Command EFFECT_CMD_SET_FEATURE_CONFIG: \"\n \"gDualMicEnabled %d effect->aux_channels_on %d\",\n                  gDualMicEnabled, effect->aux_channels_on);\n if(!gDualMicEnabled) {\n return -EINVAL;\n }\n if (pCmdData == NULL|| cmdSize != (sizeof(uint32_t) + sizeof(channel_config_t)) ||\n                    pReplyData == NULL || replySize == NULL ||\n *replySize < sizeof(uint32_t)) {\n                ALOGE(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_SET_FEATURE_CONFIG: ERROR\\n\"\n \"pCmdData %p cmdSize %d pReplyData %p replySize %p *replySize %d\",\n                        pCmdData, cmdSize, pReplyData, replySize, replySize ? *replySize : -1);\n return -EINVAL;\n }\n *replySize = sizeof(uint32_t);\n if (*(uint32_t *)pCmdData != EFFECT_FEATURE_AUX_CHANNELS || !effect->aux_channels_on) {\n *(uint32_t *)pReplyData = -ENOSYS;\n                ALOGV(\"PreProcessingFx_Command cmdCode Case: \"\n \"EFFECT_CMD_SET_FEATURE_CONFIG: ERROR\\n\"\n \"CmdData %d effect->aux_channels_on %d\",\n *(uint32_t *)pCmdData, effect->aux_channels_on);\n break;\n }\n size_t i;\n for (i = 0; i < CHANNEL_CFG_CNT;i++) {\n if (memcmp((uint32_t *)pCmdData + 1,\n &sDualMicConfigs[i], sizeof(channel_config_t)) == 0) {\n break;\n }\n }\n if (i == CHANNEL_CFG_CNT) {\n *(uint32_t *)pReplyData = -EINVAL;\n                ALOGW(\"PreProcessingFx_Command EFFECT_CMD_SET_FEATURE_CONFIG invalid config\"\n \"[%08x].[%08x]\", *((uint32_t *)pCmdData + 1), *((uint32_t *)pCmdData + 2));\n } else {\n                effect->cur_channel_config = i;\n *(uint32_t *)pReplyData = 0;\n                ALOGV(\"PreProcessingFx_Command EFFECT_CMD_SET_FEATURE_CONFIG New config\"\n \"[%08x].[%08x]\", sDualMicConfigs[i].main_channels, sDualMicConfigs[i].aux_channels);\n }\n } break;\n#endif\n default:\n return -EINVAL;\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": "104,105,106,107,108,113,132,133,155,164"}
{"idx": 187993, "func": "status_t SoftVPXEncoder::initEncoder() {\n vpx_codec_err_t codec_return;\n\n    mCodecContext = new vpx_codec_ctx_t;\n    mCodecConfiguration = new vpx_codec_enc_cfg_t;\n    mCodecInterface = vpx_codec_vp8_cx();\n\n if (mCodecInterface == NULL) {\n return UNKNOWN_ERROR;\n }\n    ALOGD(\"VP8: initEncoder. BRMode: %u. TSLayers: %zu. KF: %u. QP: %u - %u\",\n (uint32_t)mBitrateControlMode, mTemporalLayers, mKeyFrameInterval,\n          mMinQuantizer, mMaxQuantizer);\n    codec_return = vpx_codec_enc_config_default(mCodecInterface,\n                                                mCodecConfiguration,\n 0); \n\n if (codec_return != VPX_CODEC_OK) {\n        ALOGE(\"Error populating default configuration for vpx encoder.\");\n return UNKNOWN_ERROR;\n }\n\n    mCodecConfiguration->g_w = mWidth;\n    mCodecConfiguration->g_h = mHeight;\n    mCodecConfiguration->g_threads = GetCPUCoreCount();\n    mCodecConfiguration->g_error_resilient = mErrorResilience;\n\n switch (mLevel) {\n case OMX_VIDEO_VP8Level_Version0:\n            mCodecConfiguration->g_profile = 0;\n break;\n\n case OMX_VIDEO_VP8Level_Version1:\n            mCodecConfiguration->g_profile = 1;\n break;\n\n case OMX_VIDEO_VP8Level_Version2:\n            mCodecConfiguration->g_profile = 2;\n break;\n\n case OMX_VIDEO_VP8Level_Version3:\n            mCodecConfiguration->g_profile = 3;\n break;\n\n default:\n            mCodecConfiguration->g_profile = 0;\n }\n\n    mCodecConfiguration->g_timebase.num = 1;\n    mCodecConfiguration->g_timebase.den = 1000000;\n    mCodecConfiguration->rc_target_bitrate = (mBitrate + 500) / 1000;\n    mCodecConfiguration->rc_end_usage = mBitrateControlMode;\n    mCodecConfiguration->rc_dropframe_thresh = 0;\n if (mBitrateControlMode == VPX_CBR) {\n        mCodecConfiguration->rc_resize_allowed = 0;\n        mCodecConfiguration->g_pass = VPX_RC_ONE_PASS;\n        mCodecConfiguration->rc_undershoot_pct = 100;\n        mCodecConfiguration->rc_overshoot_pct = 15;\n        mCodecConfiguration->rc_buf_initial_sz = 500;\n        mCodecConfiguration->rc_buf_optimal_sz = 600;\n        mCodecConfiguration->rc_buf_sz = 1000;\n        mCodecConfiguration->g_error_resilient = 1;\n        mCodecConfiguration->g_lag_in_frames = 0;\n        mCodecConfiguration->kf_max_dist = 3000;\n        mCodecConfiguration->kf_mode = VPX_KF_AUTO;\n }\n\n switch (mTemporalLayers) {\n case 0:\n {\n            mTemporalPatternLength = 0;\n break;\n }\n case 1:\n {\n            mCodecConfiguration->ts_number_layers = 1;\n            mCodecConfiguration->ts_rate_decimator[0] = 1;\n            mCodecConfiguration->ts_periodicity = 1;\n            mCodecConfiguration->ts_layer_id[0] = 0;\n            mTemporalPattern[0] = kTemporalUpdateLastRefAll;\n            mTemporalPatternLength = 1;\n break;\n }\n case 2:\n {\n            mCodecConfiguration->ts_number_layers = 2;\n            mCodecConfiguration->ts_rate_decimator[0] = 2;\n            mCodecConfiguration->ts_rate_decimator[1] = 1;\n            mCodecConfiguration->ts_periodicity = 2;\n            mCodecConfiguration->ts_layer_id[0] = 0;\n            mCodecConfiguration->ts_layer_id[1] = 1;\n            mTemporalPattern[0] = kTemporalUpdateLastAndGoldenRefAltRef;\n            mTemporalPattern[1] = kTemporalUpdateGoldenWithoutDependencyRefAltRef;\n            mTemporalPattern[2] = kTemporalUpdateLastRefAltRef;\n            mTemporalPattern[3] = kTemporalUpdateGoldenRefAltRef;\n            mTemporalPattern[4] = kTemporalUpdateLastRefAltRef;\n            mTemporalPattern[5] = kTemporalUpdateGoldenRefAltRef;\n            mTemporalPattern[6] = kTemporalUpdateLastRefAltRef;\n            mTemporalPattern[7] = kTemporalUpdateNone;\n            mTemporalPatternLength = 8;\n break;\n }\n case 3:\n {\n            mCodecConfiguration->ts_number_layers = 3;\n            mCodecConfiguration->ts_rate_decimator[0] = 4;\n            mCodecConfiguration->ts_rate_decimator[1] = 2;\n            mCodecConfiguration->ts_rate_decimator[2] = 1;\n            mCodecConfiguration->ts_periodicity = 4;\n            mCodecConfiguration->ts_layer_id[0] = 0;\n            mCodecConfiguration->ts_layer_id[1] = 2;\n            mCodecConfiguration->ts_layer_id[2] = 1;\n            mCodecConfiguration->ts_layer_id[3] = 2;\n            mTemporalPattern[0] = kTemporalUpdateLastAndGoldenRefAltRef;\n            mTemporalPattern[1] = kTemporalUpdateNoneNoRefGoldenRefAltRef;\n            mTemporalPattern[2] = kTemporalUpdateGoldenWithoutDependencyRefAltRef;\n            mTemporalPattern[3] = kTemporalUpdateNone;\n            mTemporalPattern[4] = kTemporalUpdateLastRefAltRef;\n            mTemporalPattern[5] = kTemporalUpdateNone;\n            mTemporalPattern[6] = kTemporalUpdateGoldenRefAltRef;\n            mTemporalPattern[7] = kTemporalUpdateNone;\n            mTemporalPatternLength = 8;\n break;\n }\n default:\n {\n            ALOGE(\"Wrong number of temporal layers %zu\", mTemporalLayers);\n return UNKNOWN_ERROR;\n }\n }\n\n for (size_t i = 0; i < mCodecConfiguration->ts_number_layers; i++) {\n        mCodecConfiguration->ts_target_bitrate[i] =\n            mCodecConfiguration->rc_target_bitrate *\n            mTemporalLayerBitrateRatio[i] / 100;\n }\n if (mKeyFrameInterval > 0) {\n        mCodecConfiguration->kf_max_dist = mKeyFrameInterval;\n        mCodecConfiguration->kf_min_dist = mKeyFrameInterval;\n        mCodecConfiguration->kf_mode = VPX_KF_AUTO;\n }\n if (mMinQuantizer > 0) {\n        mCodecConfiguration->rc_min_quantizer = mMinQuantizer;\n }\n if (mMaxQuantizer > 0) {\n        mCodecConfiguration->rc_max_quantizer = mMaxQuantizer;\n }\n\n    codec_return = vpx_codec_enc_init(mCodecContext,\n                                      mCodecInterface,\n                                      mCodecConfiguration,\n 0); \n\n if (codec_return != VPX_CODEC_OK) {\n        ALOGE(\"Error initializing vpx encoder\");\n return UNKNOWN_ERROR;\n }\n\n    codec_return = vpx_codec_control(mCodecContext,\n                                     VP8E_SET_TOKEN_PARTITIONS,\n                                     mDCTPartitions);\n if (codec_return != VPX_CODEC_OK) {\n        ALOGE(\"Error setting dct partitions for vpx encoder.\");\n return UNKNOWN_ERROR;\n }\n\n if (mBitrateControlMode == VPX_CBR) {\n        codec_return = vpx_codec_control(mCodecContext,\n                                         VP8E_SET_STATIC_THRESHOLD,\n 1);\n if (codec_return == VPX_CODEC_OK) {\n uint32_t rc_max_intra_target =\n                mCodecConfiguration->rc_buf_optimal_sz * (mFramerate >> 17) / 10;\n if (rc_max_intra_target < 300) {\n                rc_max_intra_target = 300;\n }\n            codec_return = vpx_codec_control(mCodecContext,\n                                             VP8E_SET_MAX_INTRA_BITRATE_PCT,\n                                             rc_max_intra_target);\n }\n if (codec_return == VPX_CODEC_OK) {\n            codec_return = vpx_codec_control(mCodecContext,\n                                             VP8E_SET_CPUUSED,\n -8);\n }\n if (codec_return != VPX_CODEC_OK) {\n            ALOGE(\"Error setting cbr parameters for vpx encoder.\");\n return UNKNOWN_ERROR;\n }\n }\n\n \n     if (mColorFormat != OMX_COLOR_FormatYUV420Planar || mInputDataIsMeta) {\n         free(mConversionBuffer);\n         mConversionBuffer = (uint8_t *)malloc(mWidth * mHeight * 3 / 2);\n         if (mConversionBuffer == NULL) {\n             ALOGE(\"Allocating conversion buffer failed.\");\n return UNKNOWN_ERROR;\n }\n }\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8476, "func": "UINT CSoundFile::GetBestSaveFormat() const\n{\n\tif ((!m_nSamples) || (!m_nChannels)) return MOD_TYPE_NONE;\n\tif (!m_nType) return MOD_TYPE_NONE;\n\tif (m_nType & (MOD_TYPE_MOD|MOD_TYPE_OKT))\n\t\treturn MOD_TYPE_MOD;\n\tif (m_nType & (MOD_TYPE_S3M|MOD_TYPE_STM|MOD_TYPE_ULT|MOD_TYPE_FAR|MOD_TYPE_PTM))\n\t\treturn MOD_TYPE_S3M;\n\tif (m_nType & (MOD_TYPE_XM|MOD_TYPE_MED|MOD_TYPE_MTM|MOD_TYPE_MT2))\n\t\treturn MOD_TYPE_XM;\n\treturn MOD_TYPE_IT;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8308, "func": "XFixesExpandRegion (Display *dpy, XserverRegion dst, XserverRegion src,\n\t\t    unsigned left, unsigned right,\n\t\t    unsigned top, unsigned bottom)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesExpandRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesExpandRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesExpandRegion;\n    req->source = src;\n    req->destination = dst;\n    req->left = left;\n    req->right = right;\n    req->top = top;\n    req->bottom = bottom;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8677, "func": "append_dir_structure (const struct url *u, struct growable *dest)\n{\n  char *pathel, *next;\n  int cut = opt.cut_dirs;\n\n\n  pathel = u->path;\n  for (; (next = strchr (pathel, '/')) != NULL; pathel = next + 1)\n    {\n      if (cut-- > 0)\n        continue;\n      if (pathel == next)\n        continue;\n\n      if (dest->tail)\n        append_char ('/', dest);\n      append_uri_pathel (pathel, next, true, dest);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9169, "func": "static void set_dsa_write_depth_keep_stencil(void)\n{\n   glDisable(GL_STENCIL_TEST);\n   glEnable(GL_DEPTH_TEST);\n   glDepthFunc(GL_ALWAYS);\n   glDepthMask(GL_TRUE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187896, "func": "H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering)\n{\n    u32 rv = 0;\n\n decContainer_t *pDecCont;\n\n    DEC_API_TRC(\"H264SwDecInit#\");\n\n if ( ((-1)>>1) != (-1) )\n {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Right shift is not signed\");\n return(H264SWDEC_INITFAIL);\n }\n\n if (decInst == NULL)\n {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: decInst == NULL\");\n\n         return(H264SWDEC_PARAM_ERR);\n     }\n \n    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));\n \n     if (pDecCont == NULL)\n     {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Memory allocation failed\");\n return(H264SWDEC_MEMFAIL);\n }\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# decInst %p noOutputReordering %d\",\n (void*)decInst, noOutputReordering);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    rv = h264bsdInit(&pDecCont->storage, noOutputReordering);\n if (rv != HANTRO_OK)\n {\n        H264SwDecRelease(pDecCont);\n return(H264SWDEC_MEMFAIL);\n }\n\n    pDecCont->decStat  = INITIALIZED;\n    pDecCont->picNumber = 0;\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# OK: return %p\", (void*)pDecCont);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n *decInst = (decContainer_t *)pDecCont;\n\n return(H264SWDEC_OK);\n\n}\n", "target": 1, "flaw_line_index": "22"}
{"idx": 187607, "func": "set_value(png_bytep row, size_t rowbytes, png_uint_32 x, unsigned int bit_depth,\n   png_uint_32 value, png_const_bytep gamma_table, double conv)\n{\n unsigned int mask = (1U << bit_depth)-1;\n\n   x *= bit_depth; \n\n if (value <= mask)\n {\n      png_uint_32 offset = x >> 3;\n\n if (offset < rowbytes && (bit_depth < 16 || offset+1 < rowbytes))\n {\n         row += offset;\n\n switch (bit_depth)\n {\n case 1:\n case 2:\n case 4:\n {\n unsigned int shift = (8 - bit_depth) - (x & 0x7U);\n\n                  mask <<= shift;\n                  value = (value << shift) & mask;\n *row = (png_byte)((*row & ~mask) | value);\n }\n return;\n\n default:\n               fprintf(stderr, \"makepng: bad bit depth (internal error)\\n\");\n\n                exit(1);\n \n             case 16:\n               value = (unsigned int)floor(65535*pow(value/65535.,conv)+.5);\n                *row++ = (png_byte)(value >> 8);\n                *row = (png_byte)value;\n                return;\n\n case 8:\n *row = gamma_table[value];\n return;\n }\n }\n\n else\n {\n         fprintf(stderr, \"makepng: row buffer overflow (internal error)\\n\");\n         exit(1);\n }\n }\n\n else\n {\n      fprintf(stderr, \"makepng: component overflow (internal error)\\n\");\n      exit(1);\n\n    }\n }\n", "target": 1, "flaw_line_index": "36"}
{"idx": 188246, "func": "OMX_ERRORTYPE SoftVideoDecoderOMXComponent::getConfig(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexConfigCommonOutputCrop:\n\n         {\n             OMX_CONFIG_RECTTYPE *rectParams = (OMX_CONFIG_RECTTYPE *)params;\n \n             if (rectParams->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorUndefined;\n             }\n\n            rectParams->nLeft = mCropLeft;\n            rectParams->nTop = mCropTop;\n            rectParams->nWidth = mCropWidth;\n            rectParams->nHeight = mCropHeight;\n\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187384, "func": "status_t MPEG4Source::fragmentedRead(\n MediaBuffer **out, const ReadOptions *options) {\n\n    ALOGV(\"MPEG4Source::fragmentedRead\");\n\n    CHECK(mStarted);\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n\n int numSidxEntries = mSegments.size();\n if (numSidxEntries != 0) {\n int64_t totalTime = 0;\n off64_t totalOffset = mFirstMoofOffset;\n for (int i = 0; i < numSidxEntries; i++) {\n const SidxEntry *se = &mSegments[i];\n if (totalTime + se->mDurationUs > seekTimeUs) {\n if ((mode == ReadOptions::SEEK_NEXT_SYNC && seekTimeUs > totalTime) ||\n (mode == ReadOptions::SEEK_CLOSEST_SYNC &&\n (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {\n                        totalTime += se->mDurationUs;\n                        totalOffset += se->mSize;\n }\n break;\n }\n                totalTime += se->mDurationUs;\n                totalOffset += se->mSize;\n }\n            mCurrentMoofOffset = totalOffset;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&totalOffset);\n            mCurrentTime = totalTime * mTimescale / 1000000ll;\n } else {\n            mCurrentMoofOffset = mFirstMoofOffset;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n off64_t tmp = mCurrentMoofOffset;\n            parseChunk(&tmp);\n            mCurrentTime = 0;\n }\n\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset = 0;\n size_t size = 0;\n uint32_t cts = 0;\n bool isSyncSample = false;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n if (mNextMoofOffset <= mCurrentMoofOffset) {\n return ERROR_END_OF_STREAM;\n }\n off64_t nextMoof = mNextMoofOffset;\n            mCurrentMoofOffset = nextMoof;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&nextMoof);\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n return ERROR_END_OF_STREAM;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n        offset = smpl->offset;\n        size = smpl->size;\n        cts = mCurrentTime + smpl->compositionOffset;\n        mCurrentTime += smpl->duration;\n        isSyncSample = (mCurrentSampleIndex == 0); \n\n status_t err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n            ALOGV(\"acquire_buffer returned %d\", err);\n return err;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n const sp<MetaData> bufmeta = mBuffer->meta_data();\n    bufmeta->clear();\n if (smpl->encryptedsizes.size()) {\n        bufmeta->setData(kKeyPlainSizes, 0,\n                smpl->clearsizes.array(), smpl->clearsizes.size() * 4);\n        bufmeta->setData(kKeyEncryptedSizes, 0,\n                smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);\n        bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16); \n        bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);\n        bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);\n        bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);\n }\n\n if ((!mIsAVC && !mIsHEVC)|| mWantsNALFragments) {\n if (newBuffer) {\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGV(\"i/o error\");\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n            mBuffer->meta_data()->setInt64(\n                    kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC && !mIsHEVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mBuffer->range_length() < mNALLengthSize + nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n        ALOGV(\"whole NAL\");\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n if (usesDRM) {\n            num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);\n } else {\n            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);\n }\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            ALOGV(\"i/o error\");\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n\n             size_t dstOffset = 0;\n \n             while (srcOffset < size) {\n                bool isMalFormed = (srcOffset + mNALLengthSize > size);\n                 size_t nalLength = 0;\n                 if (!isMalFormed) {\n                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                     srcOffset += mNALLengthSize;\n                    isMalFormed = srcOffset + nalLength > size;\n                 }\n \n                 if (isMalFormed) {\n                    ALOGE(\"Video is malformed\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n continue;\n }\n\n                CHECK(dstOffset + 4 <= mBuffer->size());\n\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n        mBuffer->meta_data()->setInt64(\n                kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n", "target": 1, "flaw_line_index": "221,226"}
{"idx": 187695, "func": " normalize_color_encoding(color_encoding *encoding)\n {\n   PNG_CONST double whiteY = encoding->red.Y + encoding->green.Y +\n       encoding->blue.Y;\n \n    if (whiteY != 1)\n {\n      encoding->red.X /= whiteY;\n      encoding->red.Y /= whiteY;\n      encoding->red.Z /= whiteY;\n      encoding->green.X /= whiteY;\n      encoding->green.Y /= whiteY;\n      encoding->green.Z /= whiteY;\n      encoding->blue.X /= whiteY;\n      encoding->blue.Y /= whiteY;\n      encoding->blue.Z /= whiteY;\n }\n\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 9179, "func": "static VirtQueue *virtio_add_queue_internal(VirtIODevice *vdev, int queue_size,\n                                            VirtIOHandleOutput handle_output,\n                                            bool use_aio)\n{\n    int i;\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n        if (vdev->vq[i].vring.num == 0)\n            break;\n    }\n\n    if (i == VIRTIO_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE)\n        abort();\n\n    vdev->vq[i].vring.num = queue_size;\n    vdev->vq[i].vring.num_default = queue_size;\n    vdev->vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;\n    vdev->vq[i].handle_output = handle_output;\n    vdev->vq[i].handle_aio_output = NULL;\n    vdev->vq[i].use_aio = use_aio;\n\n    return &vdev->vq[i];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188604, "func": "   virtual void TearDown() {\n    vpx_svc_release(&svc_);\n     delete(decoder_);\n     if (codec_initialized_) vpx_codec_destroy(&codec_);\n   }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8697, "func": "schemes_are_similar_p (enum url_scheme a, enum url_scheme b)\n{\n  if (a == b)\n    return true;\n#ifdef HAVE_SSL\n  if ((a == SCHEME_HTTP && b == SCHEME_HTTPS)\n      || (a == SCHEME_HTTPS && b == SCHEME_HTTP))\n    return true;\n#endif\n  return false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188151, "func": "OMXNodeInstance::OMXNodeInstance(\n        OMX *owner, const sp<IOMXObserver> &observer, const char *name)\n : mOwner(owner),\n      mNodeID(0),\n\n       mHandle(NULL),\n       mObserver(observer),\n       mDying(false),\n       mBufferIDCount(0)\n {\n     mName = ADebug::GetDebugName(name);\n    DEBUG = ADebug::GetDebugLevelFromProperty(name, \"debug.stagefright.omx-debug\");\n    ALOGV(\"debug level for %s is %d\", name, DEBUG);\n    DEBUG_BUMP = DEBUG;\n    mNumPortBuffers[0] = 0;\n    mNumPortBuffers[1] = 0;\n    mDebugLevelBumpPendingBuffers[0] = 0;\n    mDebugLevelBumpPendingBuffers[1] = 0;\n    mMetadataType[0] = kMetadataBufferTypeInvalid;\n    mMetadataType[1] = kMetadataBufferTypeInvalid;\n    mSecureBufferType[0] = kSecureBufferTypeUnknown;\n    mSecureBufferType[1] = kSecureBufferTypeUnknown;\n    mIsSecure = AString(name).endsWith(\".secure\");\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8880, "func": "vrend_insert_format_swizzle(int override_format, struct vrend_format_table *entry, uint32_t bindings, uint8_t swizzle[4])\n{\n   int i;\n   tex_conv_table[override_format] = *entry;\n   tex_conv_table[override_format].bindings = bindings;\n   tex_conv_table[override_format].flags = VREND_BIND_NEED_SWIZZLE;\n   for (i = 0; i < 4; i++)\n      tex_conv_table[override_format].swizzle[i] = swizzle[i];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187427, "func": "void close_all_sockets(atransport* t) {\n    asocket* s;\n\n    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);\n\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close(s);\n             goto restart;\n         }\n     }\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 187759, "func": "process_IDAT(struct file *file)\n{\n struct IDAT_list *list;\n\n   assert(file->idat != NULL && file->chunk != NULL);\n\n list = file->idat->idat_list_tail;\n\n if (list->count == list->length)\n {\n list = IDAT_list_extend(list);\n\n if (list == NULL)\n         stop(file, READ_ERROR_CODE, \"out of memory\");\n\n\n       list->count = 0;\n       file->idat->idat_list_tail = list;\n    }\n    list->lengths[(list->count)++] = file->chunk->chunk_length;\n \n if (file->type == png_IDAT)\n return 0; \n\n   setpos(file->chunk);\n\n if (zlib_check(file, 0))\n {\n struct IDAT *idat;\n int cmp;\n\n      cmp = uarb_cmp(file->image_bytes, file->image_digits,\n         file->chunk->uncompressed_bytes, file->chunk->uncompressed_digits);\n\n if (cmp < 0)\n         type_message(file, png_IDAT, \"extra uncompressed data\");\n\n else if (cmp > 0)\n         stop(file, LIBPNG_ERROR_CODE, \"IDAT: uncompressed data too small\");\n\n      setpos(file->chunk);\n\n      idat = file->idat;\n      idat->idat_cur = idat->idat_list_head;\n      idat->idat_length = idat->idat_cur->lengths[0];\n      idat->idat_count = 0; \n      idat->idat_index = 0; \n\n      file->chunk->chunk_length = rechunk_length(idat);\n\n      file->state = STATE_IDAT;\n\n return 1;\n }\n\n else \n      stop(file, ZLIB_ERROR_CODE, \"could not uncompress IDAT\");\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187341, "func": "xsltApplyStylesheetInternal(xsltStylesheetPtr style, xmlDocPtr doc,\n                            const char **params, const char *output,\n                            FILE * profile, xsltTransformContextPtr userCtxt)\n{\n    xmlDocPtr res = NULL;\n    xsltTransformContextPtr ctxt = NULL;\n    xmlNodePtr root, node;\n    const xmlChar *method;\n    const xmlChar *doctypePublic;\n    const xmlChar *doctypeSystem;\n    const xmlChar *version;\n    const xmlChar *encoding;\n    xsltStackElemPtr variables;\n    xsltStackElemPtr vptr;\n\n    xsltInitGlobals();\n\n    if ((style == NULL) || (doc == NULL))\n        return (NULL);\n\n    if (style->internalized == 0) {\n#ifdef WITH_XSLT_DEBUG\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"Stylesheet was not fully internalized !\\n\");\n#endif\n    }\n    if (doc->intSubset != NULL) {\n\txmlNodePtr cur = (xmlNodePtr) doc->intSubset;\n\tif (cur->next != NULL)\n\t    cur->next->prev = cur->prev;\n\tif (cur->prev != NULL)\n\t    cur->prev->next = cur->next;\n\tif (doc->children == cur)\n\t    doc->children = cur->next;\n\tif (doc->last == cur)\n\t    doc->last = cur->prev;\n\tcur->prev = cur->next = NULL;\n    }\n\n    root = xmlDocGetRootElement(doc);\n    if (root != NULL) {\n\tif (((long) root->content) >= 0 && (xslDebugStatus == XSLT_DEBUG_NONE))\n\t    xmlXPathOrderDocElems(doc);\n    }\n\n    if (userCtxt != NULL)\n\tctxt = userCtxt;\n    else\n\tctxt = xsltNewTransformContext(style, doc);\n\n    if (ctxt == NULL)\n        return (NULL);\n\n    ctxt->initialContextDoc = doc;\n    ctxt->initialContextNode = (xmlNodePtr) doc;\n\n    if (profile != NULL)\n        ctxt->profile = 1;\n\n    if (output != NULL)\n        ctxt->outputFile = output;\n    else\n        ctxt->outputFile = NULL;\n\n    if (ctxt->dict != NULL) {\n        if (ctxt->mode != NULL)\n\t    ctxt->mode = xmlDictLookup(ctxt->dict, ctxt->mode, -1);\n        if (ctxt->modeURI != NULL)\n\t    ctxt->modeURI = xmlDictLookup(ctxt->dict, ctxt->modeURI, -1);\n    }\n\n    XSLT_GET_IMPORT_PTR(method, style, method)\n    XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n    XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n    XSLT_GET_IMPORT_PTR(version, style, version)\n    XSLT_GET_IMPORT_PTR(encoding, style, encoding)\n\n    if ((method != NULL) &&\n\t(!xmlStrEqual(method, (const xmlChar *) \"xml\")))\n    {\n        if (xmlStrEqual(method, (const xmlChar *) \"html\")) {\n            ctxt->type = XSLT_OUTPUT_HTML;\n            if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\n                res = htmlNewDoc(doctypeSystem, doctypePublic);\n\t    } else {\n                if (version == NULL) {\n\t\t    xmlDtdPtr dtd;\n\n\t\t    res = htmlNewDoc(NULL, NULL);\n\t\t    if (res != NULL) {\n\t\t\tdtd = xmlGetIntSubset(res);\n\t\t\tif (dtd != NULL) {\n\t\t\t    xmlUnlinkNode((xmlNodePtr) dtd);\n\t\t\t    xmlFreeDtd(dtd);\n\t\t\t}\n\t\t\tres->intSubset = NULL;\n\t\t\tres->extSubset = NULL;\n\t\t    }\n\t\t} else {\n\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t    xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n#endif\n\t\t    res = htmlNewDoc(doctypeSystem, doctypePublic);\n\t\t}\n            }\n            if (res == NULL)\n                goto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n\n#ifdef WITH_XSLT_DEBUG\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"reusing transformation dict for output\\n\");\n #endif\n         } else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\n \t    xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n\t\t\"xsltApplyStylesheetInternal: unsupported method xhtml, using html\\n\",\n\t\tstyle->method);\n             ctxt->type = XSLT_OUTPUT_HTML;\n             res = htmlNewDoc(doctypeSystem, doctypePublic);\n             if (res == NULL)\n                goto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n\n#ifdef WITH_XSLT_DEBUG\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"reusing transformation dict for output\\n\");\n#endif\n        } else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\n            ctxt->type = XSLT_OUTPUT_TEXT;\n            res = xmlNewDoc(style->version);\n            if (res == NULL)\n                goto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n\n#ifdef WITH_XSLT_DEBUG\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"reusing transformation dict for output\\n\");\n #endif\n         } else {\n \t    xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n\t\t\"xsltApplyStylesheetInternal: unsupported method %s\\n\",\n\t\tstyle->method);\n             goto error;\n         }\n     } else {\n        ctxt->type = XSLT_OUTPUT_XML;\n        res = xmlNewDoc(style->version);\n        if (res == NULL)\n            goto error;\n\tres->dict = ctxt->dict;\n\txmlDictReference(ctxt->dict);\n#ifdef WITH_XSLT_DEBUG\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"reusing transformation dict for output\\n\");\n#endif\n    }\n    res->charset = XML_CHAR_ENCODING_UTF8;\n    if (encoding != NULL)\n        res->encoding = xmlStrdup(encoding);\n    variables = style->variables;\n\n    if (xsltNeedElemSpaceHandling(ctxt))\n\txsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));\n    ctxt->node = (xmlNodePtr) doc;\n    if (ctxt->globalVars == NULL)\n\tctxt->globalVars = xmlHashCreate(20);\n    if (params != NULL) {\n        xsltEvalUserParams(ctxt, params);\n    }\n\n    xsltCountKeys(ctxt);\n\n    xsltEvalGlobalVariables(ctxt);\n\n    ctxt->node = (xmlNodePtr) doc;\n    ctxt->output = res;\n    ctxt->insert = (xmlNodePtr) res;\n    ctxt->varsBase = ctxt->varsNr - 1;\n\n    ctxt->xpathCtxt->contextSize = 1;\n    ctxt->xpathCtxt->proximityPosition = 1;\n    ctxt->xpathCtxt->node = NULL; \n    xsltProcessOneNode(ctxt, ctxt->node, NULL);\n    xsltLocalVariablePop(ctxt, 0, -2);\n    xsltShutdownCtxtExts(ctxt);\n\n    xsltCleanupTemplates(style); \n\n    if (style->variables != variables) {\n        vptr = style->variables;\n        while (vptr->next != variables)\n            vptr = vptr->next;\n        vptr->next = NULL;\n        xsltFreeStackElemList(style->variables);\n        style->variables = variables;\n    }\n    vptr = style->variables;\n    while (vptr != NULL) {\n        if (vptr->computed) {\n            if (vptr->value != NULL) {\n                xmlXPathFreeObject(vptr->value);\n                vptr->value = NULL;\n                vptr->computed = 0;\n            }\n        }\n        vptr = vptr->next;\n    }\n#if 0\n    xsltFreeRVTs(ctxt);\n#endif\n    root = xmlDocGetRootElement(res);\n    if (root != NULL) {\n        const xmlChar *doctype = NULL;\n\n        if ((root->ns != NULL) && (root->ns->prefix != NULL))\n\t    doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n\tif (doctype == NULL)\n\t    doctype = root->name;\n\n        if ((method == NULL) &&\n            (root->ns == NULL) &&\n            (!xmlStrcasecmp(root->name, (const xmlChar *) \"html\"))) {\n            xmlNodePtr tmp;\n\n            tmp = res->children;\n            while ((tmp != NULL) && (tmp != root)) {\n                if (tmp->type == XML_ELEMENT_NODE)\n                    break;\n                if ((tmp->type == XML_TEXT_NODE) && (!xmlIsBlankNode(tmp)))\n                    break;\n\t\ttmp = tmp->next;\n            }\n            if (tmp == root) {\n                ctxt->type = XSLT_OUTPUT_HTML;\n                res->type = XML_HTML_DOCUMENT_NODE;\n                if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\n                    res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                        doctypePublic,\n                                                        doctypeSystem);\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t} else if (version != NULL) {\n                    xsltGetHTMLIDs(version, &doctypePublic,\n                                   &doctypeSystem);\n                    if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n                        res->intSubset =\n                            xmlCreateIntSubset(res, doctype,\n                                               doctypePublic,\n                                               doctypeSystem);\n#endif\n                }\n            }\n\n        }\n        if (ctxt->type == XSLT_OUTPUT_XML) {\n            XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n            XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n            if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\n\t        xmlNodePtr last;\n\t\tnode = res->children;\n\t\tlast = res->last;\n\t\tres->children = NULL;\n\t\tres->last = NULL;\n                res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                    doctypePublic,\n                                                    doctypeSystem);\n\t\tif (res->children != NULL) {\n\t\t    res->children->next = node;\n\t\t    node->prev = res->children;\n\t\t    res->last = last;\n\t\t} else {\n\t\t    res->children = node;\n\t\t    res->last = last;\n\t\t}\n\t    }\n        }\n    }\n    xmlXPathFreeNodeSet(ctxt->nodeList);\n    if (profile != NULL) {\n        xsltSaveProfiling(ctxt, profile);\n    }\n\n    if ((ctxt != NULL) && (ctxt->state == XSLT_STATE_ERROR)) {\n\txmlFreeDoc(res);\n\tres = NULL;\n    }\n    if ((res != NULL) && (ctxt != NULL) && (output != NULL)) {\n\tint ret;\n\n\tret = xsltCheckWrite(ctxt->sec, ctxt, (const xmlChar *) output);\n\tif (ret == 0) {\n\t    xsltTransformError(ctxt, NULL, NULL,\n\t\t     \"xsltApplyStylesheet: forbidden to save to %s\\n\",\n\t\t\t       output);\n\t} else if (ret < 0) {\n\t    xsltTransformError(ctxt, NULL, NULL,\n\t\t     \"xsltApplyStylesheet: saving to %s may not be possible\\n\",\n\t\t\t       output);\n\t}\n    }\n\n#ifdef XSLT_DEBUG_PROFILE_CACHE\n    printf(\"# Cache:\\n\");\n    printf(\"# Reused tree fragments: %d\\n\", ctxt->cache->dbgReusedRVTs);\n    printf(\"# Reused variables     : %d\\n\", ctxt->cache->dbgReusedVars);\n#endif\n\n    if ((ctxt != NULL) && (userCtxt == NULL))\n\txsltFreeTransformContext(ctxt);\n\n    return (res);\n\nerror:\n    if (res != NULL)\n        xmlFreeDoc(res);\n\n#ifdef XSLT_DEBUG_PROFILE_CACHE\n    printf(\"# Cache:\\n\");\n    printf(\"# Reused tree fragments: %d\\n\", ctxt->cache->dbgReusedRVTs);\n    printf(\"# Reused variables     : %d\\n\", ctxt->cache->dbgReusedVars);\n#endif\n\n    if ((ctxt != NULL) && (userCtxt == NULL))\n        xsltFreeTransformContext(ctxt);\n    return (NULL);\n}\n", "target": 1, "flaw_line_index": "118,119,145,146"}
{"idx": 8569, "func": "static void ssh_pkt_addbyte(struct Packet *pkt, unsigned char byte)\n{\n    ssh_pkt_adddata(pkt, &byte, 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187564, "func": "WORD32 ih264d_parse_nal_unit(iv_obj_t *dec_hdl,\n ivd_video_decode_op_t *ps_dec_op,\n                          UWORD8 *pu1_buf,\n                          UWORD32 u4_length)\n{\n\n dec_bit_stream_t *ps_bitstrm;\n\n\n dec_struct_t *ps_dec = (dec_struct_t *)dec_hdl->pv_codec_handle;\n ivd_video_decode_ip_t *ps_dec_in =\n (ivd_video_decode_ip_t *)ps_dec->pv_dec_in;\n dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;\n    UWORD8 u1_first_byte, u1_nal_ref_idc;\n    UWORD8 u1_nal_unit_type;\n    WORD32 i_status = OK;\n    ps_bitstrm = ps_dec->ps_bitstrm;\n\n if(pu1_buf)\n {\n if(u4_length)\n {\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ih264d_process_nal_unit(ps_dec->ps_bitstrm, pu1_buf,\n                                    u4_length);\n\n            SWITCHOFFTRACE;\n            u1_first_byte = ih264d_get_bits_h264(ps_bitstrm, 8);\n\n if(NAL_FORBIDDEN_BIT(u1_first_byte))\n {\n\n                 H264_DEC_DEBUG_PRINT(\"\\nForbidden bit set in Nal Unit, Let's try\\n\");\n             }\n             u1_nal_unit_type = NAL_UNIT_TYPE(u1_first_byte);\n             ps_dec->u1_nal_unit_type = u1_nal_unit_type;\n             u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_first_byte));\n switch(u1_nal_unit_type)\n {\n case SLICE_DATA_PARTITION_A_NAL:\n case SLICE_DATA_PARTITION_B_NAL:\n case SLICE_DATA_PARTITION_C_NAL:\n if(!ps_dec->i4_decode_header)\n                        ih264d_parse_slice_partition(ps_dec, ps_bitstrm);\n\n break;\n\n case IDR_SLICE_NAL:\n case SLICE_NAL:\n\n                    DEBUG_THREADS_PRINTF(\"Decoding  a slice NAL\\n\");\n if(!ps_dec->i4_decode_header)\n {\n if(ps_dec->i4_header_decoded == 3)\n {\n                            ps_dec->u4_slice_start_code_found = 1;\n\n                            ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n\n                            i_status = ih264d_parse_decode_slice(\n (UWORD8)(u1_nal_unit_type\n == IDR_SLICE_NAL),\n                                            u1_nal_ref_idc, ps_dec);\n\n if((ps_dec->u4_first_slice_in_pic != 0)&&\n ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0))\n {\n                                ps_dec->u4_first_slice_in_pic = 1;\n }\n\n if(i_status != OK)\n {\n return i_status;\n }\n }\n else\n {\n                            H264_DEC_DEBUG_PRINT(\n \"\\nSlice NAL Supplied but no header has been supplied\\n\");\n }\n }\n break;\n\n case SEI_NAL:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                        i_status = ih264d_parse_sei_message(ps_dec, ps_bitstrm);\n if(i_status != OK)\n return i_status;\n                        ih264d_parse_sei(ps_dec, ps_bitstrm);\n }\n break;\n case SEQ_PARAM_NAL:\n                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                    i_status = ih264d_parse_sps(ps_dec, ps_bitstrm);\n if(i_status == ERROR_INV_SPS_PPS_T)\n return i_status;\n if(!i_status)\n                        ps_dec->i4_header_decoded |= 0x1;\n break;\n\n case PIC_PARAM_NAL:\n                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                    i_status = ih264d_parse_pps(ps_dec, ps_bitstrm);\n if(i_status == ERROR_INV_SPS_PPS_T)\n return i_status;\n if(!i_status)\n                        ps_dec->i4_header_decoded |= 0x2;\n break;\n case ACCESS_UNIT_DELIMITER_RBSP:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_access_unit_delimiter_rbsp(ps_dec);\n }\n break;\n case END_OF_STREAM_RBSP:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_parse_end_of_stream(ps_dec);\n }\n break;\n case FILLER_DATA_NAL:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_parse_filler_data(ps_dec, ps_bitstrm);\n }\n break;\n default:\n                    H264_DEC_DEBUG_PRINT(\"\\nUnknown NAL type %d\\n\", u1_nal_unit_type);\n break;\n }\n\n }\n\n }\n\n return i_status;\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8526, "func": "static void send_packet(Ssh ssh, int pkttype, ...)\n{\n    struct Packet *pkt;\n    va_list ap;\n    va_start(ap, pkttype);\n    pkt = construct_packet(ssh, pkttype, ap);\n    va_end(ap);\n    s_wrpkt(ssh, pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187568, "func": "u32 h264bsdInitDpb(\n dpbStorage_t *dpb,\n  u32 picSizeInMbs,\n  u32 dpbSize,\n  u32 maxRefFrames,\n  u32 maxFrameNum,\n  u32 noReordering)\n{\n\n\n    u32 i;\n\n\n    ASSERT(picSizeInMbs);\n    ASSERT(maxRefFrames <= MAX_NUM_REF_PICS);\n    ASSERT(maxRefFrames <= dpbSize);\n\n     ASSERT(maxFrameNum);\n     ASSERT(dpbSize);\n \n     dpb->maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES;\n     dpb->maxRefFrames        = MAX(maxRefFrames, 1);\n     if (noReordering)\n        dpb->dpbSize         = dpb->maxRefFrames;\n else\n        dpb->dpbSize         = dpbSize;\n    dpb->maxFrameNum         = maxFrameNum;\n    dpb->noReordering        = noReordering;\n    dpb->fullness            = 0;\n    dpb->numRefFrames        = 0;\n    dpb->prevRefFrameNum     = 0;\n\n    ALLOCATE(dpb->buffer, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t);\n if (dpb->buffer == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n    H264SwDecMemset(dpb->buffer, 0,\n (MAX_NUM_REF_IDX_L0_ACTIVE + 1)*sizeof(dpbPicture_t));\n for (i = 0; i < dpb->dpbSize + 1; i++)\n {\n        ALLOCATE(dpb->buffer[i].pAllocatedData, (picSizeInMbs*384 + 32+15), u8);\n if (dpb->buffer[i].pAllocatedData == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n\n        dpb->buffer[i].data = ALIGN(dpb->buffer[i].pAllocatedData, 16);\n }\n\n    ALLOCATE(dpb->list, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t*);\n    ALLOCATE(dpb->outBuf, dpb->dpbSize+1, dpbOutPicture_t);\n\n if (dpb->list == NULL || dpb->outBuf == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n\n    H264SwDecMemset(dpb->list, 0,\n ((MAX_NUM_REF_IDX_L0_ACTIVE + 1) * sizeof(dpbPicture_t*)) );\n\n    dpb->numOut = dpb->outIndex = 0;\n\n return(HANTRO_OK);\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8322, "func": "XInsertModifiermapEntry(XModifierKeymap *map,\n#if NeedWidePrototypes\n\t\t\tunsigned int keycode,\n#else\n\t\t\tKeyCode keycode,\n#endif\n\t\t\tint modifier)\n{\n    XModifierKeymap *newmap;\n    int i,\n\trow = modifier * map->max_keypermod,\n\tnewrow,\n\tlastrow;\n\n    for (i=0; i<map->max_keypermod; i++) {\n        if (map->modifiermap[ row+i ] == keycode)\n\t    return(map); \n        if (map->modifiermap[ row+i ] == 0) {\n            map->modifiermap[ row+i ] = keycode;\n\t    return(map); \n\t}\n    }\n\n    if ((newmap = XNewModifiermap(map->max_keypermod+1)) == NULL)\n\treturn (XModifierKeymap *) NULL;\n    newrow = row = 0;\n    lastrow = newmap->max_keypermod * 8;\n    while (newrow < lastrow) {\n\tfor (i=0; i<map->max_keypermod; i++)\n\t    newmap->modifiermap[ newrow+i ] = map->modifiermap[ row+i ];\n\tnewmap->modifiermap[ newrow+i ] = 0;\n\trow += map->max_keypermod;\n\tnewrow += newmap->max_keypermod;\n    }\n    (void) XFreeModifiermap(map);\n    newrow = newmap->max_keypermod * modifier + newmap->max_keypermod - 1;\n    newmap->modifiermap[ newrow ] = keycode;\n    return(newmap);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8409, "func": "pvscsi_device_find(PVSCSIState *s, int channel, int target,\n                   uint8_t *requested_lun, uint8_t *target_lun)\n{\n    if (requested_lun[0] || requested_lun[2] || requested_lun[3] ||\n        requested_lun[4] || requested_lun[5] || requested_lun[6] ||\n        requested_lun[7] || (target > PVSCSI_MAX_DEVS)) {\n        return NULL;\n    } else {\n        *target_lun = requested_lun[1];\n        return scsi_device_find(&s->bus, channel, target, *target_lun);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9194, "func": "static enum virtio_device_endian virtio_default_endian(void)\n{\n    if (target_words_bigendian()) {\n        return VIRTIO_DEVICE_ENDIAN_BIG;\n    } else {\n        return VIRTIO_DEVICE_ENDIAN_LITTLE;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8850, "func": "static void vrend_destroy_sub_context(struct vrend_sub_context *sub)\n{\n   int i, j;\n   struct vrend_streamout_object *obj, *tmp;\n\n   if (sub->fb_id)\n      glDeleteFramebuffers(1, &sub->fb_id);\n\n   if (sub->blit_fb_ids[0])\n      glDeleteFramebuffers(2, sub->blit_fb_ids);\n\n   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      while (sub->enabled_attribs_bitmask) {\n         i = u_bit_scan(&sub->enabled_attribs_bitmask);\n\n         glDisableVertexAttribArray(i);\n      }\n      glDeleteVertexArrays(1, &sub->vaoid);\n   }\n\n   glBindVertexArray(0);\n\n   if (sub->current_so)\n      glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, 0);\n\n   LIST_FOR_EACH_ENTRY_SAFE(obj, tmp, &sub->streamout_list, head) {\n      vrend_destroy_streamout_object(obj);\n   }\n\n   vrend_shader_state_reference(&sub->shaders[PIPE_SHADER_VERTEX], NULL);\n   vrend_shader_state_reference(&sub->shaders[PIPE_SHADER_FRAGMENT], NULL);\n   vrend_shader_state_reference(&sub->shaders[PIPE_SHADER_GEOMETRY], NULL);\n\n   vrend_free_programs(sub);\n   for (i = 0; i < PIPE_SHADER_TYPES; i++) {\n      free(sub->consts[i].consts);\n      sub->consts[i].consts = NULL;\n\n      for (j = 0; j < PIPE_MAX_SHADER_SAMPLER_VIEWS; j++) {\n         vrend_sampler_view_reference(&sub->views[i].views[j], NULL);\n      }\n   }\n\n   if (sub->zsurf)\n      vrend_surface_reference(&sub->zsurf, NULL);\n\n   for (i = 0; i < sub->nr_cbufs; i++) {\n      if (!sub->surf[i])\n         continue;\n      vrend_surface_reference(&sub->surf[i], NULL);\n   }\n\n   vrend_resource_reference((struct vrend_resource **)&sub->ib.buffer, NULL);\n\n   vrend_object_fini_ctx_table(sub->object_hash);\n   vrend_clicbs->destroy_gl_context(sub->gl_context);\n\n   list_del(&sub->head);\n   FREE(sub);\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187976, "func": "WORD32 ih264d_parse_islice_data_cavlc(dec_struct_t * ps_dec,\n dec_slice_params_t * ps_slice,\n                                      UWORD16 u2_first_mb_in_slice)\n{\n    UWORD8 uc_more_data_flag;\n    UWORD8 u1_num_mbs, u1_mb_idx;\n dec_mb_info_t *ps_cur_mb_info;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    WORD16 i2_cur_mb_addr;\n    UWORD8 u1_mbaff;\n    UWORD8 u1_num_mbs_next, u1_end_of_row, u1_tfr_n_mb;\n    WORD32 ret = OK;\n\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    u1_num_mbs = u1_mb_idx;\n\n    uc_more_data_flag = 1;\n    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;\n\n do\n {\n        UWORD8 u1_mb_type;\n\n        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n {\n            ret = ERROR_MB_ADDRESS_T;\n break;\n }\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 0);\n\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n\n        ps_cur_deblk_mb->u1_mb_type = ps_cur_deblk_mb->u1_mb_type | D_INTRA_MB;\n\n {\n            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;\n            UWORD32 u4_word, u4_ldz, u4_temp;\n\n            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);\n            u4_ldz = CLZ(u4_word);\n            u4_bitstream_offset += (u4_ldz + 1);\n            u4_word = 0;\n if(u4_ldz)\n                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,\n                        u4_ldz);\n *pu4_bitstrm_ofst = u4_bitstream_offset;\n            u4_temp = ((1 << u4_ldz) + u4_word - 1);\n if(u4_temp > 25)\n return ERROR_MB_TYPE;\n            u1_mb_type = u4_temp;\n\n }\n        ps_cur_mb_info->u1_mb_type = u1_mb_type;\n        COPYTHECONTEXT(\"u1_mb_type\", u1_mb_type);\n\n if(25 == u1_mb_type)\n {\n            ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;\n            ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);\n if(ret != OK)\n return ret;\n            ps_cur_deblk_mb->u1_mb_qp = 0;\n }\n else\n {\n            ret = ih264d_parse_imb_cavlc(ps_dec, ps_cur_mb_info, u1_num_mbs, u1_mb_type);\n if(ret != OK)\n return ret;\n            ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n }\n\n if(u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n        i2_cur_mb_addr++;\n        uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);\n\n {\n mv_pred_t *ps_mv_nmb_start = ps_dec->ps_mv_cur + (u1_num_mbs << 4);\n\n mv_pred_t s_mvPred =\n {\n { 0, 0, 0, 0 },\n { -1, -1 }, 0, 0};\n            ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0,\n (UWORD8)(ps_dec->u1_cur_mb_fld_dec_flag << 1), 4,\n 4);\n }\n\n if(ps_dec->u4_num_cores < 3)\n {\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n                ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,\n\n                                      (UWORD16)(u1_num_mbs >> u1_mbaff));\n         }\n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n \n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || (!uc_more_data_flag);\n        ps_cur_mb_info->u1_end_of_slice = (!uc_more_data_flag);\n\n if(u1_tfr_n_mb || (!uc_more_data_flag))\n {\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n\n                                             u1_num_mbs_next, u1_tfr_n_mb,\n                                             u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n\n }\n }\n while(uc_more_data_flag);\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n\n - (u2_first_mb_in_slice << u1_mbaff);\n\n return ret;\n}\n", "target": 1, "flaw_line_index": "123"}
{"idx": 8345, "func": "static int xhci_setup_packet(XHCITransfer *xfer)\n{\n    XHCIState *xhci = xfer->xhci;\n    USBEndpoint *ep;\n    int dir;\n\n    dir = xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n    if (xfer->packet.ep) {\n        ep = xfer->packet.ep;\n    } else {\n        ep = xhci_epid_to_usbep(xhci, xfer->slotid, xfer->epid);\n        if (!ep) {\n            DPRINTF(\"xhci: slot %d has no device\\n\",\n                    xfer->slotid);\n            return -1;\n        }\n    }\n\n    xhci_xfer_create_sgl(xfer, dir == USB_TOKEN_IN); \n    usb_packet_setup(&xfer->packet, dir, ep, xfer->streamid,\n                     xfer->trbs[0].addr, false, xfer->int_req);\n    usb_packet_map(&xfer->packet, &xfer->sgl);\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n            xfer->packet.pid, ep->dev->addr, ep->nr);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9101, "func": "static int vrend_decode_create_stream_output_target(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   uint32_t res_handle, buffer_size, buffer_offset;\n\n   if (length != VIRGL_OBJ_STREAMOUT_SIZE)\n      return EINVAL;\n\n   res_handle = get_buf_entry(ctx, VIRGL_OBJ_STREAMOUT_RES_HANDLE);\n   buffer_offset = get_buf_entry(ctx, VIRGL_OBJ_STREAMOUT_BUFFER_OFFSET);\n   buffer_size = get_buf_entry(ctx, VIRGL_OBJ_STREAMOUT_BUFFER_SIZE);\n\n   return vrend_create_so_target(ctx->grctx, handle, res_handle, buffer_offset,\n                                 buffer_size);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187355, "func": "void InputConnectionImpl::CommitText(const base::string16& text,\n                                     int new_cursor_pos) {\n  StartStateUpdateTimer();\n\n  std::string error;\n  if (!ime_engine_->ClearComposition(input_context_id_, &error))\n    LOG(ERROR) << \"ClearComposition failed: error=\\\"\" << error << \"\\\"\";\n\n  if (IsControlChar(text)) {\n    SendControlKeyEvent(text);\n    return;\n  }\n\n   if (!ime_engine_->CommitText(input_context_id_,\n                                base::UTF16ToUTF8(text).c_str(), &error))\n     LOG(ERROR) << \"CommitText failed: error=\\\"\" << error << \"\\\"\";\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9143, "func": "static boolean parse_uint( const char **pcur, uint *val )\n{\n   const char *cur = *pcur;\n\n   if (is_digit( cur )) {\n      *val = *cur++ - '0';\n      while (is_digit( cur ))\n         *val = *val * 10 + *cur++ - '0';\n      *pcur = cur;\n      return TRUE;\n   }\n   return FALSE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8330, "func": "static XHCIEPContext *xhci_alloc_epctx(XHCIState *xhci,\n                                       unsigned int slotid,\n                                       unsigned int epid)\n{\n    XHCIEPContext *epctx;\n    int i;\n\n    epctx = g_new0(XHCIEPContext, 1);\n    epctx->xhci = xhci;\n    epctx->slotid = slotid;\n    epctx->epid = epid;\n\n    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) {\n        epctx->transfers[i].xhci = xhci;\n        epctx->transfers[i].slotid = slotid;\n        epctx->transfers[i].epid = epid;\n        usb_packet_init(&epctx->transfers[i].packet);\n    }\n    epctx->kick_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, xhci_ep_kick_timer, epctx);\n\n    return epctx;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188247, "func": "OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamVideoPortFormat:\n {\n\n             OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_VIDEO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > kMaxPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n if (formatParams->nIndex != 0) {\n return OMX_ErrorNoMore;\n }\n\n if (formatParams->nPortIndex == kInputPortIndex) {\n                formatParams->eCompressionFormat = mCodingType;\n                formatParams->eColorFormat = OMX_COLOR_FormatUnused;\n                formatParams->xFramerate = 0;\n } else {\n                CHECK_EQ(formatParams->nPortIndex, 1u);\n\n                formatParams->eCompressionFormat = OMX_VIDEO_CodingUnused;\n                formatParams->eColorFormat = OMX_COLOR_FormatYUV420Planar;\n                formatParams->xFramerate = 0;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoProfileLevelQuerySupported:\n {\n\n             OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileLevel =\n                   (OMX_VIDEO_PARAM_PROFILELEVELTYPE *) params;\n \n             if (profileLevel->nPortIndex != kInputPortIndex) {\n                 ALOGE(\"Invalid port index: %\" PRIu32, profileLevel->nPortIndex);\n                 return OMX_ErrorUnsupportedIndex;\n }\n\n if (profileLevel->nProfileIndex >= mNumProfileLevels) {\n return OMX_ErrorNoMore;\n }\n\n            profileLevel->eProfile = mProfileLevels[profileLevel->nProfileIndex].mProfile;\n            profileLevel->eLevel   = mProfileLevels[profileLevel->nProfileIndex].mLevel;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9022, "func": "static void vmxnet3_net_init(VMXNET3State *s)\n{\n    DeviceState *d = DEVICE(s);\n\n    VMW_CBPRN(\"vmxnet3_net_init called...\");\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    memcpy(&s->perm_mac.a, &s->conf.macaddr.a, sizeof(s->perm_mac.a));\n\n    s->mcast_list = NULL;\n    s->mcast_list_len = 0;\n\n    s->link_status_and_speed = VMXNET3_LINK_SPEED | VMXNET3_LINK_STATUS_UP;\n\n    VMW_CFPRN(\"Permanent MAC: \" MAC_FMT, MAC_ARG(s->perm_mac.a));\n\n    s->nic = qemu_new_nic(&net_vmxnet3_info, &s->conf,\n                          object_get_typename(OBJECT(s)),\n                          d->id, s);\n\n    s->peer_has_vhdr = vmxnet3_peer_has_vnet_hdr(s);\n    s->tx_sop = true;\n    s->skip_current_tx_pkt = false;\n    s->tx_pkt = NULL;\n    s->rx_pkt = NULL;\n    s->rx_vlan_stripping = false;\n    s->lro_supported = false;\n\n    if (s->peer_has_vhdr) {\n        qemu_set_vnet_hdr_len(qemu_get_queue(s->nic)->peer,\n            sizeof(struct virtio_net_hdr));\n\n        qemu_using_vnet_hdr(qemu_get_queue(s->nic)->peer, 1);\n    }\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9167, "func": "static bool build_and_check(GLuint id, const char *buf)\n{\n   GLint param;\n   glShaderSource(id, 1, (const char **)&buf, NULL);\n   glCompileShader(id);\n\n   glGetShaderiv(id, GL_COMPILE_STATUS, &param);\n   if (param == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetShaderInfoLog(id, 65536, &len, infolog);\n      fprintf(stderr,\"shader failed to compile\\n%s\\n\", infolog);\n      fprintf(stderr,\"GLSL:\\n%s\\n\", buf);\n      return false;\n   }\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188565, "func": "   void Reset() {\n     error_nframes_ = 0;\n     droppable_nframes_ = 0;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8745, "func": "vcard_response_new_bytes(VCard *card, unsigned char *buf, int len, int Le,\n                         unsigned char sw1, unsigned char sw2)\n{\n    VCardResponse *new_response;\n\n    if (len > Le) {\n        return vcard_init_buffer_response(card, buf, len);\n    }\n    new_response = vcard_response_new_data(buf, len);\n    if (new_response == NULL) {\n        return NULL;\n    }\n    vcard_response_set_status_bytes(new_response, sw1, sw2);\n    return new_response;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187843, "func": " const CuePoint* Cues::GetNext(const CuePoint* pCurr) const {\n  if (pCurr == NULL)\n     return NULL;\n \n  assert(pCurr->GetTimeCode() >= 0);\n  assert(m_cue_points);\n  assert(m_count >= 1);\n#if 0\n    const size_t count = m_count + m_preload_count;\n    size_t index = pCurr->m_index;\n    assert(index < count);\n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    assert(pp[index] == pCurr);\n    ++index;\n    if (index >= count)\n        return NULL;\n    CuePoint* const pNext = pp[index];\n    assert(pNext);\n    pNext->Load(m_pSegment->m_pReader);\n#else\n  long index = pCurr->m_index;\n  assert(index < m_count);\n   CuePoint* const* const pp = m_cue_points;\n  assert(pp);\n  assert(pp[index] == pCurr);\n \n   ++index;\n \n if (index >= m_count)\n\n     return NULL;\n \n   CuePoint* const pNext = pp[index];\n  assert(pNext);\n  assert(pNext->GetTimeCode() >= 0);\n#endif\n \n   return pNext;\n }\n", "target": 1, "flaw_line_index": "2,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,25,26,35,36,37"}
{"idx": 187904, "func": "void SoftVPXEncoder::onQueueFilled(OMX_U32 \n) {\n if (mCodecContext == NULL) {\n if (OK != initEncoder()) {\n            ALOGE(\"Failed to initialize encoder\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, \n                   NULL); \n return;\n }\n }\n\n vpx_codec_err_t codec_return;\n List<BufferInfo *> &inputBufferInfoQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outputBufferInfoQueue = getPortQueue(kOutputPortIndex);\n\n while (!inputBufferInfoQueue.empty() && !outputBufferInfoQueue.empty()) {\n BufferInfo *inputBufferInfo = *inputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *inputBufferHeader = inputBufferInfo->mHeader;\n\n BufferInfo *outputBufferInfo = *outputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo->mHeader;\n\n if ((inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) &&\n                inputBufferHeader->nFilledLen == 0) {\n            inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n            inputBufferInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inputBufferHeader);\n\n            outputBufferHeader->nFilledLen = 0;\n            outputBufferHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n            outputBufferInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outputBufferHeader);\n return;\n }\n\n\n         const uint8_t *source =\n             inputBufferHeader->pBuffer + inputBufferHeader->nOffset;\n \n         if (mInputDataIsMeta) {\n             source = extractGraphicBuffer(\n                    mConversionBuffer, mWidth * mHeight * 3 / 2,\n                     source, inputBufferHeader->nFilledLen,\n                     mWidth, mHeight);\n             if (source == NULL) {\n                ALOGE(\"Unable to extract gralloc buffer in metadata mode\");\n\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n                 return;\n             }\n        } else if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {\n            ConvertYUV420SemiPlanarToYUV420Planar(\n                    source, mConversionBuffer, mWidth, mHeight);\n \n            source = mConversionBuffer;\n         }\n         vpx_image_t raw_frame;\n         vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,\n                     kInputBufferAlignment, (uint8_t *)source);\n\n vpx_enc_frame_flags_t flags = 0;\n if (mTemporalPatternLength > 0) {\n            flags = getEncodeFlags();\n }\n if (mKeyFrameRequested) {\n            flags |= VPX_EFLAG_FORCE_KF;\n            mKeyFrameRequested = false;\n }\n\n if (mBitrateUpdated) {\n            mCodecConfiguration->rc_target_bitrate = mBitrate/1000;\n vpx_codec_err_t res = vpx_codec_enc_config_set(mCodecContext,\n                                                           mCodecConfiguration);\n if (res != VPX_CODEC_OK) {\n                ALOGE(\"vp8 encoder failed to update bitrate: %s\",\n                      vpx_codec_err_to_string(res));\n                notify(OMX_EventError,\n                       OMX_ErrorUndefined,\n 0, \n                       NULL); \n }\n            mBitrateUpdated = false;\n }\n\n uint32_t frameDuration;\n if (inputBufferHeader->nTimeStamp > mLastTimestamp) {\n            frameDuration = (uint32_t)(inputBufferHeader->nTimeStamp - mLastTimestamp);\n } else {\n            frameDuration = (uint32_t)(((uint64_t)1000000 << 16) / mFramerate);\n }\n        mLastTimestamp = inputBufferHeader->nTimeStamp;\n        codec_return = vpx_codec_encode(\n                mCodecContext,\n &raw_frame,\n                inputBufferHeader->nTimeStamp, \n                frameDuration, \n                flags, \n                VPX_DL_REALTIME); \n if (codec_return != VPX_CODEC_OK) {\n            ALOGE(\"vpx encoder failed to encode frame\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, \n                   NULL); \n return;\n }\n\n vpx_codec_iter_t encoded_packet_iterator = NULL;\n const vpx_codec_cx_pkt_t* encoded_packet;\n\n while ((encoded_packet = vpx_codec_get_cx_data(\n                        mCodecContext, &encoded_packet_iterator))) {\n if (encoded_packet->kind == VPX_CODEC_CX_FRAME_PKT) {\n\n                 outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;\n                 outputBufferHeader->nFlags = 0;\n                 if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)\n                  outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;\n                 outputBufferHeader->nOffset = 0;\n                 outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;\n                 memcpy(outputBufferHeader->pBuffer,\n                        encoded_packet->data.frame.buf,\n                        encoded_packet->data.frame.sz);\n                outputBufferInfo->mOwnedByUs = false;\n                outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n if (inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                    outputBufferHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n }\n                notifyFillBufferDone(outputBufferHeader);\n }\n }\n\n        inputBufferInfo->mOwnedByUs = false;\n        inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n        notifyEmptyBufferDone(inputBufferHeader);\n }\n}\n", "target": 1, "flaw_line_index": "47,56,57,58,60,123"}
{"idx": 188042, "func": "static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\n {\n     for (unsigned i = 0; i < nSamples; ++i) {\n         for (unsigned c = 0; c < nChannels; ++c) {\n *dst++ = src[c][i] << 8;\n }\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187977, "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(prev_slice_err == 1)\n {\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n {\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n\n                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                 }\n                 ps_dec->u1_mb_idx = 0;\n                 ps_dec->u4_num_mbs_cur_nmb = 0;\n             }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n\n         i2_cur_mb_addr++;\n \n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n         u1_num_mbsNby2++;\n         ps_parse_mb_data++;\n \n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n\n                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                             u1_tfr_n_mb, u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": "328"}
{"idx": 187346, "func": "xsltCopyTreeInternal(xsltTransformContextPtr ctxt,\n\t\t     xmlNodePtr invocNode,\n\t\t     xmlNodePtr node,\n\t\t     xmlNodePtr insert, int isLRE, int topElemVisited)\n{\n    xmlNodePtr copy;\n\n    if (node == NULL)\n\treturn(NULL);\n    switch (node->type) {\n        case XML_ELEMENT_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n        case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t    break;\n        case XML_TEXT_NODE: {\n\t    int noenc = (node->name == xmlStringTextNoenc);\n\t    return(xsltCopyTextString(ctxt, insert, node->content, noenc));\n\t    }\n        case XML_CDATA_SECTION_NODE:\n\t    return(xsltCopyTextString(ctxt, insert, node->content, 0));\n        case XML_ATTRIBUTE_NODE:\n\t    return((xmlNodePtr)\n\t\txsltShallowCopyAttr(ctxt, invocNode, insert, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xsltShallowCopyNsNode(ctxt, invocNode,\n\t\tinsert, (xmlNsPtr) node));\n\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n            return(NULL);\n    }\n    if (XSLT_IS_RES_TREE_FRAG(node)) {\n\tif (node->children != NULL)\n\t    copy = xsltCopyTreeList(ctxt, invocNode,\n\t\tnode->children, insert, 0, 0);\n\telse\n\t    copy = NULL;\n\treturn(copy);\n    }\n    copy = xmlDocCopyNode(node, insert->doc, 0);\n     if (copy != NULL) {\n \tcopy->doc = ctxt->output;\n \tcopy = xsltAddChild(insert, copy);\n\tif (insert->last != copy)\n\t    return(insert->last);\n\tcopy->next = NULL;\n\n\tif (node->type == XML_ELEMENT_NODE) {\n\t    if ((topElemVisited == 0) &&\n\t\t(node->parent != NULL) &&\n\t\t(node->parent->type != XML_DOCUMENT_NODE) &&\n\t\t(node->parent->type != XML_HTML_DOCUMENT_NODE))\n\t    {\n\t\txmlNsPtr *nsList, *curns, ns;\n\n\n\t\tnsList = xmlGetNsList(node->doc, node);\n\t\tif (nsList != NULL) {\n\t\t    curns = nsList;\n\t\t    do {\n\t\t\tns = xmlSearchNs(insert->doc, insert,\n\t\t\t    (*curns)->prefix);\n\n\t\t\tif ((ns == NULL) ||\n\t\t\t    (! xmlStrEqual(ns->href, (*curns)->href)))\n\t\t\t{\n\t\t\t    ns = NULL;\n#if 0\n\t\t\t    ns = xmlSearchNsByHref(insert->doc,\n\t\t\t\tinsert, (*curns)->href);\n#endif\n\t\t\t}\n\t\t\tif (ns == NULL) {\n\t\t\t    ns = xmlNewNs(copy, (*curns)->href,\n\t\t\t\t(*curns)->prefix);\n\t\t\t}\n\t\t\tif (node->ns == *curns) {\n\t\t\t    copy->ns = ns;\n\t\t\t}\n\t\t\tcurns++;\n\t\t    } while (*curns != NULL);\n\t\t    xmlFree(nsList);\n\t\t}\n\t    } else if (node->nsDef != NULL) {\n\t\tif (node->nsDef != NULL) {\n\t\t    if (isLRE)\n\t\t\txsltCopyNamespaceList(ctxt, copy, node->nsDef);\n\t\t    else\n\t\t\txsltCopyNamespaceListInternal(copy, node->nsDef);\n\t\t}\n\t    }\n\t    if (node->ns != NULL) {\n\t\tif (copy->ns == NULL) {\n\t\t    copy->ns = xsltGetSpecialNamespace(ctxt, invocNode,\n\t\t\tnode->ns->href, node->ns->prefix, copy);\n\t\t}\n\t    } else if ((insert->type == XML_ELEMENT_NODE) &&\n\t\t(insert->ns != NULL))\n\t    {\n\t\txsltGetSpecialNamespace(ctxt, invocNode, NULL, NULL, copy);\n\t    }\n\t    if (node->properties != NULL) {\n\t\txsltCopyAttrListNoOverwrite(ctxt, invocNode,\n\t\t    copy, node->properties);\n\t    }\n\t    if (topElemVisited == 0)\n\t\ttopElemVisited = 1;\n\t}\n\tif (node->children != NULL) {\n\t    xsltCopyTreeList(ctxt, invocNode,\n\t\tnode->children, copy, isLRE, topElemVisited);\n\t}\n    } else {\n\txsltTransformError(ctxt, NULL, invocNode,\n\t    \"xsltCopyTreeInternal: Copying of '%s' failed.\\n\", node->name);\n    }\n    return(copy);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188129, "func": "WORD32 ih264d_parse_sei_message(dec_struct_t *ps_dec,\n dec_bit_stream_t *ps_bitstrm)\n{\n    UWORD32 ui4_payload_type, ui4_payload_size;\n    UWORD32 u4_bits;\n    WORD32 i4_status = 0;\n\n do\n {\n\n         ui4_payload_type = 0;\n \n         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n        while(0xff == u4_bits)\n         {\n             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n             ui4_payload_type += 255;\n }\n        ui4_payload_type += u4_bits;\n\n \n         ui4_payload_size = 0;\n         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n        while(0xff == u4_bits)\n         {\n             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n             ui4_payload_size += 255;\n }\n        ui4_payload_size += u4_bits;\n\n        i4_status = ih264d_parse_sei_payload(ps_bitstrm, ui4_payload_type,\n                                             ui4_payload_size, ps_dec);\n if(i4_status == -1)\n {\n            i4_status = 0;\n break;\n }\n\n if(i4_status != OK)\n return i4_status;\n\n if(ih264d_check_byte_aligned(ps_bitstrm) == 0)\n {\n            u4_bits = ih264d_get_bit_h264(ps_bitstrm);\n if(0 == u4_bits)\n\n             {\n                 H264_DEC_DEBUG_PRINT(\"\\nError in parsing SEI message\");\n             }\n            while(0 == ih264d_check_byte_aligned(ps_bitstrm))\n             {\n                 u4_bits = ih264d_get_bit_h264(ps_bitstrm);\n                 if(u4_bits)\n {\n                    H264_DEC_DEBUG_PRINT(\"\\nError in parsing SEI message\");\n }\n }\n }\n }\n while(ps_bitstrm->u4_ofst < ps_bitstrm->u4_max_ofst);\n return (i4_status);\n}\n", "target": 1, "flaw_line_index": "14,24,50"}
{"idx": 8807, "func": "static inline const char *pipe_shader_to_prefix(int shader_type)\n{\n   switch (shader_type) {\n   case PIPE_SHADER_VERTEX: return \"vs\";\n   case PIPE_SHADER_FRAGMENT: return \"fs\";\n   case PIPE_SHADER_GEOMETRY: return \"gs\";\n   default:\n      return NULL;\n   };\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8811, "func": "static GLenum tgsitargettogltarget(const enum pipe_texture_target target, int nr_samples)\n{\n   switch(target) {\n   case PIPE_TEXTURE_1D:\n      return GL_TEXTURE_1D;\n   case PIPE_TEXTURE_2D:\n      return (nr_samples > 1) ? GL_TEXTURE_2D_MULTISAMPLE : GL_TEXTURE_2D;\n   case PIPE_TEXTURE_3D:\n      return GL_TEXTURE_3D;\n   case PIPE_TEXTURE_RECT:\n      return GL_TEXTURE_RECTANGLE_NV;\n   case PIPE_TEXTURE_CUBE:\n      return GL_TEXTURE_CUBE_MAP;\n\n   case PIPE_TEXTURE_1D_ARRAY:\n      return GL_TEXTURE_1D_ARRAY;\n   case PIPE_TEXTURE_2D_ARRAY:\n      return (nr_samples > 1) ? GL_TEXTURE_2D_MULTISAMPLE_ARRAY : GL_TEXTURE_2D_ARRAY;\n   case PIPE_TEXTURE_CUBE_ARRAY:\n      return GL_TEXTURE_CUBE_MAP_ARRAY;\n   case PIPE_BUFFER:\n   default:\n      return PIPE_BUFFER;\n   }\n   return PIPE_BUFFER;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187668, "func": "image_transform_png_set_scale_16_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->bit_depth == 16)\n    {\n      that->sample_depth = that->bit_depth = 8;\n if (that->red_sBIT > 8) that->red_sBIT = 8;\n if (that->green_sBIT > 8) that->green_sBIT = 8;\n if (that->blue_sBIT > 8) that->blue_sBIT = 8;\n if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;\n }\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 188593, "func": "  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        data[h * stride + w] = fill_constant;\n       }\n     }\n   }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 9110, "func": "void vrend_decode_reset(bool ctx_0_only)\n{\n   int i;\n\n   vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n\n   if (ctx_0_only == false) {\n      for (i = 1; i < VREND_MAX_CTX; i++) {\n         if (!dec_ctx[i])\n            continue;\n\n         if (!dec_ctx[i]->grctx)\n            continue;\n\n         vrend_destroy_context(dec_ctx[i]->grctx);\n         free(dec_ctx[i]);\n         dec_ctx[i] = NULL;\n      }\n   } else {\n      vrend_destroy_context(dec_ctx[0]->grctx);\n      free(dec_ctx[0]);\n      dec_ctx[0] = NULL;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8872, "func": "static void vrend_hw_emit_dsa(struct vrend_context *ctx)\n{\n   struct pipe_depth_stencil_alpha_state *state = &ctx->sub->dsa_state;\n\n   if (state->depth.enabled) {\n      vrend_depth_test_enable(ctx, true);\n      glDepthFunc(GL_NEVER + state->depth.func);\n      if (state->depth.writemask)\n         glDepthMask(GL_TRUE);\n      else\n         glDepthMask(GL_FALSE);\n   } else\n      vrend_depth_test_enable(ctx, false);\n\n   if (state->alpha.enabled) {\n      vrend_alpha_test_enable(ctx, true);\n      if (!vrend_state.use_core_profile)\n         glAlphaFunc(GL_NEVER + state->alpha.func, state->alpha.ref_value);\n   } else\n      vrend_alpha_test_enable(ctx, false);\n\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188086, "func": "static void setup_token_decoder(VP8D_COMP *pbi,\n const unsigned char* token_part_sizes)\n{\n    vp8_reader *bool_decoder = &pbi->mbc[0];\n unsigned int partition_idx;\n unsigned int fragment_idx;\n unsigned int num_token_partitions;\n const unsigned char *first_fragment_end = pbi->fragments.ptrs[0] +\n                                          pbi->fragments.sizes[0];\n\n    TOKEN_PARTITION multi_token_partition =\n (TOKEN_PARTITION)vp8_read_literal(&pbi->mbc[8], 2);\n if (!vp8dx_bool_error(&pbi->mbc[8]))\n        pbi->common.multi_token_partition = multi_token_partition;\n    num_token_partitions = 1 << pbi->common.multi_token_partition;\n\n for (fragment_idx = 0; fragment_idx < pbi->fragments.count; ++fragment_idx)\n {\n unsigned int fragment_size = pbi->fragments.sizes[fragment_idx];\n const unsigned char *fragment_end = pbi->fragments.ptrs[fragment_idx] +\n                                            fragment_size;\n if (fragment_idx == 0)\n {\n ptrdiff_t ext_first_part_size = token_part_sizes -\n                pbi->fragments.ptrs[0] + 3 * (num_token_partitions - 1);\n            fragment_size -= (unsigned int)ext_first_part_size;\n if (fragment_size > 0)\n {\n                pbi->fragments.sizes[0] = (unsigned int)ext_first_part_size;\n                fragment_idx++;\n                pbi->fragments.ptrs[fragment_idx] = pbi->fragments.ptrs[0] +\n                  pbi->fragments.sizes[0];\n }\n }\n while (fragment_size > 0)\n {\n ptrdiff_t partition_size = read_available_partition_size(\n                                                 pbi,\n                                                 token_part_sizes,\n                                                 pbi->fragments.ptrs[fragment_idx],\n                                                 first_fragment_end,\n                                                 fragment_end,\n                                                 fragment_idx - 1,\n                                                 num_token_partitions);\n            pbi->fragments.sizes[fragment_idx] = (unsigned int)partition_size;\n            fragment_size -= (unsigned int)partition_size;\n            assert(fragment_idx <= num_token_partitions);\n if (fragment_size > 0)\n {\n                fragment_idx++;\n                pbi->fragments.ptrs[fragment_idx] =\n                    pbi->fragments.ptrs[fragment_idx - 1] + partition_size;\n }\n }\n }\n\n    pbi->fragments.count = num_token_partitions + 1;\n\n for (partition_idx = 1; partition_idx < pbi->fragments.count; ++partition_idx)\n {\n if (vp8dx_start_decode(bool_decoder,\n                               pbi->fragments.ptrs[partition_idx],\n                               pbi->fragments.sizes[partition_idx],\n                               pbi->decrypt_cb, pbi->decrypt_state))\n            vpx_internal_error(&pbi->common.error, VPX_CODEC_MEM_ERROR,\n \"Failed to allocate bool decoder %d\",\n                               partition_idx);\n\n        bool_decoder++;\n\n     }\n \n #if CONFIG_MULTITHREAD\n    if (pbi->decoding_thread_count > num_token_partitions - 1)\n        pbi->decoding_thread_count = num_token_partitions - 1;\n #endif\n }\n", "target": 1, "flaw_line_index": "73,74,75"}
{"idx": 8715, "func": "url_has_scheme (const char *url)\n{\n  const char *p = url;\n\n  if (!*p || !SCHEME_CHAR (*p))\n    return false;\n  ++p;\n  while (*p && SCHEME_CHAR (*p))\n    ++p;\n  return *p == ':';\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187663, "func": " image_transform_png_set_rgb_to_gray_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n return (colour_type & PNG_COLOR_MASK_COLOR) != 0;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8349, "func": "static void xhci_xfer_report(XHCITransfer *xfer)\n{\n    uint32_t edtla = 0;\n    unsigned int left;\n    bool reported = 0;\n    bool shortpkt = 0;\n    XHCIEvent event = {ER_TRANSFER, CC_SUCCESS};\n    XHCIState *xhci = xfer->xhci;\n    int i;\n\n    left = xfer->packet.actual_length;\n\n    for (i = 0; i < xfer->trb_count; i++) {\n        XHCITRB *trb = &xfer->trbs[i];\n        unsigned int chunk = 0;\n\n        switch (TRB_TYPE(*trb)) {\n        case TR_SETUP:\n            chunk = trb->status & 0x1ffff;\n            if (chunk > 8) {\n                chunk = 8;\n            }\n            break;\n        case TR_DATA:\n        case TR_NORMAL:\n        case TR_ISOCH:\n            chunk = trb->status & 0x1ffff;\n            if (chunk > left) {\n                chunk = left;\n                if (xfer->status == CC_SUCCESS) {\n                    shortpkt = 1;\n                }\n            }\n            left -= chunk;\n            edtla += chunk;\n            break;\n        case TR_STATUS:\n            reported = 0;\n            shortpkt = 0;\n            break;\n        }\n\n        if (!reported && ((trb->control & TRB_TR_IOC) ||\n                          (shortpkt && (trb->control & TRB_TR_ISP)) ||\n                          (xfer->status != CC_SUCCESS && left == 0))) {\n            event.slotid = xfer->slotid;\n            event.epid = xfer->epid;\n            event.length = (trb->status & 0x1ffff) - chunk;\n            event.flags = 0;\n            event.ptr = trb->addr;\n            if (xfer->status == CC_SUCCESS) {\n                event.ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;\n            } else {\n                event.ccode = xfer->status;\n            }\n            if (TRB_TYPE(*trb) == TR_EVDATA) {\n                event.ptr = trb->parameter;\n                event.flags |= TRB_EV_ED;\n                event.length = edtla & 0xffffff;\n                DPRINTF(\"xhci_xfer_data: EDTLA=%d\\n\", event.length);\n                edtla = 0;\n            }\n            xhci_event(xhci, &event, TRB_INTR(*trb));\n            reported = 1;\n            if (xfer->status != CC_SUCCESS) {\n                return;\n            }\n        }\n\n        switch (TRB_TYPE(*trb)) {\n        case TR_SETUP:\n            reported = 0;\n            shortpkt = 0;\n            break;\n        }\n\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8763, "func": "static uint8_t* alloc_dhcp_option(int code, const char *str, int extra)\n{\n\tuint8_t *storage;\n\tint len = strnlen(str, 255);\n\tstorage = xzalloc(len + extra + OPT_DATA);\n\tstorage[OPT_CODE] = code;\n\tstorage[OPT_LEN] = len + extra;\n\tmemcpy(storage + extra + OPT_DATA, str, len);\n\treturn storage;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187353, "func": "xsltValueOf(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t           xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemValueOfPtr comp = (xsltStyleItemValueOfPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n #endif\n     xmlXPathObjectPtr res = NULL;\n     xmlChar *value = NULL;\n    xmlDocPtr oldXPContextDoc;\n    xmlNsPtr *oldXPNamespaces;\n    xmlNodePtr oldXPContextNode;\n    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n    xmlXPathContextPtr xpctxt;\n \n     if ((ctxt == NULL) || (node == NULL) || (inst == NULL))\n \treturn;\n\n    if ((comp == NULL) || (comp->select == NULL) || (comp->comp == NULL)) {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"Internal error in xsltValueOf(): \"\n\t    \"The XSLT 'value-of' instruction was not compiled.\\n\");\n\treturn;\n    }\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_VALUE_OF,xsltGenericDebug(xsltGenericDebugContext,\n \t \"xsltValueOf: select %s\\n\", comp->select));\n #endif\n \n    xpctxt = ctxt->xpathCtxt;\n    oldXPContextDoc = xpctxt->doc;\n    oldXPContextNode = xpctxt->node;\n    oldXPProximityPosition = xpctxt->proximityPosition;\n    oldXPContextSize = xpctxt->contextSize;\n    oldXPNsNr = xpctxt->nsNr;\n    oldXPNamespaces = xpctxt->namespaces;\n    xpctxt->node = node;\n    if (comp != NULL) {\n#ifdef XSLT_REFACTORED\n\tif (comp->inScopeNs != NULL) {\n\t    xpctxt->namespaces = comp->inScopeNs->list;\n\t    xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n\t} else {\n\t    xpctxt->namespaces = NULL;\n\t    xpctxt->nsNr = 0;\n\t}\n#else\n\txpctxt->namespaces = comp->nsList;\n\txpctxt->nsNr = comp->nsNr;\n#endif\n    } else {\n\txpctxt->namespaces = NULL;\n\txpctxt->nsNr = 0;\n    }\n    res = xmlXPathCompiledEval(comp->comp, xpctxt);\n    xpctxt->doc = oldXPContextDoc;\n    xpctxt->node = oldXPContextNode;\n    xpctxt->contextSize = oldXPContextSize;\n    xpctxt->proximityPosition = oldXPProximityPosition;\n    xpctxt->nsNr = oldXPNsNr;\n    xpctxt->namespaces = oldXPNamespaces;\n \n    if (res != NULL) {\n\tvalue = xmlXPathCastToString(res);\n\tif (value == NULL) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\"Internal error in xsltValueOf(): \"\n\t\t\"failed to cast an XPath object to string.\\n\");\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t    goto error;\n\t}\n\tif (value[0] != 0) {\n\t    xsltCopyTextString(ctxt, ctxt->insert, value, comp->noescape);\n\t}\n    } else {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"XPath evaluation returned no result.\\n\");\n\tctxt->state = XSLT_STATE_STOPPED;\n\tgoto error;\n    }\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if (value) {\n\tXSLT_TRACE(ctxt,XSLT_TRACE_VALUE_OF,xsltGenericDebug(xsltGenericDebugContext,\n\t     \"xsltValueOf: result '%s'\\n\", value));\n    }\n#endif\n\nerror:\n    if (value != NULL)\n\txmlFree(value);\n    if (res != NULL)\n\txmlXPathFreeObject(res);\n}\n", "target": 1, "flaw_line_index": "11,12,13,14,15,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63"}
{"idx": 188553, "func": "   virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n\n     inv_txfm_ = GET_PARAM(1);\n     version_  = GET_PARAM(2);  \n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188250, "func": "status_t ACodec::setupAACCodec(\n bool encoder, int32_t numChannels, int32_t sampleRate,\n int32_t bitRate, int32_t aacProfile, bool isADTS, int32_t sbrMode,\n int32_t maxOutputChannelCount, const drcParams_t& drc,\n int32_t pcmLimiterEnable) {\n if (encoder && isADTS) {\n return -EINVAL;\n }\n\n status_t err = setupRawAudioFormat(\n            encoder ? kPortIndexInput : kPortIndexOutput,\n            sampleRate,\n            numChannels);\n\n if (err != OK) {\n return err;\n }\n\n if (encoder) {\n        err = selectAudioPortFormat(kPortIndexOutput, OMX_AUDIO_CodingAAC);\n\n if (err != OK) {\n return err;\n }\n\n        OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n        def.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        def.format.audio.bFlagErrorConcealment = OMX_TRUE;\n        def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n        profile.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n        profile.nChannels = numChannels;\n\n        profile.eChannelMode =\n (numChannels == 1)\n ? OMX_AUDIO_ChannelModeMono: OMX_AUDIO_ChannelModeStereo;\n\n        profile.nSampleRate = sampleRate;\n        profile.nBitRate = bitRate;\n        profile.nAudioBandWidth = 0;\n        profile.nFrameLength = 0;\n        profile.nAACtools = OMX_AUDIO_AACToolAll;\n        profile.nAACERtools = OMX_AUDIO_AACERNone;\n        profile.eAACProfile = (OMX_AUDIO_AACPROFILETYPE) aacProfile;\n        profile.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n switch (sbrMode) {\n case 0:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case -1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n return BAD_VALUE;\n }\n\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n return err;\n }\n\n    OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n    profile.nPortIndex = kPortIndexInput;\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n    profile.nChannels = numChannels;\n    profile.nSampleRate = sampleRate;\n\n    profile.eAACStreamFormat =\n        isADTS\n ? OMX_AUDIO_AACStreamFormatMP4ADTS\n\n             : OMX_AUDIO_AACStreamFormatMP4FF;\n \n     OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE presentation;\n     presentation.nMaxOutputChannels = maxOutputChannelCount;\n     presentation.nDrcCut = drc.drcCut;\n     presentation.nDrcBoost = drc.drcBoost;\n    presentation.nHeavyCompression = drc.heavyCompression;\n    presentation.nTargetReferenceLevel = drc.targetRefLevel;\n    presentation.nEncodedTargetLevel = drc.encodedTargetLevel;\n    presentation.nPCMLimiterEnable = pcmLimiterEnable;\n\n status_t res = mOMX->setParameter(mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n if (res == OK) {\n        mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAacPresentation,\n &presentation, sizeof(presentation));\n } else {\n        ALOGW(\"did not set AudioAndroidAacPresentation due to error %d when setting AudioAac\", res);\n }\n return res;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8618, "func": "static int vmsvga_post_load(void *opaque, int version_id)\n{\n    struct vmsvga_state_s *s = opaque;\n\n    s->invalidated = 1;\n    if (s->config) {\n        s->fifo = (uint32_t *) s->fifo_ptr;\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187934, "func": "const sp<IMediaPlayerService>& MediaMetadataRetriever::getService()\n {\n     Mutex::Autolock lock(sServiceLock);\n     if (sService == 0) {\n        sp<IServiceManager> sm = defaultServiceManager();\n        sp<IBinder> binder;\n do {\n            binder = sm->getService(String16(\"media.player\"));\n if (binder != 0) {\n break;\n }\n            ALOGW(\"MediaPlayerService not published, waiting...\");\n            usleep(500000); \n } while (true);\n if (sDeathNotifier == NULL) {\n            sDeathNotifier = new DeathNotifier();\n }\n        binder->linkToDeath(sDeathNotifier);\n        sService = interface_cast<IMediaPlayerService>(binder);\n }\n    ALOGE_IF(sService == 0, \"no MediaPlayerService!?\");\n return sService;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8462, "func": "void CSoundFile::AdjustSampleLoop(MODINSTRUMENT *pIns)\n{\n\tif (!pIns->pSample) return;\n\tif (pIns->nLoopEnd > pIns->nLength) pIns->nLoopEnd = pIns->nLength;\n\tif (pIns->nLoopStart+2 >= pIns->nLoopEnd)\n\t{\n\t\tpIns->nLoopStart = pIns->nLoopEnd = 0;\n\t\tpIns->uFlags &= ~CHN_LOOP;\n\t}\n\tUINT len = pIns->nLength;\n\tif (pIns->uFlags & CHN_16BIT)\n\t{\n\t\tshort int *pSample = (short int *)pIns->pSample;\n\t\tif (pIns->uFlags & CHN_STEREO)\n\t\t{\n\t\t\tpSample[len*2+6] = pSample[len*2+4] = pSample[len*2+2] = pSample[len*2] = pSample[len*2-2];\n\t\t\tpSample[len*2+7] = pSample[len*2+5] = pSample[len*2+3] = pSample[len*2+1] = pSample[len*2-1];\n\t\t} else\n\t\t{\n\t\t\tpSample[len+4] = pSample[len+3] = pSample[len+2] = pSample[len+1] = pSample[len] = pSample[len-1];\n\t\t}\n\t\tif ((pIns->uFlags & (CHN_LOOP|CHN_PINGPONGLOOP|CHN_STEREO)) == CHN_LOOP)\n\t\t{\n\t\t\tif ((pIns->nLoopEnd+3 >= pIns->nLength) || (m_nType & MOD_TYPE_S3M))\n\t\t\t{\n\t\t\t\tpSample[pIns->nLoopEnd] = pSample[pIns->nLoopStart];\n\t\t\t\tpSample[pIns->nLoopEnd+1] = pSample[pIns->nLoopStart+1];\n\t\t\t\tpSample[pIns->nLoopEnd+2] = pSample[pIns->nLoopStart+2];\n\t\t\t\tpSample[pIns->nLoopEnd+3] = pSample[pIns->nLoopStart+3];\n\t\t\t\tpSample[pIns->nLoopEnd+4] = pSample[pIns->nLoopStart+4];\n\t\t\t}\n\t\t}\n\t} else\n\t{\n\t\tsigned char *pSample = pIns->pSample;\n#ifndef FASTSOUNDLIB\n\t\tif ((pIns->nLength > 0x100) && (m_nType & (MOD_TYPE_MOD|MOD_TYPE_S3M))\n\t\t && (!(pIns->uFlags & CHN_STEREO)))\n\t\t{\n\t\t\tint smpend = pSample[pIns->nLength-1], smpfix = 0, kscan;\n\t\t\tfor (kscan=pIns->nLength-1; kscan>0; kscan--)\n\t\t\t{\n\t\t\t\tsmpfix = pSample[kscan-1];\n\t\t\t\tif (smpfix != smpend) break;\n\t\t\t}\n\t\t\tint delta = smpfix - smpend;\n\t\t\tif (((!(pIns->uFlags & CHN_LOOP)) || (kscan > (int)pIns->nLoopEnd))\n\t\t\t && ((delta < -8) || (delta > 8)))\n\t\t\t{\n\t\t\t\twhile (kscan<(int)pIns->nLength)\n\t\t\t\t{\n\t\t\t\t\tif (!(kscan & 7))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (smpfix > 0) smpfix--;\n\t\t\t\t\t\tif (smpfix < 0) smpfix++;\n\t\t\t\t\t}\n\t\t\t\t\tpSample[kscan] = (signed char)smpfix;\n\t\t\t\t\tkscan++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tif (pIns->uFlags & CHN_STEREO)\n\t\t{\n\t\t\tpSample[len*2+6] = pSample[len*2+4] = pSample[len*2+2] = pSample[len*2] = pSample[len*2-2];\n\t\t\tpSample[len*2+7] = pSample[len*2+5] = pSample[len*2+3] = pSample[len*2+1] = pSample[len*2-1];\n\t\t} else\n\t\t{\n\t\t\tpSample[len+4] = pSample[len+3] = pSample[len+2] = pSample[len+1] = pSample[len] = pSample[len-1];\n\t\t}\n\t\tif ((pIns->uFlags & (CHN_LOOP|CHN_PINGPONGLOOP|CHN_STEREO)) == CHN_LOOP)\n\t\t{\n\t\t\tif ((pIns->nLoopEnd+3 >= pIns->nLength) || (m_nType & (MOD_TYPE_MOD|MOD_TYPE_S3M)))\n\t\t\t{\n\t\t\t\tpSample[pIns->nLoopEnd] = pSample[pIns->nLoopStart];\n\t\t\t\tpSample[pIns->nLoopEnd+1] = pSample[pIns->nLoopStart+1];\n\t\t\t\tpSample[pIns->nLoopEnd+2] = pSample[pIns->nLoopStart+2];\n\t\t\t\tpSample[pIns->nLoopEnd+3] = pSample[pIns->nLoopStart+3];\n\t\t\t\tpSample[pIns->nLoopEnd+4] = pSample[pIns->nLoopStart+4];\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187755, "func": " main(int argc, const char **argv)\n {\n    const char *  prog = *argv;\n    const char *  outfile = NULL;\n    const char *  suffix = NULL;\n const char *  prefix = NULL;\n int           done = 0; \n struct global global;\n\n   global_init(&global);\n\n while (--argc > 0)\n {\n ++argv;\n\n if (strcmp(*argv, \"--debug\") == 0)\n {\n         global.errors = global.warnings = 1;\n         global.quiet = 0;\n         global.verbose = 7;\n }\n\n else if (strncmp(*argv, \"--max=\", 6) == 0)\n {\n         global.idat_max = (png_uint_32)atol(6+*argv);\n\n if (global.skip < SKIP_UNSAFE)\n            global.skip = SKIP_UNSAFE;\n }\n\n else if (strcmp(*argv, \"--max\") == 0)\n {\n         global.idat_max = 0x7fffffff;\n\n if (global.skip < SKIP_UNSAFE)\n            global.skip = SKIP_UNSAFE;\n }\n\n else if (strcmp(*argv, \"--optimize\") == 0 || strcmp(*argv, \"-o\") == 0)\n         global.optimize_zlib = 1;\n\n else if (strncmp(*argv, \"--out=\", 6) == 0)\n         outfile = 6+*argv;\n\n else if (strncmp(*argv, \"--suffix=\", 9) == 0)\n         suffix = 9+*argv;\n\n else if (strncmp(*argv, \"--prefix=\", 9) == 0)\n         prefix = 9+*argv;\n\n else if (strcmp(*argv, \"--strip=none\") == 0)\n         global.skip = SKIP_NONE;\n\n else if (strcmp(*argv, \"--strip=crc\") == 0)\n         global.skip = SKIP_BAD_CRC;\n\n else if (strcmp(*argv, \"--strip=unsafe\") == 0)\n         global.skip = SKIP_UNSAFE;\n\n else if (strcmp(*argv, \"--strip=unused\") == 0)\n         global.skip = SKIP_UNUSED;\n\n else if (strcmp(*argv, \"--strip=transform\") == 0)\n         global.skip = SKIP_TRANSFORM;\n\n else if (strcmp(*argv, \"--strip=color\") == 0)\n         global.skip = SKIP_COLOR;\n\n else if (strcmp(*argv, \"--strip=all\") == 0)\n         global.skip = SKIP_ALL;\n\n else if (strcmp(*argv, \"--errors\") == 0 || strcmp(*argv, \"-e\") == 0)\n         global.errors = 1;\n\n else if (strcmp(*argv, \"--warnings\") == 0 || strcmp(*argv, \"-w\") == 0)\n         global.warnings = 1;\n\n else if (strcmp(*argv, \"--quiet\") == 0 || strcmp(*argv, \"-q\") == 0)\n {\n if (global.quiet)\n            global.quiet = 2;\n\n else\n            global.quiet = 1;\n }\n\n else if (strcmp(*argv, \"--verbose\") == 0 || strcmp(*argv, \"-v\") == 0)\n ++global.verbose;\n\n#if 0\n#     ifdef PNG_MAXIMUM_INFLATE_WINDOW\n else if (strcmp(*argv, \"--test\") == 0)\n ++set_option;\n#     endif\n#endif\n\n else if ((*argv)[0] == '-')\n         usage(prog);\n\n\n       else\n       {\n          size_t outlen = strlen(*argv);\n         char temp_name[FILENAME_MAX+1];\n \n          if (outfile == NULL) \n          {\n if (prefix != NULL)\n {\n size_t prefixlen = strlen(prefix);\n\n if (prefixlen+outlen > FILENAME_MAX)\n {\n                  fprintf(stderr, \"%s: output file name too long: %s%s%s\\n\",\n                     prog, prefix, *argv, suffix ? suffix : \"\");\n                  global.status_code |= WRITE_ERROR;\n continue;\n }\n\n               memcpy(temp_name, prefix, prefixlen);\n               memcpy(temp_name+prefixlen, *argv, outlen);\n               outlen += prefixlen;\n               outfile = temp_name;\n }\n\n else if (suffix != NULL)\n               memcpy(temp_name, *argv, outlen);\n\n            temp_name[outlen] = 0;\n\n if (suffix != NULL)\n {\n size_t suffixlen = strlen(suffix);\n\n if (outlen+suffixlen > FILENAME_MAX)\n {\n                  fprintf(stderr, \"%s: output file name too long: %s%s\\n\",\n                     prog, *argv, suffix);\n                  global.status_code |= WRITE_ERROR;\n continue;\n }\n\n               memcpy(temp_name+outlen, suffix, suffixlen);\n               outlen += suffixlen;\n               temp_name[outlen] = 0;\n               outfile = temp_name;\n }\n }\n\n (void)one_file(&global, *argv, outfile);\n ++done;\n         outfile = NULL;\n }\n }\n\n if (!done)\n      usage(prog);\n\n\n    return global_end(&global);\n }\n", "target": 1, "flaw_line_index": "104"}
{"idx": 187618, "func": "read_one_file(Image *image)\n{\n if (!(image->opts & READ_FILE) || (image->opts & USE_STDIO))\n {\n FILE *f = fopen(image->file_name, \"rb\");\n\n if (f != NULL)\n {\n if (image->opts & READ_FILE)\n            image->input_file = f;\n\n else \n {\n if (fseek(f, 0, SEEK_END) == 0)\n\n             {\n                long int cb = ftell(f);\n \n               if (cb > 0 && (unsigned long int)cb < (size_t)~(size_t)0)\n                {\n                  png_bytep b = voidcast(png_bytep, malloc((size_t)cb));\n                  if (b != NULL)\n                   {\n                     rewind(f);\n \n                     if (fread(b, (size_t)cb, 1, f) == 1)\n                      {\n                        fclose(f);\n                        image->input_memory_size = cb;\n                        image->input_memory = b;\n                      }\n \n                      else\n                     {\n                        free(b);\n                         return logclose(image, f, image->file_name,\n                           \": read failed: \");\n                     }\n                   }\n \n                   else\n                      return logclose(image, f, image->file_name,\n                        \": out of memory: \");\n                }\n \n                else if (cb == 0)\n return logclose(image, f, image->file_name,\n \": zero length: \");\n\n else\n return logclose(image, f, image->file_name,\n \": tell failed: \");\n }\n\n else\n return logclose(image, f, image->file_name, \": seek failed: \");\n }\n }\n\n else\n return logerror(image, image->file_name, \": open failed: \",\n            strerror(errno));\n }\n\n return read_file(image, FORMAT_NO_CHANGE, NULL);\n}\n", "target": 1, "flaw_line_index": "19,21,22,24,26,28,29,30,34,35,37,38,43"}
{"idx": 187839, "func": " const BlockEntry* Cluster::GetEntry(const CuePoint& cp,\n                                     const CuePoint::TrackPosition& tp) const {\n   assert(m_pSegment);\n#if 0\n    LoadBlockEntries();\n    if (m_entries == NULL)\n        return NULL;\n    const long long count = m_entries_count;\n    if (count <= 0)\n        return NULL;\n    const long long tc = cp.GetTimeCode();\n    if ((tp.m_block > 0) && (tp.m_block <= count))\n    {\n        const size_t block = static_cast<size_t>(tp.m_block);\n        const size_t index = block - 1;\n        const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if ((pBlock->GetTrackNumber() == tp.m_track) &&\n            (pBlock->GetTimeCode(this) == tc))\n        {\n            return pEntry;\n        }\n    }\n    const BlockEntry* const* i = m_entries;\n    const BlockEntry* const* const j = i + count;\n    while (i != j)\n    {\n#ifdef _DEBUG\n        const ptrdiff_t idx = i - m_entries;\n        idx;\n#endif\n        const BlockEntry* const pEntry = *i++;\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if (pBlock->GetTrackNumber() != tp.m_track)\n            continue;\n        const long long tc_ = pBlock->GetTimeCode(this);\n        assert(tc_ >= 0);\n        if (tc_ < tc)\n            continue;\n        if (tc_ > tc)\n            return NULL;\n        const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n        const long tn = static_cast<long>(tp.m_track);\n        const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n        if (pTrack == NULL)\n            return NULL;\n        const long long type = pTrack->GetType();\n        if (type == 2)  \n            return pEntry;\n        if (type != 1)  \n            return NULL;\n        if (!pBlock->IsKey())\n            return NULL;\n        return pEntry;\n    }\n    return NULL;\n#else\n   const long long tc = cp.GetTimeCode();\n \n   if (tp.m_block > 0) {\n const long block = static_cast<long>(tp.m_block);\n const long index = block - 1;\n\n while (index >= m_entries_count) {\n long long pos;\n long len;\n\n const long status = Parse(pos, len);\n\n if (status < 0) \n return NULL;\n\n if (status > 0) \n return NULL;\n }\n\n const BlockEntry* const pEntry = m_entries[index];\n    assert(pEntry);\n    assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n\n if ((pBlock->GetTrackNumber() == tp.m_track) &&\n (pBlock->GetTimeCode(this) == tc)) {\n return pEntry;\n }\n }\n\n long index = 0;\n\n for (;;) {\n if (index >= m_entries_count) {\n long long pos;\n long len;\n\n const long status = Parse(pos, len);\n\n if (status < 0) \n return NULL;\n\n if (status > 0) \n return NULL;\n\n      assert(m_entries);\n      assert(index < m_entries_count);\n }\n\n const BlockEntry* const pEntry = m_entries[index];\n    assert(pEntry);\n    assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n\n if (pBlock->GetTrackNumber() != tp.m_track) {\n ++index;\n continue;\n }\n\n const long long tc_ = pBlock->GetTimeCode(this);\n\n if (tc_ < tc) {\n ++index;\n continue;\n }\n\n if (tc_ > tc)\n return NULL;\n\n const Tracks* const pTracks = m_pSegment->GetTracks();\n    assert(pTracks);\n\n const long tn = static_cast<long>(tp.m_track);\n const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n\n if (pTrack == NULL)\n return NULL;\n\n const long long type = pTrack->GetType();\n\n if (type == 2) \n return pEntry;\n\n if (type != 1) \n return NULL;\n\n if (!pBlock->IsKey())\n return NULL;\n\n \n     return pEntry;\n   }\n#endif\n }\n", "target": 1, "flaw_line_index": "4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,161"}
{"idx": 188545, "func": "   void RunInvAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       double out_r[kNumCoeffs];\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        in[j] = src[j] - dst[j];\n       }\n \n       reference_16x16_dct_2d(in, out_r);\n       for (int j = 0; j < kNumCoeffs; ++j)\n        coeff[j] = round(out_r[j]);\n \n      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         EXPECT_GE(1u, error)\n             << \"Error: 16x16 IDCT has error \" << error\n << \" at index \" << j;\n\n       }\n     }\n   }\n", "target": 1, "flaw_line_index": "4,5,6,7,14,15,16,21,23"}
{"idx": 187582, "func": " static void print_maps(struct pid_info_t* info)\n {\n     FILE *maps;\n     size_t offset;\n     char device[10];\n     long int inode;\n    char file[PATH_MAX];\n \n     strlcat(info->path, \"maps\", sizeof(info->path));\n \n    maps = fopen(info->path, \"r\");\n\n     if (!maps)\n         goto out;\n \n    while (fscanf(maps, \"%*x-%*x %*s %zx %s %ld %s\\n\", &offset, device, &inode,\n            file) == 4) {\n         if (inode == 0 || !strcmp(device, \"00:00\"))\n             continue;\n\n        printf(\"%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\\n\",\n                info->cmdline, info->pid, info->user, \"mem\",\n \"???\", device, offset, inode, file);\n }\n\n    fclose(maps);\n\nout:\n    info->path[info->parent_length] = '\\0';\n}\n", "target": 1, "flaw_line_index": "7,16,17"}
{"idx": 8489, "func": "UINT CSoundFile::PackSample(int &sample, int next)\n{\n\tUINT i = 0;\n\tint delta = next - sample;\n\tif (delta >= 0)\n\t{\n\t\tfor (i=0; i<7; i++) if (delta <= (int)CompressionTable[i+1]) break;\n\t} else\n\t{\n\t\tfor (i=8; i<15; i++) if (delta >= (int)CompressionTable[i+1]) break;\n\t}\n\tsample += (int)CompressionTable[i];\n\treturn i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187995, "func": "static void debugCallback (int fd, short flags, void *param) {\n int acceptFD, option;\n struct sockaddr_un peeraddr;\n socklen_t socklen = sizeof (peeraddr);\n\n     int data;\n     unsigned int qxdm_data[6];\n     const char *deactData[1] = {\"1\"};\n    char *actData[1];\n     RIL_Dial dialData;\n     int hangupData[1] = {1};\n     int number;\n     char **args;\n     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;\n     int sim_id = 0;\n \n     RLOGI(\"debugCallback for socket %s\", rilSocketIdToString(socket_id));\n\n    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);\n\n if (acceptFD < 0) {\n        RLOGE (\"error accepting on debug port: %d\\n\", errno);\n return;\n }\n\n if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {\n        RLOGE (\"error reading on socket: number of Args: \\n\");\n        close(acceptFD);\n return;\n }\n\n if (number < 0) {\n        RLOGE (\"Invalid number of arguments: \\n\");\n        close(acceptFD);\n return;\n }\n\n    args = (char **) calloc(number, sizeof(char*));\n if (args == NULL) {\n        RLOGE(\"Memory allocation failed for debug args\");\n        close(acceptFD);\n return;\n }\n\n for (int i = 0; i < number; i++) {\n int len;\n if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {\n            RLOGE (\"error reading on socket: Len of Args: \\n\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n if (len == INT_MAX || len < 0) {\n            RLOGE(\"Invalid value of len: \\n\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n\n        args[i] = (char *) calloc(len + 1, sizeof(char));\n if (args[i] == NULL) {\n            RLOGE(\"Memory allocation failed for debug args\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n if (recv(acceptFD, args[i], sizeof(char) * len, 0)\n != (int)sizeof(char) * len) {\n            RLOGE (\"error reading on socket: Args[%d] \\n\", i);\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n char * buf = args[i];\n        buf[len] = 0;\n if ((i+1) == number) {\n            sim_id = atoi(args[i]);\n switch (sim_id) {\n case 0:\n                    socket_id = RIL_SOCKET_1;\n break;\n #if (SIM_COUNT >= 2)\n case 1:\n                    socket_id = RIL_SOCKET_2;\n break;\n #endif\n #if (SIM_COUNT >= 3)\n case 2:\n                    socket_id = RIL_SOCKET_3;\n break;\n #endif\n #if (SIM_COUNT >= 4)\n case 3:\n                    socket_id = RIL_SOCKET_4;\n break;\n #endif\n default:\n                    socket_id = RIL_SOCKET_1;\n break;\n }\n }\n }\n\n switch (atoi(args[0])) {\n case 0:\n            RLOGI (\"Connection on debug port: issuing reset.\");\n            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);\n break;\n case 1:\n            RLOGI (\"Connection on debug port: issuing radio power off.\");\n            data = 0;\n            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);\n if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {\n                close(s_ril_param_socket.fdCommand);\n                s_ril_param_socket.fdCommand = -1;\n }\n #if (SIM_COUNT == 2)\n else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {\n                close(s_ril_param_socket2.fdCommand);\n                s_ril_param_socket2.fdCommand = -1;\n }\n #endif\n break;\n case 2:\n            RLOGI (\"Debug port: issuing unsolicited voice network change.\");\n            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);\n break;\n case 3:\n            RLOGI (\"Debug port: QXDM log enable.\");\n            qxdm_data[0] = 65536; \n            qxdm_data[1] = 16; \n            qxdm_data[2] = 1; \n            qxdm_data[3] = 32; \n            qxdm_data[4] = 0; \n            qxdm_data[5] = 8; \n            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,\n 6 * sizeof(int), socket_id);\n break;\n case 4:\n            RLOGI (\"Debug port: QXDM log disable.\");\n            qxdm_data[0] = 65536;\n            qxdm_data[1] = 16;\n            qxdm_data[2] = 0; \n            qxdm_data[3] = 32;\n            qxdm_data[4] = 0;\n            qxdm_data[5] = 8;\n            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,\n 6 * sizeof(int), socket_id);\n break;\n case 5:\n            RLOGI(\"Debug port: Radio On\");\n            data = 1;\n            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);\n            sleep(2);\n\n             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);\n             break;\n        case 6:\n            RLOGI(\"Debug port: Setup Data Call, Apn :%s\\n\", args[1]);\n            actData[0] = args[1];\n            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,\n                              sizeof(actData), socket_id);\n            break;\n         case 7:\n             RLOGI(\"Debug port: Deactivate Data Call\");\n             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,\n sizeof(deactData), socket_id);\n break;\n\n         case 8:\n             RLOGI(\"Debug port: Dial Call\");\n             dialData.clir = 0;\n             dialData.address = args[1];\n             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);\n             break;\n case 9:\n            RLOGI(\"Debug port: Answer Call\");\n            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);\n break;\n case 10:\n            RLOGI(\"Debug port: End Call\");\n            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,\n sizeof(hangupData), socket_id);\n break;\n default:\n            RLOGE (\"Invalid request\");\n break;\n }\n    freeDebugCallbackArgs(number, args);\n    close(acceptFD);\n}\n", "target": 1, "flaw_line_index": "9,161,162,163,164,165,166"}
{"idx": 187439, "func": "static char* allocFromUTF16(const char16_t* in, size_t len)\n\n {\n     if (len == 0) return getEmptyString();\n \n    const ssize_t bytes = utf16_to_utf8_length(in, len);\n    if (bytes < 0) {\n         return getEmptyString();\n     }\n \n    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);\n     ALOG_ASSERT(buf, \"Unable to allocate shared buffer\");\n     if (!buf) {\n         return getEmptyString();\n     }\n \n    char* str = (char*)buf->data();\n    utf16_to_utf8(in, len, str);\n    return str;\n }\n", "target": 1, "flaw_line_index": "6,7,11,17,18,19"}
{"idx": 187629, "func": "deinterlace_row(png_bytep buffer, png_const_bytep row,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   png_uint_32 xin, xout, xstep;\n   xout = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xin=0; xout<w; xout+=xstep)\n   {\n      pixel_copy(buffer, xout, row, xin, pixel_size);\n      ++xin;\n   }\n}\n", "target": 1, "flaw_line_index": "2,3,3,3,4,5,6,7,8,9,10,11,12"}
{"idx": 187684, "func": "make_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,\n    int bdlo, int PNG_CONST bdhi)\n {\n    for (; bdlo <= bdhi; ++bdlo)\n    {\n int interlace_type;\n\n for (interlace_type = PNG_INTERLACE_NONE;\n           interlace_type < INTERLACE_LAST; ++interlace_type)\n {\n unsigned int test;\n\n          char name[FILE_NAME_SIZE];\n \n          standard_name(name, sizeof name, 0, colour_type, 1<<bdlo, 0,\n            interlace_type, 0, 0, 0);\n \n         for (test=0; test<(sizeof error_test)/(sizeof error_test[0]); ++test)\n          {\n             make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type,\n                test, name);\n\n if (fail(pm))\n return 0;\n }\n }\n }\n\n return 1; \n}\n", "target": 1, "flaw_line_index": "2,16,18"}
{"idx": 8332, "func": "static int xhci_complete_packet(XHCITransfer *xfer)\n{\n    if (xfer->packet.status == USB_RET_ASYNC) {\n        trace_usb_xhci_xfer_async(xfer);\n        xfer->running_async = 1;\n        xfer->running_retry = 0;\n        xfer->complete = 0;\n        return 0;\n    } else if (xfer->packet.status == USB_RET_NAK) {\n        trace_usb_xhci_xfer_nak(xfer);\n        xfer->running_async = 0;\n        xfer->running_retry = 1;\n        xfer->complete = 0;\n        return 0;\n    } else {\n        xfer->running_async = 0;\n        xfer->running_retry = 0;\n        xfer->complete = 1;\n        xhci_xfer_unmap(xfer);\n    }\n\n    if (xfer->packet.status == USB_RET_SUCCESS) {\n        trace_usb_xhci_xfer_success(xfer, xfer->packet.actual_length);\n        xfer->status = CC_SUCCESS;\n        xhci_xfer_report(xfer);\n        return 0;\n    }\n\n    trace_usb_xhci_xfer_error(xfer, xfer->packet.status);\n    switch (xfer->packet.status) {\n    case USB_RET_NODEV:\n    case USB_RET_IOERROR:\n        xfer->status = CC_USB_TRANSACTION_ERROR;\n        xhci_xfer_report(xfer);\n        xhci_stall_ep(xfer);\n        break;\n    case USB_RET_STALL:\n        xfer->status = CC_STALL_ERROR;\n        xhci_xfer_report(xfer);\n        xhci_stall_ep(xfer);\n        break;\n    case USB_RET_BABBLE:\n        xfer->status = CC_BABBLE_DETECTED;\n        xhci_xfer_report(xfer);\n        xhci_stall_ep(xfer);\n        break;\n    default:\n        DPRINTF(\"%s: FIXME: status = %d\\n\", __func__,\n                xfer->packet.status);\n        FIXME(\"unhandled USB_RET_*\");\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188144, "func": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp) {\n\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     header->nFilledLen = rangeLength;\n     header->nOffset = rangeOffset;\n \n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    buffer_meta->CopyToOMX(header);\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187621, "func": "read_callback(png_structp pp, png_unknown_chunkp pc)\n{\n   display *d = voidcast(display*, png_get_user_chunk_ptr(pp));\n int chunk = findb(pc->name);\n int keep, discard;\n\n if (chunk < 0) \n      keep = d->keep;\n\n else\n {\n      keep = chunk_info[chunk].keep;\n if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n {\n if (chunk_info[chunk].unknown)\n            keep = d->keep;\n\n else\n            keep = PNG_HANDLE_CHUNK_NEVER;\n }\n }\n\n switch (keep)\n {\n default:\n         fprintf(stderr, \"%s(%s): %d: unrecognized chunk option\\n\", d->file,\n            d->test, chunk_info[chunk].keep);\n         display_exit(d);\n\n case PNG_HANDLE_CHUNK_AS_DEFAULT:\n case PNG_HANDLE_CHUNK_NEVER:\n         discard = 1\n;\n break;\n\n case PNG_HANDLE_CHUNK_IF_SAFE:\n case PNG_HANDLE_CHUNK_ALWAYS:\n         discard = 0\n;\n break;\n }\n\n if (chunk >= 0) if (!discard) \n {\n      png_uint_32 flag = chunk_info[chunk].flag;\n\n if (pc->location & PNG_AFTER_IDAT)\n         d->after_IDAT |= flag;\n\n else\n         d->before_IDAT |= flag;\n }\n\n\n#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n       return discard;\n #  else\n       return 1; \n#  endif\n\n }\n", "target": 1, "flaw_line_index": "55"}
{"idx": 187728, "func": " store_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize,\n   size_t pos, PNG_CONST char *msg)\n {\n    if (pp != NULL && pp == ps->pread)\n    {\n      pos = safecat(buffer, bufsize, pos, \"read: \");\n\n if (ps->current != NULL)\n {\n         pos = safecat(buffer, bufsize, pos, ps->current->name);\n         pos = safecat(buffer, bufsize, pos, sep);\n }\n }\n\n else if (pp != NULL && pp == ps->pwrite)\n {\n      pos = safecat(buffer, bufsize, pos, \"write: \");\n      pos = safecat(buffer, bufsize, pos, ps->wname);\n      pos = safecat(buffer, bufsize, pos, sep);\n }\n\n else\n {\n      pos = safecat(buffer, bufsize, pos, \"pngvalid: \");\n }\n\n if (ps->test[0] != 0)\n {\n      pos = safecat(buffer, bufsize, pos, ps->test);\n      pos = safecat(buffer, bufsize, pos, sep);\n }\n   pos = safecat(buffer, bufsize, pos, msg);\n return pos;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187446, "func": "static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)\n{\n int i;\n\n for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)\n {\n if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)\n {\n if (check_a2dp_ready(common) == 0)\n\n                 break;\n \n             ERROR(\"error : a2dp not ready, wait 250 ms and retry\");\n            usleep(250000);\n             skt_disconnect(common->ctrl_fd);\n             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n         }\n \n        usleep(250000);\n     }\n }\n", "target": 1, "flaw_line_index": "14,19"}
{"idx": 8451, "func": "pvscsi_ring_init_msg(PVSCSIRingInfo *m, PVSCSICmdDescSetupMsgRing *ri)\n{\n    int i;\n    uint32_t len_log2;\n    uint32_t ring_size;\n\n    if (ri->numPages > PVSCSI_SETUP_MSG_RING_MAX_NUM_PAGES) {\n        return -1;\n    }\n    ring_size = ri->numPages * PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE;\n    len_log2 = pvscsi_log2(ring_size - 1);\n\n    m->msg_len_mask = MASK(len_log2);\n\n    m->filled_msg_ptr = 0;\n\n    for (i = 0; i < ri->numPages; i++) {\n        m->msg_ring_pages_pa[i] = ri->ringPPNs[i] << VMW_PAGE_SHIFT;\n    }\n\n    RS_SET_FIELD(m, msgProdIdx, 0);\n    RS_SET_FIELD(m, msgConsIdx, 0);\n    RS_SET_FIELD(m, msgNumEntriesLog2, len_log2);\n\n    trace_pvscsi_ring_init_msg(len_log2);\n\n    smp_wmb();\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187467, "func": "int btpan_tap_open()\n{\n struct ifreq ifr;\n int fd, err;\n const char *clonedev = \"/dev/tun\";\n\n \n \n    if ((fd = open(clonedev, O_RDWR)) < 0)\n     {\n         BTIF_TRACE_DEBUG(\"could not open %s, err:%d\", clonedev, errno);\n         return fd;\n }\n\n    memset(&ifr, 0, sizeof(ifr));\n    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\n\n     strncpy(ifr.ifr_name, TAP_IF_NAME, IFNAMSIZ);\n \n    if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0)\n     {\n         BTIF_TRACE_DEBUG(\"ioctl error:%d, errno:%s\", err, strerror(errno));\n         close(fd);\n return err;\n\n     }\n     if (tap_if_up(TAP_IF_NAME, controller_get_interface()->get_address()) == 0)\n     {\n        int flags = fcntl(fd, F_GETFL, 0);\n        fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n         return fd;\n     }\n     BTIF_TRACE_ERROR(\"can not bring up tap interface:%s\", TAP_IF_NAME);\n    close(fd);\n return INVALID_FD;\n}\n", "target": 1, "flaw_line_index": "9,21,30,31"}
{"idx": 8334, "func": "static TRBCCode xhci_enable_slot(XHCIState *xhci, unsigned int slotid)\n{\n    trace_usb_xhci_slot_enable(slotid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    xhci->slots[slotid-1].enabled = 1;\n    xhci->slots[slotid-1].uport = NULL;\n    memset(xhci->slots[slotid-1].eps, 0, sizeof(XHCIEPContext*)*31);\n\n    return CC_SUCCESS;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8912, "func": "int vrend_renderer_resource_attach_iov(int res_handle, struct iovec *iov,\n                                       int num_iovs)\n{\n   struct vrend_resource *res;\n\n   res = vrend_resource_lookup(res_handle, 0);\n   if (!res)\n      return EINVAL;\n\n   if (res->iov)\n      return 0;\n\n   res->iov = iov;\n   res->num_iovs = num_iovs;\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9188, "func": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8465, "func": "CSoundFile::CSoundFile()\n{\n\tm_nType = MOD_TYPE_NONE;\n\tm_dwSongFlags = 0;\n\tm_nChannels = 0;\n\tm_nMixChannels = 0;\n\tm_nSamples = 0;\n\tm_nInstruments = 0;\n\tm_nPatternNames = 0;\n\tm_lpszPatternNames = NULL;\n\tm_lpszSongComments = NULL;\n\tm_nFreqFactor = m_nTempoFactor = 128;\n\tm_nMasterVolume = 128;\n\tm_nMinPeriod = 0x20;\n\tm_nMaxPeriod = 0x7FFF;\n\tm_nRepeatCount = 0;\n\tmemset(Chn, 0, sizeof(Chn));\n\tmemset(ChnMix, 0, sizeof(ChnMix));\n\tmemset(Ins, 0, sizeof(Ins));\n\tmemset(ChnSettings, 0, sizeof(ChnSettings));\n\tmemset(Headers, 0, sizeof(Headers));\n\tmemset(Order, 0xFF, sizeof(Order));\n\tmemset(Patterns, 0, sizeof(Patterns));\n\tmemset(m_szNames, 0, sizeof(m_szNames));\n\tmemset(m_MixPlugins, 0, sizeof(m_MixPlugins));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188587, "func": "void fht8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht8x8_c(in, out, stride, tx_type);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8624, "func": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n{\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n        s->redraw_fifo_first = s->redraw_fifo_last;\n        return;\n    }\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n        rect = &s->redraw_fifo[s->redraw_fifo_first++];\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188217, "func": "OMX_ERRORTYPE SoftAMRNBEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.amrnb\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAMR)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (amrParams->nChannels != 1\n || amrParams->eAMRDTXMode != OMX_AUDIO_AMRDTXModeOff\n || amrParams->eAMRFrameFormat\n != OMX_AUDIO_AMRFrameFormatFSF\n || amrParams->eAMRBandMode < OMX_AUDIO_AMRBandModeNB0\n || amrParams->eAMRBandMode > OMX_AUDIO_AMRBandModeNB7) {\n return OMX_ErrorUndefined;\n }\n\n            mBitRate = amrParams->nBitRate;\n            mMode = amrParams->eAMRBandMode - 1;\n\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels != 1\n || pcmParams->nSamplingRate != (OMX_U32)kSampleRate) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188519, "func": " int main(int argc, char **argv)\n {\n    FILE                *infile, *outfile[NUM_ENCODERS];\n     vpx_codec_ctx_t      codec[NUM_ENCODERS];\n     vpx_codec_enc_cfg_t  cfg[NUM_ENCODERS];\n    vpx_codec_pts_t      frame_cnt = 0;\n     vpx_image_t          raw[NUM_ENCODERS];\n     vpx_codec_err_t      res[NUM_ENCODERS];\n \n     int                  i;\n     long                 width;\n     long                 height;\n     int                  frame_avail;\n     int                  got_data;\n     int                  flags = 0;\n \n     int                  arg_deadline = VPX_DL_REALTIME;\n\n     int                  show_psnr = 0;\n     uint64_t             psnr_sse_total[NUM_ENCODERS] = {0};\n     uint64_t             psnr_samples_total[NUM_ENCODERS] = {0};\n     double               psnr_totals[NUM_ENCODERS][4] = {{0,0}};\n     int                  psnr_count[NUM_ENCODERS] = {0};\n \n     unsigned int         target_bitrate[NUM_ENCODERS]={1000, 500, 100};\n     int                  framerate = 30;\n     vpx_rational_t dsf[NUM_ENCODERS] = {{2, 1}, {2, 1}, {1, 1}};\n \n    if(argc!= (5+NUM_ENCODERS))\n        die(\"Usage: %s <width> <height> <infile> <outfile(s)> <output psnr?>\\n\",\n             argv[0]);\n \n     printf(\"Using %s\\n\",vpx_codec_iface_name(interface));\n \n     width = strtol(argv[1], NULL, 0);\n     height = strtol(argv[2], NULL, 0);\n \n     if(width < 16 || width%2 || height <16 || height%2)\n         die(\"Invalid resolution: %ldx%ld\", width, height);\n \n    if(!(infile = fopen(argv[3], \"rb\")))\n        die(\"Failed to open %s for reading\", argv[3]);\n \n     for (i=0; i< NUM_ENCODERS; i++)\n {\n if(!target_bitrate[i])\n {\n            outfile[i] = NULL;\n\n             continue;\n         }\n \n        if(!(outfile[i] = fopen(argv[i+4], \"wb\")))\n             die(\"Failed to open %s for writing\", argv[i+4]);\n     }\n \n    show_psnr = strtol(argv[NUM_ENCODERS + 4], NULL, 0);\n \n     for (i=0; i< NUM_ENCODERS; i++)\n {\n        res[i] = vpx_codec_enc_config_default(interface, &cfg[i], 0);\n if(res[i]) {\n            printf(\"Failed to get config: %s\\n\", vpx_codec_err_to_string(res[i]));\n return EXIT_FAILURE;\n }\n }\n\n\n     cfg[0].g_w = width;\n     cfg[0].g_h = height;\n    cfg[0].g_threads = 1;                           \n    cfg[0].rc_dropframe_thresh = 30;\n     cfg[0].rc_end_usage = VPX_CBR;\n     cfg[0].rc_resize_allowed = 0;\n    cfg[0].rc_min_quantizer = 4;\n     cfg[0].rc_max_quantizer = 56;\n    cfg[0].rc_undershoot_pct = 98;\n    cfg[0].rc_overshoot_pct = 100;\n     cfg[0].rc_buf_initial_sz = 500;\n     cfg[0].rc_buf_optimal_sz = 600;\n     cfg[0].rc_buf_sz = 1000;\n    cfg[0].g_error_resilient = 1; \n    cfg[0].g_lag_in_frames   = 0;\n\n\n     cfg[0].kf_min_dist = 3000;\n     cfg[0].kf_max_dist = 3000;\n\n    cfg[0].rc_target_bitrate = target_bitrate[0]; \n    cfg[0].g_timebase.num = 1; \n    cfg[0].g_timebase.den = framerate;\n\n for (i=1; i< NUM_ENCODERS; i++)\n\n     {\n         memcpy(&cfg[i], &cfg[0], sizeof(vpx_codec_enc_cfg_t));\n \n        cfg[i].g_threads = 1;                       \n         cfg[i].rc_target_bitrate = target_bitrate[i];\n \n {\n unsigned int iw = cfg[i-1].g_w*dsf[i-1].den + dsf[i-1].num - 1;\n unsigned int ih = cfg[i-1].g_h*dsf[i-1].den + dsf[i-1].num - 1;\n            cfg[i].g_w = iw/dsf[i-1].num;\n            cfg[i].g_h = ih/dsf[i-1].num;\n }\n\n if((cfg[i].g_w)%2)cfg[i].g_w++;\n\n         if((cfg[i].g_h)%2)cfg[i].g_h++;\n     }\n \n     for (i=0; i< NUM_ENCODERS; i++)\n         if(!vpx_img_alloc(&raw[i], VPX_IMG_FMT_I420, cfg[i].g_w, cfg[i].g_h, 32))\n            die(\"Failed to allocate image\", cfg[i].g_w, cfg[i].g_h);\n\n if (raw[0].stride[VPX_PLANE_Y] == raw[0].d_w)\n        read_frame_p = read_frame;\n else\n        read_frame_p = read_frame_by_row;\n\n for (i=0; i< NUM_ENCODERS; i++)\n\n         if(outfile[i])\n             write_ivf_file_header(outfile[i], &cfg[i], 0);\n \n     if(vpx_codec_enc_init_multi(&codec[0], interface, &cfg[0], NUM_ENCODERS,\n                                 (show_psnr ? VPX_CODEC_USE_PSNR : 0), &dsf[0]))\n        die_codec(&codec[0], \"Failed to initialize encoder\");\n\n\n     for ( i=0; i<NUM_ENCODERS; i++)\n     {\n         int speed = -6;\n         if(vpx_codec_control(&codec[i], VP8E_SET_CPUUSED, speed))\n             die_codec(&codec[i], \"Failed to set cpu_used\");\n     }\n \n     for ( i=0; i<NUM_ENCODERS; i++)\n     {\n        unsigned int static_thresh = 1;\n        if(vpx_codec_control(&codec[i], VP8E_SET_STATIC_THRESHOLD, static_thresh))\n             die_codec(&codec[i], \"Failed to set static threshold\");\n     }\n \n if(vpx_codec_control(&codec[0], VP8E_SET_NOISE_SENSITIVITY, 1))\n        die_codec(&codec[0], \"Failed to set noise_sensitivity\");\n for ( i=1; i< NUM_ENCODERS; i++)\n {\n if(vpx_codec_control(&codec[i], VP8E_SET_NOISE_SENSITIVITY, 0))\n\n             die_codec(&codec[i], \"Failed to set noise_sensitivity\");\n     }\n \n \n     frame_avail = 1;\n     got_data = 0;\n\n while(frame_avail || got_data)\n {\n vpx_codec_iter_t iter[NUM_ENCODERS]={NULL};\n const vpx_codec_cx_pkt_t *pkt[NUM_ENCODERS];\n\n        flags = 0;\n        frame_avail = read_frame_p(infile, &raw[0]);\n\n if(frame_avail)\n {\n for ( i=1; i<NUM_ENCODERS; i++)\n {\n                I420Scale(raw[i-1].planes[VPX_PLANE_Y], raw[i-1].stride[VPX_PLANE_Y],\n                          raw[i-1].planes[VPX_PLANE_U], raw[i-1].stride[VPX_PLANE_U],\n                          raw[i-1].planes[VPX_PLANE_V], raw[i-1].stride[VPX_PLANE_V],\n                          raw[i-1].d_w, raw[i-1].d_h,\n                          raw[i].planes[VPX_PLANE_Y], raw[i].stride[VPX_PLANE_Y],\n\n                           raw[i].planes[VPX_PLANE_U], raw[i].stride[VPX_PLANE_U],\n                           raw[i].planes[VPX_PLANE_V], raw[i].stride[VPX_PLANE_V],\n                           raw[i].d_w, raw[i].d_h, 1);\n             }\n         }\n \n        if(vpx_codec_encode(&codec[0], frame_avail? &raw[0] : NULL,\n            frame_cnt, 1, flags, arg_deadline))\n            die_codec(&codec[0], \"Failed to encode frame\");\n \n         for (i=NUM_ENCODERS-1; i>=0 ; i--)\n         {\n             got_data = 0;\n             while( (pkt[i] = vpx_codec_get_cx_data(&codec[i], &iter[i])) )\n             {\n                 got_data = 1;\n switch(pkt[i]->kind) {\n case VPX_CODEC_CX_FRAME_PKT:\n                        write_ivf_frame_header(outfile[i], pkt[i]);\n (void) fwrite(pkt[i]->data.frame.buf, 1,\n                                      pkt[i]->data.frame.sz, outfile[i]);\n break;\n case VPX_CODEC_PSNR_PKT:\n if (show_psnr)\n {\n int j;\n\n                            psnr_sse_total[i] += pkt[i]->data.psnr.sse[0];\n\n                             psnr_samples_total[i] += pkt[i]->data.psnr.samples[0];\n                             for (j = 0; j < 4; j++)\n                             {\n                             }\n                             psnr_count[i]++;\n }\n\n break;\n default:\n\n                         break;\n                 }\n                 printf(pkt[i]->kind == VPX_CODEC_CX_FRAME_PKT\n                       && (pkt[i]->data.frame.flags & VPX_FRAME_IS_KEY)? \"K\":\".\");\n                 fflush(stdout);\n             }\n         }\n         frame_cnt++;\n     }\n     printf(\"\\n\");\n \n     fclose(infile);\n \n    printf(\"Processed %ld frames.\\n\",(long int)frame_cnt-1);\n for (i=0; i< NUM_ENCODERS; i++)\n {\n if ( (show_psnr) && (psnr_count[i]>0) )\n {\n int j;\n double ovpsnr = sse_to_psnr(psnr_samples_total[i], 255.0,\n                                        psnr_sse_total[i]);\n\n            fprintf(stderr, \"\\n ENC%d PSNR (Overall/Avg/Y/U/V)\", i);\n\n            fprintf(stderr, \" %.3lf\", ovpsnr);\n for (j = 0; j < 4; j++)\n {\n                fprintf(stderr, \" %.3lf\", psnr_totals[i][j]/psnr_count[i]);\n }\n }\n\n if(vpx_codec_destroy(&codec[i]))\n            die_codec(&codec[i], \"Failed to destroy codec\");\n\n        vpx_img_free(&raw[i]);\n\n if(!outfile[i])\n continue;\n\n if(!fseek(outfile[i], 0, SEEK_SET))\n            write_ivf_file_header(outfile[i], &cfg[i], frame_cnt-1);\n        fclose(outfile[i]);\n }\n    printf(\"\\n\");\n\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "3,6,29,30,41,42,53,57,71,72,75,77,78,86,100,141,144,145,185,186,187,188,212,224"}
{"idx": 187990, "func": "static bool get_build_id(\n Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {\n HdrType hdr;\n\n  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);\n\n if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,\n sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {\n return false;\n }\n\n for (size_t i = 0; i < hdr.e_phnum; i++) {\n PhdrType phdr;\n if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,\n reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {\n return false;\n }\n if (phdr.p_type == PT_NOTE) {\n size_t hdr_size = phdr.p_filesz;\n uintptr_t addr = base_addr + phdr.p_offset;\n while (hdr_size >= sizeof(NhdrType)) {\n NhdrType nhdr;\n if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {\n return false;\n }\n        addr += sizeof(nhdr);\n\n         if (nhdr.n_type == NT_GNU_BUILD_ID) {\n           addr += NOTE_ALIGN(nhdr.n_namesz);\n          uint8_t build_id_data[128];\n          if (nhdr.n_namesz > sizeof(build_id_data)) {\n            ALOGE(\"Possible corrupted note, name size value is too large: %u\",\n                  nhdr.n_namesz);\n             return false;\n           }\n           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {\n return false;\n }\n\n          build_id->clear();\n for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {\n *build_id += android::base::StringPrintf(\"%02x\", build_id_data[bytes]);\n }\n\n return true;\n } else {\n          hdr_size -= sizeof(nhdr);\n size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);\n          addr += skip_bytes;\n if (hdr_size < skip_bytes) {\n break;\n }\n          hdr_size -= skip_bytes;\n }\n }\n }\n }\n return false;\n}\n", "target": 1, "flaw_line_index": "33,34,35,36"}
{"idx": 8630, "func": "eth_write(void *opaque, hwaddr addr,\n          uint64_t val64, unsigned int size)\n{\n    struct xlx_ethlite *s = opaque;\n    unsigned int base = 0;\n    uint32_t value = val64;\n\n    addr >>= 2;\n    switch (addr) \n    {\n        case R_TX_CTRL0:\n        case R_TX_CTRL1:\n            if (addr == R_TX_CTRL1)\n                base = 0x800 / 4;\n\n            D(qemu_log(\"%s addr=\" TARGET_FMT_plx \" val=%x\\n\",\n                       __func__, addr * 4, value));\n            if ((value & (CTRL_P | CTRL_S)) == CTRL_S) {\n                qemu_send_packet(qemu_get_queue(s->nic),\n                                 (void *) &s->regs[base],\n                                 s->regs[base + R_TX_LEN0]);\n                D(qemu_log(\"eth_tx %d\\n\", s->regs[base + R_TX_LEN0]));\n                if (s->regs[base + R_TX_CTRL0] & CTRL_I)\n                    eth_pulse_irq(s);\n            } else if ((value & (CTRL_P | CTRL_S)) == (CTRL_P | CTRL_S)) {\n                memcpy(&s->conf.macaddr.a[0], &s->regs[base], 6);\n                if (s->regs[base + R_TX_CTRL0] & CTRL_I)\n                    eth_pulse_irq(s);\n            }\n\n            s->regs[addr] = value & ~(CTRL_P | CTRL_S);\n            break;\n\n        case R_RX_CTRL0:\n        case R_RX_CTRL1:\n            if (!(value & CTRL_S)) {\n                qemu_flush_queued_packets(qemu_get_queue(s->nic));\n            }\n        case R_TX_LEN0:\n        case R_TX_LEN1:\n        case R_TX_GIE0:\n            D(qemu_log(\"%s addr=\" TARGET_FMT_plx \" val=%x\\n\",\n                       __func__, addr * 4, value));\n            s->regs[addr] = value;\n            break;\n\n        default:\n            s->regs[addr] = tswap32(value);\n            break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8714, "func": "url_full_path (const struct url *url)\n{\n  int length = full_path_length (url);\n  char *full_path = xmalloc (length + 1);\n\n  full_path_write (url, full_path);\n  full_path[length] = '\\0';\n\n  return full_path;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8685, "func": "getchar_from_escaped_string (const char *str, char *c)\n{\n  const char *p = str;\n\n  assert (str && *str);\n  assert (c);\n\n  if (p[0] == '%')\n    {\n      if (!c_isxdigit(p[1]) || !c_isxdigit(p[2]))\n        {\n          *c = '%';\n          return 1;\n        }\n      else\n        {\n          if (p[2] == 0)\n            return 0; \n\n          *c = X2DIGITS_TO_NUM (p[1], p[2]);\n          if (URL_RESERVED_CHAR(*c))\n            {\n              *c = '%';\n              return 1;\n            }\n          else\n            return 3;\n        }\n    }\n  else\n    {\n      *c = p[0];\n    }\n\n  return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8786, "func": "static void __report_context_error(const char *fname, struct vrend_context *ctx, enum virgl_ctx_errors error, uint32_t value)\n{\n   ctx->in_error = true;\n   ctx->last_error = error;\n   fprintf(stderr,\"%s: context error reported %d \\\"%s\\\" %s %d\\n\", fname, ctx->ctx_id, ctx->debug_name, vrend_ctx_error_strings[error], value);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187653, "func": " image_transform_png_set_expand_gray_1_2_4_to_8_mod(\n    PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    image_transform_png_set_expand_mod(this, that, pp, display);\n }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8617, "func": "static void vmsvga_io_write(void *opaque, hwaddr addr,\n                            uint64_t data, unsigned size)\n{\n    struct vmsvga_state_s *s = opaque;\n\n    switch (addr) {\n    case SVGA_IO_MUL * SVGA_INDEX_PORT:\n        vmsvga_index_write(s, addr, data);\n        break;\n    case SVGA_IO_MUL * SVGA_VALUE_PORT:\n        vmsvga_value_write(s, addr, data);\n        break;\n    case SVGA_IO_MUL * SVGA_BIOS_PORT:\n        vmsvga_bios_write(s, addr, data);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8325, "func": "static unsigned int Ones(                \n    unsigned long mask)\n{\n    register unsigned long y;\n\n    y = (mask >> 1) &033333333333;\n    y = mask - y - ((y >>1) & 033333333333);\n    return ((unsigned int) (((y + (y >> 3)) & 030707070707) % 077));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187838, "func": "const BlockEntry* Cluster::GetEntry(const Track* pTrack,\n long long time_ns) const {\n  assert(pTrack);\n\n\n   if (m_pSegment == NULL)  \n     return pTrack->GetEOS();\n \n#if 0\n    LoadBlockEntries();\n    if ((m_entries == NULL) || (m_entries_count <= 0))\n        return NULL;  \n    const BlockEntry* pResult = pTrack->GetEOS();\n    BlockEntry** i = m_entries;\n    assert(i);\n    BlockEntry** const j = i + m_entries_count;\n    while (i != j)\n    {\n        const BlockEntry* const pEntry = *i++;\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if (pBlock->GetTrackNumber() != pTrack->GetNumber())\n            continue;\n        if (pTrack->VetEntry(pEntry))\n        {\n            if (time_ns < 0)  \n                return pEntry;\n            const long long ns = pBlock->GetTime(this);\n            if (ns > time_ns)\n                break;\n            pResult = pEntry;\n        }\n        else if (time_ns >= 0)\n        {\n            const long long ns = pBlock->GetTime(this);\n            if (ns > time_ns)\n                break;\n        }\n    }\n    return pResult;\n#else\n   const BlockEntry* pResult = pTrack->GetEOS();\n \n   long index = 0;\n\n for (;;) {\n if (index >= m_entries_count) {\n long long pos;\n long len;\n\n const long status = Parse(pos, len);\n      assert(status >= 0);\n\n if (status > 0) \n return pResult;\n\n if (status < 0) \n return 0;\n\n      assert(m_entries);\n      assert(index < m_entries_count);\n }\n\n const BlockEntry* const pEntry = m_entries[index];\n    assert(pEntry);\n    assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n\n if (pBlock->GetTrackNumber() != pTrack->GetNumber()) {\n ++index;\n continue;\n }\n\n if (pTrack->VetEntry(pEntry)) {\n if (time_ns < 0) \n return pEntry;\n\n const long long ns = pBlock->GetTime(this);\n\n if (ns > time_ns)\n return pResult;\n\n      pResult = pEntry; \n } else if (time_ns >= 0) {\n const long long ns = pBlock->GetTime(this);\n\n if (ns > time_ns)\n return pResult;\n }\n\n \n     ++index;\n   }\n#endif\n }\n", "target": 1, "flaw_line_index": "9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,98"}
{"idx": 187718, "func": "set_store_for_write(png_store *ps, png_infopp ppi,\n   PNG_CONST char * volatile name)\n {\n    anon_context(ps);\n \n Try\n {\n if (ps->pwrite != NULL)\n         png_error(ps->pwrite, \"write store already in use\");\n\n      store_write_reset(ps);\n      safecat(ps->wname, sizeof ps->wname, 0, name);\n\n#     ifdef PNG_USER_MEM_SUPPORTED\n if (!ps->speed)\n            ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,\n               ps, store_error, store_warning, &ps->write_memory_pool,\n               store_malloc, store_free);\n\n else\n#     endif\n         ps->pwrite = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n            ps, store_error, store_warning);\n\n      png_set_write_fn(ps->pwrite, ps, store_write, store_flush);\n\n#     ifdef PNG_SET_OPTION_SUPPORTED\n {\n int opt;\n for (opt=0; opt<ps->noptions; ++opt)\n if (png_set_option(ps->pwrite, ps->options[opt].option,\n                  ps->options[opt].setting) == PNG_OPTION_INVALID)\n                  png_error(ps->pwrite, \"png option invalid\");\n }\n#     endif\n\n if (ppi != NULL)\n *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);\n }\n\n Catch_anonymous\n return NULL;\n\n return ps->pwrite;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 188558, "func": "void Encoder::EncodeFrameInternal(const VideoSource &video,\n const unsigned long frame_flags) {\n\n   vpx_codec_err_t res;\n   const vpx_image_t *img = video.img();\n \n  if (!encoder_.priv) {\n    cfg_.g_w = img->d_w;\n    cfg_.g_h = img->d_h;\n    cfg_.g_timebase = video.timebase();\n    cfg_.rc_twopass_stats_in = stats_->buf();\n    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,\n                             init_flags_);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n   if (cfg_.g_w != img->d_w || cfg_.g_h != img->d_h) {\n     cfg_.g_w = img->d_w;\n    cfg_.g_h = img->d_h;\n    res = vpx_codec_enc_config_set(&encoder_, &cfg_);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n\n   }\n \n  REGISTER_STATE_CHECK(\n      res = vpx_codec_encode(&encoder_,\n                             video.img(), video.pts(), video.duration(),\n                              frame_flags, deadline_));\n   ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n }\n", "target": 1, "flaw_line_index": "7,8,9,10,11,12,13,14,15,16,27,28,29"}
{"idx": 8893, "func": "void vrend_renderer_check_queries(void)\n{\n   struct vrend_query *query, *stor;\n\n   if (!vrend_state.inited)\n      return;\n\n   LIST_FOR_EACH_ENTRY_SAFE(query, stor, &vrend_state.waiting_query_list, waiting_queries) {\n      vrend_hw_switch_context(vrend_lookup_renderer_ctx(query->ctx_id), true);\n      if (vrend_check_query(query))\n         list_delinit(&query->waiting_queries);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9052, "func": "static inline void vmxnet3_ring_dec(Vmxnet3Ring *ring)\n{\n    if (ring->next-- == 0) {\n        ring->next = ring->size - 1;\n        ring->gen ^= 1;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9072, "func": "static void vmxnet3_update_pm_state(VMXNET3State *s)\n{\n    struct Vmxnet3_VariableLenConfDesc pm_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    pm_descr.confLen =\n        VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, devRead.pmConfDesc.confLen);\n    pm_descr.confVer =\n        VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, devRead.pmConfDesc.confVer);\n    pm_descr.confPA =\n        VMXNET3_READ_DRV_SHARED64(d, s->drv_shmem, devRead.pmConfDesc.confPA);\n\n    vmxnet3_dump_conf_descr(\"PM State\", &pm_descr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8991, "func": "static uint32_t vmxnet3_get_interrupt_config(VMXNET3State *s)\n{\n    uint32_t interrupt_mode = VMXNET3_IT_AUTO | (VMXNET3_IMM_AUTO << 2);\n    VMW_CFPRN(\"Interrupt config is 0x%X\", interrupt_mode);\n    return interrupt_mode;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8549, "func": "static void ssh2_pkt_send(Ssh ssh, struct Packet *pkt)\n{\n    if (ssh->queueing)\n\tssh2_pkt_queue(ssh, pkt);\n    else\n\tssh2_pkt_send_noqueue(ssh, pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188054, "func": "IV_API_CALL_STATUS_T impeg2d_api_entity(iv_obj_t *ps_dechdl,\n void *pv_api_ip,\n void *pv_api_op)\n{\n iv_obj_t *ps_dec_handle;\n dec_state_t *ps_dec_state;\n dec_state_multi_core_t *ps_dec_state_multi_core;\n\n impeg2d_video_decode_ip_t *ps_dec_ip;\n\n impeg2d_video_decode_op_t *ps_dec_op;\n    WORD32 bytes_remaining;\n pic_buf_t *ps_disp_pic;\n\n\n\n    ps_dec_ip = (impeg2d_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (impeg2d_video_decode_op_t *)pv_api_op;\n\n    memset(ps_dec_op,0,sizeof(impeg2d_video_decode_op_t));\n\n    ps_dec_op->s_ivd_video_decode_op_t.u4_size = sizeof(impeg2d_video_decode_op_t);\n    ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;\n    bytes_remaining = ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n\n    ps_dec_handle = (iv_obj_t *)ps_dechdl;\n\n if(ps_dechdl == NULL)\n {\n return(IV_FAIL);\n }\n\n\n\n    ps_dec_state_multi_core  = ps_dec_handle->pv_codec_handle;\n    ps_dec_state = ps_dec_state_multi_core->ps_dec_state[0];\n\n    ps_dec_state->ps_disp_frm_buf = &(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n if(0 == ps_dec_state->u4_share_disp_buf)\n {\n        ps_dec_state->ps_disp_frm_buf->pv_y_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0];\n        ps_dec_state->ps_disp_frm_buf->pv_u_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1];\n        ps_dec_state->ps_disp_frm_buf->pv_v_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2];\n }\n\n    ps_dec_state->ps_disp_pic = NULL;\n    ps_dec_state->i4_frame_decoded = 0;\n    ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;\n\n    ps_dec_op->s_ivd_video_decode_op_t.u4_error_code           = IV_SUCCESS;\n\n if((ps_dec_ip->s_ivd_video_decode_ip_t.pv_stream_buffer == NULL)&&(ps_dec_state->u1_flushfrm==0))\n {\n        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n\n\n if (ps_dec_state->u4_num_frames_decoded > NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code       = IMPEG2D_SAMPLE_VERSION_LIMIT_ERR;\n return(IV_FAIL);\n }\n\n if(((0 == ps_dec_state->u2_header_done) || (ps_dec_state->u2_decode_header == 1)) && (ps_dec_state->u1_flushfrm == 0))\n {\n        impeg2d_dec_hdr(ps_dec_state,ps_dec_ip ,ps_dec_op);\n\n         bytes_remaining -= ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed;\n     }\n \n    if((1 != ps_dec_state->u2_decode_header) && ((bytes_remaining > 0) || ps_dec_state->u1_flushfrm))\n     {\n         if(ps_dec_state->u1_flushfrm)\n         {\n if(ps_dec_state->aps_ref_pics[1] != NULL)\n {\n                impeg2_disp_mgr_add(&ps_dec_state->s_disp_mgr, ps_dec_state->aps_ref_pics[1], ps_dec_state->aps_ref_pics[1]->i4_buf_id);\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[1]->i4_buf_id, BUF_MGR_REF);\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);\n\n                ps_dec_state->aps_ref_pics[1] = NULL;\n                ps_dec_state->aps_ref_pics[0] = NULL;\n\n }\n else if(ps_dec_state->aps_ref_pics[0] != NULL)\n {\n                impeg2_disp_mgr_add(&ps_dec_state->s_disp_mgr, ps_dec_state->aps_ref_pics[0], ps_dec_state->aps_ref_pics[0]->i4_buf_id);\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);\n\n                ps_dec_state->aps_ref_pics[0] = NULL;\n }\n            ps_dec_ip->s_ivd_video_decode_ip_t.u4_size                 = sizeof(impeg2d_video_decode_ip_t);\n            ps_dec_op->s_ivd_video_decode_op_t.u4_size                 = sizeof(impeg2d_video_decode_op_t);\n\n            ps_disp_pic = impeg2_disp_mgr_get(&ps_dec_state->s_disp_mgr, &ps_dec_state->i4_disp_buf_id);\n\n            ps_dec_state->ps_disp_pic = ps_disp_pic;\n if(ps_disp_pic == NULL)\n {\n                ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;\n }\n else\n {\n                WORD32 fmt_conv;\n if(0 == ps_dec_state->u4_share_disp_buf)\n {\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_y_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0];\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1];\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2];\n                    fmt_conv = 1;\n }\n else\n {\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_y_buf  = ps_disp_pic->pu1_y;\n if(IV_YUV_420P == ps_dec_state->i4_chromaFormat)\n {\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = ps_disp_pic->pu1_u;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = ps_disp_pic->pu1_v;\n                        fmt_conv = 0;\n }\n else\n {\n                        UWORD8 *pu1_buf;\n\n                        pu1_buf = ps_dec_state->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[1];\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = pu1_buf;\n\n                        pu1_buf = ps_dec_state->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[2];\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = pu1_buf;\n                        fmt_conv = 1;\n }\n }\n\n if(fmt_conv == 1)\n {\n iv_yuv_buf_t *ps_dst;\n\n\n                    ps_dst = &(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n if(ps_dec_state->u4_deinterlace && (0 == ps_dec_state->u2_progressive_frame))\n {\n                        impeg2d_deinterlace(ps_dec_state,\n                                            ps_disp_pic,\n                                            ps_dst,\n 0,\n                                            ps_dec_state->u2_vertical_size);\n\n }\n else\n {\n                        impeg2d_format_convert(ps_dec_state,\n                                               ps_disp_pic,\n                                               ps_dst,\n 0,\n                                               ps_dec_state->u2_vertical_size);\n }\n }\n\n if(ps_dec_state->u4_deinterlace)\n {\n if(ps_dec_state->ps_deint_pic)\n {\n                        impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg,\n                                               ps_dec_state->ps_deint_pic->i4_buf_id,\n                                               MPEG2_BUF_MGR_DEINT);\n }\n                    ps_dec_state->ps_deint_pic = ps_disp_pic;\n }\n if(0 == ps_dec_state->u4_share_disp_buf)\n                    impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_disp_pic->i4_buf_id, BUF_MGR_DISP);\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec_state->u2_vertical_size;\n                ps_dec_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec_state->u2_horizontal_size;\n                ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 1;\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_disp_buf_id = ps_disp_pic->i4_buf_id;\n                ps_dec_op->s_ivd_video_decode_op_t.u4_ts = ps_disp_pic->u4_ts;\n\n                ps_dec_op->s_ivd_video_decode_op_t.e_output_format = (IV_COLOR_FORMAT_T)ps_dec_state->i4_chromaFormat;\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_is_ref_flag = (B_PIC != ps_dec_state->e_pic_type);\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag           = IV_PROGRESSIVE;\n\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_wd = ps_dec_state->u2_horizontal_size;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_strd = ps_dec_state->u4_frm_buf_stride;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_ht = ps_dec_state->u2_vertical_size;\n\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = ps_dec_state->u2_vertical_size >> 1;\n\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = ps_dec_state->u2_horizontal_size >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = ps_dec_state->u2_vertical_size >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_size = sizeof(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n\n switch(ps_dec_state->i4_chromaFormat)\n {\n case IV_YUV_420SP_UV:\n case IV_YUV_420SP_VU:\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride;\n break;\n case IV_YUV_422ILE:\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = 0;\n break;\n default:\n break;\n }\n\n\n }\n if(ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)\n {\n if(1 == ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)\n {\n                    INSERT_LOGO(ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0],\n                                ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1],\n                                ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2],\n                                ps_dec_state->u4_frm_buf_stride,\n                                ps_dec_state->u2_horizontal_size,\n                                ps_dec_state->u2_vertical_size,\n                                ps_dec_state->i4_chromaFormat,\n                                ps_dec_state->u2_horizontal_size,\n                                ps_dec_state->u2_vertical_size);\n }\n return(IV_SUCCESS);\n }\n else\n {\n                ps_dec_state->u1_flushfrm = 0;\n\n return(IV_FAIL);\n }\n\n }\n else if(ps_dec_state->u1_flushfrm==0)\n {\n            ps_dec_ip->s_ivd_video_decode_ip_t.u4_size                 = sizeof(impeg2d_video_decode_ip_t);\n            ps_dec_op->s_ivd_video_decode_op_t.u4_size                 = sizeof(impeg2d_video_decode_op_t);\n if(ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes < 4)\n {\n                ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n return(IV_FAIL);\n }\n\n if(1 == ps_dec_state->u4_share_disp_buf)\n {\n if(0 == impeg2_buf_mgr_check_free(ps_dec_state->pv_pic_buf_mg))\n {\n                    ps_dec_op->s_ivd_video_decode_op_t.u4_error_code =\n (IMPEG2D_ERROR_CODES_T)IVD_DEC_REF_BUF_NULL;\n return IV_FAIL;\n }\n }\n\n\n            ps_dec_op->s_ivd_video_decode_op_t.e_output_format = (IV_COLOR_FORMAT_T)ps_dec_state->i4_chromaFormat;\n\n            ps_dec_op->s_ivd_video_decode_op_t.u4_is_ref_flag = (B_PIC != ps_dec_state->e_pic_type);\n\n            ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag           = IV_PROGRESSIVE;\n\n if (0 == ps_dec_state->u4_frm_buf_stride)\n {\n                ps_dec_state->u4_frm_buf_stride = (ps_dec_state->u2_horizontal_size);\n }\n\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_wd = ps_dec_state->u2_horizontal_size;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_strd = ps_dec_state->u4_frm_buf_stride;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_ht = ps_dec_state->u2_vertical_size;\n\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = ps_dec_state->u2_vertical_size >> 1;\n\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = ps_dec_state->u2_horizontal_size >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = ps_dec_state->u2_vertical_size >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_size = sizeof(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n\n switch(ps_dec_state->i4_chromaFormat)\n {\n case IV_YUV_420SP_UV:\n case IV_YUV_420SP_VU:\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride;\n break;\n case IV_YUV_422ILE:\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = 0;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = 0;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = 0;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = 0;\n break;\n default:\n break;\n }\n\n if( ps_dec_state->u1_flushfrm == 0)\n {\n                ps_dec_state->u1_flushcnt    = 0;\n\n\n                impeg2d_dec_frm(ps_dec_state,ps_dec_ip,ps_dec_op);\n\n if (IVD_ERROR_NONE ==\n                        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code)\n {\n if(ps_dec_state->u1_first_frame_done == 0)\n {\n                        ps_dec_state->u1_first_frame_done = 1;\n }\n\n if(ps_dec_state->ps_disp_pic)\n {\n                        ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 1;\n switch(ps_dec_state->ps_disp_pic->e_pic_type)\n {\n case I_PIC :\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;\n break;\n\n case P_PIC:\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_P_FRAME;\n break;\n\n case B_PIC:\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_B_FRAME;\n break;\n\n case D_PIC:\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;\n break;\n\n default :\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_FRAMETYPE_DEFAULT;\n break;\n }\n }\n else\n {\n                        ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_NA_FRAME;\n }\n\n                    ps_dec_state->u4_num_frames_decoded++;\n }\n }\n else\n {\n                ps_dec_state->u1_flushcnt++;\n }\n }\n if(ps_dec_state->ps_disp_pic)\n {\n            ps_dec_op->s_ivd_video_decode_op_t.u4_disp_buf_id = ps_dec_state->ps_disp_pic->i4_buf_id;\n            ps_dec_op->s_ivd_video_decode_op_t.u4_ts = ps_dec_state->ps_disp_pic->u4_ts;\n\n if(0 == ps_dec_state->u4_share_disp_buf)\n {\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->ps_disp_pic->i4_buf_id, BUF_MGR_DISP);\n }\n }\n\n if(ps_dec_state->u4_deinterlace)\n {\n if(ps_dec_state->ps_deint_pic)\n {\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg,\n                                       ps_dec_state->ps_deint_pic->i4_buf_id,\n                                       MPEG2_BUF_MGR_DEINT);\n }\n            ps_dec_state->ps_deint_pic = ps_dec_state->ps_disp_pic;\n }\n\n if(1 == ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)\n {\n            INSERT_LOGO(ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0],\n                        ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1],\n                        ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2],\n                        ps_dec_state->u4_frm_buf_stride,\n                        ps_dec_state->u2_horizontal_size,\n                        ps_dec_state->u2_vertical_size,\n                        ps_dec_state->i4_chromaFormat,\n                        ps_dec_state->u2_horizontal_size,\n                        ps_dec_state->u2_vertical_size);\n }\n\n }\n\n    ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag = 1;\n    ps_dec_op->s_ivd_video_decode_op_t.e4_fld_type     = ps_dec_state->s_disp_op.e4_fld_type;\n\n\n if(ps_dec_op->s_ivd_video_decode_op_t.u4_error_code)\n return IV_FAIL;\n else\n return IV_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "73"}
{"idx": 187753, "func": "emit_string(const char *str, FILE *out)\n{\n for (; *str; ++str)\n if (isgraph(UCHAR_MAX & *str))\n         putc(*str, out);\n\n \n       else if (isspace(UCHAR_MAX & *str))\n          putc('_', out);\n       else\n          fprintf(out, \"\\\\%.3o\", *str);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8816, "func": "static inline GLenum translate_fill(uint32_t mode)\n{\n   switch (mode) {\n   case PIPE_POLYGON_MODE_POINT:\n      return GL_POINT;\n   case PIPE_POLYGON_MODE_LINE:\n      return GL_LINE;\n   case PIPE_POLYGON_MODE_FILL:\n      return GL_FILL;\n   default:\n      assert(0);\n      return 0;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188098, "func": "void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = p_data->p_data;\n\n   tBTM_LE_PENC_KEYS le_key;\n \n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true);\n \n   STREAM_TO_UINT16(le_key.ediv, p);\n  STREAM_TO_ARRAY(le_key.rand, p, BT_OCTET8_LEN);\n\n  memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN);\n  le_key.sec_level = p_cb->sec_level;\n  le_key.key_size = p_cb->loc_enc_size;\n\n if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&\n (p_cb->loc_auth_req & SMP_AUTH_BOND))\n    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC,\n (tBTM_LE_KEY_VALUE*)&le_key, true);\n\n  smp_key_distribution(p_cb, NULL);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9149, "func": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n\n    txcq_descr.txdIdx = tx_ridx;\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187570, "func": "status_t MPEG4Extractor::readMetaData() {\n if (mInitCheck != NO_INIT) {\n return mInitCheck;\n }\n\n off64_t offset = 0;\n status_t err;\n bool sawMoovOrSidx = false;\n\n while (!(sawMoovOrSidx && (mMdatFound || mMoofFound))) {\n off64_t orig_offset = offset;\n        err = parseChunk(&offset, 0);\n\n if (err != OK && err != UNKNOWN_ERROR) {\n break;\n } else if (offset <= orig_offset) {\n            ALOGE(\"did not advance: %lld->%lld\", (long long)orig_offset, (long long)offset);\n            err = ERROR_MALFORMED;\n break;\n } else if (err == UNKNOWN_ERROR) {\n            sawMoovOrSidx = true;\n }\n }\n\n if (mInitCheck == OK) {\n if (mHasVideo) {\n            mFileMetaData->setCString(\n                    kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_MPEG4);\n } else {\n            mFileMetaData->setCString(kKeyMIMEType, \"audio/mp4\");\n }\n } else {\n        mInitCheck = err;\n }\n\n    CHECK_NE(err, (status_t)NO_INIT);\n\n uint64_t psshsize = 0;\n for (size_t i = 0; i < mPssh.size(); i++) {\n        psshsize += 20 + mPssh[i].datalen;\n\n     }\n     if (psshsize > 0 && psshsize <= UINT32_MAX) {\n         char *buf = (char*)malloc(psshsize);\n         char *ptr = buf;\n         for (size_t i = 0; i < mPssh.size(); i++) {\n             memcpy(ptr, mPssh[i].uuid, 20); \n            memcpy(ptr + 20, mPssh[i].data, mPssh[i].datalen);\n            ptr += (20 + mPssh[i].datalen);\n }\n        mFileMetaData->setData(kKeyPssh, 'pssh', buf, psshsize);\n        free(buf);\n }\n return mInitCheck;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8590, "func": "static void ssh_sent(Plug plug, int bufsize)\n{\n    Ssh ssh = (Ssh) plug;\n    if (bufsize < SSH_MAX_BACKLOG)\n\tssh_throttle_all(ssh, 0, bufsize);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8562, "func": "static void ssh_detect_bugs(Ssh ssh, char *vstring)\n{\n    char *imp;\t\t\t       \n    imp = vstring;\n    imp += strcspn(imp, \"-\");\n    if (*imp) imp++;\n    imp += strcspn(imp, \"-\");\n    if (*imp) imp++;\n\n    ssh->remote_bugs = 0;\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_ignore1) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_ignore1) == AUTO &&\n\t (!strcmp(imp, \"1.2.18\") || !strcmp(imp, \"1.2.19\") ||\n\t  !strcmp(imp, \"1.2.20\") || !strcmp(imp, \"1.2.21\") ||\n\t  !strcmp(imp, \"1.2.22\") || !strcmp(imp, \"Cisco-1.25\") ||\n\t  !strcmp(imp, \"OSU_1.4alpha3\") || !strcmp(imp, \"OSU_1.5alpha4\")))) {\n\tssh->remote_bugs |= BUG_CHOKES_ON_SSH1_IGNORE;\n\tlogevent(\"We believe remote version has SSH-1 ignore bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_plainpw1) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_plainpw1) == AUTO &&\n\t (!strcmp(imp, \"Cisco-1.25\") || !strcmp(imp, \"OSU_1.4alpha3\")))) {\n\tssh->remote_bugs |= BUG_NEEDS_SSH1_PLAIN_PASSWORD;\n\tlogevent(\"We believe remote version needs a plain SSH-1 password\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_rsa1) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_rsa1) == AUTO &&\n\t (!strcmp(imp, \"Cisco-1.25\")))) {\n\tssh->remote_bugs |= BUG_CHOKES_ON_RSA;\n\tlogevent(\"We believe remote version can't handle SSH-1 RSA authentication\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_hmac2) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_hmac2) == AUTO &&\n\t !wc_match(\"* VShell\", imp) &&\n\t (wc_match(\"2.1.0*\", imp) || wc_match(\"2.0.*\", imp) ||\n\t  wc_match(\"2.2.0*\", imp) || wc_match(\"2.3.0*\", imp) ||\n\t  wc_match(\"2.1 *\", imp)))) {\n\tssh->remote_bugs |= BUG_SSH2_HMAC;\n\tlogevent(\"We believe remote version has SSH-2 HMAC bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_derivekey2) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_derivekey2) == AUTO &&\n\t !wc_match(\"* VShell\", imp) &&\n\t (wc_match(\"2.0.0*\", imp) || wc_match(\"2.0.10*\", imp) ))) {\n\tssh->remote_bugs |= BUG_SSH2_DERIVEKEY;\n\tlogevent(\"We believe remote version has SSH-2 key-derivation bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_rsapad2) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_rsapad2) == AUTO &&\n\t (wc_match(\"OpenSSH_2.[5-9]*\", imp) ||\n\t  wc_match(\"OpenSSH_3.[0-2]*\", imp) ||\n\t  wc_match(\"mod_sftp/0.[0-8]*\", imp) ||\n\t  wc_match(\"mod_sftp/0.9.[0-8]\", imp)))) {\n\tssh->remote_bugs |= BUG_SSH2_RSA_PADDING;\n\tlogevent(\"We believe remote version has SSH-2 RSA padding bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_pksessid2) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_pksessid2) == AUTO &&\n\t wc_match(\"OpenSSH_2.[0-2]*\", imp))) {\n\tssh->remote_bugs |= BUG_SSH2_PK_SESSIONID;\n\tlogevent(\"We believe remote version has SSH-2 public-key-session-ID bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_rekey2) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_rekey2) == AUTO &&\n\t (wc_match(\"DigiSSH_2.0\", imp) ||\n\t  wc_match(\"OpenSSH_2.[0-4]*\", imp) ||\n\t  wc_match(\"OpenSSH_2.5.[0-3]*\", imp) ||\n\t  wc_match(\"Sun_SSH_1.0\", imp) ||\n\t  wc_match(\"Sun_SSH_1.0.1\", imp) ||\n\t  wc_match(\"WeOnlyDo-*\", imp)))) {\n\tssh->remote_bugs |= BUG_SSH2_REKEY;\n\tlogevent(\"We believe remote version has SSH-2 rekey bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_maxpkt2) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_maxpkt2) == AUTO &&\n\t (wc_match(\"1.36_sshlib GlobalSCAPE\", imp) ||\n          wc_match(\"1.36 sshlib: GlobalScape\", imp)))) {\n\tssh->remote_bugs |= BUG_SSH2_MAXPKT;\n\tlogevent(\"We believe remote version ignores SSH-2 maximum packet size\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_ignore2) == FORCE_ON) {\n\tssh->remote_bugs |= BUG_CHOKES_ON_SSH2_IGNORE;\n\tlogevent(\"We believe remote version has SSH-2 ignore bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_oldgex2) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_oldgex2) == AUTO &&\n\t (wc_match(\"OpenSSH_2.[235]*\", imp)))) {\n\tssh->remote_bugs |= BUG_SSH2_OLDGEX;\n\tlogevent(\"We believe remote version has outdated SSH-2 GEX\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_winadj) == FORCE_ON) {\n\tssh->remote_bugs |= BUG_CHOKES_ON_WINADJ;\n\tlogevent(\"We believe remote version has winadj bug\");\n    }\n\n    if (conf_get_int(ssh->conf, CONF_sshbug_chanreq) == FORCE_ON ||\n\t(conf_get_int(ssh->conf, CONF_sshbug_chanreq) == AUTO &&\n\t (wc_match(\"OpenSSH_[2-5].*\", imp) ||\n\t  wc_match(\"OpenSSH_6.[0-6]*\", imp) ||\n\t  wc_match(\"dropbear_0.[2-4][0-9]*\", imp) ||\n\t  wc_match(\"dropbear_0.5[01]*\", imp)))) {\n\t * https:\n\t * https:\n\tssh->remote_bugs |= BUG_SENDS_LATE_REQUEST_REPLY;\n\tlogevent(\"We believe remote version has SSH-2 channel request bug\");\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188257, "func": " static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n     const size_t kSegCountOffset = 6;\n     const size_t kEndCountOffset = 14;\n const size_t kHeaderSize = 16;\n const size_t kSegmentSize = 8; \n if (kEndCountOffset > size) {\n return false;\n }\n size_t segCount = readU16(data, kSegCountOffset) >> 1;\n if (kHeaderSize + segCount * kSegmentSize > size) {\n\n         return false;\n     }\n     for (size_t i = 0; i < segCount; i++) {\n        int end = readU16(data, kEndCountOffset + 2 * i);\n        int start = readU16(data, kHeaderSize + 2 * (segCount + i));\n        int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));\n         if (rangeOffset == 0) {\n            int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));\n             if (((end + delta) & 0xffff) > end - start) {\n                 addRange(coverage, start, end + 1);\n             } else {\n                for (int j = start; j < end + 1; j++) {\n                     if (((j + delta) & 0xffff) != 0) {\n                         addRange(coverage, j, j + 1);\n                     }\n                 }\n             }\n         } else {\n            for (int j = start; j < end + 1; j++) {\n                 uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +\n                     (i + j - start) * 2;\n                 if (actualRangeOffset + 2 > size) {\n                     return false;\n                 }\n                int glyphId = readU16(data, actualRangeOffset);\n                 if (glyphId != 0) {\n                     addRange(coverage, j, j + 1);\n                 }\n }\n }\n }\n return true;\n}\n", "target": 1, "flaw_line_index": "15,16,17,19,23,30,36"}
{"idx": 187719, "func": "standard_display_init(standard_display *dp, png_store* ps, png_uint_32 id,\n int do_interlace, int use_update_info)\n{\n   memset(dp, 0, sizeof *dp);\n\n   dp->ps = ps;\n   dp->colour_type = COL_FROM_ID(id);\n   dp->bit_depth = DEPTH_FROM_ID(id);\n if (dp->bit_depth < 1 || dp->bit_depth > 16)\n      internal_error(ps, \"internal: bad bit depth\");\n if (dp->colour_type == 3)\n      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT = 8;\n else\n      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT =\n         dp->bit_depth;\n   dp->interlace_type = INTERLACE_FROM_ID(id);\n   check_interlace_type(dp->interlace_type);\n   dp->id = id;\n   dp->w = 0;\n   dp->h = 0;\n   dp->npasses = 0;\n   dp->pixel_size = 0;\n\n    dp->bit_width = 0;\n    dp->cbRow = 0;\n    dp->do_interlace = do_interlace;\n    dp->is_transparent = 0;\n    dp->speed = ps->speed;\n    dp->use_update_info = use_update_info;\n   dp->npalette = 0;\n   memset(&dp->transparent, 0, sizeof dp->transparent);\n   memset(dp->palette, 0xff, sizeof dp->palette);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8358, "func": "static void mptsas_doorbell_write(MPTSASState *s, uint32_t val)\n{\n    if (s->doorbell_state == DOORBELL_WRITE) {\n        if (s->doorbell_idx < s->doorbell_cnt) {\n            s->doorbell_msg[s->doorbell_idx++] = cpu_to_le32(val);\n            if (s->doorbell_idx == s->doorbell_cnt) {\n                mptsas_process_message(s, (MPIRequestHeader *)s->doorbell_msg);\n            }\n        }\n        return;\n    }\n\n    switch ((val & MPI_DOORBELL_FUNCTION_MASK) >> MPI_DOORBELL_FUNCTION_SHIFT) {\n    case MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET:\n        mptsas_soft_reset(s);\n        break;\n    case MPI_FUNCTION_IO_UNIT_RESET:\n        break;\n    case MPI_FUNCTION_HANDSHAKE:\n        s->doorbell_state = DOORBELL_WRITE;\n        s->doorbell_idx = 0;\n        s->doorbell_cnt = (val & MPI_DOORBELL_ADD_DWORDS_MASK)\n            >> MPI_DOORBELL_ADD_DWORDS_SHIFT;\n        s->intr_status |= MPI_HIS_DOORBELL_INTERRUPT;\n        mptsas_update_interrupt(s);\n        break;\n    default:\n        trace_mptsas_unhandled_doorbell_cmd(s, val);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8396, "func": "void virtqueue_discard(VirtQueue *vq, const VirtQueueElement *elem,\n                       unsigned int len)\n{\n    vq->last_avail_idx--;\n    vq->inuse--;\n    virtqueue_unmap_sg(vq, elem, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8736, "func": "vcard7816_file_system_process_apdu(VCard *card, VCardAPDU *apdu,\n                                   VCardResponse **response)\n{\n    *response = vcard_make_response(\n                    VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);\n    return VCARD_DONE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188219, "func": "OMX_ERRORTYPE SoftAMRWBEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.amrwb\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAMR)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (amrParams->nChannels != 1\n || amrParams->eAMRDTXMode != OMX_AUDIO_AMRDTXModeOff\n || amrParams->eAMRFrameFormat\n != OMX_AUDIO_AMRFrameFormatFSF\n || amrParams->eAMRBandMode < OMX_AUDIO_AMRBandModeWB0\n || amrParams->eAMRBandMode > OMX_AUDIO_AMRBandModeWB8) {\n return OMX_ErrorUndefined;\n }\n\n            mBitRate = amrParams->nBitRate;\n\n            mMode = (VOAMRWBMODE)(\n                    amrParams->eAMRBandMode - OMX_AUDIO_AMRBandModeWB0);\n\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n if (VO_ERR_NONE !=\n                    mApiHandle->SetParam(\n                        mEncoderHandle, VO_PID_AMRWB_MODE, &mMode)) {\n                ALOGE(\"Failed to set AMRWB encoder mode to %d\", mMode);\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels != 1\n || pcmParams->nSamplingRate != (OMX_U32)kSampleRate) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8994, "func": "vmxnet3_get_next_body_rx_descr(VMXNET3State *s,\n                               struct Vmxnet3_RxDesc *d,\n                               uint32_t *didx,\n                               uint32_t *ridx)\n{\n    vmxnet3_read_next_rx_descr(s, RXQ_IDX, RX_HEAD_BODY_RING, d, didx);\n\n    if (d->gen == vmxnet3_get_rx_ring_gen(s, RXQ_IDX, RX_HEAD_BODY_RING)) {\n        smp_rmb();\n        vmxnet3_read_next_rx_descr(s, RXQ_IDX, RX_HEAD_BODY_RING, d, didx);\n        if (d->btype == VMXNET3_RXD_BTYPE_BODY) {\n            vmxnet3_inc_rx_consumption_counter(s, RXQ_IDX, RX_HEAD_BODY_RING);\n            *ridx = RX_HEAD_BODY_RING;\n            return true;\n        }\n    }\n\n    vmxnet3_read_next_rx_descr(s, RXQ_IDX, RX_BODY_ONLY_RING, d, didx);\n\n    if (d->gen == vmxnet3_get_rx_ring_gen(s, RXQ_IDX, RX_BODY_ONLY_RING)) {\n        smp_rmb();\n        vmxnet3_read_next_rx_descr(s, RXQ_IDX, RX_BODY_ONLY_RING, d, didx);\n        assert(d->btype == VMXNET3_RXD_BTYPE_BODY);\n        *ridx = RX_BODY_ONLY_RING;\n        vmxnet3_inc_rx_consumption_counter(s, RXQ_IDX, RX_BODY_ONLY_RING);\n        return true;\n    }\n\n    return false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8435, "func": "pvscsi_process_completion_queue(void *opaque)\n{\n    PVSCSIState *s = opaque;\n    PVSCSIRequest *pvscsi_req;\n    bool has_completed = false;\n\n    while (!QTAILQ_EMPTY(&s->completion_queue)) {\n        pvscsi_req = QTAILQ_FIRST(&s->completion_queue);\n        QTAILQ_REMOVE(&s->completion_queue, pvscsi_req, next);\n        pvscsi_cmp_ring_put(s, &pvscsi_req->cmp);\n        g_free(pvscsi_req);\n        has_completed = true;\n    }\n\n    if (has_completed) {\n        pvscsi_ring_flush_cmp(&s->rings);\n        pvscsi_raise_completion_interrupt(s);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8877, "func": "bool vrend_hw_switch_context(struct vrend_context *ctx, bool now)\n{\n   if (ctx == vrend_state.current_ctx && ctx->ctx_switch_pending == false)\n      return true;\n\n   if (ctx->ctx_id != 0 && ctx->in_error) {\n      return false;\n   }\n\n   ctx->ctx_switch_pending = true;\n   if (now == true) {\n      vrend_finish_context_switch(ctx);\n   }\n   vrend_state.current_ctx = ctx;\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8557, "func": "static int ssh_comp_none_block(void *handle, unsigned char *block, int len,\n\t\t\t       unsigned char **outblock, int *outlen)\n{\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8861, "func": "static void vrend_finish_context_switch(struct vrend_context *ctx)\n{\n   if (ctx->ctx_switch_pending == false)\n      return;\n   ctx->ctx_switch_pending = false;\n\n   if (vrend_state.current_hw_ctx == ctx)\n      return;\n\n   vrend_state.current_hw_ctx = ctx;\n\n   vrend_clicbs->make_current(0, ctx->sub->gl_context);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8788, "func": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n         fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n      fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n      glDeleteProgram(prog_id);\n      free(sprog);\n      return NULL;\n   }\n\n   sprog->ss[PIPE_SHADER_VERTEX] = vs;\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9159, "func": "static GLuint blit_build_frag_tex_writedepth(struct vrend_blitter_ctx *blit_ctx, int tgsi_tex_target)\n{\n   GLuint fs_id;\n   char shader_buf[4096];\n   int is_shad;\n   const char *twm;\n\n   switch (tgsi_tex_target) {\n   case TGSI_TEXTURE_1D:\n   case TGSI_TEXTURE_BUFFER:\n      twm = \".x\";\n      break;\n   case TGSI_TEXTURE_1D_ARRAY:\n   case TGSI_TEXTURE_2D:\n   case TGSI_TEXTURE_RECT:\n   case TGSI_TEXTURE_2D_MSAA:\n   default:\n      twm = \".xy\";\n      break;\n   case TGSI_TEXTURE_SHADOW1D:\n   case TGSI_TEXTURE_SHADOW2D:\n   case TGSI_TEXTURE_SHADOW1D_ARRAY:\n   case TGSI_TEXTURE_SHADOWRECT:\n   case TGSI_TEXTURE_3D:\n   case TGSI_TEXTURE_CUBE:\n   case TGSI_TEXTURE_2D_ARRAY:\n   case TGSI_TEXTURE_2D_ARRAY_MSAA:\n      twm = \".xyz\";\n      break;\n   case TGSI_TEXTURE_SHADOWCUBE:\n   case TGSI_TEXTURE_SHADOW2D_ARRAY:\n   case TGSI_TEXTURE_SHADOWCUBE_ARRAY:\n   case TGSI_TEXTURE_CUBE_ARRAY:\n      twm = \"\";\n      break;\n   }\n\n   snprintf(shader_buf, 4096, FS_TEXFETCH_DS, vrend_shader_samplertypeconv(tgsi_tex_target, &is_shad), twm);\n\n   fs_id = glCreateShader(GL_FRAGMENT_SHADER);\n\n   if (!build_and_check(fs_id, shader_buf)) {\n      glDeleteShader(fs_id);\n      return 0;\n   }\n\n   return fs_id;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188121, "func": " static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,\n Handle<JSObject> object,\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n    Handle<Map> original_map = handle(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n continue;\n }\n\n Handle<Object> element_k =\n Subclass::GetImpl(isolate, *parameter_map, entry);\n\n if (element_k->IsAccessorPair()) {\n LookupIterator it(isolate, object, k, LookupIterator::OWN);\n        DCHECK(it.IsFound());\n        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,\n Object::GetPropertyWithAccessor(&it),\n Nothing<int64_t>());\n\n if (value->StrictEquals(*element_k)) {\n return Just<int64_t>(k);\n }\n\n if (object->map() != *original_map) {\n return IndexOfValueSlowPath(isolate, object, value, k + 1, length);\n }\n } else if (value->StrictEquals(*element_k)) {\n return Just<int64_t>(k);\n }\n }\n return Just<int64_t>(-1);\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 187887, "func": "long mkvparser::UnserializeFloat(IMkvReader* pReader, long long pos,\n                                 long long size_, double& result) {\n  assert(pReader);\n  assert(pos >= 0);\n  if ((size_ != 4) && (size_ != 8))\n     return E_FILE_FORMAT_INVALID;\n \n   const long size = static_cast<long>(size_);\n\n unsigned char buf[8];\n\n const int status = pReader->Read(pos, size, buf);\n\n if (status < 0) \n return status;\n\n if (size == 4) {\n union {\n float f;\n unsigned long ff;\n };\n\n    ff = 0;\n\n for (int i = 0;;) {\n      ff |= buf[i];\n\n if (++i >= 4)\n break;\n\n      ff <<= 8;\n }\n\n \n     result = f;\n   } else {\n    assert(size == 8);\n     union {\n       double d;\n       unsigned long long dd;\n };\n\n    dd = 0;\n\n for (int i = 0;;) {\n      dd |= buf[i];\n\n if (++i >= 8)\n break;\n\n      dd <<= 8;\n }\n\n\n     result = d;\n   }\n \n   return 0;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,37"}
{"idx": 8675, "func": "static size_t vpack(uint8_t **p_data, const char *fmt, va_list ap1)\n{\n    size_t size = 0;\n    uint8_t *data = NULL;\n\n    if (p_data) {\n        va_list ap2;\n\n        va_copy(ap2, ap1);\n        size = vfill(NULL, 0, fmt, ap2);\n        *p_data = data = g_malloc(size);\n        va_end(ap2);\n    }\n    return vfill(data, size, fmt, ap1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188550, "func": " virtual void SetUp() {\n\n     fwd_txfm_ = GET_PARAM(0);\n     inv_txfm_ = GET_PARAM(1);\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 16;\n     fwd_txfm_ref = fht16x16_ref;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9191, "func": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stl_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188574, "func": "  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9220, "func": "int virtio_queue_get_num(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.num;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187811, "func": "OMX_ERRORTYPE  omx_vdec::get_parameter(OMX_IN OMX_HANDLETYPE     hComp,\n        OMX_IN OMX_INDEXTYPE paramIndex,\n        OMX_INOUT OMX_PTR     paramData)\n{\n (void) hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n\n    DEBUG_PRINT_LOW(\"get_parameter:\");\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"Get Param in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n if (paramData == NULL) {\n        DEBUG_PRINT_LOW(\"Get Param in Invalid paramData\");\n return OMX_ErrorBadParameter;\n\n     }\n     switch ((unsigned long)paramIndex) {\n         case OMX_IndexParamPortDefinition: {\n                                OMX_PARAM_PORTDEFINITIONTYPE *portDefn =\n                                    (OMX_PARAM_PORTDEFINITIONTYPE *) paramData;\n                                DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamPortDefinition\");\n                               eRet = update_portdef(portDefn);\n if (eRet == OMX_ErrorNone)\n                                   m_port_def = *portDefn;\n\n                                break;\n                            }\n         case OMX_IndexParamVideoInit: {\n                               OMX_PORT_PARAM_TYPE *portParamType =\n                                   (OMX_PORT_PARAM_TYPE *) paramData;\n                               DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoInit\");\n \n                               portParamType->nVersion.nVersion = OMX_SPEC_VERSION;\n                              portParamType->nSize = sizeof(portParamType);\n                               portParamType->nPorts           = 2;\n                               portParamType->nStartPortNumber = 0;\n                               break;\n                           }\n         case OMX_IndexParamVideoPortFormat: {\n                                 OMX_VIDEO_PARAM_PORTFORMATTYPE *portFmt =\n                                     (OMX_VIDEO_PARAM_PORTFORMATTYPE *)paramData;\n                                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoPortFormat\");\n \n                                 portFmt->nVersion.nVersion = OMX_SPEC_VERSION;\n                                portFmt->nSize             = sizeof(portFmt);\n \n                                 if (0 == portFmt->nPortIndex) {\n                                     if (0 == portFmt->nIndex) {\n                                        portFmt->eColorFormat =  OMX_COLOR_FormatUnused;\n                                        portFmt->eCompressionFormat = eCompressionFormat;\n } else {\n                                        DEBUG_PRINT_ERROR(\"get_parameter: OMX_IndexParamVideoPortFormat:\"\\\n \" NoMore compression formats\");\n                                        eRet =  OMX_ErrorNoMore;\n }\n } else if (1 == portFmt->nPortIndex) {\n                                    portFmt->eCompressionFormat =  OMX_VIDEO_CodingUnused;\n\n bool useNonSurfaceMode = false;\n#if defined(_ANDROID_) && !defined(FLEXYUV_SUPPORTED)\n                                    useNonSurfaceMode = (m_enable_android_native_buffers == OMX_FALSE);\n#endif\n                                    portFmt->eColorFormat = useNonSurfaceMode ?\n                                        getPreferredColorFormatNonSurfaceMode(portFmt->nIndex) :\n                                        getPreferredColorFormatDefaultMode(portFmt->nIndex);\n\n if (portFmt->eColorFormat == OMX_COLOR_FormatMax ) {\n                                        eRet = OMX_ErrorNoMore;\n                                        DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoPortFormat:\"\\\n \" NoMore Color formats\");\n }\n                                    DEBUG_PRINT_HIGH(\"returning color-format: 0x%x\", portFmt->eColorFormat);\n } else {\n                                    DEBUG_PRINT_ERROR(\"get_parameter: Bad port index %d\",\n (int)portFmt->nPortIndex);\n                                    eRet = OMX_ErrorBadPortIndex;\n }\n break;\n\n                             }\n         case OMX_IndexParamAudioInit: {\n                               OMX_PORT_PARAM_TYPE *audioPortParamType =\n                                   (OMX_PORT_PARAM_TYPE *) paramData;\n                               DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamAudioInit\");\n                               audioPortParamType->nVersion.nVersion = OMX_SPEC_VERSION;\n                              audioPortParamType->nSize = sizeof(audioPortParamType);\n                               audioPortParamType->nPorts           = 0;\n                               audioPortParamType->nStartPortNumber = 0;\n                               break;\n                           }\n         case OMX_IndexParamImageInit: {\n                               OMX_PORT_PARAM_TYPE *imagePortParamType =\n                                   (OMX_PORT_PARAM_TYPE *) paramData;\n                               DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamImageInit\");\n                               imagePortParamType->nVersion.nVersion = OMX_SPEC_VERSION;\n                              imagePortParamType->nSize = sizeof(imagePortParamType);\n                               imagePortParamType->nPorts           = 0;\n                               imagePortParamType->nStartPortNumber = 0;\n                               break;\n\n }\n case OMX_IndexParamOtherInit: {\n                              DEBUG_PRINT_ERROR(\"get_parameter: OMX_IndexParamOtherInit %08x\",\n                                      paramIndex);\n                              eRet =OMX_ErrorUnsupportedIndex;\n\n                               break;\n                           }\n         case OMX_IndexParamStandardComponentRole: {\n                                   OMX_PARAM_COMPONENTROLETYPE *comp_role;\n                                   comp_role = (OMX_PARAM_COMPONENTROLETYPE *) paramData;\n                                   comp_role->nVersion.nVersion = OMX_SPEC_VERSION;\n                                  comp_role->nSize = sizeof(*comp_role);\n\n                                  DEBUG_PRINT_LOW(\"Getparameter: OMX_IndexParamStandardComponentRole %d\",\n                                          paramIndex);\n                                  strlcpy((char*)comp_role->cRole,(const char*)m_cRole,\n                                          OMX_MAX_STRINGNAME_SIZE);\n break;\n\n                               }\n         case OMX_IndexParamPriorityMgmt: {\n                              OMX_PRIORITYMGMTTYPE *priorityMgmType =\n                                  (OMX_PRIORITYMGMTTYPE *) paramData;\n                              DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamPriorityMgmt\");\n                              priorityMgmType->nVersion.nVersion = OMX_SPEC_VERSION;\n                             priorityMgmType->nSize = sizeof(priorityMgmType);\n \n                              break;\n                          }\n         case OMX_IndexParamCompBufferSupplier: {\n                                    OMX_PARAM_BUFFERSUPPLIERTYPE *bufferSupplierType =\n                                        (OMX_PARAM_BUFFERSUPPLIERTYPE*) paramData;\n                                    DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamCompBufferSupplier\");\n \n                                   bufferSupplierType->nSize = sizeof(bufferSupplierType);\n                                    bufferSupplierType->nVersion.nVersion = OMX_SPEC_VERSION;\n                                    if (0 == bufferSupplierType->nPortIndex)\n                                        bufferSupplierType->nPortIndex = OMX_BufferSupplyUnspecified;\n else if (1 == bufferSupplierType->nPortIndex)\n                                       bufferSupplierType->nPortIndex = OMX_BufferSupplyUnspecified;\n else\n                                       eRet = OMX_ErrorBadPortIndex;\n\n\n break;\n }\n case OMX_IndexParamVideoAvc: {\n                             DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoAvc %08x\",\n                                     paramIndex);\n break;\n }\n case (OMX_INDEXTYPE)QOMX_IndexParamVideoMvc: {\n                             DEBUG_PRINT_LOW(\"get_parameter: QOMX_IndexParamVideoMvc %08x\",\n                                     paramIndex);\n break;\n }\n case OMX_IndexParamVideoH263: {\n                              DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoH263 %08x\",\n                                      paramIndex);\n break;\n }\n case OMX_IndexParamVideoMpeg4: {\n                               DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoMpeg4 %08x\",\n                                       paramIndex);\n break;\n }\n case OMX_IndexParamVideoMpeg2: {\n                               DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoMpeg2 %08x\",\n                                       paramIndex);\n\n                                break;\n                            }\n         case OMX_IndexParamVideoProfileLevelQuerySupported: {\n                                         DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoProfileLevelQuerySupported %08x\", paramIndex);\n                                         OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileLevelType =\n                                             (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)paramData;\n                                        eRet = get_supported_profile_level_for_1080p(profileLevelType);\n break;\n\n                                     }\n #if defined (_ANDROID_HONEYCOMB_) || defined (_ANDROID_ICS_)\n         case OMX_GoogleAndroidIndexGetAndroidNativeBufferUsage: {\n                                         DEBUG_PRINT_LOW(\"get_parameter: OMX_GoogleAndroidIndexGetAndroidNativeBufferUsage\");\n                                         GetAndroidNativeBufferUsageParams* nativeBuffersUsage = (GetAndroidNativeBufferUsageParams *) paramData;\n                                         if (nativeBuffersUsage->nPortIndex == OMX_CORE_OUTPUT_PORT_INDEX) {\n\n if (secure_mode && !secure_scaling_to_non_secure_opb) {\n                                                nativeBuffersUsage->nUsage = (GRALLOC_USAGE_PRIVATE_MM_HEAP | GRALLOC_USAGE_PROTECTED |\n                                                        GRALLOC_USAGE_PRIVATE_UNCACHED);\n } else {\n                                                nativeBuffersUsage->nUsage =\n (GRALLOC_USAGE_PRIVATE_IOMMU_HEAP |\n                                                     GRALLOC_USAGE_PRIVATE_UNCACHED);\n }\n } else {\n                                            DEBUG_PRINT_HIGH(\"get_parameter: OMX_GoogleAndroidIndexGetAndroidNativeBufferUsage failed!\");\n                                            eRet = OMX_ErrorBadParameter;\n }\n }\n break;\n#endif\n\n\n #ifdef FLEXYUV_SUPPORTED\n         case OMX_QcomIndexFlexibleYUVDescription: {\n                 DEBUG_PRINT_LOW(\"get_parameter: describeColorFormat\");\n                 eRet = describeColorFormat(paramData);\n                 break;\n             }\n#endif\n\n default: {\n                 DEBUG_PRINT_ERROR(\"get_parameter: unknown param %08x\", paramIndex);\n                 eRet =OMX_ErrorUnsupportedIndex;\n }\n\n }\n\n    DEBUG_PRINT_LOW(\"get_parameter returning WxH(%d x %d) SxSH(%d x %d)\",\n            drv_ctx.video_resolution.frame_width,\n            drv_ctx.video_resolution.frame_height,\n            drv_ctx.video_resolution.stride,\n            drv_ctx.video_resolution.scan_lines);\n\n return eRet;\n}\n", "target": 1, "flaw_line_index": "35,46,91,102,132,142"}
{"idx": 187493, "func": "void GKI_delay(UINT32 timeout_ms) {\n struct timespec delay;\n  delay.tv_sec = timeout_ms / 1000;\n  delay.tv_nsec = 1000 * 1000 * (timeout_ms % 1000);\n\n \n   int err;\n   do {\n    err = nanosleep(&delay, &delay);\n   } while (err == -1 && errno == EINTR);\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 9196, "func": "static void virtio_device_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    dc->realize = virtio_device_realize;\n    dc->unrealize = virtio_device_unrealize;\n    dc->bus_type = TYPE_VIRTIO_BUS;\n    dc->props = virtio_properties;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8384, "func": "static int mptsas_scsi_device_find(MPTSASState *s, int bus, int target,\n                                   uint8_t *lun, SCSIDevice **sdev)\n{\n    if (bus != 0) {\n        return MPI_IOCSTATUS_SCSI_INVALID_BUS;\n    }\n\n    if (target >= s->max_devices) {\n        return MPI_IOCSTATUS_SCSI_INVALID_TARGETID;\n    }\n\n    *sdev = scsi_device_find(&s->bus, bus, target, lun[1]);\n    if (!*sdev) {\n        return MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE;\n    }\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8914, "func": "int vrend_renderer_resource_create(struct vrend_renderer_resource_create_args *args, struct iovec *iov, uint32_t num_iovs)\n{\n   struct vrend_resource *gr;\n   int level;\n   int ret;\n\n   ret = check_resource_valid(args);\n   if (ret)\n      return EINVAL;\n\n   gr = (struct vrend_resource *)CALLOC_STRUCT(vrend_texture);\n   if (!gr)\n      return ENOMEM;\n\n   gr->handle = args->handle;\n   gr->iov = iov;\n   gr->num_iovs = num_iovs;\n   gr->base.width0 = args->width;\n   gr->base.height0 = args->height;\n   gr->base.depth0 = args->depth;\n   gr->base.format = args->format;\n   gr->base.target = args->target;\n   gr->base.last_level = args->last_level;\n   gr->base.nr_samples = args->nr_samples;\n   gr->base.array_size = args->array_size;\n\n   if (args->flags & VIRGL_RESOURCE_Y_0_TOP)\n      gr->y_0_top = true;\n\n   pipe_reference_init(&gr->base.reference, 1);\n\n   if (args->bind == VREND_RES_BIND_CUSTOM) {\n      gr->ptr = malloc(args->width);\n      if (!gr->ptr) {\n         FREE(gr);\n         return ENOMEM;\n      }\n   } else if (args->bind == VREND_RES_BIND_INDEX_BUFFER) {\n      gr->target = GL_ELEMENT_ARRAY_BUFFER_ARB;\n      glGenBuffersARB(1, &gr->id);\n      glBindBufferARB(gr->target, gr->id);\n      glBufferData(gr->target, args->width, NULL, GL_STREAM_DRAW);\n   } else if (args->bind == VREND_RES_BIND_STREAM_OUTPUT) {\n      gr->target = GL_TRANSFORM_FEEDBACK_BUFFER;\n      glGenBuffersARB(1, &gr->id);\n      glBindBuffer(gr->target, gr->id);\n      glBufferData(gr->target, args->width, NULL, GL_STREAM_DRAW);\n   } else if (args->bind == VREND_RES_BIND_VERTEX_BUFFER) {\n      gr->target = GL_ARRAY_BUFFER_ARB;\n      glGenBuffersARB(1, &gr->id);\n      glBindBufferARB(gr->target, gr->id);\n      glBufferData(gr->target, args->width, NULL, GL_STREAM_DRAW);\n   } else if (args->bind == VREND_RES_BIND_CONSTANT_BUFFER) {\n      gr->target = GL_UNIFORM_BUFFER;\n      glGenBuffersARB(1, &gr->id);\n      glBindBufferARB(gr->target, gr->id);\n      glBufferData(gr->target, args->width, NULL, GL_STREAM_DRAW);\n   } else if (args->target == PIPE_BUFFER && args->bind == 0) {\n      gr->target = GL_ARRAY_BUFFER_ARB;\n      glGenBuffersARB(1, &gr->id);\n      glBindBufferARB(gr->target, gr->id);\n      glBufferData(gr->target, args->width, NULL, GL_STREAM_DRAW);\n   } else if (args->target == PIPE_BUFFER && (args->bind & VREND_RES_BIND_SAMPLER_VIEW)) {\n      GLenum internalformat;\n      if (epoxy_has_gl_extension(\"GL_ARB_texture_buffer_object\")) {\n         gr->target = GL_TEXTURE_BUFFER;\n         glGenBuffersARB(1, &gr->id);\n         glBindBufferARB(gr->target, gr->id);\n         glGenTextures(1, &gr->tbo_tex_id);\n         glBufferData(gr->target, args->width, NULL, GL_STREAM_DRAW);\n\n         glBindTexture(gr->target, gr->tbo_tex_id);\n         internalformat = tex_conv_table[args->format].internalformat;\n         glTexBuffer(gr->target, internalformat, gr->id);\n      } else {\n         gr->target = GL_PIXEL_PACK_BUFFER_ARB;\n         glGenBuffersARB(1, &gr->id);\n         glBindBufferARB(gr->target, gr->id);\n         glBufferData(gr->target, args->width, NULL, GL_STREAM_DRAW);\n      }\n   } else {\n      struct vrend_texture *gt = (struct vrend_texture *)gr;\n      GLenum internalformat, glformat, gltype;\n      gr->target = tgsitargettogltarget(args->target, args->nr_samples);\n      glGenTextures(1, &gr->id);\n      glBindTexture(gr->target, gr->id);\n\n      internalformat = tex_conv_table[args->format].internalformat;\n      glformat = tex_conv_table[args->format].glformat;\n      gltype = tex_conv_table[args->format].gltype;\n      if (internalformat == 0) {\n         fprintf(stderr,\"unknown format is %d\\n\", args->format);\n         FREE(gr);\n         return EINVAL;\n      }\n\n      if (args->nr_samples > 1) {\n         if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) {\n            glTexImage2DMultisample(gr->target, args->nr_samples,\n                                    internalformat, args->width, args->height,\n                                    GL_TRUE);\n         } else {\n            glTexImage3DMultisample(gr->target, args->nr_samples,\n                                    internalformat, args->width, args->height, args->array_size,\n                                    GL_TRUE);\n         }\n\n      } else if (gr->target == GL_TEXTURE_CUBE_MAP) {\n         int i;\n         for (i = 0; i < 6; i++) {\n            GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;\n            for (level = 0; level <= args->last_level; level++) {\n               unsigned mwidth = u_minify(args->width, level);\n               unsigned mheight = u_minify(args->height, level);\n               glTexImage2D(ctarget, level, internalformat, mwidth, mheight, 0, glformat,\n                            gltype, NULL);\n            }\n         }\n      } else if (gr->target == GL_TEXTURE_3D ||\n                 gr->target == GL_TEXTURE_2D_ARRAY ||\n                 gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) {\n         for (level = 0; level <= args->last_level; level++) {\n            unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ? args->array_size : u_minify(args->depth, level);\n            unsigned mwidth = u_minify(args->width, level);\n            unsigned mheight = u_minify(args->height, level);\n            glTexImage3D(gr->target, level, internalformat, mwidth, mheight, depth_param, 0,\n                         glformat,\n                         gltype, NULL);\n         }\n      } else if (gr->target == GL_TEXTURE_1D) {\n         for (level = 0; level <= args->last_level; level++) {\n            unsigned mwidth = u_minify(args->width, level);\n            glTexImage1D(gr->target, level, internalformat, mwidth, 0,\n                         glformat,\n                         gltype, NULL);\n         }\n      } else {\n         for (level = 0; level <= args->last_level; level++) {\n            unsigned mwidth = u_minify(args->width, level);\n            unsigned mheight = u_minify(args->height, level);\n            glTexImage2D(gr->target, level, internalformat, mwidth, gr->target == GL_TEXTURE_1D_ARRAY ? args->array_size : mheight, 0, glformat,\n                         gltype, NULL);\n         }\n      }\n\n      gt->state.max_lod = -1;\n      gt->cur_swizzle_r = gt->cur_swizzle_g = gt->cur_swizzle_b = gt->cur_swizzle_a = -1;\n   }\n\n   ret = vrend_resource_insert(gr, args->handle);\n   if (ret == 0) {\n      vrend_renderer_resource_destroy(gr, true);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9038, "func": "static void vmxnet3_put_tx_stats_to_file(QEMUFile *f,\n    struct UPT1_TxStats *tx_stat)\n{\n    qemu_put_be64(f, tx_stat->TSOPktsTxOK);\n    qemu_put_be64(f, tx_stat->TSOBytesTxOK);\n    qemu_put_be64(f, tx_stat->ucastPktsTxOK);\n    qemu_put_be64(f, tx_stat->ucastBytesTxOK);\n    qemu_put_be64(f, tx_stat->mcastPktsTxOK);\n    qemu_put_be64(f, tx_stat->mcastBytesTxOK);\n    qemu_put_be64(f, tx_stat->bcastPktsTxOK);\n    qemu_put_be64(f, tx_stat->bcastBytesTxOK);\n    qemu_put_be64(f, tx_stat->pktsTxError);\n    qemu_put_be64(f, tx_stat->pktsTxDiscard);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8387, "func": "static void mptsas_set_fault(MPTSASState *s, uint32_t code)\n{\n    if ((s->state & MPI_IOC_STATE_FAULT) == 0) {\n        s->state = MPI_IOC_STATE_FAULT | code;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188612, "func": "   virtual void SetUp() {\n    const tuple<int, int, SubpelVarianceFunctionType>& params =\n        this->GetParam();\n     log2width_  = get<0>(params);\n     width_ = 1 << log2width_;\n     log2height_ = get<1>(params);\n     height_ = 1 << log2height_;\n    subpel_variance_ = get<2>(params);\n \n     rnd(ACMRandom::DeterministicSeed());\n     block_size_ = width_ * height_;\n     src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n    sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n    ref_ = new uint8_t[block_size_ + width_ + height_ + 1];\n     ASSERT_TRUE(src_ != NULL);\n    ASSERT_TRUE(sec_ != NULL);\n     ASSERT_TRUE(ref_ != NULL);\n   }\n", "target": 1, "flaw_line_index": "2,3,8,13,14,16"}
{"idx": 187386, "func": " ssize_t MPEG4DataSource::readAt(off64_t offset, void *data, size_t size) {\n     Mutex::Autolock autoLock(mLock);\n \n    if (offset >= mCachedOffset\n            && offset + size <= mCachedOffset + mCachedSize) {\n         memcpy(data, &mCache[offset - mCachedOffset], size);\n         return size;\n     }\n\n return mSource->readAt(offset, data, size);\n}\n", "target": 1, "flaw_line_index": "4,5"}
{"idx": 8519, "func": "static void logeventf(Ssh ssh, const char *fmt, ...)\n{\n    va_list ap;\n    char *buf;\n\n    va_start(ap, fmt);\n    buf = dupvprintf(fmt, ap);\n    va_end(ap);\n    logevent(buf);\n    sfree(buf);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187660, "func": " image_transform_png_set_palette_to_rgb_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n return colour_type == PNG_COLOR_TYPE_PALETTE;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187412, "func": "void FrameworkListener::init(const char *socketName UNUSED, bool withSeq) {\n    mCommands = new FrameworkCommandCollection();\n\n     errorRate = 0;\n     mCommandCount = 0;\n     mWithSeq = withSeq;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187666, "func": "image_transform_png_set_rgb_to_gray_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n   PNG_CONST int error_action = 1; \n \n #  ifdef PNG_FLOATING_POINT_SUPPORTED\n       png_set_rgb_to_gray(pp, error_action, data.red_to_set, data.green_to_set);\n#  else\n      png_set_rgb_to_gray_fixed(pp, error_action, data.red_to_set,\n         data.green_to_set);\n#  endif\n\n#  ifdef PNG_READ_cHRM_SUPPORTED\n if (that->pm->current_encoding != 0)\n {\n#        ifdef PNG_FLOATING_POINT_SUPPORTED\n#           define API_function png_get_cHRM_XYZ\n#           define API_form \"FP\"\n#           define API_type double\n#           define API_cvt(x) (x)\n#        else\n#           define API_function png_get_cHRM_XYZ_fixed\n#           define API_form \"fixed\"\n#           define API_type png_fixed_point\n#           define API_cvt(x) ((double)(x)/PNG_FP_1)\n#        endif\n\n         API_type rX, gX, bX;\n         API_type rY, gY, bY;\n         API_type rZ, gZ, bZ;\n\n if ((API_function(pp, pi, &rX, &rY, &rZ, &gX, &gY, &gZ, &bX, &bY, &bZ)\n\n                & PNG_INFO_cHRM) != 0)\n          {\n             double maxe;\n            PNG_CONST char *el;\n             color_encoding e, o;\n \n            modifier_current_encoding(that->pm, &o);\n            normalize_color_encoding(&o);\n\n if (data.red_to_set == -1 && data.green_to_set == -1 &&\n (fabs(o.red.Y - data.red_coefficient) > DBL_EPSILON ||\n               fabs(o.green.Y - data.green_coefficient) > DBL_EPSILON ||\n               fabs(o.blue.Y - data.blue_coefficient) > DBL_EPSILON))\n               png_error(pp, \"internal pngvalid cHRM coefficient error\");\n\n            e.gamma = o.gamma; \n            e.red.X = API_cvt(rX);\n            e.red.Y = API_cvt(rY);\n            e.red.Z = API_cvt(rZ);\n            e.green.X = API_cvt(gX);\n            e.green.Y = API_cvt(gY);\n            e.green.Z = API_cvt(gZ);\n            e.blue.X = API_cvt(bX);\n            e.blue.Y = API_cvt(bY);\n            e.blue.Z = API_cvt(bZ);\n\n            maxe = 0;\n            el = \"-\"; \n\n#           define CHECK(col,x)\\\n {\\\n double err = fabs(o.col.x - e.col.x);\\\n if (err > maxe)\\\n {\\\n                  maxe = err;\\\n                  el = #col \"(\" #x \")\";\\\n }\\\n }\n\n            CHECK(red,X)\n            CHECK(red,Y)\n            CHECK(red,Z)\n            CHECK(green,X)\n            CHECK(green,Y)\n            CHECK(green,Z)\n            CHECK(blue,X)\n            CHECK(blue,Y)\n            CHECK(blue,Z)\n\n if (maxe >= 1E-5)\n {\n size_t pos = 0;\n char buffer[256];\n\n               pos = safecat(buffer, sizeof buffer, pos, API_form);\n               pos = safecat(buffer, sizeof buffer, pos, \" cHRM \");\n               pos = safecat(buffer, sizeof buffer, pos, el);\n               pos = safecat(buffer, sizeof buffer, pos, \" error: \");\n               pos = safecatd(buffer, sizeof buffer, pos, maxe, 7);\n               pos = safecat(buffer, sizeof buffer, pos, \" \");\n               pos = safecat_color_encoding(buffer, sizeof buffer, pos, &o, 0);\n               pos = safecat(buffer, sizeof buffer, pos, \" -> \");\n               pos = safecat_color_encoding(buffer, sizeof buffer, pos, &e, 0);\n\n               png_error(pp, buffer);\n }\n }\n }\n#  endif \n\n this->next->set(this->next, that, pp, pi);\n\n }\n", "target": 1, "flaw_line_index": "4,37"}
{"idx": 8821, "func": "void vrend_begin_query(struct vrend_context *ctx, uint32_t handle)\n{\n   struct vrend_query *q;\n\n   q = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_QUERY);\n   if (!q)\n      return;\n\n   if (q->gltype == GL_TIMESTAMP)\n      return;\n\n   glBeginQuery(q->gltype, q->id);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9082, "func": "static bool vmxnet3_vmstate_test_pci_device(void *opaque, int version_id)\n{\n    return !vmxnet3_vmstate_need_pcie_device(opaque);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8746, "func": "vcard_response_new_data(unsigned char *buf, int len)\n{\n    VCardResponse *new_response;\n\n    new_response = g_new(VCardResponse, 1);\n    new_response->b_data = g_malloc(len + 2);\n    memcpy(new_response->b_data, buf, len);\n    new_response->b_total_len = len+2;\n    new_response->b_len = len;\n    new_response->b_type = VCARD_MALLOC;\n    return new_response;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188592, "func": "  void CheckSad(unsigned int max_sad) {\n    unsigned int reference_sad, exp_sad;\n    reference_sad = ReferenceSAD(max_sad);\n    exp_sad = SAD(max_sad);\n    if (reference_sad <= max_sad) {\n      ASSERT_EQ(exp_sad, reference_sad);\n    } else {\n      ASSERT_GE(exp_sad, reference_sad);\n    }\n  }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11"}
{"idx": 8537, "func": "static void ssh2_log_outgoing_packet(Ssh ssh, struct Packet *pkt)\n{\n    int nblanks = 0;\n    struct logblank_t blanks[4];\n    char *str;\n    int slen;\n\n    pkt->length -= (pkt->body - pkt->data);\n    pkt->savedpos = 0;\n\n    if (ssh->logomitdata &&\n        (pkt->type == SSH2_MSG_CHANNEL_DATA ||\n         pkt->type == SSH2_MSG_CHANNEL_EXTENDED_DATA)) {\n        ssh_pkt_getuint32(pkt);    \n        if (pkt->type == SSH2_MSG_CHANNEL_EXTENDED_DATA)\n            ssh_pkt_getuint32(pkt);    \n        blanks[nblanks].offset = pkt->savedpos + 4;\n        blanks[nblanks].type = PKTLOG_OMIT;\n        ssh_pkt_getstring(pkt, &str, &slen);\n        if (str) {\n            blanks[nblanks].len = slen;\n            nblanks++;\n        }\n    }\n\n    if (pkt->type == SSH2_MSG_USERAUTH_REQUEST &&\n        conf_get_int(ssh->conf, CONF_logomitpass)) {\n        pkt->savedpos = 0;\n        ssh_pkt_getstring(pkt, &str, &slen);\n        ssh_pkt_getstring(pkt, &str, &slen);\n        ssh_pkt_getstring(pkt, &str, &slen);\n        if (slen == 8 && !memcmp(str, \"password\", 8)) {\n            ssh2_pkt_getbool(pkt);\n            blanks[nblanks].offset = pkt->savedpos;\n            blanks[nblanks].type = PKTLOG_BLANK;\n            ssh_pkt_getstring(pkt, &str, &slen);\n            if (str) {\n                blanks[nblanks].len = pkt->savedpos - blanks[nblanks].offset;\n                nblanks++;\n                ssh_pkt_getstring(pkt, &str, &slen);\n                if (str)\n                    blanks[nblanks-1].len =\n                        pkt->savedpos - blanks[nblanks].offset;\n            }\n        }\n    } else if (ssh->pkt_actx == SSH2_PKTCTX_KBDINTER &&\n               pkt->type == SSH2_MSG_USERAUTH_INFO_RESPONSE &&\n               conf_get_int(ssh->conf, CONF_logomitpass)) {\n        pkt->savedpos = 0;\n        ssh_pkt_getuint32(pkt);\n        blanks[nblanks].offset = pkt->savedpos;\n        blanks[nblanks].type = PKTLOG_BLANK;\n        while (1) {\n            ssh_pkt_getstring(pkt, &str, &slen);\n            if (!str)\n                break;\n        }\n        blanks[nblanks].len = pkt->savedpos - blanks[nblanks].offset;\n        nblanks++;\n    } else if (pkt->type == SSH2_MSG_CHANNEL_REQUEST &&\n               conf_get_int(ssh->conf, CONF_logomitpass)) {\n        pkt->savedpos = 0;\n        ssh_pkt_getuint32(pkt);\n        ssh_pkt_getstring(pkt, &str, &slen);\n        if (slen == 7 && !memcmp(str, \"x11-req\", 0)) {\n            ssh2_pkt_getbool(pkt);\n            ssh2_pkt_getbool(pkt);\n            ssh_pkt_getstring(pkt, &str, &slen);\n            blanks[nblanks].offset = pkt->savedpos;\n            blanks[nblanks].type = PKTLOG_BLANK;\n            ssh_pkt_getstring(pkt, &str, &slen);\n            if (str) {\n                blanks[nblanks].len = pkt->savedpos - blanks[nblanks].offset;\n                nblanks++;\n            }\n        }\n    }\n\n    log_packet(ssh->logctx, PKT_OUTGOING, pkt->data[5],\n               ssh2_pkt_type(ssh->pkt_kctx, ssh->pkt_actx, pkt->data[5]),\n               pkt->body, pkt->length, nblanks, blanks,\n               &ssh->v2_outgoing_sequence,\n               pkt->downstream_id, pkt->additional_log_text);\n\n    pkt->length += (pkt->body - pkt->data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9128, "func": "static int vrend_decode_set_viewport_state(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_viewport_state vps[PIPE_MAX_VIEWPORTS];\n   int i, v;\n   uint32_t num_viewports, start_slot;\n   if (length < 1)\n      return EINVAL;\n\n   if ((length - 1) % 6)\n      return EINVAL;\n\n   num_viewports = (length - 1) / 6;\n   start_slot = get_buf_entry(ctx, VIRGL_SET_VIEWPORT_START_SLOT);\n\n   if (num_viewports > PIPE_MAX_VIEWPORTS ||\n       start_slot > (PIPE_MAX_VIEWPORTS - num_viewports))\n      return EINVAL;\n\n   for (v = 0; v < num_viewports; v++) {\n      for (i = 0; i < 3; i++)\n         vps[v].scale[i] = uif(get_buf_entry(ctx, VIRGL_SET_VIEWPORT_STATE_SCALE_0(v) + i));\n      for (i = 0; i < 3; i++)\n         vps[v].translate[i] = uif(get_buf_entry(ctx, VIRGL_SET_VIEWPORT_STATE_TRANSLATE_0(v) + i));\n   }\n\n   vrend_set_viewport_states(ctx->grctx, start_slot, num_viewports, vps);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188106, "func": "SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {\n    std::unique_ptr<SkStream> inputStream(stream);\n\n static const uint32_t kIcoDirectoryBytes = 6;\n static const uint32_t kIcoDirEntryBytes = 16;\n\n    std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);\n if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=\n            kIcoDirectoryBytes) {\n SkCodecPrintf(\"Error: unable to read ico directory header.\\n\");\n *result = kIncompleteInput;\n return nullptr;\n }\n\n const uint16_t numImages = get_short(dirBuffer.get(), 4);\n if (0 == numImages) {\n SkCodecPrintf(\"Error: No images embedded in ico.\\n\");\n *result = kInvalidInput;\n return nullptr;\n }\n\n struct Entry {\n\n         uint32_t offset;\n         uint32_t size;\n     };\n    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,\n                                              SK_MALLOC_TEMP));\n     if (!dirEntryBuffer) {\n         SkCodecPrintf(\"Error: OOM allocating ICO directory for %i images.\\n\",\n                       numImages);\n *result = kInternalError;\n return nullptr;\n }\n auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());\n\n for (uint32_t i = 0; i < numImages; i++) {\n uint8_t entryBuffer[kIcoDirEntryBytes];\n if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=\n                kIcoDirEntryBytes) {\n SkCodecPrintf(\"Error: Dir entries truncated in ico.\\n\");\n *result = kIncompleteInput;\n return nullptr;\n }\n\n\n uint32_t size = get_int(entryBuffer, 8);\n\n uint32_t offset = get_int(entryBuffer, 12);\n\n        directoryEntries[i].offset = offset;\n        directoryEntries[i].size = size;\n }\n\n *result = kInvalidInput;\n\n struct EntryLessThan {\n bool operator() (Entry a, Entry b) const {\n return a.offset < b.offset;\n }\n };\n EntryLessThan lessThan;\n SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);\n\n uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;\n    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(\n new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));\n for (uint32_t i = 0; i < numImages; i++) {\n uint32_t offset = directoryEntries[i].offset;\n uint32_t size = directoryEntries[i].size;\n\n if (offset < bytesRead) {\n SkCodecPrintf(\"Warning: invalid ico offset.\\n\");\n continue;\n }\n\n if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {\n SkCodecPrintf(\"Warning: could not skip to ico offset.\\n\");\n break;\n }\n\n         bytesRead = offset;\n \n        SkAutoFree buffer(sk_malloc_flags(size, 0));\n         if (!buffer) {\n             SkCodecPrintf(\"Warning: OOM trying to create embedded stream.\\n\");\n             break;\n }\n\n if (inputStream->read(buffer.get(), size) != size) {\n SkCodecPrintf(\"Warning: could not create embedded stream.\\n\");\n *result = kIncompleteInput;\n break;\n }\n\n        sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));\n        std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));\n        bytesRead += size;\n\n SkCodec* codec = nullptr;\n Result dummyResult;\n if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {\n            codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);\n } else {\n            codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);\n }\n\n if (nullptr != codec) {\n            codecs->push_back().reset(codec);\n }\n }\n\n if (0 == codecs->count()) {\n SkCodecPrintf(\"Error: could not find any valid embedded ico codecs.\\n\");\n return nullptr;\n }\n\n size_t maxSize = 0;\n int maxIndex = 0;\n for (int i = 0; i < codecs->count(); i++) {\n SkImageInfo info = codecs->operator[](i)->getInfo();\n size_t size = info.getSafeSize(info.minRowBytes());\n\n if (size > maxSize) {\n            maxSize = size;\n            maxIndex = i;\n }\n }\n int width = codecs->operator[](maxIndex)->getInfo().width();\n int height = codecs->operator[](maxIndex)->getInfo().height();\n SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();\n SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();\n\n *result = kSuccess;\n return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));\n}\n", "target": 1, "flaw_line_index": "34,35,112"}
{"idx": 8527, "func": "static void ssh1_log_incoming_packet(Ssh ssh, struct Packet *pkt)\n{\n    int nblanks = 0;\n    struct logblank_t blanks[4];\n    char *str;\n    int slen;\n\n    pkt->savedpos = 0;\n\n    if (ssh->logomitdata &&\n        (pkt->type == SSH1_SMSG_STDOUT_DATA ||\n         pkt->type == SSH1_SMSG_STDERR_DATA ||\n         pkt->type == SSH1_MSG_CHANNEL_DATA)) {\n        if (pkt->type == SSH1_MSG_CHANNEL_DATA)\n            ssh_pkt_getuint32(pkt);    \n        blanks[nblanks].offset = pkt->savedpos + 4;\n        blanks[nblanks].type = PKTLOG_OMIT;\n        ssh_pkt_getstring(pkt, &str, &slen);\n        if (str) {\n            blanks[nblanks].len = slen;\n            nblanks++;\n        }\n    }\n    log_packet(ssh->logctx, PKT_INCOMING, pkt->type,\n               ssh1_pkt_type(pkt->type),\n               pkt->body, pkt->length, nblanks, blanks, NULL,\n               0, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8541, "func": "static int ssh2_pkt_construct(Ssh ssh, struct Packet *pkt)\n{\n    int cipherblk, maclen, padding, unencrypted_prefix, i;\n\n    if (ssh->logctx)\n        ssh2_log_outgoing_packet(ssh, pkt);\n\n    if (ssh->bare_connection) {\n        PUT_32BIT(pkt->data + 1, pkt->length - 5);\n        pkt->body = pkt->data + 1;\n        ssh->v2_outgoing_sequence++;   \n        return pkt->length - 1;\n    }\n\n    {\n\tunsigned char *newpayload;\n\tint newlen;\n\tif (ssh->cscomp &&\n\t    ssh->cscomp->compress(ssh->cs_comp_ctx, pkt->data + 5,\n\t\t\t\t  pkt->length - 5,\n\t\t\t\t  &newpayload, &newlen)) {\n\t    pkt->length = 5;\n\t    ssh2_pkt_adddata(pkt, newpayload, newlen);\n\t    sfree(newpayload);\n\t}\n    }\n\n    cipherblk = ssh->cscipher ? ssh->cscipher->blksize : 8;  \n    cipherblk = cipherblk < 8 ? 8 : cipherblk;\t\n    padding = 4;\n    unencrypted_prefix = (ssh->csmac && ssh->csmac_etm) ? 4 : 0;\n    if (pkt->length + padding < pkt->forcepad)\n\tpadding = pkt->forcepad - pkt->length;\n    padding +=\n\t(cipherblk - (pkt->length - unencrypted_prefix + padding) % cipherblk)\n        % cipherblk;\n    assert(padding <= 255);\n    maclen = ssh->csmac ? ssh->csmac->len : 0;\n    ssh2_pkt_ensure(pkt, pkt->length + padding + maclen);\n    pkt->data[4] = padding;\n    for (i = 0; i < padding; i++)\n\tpkt->data[pkt->length + i] = random_byte();\n    PUT_32BIT(pkt->data, pkt->length + padding - 4);\n\n    if (ssh->cscipher && (ssh->cscipher->flags & SSH_CIPHER_SEPARATE_LENGTH)) {\n        ssh->cscipher->encrypt_length(ssh->cs_cipher_ctx, pkt->data, 4,\n                                      ssh->v2_outgoing_sequence);\n    }\n\n    if (ssh->csmac && ssh->csmac_etm) {\n        if (ssh->cscipher)\n            ssh->cscipher->encrypt(ssh->cs_cipher_ctx,\n                                   pkt->data + 4, pkt->length + padding - 4);\n        ssh->csmac->generate(ssh->cs_mac_ctx, pkt->data,\n                             pkt->length + padding,\n                             ssh->v2_outgoing_sequence);\n    } else {\n        if (ssh->csmac)\n            ssh->csmac->generate(ssh->cs_mac_ctx, pkt->data,\n                                 pkt->length + padding,\n                                 ssh->v2_outgoing_sequence);\n        if (ssh->cscipher)\n            ssh->cscipher->encrypt(ssh->cs_cipher_ctx,\n                                   pkt->data, pkt->length + padding);\n    }\n\n    ssh->v2_outgoing_sequence++;       \n    pkt->encrypted_len = pkt->length + padding;\n\n    pkt->body = pkt->data;\n    return pkt->length + padding + maclen;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8440, "func": "static void pvscsi_realize(DeviceState *qdev, Error **errp)\n{\n    PVSCSIClass *pvs_c = PVSCSI_DEVICE_GET_CLASS(qdev);\n    PCIDevice *pci_dev = PCI_DEVICE(qdev);\n    PVSCSIState *s = PVSCSI(qdev);\n\n    if (!(s->compat_flags & PVSCSI_COMPAT_DISABLE_PCIE)) {\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n    }\n\n    pvs_c->parent_dc_realize(qdev, errp);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8707, "func": "url_escape (const char *s)\n{\n  return url_escape_1 (s, urlchr_unsafe, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187327, "func": "xsltCopyNamespaceList(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t              xmlNsPtr cur) {\n    xmlNsPtr ret = NULL, tmp;\n    xmlNsPtr p = NULL,q;\n\n    if (cur == NULL)\n\treturn(NULL);\n    if (cur->type != XML_NAMESPACE_DECL)\n\treturn(NULL);\n\n    if ((node != NULL) && (node->type != XML_ELEMENT_NODE))\n\tnode = NULL;\n\n    while (cur != NULL) {\n\tif (cur->type != XML_NAMESPACE_DECL)\n\t    break;\n\n\tif (node != NULL) {\n\t    if ((node->ns != NULL) &&\n\t\t(xmlStrEqual(node->ns->prefix, cur->prefix)) &&\n\t(xmlStrEqual(node->ns->href, cur->href))) {\n\t\tcur = cur->next;\n\t\tcontinue;\n\t    }\n\t    tmp = xmlSearchNs(node->doc, node, cur->prefix);\n\t    if ((tmp != NULL) && (xmlStrEqual(tmp->href, cur->href))) {\n\t\tcur = cur->next;\n\t\tcontinue;\n\t    }\n\t}\n#ifdef XSLT_REFACTORED\n\tq = xmlNewNs(node, cur->href, cur->prefix);\n\tif (p == NULL) {\n\t    ret = p = q;\n\t} else {\n\t    p->next = q;\n\t    p = q;\n\t}\n#else\n\tif (!xmlStrEqual(cur->href, XSLT_NAMESPACE)) {\n\t    const xmlChar *URI;\n \t    URI = (const xmlChar *) xmlHashLookup(ctxt->style->nsAliases,\n \t\t                                  cur->href);\n\t    if (URI == UNDEFINED_DEFAULT_NS)\n \t        continue;\n \t    if (URI != NULL) {\n \t\tq = xmlNewNs(node, URI, cur->prefix);\n \t    } else {\n\t\tq = xmlNewNs(node, cur->href, cur->prefix);\n\t    }\n\t    if (p == NULL) {\n\t\tret = p = q;\n\t    } else {\n\t\tp->next = q;\n\t\tp = q;\n\t    }\n\t}\n#endif\n\tcur = cur->next;\n    }\n    return(ret);\n}\n", "target": 1, "flaw_line_index": "44"}
{"idx": 8968, "func": "static inline void net_tx_pkt_sendv(struct NetTxPkt *pkt,\n    NetClientState *nc, const struct iovec *iov, int iov_cnt)\n{\n    if (pkt->is_loopback) {\n        nc->info->receive_iov(nc, iov, iov_cnt);\n    } else {\n        qemu_sendv_packet(nc, iov, iov_cnt);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187454, "func": "static int uhid_event(btif_hh_device_t *p_dev)\n{\n struct uhid_event ev;\n ssize_t ret;\n    memset(&ev, 0, sizeof(ev));\n if(!p_dev)\n {\n\n         APPL_TRACE_ERROR(\"%s: Device not found\",__FUNCTION__)\n         return -1;\n     }\n    ret = read(p_dev->fd, &ev, sizeof(ev));\n     if (ret == 0) {\n         APPL_TRACE_ERROR(\"%s: Read HUP on uhid-cdev %s\", __FUNCTION__,\n                                                  strerror(errno));\n return -EFAULT;\n } else if (ret < 0) {\n        APPL_TRACE_ERROR(\"%s: Cannot read uhid-cdev: %s\", __FUNCTION__,\n                                                strerror(errno));\n return -errno;\n } else if ((ev.type == UHID_OUTPUT) || (ev.type==UHID_OUTPUT_EV)) {\n if (ret < (ssize_t)sizeof(ev)) {\n            APPL_TRACE_ERROR(\"%s: Invalid size read from uhid-dev: %ld != %lu\",\n                         __FUNCTION__, ret, sizeof(ev.type));\n return -EFAULT;\n }\n }\n\n switch (ev.type) {\n case UHID_START:\n        APPL_TRACE_DEBUG(\"UHID_START from uhid-dev\\n\");\n        p_dev->ready_for_data = TRUE;\n break;\n case UHID_STOP:\n        APPL_TRACE_DEBUG(\"UHID_STOP from uhid-dev\\n\");\n        p_dev->ready_for_data = FALSE;\n break;\n case UHID_OPEN:\n        APPL_TRACE_DEBUG(\"UHID_OPEN from uhid-dev\\n\");\n break;\n case UHID_CLOSE:\n        APPL_TRACE_DEBUG(\"UHID_CLOSE from uhid-dev\\n\");\n        p_dev->ready_for_data = FALSE;\n break;\n case UHID_OUTPUT:\n if (ret < (ssize_t)(sizeof(ev.type) + sizeof(ev.u.output))) {\n            APPL_TRACE_ERROR(\"%s: Invalid size read from uhid-dev: %zd < %zu\",\n                             __FUNCTION__, ret,\n sizeof(ev.type) + sizeof(ev.u.output));\n return -EFAULT;\n }\n\n        APPL_TRACE_DEBUG(\"UHID_OUTPUT: Report type = %d, report_size = %d\"\n ,ev.u.output.rtype, ev.u.output.size);\n if(ev.u.output.rtype == UHID_FEATURE_REPORT)\n            btif_hh_setreport(p_dev, BTHH_FEATURE_REPORT,\n                              ev.u.output.size, ev.u.output.data);\n else if(ev.u.output.rtype == UHID_OUTPUT_REPORT)\n            btif_hh_setreport(p_dev, BTHH_OUTPUT_REPORT,\n                              ev.u.output.size, ev.u.output.data);\n else\n            btif_hh_setreport(p_dev, BTHH_INPUT_REPORT,\n                              ev.u.output.size, ev.u.output.data);\n break;\n case UHID_OUTPUT_EV:\n        APPL_TRACE_DEBUG(\"UHID_OUTPUT_EV from uhid-dev\\n\");\n break;\n case UHID_FEATURE:\n        APPL_TRACE_DEBUG(\"UHID_FEATURE from uhid-dev\\n\");\n break;\n case UHID_FEATURE_ANSWER:\n        APPL_TRACE_DEBUG(\"UHID_FEATURE_ANSWER from uhid-dev\\n\");\n break;\n\n default:\n        APPL_TRACE_DEBUG(\"Invalid event from uhid-dev: %u\\n\", ev.type);\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 188213, "func": "OMX_ERRORTYPE SoftAACEncoder2::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mBitRate = aacParams->nBitRate;\n            mNumChannels = aacParams->nChannels;\n            mSampleRate = aacParams->nSampleRate;\n if (aacParams->eAACProfile != OMX_AUDIO_AACObjectNull) {\n                mAACProfile = aacParams->eAACProfile;\n }\n\n if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 0;\n                mSBRRatio = 0;\n } else if ((aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 1;\n } else if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && (aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 2;\n } else {\n                mSBRMode = -1; \n                mSBRRatio = 0;\n }\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8982, "func": "static void vmxnet3_deactivate_device(VMXNET3State *s)\n{\n    if (s->device_active) {\n        VMW_CBPRN(\"Deactivating vmxnet3...\");\n        net_tx_pkt_reset(s->tx_pkt);\n        net_tx_pkt_uninit(s->tx_pkt);\n        net_rx_pkt_uninit(s->rx_pkt);\n        s->device_active = false;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188580, "func": "void fht4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht4x4_c(in, out, stride, tx_type);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187889, "func": "long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,\n                                  long long size_, char*& str) {\n   delete[] str;\n   str = NULL;\n \n  if (size_ >= LONG_MAX)  \n     return E_FILE_FORMAT_INVALID;\n \n  const long size = static_cast<long>(size_);\n \n  str = new (std::nothrow) char[size + 1];\n   if (str == NULL)\n    return -1;\n \n   unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n \n const long status = pReader->Read(pos, size, buf);\n\n if (status) {\n delete[] str;\n    str = NULL;\n\n\n     return status;\n   }\n \n  str[size] = '\\0';\n  return 0;  \n }\n", "target": 1, "flaw_line_index": "2,6,9,11,13,27,28"}
{"idx": 8467, "func": "void CSoundFile::CheckCPUUsage(UINT nCPU)\n{\n\tif (nCPU > 100) nCPU = 100;\n\tgnCPUUsage = nCPU;\n\tif (nCPU < 90)\n\t{\n\t\tm_dwSongFlags &= ~SONG_CPUVERYHIGH;\n\t} else\n\tif ((m_dwSongFlags & SONG_CPUVERYHIGH) && (nCPU >= 94))\n\t{\n\t\tUINT i=MAX_CHANNELS;\n\t\twhile (i >= 8)\n\t\t{\n\t\t\ti--;\n\t\t\tif (Chn[i].nLength)\n\t\t\t{\n\t\t\t\tChn[i].nLength = Chn[i].nPos = 0;\n\t\t\t\tnCPU -= 2;\n\t\t\t\tif (nCPU < 94) break;\n\t\t\t}\n\t\t}\n\t} else\n\tif (nCPU > 90)\n\t{\n\t\tm_dwSongFlags |= SONG_CPUVERYHIGH;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8851, "func": "static void vrend_destroy_surface(struct vrend_surface *surf)\n{\n   vrend_resource_reference(&surf->texture, NULL);\n   free(surf);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8889, "func": "void vrend_renderer_attach_res_ctx(int ctx_id, int resource_id)\n{\n   struct vrend_context *ctx = vrend_lookup_renderer_ctx(ctx_id);\n   struct vrend_resource *res;\n\n   if (!ctx)\n      return;\n\n   res = vrend_resource_lookup(resource_id, 0);\n   if (!res)\n      return;\n\n   vrend_object_insert_nofree(ctx->res_hash, res, sizeof(*res), resource_id, 1, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187779, "func": " static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)\n {\n    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));\n \n     if (p_buf) {\n         UINT8* pbuf_data;\n\n        p_buf->len = len;\n        p_buf->offset = BTA_HH_MIN_OFFSET;\n\n        pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset;\n        memcpy(pbuf_data, data, len);\n }\n return p_buf;\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187729, "func": "store_pool_delete(png_store *ps, store_pool *pool)\n{\n if (pool->list != NULL)\n {\n      fprintf(stderr, \"%s: %s %s: memory lost (list follows):\\n\", ps->test,\n         pool == &ps->read_memory_pool ? \"read\" : \"write\",\n         pool == &ps->read_memory_pool ? (ps->current != NULL ?\n            ps->current->name : \"unknown file\") : ps->wname);\n ++ps->nerrors;\n\n do\n {\n         store_memory *next = pool->list;\n         pool->list = next->next;\n\n          next->next = NULL;\n \n          fprintf(stderr, \"\\t%lu bytes @ %p\\n\",\n             (unsigned long)next->size, (PNG_CONST void*)(next+1));\n         store_memory_free(NULL, pool, next);\n }\n while (pool->list != NULL);\n }\n\n if (pool->max > pool->max_max) pool->max_max = pool->max;\n   pool->max = 0;\n if (pool->current != 0) \n      fprintf(stderr, \"%s: %s %s: memory counter mismatch (internal error)\\n\",\n         ps->test, pool == &ps->read_memory_pool ? \"read\" : \"write\",\n         pool == &ps->read_memory_pool ? (ps->current != NULL ?\n            ps->current->name : \"unknown file\") : ps->wname);\n   pool->current = 0;\n\n if (pool->limit > pool->max_limit)\n      pool->max_limit = pool->limit;\n\n   pool->limit = 0;\n\n if (pool->total > pool->max_total)\n      pool->max_total = pool->total;\n\n   pool->total = 0;\n\n   store_pool_mark(pool->mark);\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 8963, "func": "static bool net_tx_pkt_parse_headers(struct NetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[NET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        l3_hdr->iov_len = 0;\n        pkt->packet_type = ETH_PKT_UCAST;\n        return false;\n    } else {\n        l2_hdr->iov_len = ETH_MAX_L2_HDR_LEN;\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n        pkt->packet_type = get_eth_packet_type(l2_hdr->iov_base);\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr, 1, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n\n        if (l3_hdr->iov_len < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        if (IP_HDR_GET_LEN(l3_hdr->iov_base) != sizeof(struct ip_header)) {\n            bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                    l2_hdr->iov_len + sizeof(struct ip_header),\n                                    l3_hdr->iov_base + sizeof(struct ip_header),\n                                    l3_hdr->iov_len - sizeof(struct ip_header));\n            if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n                l3_hdr->iov_len = 0;\n                return false;\n            }\n        }\n\n        break;\n\n    case ETH_P_IPV6:\n    {\n        eth_ip6_hdr_info hdrinfo;\n\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                &hdrinfo)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = hdrinfo.l4proto;\n        full_ip6hdr_len = hdrinfo.full_hdr_len;\n\n        if (full_ip6hdr_len > ETH_MAX_IP_DGRAM_LEN) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n    }\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n\n    net_tx_pkt_calculate_hdr_len(pkt);\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8728, "func": "static int check_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)\n{\n    int i;\n    int n = sk_OPENSSL_STRING_num(id->hosts);\n    char *name;\n\n    if (id->peername != NULL) {\n        OPENSSL_free(id->peername);\n        id->peername = NULL;\n    }\n    for (i = 0; i < n; ++i) {\n        name = sk_OPENSSL_STRING_value(id->hosts, i);\n        if (X509_check_host(x, name, 0, id->hostflags, &id->peername) > 0)\n            return 1;\n    }\n    return n == 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8953, "func": "static void net_tx_pkt_calculate_hdr_len(struct NetTxPkt *pkt)\n{\n    pkt->hdr_len = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len +\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187453, "func": "static void *btif_hh_poll_event_thread(void *arg)\n{\n btif_hh_device_t *p_dev = arg;\n    APPL_TRACE_DEBUG(\"%s: Thread created fd = %d\", __FUNCTION__, p_dev->fd);\n struct pollfd pfds[1];\n int ret;\n\n    pfds[0].fd = p_dev->fd;\n    pfds[0].events = POLLIN;\n\n\n     uhid_set_non_blocking(p_dev->fd);\n \n     while(p_dev->hh_keep_polling){\n        ret = poll(pfds, 1, 50);\n         if (ret < 0) {\n             APPL_TRACE_ERROR(\"%s: Cannot poll for fds: %s\\n\", __FUNCTION__, strerror(errno));\n             break;\n }\n if (pfds[0].revents & POLLIN) {\n            APPL_TRACE_DEBUG(\"btif_hh_poll_event_thread: POLLIN\");\n            ret = uhid_event(p_dev);\n if (ret){\n break;\n }\n }\n }\n\n    p_dev->hh_poll_thread_id = -1;\n return 0;\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 187721, "func": "standard_info_part2(standard_display *dp, png_const_structp pp,\n\n     png_const_infop pi, int nImages)\n {\n   dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),\n      png_get_bit_depth(pp, pi));\n    dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;\n    dp->cbRow = png_get_rowbytes(pp, pi);\n \n if (dp->cbRow != (dp->bit_width+7)/8)\n      png_error(pp, \"bad png_get_rowbytes calculation\");\n\n   store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);\n}\n", "target": 1, "flaw_line_index": "5,6"}
{"idx": 8913, "func": "void vrend_renderer_resource_copy_region(struct vrend_context *ctx,\n                                         uint32_t dst_handle, uint32_t dst_level,\n                                         uint32_t dstx, uint32_t dsty, uint32_t dstz,\n                                         uint32_t src_handle, uint32_t src_level,\n                                         const struct pipe_box *src_box)\n{\n   struct vrend_resource *src_res, *dst_res;\n   GLbitfield glmask = 0;\n   GLint sy1, sy2, dy1, dy2;\n\n   if (ctx->in_error)\n      return;\n\n   src_res = vrend_renderer_ctx_res_lookup(ctx, src_handle);\n   dst_res = vrend_renderer_ctx_res_lookup(ctx, dst_handle);\n\n   if (!src_res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, src_handle);\n      return;\n   }\n   if (!dst_res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, dst_handle);\n      return;\n   }\n\n   if (src_res->base.target == PIPE_BUFFER && dst_res->base.target == PIPE_BUFFER) {\n      vrend_resource_buffer_copy(ctx, src_res, dst_res, dstx,\n                                 src_box->x, src_box->width);\n      return;\n   }\n\n   if (!vrend_format_can_render(src_res->base.format) ||\n       !vrend_format_can_render(dst_res->base.format)) {\n      vrend_resource_copy_fallback(ctx, src_res, dst_res, dst_level, dstx,\n                                   dsty, dstz, src_level, src_box);\n\n      return;\n   }\n\n   glBindFramebuffer(GL_FRAMEBUFFER_EXT, ctx->sub->blit_fb_ids[0]);\n   glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_STENCIL_ATTACHMENT,\n                             GL_TEXTURE_2D, 0, 0);\n   vrend_fb_bind_texture(src_res, 0, src_level, src_box->z);\n\n   glBindFramebuffer(GL_FRAMEBUFFER_EXT, ctx->sub->blit_fb_ids[1]);\n   glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_STENCIL_ATTACHMENT,\n                             GL_TEXTURE_2D, 0, 0);\n   vrend_fb_bind_texture(dst_res, 0, dst_level, dstz);\n   glBindFramebuffer(GL_DRAW_FRAMEBUFFER, ctx->sub->blit_fb_ids[1]);\n\n   glBindFramebuffer(GL_READ_FRAMEBUFFER, ctx->sub->blit_fb_ids[0]);\n\n   glmask = GL_COLOR_BUFFER_BIT;\n   glDisable(GL_SCISSOR_TEST);\n\n   if (!src_res->y_0_top) {\n      sy1 = src_box->y;\n      sy2 = src_box->y + src_box->height;\n   } else {\n      sy1 = src_res->base.height0 - src_box->y - src_box->height;\n      sy2 = src_res->base.height0 - src_box->y;\n   }\n\n   if (!dst_res->y_0_top) {\n      dy1 = dsty;\n      dy2 = dsty + src_box->height;\n   } else {\n      dy1 = dst_res->base.height0 - dsty - src_box->height;\n      dy2 = dst_res->base.height0 - dsty;\n   }\n\n   glBlitFramebuffer(src_box->x, sy1,\n                     src_box->x + src_box->width,\n                     sy2,\n                     dstx, dy1,\n                     dstx + src_box->width,\n                     dy2,\n                     glmask, GL_NEAREST);\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187856, "func": " long long EBMLHeader::Parse(IMkvReader* pReader, long long& pos) {\n  assert(pReader);\n \n   long long total, available;\n \n long status = pReader->Length(&total, &available);\n\n if (status < 0) \n return status;\n\n  pos = 0;\n long long end = (available >= 1024) ? 1024 : available;\n\n for (;;) {\n unsigned char b = 0;\n\n while (pos < end) {\n      status = pReader->Read(pos, 1, &b);\n\n if (status < 0) \n return status;\n\n if (b == 0x1A)\n break;\n\n ++pos;\n }\n\n if (b != 0x1A) {\n if (pos >= 1024)\n return E_FILE_FORMAT_INVALID; \n\n if ((total >= 0) && ((total - available) < 5))\n return E_FILE_FORMAT_INVALID;\n\n return available + 5; \n }\n\n if ((total >= 0) && ((total - pos) < 5))\n return E_FILE_FORMAT_INVALID;\n\n if ((available - pos) < 5)\n return pos + 5; \n\n long len;\n\n const long long result = ReadUInt(pReader, pos, len);\n\n if (result < 0) \n return result;\n\n if (result == 0x0A45DFA3) { \n      pos += len; \n break;\n }\n\n ++pos; \n }\n\n\n\n long len;\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return result;\n\n\n   if (result > 0)  \n     return result;\n \n  assert(len > 0);\n  assert(len <= 8);\n \n   if ((total >= 0) && ((total - pos) < len))\n     return E_FILE_FORMAT_INVALID;\n\n if ((available - pos) < len)\n return pos + len; \n\n\n  result = ReadUInt(pReader, pos, len);\n\n if (result < 0) \n return result;\n\n  pos += len; \n\n\n if ((total >= 0) && ((total - pos) < result))\n return E_FILE_FORMAT_INVALID;\n\n if ((available - pos) < result)\n return pos + result;\n\n  end = pos + result;\n\n Init();\n\n while (pos < end) {\n long long id, size;\n\n    status = ParseElementHeader(pReader, pos, end, id, size);\n\n if (status < 0) \n return status;\n\n if (size == 0) \n return E_FILE_FORMAT_INVALID;\n\n if (id == 0x0286) { \n      m_version = UnserializeUInt(pReader, pos, size);\n\n if (m_version <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x02F7) { \n      m_readVersion = UnserializeUInt(pReader, pos, size);\n\n if (m_readVersion <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x02F2) { \n      m_maxIdLength = UnserializeUInt(pReader, pos, size);\n\n if (m_maxIdLength <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x02F3) { \n      m_maxSizeLength = UnserializeUInt(pReader, pos, size);\n\n if (m_maxSizeLength <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x0282) { \n if (m_docType)\n return E_FILE_FORMAT_INVALID;\n\n      status = UnserializeString(pReader, pos, size, m_docType);\n\n if (status) \n return status;\n } else if (id == 0x0287) { \n      m_docTypeVersion = UnserializeUInt(pReader, pos, size);\n\n if (m_docTypeVersion <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x0285) { \n      m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);\n\n if (m_docTypeReadVersion <= 0)\n return E_FILE_FORMAT_INVALID;\n }\n\n\n     pos += size;\n   }\n \n  assert(pos == end);\n   return 0;\n }\n", "target": 1, "flaw_line_index": "2,74,75"}
{"idx": 8949, "func": "void vrend_set_framebuffer_state(struct vrend_context *ctx,\n                                 uint32_t nr_cbufs, uint32_t surf_handle[8],\n                                 uint32_t zsurf_handle)\n{\n   struct vrend_surface *surf, *zsurf;\n   int i;\n   int old_num;\n   GLenum status;\n   GLint new_height = -1;\n   bool new_ibf = false;\n\n   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);\n\n   if (zsurf_handle) {\n      zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);\n      if (!zsurf) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);\n         return;\n      }\n   } else\n      zsurf = NULL;\n\n   if (ctx->sub->zsurf != zsurf) {\n      vrend_surface_reference(&ctx->sub->zsurf, zsurf);\n      vrend_hw_set_zsurf_texture(ctx);\n   }\n\n   old_num = ctx->sub->nr_cbufs;\n   ctx->sub->nr_cbufs = nr_cbufs;\n   ctx->sub->old_nr_cbufs = old_num;\n\n   for (i = 0; i < nr_cbufs; i++) {\n      if (surf_handle[i] != 0) {\n         surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);\n         if (!surf) {\n            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);\n            return;\n         }\n      } else\n         surf = NULL;\n\n      if (ctx->sub->surf[i] != surf) {\n         vrend_surface_reference(&ctx->sub->surf[i], surf);\n         vrend_hw_set_color_surface(ctx, i);\n      }\n   }\n\n   if (old_num > ctx->sub->nr_cbufs) {\n      for (i = ctx->sub->nr_cbufs; i < old_num; i++) {\n         vrend_surface_reference(&ctx->sub->surf[i], NULL);\n         vrend_hw_set_color_surface(ctx, i);\n      }\n   }\n\n   if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {\n      new_height = 0;\n      new_ibf = false;\n   } else if (ctx->sub->nr_cbufs == 0) {\n      new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);\n      new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;\n   }\n   else {\n      surf = NULL;\n      for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n         if (ctx->sub->surf[i]) {\n            surf = ctx->sub->surf[i];\n            break;\n         }\n      }\n      if (surf == NULL) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);\n         return;\n      }\n      new_height = u_minify(surf->texture->base.height0, surf->val0);\n      new_ibf = surf->texture->y_0_top ? true : false;\n   }\n\n   if (new_height != -1) {\n      if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {\n         ctx->sub->fb_height = new_height;\n         ctx->sub->inverted_fbo_content = new_ibf;\n         ctx->sub->scissor_state_dirty = (1 << 0);\n         ctx->sub->viewport_state_dirty = (1 << 0);\n      }\n   }\n\n   vrend_hw_emit_framebuffer_state(ctx);\n\n   if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {\n      status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n      if (status != GL_FRAMEBUFFER_COMPLETE)\n         fprintf(stderr,\"failed to complete framebuffer 0x%x %s\\n\", status, ctx->debug_name);\n   }\n   ctx->sub->shader_dirty = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187710, "func": "row_copy(png_bytep toBuffer, png_const_bytep fromBuffer, unsigned int bitWidth)\n {\n    memcpy(toBuffer, fromBuffer, bitWidth >> 3);\n \n if ((bitWidth & 7) != 0)\n {\n unsigned int mask;\n\n \n       toBuffer += bitWidth >> 3;\n       fromBuffer += bitWidth >> 3;\n      mask = 0xff >> (bitWidth & 7);\n       *toBuffer = (png_byte)((*toBuffer & mask) | (*fromBuffer & ~mask));\n    }\n }\n", "target": 1, "flaw_line_index": "11,11,12"}
{"idx": 9168, "func": "static void get_texcoords(struct vrend_resource *src_res,\n                          int src_level,\n                          int x1, int y1, int x2, int y2,\n                          float out[4])\n{\n   bool normalized = src_res->base.target != PIPE_TEXTURE_RECT &&\n      src_res->base.nr_samples <= 1;\n\n   if (normalized) {\n      out[0] = x1 / (float)u_minify(src_res->base.width0,  src_level);\n      out[1] = y1 / (float)u_minify(src_res->base.height0, src_level);\n      out[2] = x2 / (float)u_minify(src_res->base.width0,  src_level);\n      out[3] = y2 / (float)u_minify(src_res->base.height0, src_level);\n   } else {\n      out[0] = (float) x1;\n      out[1] = (float) y1;\n      out[2] = (float) x2;\n      out[3] = (float) y2;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8866, "func": "bool vrend_format_is_emulated_alpha(enum virgl_formats format)\n{\n   if (!vrend_state.use_core_profile)\n      return false;\n   return (format == VIRGL_FORMAT_A8_UNORM ||\n           format == VIRGL_FORMAT_A16_UNORM);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188622, "func": "   virtual void TearDown() {\n    vp9_worker_end(&worker_);\n   }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187576, "func": "bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,\n                                           LINK_KEY link_key,\n uint8_t key_type,\n uint8_t pin_length)\n{\n bdstr_t bdstr;\n    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));\n\n     int ret = btif_config_set_int(bdstr, \"LinkKeyType\", (int)key_type);\n     ret &= btif_config_set_int(bdstr, \"PinLength\", (int)pin_length);\n     ret &= btif_config_set_bin(bdstr, \"LinkKey\", link_key, sizeof(LINK_KEY));\n     btif_config_flush();\n     return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8613, "func": "static void vmsvga_index_write(void *opaque, uint32_t address, uint32_t index)\n{\n    struct vmsvga_state_s *s = opaque;\n\n    s->index = index;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9108, "func": "static int vrend_decode_end_query(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t handle = get_buf_entry(ctx, VIRGL_QUERY_END_HANDLE);\n\n   vrend_end_query(ctx->grctx, handle);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187708, "func": " progressive_row(png_structp ppIn, png_bytep new_row, png_uint_32 y, int pass)\n {\n    png_const_structp pp = ppIn;\n   PNG_CONST standard_display *dp = voidcast(standard_display*,\n       png_get_progressive_ptr(pp));\n \n if (new_row != NULL)\n {\n      png_bytep row;\n\n if (dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7)\n {\n#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED\n if (y != png_get_current_row_number(pp))\n            png_error(pp, \"png_get_current_row_number is broken\");\n\n \n          if (pass != png_get_current_pass_number(pp))\n             png_error(pp, \"png_get_current_pass_number is broken\");\n#endif\n \n          y = PNG_ROW_FROM_PASS_ROW(y, pass);\n       }\n\n if (y >= dp->h)\n         png_error(pp, \"invalid y to progressive row callback\");\n\n \n       row = store_image_row(dp->ps, pp, 0, y);\n \n#ifdef PNG_READ_INTERLACING_SUPPORTED\n       if (dp->do_interlace)\n       {\n          if (dp->interlace_type == PNG_INTERLACE_ADAM7)\n            deinterlace_row(row, new_row, dp->pixel_size, dp->w, pass);\n          else\n            row_copy(row, new_row, dp->pixel_size * dp->w);\n       }\n       else\n          png_progressive_combine_row(pp, row, new_row);\n #endif \n    }\n \n#ifdef PNG_READ_INTERLACING_SUPPORTED\n    else if (dp->interlace_type == PNG_INTERLACE_ADAM7 &&\n        PNG_ROW_IN_INTERLACE_PASS(y, pass) &&\n        PNG_PASS_COLS(dp->w, pass) > 0)\n       png_error(pp, \"missing row in progressive de-interlacing\");\n#endif \n }\n", "target": 1, "flaw_line_index": "4,20,31,35,37,44,49"}
{"idx": 188542, "func": "   void RunCoeffCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j)\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n \n       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n }\n }\n", "target": 1, "flaw_line_index": "4,5,6,9,11,14"}
{"idx": 187466, "func": " static inline int btif_hl_select_wakeup(void){\n     char sig_on = btif_hl_signal_select_wakeup;\n     BTIF_TRACE_DEBUG(\"btif_hl_select_wakeup\");\n    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187888, "func": "long mkvparser::UnserializeInt(IMkvReader* pReader, long long pos, long size,\n                               long long& result) {\n  assert(pReader);\n  assert(pos >= 0);\n  assert(size > 0);\n  assert(size <= 8);\n \n  {\n    signed char b;\n \n    const long status = pReader->Read(pos, 1, (unsigned char*)&b);\n \n    if (status < 0)\n      return status;\n    result = b;\n    ++pos;\n  }\n \n   for (long i = 1; i < size; ++i) {\n     unsigned char b;\n\n const long status = pReader->Read(pos, 1, &b);\n\n if (status < 0)\n return status;\n\n    result <<= 8;\n    result |= b;\n\n\n     ++pos;\n   }\n \n  return 0;  \n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,8,9,11,13,14,15,16,17,34"}
{"idx": 187732, "func": "test_standard(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,\n    int bdlo, int PNG_CONST bdhi)\n {\n    for (; bdlo <= bdhi; ++bdlo)\n    {\n int interlace_type;\n\n for (interlace_type = PNG_INTERLACE_NONE;\n\n            interlace_type < INTERLACE_LAST; ++interlace_type)\n       {\n          standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0\n,\n            interlace_type, 0, 0, 0), 0\n, pm->use_update_info);\n \n          if (fail(pm))\n             return 0;\n }\n }\n\n return 1; \n}\n", "target": 1, "flaw_line_index": "2,15"}
{"idx": 9140, "func": "static boolean is_digit( const char *cur )\n{\n   return *cur >= '0' && *cur <= '9';\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187507, "func": "ssize_t socket_bytes_available(const socket_t *socket) {\n\n   assert(socket != NULL);\n \n   int size = 0;\n  if (ioctl(socket->fd, FIONREAD, &size) == -1)\n     return -1;\n   return size;\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 188220, "func": "OMX_ERRORTYPE SoftAVCEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *) params;\n \n             if (bitRate->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            bitRate->eControlRate = OMX_Video_ControlRateVariable;\n            bitRate->nTargetBitrate = mBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoAvc:\n {\n\n             OMX_VIDEO_PARAM_AVCTYPE *avcParams =\n                 (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            avcParams->eProfile = OMX_VIDEO_AVCProfileBaseline;\n            OMX_U32 omxLevel = AVC_LEVEL2;\n if (OMX_ErrorNone !=\n ConvertAvcSpecLevelToOmxAvcLevel(mAVCEncLevel, &omxLevel)) {\n return OMX_ErrorUndefined;\n }\n\n            avcParams->eLevel = (OMX_VIDEO_AVCLEVELTYPE) omxLevel;\n            avcParams->nRefFrames = 1;\n            avcParams->nBFrames = 0;\n            avcParams->bUseHadamard = OMX_TRUE;\n            avcParams->nAllowedPictureTypes =\n (OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP);\n            avcParams->nRefIdx10ActiveMinus1 = 0;\n            avcParams->nRefIdx11ActiveMinus1 = 0;\n            avcParams->bWeightedPPrediction = OMX_FALSE;\n            avcParams->bEntropyCodingCABAC = OMX_FALSE;\n            avcParams->bconstIpred = OMX_FALSE;\n            avcParams->bDirect8x8Inference = OMX_FALSE;\n            avcParams->bDirectSpatialTemporal = OMX_FALSE;\n            avcParams->nCabacInitIdc = 0;\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8910, "func": "uint32_t vrend_renderer_object_insert(struct vrend_context *ctx, void *data,\n                                      uint32_t size, uint32_t handle, enum virgl_object_type type)\n{\n   return vrend_object_insert(ctx->sub->object_hash, data, size, handle, type);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188623, "func": "void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n const EAS_SAMPLE *loopEnd;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n\n    loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n    phaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n#if defined(_8_BIT_SAMPLES)\n    samp1 = pSamples[0] << 8;\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n        phaseFrac += phaseInc;\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n if (acc0 > 0) {\n\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n            acc0 = (EAS_I32) (pSamples - loopEnd);\n if (acc0 >= 0)\n                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;\n\n#if defined(_8_BIT_SAMPLES)\n            samp1 = pSamples[0] << 8;\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8619, "func": "static void vmsvga_register_types(void)\n{\n    type_register_static(&vmsvga_info);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9028, "func": "static void vmxnet3_pci_uninit(PCIDevice *pci_dev)\n{\n    DeviceState *dev = DEVICE(pci_dev);\n    VMXNET3State *s = VMXNET3(pci_dev);\n\n    VMW_CBPRN(\"Starting uninit...\");\n\n    unregister_savevm(dev, \"vmxnet3-msix\", s);\n\n    vmxnet3_net_uninit(s);\n\n    vmxnet3_cleanup_msix(s);\n\n    vmxnet3_cleanup_msi(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8445, "func": "pvscsi_reset_state(PVSCSIState *s)\n{\n    s->curr_cmd = PVSCSI_CMD_FIRST;\n    s->curr_cmd_data_cntr = 0;\n    s->reg_command_status = PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n    s->reg_interrupt_status = 0;\n    pvscsi_ring_cleanup(&s->rings);\n    s->rings_info_valid = FALSE;\n    s->msg_ring_info_valid = FALSE;\n    QTAILQ_INIT(&s->pending_queue);\n    QTAILQ_INIT(&s->completion_queue);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187939, "func": "void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n const EAS_SAMPLE *loopEnd;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n \n     numSamples = pWTIntFrame->numSamples;\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n \n     loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n    phaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n#if defined(_8_BIT_SAMPLES)\n    samp1 = pSamples[0] << 8;\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n        phaseFrac += phaseInc;\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n if (acc0 > 0) {\n\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n            acc0 = (EAS_I32) (pSamples - loopEnd);\n if (acc0 >= 0)\n                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;\n\n#if defined(_8_BIT_SAMPLES)\n            samp1 = pSamples[0] << 8;\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8708, "func": "url_escape_1 (const char *s, unsigned char mask, bool allow_passthrough)\n{\n  const char *p1;\n  char *p2, *newstr;\n  int newlen;\n  int addition = 0;\n\n  for (p1 = s; *p1; p1++)\n    if (urlchr_test (*p1, mask))\n      addition += 2;            \n\n  if (!addition)\n    return allow_passthrough ? (char *)s : xstrdup (s);\n\n  newlen = (p1 - s) + addition;\n  newstr = xmalloc (newlen + 1);\n\n  p1 = s;\n  p2 = newstr;\n  while (*p1)\n    {\n      if (urlchr_test (*p1, mask))\n        {\n          unsigned char c = *p1++;\n          *p2++ = '%';\n          *p2++ = XNUM_TO_DIGIT (c >> 4);\n          *p2++ = XNUM_TO_DIGIT (c & 0xf);\n        }\n      else\n        *p2++ = *p1++;\n    }\n  assert (p2 - newstr == newlen);\n  *p2 = '\\0';\n\n  return newstr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8455, "func": "pvscsi_schedule_completion_processing(PVSCSIState *s)\n{\n    if (!QTAILQ_EMPTY(&s->completion_queue)) {\n        qemu_bh_schedule(s->completion_worker);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188620, "func": " string DecodeFile(const string& filename, int num_threads) {\n   libvpx_test::WebMVideoSource video(filename);\n   video.Init();\n \n  vpx_codec_dec_cfg_t cfg = {0};\n   cfg.threads = num_threads;\n   libvpx_test::VP9Decoder decoder(cfg, 0);\n \n  libvpx_test::MD5 md5;\n for (video.Begin(); video.cxdata(); video.Next()) {\n const vpx_codec_err_t res =\n        decoder.DecodeFrame(video.cxdata(), video.frame_size());\n if (res != VPX_CODEC_OK) {\n      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n break;\n }\n\n    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();\n const vpx_image_t *img = NULL;\n\n while ((img = dec_iter.Next())) {\n      md5.Add(img);\n }\n }\n\n   return string(md5.Get());\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 9226, "func": "static void virtio_queue_host_notifier_aio_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_aio_vq(vq);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188630, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice(dec_state_t *ps_dec)\n{\n    WORD16 *pi2_vld_out;\n    UWORD32 i;\n yuv_buf_t *ps_cur_frm_buf      = &ps_dec->s_cur_frm_buf;\n\n    UWORD32 u4_frm_offset          = 0;\n const dec_mb_params_t *ps_dec_mb_params;\n    IMPEG2D_ERROR_CODES_T e_error   = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    pi2_vld_out = ps_dec->ai2_vld_buf;\n    memset(ps_dec->ai2_pred_mv,0,sizeof(ps_dec->ai2_pred_mv));\n\n    ps_dec->u2_prev_intra_mb    = 0;\n    ps_dec->u2_first_mb       = 1;\n\n    ps_dec->u2_picture_width = ps_dec->u2_frame_width;\n\n if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n {\n        ps_dec->u2_picture_width <<= 1;\n if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n {\n            u4_frm_offset = ps_dec->u2_frame_width;\n }\n }\n\n\n     do\n     {\n         UWORD32 u4_x_offset, u4_y_offset;\n \n \n         UWORD32 u4_x_dst_offset = 0;\n        UWORD32 u4_y_dst_offset = 0;\n        UWORD8  *pu1_out_p;\n        UWORD8  *pu1_pred;\n        WORD32 u4_pred_strd;\n\n        IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n\n \n \n         if(ps_dec->e_pic_type == B_PIC)\n            impeg2d_dec_pnb_mb_params(ps_dec);\n         else\n            impeg2d_dec_p_mb_params(ps_dec);\n \n         IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n \n         u4_x_dst_offset = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        u4_y_dst_offset = (ps_dec->u2_mb_y << 4) * ps_dec->u2_picture_width;\n        pu1_out_p = ps_cur_frm_buf->pu1_y + u4_x_dst_offset + u4_y_dst_offset;\n if(ps_dec->u2_prev_intra_mb == 0)\n {\n            UWORD32 offset_x, offset_y, stride;\n            UWORD16 index = (ps_dec->u2_motion_type);\n if(ps_dec->e_mb_pred == BIDIRECT)\n {\n                ps_dec_mb_params = &ps_dec->ps_func_bi_direct[index];\n }\n else\n {\n                ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n }\n\n            stride = ps_dec->u2_picture_width;\n\n            offset_x = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n\n            offset_y = (ps_dec->u2_mb_y << 4);\n\n            ps_dec->s_dest_buf.pu1_y = ps_cur_frm_buf->pu1_y + offset_y * stride + offset_x;\n\n            stride = stride >> 1;\n\n            ps_dec->s_dest_buf.pu1_u = ps_cur_frm_buf->pu1_u + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            ps_dec->s_dest_buf.pu1_v = ps_cur_frm_buf->pu1_v + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            PROFILE_DISABLE_MC_IF0\n            ps_dec_mb_params->pf_mc(ps_dec);\n\n }\n for(i = 0; i < NUM_LUMA_BLKS; ++i)\n {\n if((ps_dec->u2_cbp & (1 << (BLOCKS_IN_MB - 1 - i))) != 0)\n {\n                e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                              ps_dec->u2_prev_intra_mb, Y_LUMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n                u4_x_offset = gai2_impeg2_blk_x_off[i];\n\n if(ps_dec->u2_field_dct == 0)\n                    u4_y_offset = gai2_impeg2_blk_y_off_frm[i] ;\n else\n                    u4_y_offset = gai2_impeg2_blk_y_off_fld[i] ;\n\n\n\n\n\n                IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n                PROFILE_DISABLE_IDCT_IF0\n {\n                    WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                        idx = 0;\n else\n                        idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                        pu1_pred = pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset;\n                        u4_pred_strd = ps_dec->u2_picture_width << ps_dec->u2_field_dct;\n }\n else\n {\n                        pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                        u4_pred_strd = 8;\n }\n\n                    ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                            ps_dec->ai2_idct_stg1,\n                                                            pu1_pred,\n                                                            pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset,\n 8,\n                                                            u4_pred_strd,\n                                                            ps_dec->u2_picture_width << ps_dec->u2_field_dct,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n }\n }\n\n }\n\n        u4_x_dst_offset >>= 1;\n        u4_y_dst_offset >>= 2;\n\n\n if((ps_dec->u2_cbp & 0x02) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_u + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, U_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n\n }\n\n\n if((ps_dec->u2_cbp & 0x01) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_v + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, V_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n }\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_first_mb = 0;\n        ps_dec->u2_mb_x++;\n\n if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n {\n return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n }\n else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n }\n }\n while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n return e_error;\n}\n", "target": 1, "flaw_line_index": "45,47"}
{"idx": 187497, "func": "static void *listen_fn_(UNUSED_ATTR void *context) {\n\n  prctl(PR_SET_NAME, (unsigned long)LISTEN_THREAD_NAME_, 0, 0, 0);\n\n  listen_socket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n if (listen_socket_ == -1) {\n    LOG_ERROR(\"%s socket creation failed: %s\", __func__, strerror(errno));\n goto cleanup;\n }\n\n int enable = 1;\n if (setsockopt(listen_socket_, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) == -1) {\n    LOG_ERROR(\"%s unable to set SO_REUSEADDR: %s\", __func__, strerror(errno));\n goto cleanup;\n }\n\n struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl(LOCALHOST_);\n  addr.sin_port = htons(LISTEN_PORT_);\n if (bind(listen_socket_, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    LOG_ERROR(\"%s unable to bind listen socket: %s\", __func__, strerror(errno));\n goto cleanup;\n }\n\n if (listen(listen_socket_, 10) == -1) {\n    LOG_ERROR(\"%s unable to listen: %s\", __func__, strerror(errno));\n goto cleanup;\n\n   }\n \n   for (;;) {\n    int client_socket = accept(listen_socket_, NULL, NULL);\n     if (client_socket == -1) {\n       if (errno == EINVAL || errno == EBADF) {\n         break;\n }\n      LOG_WARN(\"%s error accepting socket: %s\", __func__, strerror(errno));\n continue;\n }\n\n\n     pthread_mutex_lock(&client_socket_lock_);\n     safe_close_(&client_socket_);\n     client_socket_ = client_socket;\n    send(client_socket_, \"btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\", 16, 0);\n     pthread_mutex_unlock(&client_socket_lock_);\n   }\n \ncleanup:\n  safe_close_(&listen_socket_);\n return NULL;\n}\n", "target": 1, "flaw_line_index": "33,46"}
{"idx": 8363, "func": "static int mptsas_hard_reset(MPTSASState *s)\n{\n    mptsas_soft_reset(s);\n\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n\n    s->host_mfa_high_addr = 0;\n    s->sense_buffer_high_addr = 0;\n    s->reply_frame_size = 0;\n    s->max_devices = MPTSAS_NUM_PORTS;\n    s->max_buses = 1;\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8842, "func": "static void vrend_destroy_sampler_state_object(void *obj_ptr)\n{\n   struct vrend_sampler_state *state = obj_ptr;\n\n   glDeleteSamplers(1, &state->id);\n   FREE(state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188419, "func": "bool Cues::LoadCuePoint() const\n{\n    const long long stop = m_start + m_size;\n    if (m_pos >= stop)\n        return false;  \n    Init();\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    while (m_pos < stop)\n    {\n        const long long idpos = m_pos;\n        long len;\n        const long long id = ReadUInt(pReader, m_pos, len);\n        assert(id >= 0);  \n        assert((m_pos + len) <= stop);\n        m_pos += len;  \n        const long long size = ReadUInt(pReader, m_pos, len);\n        assert(size >= 0);\n        assert((m_pos + len) <= stop);\n        m_pos += len;  \n        assert((m_pos + size) <= stop);\n        if (id != 0x3B)  \n        {\n            m_pos += size;  \n            assert(m_pos <= stop);\n            continue;\n        }\n        assert(m_preload_count > 0);\n        CuePoint* const pCP = m_cue_points[m_count];\n        assert(pCP);\n        assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));\n        if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))\n            return false;\n        pCP->Load(pReader);\n        ++m_count;\n        --m_preload_count;\n        m_pos += size;  \n        assert(m_pos <= stop);\n        return true;  \n    }\n    return false;  \n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42"}
{"idx": 8509, "func": "static void c_write_untrusted(Ssh ssh, const char *buf, int len)\n{\n    if (flags & FLAG_STDERR)\n\tc_write_stderr(0, buf, len);\n    else\n\tfrom_backend_untrusted(ssh->frontend, buf, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188424, "func": "long Chapters::Atom::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  \n            return status;\n        if (size == 0)  \n            continue;\n        if (id == 0x00)  \n        {\n            status = ParseDisplay(pReader, pos, size);\n            if (status < 0)  \n                return status;\n        }\n        else if (id == 0x1654)  \n        {\n            status = UnserializeString(pReader, pos, size, m_string_uid);\n            if (status < 0)  \n                return status;\n        }\n        else if (id == 0x33C4)  \n        {\n            long long val;\n            status = UnserializeInt(pReader, pos, size, val);\n            if (status < 0)  \n                return status;\n            m_uid = val;\n        }\n        else if (id == 0x11)  \n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  \n                return static_cast<long>(val);\n            m_start_timecode = val;\n        }\n        else if (id == 0x12)  \n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  \n                return static_cast<long>(val);\n            m_stop_timecode = val;\n        }\n        pos += size;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59"}
{"idx": 8337, "func": "static int xhci_ep_nuke_xfers(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid, TRBCCode report)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i, xferi, killed = 0;\n    USBEndpoint *ep = NULL;\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    DPRINTF(\"xhci_ep_nuke_xfers(%d, %d)\\n\", slotid, epid);\n\n    slot = &xhci->slots[slotid-1];\n\n    if (!slot->eps[epid-1]) {\n        return 0;\n    }\n\n    epctx = slot->eps[epid-1];\n\n    xferi = epctx->next_xfer;\n    for (i = 0; i < TD_QUEUE; i++) {\n        killed += xhci_ep_nuke_one_xfer(&epctx->transfers[xferi], report);\n        if (killed) {\n            report = 0; \n        }\n        epctx->transfers[xferi].packet.ep = NULL;\n        xferi = (xferi + 1) % TD_QUEUE;\n    }\n\n    ep = xhci_epid_to_usbep(xhci, slotid, epid);\n    if (ep) {\n        usb_device_ep_stopped(ep->dev, ep);\n    }\n    return killed;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188499, "func": "void usage_exit() {\n   fprintf(stderr, \"Usage: %s <infile> <outfile> <N-M|N/M>\\n\", exec_name);\n   exit(EXIT_FAILURE);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188216, "func": "OMX_ERRORTYPE SoftAMRNBEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAMR;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->nBitRate = mBitRate;\n            amrParams->eAMRBandMode = (OMX_AUDIO_AMRBANDMODETYPE)(mMode + 1);\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelCF;\n\n            pcmParams->nChannels = 1;\n            pcmParams->nSamplingRate = kSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8938, "func": "void vrend_set_polygon_stipple(struct vrend_context *ctx,\n                               struct pipe_poly_stipple *ps)\n{\n   if (vrend_state.use_core_profile) {\n      static const unsigned bit31 = 1 << 31;\n      GLubyte *stip = calloc(1, 1024);\n      int i, j;\n\n      if (!ctx->pstip_inited)\n         vrend_init_pstipple_texture(ctx);\n\n      if (!stip)\n         return;\n\n      for (i = 0; i < 32; i++) {\n         for (j = 0; j < 32; j++) {\n            if (ps->stipple[i] & (bit31 >> j))\n               stip[i * 32 + j] = 0;\n            else\n               stip[i * 32 + j] = 255;\n         }\n      }\n\n      glBindTexture(GL_TEXTURE_2D, ctx->pstipple_tex_id);\n      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 32, 32,\n                      GL_RED, GL_UNSIGNED_BYTE, stip);\n\n      free(stip);\n      return;\n   }\n   glPolygonStipple((const GLubyte *)ps->stipple);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8368, "func": "static void mptsas_mmio_write(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    MPTSASState *s = opaque;\n\n    trace_mptsas_mmio_write(s, addr, val);\n    switch (addr) {\n    case MPI_DOORBELL_OFFSET:\n        mptsas_doorbell_write(s, val);\n        break;\n\n    case MPI_WRITE_SEQUENCE_OFFSET:\n        mptsas_write_sequence_write(s, val);\n        break;\n\n    case MPI_DIAGNOSTIC_OFFSET:\n        if (val & MPI_DIAG_RESET_ADAPTER) {\n            mptsas_hard_reset(s);\n        }\n        break;\n\n    case MPI_HOST_INTERRUPT_STATUS_OFFSET:\n        mptsas_interrupt_status_write(s);\n        break;\n\n    case MPI_HOST_INTERRUPT_MASK_OFFSET:\n        s->intr_mask = val & (MPI_HIM_RIM | MPI_HIM_DIM);\n        mptsas_update_interrupt(s);\n        break;\n\n    case MPI_REQUEST_POST_FIFO_OFFSET:\n        if (MPTSAS_FIFO_FULL(s, request_post)) {\n            mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);\n        } else {\n            MPTSAS_FIFO_PUT(s, request_post, val & ~0x03);\n            qemu_bh_schedule(s->request_bh);\n        }\n        break;\n\n    case MPI_REPLY_FREE_FIFO_OFFSET:\n        if (MPTSAS_FIFO_FULL(s, reply_free)) {\n            mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);\n        } else {\n            MPTSAS_FIFO_PUT(s, reply_free, val);\n        }\n        break;\n\n    default:\n        trace_mptsas_mmio_unhandled_write(s, addr, val);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9036, "func": "static void vmxnet3_put_rx_stats_to_file(QEMUFile *f,\n    struct UPT1_RxStats *rx_stat)\n{\n    qemu_put_be64(f, rx_stat->LROPktsRxOK);\n    qemu_put_be64(f, rx_stat->LROBytesRxOK);\n    qemu_put_be64(f, rx_stat->ucastPktsRxOK);\n    qemu_put_be64(f, rx_stat->ucastBytesRxOK);\n    qemu_put_be64(f, rx_stat->mcastPktsRxOK);\n    qemu_put_be64(f, rx_stat->mcastBytesRxOK);\n    qemu_put_be64(f, rx_stat->bcastPktsRxOK);\n    qemu_put_be64(f, rx_stat->bcastBytesRxOK);\n    qemu_put_be64(f, rx_stat->pktsRxOutOfBuf);\n    qemu_put_be64(f, rx_stat->pktsRxError);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187822, "func": "status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {\n    ALOGV(\"configureCodec protected=%d\",\n (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);\n\n if (!(mFlags & kIgnoreCodecSpecificData)) {\n uint32_t type;\n const void *data;\n size_t size;\n if (meta->findData(kKeyESDS, &type, &data, &size)) {\n            ESDS esds((const char *)data, size);\n            CHECK_EQ(esds.InitCheck(), (status_t)OK);\n\n const void *codec_specific_data;\n size_t codec_specific_data_size;\n            esds.getCodecSpecificInfo(\n &codec_specific_data, &codec_specific_data_size);\n\n            addCodecSpecificData(\n                    codec_specific_data, codec_specific_data_size);\n } else if (meta->findData(kKeyAVCC, &type, &data, &size)) {\n\n unsigned profile, level;\n status_t err;\n if ((err = parseAVCCodecSpecificData(\n                            data, size, &profile, &level)) != OK) {\n                ALOGE(\"Malformed AVC codec specific data.\");\n return err;\n }\n\n            CODEC_LOGI(\n \"AVC profile = %u (%s), level = %u\",\n                    profile, AVCProfileToString(profile), level);\n } else if (meta->findData(kKeyHVCC, &type, &data, &size)) {\n\n unsigned profile, level;\n status_t err;\n if ((err = parseHEVCCodecSpecificData(\n                            data, size, &profile, &level)) != OK) {\n                ALOGE(\"Malformed HEVC codec specific data.\");\n return err;\n }\n\n            CODEC_LOGI(\n \"HEVC profile = %u , level = %u\",\n                    profile, level);\n } else if (meta->findData(kKeyVorbisInfo, &type, &data, &size)) {\n            addCodecSpecificData(data, size);\n\n            CHECK(meta->findData(kKeyVorbisBooks, &type, &data, &size));\n            addCodecSpecificData(data, size);\n } else if (meta->findData(kKeyOpusHeader, &type, &data, &size)) {\n            addCodecSpecificData(data, size);\n\n            CHECK(meta->findData(kKeyOpusCodecDelay, &type, &data, &size));\n            addCodecSpecificData(data, size);\n            CHECK(meta->findData(kKeyOpusSeekPreRoll, &type, &data, &size));\n            addCodecSpecificData(data, size);\n }\n }\n\n int32_t bitRate = 0;\n if (mIsEncoder) {\n        CHECK(meta->findInt32(kKeyBitRate, &bitRate));\n }\n if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB, mMIME)) {\n        setAMRFormat(false \n, bitRate);\n } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB, mMIME)) {\n        setAMRFormat(true \n, bitRate);\n } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AAC, mMIME)) {\n int32_t numChannels, sampleRate, aacProfile;\n        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));\n        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));\n\n if (!meta->findInt32(kKeyAACProfile, &aacProfile)) {\n            aacProfile = OMX_AUDIO_AACObjectNull;\n }\n\n int32_t isADTS;\n if (!meta->findInt32(kKeyIsADTS, &isADTS)) {\n            isADTS = false;\n }\n\n status_t err = setAACFormat(numChannels, sampleRate, bitRate, aacProfile, isADTS);\n if (err != OK) {\n            CODEC_LOGE(\"setAACFormat() failed (err = %d)\", err);\n return err;\n }\n } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG, mMIME)) {\n int32_t numChannels, sampleRate;\n if (meta->findInt32(kKeyChannelCount, &numChannels)\n && meta->findInt32(kKeySampleRate, &sampleRate)) {\n            setRawAudioFormat(\n                    mIsEncoder ? kPortIndexInput : kPortIndexOutput,\n                    sampleRate,\n                    numChannels);\n }\n } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AC3, mMIME)) {\n int32_t numChannels;\n int32_t sampleRate;\n        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));\n        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));\n\n status_t err = setAC3Format(numChannels, sampleRate);\n if (err != OK) {\n            CODEC_LOGE(\"setAC3Format() failed (err = %d)\", err);\n return err;\n }\n } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_G711_ALAW, mMIME)\n || !strcasecmp(MEDIA_MIMETYPE_AUDIO_G711_MLAW, mMIME)) {\n\n int32_t sampleRate;\n int32_t numChannels;\n        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));\n if (!meta->findInt32(kKeySampleRate, &sampleRate)) {\n            sampleRate = 8000;\n }\n\n        setG711Format(sampleRate, numChannels);\n } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_RAW, mMIME)) {\n        CHECK(!mIsEncoder);\n\n int32_t numChannels, sampleRate;\n        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));\n        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));\n\n        setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);\n }\n\n if (!strncasecmp(mMIME, \"video/\", 6)) {\n\n if (mIsEncoder) {\n            setVideoInputFormat(mMIME, meta);\n } else {\n status_t err = setVideoOutputFormat(\n                    mMIME, meta);\n\n if (err != OK) {\n return err;\n }\n }\n }\n\n int32_t maxInputSize;\n if (meta->findInt32(kKeyMaxInputSize, &maxInputSize)) {\n        setMinBufferSize(kPortIndexInput, (OMX_U32)maxInputSize);\n }\n\n \n     initOutputFormat(meta);\n \n    if ((mFlags & kClientNeedsFramebuffer)\n            && !strncmp(mComponentName, \"OMX.SEC.\", 8)) {\n        OMX_INDEXTYPE index;\n        status_t err =\n            mOMX->getExtensionIndex(\n                    mNode,\n                    \"OMX.SEC.index.ThumbnailMode\",\n                    &index);\n        if (err != OK) {\n            return err;\n        }\n        OMX_BOOL enable = OMX_TRUE;\n        err = mOMX->setConfig(mNode, index, &enable, sizeof(enable));\n        if (err != OK) {\n            CODEC_LOGE(\"setConfig('OMX.SEC.index.ThumbnailMode') \"\n                       \"returned error 0x%08x\", err);\n            return err;\n        }\n        mQuirks &= ~kOutputBuffersAreUnreadable;\n    }\n     if (mNativeWindow != NULL\n         && !mIsEncoder\n         && !strncasecmp(mMIME, \"video/\", 6)\n && !strncmp(mComponentName, \"OMX.\", 4)) {\n status_t err = initNativeWindow();\n if (err != OK) {\n return err;\n }\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179"}
{"idx": 187352, "func": "xsltShallowCopyElem(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t\t    xmlNodePtr insert, int isLRE)\n{\n    xmlNodePtr copy;\n\n    if ((node->type == XML_DTD_NODE) || (insert == NULL))\n\treturn(NULL);\n    if ((node->type == XML_TEXT_NODE) ||\n\t(node->type == XML_CDATA_SECTION_NODE))\n\treturn(xsltCopyText(ctxt, insert, node, 0));\n\n    copy = xmlDocCopyNode(node, insert->doc, 0);\n     if (copy != NULL) {\n \tcopy->doc = ctxt->output;\n \tcopy = xsltAddChild(insert, copy);\n \n \tif (node->type == XML_ELEMENT_NODE) {\n\t    if (node->nsDef != NULL) {\n\t\tif (isLRE)\n\t\t    xsltCopyNamespaceList(ctxt, copy, node->nsDef);\n\t\telse\n\t\t    xsltCopyNamespaceListInternal(copy, node->nsDef);\n\t    }\n\n\t    if (node->ns != NULL) {\n\t\tif (isLRE) {\n\t\t    copy->ns = xsltGetNamespace(ctxt, node, node->ns, copy);\n\t\t} else {\n\t\t    copy->ns = xsltGetSpecialNamespace(ctxt,\n\t\t\tnode, node->ns->href, node->ns->prefix, copy);\n\n\t\t}\n\t    } else if ((insert->type == XML_ELEMENT_NODE) &&\n\t\t       (insert->ns != NULL))\n\t    {\n\t\txsltGetSpecialNamespace(ctxt, node, NULL, NULL, copy);\n\t    }\n\t}\n    } else {\n\txsltTransformError(ctxt, NULL, node,\n\t\t\"xsltShallowCopyElem: copy %s failed\\n\", node->name);\n    }\n    return(copy);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9161, "func": "static GLuint blit_get_frag_tex_col(struct vrend_blitter_ctx *blit_ctx, int pipe_tex_target, unsigned nr_samples)\n{\n   assert(pipe_tex_target < PIPE_MAX_TEXTURE_TYPES);\n\n   if (nr_samples > 1) {\n      return 0;\n   } else {\n      GLuint *shader = &blit_ctx->fs_texfetch_col[pipe_tex_target];\n\n      if (!*shader) {\n         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex_target, 0);\n\n         *shader = blit_build_frag_tex_col(blit_ctx, tgsi_tex);\n      }\n      return *shader;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8679, "func": "append_string (const char *str, struct growable *dest)\n{\n  int l = strlen (str);\n\n  if (l)\n    {\n      GROW (dest, l);\n      memcpy (TAIL (dest), str, l);\n      TAIL_INCR (dest, l);\n    }\n\n  append_null (dest);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187706, "func": " perform_transform_test(png_modifier *pm)\n {\n   png_byte colour_type = 0;\n\n    png_byte bit_depth = 0;\n    unsigned int palette_number = 0;\n \n   while (next_format(&colour_type, &bit_depth, &palette_number, 0))\n    {\n       png_uint_32 counter = 0;\n       size_t base_pos;\n char name[64];\n\n      base_pos = safecat(name, sizeof name, 0, \"transform:\");\n\n\n       for (;;)\n       {\n          size_t pos = base_pos;\n         PNG_CONST image_transform *list = 0;\n \n         counter = image_transform_add(&list, 1\n, counter,\n            name, sizeof name, &pos, colour_type, bit_depth);\n\n if (counter == 0)\n break;\n\n do\n {\n            pm->repeat = 0;\n            transform_test(pm, FILEID(colour_type, bit_depth, palette_number,\n               pm->interlace_type, 0, 0, 0), list, name);\n\n if (fail(pm))\n return;\n }\n while (pm->repeat);\n }\n }\n}\n", "target": 1, "flaw_line_index": "8,20"}
{"idx": 187810, "func": "OMX_ERRORTYPE  omx_vdec::get_config(OMX_IN OMX_HANDLETYPE      hComp,\n        OMX_IN OMX_INDEXTYPE configIndex,\n        OMX_INOUT OMX_PTR     configData)\n{\n (void) hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"Get Config in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n\n \n     switch ((unsigned long)configIndex) {\n         case OMX_QcomIndexConfigInterlaced: {\n                                 OMX_QCOM_CONFIG_INTERLACETYPE *configFmt =\n                                     (OMX_QCOM_CONFIG_INTERLACETYPE *) configData;\n                                 if (configFmt->nPortIndex == 1) {\n if (configFmt->nIndex == 0) {\n                                        configFmt->eInterlaceType = OMX_QCOM_InterlaceFrameProgressive;\n } else if (configFmt->nIndex == 1) {\n                                        configFmt->eInterlaceType =\n                                            OMX_QCOM_InterlaceInterleaveFrameTopFieldFirst;\n } else if (configFmt->nIndex == 2) {\n                                        configFmt->eInterlaceType =\n                                            OMX_QCOM_InterlaceInterleaveFrameBottomFieldFirst;\n } else {\n                                        DEBUG_PRINT_ERROR(\"get_config: OMX_QcomIndexConfigInterlaced:\"\n \" NoMore Interlaced formats\");\n                                        eRet = OMX_ErrorNoMore;\n }\n\n } else {\n                                    DEBUG_PRINT_ERROR(\"get_config: Bad port index %d queried on only o/p port\",\n (int)configFmt->nPortIndex);\n                                    eRet = OMX_ErrorBadPortIndex;\n }\n\n                                 break;\n                             }\n         case OMX_QcomIndexQueryNumberOfVideoDecInstance: {\n                                      QOMX_VIDEO_QUERY_DECODER_INSTANCES *decoderinstances =\n                                          (QOMX_VIDEO_QUERY_DECODER_INSTANCES*)configData;\n                                      decoderinstances->nNumOfInstances = 16;\n break;\n\n                                  }\n         case OMX_QcomIndexConfigVideoFramePackingArrangement: {\n                                           if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) {\n                                               OMX_QCOM_FRAME_PACK_ARRANGEMENT *configFmt =\n                                                   (OMX_QCOM_FRAME_PACK_ARRANGEMENT *) configData;\n                                               memcpy(configFmt, &m_frame_pack_arrangement,\n sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT));\n } else {\n                                              DEBUG_PRINT_ERROR(\"get_config: Framepack data not supported for non H264 codecs\");\n }\n\n                                           break;\n                                       }\n         case OMX_IndexConfigCommonOutputCrop: {\n                                   OMX_CONFIG_RECTTYPE *rect = (OMX_CONFIG_RECTTYPE *) configData;\n                                   memcpy(rect, &rectangle, sizeof(OMX_CONFIG_RECTTYPE));\n                                   DEBUG_PRINT_HIGH(\"get_config: crop info: L: %u, T: %u, R: %u, B: %u\",\n                                        rectangle.nLeft, rectangle.nTop,\n                                        rectangle.nWidth, rectangle.nHeight);\n\n                                   break;\n                               }\n         case OMX_QcomIndexConfigPerfLevel: {\n                 struct v4l2_control control;\n                 OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =\n                         (OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;\n\n                control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_G_CTRL, &control) < 0) {\n                    DEBUG_PRINT_ERROR(\"Failed getting performance level: %d\", errno);\n                    eRet = OMX_ErrorHardware;\n }\n\n if (eRet == OMX_ErrorNone) {\n switch (control.value) {\n case V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO:\n                            perf->ePerfLevel = OMX_QCOM_PerfLevelTurbo;\n break;\n default:\n                            DEBUG_PRINT_HIGH(\"Unknown perf level %d, reporting Nominal instead\", control.value);\n case V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL:\n                            perf->ePerfLevel = OMX_QCOM_PerfLevelNominal;\n break;\n }\n\n                 }\n \n                                   break;\n                              }\n         default: {\n                  DEBUG_PRINT_ERROR(\"get_config: unknown param %d\",configIndex);\n                  eRet = OMX_ErrorBadParameter;\n }\n\n }\n\n return eRet;\n}\n", "target": 1, "flaw_line_index": "95"}
{"idx": 187997, "func": "WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)\n{\n    WORD32 ret = IV_SUCCESS;\n codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    WORD32 proc_idx = 0;\n    WORD32 prev_proc_idx = 0;\n\n    ps_codec->i4_error_code = 0;\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size; \n }\n if(ps_codec->i4_init_done != 1)\n {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;\n return IV_FAIL;\n }\n\n if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;\n return IV_FAIL;\n }\n\n if(ps_codec->i4_reset_flag)\n {\n        ps_codec->i4_flush_mode = 1;\n }\n\n if(0 == ps_codec->i4_flush_mode)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)\n {\n if((WORD32)ps_dec_ip->u4_num_Bytes > 0)\n                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;\n else\n                ps_dec_op->u4_num_bytes_consumed = 0;\n\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n\n#ifdef APPLY_CONCEALMENT\n {\n        WORD32 num_mbs;\n\n        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;\n        ps_codec->mb_count = 0;\n        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));\n }\n#endif\n\n if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)\n {\n        UWORD32 i;\n if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)\n {\n if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n    ps_codec->u4_ts = ps_dec_ip->u4_ts;\n if(ps_codec->i4_flush_mode)\n {\n\n        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;\n        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(\n (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);\n if((ps_codec->ps_disp_buf)\n && ((0 == ps_codec->i4_share_disp_buf)\n || (IV_YUV_420P\n == ps_codec->e_chroma_fmt)))\n {\n\n process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];\n if(0 == ps_proc->i4_init_done)\n {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n }\n\n            ret = ihevcd_check_out_buf_size(ps_codec);\n            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);\n\n            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,\n                                  ps_codec->i4_disp_ht);\n\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n }\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n if(1 == ps_dec_op->u4_output_present)\n {\n            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n if(ypos < 0)\n                ypos = 0;\n\n if(xpos < 0)\n                xpos = 0;\n\n            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                        xpos,\n                        ypos,\n                        ps_codec->e_chroma_fmt,\n                        ps_codec->i4_disp_wd,\n                        ps_codec->i4_disp_ht);\n }\n\n\n if(NULL == ps_codec->ps_disp_buf)\n {\n if(ps_codec->i4_reset_flag)\n {\n                ihevcd_init(ps_codec);\n }\n return (IV_FAIL);\n }\n\n return (IV_SUCCESS);\n\n }\n if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))\n {\n        WORD32 buf_status;\n        buf_status = 1;\n if(ps_codec->pv_pic_buf_mgr)\n            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);\n\n if(0 == buf_status)\n {\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return IV_FAIL;\n }\n }\n    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;\n    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;\n    ps_codec->s_parse.i4_end_of_frame = 0;\n\n    ps_codec->i4_pic_present = 0;\n    ps_codec->i4_slice_error = 0;\n    ps_codec->ps_disp_buf = NULL;\n\n if(ps_codec->i4_num_cores > 1)\n {\n        ithread_set_affinity(0);\n }\n while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)\n {\n        WORD32 nal_len;\n        WORD32 nal_ofst;\n        WORD32 bits_len;\n\n if(ps_codec->i4_slice_error)\n {\n slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;\n if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                ps_codec->i4_slice_error = 0;\n }\n\n if(ps_codec->pu1_bitsbuf_dynamic)\n {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;\n }\n else\n {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;\n }\n\n        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,\n                                                ps_codec->i4_bytes_remaining);\n\n        ps_codec->i4_nal_ofst = nal_ofst;\n {\n            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;\n\n            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);\n            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,\n                                        ps_codec->pu1_bitsbuf,\n                                        bytes_remaining,\n &nal_len, &bits_len);\n\n if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))\n {\n                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));\n }\n }\n        ps_codec->i4_num_emln_bytes = nal_len - bits_len;\n        ps_codec->i4_nal_len = nal_len;\n\n        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,\n                         bits_len);\n\n        ret = ihevcd_nal_unit(ps_codec);\n\n if(ps_codec->i4_pic_present &&\n (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))\n {\n if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||\n (ps_codec->i4_header_in_slice_mode))\n {\n slice_header_t *ps_slice_hdr_next;\n\n                ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n                ps_codec->i4_slice_error = 1;\n continue;\n }\n }\n\n \n         if(IHEVCD_IGNORE_SLICE == ret)\n         {\n            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));\n             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n \n continue;\n }\n\n if((IVD_RES_CHANGED == ret) ||\n (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))\n {\n break;\n }\n\n if(ret != IHEVCD_SLICE_IN_HEADER_MODE)\n {\n if((0 == ps_codec->i4_slice_error) ||\n (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))\n {\n                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n }\n if(ret != IHEVCD_SUCCESS)\n break;\n\n if(ps_codec->s_parse.i4_end_of_frame)\n break;\n }\n else\n {\n            ret = IHEVCD_SUCCESS;\n break;\n }\n\n if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)\n {\n            WORD32 ret;\n            ret = ihevcd_allocate_dynamic_bufs(ps_codec);\n if(ret != IV_SUCCESS)\n {\n                ihevcd_free_dynamic_bufs(ps_codec);\n                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;\n                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;\n\n return IV_FAIL;\n }\n }\n\n        BREAK_AFTER_SLICE_NAL();\n }\n\n if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))\n {\n        ps_codec->i4_error_code = ret;\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n return IV_FAIL;\n }\n\n if(1 == ps_codec->i4_pic_present)\n {\n        WORD32 i;\n sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n        ps_codec->i4_first_pic_done = 1;\n\n if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)\n {\n\n process_ctxt_t *ps_proc;\n\n            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n if((ps_codec->ps_disp_buf) &&\n ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))\n {\n if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||\n (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))\n for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)\n {\n proc_job_t s_job;\n                        IHEVCD_ERROR_T ret;\n                        s_job.i4_cmd = CMD_FMTCONV;\n                        s_job.i2_ctb_cnt = 0;\n                        s_job.i2_ctb_x = 0;\n                        s_job.i2_ctb_y = i;\n                        s_job.i2_slice_idx = 0;\n                        s_job.i4_tu_coeff_data_ofst = 0;\n                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,\n &s_job, sizeof(proc_job_t), 1);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n return (WORD32)ret;\n }\n }\n            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);\n\n while(1)\n {\n                IHEVCD_ERROR_T ret;\n proc_job_t s_job;\n process_ctxt_t *ps_proc;\n\n                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,\n sizeof(proc_job_t), 1);\n if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)\n break;\n\n                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;\n                ps_proc->i4_ctb_x = s_job.i2_ctb_x;\n                ps_proc->i4_ctb_y = s_job.i2_ctb_y;\n                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;\n\n if(CMD_PROCESS == s_job.i4_cmd)\n {\n                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);\n\n                    ihevcd_process(ps_proc);\n }\n else if(CMD_FMTCONV == s_job.i4_cmd)\n {\n sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;\n if(0 == ps_proc->i4_init_done)\n {\n                        ihevcd_init_proc_ctxt(ps_proc, 0);\n }\n\n                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));\n if(num_rows < 0)\n                        num_rows = 0;\n\n                    ihevcd_fmt_conv(ps_codec, ps_proc,\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,\n                                    num_rows);\n }\n }\n }\n else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||\n (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&\n (ps_codec->s_parse.i4_end_of_frame))\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];\n            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht\n - ps_codec->s_fmt_conv.i4_cur_row;\n if(0 == ps_proc->i4_init_done)\n {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n }\n\n if(ps_codec->s_fmt_conv.i4_num_rows < 0)\n                ps_codec->s_fmt_conv.i4_num_rows = 0;\n\n            ret = ihevcd_fmt_conv(ps_codec, ps_proc,\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                  ps_codec->s_fmt_conv.i4_cur_row,\n                                  ps_codec->s_fmt_conv.i4_num_rows);\n            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;\n\n }\n\n\n        DEBUG_DUMP_MV_MAP(ps_codec);\n\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,\n                                 BUF_MGR_REF);\n\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_REF);\n\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_DISP);\n\n        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,\n                                 ps_codec->as_process[proc_idx].ps_cur_pic,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);\n\n if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n\n for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)\n {\n if(ps_codec->ai4_process_thread_created[i])\n {\n                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);\n                ps_codec->ai4_process_thread_created[i] = 0;\n }\n }\n\n        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);\n if(ps_codec->u4_pic_cnt > 0)\n {\n            DEBUG_DUMP_PIC_PU(ps_codec);\n }\n        DEBUG_DUMP_PIC_BUFFERS(ps_codec);\n\n        ps_codec->u4_pic_cnt++;\n }\n    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n if(1 == ps_dec_op->u4_output_present)\n {\n        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n if(ypos < 0)\n            ypos = 0;\n\n if(xpos < 0)\n            xpos = 0;\n\n        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                    xpos,\n                    ypos,\n                    ps_codec->e_chroma_fmt,\n                    ps_codec->i4_disp_wd,\n                    ps_codec->i4_disp_ht);\n }\n\n\n return ret;\n}\n", "target": 1, "flaw_line_index": "275"}
{"idx": 187602, "func": " generate_row(png_bytep row, size_t rowbytes, unsigned int y, int color_type,\n    int bit_depth, png_const_bytep gamma_table, double conv,\n   unsigned int *colors)\n {\n   png_uint_32 size_max = image_size_of_type(color_type, bit_depth, colors)-1;\n    png_uint_32 depth_max = (1U << bit_depth)-1; \n \n   if (colors[0] == 0) switch (channels_of_type(color_type))\n    {\n case 1:\n {\n            png_uint_32 x;\n            png_uint_32 base = 2*size_max - abs(2*y-size_max);\n\n for (x=0; x<=size_max; ++x)\n {\n               png_uint_32 luma = base - abs(2*x-size_max);\n\n               luma = (luma*depth_max + size_max) / (2*size_max);\n               set_value(row, rowbytes, x, bit_depth, luma, gamma_table, conv);\n }\n }\n break;\n\n case 2:\n {\n            png_uint_32 alpha = (depth_max * y * 2 + size_max) / (2 * size_max);\n            png_uint_32 x;\n\n for (x=0; x<=size_max; ++x)\n {\n               set_value(row, rowbytes, 2*x, bit_depth,\n (depth_max * x * 2 + size_max) / (2 * size_max), gamma_table,\n                  conv);\n               set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,\n                  conv);\n }\n }\n break;\n\n case 3:\n {\n            png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);\n            png_uint_32 x;\n\n for (x=0; x<=size_max; ++x)\n {\n               set_value(row, rowbytes, 3*x+0, bit_depth, \n Y,\n                     gamma_table, conv);\n               set_value(row, rowbytes, 3*x+1, bit_depth, \n (depth_max * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 3*x+2, bit_depth, \n (Y * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n }\n }\n break;\n\n case 4:\n {\n            png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);\n            png_uint_32 x;\n\n for (x=0; x<=size_max; ++x)\n {\n               set_value(row, rowbytes, 4*x+0, bit_depth, \n ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 4*x+1, bit_depth, \n (Y * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 4*x+2, bit_depth, \n                  Y - (Y * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n               set_value(row, rowbytes, 4*x+3, bit_depth, \n                  Y + ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),\n                  gamma_table, conv);\n }\n }\n break;\n\n default:\n         fprintf(stderr, \"makepng: internal bad channel count\\n\");\n         exit(2);\n }\n\n else if (color_type & PNG_COLOR_MASK_PALETTE)\n {\n      memset(row, 0, rowbytes);\n }\n\n else if (colors[0] == channels_of_type(color_type))\n switch (channels_of_type(color_type))\n {\n case 1:\n {\n const png_uint_32 luma = colors[1];\n               png_uint_32 x;\n\n for (x=0; x<=size_max; ++x)\n                  set_value(row, rowbytes, x, bit_depth, luma, gamma_table,\n                     conv);\n }\n break;\n\n case 2:\n {\n const png_uint_32 luma = colors[1];\n const png_uint_32 alpha = colors[2];\n               png_uint_32 x;\n\n for (x=0; x<size_max; ++x)\n {\n                  set_value(row, rowbytes, 2*x, bit_depth, luma, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,\n                     conv);\n }\n }\n break;\n\n case 3:\n {\n const png_uint_32 red = colors[1];\n const png_uint_32 green = colors[2];\n const png_uint_32 blue = colors[3];\n               png_uint_32 x;\n\n for (x=0; x<=size_max; ++x)\n {\n                  set_value(row, rowbytes, 3*x+0, bit_depth, red, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 3*x+1, bit_depth, green, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 3*x+2, bit_depth, blue, gamma_table,\n                     conv);\n }\n }\n break;\n\n case 4:\n {\n const png_uint_32 red = colors[1];\n const png_uint_32 green = colors[2];\n const png_uint_32 blue = colors[3];\n const png_uint_32 alpha = colors[4];\n               png_uint_32 x;\n\n for (x=0; x<=size_max; ++x)\n {\n                  set_value(row, rowbytes, 4*x+0, bit_depth, red, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 4*x+1, bit_depth, green, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 4*x+2, bit_depth, blue, gamma_table,\n                     conv);\n                  set_value(row, rowbytes, 4*x+3, bit_depth, alpha, gamma_table,\n                     conv);\n }\n }\n break;\n\n default:\n            fprintf(stderr, \"makepng: internal bad channel count\\n\");\n            exit(2);\n }\n\n else\n {\n      fprintf(stderr,\n \"makepng: --color: count(%u) does not match channels(%u)\\n\",\n\n          colors[0], channels_of_type(color_type));\n       exit(1);\n    }\n }\n", "target": 1, "flaw_line_index": "3,5,8"}
{"idx": 187575, "func": "static future_t *init(void) {\n  pthread_mutex_init(&lock, NULL);\n  config = config_new(CONFIG_FILE_PATH);\n if (!config) {\n    LOG_WARN(\"%s unable to load config file; attempting to transcode legacy file.\", __func__);\n    config = btif_config_transcode(LEGACY_CONFIG_FILE_PATH);\n if (!config) {\n      LOG_WARN(\"%s unable to transcode legacy file, starting unconfigured.\", __func__);\n      config = config_new_empty();\n if (!config) {\n        LOG_ERROR(\"%s unable to allocate a config object.\", __func__);\n goto error;\n }\n }\n\n if (config_save(config, CONFIG_FILE_PATH))\n      unlink(LEGACY_CONFIG_FILE_PATH);\n }\n\n \n   btif_config_remove_unpaired(config);\n \n  alarm_timer = alarm_new();\n if (!alarm_timer) {\n    LOG_ERROR(\"%s unable to create alarm.\", __func__);\n goto error;\n }\n\n return future_new_immediate(FUTURE_SUCCESS);\n\nerror:;\n  alarm_free(alarm_timer);\n  config_free(config);\n  pthread_mutex_destroy(&lock);\n  alarm_timer = NULL;\n  config = NULL;\n return future_new_immediate(FUTURE_FAIL);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188529, "func": "   static void TearDownTestCase() {\n     vpx_free(input_ - 1);\n     input_ = NULL;\n     vpx_free(output_);\n     output_ = NULL;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8730, "func": "static int check_id_error(X509_STORE_CTX *ctx, int errcode)\n{\n    ctx->error = errcode;\n    ctx->current_cert = ctx->cert;\n    ctx->error_depth = 0;\n    return ctx->verify_cb(0, ctx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187816, "func": "OMX_ERRORTYPE  omx_video::get_parameter(OMX_IN OMX_HANDLETYPE     hComp,\n        OMX_IN OMX_INDEXTYPE paramIndex,\n        OMX_INOUT OMX_PTR     paramData)\n{\n (void)hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned int height=0,width = 0;\n\n    DEBUG_PRINT_LOW(\"get_parameter:\");\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"ERROR: Get Param in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n if (paramData == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: Get Param in Invalid paramData\");\n return OMX_ErrorBadParameter;\n }\n\n     switch ((int)paramIndex) {\n         case OMX_IndexParamPortDefinition:\n             {\n                 OMX_PARAM_PORTDEFINITIONTYPE *portDefn;\n                 portDefn = (OMX_PARAM_PORTDEFINITIONTYPE *) paramData;\n \n                DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamPortDefinition\");\n if (portDefn->nPortIndex == (OMX_U32) PORT_INDEX_IN) {\n                    dev_get_buf_req (&m_sInPortDef.nBufferCountMin,\n &m_sInPortDef.nBufferCountActual,\n &m_sInPortDef.nBufferSize,\n                        m_sInPortDef.nPortIndex);\n                    DEBUG_PRINT_LOW(\"m_sInPortDef: size = %u, min cnt = %u, actual cnt = %u\",\n (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountMin,\n (unsigned int)m_sInPortDef.nBufferCountActual);\n                    memcpy(portDefn, &m_sInPortDef, sizeof(m_sInPortDef));\n#ifdef _ANDROID_ICS_\n if (meta_mode_enable) {\n                        portDefn->nBufferSize = sizeof(encoder_media_buffer_type);\n }\n if (mUseProxyColorFormat) {\n                        portDefn->format.video.eColorFormat =\n (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatAndroidOpaque;\n }\n#endif\n } else if (portDefn->nPortIndex == (OMX_U32) PORT_INDEX_OUT) {\n if (m_state != OMX_StateExecuting) {\n                    dev_get_buf_req (&m_sOutPortDef.nBufferCountMin,\n &m_sOutPortDef.nBufferCountActual,\n &m_sOutPortDef.nBufferSize,\n                            m_sOutPortDef.nPortIndex);\n }\n                    DEBUG_PRINT_LOW(\"m_sOutPortDef: size = %u, min cnt = %u, actual cnt = %u\",\n (unsigned int)m_sOutPortDef.nBufferSize, (unsigned int)m_sOutPortDef.nBufferCountMin,\n (unsigned int)m_sOutPortDef.nBufferCountActual);\n                    memcpy(portDefn, &m_sOutPortDef, sizeof(m_sOutPortDef));\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: GetParameter called on Bad Port Index\");\n                    eRet = OMX_ErrorBadPortIndex;\n }\n break;\n\n             }\n         case OMX_IndexParamVideoInit:\n             {\n                 OMX_PORT_PARAM_TYPE *portParamType =\n                     (OMX_PORT_PARAM_TYPE *) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoInit\");\n\n                memcpy(portParamType, &m_sPortParam, sizeof(m_sPortParam));\n break;\n\n             }\n         case OMX_IndexParamVideoPortFormat:\n             {\n                 OMX_VIDEO_PARAM_PORTFORMATTYPE *portFmt =\n                     (OMX_VIDEO_PARAM_PORTFORMATTYPE *)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoPortFormat\");\n\n if (portFmt->nPortIndex == (OMX_U32) PORT_INDEX_IN) {\n unsigned index = portFmt->nIndex;\n int supportedFormats[] = {\n [0] = QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m,\n [1] = QOMX_COLOR_FormatAndroidOpaque,\n [2] = OMX_COLOR_FormatYUV420SemiPlanar,\n };\n\n if (index > (sizeof(supportedFormats)/sizeof(*supportedFormats) - 1))\n                        eRet = OMX_ErrorNoMore;\n else {\n                        memcpy(portFmt, &m_sInPortFormat, sizeof(m_sInPortFormat));\n                        portFmt->nIndex = index; \n                        portFmt->eColorFormat = (OMX_COLOR_FORMATTYPE)supportedFormats[index];\n }\n } else if (portFmt->nPortIndex == (OMX_U32) PORT_INDEX_OUT) {\n                    memcpy(portFmt, &m_sOutPortFormat, sizeof(m_sOutPortFormat));\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: GetParameter called on Bad Port Index\");\n                    eRet = OMX_ErrorBadPortIndex;\n }\n break;\n\n             }\n         case OMX_IndexParamVideoBitrate:\n             {\n                 OMX_VIDEO_PARAM_BITRATETYPE* pParam = (OMX_VIDEO_PARAM_BITRATETYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoBitrate\");\n \n if (pParam->nPortIndex == (OMX_U32) PORT_INDEX_OUT) {\n                    memcpy(pParam, &m_sParamBitrate, sizeof(m_sParamBitrate));\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: GetParameter called on Bad Port Index\");\n                    eRet = OMX_ErrorBadPortIndex;\n }\n\n break;\n\n             }\n         case OMX_IndexParamVideoMpeg4:\n             {\n                 OMX_VIDEO_PARAM_MPEG4TYPE* pParam = (OMX_VIDEO_PARAM_MPEG4TYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoMpeg4\");\n                 memcpy(pParam, &m_sParamMPEG4, sizeof(m_sParamMPEG4));\n break;\n\n             }\n         case OMX_IndexParamVideoH263:\n             {\n                 OMX_VIDEO_PARAM_H263TYPE* pParam = (OMX_VIDEO_PARAM_H263TYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoH263\");\n                 memcpy(pParam, &m_sParamH263, sizeof(m_sParamH263));\n break;\n\n             }\n         case OMX_IndexParamVideoAvc:\n             {\n                 OMX_VIDEO_PARAM_AVCTYPE* pParam = (OMX_VIDEO_PARAM_AVCTYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoAvc\");\n                 memcpy(pParam, &m_sParamAVC, sizeof(m_sParamAVC));\n break;\n\n             }\n         case (OMX_INDEXTYPE)OMX_IndexParamVideoVp8:\n             {\n                 OMX_VIDEO_PARAM_VP8TYPE* pParam = (OMX_VIDEO_PARAM_VP8TYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoVp8\");\n                 memcpy(pParam, &m_sParamVP8, sizeof(m_sParamVP8));\n break;\n\n             }\n         case (OMX_INDEXTYPE)OMX_IndexParamVideoHevc:\n             {\n                 OMX_VIDEO_PARAM_HEVCTYPE* pParam = (OMX_VIDEO_PARAM_HEVCTYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoHevc\");\n                 memcpy(pParam, &m_sParamHEVC, sizeof(m_sParamHEVC));\n break;\n\n             }\n         case OMX_IndexParamVideoProfileLevelQuerySupported:\n             {\n                 OMX_VIDEO_PARAM_PROFILELEVELTYPE* pParam = (OMX_VIDEO_PARAM_PROFILELEVELTYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoProfileLevelQuerySupported\");\n                 eRet = get_supported_profile_level(pParam);\n if (eRet && eRet != OMX_ErrorNoMore)\n                    DEBUG_PRINT_ERROR(\"Invalid entry returned from get_supported_profile_level %u, %u\",\n (unsigned int)pParam->eProfile, (unsigned int)pParam->eLevel);\n break;\n\n             }\n         case OMX_IndexParamVideoProfileLevelCurrent:\n             {\n                 OMX_VIDEO_PARAM_PROFILELEVELTYPE* pParam = (OMX_VIDEO_PARAM_PROFILELEVELTYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoProfileLevelCurrent\");\n                 memcpy(pParam, &m_sParamProfileLevel, sizeof(m_sParamProfileLevel));\n break;\n }\n\n         case OMX_IndexParamAudioInit:\n             {\n                 OMX_PORT_PARAM_TYPE *audioPortParamType = (OMX_PORT_PARAM_TYPE *) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamAudioInit\");\n                 memcpy(audioPortParamType, &m_sPortParam_audio, sizeof(m_sPortParam_audio));\n break;\n }\n\n         case OMX_IndexParamImageInit:\n             {\n                 OMX_PORT_PARAM_TYPE *imagePortParamType = (OMX_PORT_PARAM_TYPE *) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamImageInit\");\n                 memcpy(imagePortParamType, &m_sPortParam_img, sizeof(m_sPortParam_img));\n break;\n\n }\n case OMX_IndexParamOtherInit:\n {\n                DEBUG_PRINT_ERROR(\"ERROR: get_parameter: OMX_IndexParamOtherInit %08x\", paramIndex);\n                eRet =OMX_ErrorUnsupportedIndex;\n break;\n\n             }\n         case OMX_IndexParamStandardComponentRole:\n             {\n                 OMX_PARAM_COMPONENTROLETYPE *comp_role;\n                 comp_role = (OMX_PARAM_COMPONENTROLETYPE *) paramData;\n                 comp_role->nVersion.nVersion = OMX_SPEC_VERSION;\n                comp_role->nSize = sizeof(*comp_role);\n\n                DEBUG_PRINT_LOW(\"Getparameter: OMX_IndexParamStandardComponentRole %d\",paramIndex);\n                strlcpy((char*)comp_role->cRole,(const char*)m_cRole,OMX_MAX_STRINGNAME_SIZE);\n break;\n }\n\n         case OMX_IndexParamPriorityMgmt:\n             {\n                 OMX_PRIORITYMGMTTYPE *priorityMgmType = (OMX_PRIORITYMGMTTYPE *) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamPriorityMgmt\");\n                 memcpy(priorityMgmType, &m_sPriorityMgmt, sizeof(m_sPriorityMgmt));\n break;\n }\n\n         case OMX_IndexParamCompBufferSupplier:\n             {\n                 OMX_PARAM_BUFFERSUPPLIERTYPE *bufferSupplierType = (OMX_PARAM_BUFFERSUPPLIERTYPE*) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamCompBufferSupplier\");\n                 if (bufferSupplierType->nPortIndex ==(OMX_U32) PORT_INDEX_IN) {\n                    memcpy(bufferSupplierType, &m_sInBufSupplier, sizeof(m_sInBufSupplier));\n } else if (bufferSupplierType->nPortIndex ==(OMX_U32) PORT_INDEX_OUT) {\n                    memcpy(bufferSupplierType, &m_sOutBufSupplier, sizeof(m_sOutBufSupplier));\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: GetParameter called on Bad Port Index\");\n                    eRet = OMX_ErrorBadPortIndex;\n }\n break;\n }\n\n \n         case OMX_IndexParamVideoQuantization:\n             {\n                 OMX_VIDEO_PARAM_QUANTIZATIONTYPE *session_qp = (OMX_VIDEO_PARAM_QUANTIZATIONTYPE*) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_IndexParamVideoQuantization\");\n                 memcpy(session_qp, &m_sSessionQuantization, sizeof(m_sSessionQuantization));\n break;\n }\n\n \n         case OMX_QcomIndexParamVideoQPRange:\n             {\n                 OMX_QCOM_VIDEO_PARAM_QPRANGETYPE *qp_range = (OMX_QCOM_VIDEO_PARAM_QPRANGETYPE*) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_QcomIndexParamVideoQPRange\");\n                 memcpy(qp_range, &m_sSessionQPRange, sizeof(m_sSessionQPRange));\n break;\n }\n\n \n         case OMX_IndexParamVideoErrorCorrection:\n             {\n                 OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE* errorresilience = (OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"OMX_IndexParamVideoErrorCorrection\");\n                 errorresilience->bEnableHEC = m_sErrorCorrection.bEnableHEC;\n                errorresilience->bEnableResync = m_sErrorCorrection.bEnableResync;\n                errorresilience->nResynchMarkerSpacing = m_sErrorCorrection.nResynchMarkerSpacing;\n break;\n\n             }\n         case OMX_IndexParamVideoIntraRefresh:\n             {\n                 OMX_VIDEO_PARAM_INTRAREFRESHTYPE* intrarefresh = (OMX_VIDEO_PARAM_INTRAREFRESHTYPE*)paramData;\n                 DEBUG_PRINT_LOW(\"OMX_IndexParamVideoIntraRefresh\");\n                 DEBUG_PRINT_ERROR(\"OMX_IndexParamVideoIntraRefresh GET\");\n                intrarefresh->eRefreshMode = m_sIntraRefresh.eRefreshMode;\n                intrarefresh->nCirMBs = m_sIntraRefresh.nCirMBs;\n break;\n }\n case OMX_QcomIndexPortDefn:\n\n             break;\n         case OMX_COMPONENT_CAPABILITY_TYPE_INDEX:\n             {\n                 OMXComponentCapabilityFlagsType *pParam = reinterpret_cast<OMXComponentCapabilityFlagsType*>(paramData);\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_COMPONENT_CAPABILITY_TYPE_INDEX\");\n                 pParam->iIsOMXComponentMultiThreaded = OMX_TRUE;\n                pParam->iOMXComponentSupportsExternalOutputBufferAlloc = OMX_FALSE;\n                pParam->iOMXComponentSupportsExternalInputBufferAlloc = OMX_TRUE;\n                pParam->iOMXComponentSupportsMovableInputBuffers = OMX_TRUE;\n                pParam->iOMXComponentUsesNALStartCodes = OMX_TRUE;\n                pParam->iOMXComponentSupportsPartialFrames = OMX_FALSE;\n                pParam->iOMXComponentCanHandleIncompleteFrames = OMX_FALSE;\n                pParam->iOMXComponentUsesFullAVCFrames = OMX_FALSE;\n                m_use_input_pmem = OMX_TRUE;\n                DEBUG_PRINT_LOW(\"Supporting capability index in encoder node\");\n break;\n }\n\n #if !defined(MAX_RES_720P) || defined(_MSM8974_)\n         case OMX_QcomIndexParamIndexExtraDataType:\n             {\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_QcomIndexParamIndexExtraDataType\");\n                 QOMX_INDEXEXTRADATATYPE *pParam = (QOMX_INDEXEXTRADATATYPE *)paramData;\n                 if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoEncoderSliceInfo) {\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n                        pParam->bEnabled =\n (OMX_BOOL)(m_sExtraData & VEN_EXTRADATA_SLICEINFO);\n                        DEBUG_PRINT_HIGH(\"Slice Info extradata %d\", pParam->bEnabled);\n } else {\n                        DEBUG_PRINT_ERROR(\"get_parameter: slice information is \"\n \"valid for output port only\");\n                        eRet =OMX_ErrorUnsupportedIndex;\n }\n } else if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoEncoderMBInfo) {\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n                        pParam->bEnabled =\n (OMX_BOOL)(m_sExtraData & VEN_EXTRADATA_MBINFO);\n                        DEBUG_PRINT_HIGH(\"MB Info extradata %d\", pParam->bEnabled);\n } else {\n                        DEBUG_PRINT_ERROR(\"get_parameter: MB information is \"\n \"valid for output port only\");\n                        eRet = OMX_ErrorUnsupportedIndex;\n }\n }\n#ifndef _MSM8974_\n else if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoLTRInfo) {\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n                        pParam->bEnabled =\n (OMX_BOOL)(m_sExtraData & VEN_EXTRADATA_LTRINFO);\n                        DEBUG_PRINT_HIGH(\"LTR Info extradata %d\", pParam->bEnabled);\n } else {\n                        DEBUG_PRINT_ERROR(\"get_parameter: LTR information is \"\n \"valid for output port only\");\n                        eRet = OMX_ErrorUnsupportedIndex;\n }\n }\n#endif\n else {\n                    DEBUG_PRINT_ERROR(\"get_parameter: unsupported extradata index (0x%x)\",\n                            pParam->nIndex);\n                    eRet = OMX_ErrorUnsupportedIndex;\n }\n break;\n\n             }\n         case QOMX_IndexParamVideoLTRCountRangeSupported:\n             {\n                 DEBUG_PRINT_HIGH(\"get_parameter: QOMX_IndexParamVideoLTRCountRangeSupported\");\n                 QOMX_EXTNINDEX_RANGETYPE *pParam = (QOMX_EXTNINDEX_RANGETYPE *)paramData;\n                 if (pParam->nPortIndex == PORT_INDEX_OUT) {\n                    OMX_U32 min = 0, max = 0, step_size = 0;\n if (dev_get_capability_ltrcount(&min, &max, &step_size)) {\n                        pParam->nMin = min;\n                        pParam->nMax = max;\n                        pParam->nStepSize = step_size;\n } else {\n                        DEBUG_PRINT_ERROR(\"get_parameter: get_capability_ltrcount failed\");\n                        eRet = OMX_ErrorUndefined;\n }\n } else {\n                    DEBUG_PRINT_ERROR(\"LTR count range is valid for output port only\");\n                    eRet = OMX_ErrorUnsupportedIndex;\n }\n }\n\n             break;\n         case OMX_QcomIndexParamVideoLTRCount:\n             {\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_QcomIndexParamVideoLTRCount\");\n                 OMX_QCOM_VIDEO_PARAM_LTRCOUNT_TYPE *pParam =\n                         reinterpret_cast<OMX_QCOM_VIDEO_PARAM_LTRCOUNT_TYPE*>(paramData);\n                memcpy(pParam, &m_sParamLTRCount, sizeof(m_sParamLTRCount));\n break;\n }\n\n #endif\n         case QOMX_IndexParamVideoSyntaxHdr:\n             {\n                 DEBUG_PRINT_HIGH(\"QOMX_IndexParamVideoSyntaxHdr\");\n                 QOMX_EXTNINDEX_PARAMTYPE* pParam =\n                     reinterpret_cast<QOMX_EXTNINDEX_PARAMTYPE*>(paramData);\n if (pParam->pData == NULL) {\n                    DEBUG_PRINT_ERROR(\"Error: Data buffer is NULL\");\n                    eRet = OMX_ErrorBadParameter;\n break;\n }\n if (get_syntaxhdr_enable == false) {\n                    DEBUG_PRINT_ERROR(\"ERROR: get_parameter: Get syntax header disabled\");\n                    eRet = OMX_ErrorUnsupportedIndex;\n break;\n }\n                BITMASK_SET(&m_flags, OMX_COMPONENT_LOADED_START_PENDING);\n if (dev_loaded_start()) {\n                    DEBUG_PRINT_LOW(\"device start successful\");\n } else {\n                    DEBUG_PRINT_ERROR(\"device start failed\");\n                    BITMASK_CLEAR(&m_flags, OMX_COMPONENT_LOADED_START_PENDING);\n return OMX_ErrorHardware;\n }\n if (dev_get_seq_hdr(pParam->pData,\n (unsigned)(pParam->nSize - sizeof(QOMX_EXTNINDEX_PARAMTYPE)),\n (unsigned *)(void *)&pParam->nDataSize)) {\n                    DEBUG_PRINT_HIGH(\"get syntax header successful (hdrlen = %u)\",\n (unsigned int)pParam->nDataSize);\n for (unsigned i = 0; i < pParam->nDataSize; i++) {\n                        DEBUG_PRINT_LOW(\"Header[%d] = %x\", i, *((char *)pParam->pData + i));\n }\n } else {\n                    DEBUG_PRINT_ERROR(\"Error returned from GetSyntaxHeader()\");\n                    eRet = OMX_ErrorHardware;\n }\n                BITMASK_SET(&m_flags, OMX_COMPONENT_LOADED_STOP_PENDING);\n if (dev_loaded_stop()) {\n                    DEBUG_PRINT_LOW(\"device stop successful\");\n } else {\n                    DEBUG_PRINT_ERROR(\"device stop failed\");\n                    BITMASK_CLEAR(&m_flags, OMX_COMPONENT_LOADED_STOP_PENDING);\n                    eRet = OMX_ErrorHardware;\n }\n break;\n\n             }\n         case OMX_QcomIndexHierarchicalStructure:\n             {\n                 QOMX_VIDEO_HIERARCHICALLAYERS* hierp = (QOMX_VIDEO_HIERARCHICALLAYERS*) paramData;\n                 DEBUG_PRINT_LOW(\"get_parameter: OMX_QcomIndexHierarchicalStructure\");\n                 memcpy(hierp, &m_sHierLayers, sizeof(m_sHierLayers));\n break;\n\n             }\n         case OMX_QcomIndexParamPerfLevel:\n             {\n                 OMX_U32 perflevel;\n                 OMX_QCOM_VIDEO_PARAM_PERF_LEVEL *pParam =\n                     reinterpret_cast<OMX_QCOM_VIDEO_PARAM_PERF_LEVEL*>(paramData);\n                DEBUG_PRINT_LOW(\"get_parameter: OMX_QcomIndexParamPerfLevel\");\n if (!dev_get_performance_level(&perflevel)) {\n                    DEBUG_PRINT_ERROR(\"Invalid entry returned from get_performance_level %d\",\n                        pParam->ePerfLevel);\n } else {\n                    pParam->ePerfLevel = (QOMX_VIDEO_PERF_LEVEL)perflevel;\n }\n break;\n\n             }\n         case OMX_QcomIndexParamH264VUITimingInfo:\n             {\n                 OMX_U32 enabled;\n                 OMX_QCOM_VIDEO_PARAM_VUI_TIMING_INFO *pParam =\n                     reinterpret_cast<OMX_QCOM_VIDEO_PARAM_VUI_TIMING_INFO*>(paramData);\n                DEBUG_PRINT_LOW(\"get_parameter: OMX_QcomIndexParamH264VUITimingInfo\");\n if (!dev_get_vui_timing_info(&enabled)) {\n                    DEBUG_PRINT_ERROR(\"Invalid entry returned from get_vui_Timing_info %d\",\n                        pParam->bEnable);\n } else {\n                    pParam->bEnable = (OMX_BOOL)enabled;\n }\n break;\n\n             }\n         case OMX_QcomIndexParamPeakBitrate:\n             {\n                 OMX_U32 peakbitrate;\n                 OMX_QCOM_VIDEO_PARAM_PEAK_BITRATE *pParam =\n                     reinterpret_cast<OMX_QCOM_VIDEO_PARAM_PEAK_BITRATE*>(paramData);\n                DEBUG_PRINT_LOW(\"get_parameter: OMX_QcomIndexParamPeakBitrate\");\n if (!dev_get_peak_bitrate(&peakbitrate)) {\n                    DEBUG_PRINT_ERROR(\"Invalid entry returned from get_peak_bitrate %u\",\n (unsigned int)pParam->nPeakBitrate);\n } else {\n                    pParam->nPeakBitrate = peakbitrate;\n }\n break;\n\n             }\n          case QOMX_IndexParamVideoInitialQp:\n             {\n                  QOMX_EXTNINDEX_VIDEO_INITIALQP* initqp =\n                      reinterpret_cast<QOMX_EXTNINDEX_VIDEO_INITIALQP *>(paramData);\n                      memcpy(initqp, &m_sParamInitqp, sizeof(m_sParamInitqp));\n break;\n }\n case OMX_IndexParamVideoSliceFMO:\n default:\n {\n                DEBUG_PRINT_LOW(\"ERROR: get_parameter: unknown param %08x\", paramIndex);\n                eRet =OMX_ErrorUnsupportedIndex;\n break;\n }\n\n }\n\n return eRet;\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9065, "func": "vmxnet3_setup_tx_offloads(VMXNET3State *s)\n{\n    switch (s->offload_mode) {\n    case VMXNET3_OM_NONE:\n        net_tx_pkt_build_vheader(s->tx_pkt, false, false, 0);\n        break;\n\n    case VMXNET3_OM_CSUM:\n        net_tx_pkt_build_vheader(s->tx_pkt, false, true, 0);\n        VMW_PKPRN(\"L4 CSO requested\\n\");\n        break;\n\n    case VMXNET3_OM_TSO:\n        net_tx_pkt_build_vheader(s->tx_pkt, true, true,\n            s->cso_or_gso_size);\n        net_tx_pkt_update_ip_checksums(s->tx_pkt);\n        VMW_PKPRN(\"GSO offload requested.\");\n        break;\n\n    default:\n        g_assert_not_reached();\n        return false;\n    }\n\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8898, "func": "void vrend_renderer_detach_res_ctx(int ctx_id, int res_handle)\n{\n   struct vrend_context *ctx = vrend_lookup_renderer_ctx(ctx_id);\n   if (!ctx)\n      return;\n   vrend_renderer_detach_res_ctx_p(ctx, res_handle);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8961, "func": "bool net_tx_pkt_has_fragments(struct NetTxPkt *pkt)\n{\n    return pkt->raw_frags > 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187884, "func": "long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {\n  assert(pReader);\n  assert(pos >= 0);\n  int status;\n \n   len = 1;\n   unsigned char b;\n  status = pReader->Read(pos, 1, &b);\n \n   if (status < 0)  \n     return status;\n\n if (status > 0) \n return E_BUFFER_NOT_FULL;\n\n if (b == 0) \n return E_FILE_FORMAT_INVALID;\n\n unsigned char m = 0x80;\n\n while (!(b & m)) {\n    m >>= 1;\n\n     ++len;\n   }\n \n   long long result = b & (~m);\n   ++pos;\n \n for (int i = 1; i < len; ++i) {\n    status = pReader->Read(pos, 1, &b);\n\n if (status < 0) {\n      len = 1;\n return status;\n }\n\n if (status > 0) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result <<= 8;\n    result |= b;\n\n ++pos;\n }\n\n\n   return result;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,16,35,36,37"}
{"idx": 188226, "func": "OMX_ERRORTYPE SoftFlacEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamAudioPcm)\");\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams = (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 ALOGE(\"SoftFlacEncoder::internalSetParameter() Error #1\");\n                 return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n            ALOGV(\"will encode %d channels at %dHz\", mNumChannels, mSampleRate);\n\n return configureEncoder();\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\");\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                     \"audio_encoder.flac\",\n                     OMX_MAX_STRINGNAME_SIZE - 1)) {\n                ALOGE(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\"\n \"error\");\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioFlac:\n\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             mCompressionLevel = flacParams->nCompressionLevel; \n             return OMX_ErrorNone;\n         }\n\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex == 0) {\n                 if (defParams->nBufferSize > kMaxInputBufferSize) {\n                     ALOGE(\"Input buffer size must be at most %d bytes\",\n                        kMaxInputBufferSize);\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n }\n\n default:\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(default)\");\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187871, "func": "long ContentEncoding::ParseContentEncAESSettingsEntry(\n long long start, long long size, IMkvReader* pReader,\n ContentEncAESSettings* aes) {\n  assert(pReader);\n  assert(aes);\n\n long long pos = start;\n const long long stop = start + size;\n\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) \n return status;\n\n if (id == 0x7E8) {\n      aes->cipher_mode = UnserializeUInt(pReader, pos, size);\n if (aes->cipher_mode != 1)\n return E_FILE_FORMAT_INVALID;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n   return 0;\n}\n", "target": 1, "flaw_line_index": "25"}
{"idx": 187330, "func": " xsltNumberFormatGetAnyLevel(xsltTransformContextPtr context,\n \t\t\t    xmlNodePtr node,\n \t\t\t    xsltCompMatchPtr countPat,\n \t\t\t    xsltCompMatchPtr fromPat,\n\t\t\t    double *array,\n\t\t\t    xmlDocPtr doc,\n\t\t\t    xmlNodePtr elem)\n {\n     int amount = 0;\n     int cnt = 0;\n    xmlNodePtr cur;\n\n    switch (node->type) {\n\tcase XML_ELEMENT_NODE:\n\t    cur = node;\n\t    break;\n\tcase XML_ATTRIBUTE_NODE:\n\t    cur = ((xmlAttrPtr) node)->parent;\n\t    break;\n\tcase XML_TEXT_NODE:\n\tcase XML_PI_NODE:\n\tcase XML_COMMENT_NODE:\n\t    cur = node->parent;\n\t    break;\n\tdefault:\n\t    cur = NULL;\n\t    break;\n    }\n \n     while (cur != NULL) {\n\tif (countPat == NULL) {\n\t    if ((node->type == cur->type) &&\n\t\txmlStrEqual(node->name, cur->name)) {\n\t\t    if ((node->ns == cur->ns) ||\n\t\t        ((node->ns != NULL) &&\n\t\t\t (cur->ns != NULL) &&\n\t\t         (xmlStrEqual(node->ns->href,\n\t\t             cur->ns->href) )))\n\t\t        cnt++;\n\t    }\n\t} else {\n\t    if (xsltTestCompMatchList(context, cur, countPat))\n\t\tcnt++;\n\t}\n \tif ((fromPat != NULL) &&\n \t    xsltTestCompMatchList(context, cur, fromPat)) {\n \t    break; \n\t}\n\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n            (cur->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n            (cur->type == XML_HTML_DOCUMENT_NODE))\n\t    break; \n\n\twhile ((cur->prev != NULL) && ((cur->prev->type == XML_DTD_NODE) ||\n\t       (cur->prev->type == XML_XINCLUDE_START) ||\n\t       (cur->prev->type == XML_XINCLUDE_END)))\n\t    cur = cur->prev;\n\tif (cur->prev != NULL) {\n\t    for (cur = cur->prev; cur->last != NULL; cur = cur->last);\n\t} else {\n\t    cur = cur->parent;\n\t}\n\n    }\n\n    array[amount++] = (double) cnt;\n\n    return(amount);\n}\n", "target": 1, "flaw_line_index": "5,6,7,31,32,32,33,34,35,36,37,38,39,40,41,42,43,44"}
{"idx": 8488, "func": "void CSoundFile::LoopPattern(int nPat, int nRow)\n{\n\tif ((nPat < 0) || (nPat >= MAX_PATTERNS) || (!Patterns[nPat]))\n\t{\n\t\tm_dwSongFlags &= ~SONG_PATTERNLOOP;\n\t} else\n\t{\n\t\tif ((nRow < 0) || (nRow >= PatternSize[nPat])) nRow = 0;\n\t\tm_nPattern = nPat;\n\t\tm_nRow = m_nNextRow = nRow;\n\t\tm_nTickCount = m_nMusicSpeed;\n\t\tm_nPatternDelay = 0;\n\t\tm_nFrameDelay = 0;\n\t\tm_nBufferCount = 0;\n\t\tm_dwSongFlags |= SONG_PATTERNLOOP;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8698, "func": "split_path (const char *path, char **dir, char **file)\n{\n  char *last_slash = strrchr (path, '/');\n  if (!last_slash)\n    {\n      *dir = xstrdup (\"\");\n      *file = xstrdup (path);\n    }\n  else\n    {\n      *dir = strdupdelim (path, last_slash);\n      *file = xstrdup (last_slash + 1);\n    }\n  url_unescape (*dir);\n  url_unescape (*file);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8760, "func": "int FAST_FUNC udhcp_str2nip(const char *str, void *arg)\n{\n\tlen_and_sockaddr *lsa;\n\n\tlsa = host_and_af2sockaddr(str, 0, AF_INET);\n\tif (!lsa)\n\t\treturn 0;\n\tmove_to_unaligned32((uint32_t*)arg, lsa->u.sin.sin_addr.s_addr);\n\tfree(lsa);\n\treturn 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188195, "func": " status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (mTimeToSample != NULL || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = (uint64_t)mTimeToSampleCount * 2 * sizeof(uint32_t);\n    if (allocSize > UINT32_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n    mTimeToSample = new (std::nothrow) uint32_t[mTimeToSampleCount * 2];\n    if (!mTimeToSample)\n        return ERROR_OUT_OF_RANGE;\n \n    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n    if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n         return ERROR_IO;\n     }\n \n    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n     }\n     return OK;\n }\n", "target": 1, "flaw_line_index": "3,20,21,24,25,26,28,29,30,34,35"}
{"idx": 187338, "func": "xsltElementComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemElementPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemElementPtr) xsltNewStylePreComp(style, XSLT_FUNC_ELEMENT);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_ELEMENT);\n#endif\n\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n\n    comp->name = xsltEvalStaticAttrValueTemplate(style, inst,\n\t(const xmlChar *)\"name\", NULL, &comp->has_name);\n    if (! comp->has_name) {\n\txsltTransformError(NULL, style, inst,\n\t    \"xsl:element: The attribute 'name' is missing.\\n\");\n\tstyle->errors++;\n\tgoto error;\n    }\n    comp->ns = xsltEvalStaticAttrValueTemplate(style, inst,\n\t(const xmlChar *)\"namespace\", NULL, &comp->has_ns);\n\n    if (comp->name != NULL) {\n\tif (xmlValidateQName(comp->name, 0)) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"xsl:element: The value '%s' of the attribute 'name' is \"\n\t\t\"not a valid QName.\\n\", comp->name);\n\t    style->errors++;\n\t} else {\n\t    const xmlChar *prefix = NULL, *name;\n\n\t    name = xsltSplitQName(style->dict, comp->name, &prefix);\n\t    if (comp->has_ns == 0) {\n\t\txmlNsPtr ns;\n\n\t\tns = xmlSearchNs(inst->doc, inst, prefix);\n\t\tif (ns != NULL) {\n\t\t    comp->ns = xmlDictLookup(style->dict, ns->href, -1);\n\t\t    comp->has_ns = 1;\n #ifdef XSLT_REFACTORED\n \t\t    comp->nsPrefix = prefix;\n \t\t    comp->name = name;\n #endif\n \t\t} else if (prefix != NULL) {\n \t\t    xsltTransformError(NULL, style, inst,\n\t\t\t\"xsl:element: The prefixed QName '%s' \"\n\t\t\t\"has no namespace binding in scope in the \"\n\t\t\t\"stylesheet; this is an error, since the namespace was \"\n\t\t\t\"not specified by the instruction itself.\\n\", comp->name);\n\t\t    style->errors++;\n\t\t}\n\t    }\n\t    if ((prefix != NULL) &&\n\t\t(!xmlStrncasecmp(prefix, (xmlChar *)\"xml\", 3)))\n\t    {\n\t\tcomp->has_name = 0;\n\t    }\n\t}\n    }\n    comp->use = xsltEvalStaticAttrValueTemplate(style, inst,\n\t\t       (const xmlChar *)\"use-attribute-sets\",\n\t\t       NULL, &comp->has_use);\n\nerror:\n    return;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8510, "func": "static const char *connect_to_host(Ssh ssh, const char *host, int port,\n\t\t\t\t   char **realhost, int nodelay, int keepalive)\n{\n    static const struct plug_function_table fn_table = {\n\tssh_socket_log,\n\tssh_closing,\n\tssh_receive,\n\tssh_sent,\n\tNULL\n    };\n\n    SockAddr addr;\n    const char *err;\n    char *loghost;\n    int addressfamily, sshprot;\n\n    ssh_hostport_setup(host, port, ssh->conf,\n                       &ssh->savedhost, &ssh->savedport, &loghost);\n\n    ssh->fn = &fn_table;               \n\n    ssh->connshare = NULL;\n    ssh->attempting_connshare = TRUE;  \n    ssh->s = ssh_connection_sharing_init(ssh->savedhost, ssh->savedport,\n                                         ssh->conf, ssh, &ssh->connshare);\n    ssh->attempting_connshare = FALSE;\n    if (ssh->s != NULL) {\n        ssh->bare_connection = TRUE;\n        ssh->do_ssh_init = do_ssh_connection_init;\n        ssh->fullhostname = NULL;\n        *realhost = dupstr(host);      \n    } else {\n        ssh->do_ssh_init = do_ssh_init;\n\n        addressfamily = conf_get_int(ssh->conf, CONF_addressfamily);\n        addr = name_lookup(host, port, realhost, ssh->conf, addressfamily,\n                           ssh->frontend, \"SSH connection\");\n        if ((err = sk_addr_error(addr)) != NULL) {\n            sk_addr_free(addr);\n            return err;\n        }\n        ssh->fullhostname = dupstr(*realhost);   \n\n        ssh->s = new_connection(addr, *realhost, port,\n                                0, 1, nodelay, keepalive,\n                                (Plug) ssh, ssh->conf);\n        if ((err = sk_socket_error(ssh->s)) != NULL) {\n            ssh->s = NULL;\n            notify_remote_exit(ssh->frontend);\n            return err;\n        }\n    }\n\n    sshprot = conf_get_int(ssh->conf, CONF_sshprot);\n    assert(sshprot == 0 || sshprot == 3);\n    if (sshprot == 0)\n\tssh->version = 1;\n    if (sshprot == 3 && !ssh->bare_connection) {\n\tssh->version = 2;\n\tssh_send_verstring(ssh, \"SSH-\", NULL);\n    }\n\n    if (*loghost) {\n\tsfree(*realhost);\n\t*realhost = dupstr(loghost);\n    }\n\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8418, "func": "pvscsi_io_write(void *opaque, hwaddr addr,\n                uint64_t val, unsigned size)\n{\n    PVSCSIState *s = opaque;\n\n    switch (addr) {\n    case PVSCSI_REG_OFFSET_COMMAND:\n        pvscsi_on_command(s, val);\n        break;\n\n    case PVSCSI_REG_OFFSET_COMMAND_DATA:\n        pvscsi_on_command_data(s, (uint32_t) val);\n        break;\n\n    case PVSCSI_REG_OFFSET_INTR_STATUS:\n        trace_pvscsi_io_write(\"PVSCSI_REG_OFFSET_INTR_STATUS\", val);\n        s->reg_interrupt_status &= ~val;\n        pvscsi_update_irq_status(s);\n        pvscsi_schedule_completion_processing(s);\n        break;\n\n    case PVSCSI_REG_OFFSET_INTR_MASK:\n        trace_pvscsi_io_write(\"PVSCSI_REG_OFFSET_INTR_MASK\", val);\n        s->reg_interrupt_enabled = val;\n        pvscsi_update_irq_status(s);\n        break;\n\n    case PVSCSI_REG_OFFSET_KICK_NON_RW_IO:\n        trace_pvscsi_io_write(\"PVSCSI_REG_OFFSET_KICK_NON_RW_IO\", val);\n        pvscsi_process_io(s);\n        break;\n\n    case PVSCSI_REG_OFFSET_KICK_RW_IO:\n        trace_pvscsi_io_write(\"PVSCSI_REG_OFFSET_KICK_RW_IO\", val);\n        pvscsi_process_io(s);\n        break;\n\n    case PVSCSI_REG_OFFSET_DEBUG:\n        trace_pvscsi_io_write(\"PVSCSI_REG_OFFSET_DEBUG\", val);\n        break;\n\n    default:\n        trace_pvscsi_io_write_unknown(addr, size, val);\n        break;\n    }\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8947, "func": "void vrend_clear(struct vrend_context *ctx,\n                 unsigned buffers,\n                 const union pipe_color_union *color,\n                 double depth, unsigned stencil)\n{\n   GLbitfield bits = 0;\n\n   if (ctx->in_error)\n      return;\n\n   if (ctx->ctx_switch_pending)\n      vrend_finish_context_switch(ctx);\n\n   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);\n\n   vrend_update_frontface_state(ctx);\n   if (ctx->sub->stencil_state_dirty)\n      vrend_update_stencil_state(ctx);\n   if (ctx->sub->scissor_state_dirty)\n      vrend_update_scissor_state(ctx);\n   if (ctx->sub->viewport_state_dirty)\n      vrend_update_viewport_state(ctx);\n\n   vrend_use_program(ctx, 0);\n\n   if (buffers & PIPE_CLEAR_COLOR) {\n      if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {\n         glClearColor(color->f[3], 0.0, 0.0, 0.0);\n      } else {\n         glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);\n      }\n   }\n\n   if (buffers & PIPE_CLEAR_DEPTH) {\n      glDepthMask(GL_TRUE);\n      glClearDepth(depth);\n   }\n\n   if (buffers & PIPE_CLEAR_STENCIL)\n      glClearStencil(stencil);\n\n   if (buffers & PIPE_CLEAR_COLOR) {\n      uint32_t mask = 0;\n      int i;\n      for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n         if (ctx->sub->surf[i])\n            mask |= (1 << i);\n      }\n      if (mask != (buffers >> 2)) {\n         mask = buffers >> 2;\n         while (mask) {\n            i = u_bit_scan(&mask);\n            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))\n               glClearBufferuiv(GL_COLOR,\n                                i, (GLuint *)color);\n            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))\n               glClearBufferiv(GL_COLOR,\n                                i, (GLint *)color);\n            else\n               glClearBufferfv(GL_COLOR,\n                                i, (GLfloat *)color);\n         }\n      }\n      else\n         bits |= GL_COLOR_BUFFER_BIT;\n   }\n   if (buffers & PIPE_CLEAR_DEPTH)\n      bits |= GL_DEPTH_BUFFER_BIT;\n   if (buffers & PIPE_CLEAR_STENCIL)\n      bits |= GL_STENCIL_BUFFER_BIT;\n\n   if (bits)\n      glClear(bits);\n\n   if (buffers & PIPE_CLEAR_DEPTH)\n      if (!ctx->sub->dsa_state.depth.writemask)\n         glDepthMask(GL_FALSE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8959, "func": "size_t net_tx_pkt_get_total_len(struct NetTxPkt *pkt)\n{\n    assert(pkt);\n\n    return pkt->hdr_len + pkt->payload_len;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187938, "func": "static int vol_prc_lib_release(effect_handle_t handle)\n{\n\n     struct listnode *node, *temp_node_next;\n     vol_listener_context_t *context = NULL;\n     vol_listener_context_t *recv_contex = (vol_listener_context_t *)handle;\n    int status = -1;\n     bool recompute_flag = false;\n     int active_stream_count = 0;\n     ALOGV(\"%s context %p\", __func__, handle);\n     pthread_mutex_lock(&vol_listner_init_lock);\n \n     list_for_each_safe(node, temp_node_next, &vol_effect_list) {\n         context = node_to_item(node, struct vol_listener_context_s, effect_list_node);\n        if ((memcmp(&(context->desc->uuid), &(recv_contex->desc->uuid), sizeof(effect_uuid_t)) == 0)\n            && (context->session_id == recv_contex->session_id)\n            && (context->stream_type == recv_contex->stream_type)) {\n             ALOGV(\"--- Found something to remove ---\");\n            list_remove(&context->effect_list_node);\n             PRINT_STREAM_TYPE(context->stream_type);\n             if (context->dev_id && AUDIO_DEVICE_OUT_SPEAKER) {\n                 recompute_flag = true;\n }\n            free(context);\n            status = 0;\n } else {\n ++active_stream_count;\n }\n }\n\n \n     if (status != 0) {\n         ALOGE(\"something wrong ... <<<--- Found NOTHING to remove ... ???? --->>>>>\");\n     }\n \n if (active_stream_count == 0) {\n        current_gain_dep_cal_level = -1;\n        current_vol = 0.0;\n }\n\n if (recompute_flag) {\n        check_and_set_gain_dep_cal();\n }\n\n if (dumping_enabled) {\n        dump_list_l();\n }\n    pthread_mutex_unlock(&vol_listner_init_lock);\n return status;\n}\n", "target": 1, "flaw_line_index": "7,16,17,18,20"}
{"idx": 187749, "func": " main(void)\n {\n unsigned int i;\n unsigned char buf[MAX_LENGTH];\n unsigned long crc;\n unsigned char c;\n int inchar;\n\n\n    for (i=8; i; i--)\n    {\n      c=GETBREAK;\n       putchar(c);\n    }\n \nif (inchar != EOF)\n for (;;)\n  {\n    unsigned long length; \n   c=GETBREAK; buf[0] = c; length  = c; length <<= 8;\n   c=GETBREAK; buf[1] = c; length += c; length <<= 8;\n   c=GETBREAK; buf[2] = c; length += c; length <<= 8;\n   c=GETBREAK; buf[3] = c; length += c;\n \n   c=GETBREAK; buf[4] = c;\n   c=GETBREAK; buf[5] = c;\n   c=GETBREAK; buf[6] = c;\n   c=GETBREAK; buf[7] = c;\n \n \n if (buf[4] == 105 && buf[5] == 84 && buf[6] == 88 && buf[7] == 116)\n {\n if (length >= MAX_LENGTH-12)\n break; \n\n      crc = crc32(0, Z_NULL, 0);\n\n\n       for (i=8; i < length + 12; i++)\n       {\n         c=GETBREAK; buf[i] = c;\n       }\n \n       crc = crc32(crc, buf+4, (uInt)length+4);\n \n       for (;;)\n       {\n        if (((crc >> 24) & 0xff) == buf[length+8] &&\n            ((crc >> 16) & 0xff) == buf[length+9] &&\n            ((crc >>  8) & 0xff) == buf[length+10] &&\n            ((crc      ) & 0xff) == buf[length+11])\n            break;\n \n         length++;\n\n\n         if (length >= MAX_LENGTH-12)\n            break;\n \n        c=GETBREAK;\n        buf[length+11]=c;\n \n         crc = crc32(crc, buf+7+length, 1);\n       }\n \n      buf[0] = (unsigned char)((length << 24) & 0xff);\n      buf[1] = (unsigned char)((length << 16) & 0xff);\n      buf[2] = (unsigned char)((length <<  8) & 0xff);\n      buf[3] = (unsigned char)((length      ) & 0xff);\n \n       for (i=0; i<length+12; i++)\n         putchar(buf[i]);\n }\n\n \n    else\n    {\n       for (i=0; i<8; i++)\n          putchar(buf[i]);\n\n\n       for (i=8; i< length+12; i++)\n       {\n         c=GETBREAK;\n          putchar(c);\n       }\n \n      if (inchar == EOF)\n       {\n          break;\n       }\n\n if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)\n\n          break;\n    }\n \n   if (inchar == EOF)\n       break;\n \n    if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)\n break;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "12,16,20,21,22,23,25,26,27,28,41,48,49,50,51,60,61,66,67,68,69,84,88,98"}
{"idx": 9186, "func": "void virtio_config_modern_writew(VirtIODevice *vdev,\n                                 uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stw_le_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188039, "func": " static void copyMono8(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned \n) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i] << 8;\n }\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8585, "func": "static void ssh_queue_incoming_data(Ssh ssh,\n\t\t\t\t    const unsigned char **data, int *datalen)\n{\n    bufchain_add(&ssh->queued_incoming_data, *data, *datalen);\n    *data += *datalen;\n    *datalen = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188234, "func": "OMX_ERRORTYPE SoftMP3::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.mp3\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (const OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSamplingRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187589, "func": "int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight)\n{\n    uch sig[8];\n\n\n\n    fread(sig, 1, 8, infile);\n if (png_sig_cmp(sig, 0, 8))\n return 1; \n\n\n \n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n     if (!png_ptr)\n         return 4;   \n \n    info_ptr = png_create_info_struct(png_ptr);\n if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n return 4; \n }\n\n\n\n\n\n if (setjmp(png_jmpbuf(png_ptr))) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n return 2;\n }\n\n\n    png_init_io(png_ptr, infile);\n    png_set_sig_bytes(png_ptr, 8); \n\n    png_read_info(png_ptr, info_ptr); \n\n\n\n    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\n      NULL, NULL, NULL);\n *pWidth = width;\n *pHeight = height;\n\n\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 188244, "func": "OMX_ERRORTYPE SimpleSoftOMXComponent::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()\n                     || defParams->nSize\n                             != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUndefined;\n }\n\n const PortInfo *port =\n &mPorts.itemAt(defParams->nPortIndex);\n\n            memcpy(defParams, &port->mDef, sizeof(port->mDef));\n\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187652, "func": " image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    return image_transform_png_set_expand_add(this, that, colour_type,\n       bit_depth);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187539, "func": "void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n \n     if (NULL == mCodecCtx) {\n         if (OK != initDecoder()) {\n             return;\n         }\n     }\n if (outputBufferWidth() != mStride) {\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n            WORD32 timeDelay, timeTaken;\n size_t sizeY, sizeUV;\n\n if (!setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx)) {\n                ALOGE(\"Decoder arg setup failed\");\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            GETTIME(&mTimeStart, NULL);\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n\n             IV_API_CALL_STATUS_T status;\n             status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n \n             bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n \n             GETTIME(&mTimeEnd, NULL);\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n                mIsInFlush = false;\n\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187746, "func": "void usage()\n{\n  fprintf (stderr, \"PNG2PNM\\n\");\n  fprintf (stderr, \"   by Willem van Schaik, 1999\\n\");\n#ifdef __TURBOC__\n  fprintf (stderr, \"   for Turbo-C and Borland-C compilers\\n\");\n#else\n  fprintf (stderr, \"   for Linux (and Unix) compilers\\n\");\n#endif\n\n   fprintf (stderr, \"Usage:  png2pnm [options] <file>.png [<file>.pnm]\\n\");\n   fprintf (stderr, \"   or:  ... | png2pnm [options]\\n\");\n   fprintf (stderr, \"Options:\\n\");\n  fprintf (stderr, \"   -r[aw]   write pnm-file in binary format (P4/P5/P6) (default)\\n\");\n   fprintf (stderr, \"   -n[oraw] write pnm-file in ascii format (P1/P2/P3)\\n\");\n  fprintf (stderr, \"   -a[lpha] <file>.pgm write PNG alpha channel as pgm-file\\n\");\n   fprintf (stderr, \"   -h | -?  print this help-information\\n\");\n }\n", "target": 1, "flaw_line_index": "14,16"}
{"idx": 8378, "func": "static void mptsas_register_types(void)\n{\n    type_register(&mptsas_info);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187367, "func": "int Downmix_Reset(downmix_object_t *pDownmixer, bool init) {\n     return 0;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188148, "func": "     BufferMeta(const sp<GraphicBuffer> &graphicBuffer, OMX_U32 portIndex)\n         : mGraphicBuffer(graphicBuffer),\n          mIsBackup(false),\n          mPortIndex(portIndex) {\n     }\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 187661, "func": "image_transform_png_set_palette_to_rgb_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n       image_pixel_convert_PLTE(that);\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 9214, "func": "hwaddr virtio_queue_get_avail_size(VirtIODevice *vdev, int n)\n{\n    return offsetof(VRingAvail, ring) +\n        sizeof(uint16_t) * vdev->vq[n].vring.num;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8554, "func": "static int ssh_channelcmp(void *av, void *bv)\n{\n    struct ssh_channel *a = (struct ssh_channel *) av;\n    struct ssh_channel *b = (struct ssh_channel *) bv;\n    if (a->localid < b->localid)\n\treturn -1;\n    if (a->localid > b->localid)\n\treturn +1;\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187516, "func": "BOOLEAN UIPC_Send(tUIPC_CH_ID ch_id, UINT16 msg_evt, UINT8 *p_buf,\n        UINT16 msglen)\n{\n    UNUSED(msg_evt);\n\n    BTIF_TRACE_DEBUG(\"UIPC_Send : ch_id:%d %d bytes\", ch_id, msglen);\n\n \n     UIPC_LOCK();\n \n    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)\n     {\n         BTIF_TRACE_ERROR(\"failed to write (%s)\", strerror(errno));\n     }\n\n    UIPC_UNLOCK();\n\n return FALSE;\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 8641, "func": "size_t mptsas_config_io_unit_4(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(4, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x00, \"*l*l*q\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8720, "func": "X509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,\n                        EVP_PKEY *skey, const EVP_MD *md, unsigned int flags)\n{\n    X509_CRL *crl = NULL;\n    int i;\n    STACK_OF(X509_REVOKED) *revs = NULL;\n    if (base->base_crl_number || newer->base_crl_number) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_ALREADY_DELTA);\n        return NULL;\n    }\n    if (!base->crl_number || !newer->crl_number) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_NO_CRL_NUMBER);\n        return NULL;\n    }\n    if (X509_NAME_cmp(X509_CRL_get_issuer(base), X509_CRL_get_issuer(newer))) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_ISSUER_MISMATCH);\n        return NULL;\n    }\n    if (!crl_extension_match(base, newer, NID_authority_key_identifier)) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_AKID_MISMATCH);\n        return NULL;\n    }\n    if (!crl_extension_match(base, newer, NID_issuing_distribution_point)) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_IDP_MISMATCH);\n        return NULL;\n    }\n    if (ASN1_INTEGER_cmp(newer->crl_number, base->crl_number) <= 0) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_NEWER_CRL_NOT_NEWER);\n        return NULL;\n    }\n    if (skey && (X509_CRL_verify(base, skey) <= 0 ||\n                 X509_CRL_verify(newer, skey) <= 0)) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_VERIFY_FAILURE);\n        return NULL;\n    }\n    crl = X509_CRL_new();\n    if (!crl || !X509_CRL_set_version(crl, 1))\n        goto memerr;\n    if (!X509_CRL_set_issuer_name(crl, X509_CRL_get_issuer(newer)))\n        goto memerr;\n\n    if (!X509_CRL_set_lastUpdate(crl, X509_CRL_get_lastUpdate(newer)))\n        goto memerr;\n    if (!X509_CRL_set_nextUpdate(crl, X509_CRL_get_nextUpdate(newer)))\n        goto memerr;\n\n\n    if (!X509_CRL_add1_ext_i2d(crl, NID_delta_crl, base->crl_number, 1, 0))\n        goto memerr;\n\n\n    for (i = 0; i < X509_CRL_get_ext_count(newer); i++) {\n        X509_EXTENSION *ext;\n        ext = X509_CRL_get_ext(newer, i);\n        if (!X509_CRL_add_ext(crl, ext, -1))\n            goto memerr;\n    }\n\n\n    revs = X509_CRL_get_REVOKED(newer);\n\n    for (i = 0; i < sk_X509_REVOKED_num(revs); i++) {\n        X509_REVOKED *rvn, *rvtmp;\n        rvn = sk_X509_REVOKED_value(revs, i);\n        if (!X509_CRL_get0_by_serial(base, &rvtmp, rvn->serialNumber)) {\n            rvtmp = X509_REVOKED_dup(rvn);\n            if (!rvtmp)\n                goto memerr;\n            if (!X509_CRL_add0_revoked(crl, rvtmp)) {\n                X509_REVOKED_free(rvtmp);\n                goto memerr;\n            }\n        }\n    }\n\n    if (skey && md && !X509_CRL_sign(crl, skey, md))\n        goto memerr;\n\n    return crl;\n\n memerr:\n    X509err(X509_F_X509_CRL_DIFF, ERR_R_MALLOC_FAILURE);\n    if (crl)\n        X509_CRL_free(crl);\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188118, "func": " static Maybe<bool> IncludesValueImpl(Isolate* isolate,\n Handle<JSObject> receiver,\n Handle<Object> value,\n uint32_t start_from, uint32_t length) {\n    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n bool search_for_hole = value->IsUndefined(isolate);\n\n if (!search_for_hole) {\n Maybe<bool> result = Nothing<bool>();\n if (DictionaryElementsAccessor::IncludesValueFastPath(\n              isolate, receiver, value, start_from, length, &result)) {\n\n         return result;\n       }\n     }\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     for (uint32_t k = start_from; k < length; ++k) {\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n continue;\n }\n\n PropertyDetails details = GetDetailsImpl(*dictionary, entry);\n switch (details.kind()) {\n case kData: {\n Object* element_k = dictionary->ValueAt(entry);\n if (value->SameValueZero(element_k)) return Just(true);\n break;\n }\n case kAccessor: {\n LookupIterator it(isolate, receiver, k,\n LookupIterator::OWN_SKIP_INTERCEPTOR);\n          DCHECK(it.IsFound());\n          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n Handle<Object> element_k;\n\n          ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),\n Nothing<bool>());\n\n if (value->SameValueZero(*element_k)) return Just(true);\n\n if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {\n return IncludesValueSlowPath(isolate, receiver, value, k + 1,\n                                         length);\n }\n\n if (*dictionary == receiver->elements()) continue;\n\n if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {\n if (receiver->map()->GetInitialElements() == receiver->elements()) {\n return Just(search_for_hole);\n }\n return IncludesValueSlowPath(isolate, receiver, value, k + 1,\n                                         length);\n }\n          dictionary = handle(\n SeededNumberDictionary::cast(receiver->elements()), isolate);\n break;\n }\n }\n }\n return Just(false);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187658, "func": "image_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n \n    if (that->colour_type == PNG_COLOR_TYPE_GRAY)\n {\n if (that->bit_depth < 8)\n         that->sample_depth = that->bit_depth = 8;\n\n      that->colour_type = PNG_COLOR_TYPE_RGB;\n }\n\n else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "3,6"}
{"idx": 187394, "func": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n if (parcel == NULL) {\n SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n return NULL;\n }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n const bool        isMutable = p->readInt32() != 0;\n const SkColorType colorType = (SkColorType)p->readInt32();\n const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n const int         width = p->readInt32();\n const int         height = p->readInt32();\n const int         rowBytes = p->readInt32();\n const int         density = p->readInt32();\n\n if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n\n         return NULL;\n     }\n \n    SkBitmap* bitmap = new SkBitmap;\n \n    bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes);\n \n     SkColorTable* ctable = NULL;\n     if (colorType == kIndex_8_SkColorType) {\n         int count = p->readInt32();\n         if (count > 0) {\n             size_t size = count * sizeof(SkPMColor);\n             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n             ctable = new SkColorTable(src, count);\n         }\n     }\n \n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);\n     if (NULL == buffer) {\n         SkSafeUnref(ctable);\n        delete bitmap;\n         return NULL;\n     }\n \n SkSafeUnref(ctable);\n\n size_t size = bitmap->getSize();\n\n    android::Parcel::ReadableBlob blob;\n\n     android::status_t status = p->readBlob(size, &blob);\n     if (status) {\n         doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n        delete bitmap;\n         return NULL;\n     }\n \n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n\n \n     blob.release();\n \n    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),\n            NULL, NULL, density);\n }\n", "target": 1, "flaw_line_index": "27,29,41,44,57,68,69"}
{"idx": 8463, "func": "MODCOMMAND *CSoundFile::AllocatePattern(UINT rows, UINT nchns)\n{\n\tMODCOMMAND *p = new MODCOMMAND[rows*nchns];\n\tif (p) memset(p, 0, rows*nchns*sizeof(MODCOMMAND));\n\treturn p;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187910, "func": "FLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_VorbisComment *obj, unsigned length)\n{\n\tFLAC__uint32 i;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n if (length >= 8) {\n\t\tlength -= 8; \n\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);\n if (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->vendor_string.length))\n return false; \n if (obj->vendor_string.length > 0) {\n if (length < obj->vendor_string.length) {\n\t\t\t\tobj->vendor_string.length = 0;\n\t\t\t\tobj->vendor_string.entry = 0;\n goto skip;\n }\n else\n\t\t\t\tlength -= obj->vendor_string.length;\n if (0 == (obj->vendor_string.entry = safe_malloc_add_2op_(obj->vendor_string.length, \n1))) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n return false;\n }\n if (!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->vendor_string.entry, obj->vendor_string.length))\n return false; \n\t\t\tobj->vendor_string.entry[obj->vendor_string.length] = '\\0';\n }\n else\n\t\t\tobj->vendor_string.entry = 0;\n\n\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN == 32);\n if (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->num_comments))\n return false; \n\n if (obj->num_comments > 100000) {\n\t\t\tobj->num_comments = 0;\n return false;\n }\n\n \t\tif (obj->num_comments > 0) {\n \t\t\tif (0 == (obj->comments = safe_malloc_mul_2op_p(obj->num_comments, \nsizeof(FLAC__StreamMetadata_VorbisComment_Entry)))) {\n \t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tfor (i = 0; i < obj->num_comments; i++) {\n\t\t\t\tobj->comments[i].length = 0;\n\t\t\t\tobj->comments[i].entry = 0;\n\n\t\t\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);\n if (length < 4) {\n\t\t\t\t\tobj->num_comments = i;\n goto skip;\n }\n else\n\t\t\t\t\tlength -= 4;\n if (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->comments[i].length))\n return false; \n if (obj->comments[i].length > 0) {\n if (length < obj->comments[i].length) {\n\t\t\t\t\t\tobj->num_comments = i;\n goto skip;\n }\n else\n\t\t\t\t\t\tlength -= obj->comments[i].length;\n if (0 == (obj->comments[i].entry = safe_malloc_add_2op_(obj->comments[i].length, \n1))) {\n\t\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n return false;\n }\n\t\t\t\t\tmemset (obj->comments[i].entry, 0, obj->comments[i].length) ;\n if (!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->comments[i].entry, obj->comments[i].length)) {\n\t\t\t\t\t\tobj->num_comments = i;\n goto skip;\n }\n\t\t\t\t\tobj->comments[i].entry[obj->comments[i].length] = '\\0';\n }\n else\n\t\t\t\t\tobj->comments[i].entry = 0;\n }\n }\n else\n\t\t\tobj->comments = 0;\n }\n\n  skip:\n if (length > 0) {\n if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))\n return false; \n }\n\n return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188130, "func": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n\n if (flags & 1) {\n\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n\n            flags &= ~1;\n }\n\n if ((flags & 2) && (dataSize >= 2)) {\n\n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n\n                     --mSize;\n                     --dataSize;\n                 }\n                mData[writeOffset++] = mData[readOffset++];\n             }\n             if (readOffset <= oldSize) {\n                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n } else {\n                ALOGE(\"b/34618607 (%zu %zu %zu %zu)\", readOffset, writeOffset, oldSize, mSize);\n                android_errorWriteLog(0x534e4554, \"34618607\");\n }\n\n }\n        flags &= ~2;\n if (flags != prevFlags || iTunesHack) {\n WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n            mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n\n        offset += 10 + dataSize;\n }\n\n    memset(&mData[mSize], 0, oldSize - mSize);\n\n return true;\n}\n", "target": 1, "flaw_line_index": "51"}
{"idx": 8725, "func": "static int check_cert(X509_STORE_CTX *ctx)\n{\n    X509_CRL *crl = NULL, *dcrl = NULL;\n    X509 *x;\n    int ok, cnum;\n    unsigned int last_reasons;\n    cnum = ctx->error_depth;\n    x = sk_X509_value(ctx->chain, cnum);\n    ctx->current_cert = x;\n    ctx->current_issuer = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n    if (x->ex_flags & EXFLAG_PROXY)\n        return 1;\n    while (ctx->current_reasons != CRLDP_ALL_REASONS) {\n        last_reasons = ctx->current_reasons;\n        if (ctx->get_crl)\n            ok = ctx->get_crl(ctx, &crl, x);\n        else\n            ok = get_crl_delta(ctx, &crl, &dcrl, x);\n        if (!ok) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n        ctx->current_crl = crl;\n        ok = ctx->check_crl(ctx, crl);\n        if (!ok)\n            goto err;\n\n        if (dcrl) {\n            ok = ctx->check_crl(ctx, dcrl);\n            if (!ok)\n                goto err;\n            ok = ctx->cert_crl(ctx, dcrl, x);\n            if (!ok)\n                goto err;\n        } else\n            ok = 1;\n\n        if (ok != 2) {\n            ok = ctx->cert_crl(ctx, crl, x);\n            if (!ok)\n                goto err;\n        }\n\n        X509_CRL_free(crl);\n        X509_CRL_free(dcrl);\n        crl = NULL;\n        dcrl = NULL;\n        if (last_reasons == ctx->current_reasons) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n    }\n err:\n    X509_CRL_free(crl);\n    X509_CRL_free(dcrl);\n\n    ctx->current_crl = NULL;\n    return ok;\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9040, "func": "static void vmxnet3_qdev_reset(DeviceState *dev)\n{\n    PCIDevice *d = PCI_DEVICE(dev);\n    VMXNET3State *s = VMXNET3(d);\n\n    VMW_CBPRN(\"Starting QDEV reset...\");\n    vmxnet3_reset(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187952, "func": "static future_t *init(void) {\n  pthread_mutex_init(&lock, NULL);\n  config = config_new(CONFIG_FILE_PATH);\n if (!config) {\n    LOG_WARN(LOG_TAG, \"%s unable to load config file; attempting to transcode legacy file.\", __func__);\n    config = btif_config_transcode(LEGACY_CONFIG_FILE_PATH);\n if (!config) {\n      LOG_WARN(LOG_TAG, \"%s unable to transcode legacy file, starting unconfigured.\", __func__);\n      config = config_new_empty();\n if (!config) {\n        LOG_ERROR(LOG_TAG, \"%s unable to allocate a config object.\", __func__);\n goto error;\n }\n }\n\n if (config_save(config, CONFIG_FILE_PATH))\n\n       unlink(LEGACY_CONFIG_FILE_PATH);\n   }\n \n  alarm_timer = alarm_new();\n if (!alarm_timer) {\n    LOG_ERROR(LOG_TAG, \"%s unable to create alarm.\", __func__);\n goto error;\n }\n\n return future_new_immediate(FUTURE_SUCCESS);\n\nerror:;\n  alarm_free(alarm_timer);\n  config_free(config);\n  pthread_mutex_destroy(&lock);\n  alarm_timer = NULL;\n  config = NULL;\n return future_new_immediate(FUTURE_FAIL);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8493, "func": "void CSoundFile::SetAGC(BOOL b)\n{\n\tif (b)\n\t{\n\t\tif (!(gdwSoundSetup & SNDMIX_AGC))\n\t\t{\n\t\t\tgdwSoundSetup |= SNDMIX_AGC;\n\t\t\tgnAGC = AGC_UNITY;\n\t\t}\n\t} else gdwSoundSetup &= ~SNDMIX_AGC;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9172, "func": "static int get_extra_state(QEMUFile *f, void *pv, size_t size)\n{\n    VirtIODevice *vdev = pv;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (!k->load_extra_state) {\n        return -1;\n    } else {\n        return k->load_extra_state(qbus->parent, f);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8478, "func": "UINT CSoundFile::GetInstrumentName(UINT nInstr,LPSTR s) const\n{\n        char sztmp[40] = \"\";  \n\tif ((nInstr >= MAX_INSTRUMENTS) || (!Headers[nInstr]))\n\t{\n\t\tif (s) *s = 0;\n\t\treturn 0;\n\t}\n\tINSTRUMENTHEADER *penv = Headers[nInstr];\n\tmemcpy(sztmp, penv->name, 32);\n\tsztmp[31] = 0;\n\tif (s) strcpy(s, sztmp);\n\treturn strlen(sztmp);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188199, "func": "void SoftAVC::drainOneOutputBuffer(int32_t picId, uint8_t* data) {\n     List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n     BufferInfo *outInfo = *outQueue.begin();\n    outQueue.erase(outQueue.begin());\n     OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n     OMX_BUFFERHEADERTYPE *header = mPicToHeaderMap.valueFor(picId);\n     outHeader->nTimeStamp = header->nTimeStamp;\n     outHeader->nFlags = header->nFlags;\n    outHeader->nFilledLen = mWidth * mHeight * 3 / 2;\n \n     uint8_t *dst = outHeader->pBuffer + outHeader->nOffset;\n     const uint8_t *srcY = data;\n const uint8_t *srcU = srcY + mWidth * mHeight;\n const uint8_t *srcV = srcU + mWidth * mHeight / 4;\n size_t srcYStride = mWidth;\n size_t srcUStride = mWidth / 2;\n size_t srcVStride = srcUStride;\n    copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);\n\n    mPicToHeaderMap.removeItem(picId);\n\n     delete header;\n     outInfo->mOwnedByUs = false;\n     notifyFillBufferDone(outHeader);\n }\n", "target": 1, "flaw_line_index": "4,9"}
{"idx": 8931, "func": "void vrend_set_blend_color(struct vrend_context *ctx,\n                           struct pipe_blend_color *color)\n{\n   ctx->sub->blend_color = *color;\n   glBlendColor(color->color[0], color->color[1], color->color[2],\n                color->color[3]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8612, "func": "static uint32_t vmsvga_index_read(void *opaque, uint32_t address)\n{\n    struct vmsvga_state_s *s = opaque;\n\n    return s->index;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187739, "func": "transform_test(png_modifier *pmIn, PNG_CONST png_uint_32 idIn,\n    PNG_CONST image_transform* transform_listIn, PNG_CONST char * volatile name)\n {\n    transform_display d;\n    context(&pmIn->this, fault);\n\n   transform_display_init(&d, pmIn, idIn, transform_listIn);\n\n Try\n {\n size_t pos = 0;\n      png_structp pp;\n      png_infop pi;\n char full_name[256];\n\n      transform_set_encoding(&d);\n\n      d.transform_list->ini(d.transform_list, &d);\n\n      pos = safecat(full_name, sizeof full_name, pos, name);\n      pos = safecat_current_encoding(full_name, sizeof full_name, pos, d.pm);\n\n      pp = set_modifier_for_read(d.pm, &pi, d.this.id, full_name);\n      standard_palette_init(&d.this);\n\n#     if 0\n {\n char buffer[256];\n\n (void)store_message(&d.pm->this, pp, buffer, sizeof buffer, 0,\n \"running test\");\n\n            fprintf(stderr, \"%s\\n\", buffer);\n }\n#     endif\n\n if (d.pm->this.progressive)\n {\n         png_set_progressive_read_fn(pp, &d, transform_info, progressive_row,\n            transform_end);\n\n         modifier_progressive_read(d.pm, pp, pi);\n }\n else\n {\n         png_set_read_fn(pp, d.pm, modifier_read);\n\n         png_read_info(pp, pi);\n\n         transform_info_imp(&d, pp, pi);\n\n         sequential_row(&d.this, pp, pi, -1, 0);\n\n if (!d.this.speed)\n            transform_image_validate(&d, pp, pi);\n else\n            d.this.ps->validated = 1;\n }\n\n      modifier_reset(d.pm);\n }\n\n Catch(fault)\n {\n      modifier_reset(voidcast(png_modifier*,(void*)fault));\n }\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8512, "func": "static void defer_packet(Ssh ssh, int pkttype, ...)\n{\n    struct Packet *pkt;\n    va_list ap;\n    va_start(ap, pkttype);\n    pkt = construct_packet(ssh, pkttype, ap);\n    va_end(ap);\n    s_wrpkt_defer(ssh, pkt);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9165, "func": "static void blitter_set_rectangle(struct vrend_blitter_ctx *blit_ctx,\n                                  int x1, int y1, int x2, int y2,\n                                  float depth)\n{\n   int i;\n\n   blit_ctx->vertices[0][0][0] = (float)x1 / blit_ctx->dst_width * 2.0f - 1.0f; \n   blit_ctx->vertices[0][0][1] = (float)y1 / blit_ctx->dst_height * 2.0f - 1.0f; \n\n   blit_ctx->vertices[1][0][0] = (float)x2 / blit_ctx->dst_width * 2.0f - 1.0f; \n   blit_ctx->vertices[1][0][1] = (float)y1 / blit_ctx->dst_height * 2.0f - 1.0f; \n\n   blit_ctx->vertices[2][0][0] = (float)x2 / blit_ctx->dst_width * 2.0f - 1.0f; \n   blit_ctx->vertices[2][0][1] = (float)y2 / blit_ctx->dst_height * 2.0f - 1.0f; \n\n   blit_ctx->vertices[3][0][0] = (float)x1 / blit_ctx->dst_width * 2.0f - 1.0f; \n   blit_ctx->vertices[3][0][1] = (float)y2 / blit_ctx->dst_height * 2.0f - 1.0f; \n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][2] = depth; \n\n   glViewport(0, 0, blit_ctx->dst_width, blit_ctx->dst_height);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9118, "func": "static int vrend_decode_set_polygon_stipple(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_poly_stipple ps;\n   int i;\n\n   if (length != VIRGL_POLYGON_STIPPLE_SIZE)\n      return EINVAL;\n\n   for (i = 0; i < 32; i++)\n      ps.stipple[i] = get_buf_entry(ctx, VIRGL_POLYGON_STIPPLE_P0 + i);\n\n   vrend_set_polygon_stipple(ctx->grctx, &ps);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187860, "func": " long Chapters::Parse() {\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = m_start; \n const long long stop = pos + m_size; \n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (size == 0) \n continue;\n\n if (id == 0x05B9) { \n      status = ParseEdition(pos, size);\n\n if (status < 0) \n return status;\n\n     }\n \n     pos += size;\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n   return 0;\n }\n", "target": 1, "flaw_line_index": "27,30"}
{"idx": 188163, "func": "status_t OMXNodeInstance::updateGraphicBufferInMeta(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n\n     return updateGraphicBufferInMeta_l(\n             portIndex, graphicBuffer, buffer, header,\n            portIndex == kPortIndexOutput \n);\n }\n", "target": 1, "flaw_line_index": "11"}
{"idx": 9213, "func": "hwaddr virtio_queue_get_avail_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.avail;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188560, "func": " void EncoderTest::InitializeConfig() {\n   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);\n   ASSERT_EQ(VPX_CODEC_OK, res);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8482, "func": "UINT CSoundFile::GetNumPatterns() const\n{\n\tUINT i = 0;\n\twhile ((i < MAX_ORDERS) && (Order[i] < 0xFF)) i++;\n\treturn i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187595, "func": "int main(int argc, char **argv)\n{\n#ifdef sgi\n char tmpline[80];\n#endif\n char *p;\n int rc, alen, flen;\n int error = 0;\n int have_bg = FALSE;\n double LUT_exponent; \n double CRT_exponent = 2.2; \n double default_display_exponent; \n XEvent e;\n KeySym k;\n\n\n    displayname = (char *)NULL;\n    filename = (char *)NULL;\n\n\n\n#if defined(NeXT)\n    LUT_exponent = 1.0 / 2.2;\n#elif defined(sgi)\n    LUT_exponent = 1.0 / 1.7;\n    infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");\n if (infile) {\n double sgi_gamma;\n\n        fgets(tmpline, 80, infile);\n        fclose(infile);\n        sgi_gamma = atof(tmpline);\n if (sgi_gamma > 0.0)\n            LUT_exponent = 1.0 / sgi_gamma;\n }\n#elif defined(Macintosh)\n    LUT_exponent = 1.8 / 2.61;\n#else\n    LUT_exponent = 1.0; \n#endif\n\n    default_display_exponent = LUT_exponent * CRT_exponent;\n\n\n\n if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)\n        display_exponent = atof(p);\n else\n        display_exponent = default_display_exponent;\n\n\n\n while (*++argv && !error) {\n if (!strncmp(*argv, \"-display\", 2)) {\n if (!*++argv)\n ++error;\n else\n                displayname = *argv;\n } else if (!strncmp(*argv, \"-gamma\", 2)) {\n if (!*++argv)\n ++error;\n else {\n                display_exponent = atof(*argv);\n if (display_exponent <= 0.0)\n ++error;\n }\n } else if (!strncmp(*argv, \"-bgcolor\", 2)) {\n if (!*++argv)\n ++error;\n else {\n                bgstr = *argv;\n if (strlen(bgstr) != 7 || bgstr[0] != '#')\n ++error;\n else\n                    have_bg = TRUE;\n }\n } else {\n if (**argv != '-') {\n                filename = *argv;\n if (argv[1]) \n ++error;\n } else\n ++error; \n }\n }\n\n if (!filename)\n ++error;\n\n\n\n if (error) {\n        fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, appname);\n        readpng_version_info();\n        fprintf(stderr, \"\\n\"\n\n           \"Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg] file.png\\n\"\n           \"    xdpy\\tname of the target X display (e.g., ``hostname:0'')\\n\"\n           \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"\n          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"\n           \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"\n           \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"\n           \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"\n           \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"\n           \"\\t\\t  used with transparent images\\n\"\n           \"\\nPress Q, Esc or mouse button 1 (within image window, after image\\n\"\n          \"is displayed) to quit.\\n\"\n          \"\\n\", PROGNAME, default_display_exponent);\n         exit(1);\n     }\n \n\n if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);\n ++error;\n } else {\n if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {\n switch (rc) {\n case 1:\n                    fprintf(stderr, PROGNAME\n \":  [%s] is not a PNG file: incorrect signature\\n\",\n                      filename);\n break;\n case 2:\n                    fprintf(stderr, PROGNAME\n \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);\n break;\n case 4:\n                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");\n break;\n default:\n                    fprintf(stderr, PROGNAME\n \":  unknown readpng_init() error\\n\");\n break;\n }\n ++error;\n } else {\n            display = XOpenDisplay(displayname);\n if (!display) {\n                readpng_cleanup(TRUE);\n                fprintf(stderr, PROGNAME \":  can't open X display [%s]\\n\",\n                  displayname? displayname : \"default\");\n ++error;\n }\n }\n if (error)\n            fclose(infile);\n }\n\n\n if (error) {\n        fprintf(stderr, PROGNAME \":  aborting.\\n\");\n        exit(2);\n }\n\n\n\n    alen = strlen(appname);\n    flen = strlen(filename);\n if (alen + flen + 3 > 1023)\n        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));\n else\n        sprintf(titlebar, \"%s:  %s\", appname, filename);\n\n\n\n if (have_bg) {\n unsigned r, g, b; \n\n        sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);\n        bg_red   = (uch)r;\n        bg_green = (uch)g;\n        bg_blue  = (uch)b;\n } else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {\n        readpng_cleanup(TRUE);\n        fprintf(stderr, PROGNAME\n \":  libpng error while checking for background color\\n\");\n        exit(2);\n }\n\n\n\n if (rpng_x_create_window())\n        exit(2);\n\n\n\n Trace((stderr, \"calling readpng_get_image()\\n\"))\n    image_data = readpng_get_image(display_exponent, &image_channels,\n &image_rowbytes);\n Trace((stderr, \"done with readpng_get_image()\\n\"))\n\n\n\n    readpng_cleanup(FALSE);\n    fclose(infile);\n\n if (!image_data) {\n        fprintf(stderr, PROGNAME \":  unable to decode PNG image\\n\");\n        exit(3);\n }\n\n\n\n Trace((stderr, \"calling rpng_x_display_image()\\n\"))\n if (rpng_x_display_image()) {\n        free(image_data);\n        exit(4);\n }\n Trace((stderr, \"done with rpng_x_display_image()\\n\"))\n\n\n\n    printf(\n \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\");\n    fflush(stdout);\n\n do\n XNextEvent(display, &e);\n while (!(e.type == ButtonPress && e.xbutton.button == Button1) &&\n !(e.type == KeyPress && \n ((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape) ));\n\n\n\n \n     rpng_x_cleanup();\n \n     return 0;\n }\n", "target": 1, "flaw_line_index": "100,107,108"}
{"idx": 8434, "func": "pvscsi_pre_save(void *opaque)\n{\n    PVSCSIState *s = (PVSCSIState *) opaque;\n\n    trace_pvscsi_state(\"presave\");\n\n    assert(QTAILQ_EMPTY(&s->pending_queue));\n    assert(QTAILQ_EMPTY(&s->completion_queue));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188594, "func": "   void FillRandom(uint8_t *data, int stride) {\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n       }\n     }\n   }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 188561, "func": "void EncoderTest::MismatchHook(const vpx_image_t *img1,\n                               const vpx_image_t *img2) {\n   ASSERT_TRUE(0) << \"Encode/Decode mismatch found\";\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 188085, "func": "int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n VisualizerContext * pContext = (VisualizerContext *)self;\n int retsize;\n\n if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_init(pContext);\n break;\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL ||\n *replySize != sizeof(effect_config_t)) {\n return -EINVAL;\n }\n Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n Visualizer_reset(pContext);\n break;\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_GET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL ||\n *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {\n return -EINVAL;\n }\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));\n effect_param_t *p = (effect_param_t *)pReplyData;\n        p->status = 0;\n *replySize = sizeof(effect_param_t) + sizeof(uint32_t);\n if (p->psize != sizeof(uint32_t)) {\n            p->status = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case VISUALIZER_PARAM_CAPTURE_SIZE:\n            ALOGV(\"get mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n *((uint32_t *)p->data + 1) = pContext->mCaptureSize;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_SCALING_MODE:\n            ALOGV(\"get mScalingMode = %\" PRIu32, pContext->mScalingMode);\n *((uint32_t *)p->data + 1) = pContext->mScalingMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_MEASUREMENT_MODE:\n            ALOGV(\"get mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n default:\n            p->status = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n return -EINVAL;\n }\n *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {\n *(int32_t *)pReplyData = -EINVAL;\n\n             break;\n         }\n         switch (*(uint32_t *)p->data) {\n        case VISUALIZER_PARAM_CAPTURE_SIZE:\n            pContext->mCaptureSize = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n            break;\n         case VISUALIZER_PARAM_SCALING_MODE:\n             pContext->mScalingMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mScalingMode = %\" PRIu32, pContext->mScalingMode);\n             break;\n        case VISUALIZER_PARAM_LATENCY:\n            pContext->mLatency = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mLatency = %\" PRIu32, pContext->mLatency);\n            break;\n         case VISUALIZER_PARAM_MEASUREMENT_MODE:\n             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n break;\n default:\n *(int32_t *)pReplyData = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n\n case VISUALIZER_CMD_CAPTURE: {\n uint32_t captureSize = pContext->mCaptureSize;\n if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {\n            ALOGV(\"VISUALIZER_CMD_CAPTURE() error *replySize %\" PRIu32 \" captureSize %\" PRIu32,\n *replySize, captureSize);\n return -EINVAL;\n }\n if (pContext->mState == VISUALIZER_STATE_ACTIVE) {\n const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n\n if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&\n (pContext->mBufferUpdateTime.tv_sec != 0) &&\n (deltaMs > MAX_STALL_TIME_MS)) {\n                    ALOGV(\"capture going to idle\");\n                    pContext->mBufferUpdateTime.tv_sec = 0;\n                    memset(pReplyData, 0x80, captureSize);\n } else {\n int32_t latencyMs = pContext->mLatency;\n                latencyMs -= deltaMs;\n\n                 if (latencyMs < 0) {\n                     latencyMs = 0;\n                 }\n                const uint32_t deltaSmpl =\n                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;\n                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;\n \n                 if (capturePoint < 0) {\n                     uint32_t size = -capturePoint;\n                     if (size > captureSize) {\n                        size = captureSize;\n }\n                    memcpy(pReplyData,\n                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,\n                           size);\n                    pReplyData = (char *)pReplyData + size;\n                    captureSize -= size;\n                    capturePoint = 0;\n }\n                memcpy(pReplyData,\n                       pContext->mCaptureBuf + capturePoint,\n                       captureSize);\n }\n\n            pContext->mLastCaptureIdx = pContext->mCaptureIdx;\n } else {\n            memset(pReplyData, 0x80, captureSize);\n }\n\n } break;\n\n case VISUALIZER_CMD_MEASURE: {\n if (pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {\n if (replySize == NULL) {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error replySize NULL\");\n } else {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error *replySize %\" PRIu32\n \" < (sizeof(int32_t) * MEASUREMENT_COUNT) %\" PRIu32,\n *replySize,\n uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);\n }\n            android_errorWriteLog(0x534e4554, \"30229821\");\n return -EINVAL;\n }\n uint16_t peakU16 = 0;\n float sumRmsSquared = 0.0f;\n uint8_t nbValidMeasurements = 0;\n const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {\n            ALOGV(\"Discarding measurements, last measurement is %\" PRId32 \"ms old\", delayMs);\n for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {\n                pContext->mPastMeasurements[i].mIsValid = false;\n                pContext->mPastMeasurements[i].mPeakU16 = 0;\n                pContext->mPastMeasurements[i].mRmsSquared = 0;\n }\n            pContext->mMeasurementBufferIdx = 0;\n } else {\n for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {\n if (pContext->mPastMeasurements[i].mIsValid) {\n if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {\n                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;\n }\n                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;\n                    nbValidMeasurements++;\n }\n }\n }\n float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);\n int32_t* pIntReplyData = (int32_t*)pReplyData;\n if (rms < 0.000016f) {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; \n } else {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));\n }\n if (peakU16 == 0) {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; \n } else {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));\n }\n        ALOGV(\"VISUALIZER_CMD_MEASURE peak=%\" PRIu16 \" (%\" PRId32 \"mB), rms=%.1f (%\" PRId32 \"mB)\",\n                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],\n                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);\n }\n break;\n\n default:\n        ALOGW(\"Visualizer_command invalid command %\" PRIu32, cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "112,113,114,115,120,121,122,123,163,164,165"}
{"idx": 8654, "func": "size_t mptsas_config_manufacturing_6(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(6, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9132, "func": "static void vmxnet_tx_pkt_calculate_hdr_len(struct VmxnetTxPkt *pkt)\n{\n    pkt->hdr_len = pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_len +\n        pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8888, "func": "void vrend_render_condition(struct vrend_context *ctx,\n                            uint32_t handle,\n                            bool condition,\n                            uint mode)\n{\n   struct vrend_query *q;\n   GLenum glmode = 0;\n\n   if (handle == 0) {\n      glEndConditionalRenderNV();\n      ctx->sub->cond_render_q_id = 0;\n      ctx->sub->cond_render_gl_mode = 0;\n      return;\n   }\n\n   q = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_QUERY);\n   if (!q)\n      return;\n\n   switch (mode) {\n   case PIPE_RENDER_COND_WAIT:\n      glmode = GL_QUERY_WAIT;\n      break;\n   case PIPE_RENDER_COND_NO_WAIT:\n      glmode = GL_QUERY_NO_WAIT;\n      break;\n   case PIPE_RENDER_COND_BY_REGION_WAIT:\n      glmode = GL_QUERY_BY_REGION_WAIT;\n      break;\n   case PIPE_RENDER_COND_BY_REGION_NO_WAIT:\n      glmode = GL_QUERY_BY_REGION_NO_WAIT;\n      break;\n   default:\n      fprintf(stderr, \"unhandled condition %x\\n\", mode);\n   }\n\n   ctx->sub->cond_render_q_id = q->id;\n   ctx->sub->cond_render_gl_mode = glmode;\n   glBeginConditionalRender(q->id, glmode);\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8580, "func": "static unsigned long ssh_pkt_getuint32(struct Packet *pkt)\n{\n    unsigned long value;\n    if (pkt->length - pkt->savedpos < 4)\n\treturn 0;\t\t       \n    value = GET_32BIT(pkt->body + pkt->savedpos);\n    pkt->savedpos += 4;\n    return value;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188447, "func": "long ContentEncoding::ParseEncryptionEntry(\n    long long start,\n    long long size,\n    IMkvReader* pReader,\n    ContentEncryption* encryption) {\n   assert(pReader);\n   assert(encryption);\n \n long long pos = start;\n const long long stop = start + size;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  \n       return status;\n \n     if (id == 0x7E1) {\n      encryption->algo = UnserializeUInt(pReader, pos, size);\n if (encryption->algo != 5)\n\n         return E_FILE_FORMAT_INVALID;\n     } else if (id == 0x7E2) {\n      delete[] encryption->key_id;\n       encryption->key_id = NULL;\n       encryption->key_id_len = 0;\n \n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      encryption->key_id = buf;\n\n       encryption->key_id_len = buflen;\n     } else if (id == 0x7E3) {\n      delete[] encryption->signature;\n       encryption->signature = NULL;\n       encryption->signature_len = 0;\n \n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      encryption->signature = buf;\n\n       encryption->signature_len = buflen;\n     } else if (id == 0x7E4) {\n      delete[] encryption->sig_key_id;\n       encryption->sig_key_id = NULL;\n       encryption->sig_key_id_len = 0;\n \n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      encryption->sig_key_id = buf;\n      encryption->sig_key_id_len = buflen;\n } else if (id == 0x7E5) {\n      encryption->sig_algo = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x7E6) {\n      encryption->sig_hash_algo = UnserializeUInt(pReader, pos, size);\n\n     } else if (id == 0x7E7) {\n       const long status = ParseContentEncAESSettingsEntry(\n          pos,\n          size,\n          pReader,\n          &encryption->aes_settings);\n       if (status)\n         return status;\n     }\n \n    pos += size;  \n     assert(pos <= stop);\n   }\n \n   return 0;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,15,16,17,18,19,20,31,45,47,56,70,72,81,95,97,113,114,115,116"}
{"idx": 188208, "func": "OMX_ERRORTYPE SoftAAC2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = 0;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = OMX_AUDIO_AACObjectMain;\n\n            aacParams->eAACStreamFormat =\n                mIsADTS\n ? OMX_AUDIO_AACStreamFormatMP4ADTS\n : OMX_AUDIO_AACStreamFormatMP4FF;\n\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n if (!isConfigured()) {\n                aacParams->nChannels = 1;\n                aacParams->nSampleRate = 44100;\n                aacParams->nFrameLength = 0;\n } else {\n                aacParams->nChannels = mStreamInfo->numChannels;\n                aacParams->nSampleRate = mStreamInfo->sampleRate;\n                aacParams->nFrameLength = mStreamInfo->frameSize;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n            pcmParams->eChannelMapping[2] = OMX_AUDIO_ChannelCF;\n            pcmParams->eChannelMapping[3] = OMX_AUDIO_ChannelLFE;\n            pcmParams->eChannelMapping[4] = OMX_AUDIO_ChannelLS;\n            pcmParams->eChannelMapping[5] = OMX_AUDIO_ChannelRS;\n\n if (!isConfigured()) {\n                pcmParams->nChannels = 1;\n                pcmParams->nSamplingRate = 44100;\n } else {\n                pcmParams->nChannels = mStreamInfo->numChannels;\n                pcmParams->nSamplingRate = mStreamInfo->sampleRate;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8962, "func": "bool net_tx_pkt_parse(struct NetTxPkt *pkt)\n{\n    if (net_tx_pkt_parse_headers(pkt)) {\n        net_tx_pkt_rebuild_payload(pkt);\n        return true;\n    } else {\n        return false;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8958, "func": "eth_pkt_types_e net_tx_pkt_get_packet_type(struct NetTxPkt *pkt)\n{\n    assert(pkt);\n\n    return pkt->packet_type;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188131, "func": "long FrameSequenceState_gif::drawFrame(int frameNr,\n Color8888* outputPtr, int outputPixelStride, int previousFrameNr) {\n\n GifFileType* gif = mFrameSequence.getGif();\n if (!gif) {\n        ALOGD(\"Cannot drawFrame, mGif is NULL\");\n return -1;\n }\n\n#if GIF_DEBUG\n    ALOGD(\"      drawFrame on %p nr %d on addr %p, previous frame nr %d\",\n this, frameNr, outputPtr, previousFrameNr);\n#endif\n\n const int height = mFrameSequence.getHeight();\n const int width = mFrameSequence.getWidth();\n\n GraphicsControlBlock gcb;\n\n int start = max(previousFrameNr + 1, 0);\n\n for (int i = max(start - 1, 0); i < frameNr; i++) {\n int neededPreservedFrame = mFrameSequence.getRestoringFrame(i);\n if (neededPreservedFrame >= 0 && (mPreserveBufferFrame != neededPreservedFrame)) {\n#if GIF_DEBUG\n            ALOGD(\"frame %d needs frame %d preserved, but %d is currently, so drawing from scratch\",\n                    i, neededPreservedFrame, mPreserveBufferFrame);\n#endif\n            start = 0;\n }\n }\n\n for (int i = start; i <= frameNr; i++) {\n DGifSavedExtensionToGCB(gif, i, &gcb);\n const SavedImage& frame = gif->SavedImages[i];\n\n#if GIF_DEBUG\n bool frameOpaque = gcb.TransparentColor == NO_TRANSPARENT_COLOR;\n        ALOGD(\"producing frame %d, drawing frame %d (opaque %d, disp %d, del %d)\",\n                frameNr, i, frameOpaque, gcb.DisposalMode, gcb.DelayTime);\n#endif\n if (i == 0) {\n Color8888 bgColor = mFrameSequence.getBackgroundColor();\n for (int y = 0; y < height; y++) {\n for (int x = 0; x < width; x++) {\n                    outputPtr[y * outputPixelStride + x] = bgColor;\n }\n }\n } else {\n GraphicsControlBlock prevGcb;\n DGifSavedExtensionToGCB(gif, i - 1, &prevGcb);\n const SavedImage& prevFrame = gif->SavedImages[i - 1];\n bool prevFrameDisposed = willBeCleared(prevGcb);\n\n bool newFrameOpaque = gcb.TransparentColor == NO_TRANSPARENT_COLOR;\n bool prevFrameCompletelyCovered = newFrameOpaque\n && checkIfCover(frame.ImageDesc, prevFrame.ImageDesc);\n\n if (prevFrameDisposed && !prevFrameCompletelyCovered) {\n switch (prevGcb.DisposalMode) {\n case DISPOSE_BACKGROUND: {\n Color8888* dst = outputPtr + prevFrame.ImageDesc.Left +\n                            prevFrame.ImageDesc.Top * outputPixelStride;\n\n GifWord copyWidth, copyHeight;\n                    getCopySize(prevFrame.ImageDesc, width, height, copyWidth, copyHeight);\n for (; copyHeight > 0; copyHeight--) {\n                        setLineColor(dst, TRANSPARENT, copyWidth);\n                        dst += outputPixelStride;\n }\n } break;\n case DISPOSE_PREVIOUS: {\n                    restorePreserveBuffer(outputPtr, outputPixelStride);\n } break;\n }\n }\n\n if (mFrameSequence.getPreservedFrame(i - 1)) {\n                savePreserveBuffer(outputPtr, outputPixelStride, i - 1);\n }\n }\n\n bool willBeCleared = gcb.DisposalMode == DISPOSE_BACKGROUND\n || gcb.DisposalMode == DISPOSE_PREVIOUS;\n if (i == frameNr || !willBeCleared) {\n const ColorMapObject* cmap = gif->SColorMap;\n if (frame.ImageDesc.ColorMap) {\n\n                 cmap = frame.ImageDesc.ColorMap;\n             }\n \n            if (cmap == NULL || cmap->ColorCount != (1 << cmap->BitsPerPixel)) {\n                ALOGW(\"Warning: potentially corrupt color map\");\n            }\n            const unsigned char* src = (unsigned char*)frame.RasterBits;\n            Color8888* dst = outputPtr + frame.ImageDesc.Left +\n                    frame.ImageDesc.Top * outputPixelStride;\n            GifWord copyWidth, copyHeight;\n            getCopySize(frame.ImageDesc, width, height, copyWidth, copyHeight);\n            for (; copyHeight > 0; copyHeight--) {\n                copyLine(dst, src, cmap, gcb.TransparentColor, copyWidth);\n                src += frame.ImageDesc.Width;\n                dst += outputPixelStride;\n             }\n         }\n     }\n\n const int maxFrame = gif->ImageCount;\n const int lastFrame = (frameNr + maxFrame - 1) % maxFrame;\n DGifSavedExtensionToGCB(gif, lastFrame, &gcb);\n return getDelayMs(gcb);\n}\n", "target": 1, "flaw_line_index": "95,96,97,98,99,100,101,102,103,104,105,106"}
{"idx": 187347, "func": "xsltDocumentElem(xsltTransformContextPtr ctxt, xmlNodePtr node,\n                 xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemDocumentPtr comp = (xsltStyleItemDocumentPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    xsltStylesheetPtr style = NULL;\n    int ret;\n    xmlChar *filename = NULL, *prop, *elements;\n    xmlChar *element, *end;\n    xmlDocPtr res = NULL;\n    xmlDocPtr oldOutput;\n    xmlNodePtr oldInsert, root;\n    const char *oldOutputFile;\n    xsltOutputType oldType;\n    xmlChar *URL = NULL;\n    const xmlChar *method;\n    const xmlChar *doctypePublic;\n    const xmlChar *doctypeSystem;\n    const xmlChar *version;\n    const xmlChar *encoding;\n    int redirect_write_append = 0;\n\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n        return;\n\n    if (comp->filename == NULL) {\n\n        if (xmlStrEqual(inst->name, (const xmlChar *) \"output\")) {\n\t    *   (http:\n#ifdef WITH_XSLT_DEBUG_EXTRA\n            xsltGenericDebug(xsltGenericDebugContext,\n                             \"Found saxon:output extension\\n\");\n#endif\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"file\",\n                                                 XSLT_SAXON_NAMESPACE);\n\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"href\",\n                                                 XSLT_SAXON_NAMESPACE);\n        } else if (xmlStrEqual(inst->name, (const xmlChar *) \"write\")) {\n#ifdef WITH_XSLT_DEBUG_EXTRA\n            xsltGenericDebug(xsltGenericDebugContext,\n                             \"Found xalan:write extension\\n\");\n#endif\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *)\n                                                 \"select\",\n                                                 XSLT_XALAN_NAMESPACE);\n\t    if (URL != NULL) {\n\t\txmlXPathCompExprPtr cmp;\n\t\txmlChar *val;\n\n\t\t * (see http:\n\t\tcmp = xmlXPathCompile(URL);\n                val = xsltEvalXPathString(ctxt, cmp);\n\t\txmlXPathFreeCompExpr(cmp);\n\t\txmlFree(URL);\n\t\tURL = val;\n\t    }\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t\t     (const xmlChar *)\n\t\t\t\t\t\t     \"file\",\n\t\t\t\t\t\t     XSLT_XALAN_NAMESPACE);\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t\t     (const xmlChar *)\n\t\t\t\t\t\t     \"href\",\n\t\t\t\t\t\t     XSLT_XALAN_NAMESPACE);\n        } else if (xmlStrEqual(inst->name, (const xmlChar *) \"document\")) {\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"href\",\n                                                 NULL);\n        }\n\n    } else {\n        URL = xmlStrdup(comp->filename);\n    }\n\n    if (URL == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t\t         \"xsltDocumentElem: href/URI-Reference not found\\n\");\n\treturn;\n    }\n\n    filename = xmlBuildURI(URL, (const xmlChar *) ctxt->outputFile);\n    if (filename == NULL) {\n\txmlChar *escURL;\n\n\tescURL=xmlURIEscapeStr(URL, BAD_CAST \":/.?,\");\n\tif (escURL != NULL) {\n\t    filename = xmlBuildURI(escURL, (const xmlChar *) ctxt->outputFile);\n\t    xmlFree(escURL);\n\t}\n    }\n\n    if (filename == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t\t         \"xsltDocumentElem: URL computation failed for %s\\n\",\n\t\t\t URL);\n\txmlFree(URL);\n\treturn;\n    }\n\n    if (ctxt->sec != NULL) {\n\tret = xsltCheckWrite(ctxt->sec, ctxt, filename);\n\tif (ret == 0) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t \"xsltDocumentElem: write rights for %s denied\\n\",\n\t\t\t     filename);\n\t    xmlFree(URL);\n\t    xmlFree(filename);\n\t    return;\n\t}\n    }\n\n    oldOutputFile = ctxt->outputFile;\n    oldOutput = ctxt->output;\n    oldInsert = ctxt->insert;\n    oldType = ctxt->type;\n    ctxt->outputFile = (const char *) filename;\n\n    style = xsltNewStylesheet();\n    if (style == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n                         \"xsltDocumentElem: out of memory\\n\");\n        goto error;\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"version\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (style->version != NULL)\n\t    xmlFree(style->version);\n\tstyle->version = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"encoding\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (style->encoding != NULL)\n\t    xmlFree(style->encoding);\n\tstyle->encoding = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"method\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tconst xmlChar *URI;\n\n\tif (style->method != NULL)\n\t    xmlFree(style->method);\n\tstyle->method = NULL;\n\tif (style->methodURI != NULL)\n\t    xmlFree(style->methodURI);\n\tstyle->methodURI = NULL;\n\n\tURI = xsltGetQNameURI(inst, &prop);\n\tif (prop == NULL) {\n\t    if (style != NULL) style->errors++;\n\t} else if (URI == NULL) {\n\t    if ((xmlStrEqual(prop, (const xmlChar *) \"xml\")) ||\n\t\t(xmlStrEqual(prop, (const xmlChar *) \"html\")) ||\n\t\t(xmlStrEqual(prop, (const xmlChar *) \"text\"))) {\n\t\tstyle->method = prop;\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t\t\t \"invalid value for method: %s\\n\", prop);\n\t\tif (style != NULL) style->warnings++;\n\t    }\n\t} else {\n\t    style->method = prop;\n\t    style->methodURI = xmlStrdup(URI);\n\t}\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"doctype-system\", NULL);\n    if (prop != NULL) {\n\tif (style->doctypeSystem != NULL)\n\t    xmlFree(style->doctypeSystem);\n\tstyle->doctypeSystem = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"doctype-public\", NULL);\n    if (prop != NULL) {\n\tif (style->doctypePublic != NULL)\n\t    xmlFree(style->doctypePublic);\n\tstyle->doctypePublic = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"standalone\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->standalone = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->standalone = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for standalone: %s\\n\",\n\t\t\t     prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"indent\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->indent = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->indent = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for indent: %s\\n\", prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"omit-xml-declaration\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->omitXmlDeclaration = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->omitXmlDeclaration = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for omit-xml-declaration: %s\\n\",\n\t\t\t     prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    elements = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t (const xmlChar *)\n\t\t\t\t\t \"cdata-section-elements\",\n\t\t\t\t\t NULL);\n    if (elements != NULL) {\n\tif (style->stripSpaces == NULL)\n\t    style->stripSpaces = xmlHashCreate(10);\n\tif (style->stripSpaces == NULL)\n\t    return;\n\n\telement = elements;\n\twhile (*element != 0) {\n\t    while (IS_BLANK_CH(*element))\n\t\telement++;\n\t    if (*element == 0)\n\t\tbreak;\n\t    end = element;\n\t    while ((*end != 0) && (!IS_BLANK_CH(*end)))\n\t\tend++;\n\t    element = xmlStrndup(element, end - element);\n\t    if (element) {\n\t\tconst xmlChar *URI;\n\n#ifdef WITH_XSLT_DEBUG_PARSING\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t\t \"add cdata section output element %s\\n\",\n\t\t\t\t element);\n#endif\n                URI = xsltGetQNameURI(inst, &element);\n\n\t\txmlHashAddEntry2(style->stripSpaces, element, URI,\n\t\t\t        (xmlChar *) \"cdata\");\n\t\txmlFree(element);\n\t    }\n\t    element = end;\n\t}\n\txmlFree(elements);\n    }\n\n    XSLT_GET_IMPORT_PTR(method, style, method)\n    XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n    XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n    XSLT_GET_IMPORT_PTR(version, style, version)\n    XSLT_GET_IMPORT_PTR(encoding, style, encoding)\n\n    if ((method != NULL) &&\n\t(!xmlStrEqual(method, (const xmlChar *) \"xml\"))) {\n\tif (xmlStrEqual(method, (const xmlChar *) \"html\")) {\n\t    ctxt->type = XSLT_OUTPUT_HTML;\n\t    if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n\t\tres = htmlNewDoc(doctypeSystem, doctypePublic);\n\t    else {\n\t\tif (version != NULL) {\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t    xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n#endif\n                }\n\t\tres = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n\t    }\n\t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n \t    xmlDictReference(res->dict);\n \t} else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\n \t    xsltTransformError(ctxt, NULL, inst,\n\t     \"xsltDocumentElem: unsupported method xhtml\\n\",\n\t\t             style->method);\n \t    ctxt->type = XSLT_OUTPUT_HTML;\n \t    res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n \t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n\t} else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\n\t    ctxt->type = XSLT_OUTPUT_TEXT;\n\t    res = xmlNewDoc(style->version);\n\t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\n\t    xsltGenericDebug(xsltGenericDebugContext,\n                     \"reusing transformation dict for output\\n\");\n #endif\n \t} else {\n \t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"xsltDocumentElem: unsupported method %s\\n\",\n\t\t             style->method);\n \t    goto error;\n \t}\n     } else {\n\tctxt->type = XSLT_OUTPUT_XML;\n\tres = xmlNewDoc(style->version);\n\tif (res == NULL)\n\t    goto error;\n\tres->dict = ctxt->dict;\n\txmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\n\txsltGenericDebug(xsltGenericDebugContext,\n                     \"reusing transformation dict for output\\n\");\n#endif\n    }\n    res->charset = XML_CHAR_ENCODING_UTF8;\n    if (encoding != NULL)\n\tres->encoding = xmlStrdup(encoding);\n    ctxt->output = res;\n    ctxt->insert = (xmlNodePtr) res;\n    xsltApplySequenceConstructor(ctxt, node, inst->children, NULL);\n\n    root = xmlDocGetRootElement(res);\n    if (root != NULL) {\n        const xmlChar *doctype = NULL;\n\n        if ((root->ns != NULL) && (root->ns->prefix != NULL))\n\t    doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n\tif (doctype == NULL)\n\t    doctype = root->name;\n\n        if ((method == NULL) &&\n            (root->ns == NULL) &&\n            (!xmlStrcasecmp(root->name, (const xmlChar *) \"html\"))) {\n            xmlNodePtr tmp;\n\n            tmp = res->children;\n            while ((tmp != NULL) && (tmp != root)) {\n                if (tmp->type == XML_ELEMENT_NODE)\n                    break;\n                if ((tmp->type == XML_TEXT_NODE) && (!xmlIsBlankNode(tmp)))\n                    break;\n\t\ttmp = tmp->next;\n            }\n            if (tmp == root) {\n                ctxt->type = XSLT_OUTPUT_HTML;\n                res->type = XML_HTML_DOCUMENT_NODE;\n                if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\n                    res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                        doctypePublic,\n                                                        doctypeSystem);\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t} else if (version != NULL) {\n                    xsltGetHTMLIDs(version, &doctypePublic,\n                                   &doctypeSystem);\n                    if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n                        res->intSubset =\n                            xmlCreateIntSubset(res, doctype,\n                                               doctypePublic,\n                                               doctypeSystem);\n#endif\n                }\n            }\n\n        }\n        if (ctxt->type == XSLT_OUTPUT_XML) {\n            XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n                XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n                if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n                res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                    doctypePublic,\n                                                    doctypeSystem);\n        }\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst, (const xmlChar *)\"append\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"true\") ||\n\t    xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->omitXmlDeclaration = 1;\n\t    redirect_write_append = 1;\n\t} else\n\t    style->omitXmlDeclaration = 0;\n\txmlFree(prop);\n    }\n\n    if (redirect_write_append) {\n        FILE *f;\n\n\tf = fopen((const char *) filename, \"ab\");\n\tif (f == NULL) {\n\t    ret = -1;\n\t} else {\n\t    ret = xsltSaveResultToFile(f, res, style);\n\t    fclose(f);\n\t}\n    } else {\n\tret = xsltSaveResultToFilename((const char *) filename, res, style, 0);\n    }\n    if (ret < 0) {\n\txsltTransformError(ctxt, NULL, inst,\n                         \"xsltDocumentElem: unable to save to %s\\n\",\n                         filename);\n\tctxt->state = XSLT_STATE_ERROR;\n#ifdef WITH_XSLT_DEBUG_EXTRA\n    } else {\n        xsltGenericDebug(xsltGenericDebugContext,\n                         \"Wrote %d bytes to %s\\n\", ret, filename);\n#endif\n    }\n\n  error:\n    ctxt->output = oldOutput;\n    ctxt->insert = oldInsert;\n    ctxt->type = oldType;\n    ctxt->outputFile = oldOutputFile;\n    if (URL != NULL)\n        xmlFree(URL);\n    if (filename != NULL)\n        xmlFree(filename);\n    if (style != NULL)\n        xsltFreeStylesheet(style);\n    if (res != NULL)\n        xmlFreeDoc(res);\n}\n", "target": 1, "flaw_line_index": "314,315,335,336"}
{"idx": 187337, "func": "xsltAttributeComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemAttributePtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemAttributePtr) xsltNewStylePreComp(style,\n\tXSLT_FUNC_ATTRIBUTE);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_ATTRIBUTE);\n#endif\n\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n\n    comp->name = xsltEvalStaticAttrValueTemplate(style, inst,\n\t\t\t\t (const xmlChar *)\"name\",\n\t\t\t\t NULL, &comp->has_name);\n    if (! comp->has_name) {\n\txsltTransformError(NULL, style, inst,\n\t    \"XSLT-attribute: The attribute 'name' is missing.\\n\");\n\tstyle->errors++;\n\treturn;\n    }\n    comp->ns = xsltEvalStaticAttrValueTemplate(style, inst,\n\t(const xmlChar *)\"namespace\",\n\tNULL, &comp->has_ns);\n\n    if (comp->name != NULL) {\n\tif (xmlValidateQName(comp->name, 0)) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"xsl:attribute: The value '%s' of the attribute 'name' is \"\n\t\t\"not a valid QName.\\n\", comp->name);\n\t    style->errors++;\n        } else if (xmlStrEqual(comp->name, BAD_CAST \"xmlns\")) {\n\t    xsltTransformError(NULL, style, inst,\n                \"xsl:attribute: The attribute name 'xmlns' is not allowed.\\n\");\n\t    style->errors++;\n\t} else {\n\t    const xmlChar *prefix = NULL, *name;\n\n\t    name = xsltSplitQName(style->dict, comp->name, &prefix);\n\t    if (prefix != NULL) {\n\t\tif (comp->has_ns == 0) {\n\t\t    xmlNsPtr ns;\n\n\t\t    ns = xmlSearchNs(inst->doc, inst, prefix);\n\t\t    if (ns != NULL) {\n\t\t\tcomp->ns = xmlDictLookup(style->dict, ns->href, -1);\n\t\t\tcomp->has_ns = 1;\n #ifdef XSLT_REFACTORED\n \t\t\tcomp->nsPrefix = prefix;\n \t\t\tcomp->name = name;\n #endif\n \t\t    } else {\n \t\t\txsltTransformError(NULL, style, inst,\n\t\t\t    \"xsl:attribute: The prefixed QName '%s' \"\n\t\t\t    \"has no namespace binding in scope in the \"\n\t\t\t    \"stylesheet; this is an error, since the \"\n\t\t\t    \"namespace was not specified by the instruction \"\n\t\t\t    \"itself.\\n\", comp->name);\n\t\t\tstyle->errors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187683, "func": "make_error(png_store* volatile psIn, png_byte PNG_CONST colour_type,\n     png_byte bit_depth, int interlace_type, int test, png_const_charp name)\n {\n   png_store * volatile ps = psIn;\n    context(ps, fault);\n \n    check_interlace_type(interlace_type);\n \n    Try\n    {\n      png_structp pp;\n       png_infop pi;\n      pp = set_store_for_write(ps, &pi, name);\n \n       if (pp == NULL)\n          Throw ps;\n \n      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth),\n         transform_height(pp, colour_type, bit_depth), bit_depth, colour_type,\n         interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n \n       if (colour_type == 3) \n          init_standard_palette(ps, pp, pi, 1U << bit_depth, 0\n);\n\n#     define exception__prev exception_prev_1\n\n #     define exception__env exception_env_1\n       Try\n       {\n          ps->expect_error = !error_test[test].warning;\n          ps->expect_warning = error_test[test].warning;\n         ps->saw_warning = 0;\n         error_test[test].fn(pp, pi);\n\n         png_write_info(pp, pi);\n\n if (ps->expect_warning && ps->saw_warning)\n Throw ps;\n\n         store_log(ps, pp, error_test[test].msg, 1 \n);\n\n       }\n \n       Catch (fault)\n         ps = fault; \n #undef exception__prev\n #undef exception__env\n \n      ps->expect_error = 0;\n      ps->expect_warning = 0;\n\n if (png_get_rowbytes(pp, pi) !=\n          transform_rowsize(pp, colour_type, bit_depth))\n         png_error(pp, \"row size incorrect\");\n\n \n       else\n       {\n         png_uint_32 h = transform_height(pp, colour_type, bit_depth);\n         int npasses = png_set_interlace_handling(pp);\n          int pass;\n \n          if (npasses != npasses_from_interlace_type(pp, interlace_type))\n            png_error(pp, \"write: png_set_interlace_handling failed\");\n\n for (pass=0; pass<npasses; ++pass)\n {\n            png_uint_32 y;\n\n for (y=0; y<h; ++y)\n {\n\n                png_byte buffer[TRANSFORM_ROWMAX];\n \n                transform_row(pp, buffer, colour_type, bit_depth, y);\n                png_write_row(pp, buffer);\n             }\n          }\n }\n\n      png_write_end(pp, pi);\n\n      store_write_reset(ps);\n }\n\n Catch(fault)\n {\n      store_write_reset(fault);\n }\n\n }\n", "target": 1, "flaw_line_index": "4,11,13,18,19,20,47,61,62"}
{"idx": 187443, "func": "void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst)\n {\n     if (src == NULL || src_len == 0 || dst == NULL) {\n         return;\n }\n\n const char32_t *cur_utf32 = src;\n const char32_t *end_utf32 = src + src_len;\n\n     char *cur = dst;\n     while (cur_utf32 < end_utf32) {\n         size_t len = utf32_codepoint_utf8_length(*cur_utf32);\n         utf32_codepoint_to_utf8((uint8_t *)cur, *cur_utf32++, len);\n         cur += len;\n     }\n     *cur = '\\0';\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187554, "func": " status_t OMXNodeInstance::updateGraphicBufferInMeta_l(\n         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n         OMX::buffer_id buffer, OMX_BUFFERHEADERTYPE *header) {\n     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n         return BAD_VALUE;\n     }\n\n BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);\n    bufferMeta->setGraphicBuffer(graphicBuffer);\n if (mMetadataType[portIndex] == kMetadataBufferTypeGrallocSource\n && header->nAllocLen >= sizeof(VideoGrallocMetadata)) {\n VideoGrallocMetadata &metadata = *(VideoGrallocMetadata *)(header->pBuffer);\n        metadata.eType = kMetadataBufferTypeGrallocSource;\n        metadata.pHandle = graphicBuffer == NULL ? NULL : graphicBuffer->handle;\n } else if (mMetadataType[portIndex] == kMetadataBufferTypeANWBuffer\n && header->nAllocLen >= sizeof(VideoNativeMetadata)) {\n VideoNativeMetadata &metadata = *(VideoNativeMetadata *)(header->pBuffer);\n        metadata.eType = kMetadataBufferTypeANWBuffer;\n        metadata.pBuffer = graphicBuffer == NULL ? NULL : graphicBuffer->getNativeBuffer();\n        metadata.nFenceFd = -1;\n } else {\n        CLOG_BUFFER(updateGraphicBufferInMeta, \"%s:%u, %#x bad type (%d) or size (%u)\",\n            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], header->nAllocLen);\n return BAD_VALUE;\n }\n\n    CLOG_BUFFER(updateGraphicBufferInMeta, \"%s:%u, %#x := %p\",\n            portString(portIndex), portIndex, buffer,\n            graphicBuffer == NULL ? NULL : graphicBuffer->handle);\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187986, "func": "void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)\n{\n    hal_info *info = getHalInfo(handle);\n char buf[64];\n\n    info->cleaned_up_handler = handler;\n if (write(info->cleanup_socks[0], \"Exit\", 4) < 1) {\n        ALOGE(\"could not write to the cleanup socket\");\n } else {\n        memset(buf, 0, sizeof(buf));\n int result = read(info->cleanup_socks[0], buf, sizeof(buf));\n        ALOGE(\"%s: Read after POLL returned %d, error no = %d\", __FUNCTION__, result, errno);\n if (strncmp(buf, \"Done\", 4) == 0) {\n            ALOGE(\"Event processing terminated\");\n } else {\n            ALOGD(\"Rx'ed %s\", buf);\n }\n }\n    info->clean_up = true;\n    pthread_mutex_lock(&info->cb_lock);\n\n int bad_commands = 0;\n\n for (int i = 0; i < info->num_event_cb; i++) {\n        cb_info *cbi = &(info->event_cb[i]);\n WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;\n        ALOGI(\"Command left in event_cb %p:%s\", cmd, (cmd ? cmd->getType(): \"\"));\n }\n\n while (info->num_cmd > bad_commands) {\n int num_cmd = info->num_cmd;\n        cmd_info *cmdi = &(info->cmd[bad_commands]);\n WifiCommand *cmd = cmdi->cmd;\n if (cmd != NULL) {\n            ALOGI(\"Cancelling command %p:%s\", cmd, cmd->getType());\n\n             pthread_mutex_unlock(&info->cb_lock);\n             cmd->cancel();\n             pthread_mutex_lock(&info->cb_lock);\n            cmd->releaseRef();\n             if (num_cmd == info->num_cmd) {\n                 ALOGI(\"Cancelling command %p:%s did not work\", cmd, (cmd ? cmd->getType(): \"\"));\n                 bad_commands++;\n             }\n         }\n     }\n \n for (int i = 0; i < info->num_event_cb; i++) {\n        cb_info *cbi = &(info->event_cb[i]);\n WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;\n        ALOGE(\"Leaked command %p\", cmd);\n }\n    pthread_mutex_unlock(&info->cb_lock);\n    internal_cleaned_up_handler(handle);\n}\n", "target": 1, "flaw_line_index": "45,46"}
{"idx": 8943, "func": "void vrend_set_stencil_ref(struct vrend_context *ctx,\n                           struct pipe_stencil_ref *ref)\n{\n   if (ctx->sub->stencil_refs[0] != ref->ref_value[0] ||\n       ctx->sub->stencil_refs[1] != ref->ref_value[1]) {\n      ctx->sub->stencil_refs[0] = ref->ref_value[0];\n      ctx->sub->stencil_refs[1] = ref->ref_value[1];\n      ctx->sub->stencil_state_dirty = true;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188034, "func": "void SoftVPXEncoder::onQueueFilled(OMX_U32 portIndex) {\n if (mCodecContext == NULL) {\n if (OK != initEncoder()) {\n            ALOGE(\"Failed to initialize encoder\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, \n                   NULL); \n return;\n }\n }\n\n vpx_codec_err_t codec_return;\n List<BufferInfo *> &inputBufferInfoQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outputBufferInfoQueue = getPortQueue(kOutputPortIndex);\n\n while (!inputBufferInfoQueue.empty() && !outputBufferInfoQueue.empty()) {\n BufferInfo *inputBufferInfo = *inputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *inputBufferHeader = inputBufferInfo->mHeader;\n\n BufferInfo *outputBufferInfo = *outputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo->mHeader;\n\n if (inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n            inputBufferInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inputBufferHeader);\n\n            outputBufferHeader->nFilledLen = 0;\n            outputBufferHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n            outputBufferInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outputBufferHeader);\n return;\n }\n\n const uint8_t *source =\n            inputBufferHeader->pBuffer + inputBufferHeader->nOffset;\n\n size_t frameSize = mWidth * mHeight * 3 / 2;\n if (mInputDataIsMeta) {\n            source = extractGraphicBuffer(\n                    mConversionBuffer, frameSize,\n                    source, inputBufferHeader->nFilledLen,\n                    mWidth, mHeight);\n if (source == NULL) {\n                ALOGE(\"Unable to extract gralloc buffer in metadata mode\");\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n return;\n }\n } else {\n if (inputBufferHeader->nFilledLen < frameSize) {\n                android_errorWriteLog(0x534e4554, \"27569635\");\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n return;\n } else if (inputBufferHeader->nFilledLen > frameSize) {\n                ALOGW(\"Input buffer contains too many pixels\");\n }\n\n if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {\n ConvertYUV420SemiPlanarToYUV420Planar(\n                        source, mConversionBuffer, mWidth, mHeight);\n\n                source = mConversionBuffer;\n }\n }\n vpx_image_t raw_frame;\n        vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,\n                     kInputBufferAlignment, (uint8_t *)source);\n\n vpx_enc_frame_flags_t flags = 0;\n if (mTemporalPatternLength > 0) {\n            flags = getEncodeFlags();\n }\n if (mKeyFrameRequested) {\n            flags |= VPX_EFLAG_FORCE_KF;\n            mKeyFrameRequested = false;\n }\n\n if (mBitrateUpdated) {\n            mCodecConfiguration->rc_target_bitrate = mBitrate/1000;\n vpx_codec_err_t res = vpx_codec_enc_config_set(mCodecContext,\n                                                           mCodecConfiguration);\n if (res != VPX_CODEC_OK) {\n                ALOGE(\"vp8 encoder failed to update bitrate: %s\",\n                      vpx_codec_err_to_string(res));\n                notify(OMX_EventError,\n                       OMX_ErrorUndefined,\n 0, \n                       NULL); \n }\n            mBitrateUpdated = false;\n }\n\n uint32_t frameDuration;\n\n         if (inputBufferHeader->nTimeStamp > mLastTimestamp) {\n             frameDuration = (uint32_t)(inputBufferHeader->nTimeStamp - mLastTimestamp);\n         } else {\n            frameDuration = (uint32_t)(((uint64_t)1000000 << 16) / mFramerate);\n         }\n         mLastTimestamp = inputBufferHeader->nTimeStamp;\n         codec_return = vpx_codec_encode(\n                mCodecContext,\n &raw_frame,\n                inputBufferHeader->nTimeStamp, \n                frameDuration, \n                flags, \n                VPX_DL_REALTIME); \n if (codec_return != VPX_CODEC_OK) {\n            ALOGE(\"vpx encoder failed to encode frame\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, \n                   NULL); \n return;\n }\n\n vpx_codec_iter_t encoded_packet_iterator = NULL;\n const vpx_codec_cx_pkt_t* encoded_packet;\n\n while ((encoded_packet = vpx_codec_get_cx_data(\n                        mCodecContext, &encoded_packet_iterator))) {\n if (encoded_packet->kind == VPX_CODEC_CX_FRAME_PKT) {\n                outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;\n                outputBufferHeader->nFlags = 0;\n if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)\n                    outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;\n                outputBufferHeader->nOffset = 0;\n                outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;\n if (outputBufferHeader->nFilledLen > outputBufferHeader->nAllocLen) {\n                    android_errorWriteLog(0x534e4554, \"27569635\");\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n return;\n }\n                memcpy(outputBufferHeader->pBuffer,\n                       encoded_packet->data.frame.buf,\n                       encoded_packet->data.frame.sz);\n                outputBufferInfo->mOwnedByUs = false;\n                outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n                notifyFillBufferDone(outputBufferHeader);\n }\n }\n\n        inputBufferInfo->mOwnedByUs = false;\n        inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n        notifyEmptyBufferDone(inputBufferHeader);\n\n     }\n }\n", "target": 1, "flaw_line_index": "102"}
{"idx": 9095, "func": "static int vrend_decode_create_object(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length < 1)\n      return EINVAL;\n\n   uint32_t header = get_buf_entry(ctx, VIRGL_OBJ_CREATE_HEADER);\n   uint32_t handle = get_buf_entry(ctx, VIRGL_OBJ_CREATE_HANDLE);\n   uint8_t obj_type = (header >> 8) & 0xff;\n   int ret = 0;\n\n   if (handle == 0)\n      return EINVAL;\n\n   switch (obj_type){\n   case VIRGL_OBJECT_BLEND:\n      ret = vrend_decode_create_blend(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_DSA:\n      ret = vrend_decode_create_dsa(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_RASTERIZER:\n      ret = vrend_decode_create_rasterizer(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_SHADER:\n      ret = vrend_decode_create_shader(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_VERTEX_ELEMENTS:\n      ret = vrend_decode_create_ve(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_SURFACE:\n      ret = vrend_decode_create_surface(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_SAMPLER_VIEW:\n      ret = vrend_decode_create_sampler_view(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_SAMPLER_STATE:\n      ret = vrend_decode_create_sampler_state(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_QUERY:\n      ret = vrend_decode_create_query(ctx, handle, length);\n      break;\n   case VIRGL_OBJECT_STREAMOUT_TARGET:\n      ret = vrend_decode_create_stream_output_target(ctx, handle, length);\n      break;\n   default:\n      return EINVAL;\n   }\n\n   return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187870, "func": "long ContentEncoding::ParseCompressionEntry(long long start, long long size,\n IMkvReader* pReader,\n ContentCompression* compression) {\n  assert(pReader);\n  assert(compression);\n\n long long pos = start;\n const long long stop = start + size;\n\n bool valid = false;\n\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) \n return status;\n\n if (id == 0x254) {\n long long algo = UnserializeUInt(pReader, pos, size);\n if (algo < 0)\n return E_FILE_FORMAT_INVALID;\n      compression->algo = algo;\n      valid = true;\n } else if (id == 0x255) {\n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      compression->settings = buf;\n      compression->settings_len = buflen;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n if (!valid)\n return E_FILE_FORMAT_INVALID;\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "32,33,50"}
{"idx": 8941, "func": "void vrend_set_single_sampler_view(struct vrend_context *ctx,\n                                   uint32_t shader_type,\n                                   int index,\n                                   uint32_t handle)\n{\n   struct vrend_sampler_view *view = NULL;\n   struct vrend_texture *tex;\n\n   if (handle) {\n      view = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SAMPLER_VIEW);\n      if (!view) {\n         ctx->sub->views[shader_type].views[index] = NULL;\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_HANDLE, handle);\n         return;\n      }\n      if (ctx->sub->views[shader_type].views[index] == view) {\n         return;\n      }\n      tex = (struct vrend_texture *)view->texture;\n      if (!tex) {\n         return;\n      }\n      if (view->texture->target != GL_TEXTURE_BUFFER) {\n         glBindTexture(view->texture->target, view->texture->id);\n\n         if (util_format_is_depth_or_stencil(view->format)) {\n            if (vrend_state.use_core_profile == false) {\n               if (view->depth_texture_mode != GL_RED) {\n                  glTexParameteri(view->texture->target, GL_DEPTH_TEXTURE_MODE, GL_RED);\n                  view->depth_texture_mode = GL_RED;\n               }\n            }\n         }\n\n         if (view->cur_base != (view->val1 & 0xff)) {\n            view->cur_base = view->val1 & 0xff;\n            glTexParameteri(view->texture->target, GL_TEXTURE_BASE_LEVEL, view->cur_base);\n         }\n         if (view->cur_max != ((view->val1 >> 8) & 0xff)) {\n            view->cur_max = (view->val1 >> 8) & 0xff;\n            glTexParameteri(view->texture->target, GL_TEXTURE_MAX_LEVEL, view->cur_max);\n         }\n         if (tex->cur_swizzle_r != view->gl_swizzle_r) {\n            glTexParameteri(view->texture->target, GL_TEXTURE_SWIZZLE_R, view->gl_swizzle_r);\n            tex->cur_swizzle_r = view->gl_swizzle_r;\n         }\n         if (tex->cur_swizzle_g != view->gl_swizzle_g) {\n            glTexParameteri(view->texture->target, GL_TEXTURE_SWIZZLE_G, view->gl_swizzle_g);\n            tex->cur_swizzle_g = view->gl_swizzle_g;\n         }\n         if (tex->cur_swizzle_b != view->gl_swizzle_b) {\n            glTexParameteri(view->texture->target, GL_TEXTURE_SWIZZLE_B, view->gl_swizzle_b);\n            tex->cur_swizzle_b = view->gl_swizzle_b;\n         }\n         if (tex->cur_swizzle_a != view->gl_swizzle_a) {\n            glTexParameteri(view->texture->target, GL_TEXTURE_SWIZZLE_A, view->gl_swizzle_a);\n            tex->cur_swizzle_a = view->gl_swizzle_a;\n         }\n         if (tex->srgb_decode != view->srgb_decode && util_format_is_srgb(tex->base.base.format)) {\n            if (vrend_state.have_samplers)\n               ctx->sub->sampler_state_dirty = true;\n            else {\n               glTexParameteri(view->texture->target, GL_TEXTURE_SRGB_DECODE_EXT,\n                               view->srgb_decode);\n               tex->srgb_decode = view->srgb_decode;\n            }\n         }\n      } else {\n         GLenum internalformat;\n\n         glBindTexture(GL_TEXTURE_BUFFER, view->texture->tbo_tex_id);\n         internalformat = tex_conv_table[view->format].internalformat;\n         glTexBuffer(GL_TEXTURE_BUFFER, internalformat, view->texture->id);\n      }\n   }\n\n   vrend_sampler_view_reference(&ctx->sub->views[shader_type].views[index], view);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8936, "func": "void vrend_set_num_sampler_views(struct vrend_context *ctx,\n                                 uint32_t shader_type,\n                                 uint32_t start_slot,\n                                 int num_sampler_views)\n{\n   if (start_slot + num_sampler_views < ctx->sub->views[shader_type].num_views) {\n      int i;\n      for (i = start_slot + num_sampler_views; i < ctx->sub->views[shader_type].num_views; i++)\n         vrend_sampler_view_reference(&ctx->sub->views[shader_type].views[i], NULL);\n   }\n   ctx->sub->views[shader_type].num_views = start_slot + num_sampler_views;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188136, "func": "resetLppTransposer (HANDLE_SBR_LPP_TRANS hLppTrans, \n                    UCHAR  highBandStartSb, \n                    UCHAR *v_k_master, \n                    UCHAR  numMaster, \n                    UCHAR *noiseBandTable, \n                    UCHAR  noNoiseBands, \n                    UCHAR  usb, \n                    UINT   fs                        \n )\n{\n  TRANSPOSER_SETTINGS *pSettings = hLppTrans->pSettings;\n  PATCH_PARAM  *patchParam = pSettings->patchParam;\n\n int i, patch;\n int targetStopBand;\n int sourceStartBand;\n int patchDistance;\n int numBandsInPatch;\n\n int lsb = v_k_master[0]; \n int xoverOffset = highBandStartSb - lsb; \n int startFreqHz;\n\n int desiredBorder;\n\n  usb = fixMin(usb, v_k_master[numMaster]); \n\n\n if ( lsb - SHIFT_START_SB < 4 ) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n\n  desiredBorder    = (((2048000*2) / fs) + 1) >> 1;\n\n  desiredBorder = findClosestEntry(desiredBorder, v_k_master, numMaster, 1); \n\n  sourceStartBand = SHIFT_START_SB + xoverOffset;\n  targetStopBand = lsb + xoverOffset; \n\n  patch = 0;\n while(targetStopBand < usb) {\n\n if (patch > MAX_NUM_PATCHES) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n    patchParam[patch].guardStartBand = targetStopBand;\n    patchParam[patch].targetStartBand = targetStopBand;\n\n    numBandsInPatch = desiredBorder - targetStopBand; \n\n if ( numBandsInPatch >= lsb - sourceStartBand ) {\n      patchDistance   = targetStopBand - sourceStartBand; \n      patchDistance   = patchDistance & ~1; \n      numBandsInPatch = lsb - (targetStopBand - patchDistance); \n      numBandsInPatch = findClosestEntry(targetStopBand + numBandsInPatch, v_k_master, numMaster, 0) -\n                        targetStopBand; \n }\n\n    patchDistance   = numBandsInPatch + targetStopBand - lsb; \n    patchDistance   = (patchDistance + 1) & ~1; \n\n if (numBandsInPatch > 0) {\n      patchParam[patch].sourceStartBand = targetStopBand - patchDistance;\n      patchParam[patch].targetBandOffs  = patchDistance;\n      patchParam[patch].numBandsInPatch = numBandsInPatch;\n      patchParam[patch].sourceStopBand  = patchParam[patch].sourceStartBand + numBandsInPatch;\n\n      targetStopBand += patchParam[patch].numBandsInPatch;\n      patch++;\n }\n\n    sourceStartBand = SHIFT_START_SB;\n\n if( desiredBorder - targetStopBand < 3) \n {\n      desiredBorder = usb;\n }\n\n }\n\n  patch--;\n\n if ( (patch>0) && (patchParam[patch].numBandsInPatch < 3) ) {\n    patch--;\n    targetStopBand = patchParam[patch].targetStartBand + patchParam[patch].numBandsInPatch;\n }\n\n if (patch >= MAX_NUM_PATCHES) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n  pSettings->noOfPatches = patch + 1;\n\n  pSettings->lbStartPatching = targetStopBand;\n  pSettings->lbStopPatching  = 0;\n for ( patch = 0; patch < pSettings->noOfPatches; patch++ ) {\n    pSettings->lbStartPatching = fixMin( pSettings->lbStartPatching, patchParam[patch].sourceStartBand );\n    pSettings->lbStopPatching  = fixMax( pSettings->lbStopPatching, patchParam[patch].sourceStopBand );\n }\n\n\n   for(i = 0 ; i < noNoiseBands; i++){\n     pSettings->bwBorders[i] = noiseBandTable[i+1];\n   }\n \n\n  startFreqHz = ( (lsb + xoverOffset)*fs ) >> 7; \n\n for( i = 1; i < NUM_WHFACTOR_TABLE_ENTRIES; i++ )\n {\n if( startFreqHz < FDK_sbrDecoder_sbr_whFactorsIndex[i])\n break;\n }\n  i--;\n\n  pSettings->whFactors.off = FDK_sbrDecoder_sbr_whFactorsTable[i][0];\n  pSettings->whFactors.transitionLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][1];\n  pSettings->whFactors.lowLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][2];\n  pSettings->whFactors.midLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][3];\n  pSettings->whFactors.highLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][4];\n\n return SBRDEC_OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188513, "func": "static void encode_frame(vpx_codec_ctx_t *ctx,\n                         const vpx_image_t *img,\n                         vpx_codec_pts_t pts,\n                         unsigned int duration,\n                         vpx_enc_frame_flags_t flags,\n                         unsigned int deadline,\n                         VpxVideoWriter *writer) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\n                                               deadline);\n if (res != VPX_CODEC_OK)\n\n     die_codec(ctx, \"Failed to encode frame.\");\n \n   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n \n if (!vpx_video_writer_write_frame(writer, pkt->data.frame.buf,\n                                                pkt->data.frame.sz,\n                                                pkt->data.frame.pts))\n        die_codec(ctx, \"Failed to write compressed frame.\");\n      printf(keyframe ? \"K\" : \".\");\n\n       fflush(stdout);\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 187622, "func": "image_transform_png_set_@_add(image_transform *this,\n    PNG_CONST image_transform **that, char *name, size_t sizeof_name,\n    size_t *pos, png_byte colour_type, png_byte bit_depth)\n{\n   this->next = *that;\n   *that = this;\n   *pos = safecat(name, sizeof_name, *pos, \" +@\");\n   return 1;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9"}
{"idx": 187694, "func": " next_format(png_bytep colour_type, png_bytep bit_depth,\n   unsigned int* palette_number, int no_low_depth_gray)\n {\n    if (*bit_depth == 0)\n    {\n       *colour_type = 0;\n      if (no_low_depth_gray)\n         *bit_depth = 8;\n      else\n          *bit_depth = 1;\n       *palette_number = 0;\n       return 1;\n    }\n \n   if (*colour_type == 3)\n    {\n      if (++*palette_number < PALETTE_COUNT(*bit_depth))\n          return 1;\n \n       *palette_number = 0;\n    }\n \n *bit_depth = (png_byte)(*bit_depth << 1);\n\n \n    if (*bit_depth <= 8\n#     ifdef DO_16BIT\n          || (*colour_type != 3 && *bit_depth <= 16)\n#     endif\n       )\n       return 1;\n \n switch (*colour_type)\n {\n case 0:\n *colour_type = 2;\n *bit_depth = 8;\n return 1;\n\n case 2:\n *colour_type = 3;\n *bit_depth = 1;\n return 1;\n\n case 3:\n *colour_type = 4;\n *bit_depth = 8;\n return 1;\n\n case 4:\n *colour_type = 6;\n *bit_depth = 8;\n return 1;\n\n default:\n return 0;\n }\n}\n", "target": 1, "flaw_line_index": "2,7,8,9,15,16,17,27,29"}
{"idx": 8566, "func": "static void ssh_gotdata(Ssh ssh, const unsigned char *data, int datalen)\n{\n    if (ssh->logctx)\n\tlog_packet(ssh->logctx, PKT_INCOMING, -1, NULL, data, datalen,\n\t\t   0, NULL, NULL, 0, NULL);\n\n    crBegin(ssh->ssh_gotdata_crstate);\n\n    while (1) {\n\tint ret;\t\t       \n\tif (datalen == 0)\n\t    crReturnV;\t\t       \n\tret = ssh->do_ssh_init(ssh, *data);\n\tdata++;\n\tdatalen--;\n\tif (ret == 0)\n\t    break;\n    }\n\n\n    while (1) {\n\twhile (bufchain_size(&ssh->queued_incoming_data) > 0 || datalen > 0) {\n\t    if (ssh->frozen) {\n\t\tssh_queue_incoming_data(ssh, &data, &datalen);\n\t\tbreak;\n\t    } else if (bufchain_size(&ssh->queued_incoming_data) > 0) {\n\t\tssh_process_queued_incoming_data(ssh);\n\t    } else {\n\t\tssh_process_incoming_data(ssh, &data, &datalen);\n\t    }\n\t    if (ssh->state == SSH_STATE_CLOSED)\n\t\treturn;\n\t}\n\tcrReturnV;\n    }\n    crFinishV;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188552, "func": "void fht16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht16x16_c(in, out, stride, tx_type);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187715, "func": " sequential_row(standard_display *dp, png_structp pp, png_infop pi,\n    PNG_CONST int iImage, PNG_CONST int iDisplay)\n {\n   PNG_CONST int         npasses = dp->npasses;\n   PNG_CONST int         do_interlace = dp->do_interlace &&\n       dp->interlace_type == PNG_INTERLACE_ADAM7;\n   PNG_CONST png_uint_32 height = standard_height(pp, dp->id);\n   PNG_CONST png_uint_32 width = standard_width(pp, dp->id);\n   PNG_CONST png_store*  ps = dp->ps;\n    int pass;\n \n    for (pass=0; pass<npasses; ++pass)\n {\n      png_uint_32 y;\n      png_uint_32 wPass = PNG_PASS_COLS(width, pass);\n\n for (y=0; y<height; ++y)\n {\n if (do_interlace)\n {\n if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass))\n {\n               png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX];\n\n               memset(row, 0xc5, sizeof row);\n               memset(display, 0x5c, sizeof display);\n\n               png_read_row(pp, row, display);\n\n \n                if (iImage >= 0)\n                   deinterlace_row(store_image_row(ps, pp, iImage, y), row,\n                     dp->pixel_size, dp->w, pass);\n \n                if (iDisplay >= 0)\n                   deinterlace_row(store_image_row(ps, pp, iDisplay, y), display,\n                     dp->pixel_size, dp->w, pass);\n             }\n          }\n          else\n            png_read_row(pp,\n               iImage >= 0 ? store_image_row(ps, pp, iImage, y) : NULL,\n               iDisplay >= 0 ? store_image_row(ps, pp, iDisplay, y) : NULL);\n }\n }\n\n   png_read_end(pp, pi);\n}\n", "target": 1, "flaw_line_index": "2,4,5,7,8,9,33,37"}
{"idx": 8372, "func": "static void mptsas_process_ioc_facts(MPTSASState *s,\n                                     MPIMsgIOCFacts *req)\n{\n    MPIMsgIOCFactsReply reply;\n\n    mptsas_fix_ioc_facts_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    memset(&reply, 0, sizeof(reply));\n    reply.MsgVersion                 = 0x0105;\n    reply.MsgLength                  = sizeof(reply) / 4;\n    reply.Function                   = req->Function;\n    reply.MsgContext                 = req->MsgContext;\n    reply.MaxChainDepth              = MPTSAS_MAXIMUM_CHAIN_DEPTH;\n    reply.WhoInit                    = s->who_init;\n    reply.BlockSize                  = MPTSAS_MAX_REQUEST_SIZE / sizeof(uint32_t);\n    reply.ReplyQueueDepth            = ARRAY_SIZE(s->reply_post) - 1;\n    QEMU_BUILD_BUG_ON(ARRAY_SIZE(s->reply_post) != ARRAY_SIZE(s->reply_free));\n\n    reply.RequestFrameSize           = 128;\n    reply.ProductID                  = MPTSAS1068_PRODUCT_ID;\n    reply.CurrentHostMfaHighAddr     = s->host_mfa_high_addr >> 32;\n    reply.GlobalCredits              = ARRAY_SIZE(s->request_post) - 1;\n    reply.NumberOfPorts              = MPTSAS_NUM_PORTS;\n    reply.CurrentSenseBufferHighAddr = s->sense_buffer_high_addr >> 32;\n    reply.CurReplyFrameSize          = s->reply_frame_size;\n    reply.MaxDevices                 = s->max_devices;\n    reply.MaxBuses                   = s->max_buses;\n    reply.FWVersionDev               = 0;\n    reply.FWVersionUnit              = 0x92;\n    reply.FWVersionMinor             = 0x32;\n    reply.FWVersionMajor             = 0x1;\n\n    mptsas_fix_ioc_facts_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187960, "func": " status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n size_t len = snprintf(buffer, SIZE, \"Client[%d] (%p) PID: %d\\n\",\n            mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    len = (len > SIZE - 1) ? SIZE - 1 : len;\n    write(fd, buffer, len);\n return mHardware->dump(fd, args);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187594, "func": "uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)\n{\n    ulg  rowbytes;\n\n\n\n\n *pRowbytes = rowbytes = channels*width;\n *pChannels = channels;\n\n if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {\n return NULL;\n }\n\n Trace((stderr, \"readpng_get_image:  rowbytes = %ld, height = %ld\\n\", rowbytes, height));\n\n\n \n \n    fread(image_data, 1L, rowbytes*height, saved_infile);\n \n     return image_data;\n }\n", "target": 1, "flaw_line_index": "20"}
{"idx": 8711, "func": "url_escape_unsafe_and_reserved (const char *s)\n{\n  return url_escape_1 (s, urlchr_unsafe|urlchr_reserved, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187881, "func": "long Tracks::ParseTrackEntry(long long track_start, long long track_size,\n long long element_start, long long element_size,\n Track*& pResult) const {\n if (pResult)\n return -1;\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = track_start;\n const long long track_stop = track_start + track_size;\n\n Track::Info info;\n\n  info.type = 0;\n  info.number = 0;\n  info.uid = 0;\n  info.defaultDuration = 0;\n\n Track::Settings v;\n  v.start = -1;\n  v.size = -1;\n\n Track::Settings a;\n  a.start = -1;\n  a.size = -1;\n\n Track::Settings e; \n  e.start = -1;\n  e.size = -1;\n\n long long lacing = 1; \n\n while (pos < track_stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, track_stop, id, size);\n\n if (status < 0) \n return status;\n\n if (size < 0)\n return E_FILE_FORMAT_INVALID;\n\n const long long start = pos;\n\n if (id == 0x60) { \n      v.start = start;\n      v.size = size;\n } else if (id == 0x61) { \n      a.start = start;\n      a.size = size;\n } else if (id == 0x2D80) { \n      e.start = start;\n      e.size = size;\n } else if (id == 0x33C5) { \n if (size > 8)\n return E_FILE_FORMAT_INVALID;\n\n      info.uid = 0;\n\n long long pos_ = start;\n const long long pos_end = start + size;\n\n while (pos_ != pos_end) {\n unsigned char b;\n\n const int status = pReader->Read(pos_, 1, &b);\n\n if (status)\n return status;\n\n        info.uid <<= 8;\n        info.uid |= b;\n\n ++pos_;\n }\n } else if (id == 0x57) { \n const long long num = UnserializeUInt(pReader, pos, size);\n\n if ((num <= 0) || (num > 127))\n return E_FILE_FORMAT_INVALID;\n\n      info.number = static_cast<long>(num);\n } else if (id == 0x03) { \n const long long type = UnserializeUInt(pReader, pos, size);\n\n if ((type <= 0) || (type > 254))\n return E_FILE_FORMAT_INVALID;\n\n      info.type = static_cast<long>(type);\n } else if (id == 0x136E) { \n const long status =\n UnserializeString(pReader, pos, size, info.nameAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x02B59C) { \n const long status = UnserializeString(pReader, pos, size, info.language);\n\n if (status)\n return status;\n } else if (id == 0x03E383) { \n const long long duration = UnserializeUInt(pReader, pos, size);\n\n if (duration < 0)\n return E_FILE_FORMAT_INVALID;\n\n      info.defaultDuration = static_cast<unsigned long long>(duration);\n } else if (id == 0x06) { \n const long status = UnserializeString(pReader, pos, size, info.codecId);\n\n if (status)\n return status;\n } else if (id == 0x1C) { \n      lacing = UnserializeUInt(pReader, pos, size);\n\n if ((lacing < 0) || (lacing > 1))\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x23A2) { \n delete[] info.codecPrivate;\n      info.codecPrivate = NULL;\n      info.codecPrivateSize = 0;\n\n\n       const size_t buflen = static_cast<size_t>(size);\n \n       if (buflen) {\n        typedef unsigned char* buf_t;\n        const buf_t buf = new (std::nothrow) unsigned char[buflen];\n \n         if (buf == NULL)\n           return -1;\n\n const int status = pReader->Read(pos, static_cast<long>(buflen), buf);\n\n if (status) {\n delete[] buf;\n return status;\n }\n\n        info.codecPrivate = buf;\n        info.codecPrivateSize = buflen;\n }\n } else if (id == 0x058688) { \n const long status =\n UnserializeString(pReader, pos, size, info.codecNameAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x16AA) { \n      info.codecDelay = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x16BB) { \n      info.seekPreRoll = UnserializeUInt(pReader, pos, size);\n\n     }\n \n     pos += size;  \n    assert(pos <= track_stop);\n   }\n \n  assert(pos == track_stop);\n \n   if (info.number <= 0)  \n     return E_FILE_FORMAT_INVALID;\n\n if (GetTrackByNumber(info.number))\n return E_FILE_FORMAT_INVALID;\n\n if (info.type <= 0) \n return E_FILE_FORMAT_INVALID;\n\n  info.lacing = (lacing > 0) ? true : false;\n\n if (info.type == Track::kVideo) {\n if (v.start < 0)\n return E_FILE_FORMAT_INVALID;\n\n if (a.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings = v;\n\n VideoTrack* pTrack = NULL;\n\n const long status = VideoTrack::Parse(m_pSegment, info, element_start,\n                                          element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n\n if (e.start >= 0)\n      pResult->ParseContentEncodingsEntry(e.start, e.size);\n } else if (info.type == Track::kAudio) {\n if (a.start < 0)\n return E_FILE_FORMAT_INVALID;\n\n if (v.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings = a;\n\n AudioTrack* pTrack = NULL;\n\n const long status = AudioTrack::Parse(m_pSegment, info, element_start,\n                                          element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n\n if (e.start >= 0)\n      pResult->ParseContentEncodingsEntry(e.start, e.size);\n } else {\n\n if (a.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n if (v.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n if (info.type == Track::kMetadata && e.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings.start = -1;\n    info.settings.size = 0;\n\n Track* pTrack = NULL;\n\n const long status =\n Track::Create(m_pSegment, info, element_start, element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n }\n\n return 0; \n}\n", "target": 1, "flaw_line_index": "128,129,158,161"}
{"idx": 187598, "func": "int writepng_init(mainprog_info *mainprog_ptr)\n{\n    png_structp  png_ptr; \n    png_infop  info_ptr;\n int color_type, interlace_type;\n\n\n \n \n    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n       writepng_error_handler, NULL);\n     if (!png_ptr)\n         return 4;   \n\n    info_ptr = png_create_info_struct(png_ptr);\n if (!info_ptr) {\n        png_destroy_write_struct(&png_ptr, NULL);\n return 4; \n }\n\n\n\n if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n return 2;\n }\n\n\n\n    png_init_io(png_ptr, mainprog_ptr->outfile);\n\n\n\n    png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);\n\n\n\n if (mainprog_ptr->pnmtype == 5)\n        color_type = PNG_COLOR_TYPE_GRAY;\n else if (mainprog_ptr->pnmtype == 6)\n        color_type = PNG_COLOR_TYPE_RGB;\n else if (mainprog_ptr->pnmtype == 8)\n        color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n else {\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n return 11;\n }\n\n    interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 :\n                                               PNG_INTERLACE_NONE;\n\n    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,\n      mainprog_ptr->sample_depth, color_type, interlace_type,\n      PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n if (mainprog_ptr->gamma > 0.0)\n        png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma);\n\n if (mainprog_ptr->have_bg) { \n        png_color_16  background;\n\n        background.red = mainprog_ptr->bg_red;\n        background.green = mainprog_ptr->bg_green;\n        background.blue = mainprog_ptr->bg_blue;\n        png_set_bKGD(png_ptr, info_ptr, &background);\n }\n\n if (mainprog_ptr->have_time) {\n        png_time  modtime;\n\n png_convert_from_time_t(&modtime, mainprog_ptr->modtime);\n        png_set_tIME(png_ptr, info_ptr, &modtime);\n }\n\n if (mainprog_ptr->have_text) {\n        png_text  text[6];\n int  num_text = 0;\n\n if (mainprog_ptr->have_text & TEXT_TITLE) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Title\";\n            text[num_text].text = mainprog_ptr->title;\n ++num_text;\n }\n if (mainprog_ptr->have_text & TEXT_AUTHOR) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Author\";\n            text[num_text].text = mainprog_ptr->author;\n ++num_text;\n }\n if (mainprog_ptr->have_text & TEXT_DESC) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Description\";\n            text[num_text].text = mainprog_ptr->desc;\n ++num_text;\n }\n if (mainprog_ptr->have_text & TEXT_COPY) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"Copyright\";\n            text[num_text].text = mainprog_ptr->copyright;\n ++num_text;\n }\n if (mainprog_ptr->have_text & TEXT_EMAIL) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"E-mail\";\n            text[num_text].text = mainprog_ptr->email;\n ++num_text;\n }\n if (mainprog_ptr->have_text & TEXT_URL) {\n            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;\n            text[num_text].key = \"URL\";\n            text[num_text].text = mainprog_ptr->url;\n ++num_text;\n }\n        png_set_text(png_ptr, info_ptr, text, num_text);\n }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n\n\n    png_set_packing(png_ptr);\n\n\n\n    mainprog_ptr->png_ptr = png_ptr;\n    mainprog_ptr->info_ptr = info_ptr;\n\n\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 188113, "func": "WORD32 ixheaacd_real_synth_filt(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,\n                                WORD32 num_columns, FLOAT32 qmf_buf_real[][64],\n                                FLOAT32 qmf_buf_imag[][64]) {\n  WORD32 i, j, k, l, idx;\n  FLOAT32 g[640];\n  FLOAT32 w[640];\n  FLOAT32 synth_out[128];\n  FLOAT32 accu_r;\n  WORD32 synth_size = ptr_hbe_txposer->synth_size;\n  FLOAT32 *ptr_cos_tab_trans_qmf =\n (FLOAT32 *)&ixheaacd_cos_table_trans_qmf[0][0] +\n      ptr_hbe_txposer->k_start * 32;\n  FLOAT32 *buffer = ptr_hbe_txposer->synth_buf;\n\n for (idx = 0; idx < num_columns; idx++) {\n    FLOAT32 loc_qmf_buf[64];\n    FLOAT32 *synth_buf_r = loc_qmf_buf;\n    FLOAT32 *out_buf = ptr_hbe_txposer->ptr_input_buf +\n (idx + 1) * ptr_hbe_txposer->synth_size;\n    FLOAT32 *synth_cos_tab = ptr_hbe_txposer->synth_cos_tab;\n const FLOAT32 *interp_window_coeff = ptr_hbe_txposer->synth_wind_coeff;\n if (ptr_hbe_txposer->k_start < 0) return -1;\n for (k = 0; k < synth_size; k++) {\n      WORD32 ki = ptr_hbe_txposer->k_start + k;\n      synth_buf_r[k] = (FLOAT32)(\n          ptr_cos_tab_trans_qmf[(k << 1) + 0] * qmf_buf_real[idx][ki] +\n          ptr_cos_tab_trans_qmf[(k << 1) + 1] * qmf_buf_imag[idx][ki]);\n\n      synth_buf_r[k + ptr_hbe_txposer->synth_size] = 0;\n }\n\n for (l = (20 * synth_size - 1); l >= 2 * synth_size; l--) {\n      buffer[l] = buffer[l - 2 * synth_size];\n }\n\n if (synth_size == 20) {\n      FLOAT32 *psynth_cos_tab = synth_cos_tab;\n\n for (l = 0; l < (synth_size + 1); l++) {\n        accu_r = 0.0;\n for (k = 0; k < synth_size; k++) {\n          accu_r += synth_buf_r[k] * psynth_cos_tab[k];\n }\n        buffer[0 + l] = accu_r;\n        buffer[synth_size - l] = accu_r;\n        psynth_cos_tab = psynth_cos_tab + synth_size;\n }\n for (l = (synth_size + 1); l < (2 * synth_size - synth_size / 2); l++) {\n        accu_r = 0.0;\n for (k = 0; k < synth_size; k++) {\n          accu_r += synth_buf_r[k] * psynth_cos_tab[k];\n }\n        buffer[0 + l] = accu_r;\n        buffer[3 * synth_size - l] = -accu_r;\n        psynth_cos_tab = psynth_cos_tab + synth_size;\n }\n      accu_r = 0.0;\n for (k = 0; k < synth_size; k++) {\n        accu_r += synth_buf_r[k] * psynth_cos_tab[k];\n }\n      buffer[3 * synth_size >> 1] = accu_r;\n } else {\n      FLOAT32 tmp;\n      FLOAT32 *ptr_u = synth_out;\n      WORD32 kmax = (synth_size >> 1);\n\n       FLOAT32 *syn_buf = &buffer[kmax];\n       kmax += synth_size;\n \n      if (ixheaacd_real_synth_fft != NULL)\n        (*ixheaacd_real_synth_fft)(synth_buf_r, synth_out, synth_size * 2);\n       else\n         return -1;\n \n for (k = 0; k < kmax; k++) {\n        tmp = ((*ptr_u++) * (*synth_cos_tab++));\n        tmp -= ((*ptr_u++) * (*synth_cos_tab++));\n *syn_buf++ = tmp;\n }\n\n      syn_buf = &buffer[0];\n      kmax -= synth_size;\n\n for (k = 0; k < kmax; k++) {\n        tmp = ((*ptr_u++) * (*synth_cos_tab++));\n        tmp -= ((*ptr_u++) * (*synth_cos_tab++));\n *syn_buf++ = tmp;\n }\n }\n\n for (i = 0; i < 5; i++) {\n      memcpy(&g[(2 * i + 0) * synth_size], &buffer[(4 * i + 0) * synth_size],\n sizeof(FLOAT32) * synth_size);\n      memcpy(&g[(2 * i + 1) * synth_size], &buffer[(4 * i + 3) * synth_size],\n sizeof(FLOAT32) * synth_size);\n }\n\n for (k = 0; k < 10 * synth_size; k++) {\n      w[k] = g[k] * interp_window_coeff[k];\n }\n\n for (i = 0; i < synth_size; i++) {\n      accu_r = 0.0;\n for (j = 0; j < 10; j++) {\n        accu_r = accu_r + w[synth_size * j + i];\n }\n      out_buf[i] = (FLOAT32)accu_r;\n }\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": "70,71"}
{"idx": 187606, "func": "main(int argc, char **argv)\n{\n FILE *fp = stdout;\n\n    const char *file_name = NULL;\n    int color_type = 8; \n    int bit_depth = 32; \n    unsigned int colors[5];\n    unsigned int filters = PNG_ALL_FILTERS;\n    png_fixed_point gamma = 0; \n   chunk_insert *head_insert = NULL;\n   chunk_insert **insert_ptr = &head_insert;\n\n   memset(colors, 0, sizeof colors);\n\n while (--argc > 0)\n\n    {\n       char *arg = *++argv;\n \n       if (strcmp(arg, \"--sRGB\") == 0)\n       {\n          gamma = PNG_DEFAULT_sRGB;\n continue;\n }\n\n if (strcmp(arg, \"--linear\") == 0)\n {\n         gamma = PNG_FP_1;\n continue;\n }\n\n if (strcmp(arg, \"--1.8\") == 0)\n {\n         gamma = PNG_GAMMA_MAC_18;\n continue;\n }\n\n if (strcmp(arg, \"--nofilters\") == 0)\n {\n         filters = PNG_FILTER_NONE;\n continue;\n }\n\n if (strncmp(arg, \"--color=\", 8) == 0)\n {\n          parse_color(arg+8, colors);\n continue;\n }\n\n if (argc >= 3 && strcmp(arg, \"--insert\") == 0)\n {\n         png_const_charp what = *++argv;\n         png_charp param = *++argv;\n         chunk_insert *new_insert;\n\n         argc -= 2;\n\n         new_insert = find_insert(what, param);\n\n if (new_insert != NULL)\n {\n *insert_ptr = new_insert;\n            insert_ptr = &new_insert->next;\n }\n\n continue;\n }\n\n if (arg[0] == '-')\n {\n         fprintf(stderr, \"makepng: %s: invalid option\\n\", arg);\n         exit(1);\n }\n\n if (strcmp(arg, \"palette\") == 0)\n {\n         color_type = PNG_COLOR_TYPE_PALETTE;\n continue;\n }\n\n if (strncmp(arg, \"gray\", 4) == 0)\n {\n if (arg[4] == 0)\n {\n            color_type = PNG_COLOR_TYPE_GRAY;\n continue;\n }\n\n else if (strcmp(arg+4, \"a\") == 0 ||\n            strcmp(arg+4, \"alpha\") == 0 ||\n            strcmp(arg+4, \"-alpha\") == 0)\n {\n            color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n continue;\n }\n }\n\n if (strncmp(arg, \"rgb\", 3) == 0)\n {\n if (arg[3] == 0)\n {\n            color_type = PNG_COLOR_TYPE_RGB;\n continue;\n }\n\n else if (strcmp(arg+3, \"a\") == 0 ||\n            strcmp(arg+3, \"alpha\") == 0 ||\n            strcmp(arg+3, \"-alpha\") == 0)\n {\n            color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n continue;\n }\n }\n\n if (color_type == 8 && isdigit(arg[0]))\n {\n         color_type = atoi(arg);\n if (color_type < 0 || color_type > 6 || color_type == 1 ||\n            color_type == 5)\n {\n            fprintf(stderr, \"makepng: %s: not a valid color type\\n\", arg);\n            exit(1);\n }\n\n continue;\n }\n\n if (bit_depth == 32 && isdigit(arg[0]))\n {\n         bit_depth = atoi(arg);\n if (bit_depth <= 0 || bit_depth > 16 ||\n (bit_depth & -bit_depth) != bit_depth)\n {\n            fprintf(stderr, \"makepng: %s: not a valid bit depth\\n\", arg);\n            exit(1);\n }\n\n continue;\n }\n\n if (argc == 1) \n {\n         fp = fopen(arg, \"wb\");\n if (fp == NULL)\n {\n            fprintf(stderr, \"%s: %s: could not open\\n\", arg, strerror(errno));\n            exit(1);\n }\n\n         file_name = arg;\n continue;\n }\n\n      fprintf(stderr, \"makepng: %s: unknown argument\\n\", arg);\n      exit(1);\n } \n\n \n    if (color_type == 8 || bit_depth == 32)\n    {\n      fprintf(stderr, \"usage: makepng [--sRGB|--linear|--1.8] \"\n          \"[--color=...] color-type bit-depth [file-name]\\n\"\n         \"  Make a test PNG file, by default writes to stdout.\\n\");\n       exit(1);\n    }\n \n {\n const unsigned int lim = (color_type == PNG_COLOR_TYPE_PALETTE ? 255U :\n (1U<<bit_depth)-1);\n unsigned int i;\n\n for (i=1; i<=colors[0]; ++i)\n if (colors[i] > lim)\n {\n            fprintf(stderr, \"makepng: --color=...: %u out of range [0..%u]\\n\",\n               colors[i], lim);\n            exit(1);\n\n          }\n    }\n \n   if (filters == PNG_ALL_FILTERS)\n    {\n       if ((color_type & PNG_COLOR_MASK_PALETTE) != 0 || bit_depth < 8)\n          filters = PNG_FILTER_NONE;\n\n else if (color_type & PNG_COLOR_MASK_COLOR) \n {\n if (bit_depth == 8)\n            filters &= ~(PNG_FILTER_NONE | PNG_FILTER_AVG);\n\n else\n            filters = PNG_FILTER_SUB | PNG_FILTER_PAETH;\n }\n\n else \n\n          filters &= ~PNG_FILTER_NONE;\n    }\n \n    {\n       int ret = write_png(&file_name, fp, color_type, bit_depth, gamma,\n         head_insert, filters, colors);\n \n       if (ret != 0 && file_name != NULL)\n          remove(file_name);\n\n return ret;\n }\n}\n", "target": 1, "flaw_line_index": "162,164,183,204"}
{"idx": 187785, "func": " status_t NuPlayer::GenericSource::setBuffers(\n         bool audio, Vector<MediaBuffer *> &buffers) {\n    if (mIsSecure && !audio) {\n         return mVideoTrack.mSource->setBuffers(buffers);\n     }\n     return INVALID_OPERATION;\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8735, "func": "static X509 *lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)\n{\n    STACK_OF(X509) *certs;\n    X509 *xtmp = NULL;\n    int i;\n    certs = ctx->lookup_certs(ctx, X509_get_subject_name(x));\n    if (certs == NULL)\n        return NULL;\n    for (i = 0; i < sk_X509_num(certs); i++) {\n        xtmp = sk_X509_value(certs, i);\n        if (!X509_cmp(xtmp, x))\n            break;\n    }\n    if (i < sk_X509_num(certs))\n        CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n    else\n        xtmp = NULL;\n    sk_X509_pop_free(certs, X509_free);\n    return xtmp;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187681, "func": "interlace_row(png_bytep buffer, png_const_bytep imageRow,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   png_uint_32 xin, xout, xstep;\n   xin = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xout=0; xin<w; xin+=xstep)\n   {\n      pixel_copy(buffer, xout, imageRow, xin, pixel_size);\n      ++xout;\n   }\n}\n", "target": 1, "flaw_line_index": "2,3,4,4,4,5,6,7,8,9,10,11,12"}
{"idx": 188069, "func": "status_t BnHDCP::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case HDCP_SET_OBSERVER:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n return OK;\n }\n\n case HDCP_INIT_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n const char *host = data.readCString();\n unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n return OK;\n }\n\n case HDCP_SHUTDOWN_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n return OK;\n }\n\n case HDCP_GET_CAPS:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n return OK;\n }\n\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n             }\n             if (inData == NULL) {\n                 reply->writeInt32(ERROR_OUT_OF_RANGE);\n                 return OK;\n }\n\n \n             void *outData = (uint8_t *)inData + size;\n \n            data.read(inData, size);\n \n             uint32_t streamCTR = data.readInt32();\n             uint64_t inputCTR;\n            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n \n             reply->writeInt32(err);\n \n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n case HDCP_ENCRYPT_NATIVE:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n size_t offset = data.readInt32();\n size_t size = data.readInt32();\n uint32_t streamCTR = data.readInt32();\n void *outData = malloc(size);\n uint64_t inputCTR;\n\n status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(outData);\n            outData = NULL;\n\n return OK;\n }\n\n case HDCP_DECRYPT:\n {\n size_t size = data.readInt32();\n size_t bufSize = 2 * size;\n\n void *inData = NULL;\n if (bufSize > size) {\n                inData = malloc(bufSize);\n }\n\n if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n return OK;\n }\n\n void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR = data.readInt64();\n status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "46,47,49,50,60,64"}
{"idx": 187826, "func": "Cluster* Cluster::Create(Segment* pSegment, long idx, long long off)\n{\n  assert(pSegment);\n  assert(off >= 0);\n \n   const long long element_start = pSegment->m_start + off;\n \n  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);\n  assert(pCluster);\n \n   return pCluster;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,9,10,11"}
{"idx": 9005, "func": "vmxnet3_inc_rx_consumption_counter(VMXNET3State *s, int qidx, int ridx)\n{\n    vmxnet3_ring_inc(&s->rxq_descr[qidx].rx_ring[ridx]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8904, "func": "void *vrend_renderer_get_cursor_contents(uint32_t res_handle, uint32_t *width, uint32_t *height)\n{\n   GLenum format, type;\n   struct vrend_resource *res;\n   int blsize;\n   char *data, *data2;\n   int size;\n   int h;\n\n   res = vrend_resource_lookup(res_handle, 0);\n   if (!res)\n      return NULL;\n\n   if (res->base.width0 > 128 || res->base.height0 > 128)\n      return NULL;\n\n   if (res->target != GL_TEXTURE_2D)\n      return NULL;\n\n   if (width)\n      *width = res->base.width0;\n   if (height)\n      *height = res->base.height0;\n   format = tex_conv_table[res->base.format].glformat;\n   type = tex_conv_table[res->base.format].gltype;\n   blsize = util_format_get_blocksize(res->base.format);\n   size = util_format_get_nblocks(res->base.format, res->base.width0, res->base.height0) * blsize;\n   data = malloc(size);\n   data2 = malloc(size);\n\n   if (!data || !data2) {\n      free(data);\n      free(data2);\n      return NULL;\n   }\n\n   glBindTexture(res->target, res->id);\n   glGetnTexImageARB(res->target, 0, format, type, size, data);\n\n   for (h = 0; h < res->base.height0; h++) {\n      uint32_t doff = (res->base.height0 - h - 1) * res->base.width0 * blsize;\n      uint32_t soff = h * res->base.width0 * blsize;\n\n      memcpy(data2 + doff, data + soff, res->base.width0 * blsize);\n   }\n   free(data);\n\n   return data2;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187483, "func": " int btsock_thread_exit(int h)\n {\n if(h < 0 || h >= MAX_THREAD)\n {\n        APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\n return FALSE;\n }\n if(ts[h].cmd_fdw == -1)\n {\n        APPL_TRACE_ERROR(\"cmd socket is not created\");\n\n         return FALSE;\n     }\n     sock_cmd_t cmd = {CMD_EXIT, 0, 0, 0, 0};\n    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))\n     {\n         pthread_join(ts[h].thread_id, 0);\n         pthread_mutex_lock(&thread_slot_lock);\n        free_thread_slot(h);\n        pthread_mutex_unlock(&thread_slot_lock);\n return TRUE;\n }\n return FALSE;\n}\n", "target": 1, "flaw_line_index": "15"}
{"idx": 187664, "func": "image_transform_png_set_rgb_to_gray_ini(PNG_CONST image_transform *this,\n     transform_display *that)\n {\n    png_modifier *pm = that->pm;\n   PNG_CONST color_encoding *e = pm->current_encoding;\n \n    UNUSED(this)\n \n   pm->test_uses_encoding = 1;\n\n if (e != 0)\n {\n\n      PNG_CONST double whiteY = e->red.Y + e->green.Y + e->blue.Y;\n \n       data.red_coefficient = e->red.Y;\n       data.green_coefficient = e->green.Y;\n      data.blue_coefficient = e->blue.Y;\n\n if (whiteY != 1)\n {\n         data.red_coefficient /= whiteY;\n         data.green_coefficient /= whiteY;\n         data.blue_coefficient /= whiteY;\n }\n }\n\n\n    else\n    {\n      data.red_coefficient = 6968 / 32768.;\n      data.green_coefficient = 23434 / 32768.;\n      data.blue_coefficient = 2366 / 32768.;\n    }\n \n    data.gamma = pm->current_gamma;\n\n if (data.gamma == 0)\n      data.gamma = 1;\n\n if (pm->test_exhaustive)\n {\n      data.coefficients_overridden = !data.coefficients_overridden;\n      pm->repeat = data.coefficients_overridden != 0;\n }\n\n else\n      data.coefficients_overridden = random_choice();\n\n if (data.coefficients_overridden)\n {\n      png_uint_32 ru;\n double total;\n\n      RANDOMIZE(ru);\n      data.green_coefficient = total = (ru & 0xffff) / 65535.;\n      ru >>= 16;\n      data.red_coefficient = (1 - total) * (ru & 0xffff) / 65535.;\n      total += data.red_coefficient;\n      data.blue_coefficient = 1 - total;\n\n#     ifdef PNG_FLOATING_POINT_SUPPORTED\n         data.red_to_set = data.red_coefficient;\n         data.green_to_set = data.green_coefficient;\n#     else\n         data.red_to_set = fix(data.red_coefficient);\n         data.green_to_set = fix(data.green_coefficient);\n#     endif\n\n      pm->encoding_ignored = 1;\n }\n\n else\n {\n      data.red_to_set = -1;\n      data.green_to_set = -1;\n }\n\n if (data.gamma != 1) \n {\n if (that->this.bit_depth == 16 || pm->assume_16_bit_calculations)\n {\n          that->pm->limit += pow(\n#           if PNG_MAX_GAMMA_8 < 14\n               (that->this.bit_depth == 16 ? 8. :\n                  6. + (1<<(15-PNG_MAX_GAMMA_8)))\n#           else\n               8.\n#           endif\n               /65535, data.gamma);\n       }\n \n       else\n {\n          that->pm->limit += pow(\n#           if DIGITIZE\n               1.1\n#           else\n               1.\n#           endif\n               /255, data.gamma);\n       }\n    }\n \n else\n {\n if (that->this.bit_depth != 16 && !pm->assume_16_bit_calculations)\n         that->pm->limit += 4E-3;\n }\n\n }\n", "target": 1, "flaw_line_index": "5,14,31,32,33,84,85,86,87,88,89,90,96,97,98,99,100,101"}
{"idx": 8923, "func": "static void vrend_renderer_use_threaded_sync(void)\n{\n   struct virgl_gl_ctx_param ctx_params;\n\n   if (getenv(\"VIRGL_DISABLE_MT\"))\n      return;\n\n   ctx_params.shared = true;\n   ctx_params.major_ver = vrend_state.gl_major_ver;\n   ctx_params.minor_ver = vrend_state.gl_minor_ver;\n\n   vrend_state.stop_sync_thread = false;\n\n   vrend_state.sync_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   if (vrend_state.sync_context == NULL) {\n      fprintf(stderr, \"failed to create sync opengl context\\n\");\n      return;\n   }\n\n   vrend_state.eventfd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);\n   if (vrend_state.eventfd == -1) {\n      fprintf(stderr, \"Failed to create eventfd\\n\");\n      vrend_clicbs->destroy_gl_context(vrend_state.sync_context);\n      return;\n   }\n\n   pipe_condvar_init(vrend_state.fence_cond);\n   pipe_mutex_init(vrend_state.fence_mutex);\n\n   vrend_state.sync_thread = pipe_thread_create(thread_sync, NULL);\n   if (!vrend_state.sync_thread) {\n      close(vrend_state.eventfd);\n      vrend_state.eventfd = -1;\n      vrend_clicbs->destroy_gl_context(vrend_state.sync_context);\n      pipe_condvar_destroy(vrend_state.fence_cond);\n      pipe_mutex_destroy(vrend_state.fence_mutex);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8629, "func": "eth_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    struct xlx_ethlite *s = opaque;\n    uint32_t r = 0;\n\n    addr >>= 2;\n\n    switch (addr)\n    {\n        case R_TX_GIE0:\n        case R_TX_LEN0:\n        case R_TX_LEN1:\n        case R_TX_CTRL1:\n        case R_TX_CTRL0:\n        case R_RX_CTRL1:\n        case R_RX_CTRL0:\n            r = s->regs[addr];\n            D(qemu_log(\"%s \" TARGET_FMT_plx \"=%x\\n\", __func__, addr * 4, r));\n            break;\n\n        default:\n            r = tswap32(s->regs[addr]);\n            break;\n    }\n    return r;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8660, "func": "size_t mptsas_config_phy_0(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_phy_addr_get(s, address);\n    SCSIDevice *dev;\n\n    if (i < 0) {\n        trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n        return i;\n    }\n\n    dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n    trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n\n    return MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,\n                                  \"w*wqwb*blbb*b*b*l\",\n                                  dev_handle, s->sas_addr, dev_handle, i,\n                                  (dev\n                                   ? MPI_SAS_DEVICE_INFO_END_DEVICE \n                                   : MPI_SAS_DEVICE_INFO_NO_DEVICE),\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5,\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187559, "func": "status_t MediaPlayer::setDataSource(\n const sp<IMediaHTTPService> &httpService,\n const char *url, const KeyedVector<String8, String8> *headers)\n{\n\n     ALOGV(\"setDataSource(%s)\", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(httpService, url, headers))) {\n                player.clear();\n }\n            err = attachNewPlayer(player);\n }\n }\n return err;\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 188615, "func": " void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n    memset(src_, i, block_size_);\n     for (int j = 0; j <= 255; ++j) {\n      memset(ref_, j, block_size_);\n       unsigned int sse;\n       unsigned int var;\n      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \"ref values: \" << j;\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "3,5,8,9"}
{"idx": 9004, "func": "vmxnet3_inc_rx_completion_counter(VMXNET3State *s, int qidx)\n{\n    vmxnet3_ring_inc(&s->rxq_descr[qidx].comp_ring);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187604, "func": "insert_hIST(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params)\n {\n    int i;\n    png_uint_16 freq[256];\n\n   memset(freq, 0, sizeof freq);\n for (i=0; i<nparams; ++i)\n {\n char *endptr = NULL;\n unsigned long int l = strtoul(params[i], &endptr, 0\n);\n\n if (params[i][0] && *endptr == 0 && l <= 65535)\n         freq[i] = (png_uint_16)l;\n\n else\n {\n         fprintf(stderr, \"hIST[%d]: %s: invalid frequency\\n\", i, params[i]);\n         exit(1);\n }\n }\n\n\n    png_set_hIST(png_ptr, info_ptr, freq);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9066, "func": "static void vmxnet3_trigger_interrupt(VMXNET3State *s, int lidx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    s->interrupt_states[lidx].is_pending = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n\n    if (s->msix_used && msix_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    if (msi_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    return;\n\ndo_automask:\n    s->interrupt_states[lidx].is_masked = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8647, "func": "size_t mptsas_config_ioc_6(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(6, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                              \"*l*b*b*b*b*b*b*b*b*b*b*w*l*l*l*l*b*b*w\"\n                              \"*w*w*w*w*l*l*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187673, "func": " image_transform_png_set_strip_alpha_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n return (colour_type & PNG_COLOR_MASK_ALPHA) != 0;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187912, "func": "char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,\n uintptr_t abort_msg_address, bool dump_sibling_threads,\n bool* detach_failed, int* total_sleep_time_usec) {\n\n log_t log;\n\n   log.current_tid = tid;\n   log.crashed_tid = tid;\n \n  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {\n    _LOG(&log, logtype::ERROR, \"failed to create %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {\n    _LOG(&log, logtype::ERROR, \"failed to change ownership of %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n   int fd = -1;\n  char* path = NULL;\n  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {\n    path = find_and_open_tombstone(&fd);\n  } else {\n    _LOG(&log, logtype::ERROR, \"Failed to restore security context, not writing tombstone.\\n\");\n  }\n \n   if (fd < 0) {\n     _LOG(&log, logtype::ERROR, \"Skipping tombstone write, nothing to do.\\n\");\n *detach_failed = false;\n return NULL;\n }\n\n  log.tfd = fd;\n int amfd = activity_manager_connect();\n  log.amfd = amfd;\n *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,\n                              dump_sibling_threads, total_sleep_time_usec);\n\n  ALOGI(\"\\nTombstone written to: %s\\n\", path);\n\n  close(amfd);\n  close(fd);\n\n return path;\n}\n", "target": 1, "flaw_line_index": "10,11,12,13,14,15,17,18,19,20,21,22"}
{"idx": 188521, "func": "void usage_exit() {\n   fprintf(stderr, \"Usage: %s <width> <height> <infile> <outfile> <frame>\\n\",\n           exec_name);\n   exit(EXIT_FAILURE);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188239, "func": "OMX_ERRORTYPE SoftOpus::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.opus\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAndroidOpus:\n {\n\n             const OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *opusParams =\n                 (const OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *)params;\n \n             if (opusParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8837, "func": "static void vrend_depth_test_enable(struct vrend_context *ctx, bool depth_test_enable)\n{\n   if (ctx->sub->depth_test_enabled != depth_test_enable) {\n      ctx->sub->depth_test_enabled = depth_test_enable;\n      if (depth_test_enable)\n         glEnable(GL_DEPTH_TEST);\n      else\n         glDisable(GL_DEPTH_TEST);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9148, "func": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\n    uint32_t max_frags, bool has_virt_hdr)\n{\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n\n    p->pci_dev = pci_dev;\n\n    p->vec = g_malloc((sizeof *p->vec) *\n        (max_frags + NET_TX_PKT_PL_START_FRAG));\n\n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n\n    p->max_payload_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n\n    *pkt = p;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9001, "func": "static void vmxnet3_get_tx_stats_from_file(QEMUFile *f,\n    struct UPT1_TxStats *tx_stat)\n{\n    tx_stat->TSOPktsTxOK = qemu_get_be64(f);\n    tx_stat->TSOBytesTxOK = qemu_get_be64(f);\n    tx_stat->ucastPktsTxOK = qemu_get_be64(f);\n    tx_stat->ucastBytesTxOK = qemu_get_be64(f);\n    tx_stat->mcastPktsTxOK = qemu_get_be64(f);\n    tx_stat->mcastBytesTxOK = qemu_get_be64(f);\n    tx_stat->bcastPktsTxOK = qemu_get_be64(f);\n    tx_stat->bcastBytesTxOK = qemu_get_be64(f);\n    tx_stat->pktsTxError = qemu_get_be64(f);\n    tx_stat->pktsTxDiscard = qemu_get_be64(f);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187892, "func": "Segment::~Segment() {\n const long count = m_clusterCount + m_clusterPreloadCount;\n\n Cluster** i = m_clusters;\n Cluster** j = m_clusters + count;\n\n \n   while (i != j) {\n     Cluster* const p = *i++;\n    assert(p);\n     delete p;\n   }\n \n delete[] m_clusters;\n\n delete m_pTracks;\n\n   delete m_pInfo;\n   delete m_pCues;\n   delete m_pChapters;\n   delete m_pSeekHead;\n }\n", "target": 1, "flaw_line_index": "10"}
{"idx": 188477, "func": "Block::~Block()\n{\n    delete[] m_frames;\n}\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 187641, "func": "image_transform_add(PNG_CONST image_transform **this, unsigned int max,\n    png_uint_32 counter, char *name, size_t sizeof_name, size_t *pos,\n    png_byte colour_type, png_byte bit_depth)\n {\n for (;;) \n {\n      png_uint_32 mask;\n      image_transform *list;\n\n if (counter == 0) \n {\n         image_transform_reset_count();\n if (max <= 1)\n            counter = 1;\n else\n            counter = random_32();\n }\n else \n {\n switch (max)\n {\n case 0: ++counter; break;\n case 1:  counter <<= 1; break;\n default: counter = random_32(); break;\n }\n }\n\n *this = &image_transform_end;\n list = image_transform_first;\n      mask = 1;\n\n while (list != &image_transform_end)\n {\n if ((counter & mask) != 0 && list->enable &&\n (max == 0 || list->local_use < max))\n {\n if (list->add(list, this, colour_type, bit_depth) || max == 0)\n {\n *pos = safecat(name, sizeof_name, *pos, \" +\");\n *pos = safecat(name, sizeof_name, *pos, list->name);\n }\n\n else\n {\n *this = list->next;\n list->next = 0;\n\n list->local_use = max;\n }\n }\n\n         mask <<= 1;\n list = list->list;\n }\n\n if (*this != &image_transform_end)\n return counter;\n\n if (!image_transform_test_counter(counter, max))\n return 0;\n\n    }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8854, "func": "static void vrend_draw_bind_samplers(struct vrend_context *ctx)\n{\n   int sampler_id;\n   int i;\n   int shader_type;\n\n   sampler_id = 0;\n   for (shader_type = PIPE_SHADER_VERTEX; shader_type <= ctx->sub->last_shader_idx; shader_type++) {\n      int index = 0;\n      for (i = 0; i < ctx->sub->views[shader_type].num_views; i++) {\n         struct vrend_resource *texture = NULL;\n\n         if (ctx->sub->views[shader_type].views[i]) {\n            texture = ctx->sub->views[shader_type].views[i]->texture;\n         }\n\n         if (!(ctx->sub->prog->samplers_used_mask[shader_type] & (1 << i)))\n            continue;\n\n         if (ctx->sub->prog->samp_locs[shader_type])\n            glUniform1i(ctx->sub->prog->samp_locs[shader_type][index], sampler_id);\n\n         if (ctx->sub->prog->shadow_samp_mask[shader_type] & (1 << i)) {\n            struct vrend_sampler_view *tview = ctx->sub->views[shader_type].views[i];\n            glUniform4f(ctx->sub->prog->shadow_samp_mask_locs[shader_type][index],\n                        tview->gl_swizzle_r == GL_ZERO ? 0.0 : 1.0,\n                        tview->gl_swizzle_g == GL_ZERO ? 0.0 : 1.0,\n                        tview->gl_swizzle_b == GL_ZERO ? 0.0 : 1.0,\n                        tview->gl_swizzle_a == GL_ZERO ? 0.0 : 1.0);\n            glUniform4f(ctx->sub->prog->shadow_samp_add_locs[shader_type][index],\n                        tview->gl_swizzle_r == GL_ONE ? 1.0 : 0.0,\n                        tview->gl_swizzle_g == GL_ONE ? 1.0 : 0.0,\n                        tview->gl_swizzle_b == GL_ONE ? 1.0 : 0.0,\n                        tview->gl_swizzle_a == GL_ONE ? 1.0 : 0.0);\n         }\n\n         glActiveTexture(GL_TEXTURE0 + sampler_id);\n         if (texture) {\n            int id;\n\n            if (texture->target == GL_TEXTURE_BUFFER)\n               id = texture->tbo_tex_id;\n            else\n               id = texture->id;\n\n            glBindTexture(texture->target, id);\n            if (ctx->sub->views[shader_type].old_ids[i] != id || ctx->sub->sampler_state_dirty) {\n               vrend_apply_sampler_state(ctx, texture, shader_type, i, sampler_id, ctx->sub->views[shader_type].views[i]->srgb_decode);\n               ctx->sub->views[shader_type].old_ids[i] = id;\n            }\n            if (ctx->sub->rs_state.point_quad_rasterization) {\n               if (vrend_state.use_core_profile == false) {\n                  if (ctx->sub->rs_state.sprite_coord_enable & (1 << i))\n                     glTexEnvi(GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE);\n                  else\n                     glTexEnvi(GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_FALSE);\n               }\n            }\n            sampler_id++;\n         }\n         index++;\n      }\n   }\n\n   if (vrend_state.use_core_profile && ctx->sub->prog->fs_stipple_loc != -1) {\n      glActiveTexture(GL_TEXTURE0 + sampler_id);\n      glBindTexture(GL_TEXTURE_2D, ctx->pstipple_tex_id);\n      glUniform1i(ctx->sub->prog->fs_stipple_loc, sampler_id);\n   }\n   ctx->sub->sampler_state_dirty = false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187476, "func": "static BOOLEAN flush_incoming_que_on_wr_signal_l(l2cap_socket *sock)\n{\n uint8_t *buf;\n\n     uint32_t len;\n \n     while (packet_get_head_l(sock, &buf, &len)) {\n        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);\n \n         if (sent == (signed)len)\n             osi_free(buf);\n else if (sent >= 0) {\n            packet_put_head_l(sock, buf + sent, len - sent);\n            osi_free(buf);\n if (!sent) \n return TRUE;\n }\n else {\n            packet_put_head_l(sock, buf, len);\n            osi_free(buf);\n return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN;\n }\n }\n\n return FALSE;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 188044, "func": " static void copyStereo24(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned \n) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i] >> 8;\n *dst++ = src[1][i] >> 8;\n\n     }\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8422, "func": "pvscsi_on_cmd_adapter_reset(PVSCSIState *s)\n{\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_ADAPTER_RESET\");\n\n    pvscsi_reset_adapter(s);\n    return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8391, "func": "static void mptsas_write_sequence_write(MPTSASState *s, uint32_t val)\n{\n    if (s->diagnostic & MPI_DIAG_DRWE) {\n        goto disable;\n    }\n\n    switch (s->diagnostic_idx) {\n    case 0:\n        if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_1ST_KEY_VALUE) {\n            goto disable;\n        }\n        break;\n    case 1:\n        if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_2ND_KEY_VALUE) {\n            goto disable;\n        }\n        break;\n    case 2:\n        if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_3RD_KEY_VALUE) {\n            goto disable;\n        }\n        break;\n    case 3:\n        if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_4TH_KEY_VALUE) {\n            goto disable;\n        }\n        break;\n    case 4:\n        if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_5TH_KEY_VALUE) {\n            goto disable;\n        }\n        s->diagnostic |= MPI_DIAG_DRWE;\n        break;\n    }\n    s->diagnostic_idx++;\n    return;\n\ndisable:\n    s->diagnostic &= ~MPI_DIAG_DRWE;\n    s->diagnostic_idx = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187862, "func": "long Chapters::Atom::Parse(IMkvReader* pReader, long long pos, long long size) {\n const long long stop = pos + size;\n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (size == 0) \n continue;\n\n if (id == 0x00) { \n      status = ParseDisplay(pReader, pos, size);\n\n if (status < 0) \n return status;\n } else if (id == 0x1654) { \n      status = UnserializeString(pReader, pos, size, m_string_uid);\n\n if (status < 0) \n return status;\n } else if (id == 0x33C4) { \n long long val;\n      status = UnserializeInt(pReader, pos, size, val);\n\n if (status < 0) \n return status;\n\n      m_uid = static_cast<unsigned long long>(val);\n } else if (id == 0x11) { \n const long long val = UnserializeUInt(pReader, pos, size);\n\n if (val < 0) \n return static_cast<long>(val);\n\n      m_start_timecode = val;\n } else if (id == 0x12) { \n const long long val = UnserializeUInt(pReader, pos, size);\n\n if (val < 0) \n return static_cast<long>(val);\n\n      m_stop_timecode = val;\n\n     }\n \n     pos += size;\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n   return 0;\n }\n", "target": 1, "flaw_line_index": "51,54"}
{"idx": 8366, "func": "static void *mptsas_load_request(QEMUFile *f, SCSIRequest *sreq)\n{\n    SCSIBus *bus = sreq->bus;\n    MPTSASState *s = container_of(bus, MPTSASState, bus);\n    PCIDevice *pci = PCI_DEVICE(s);\n    MPTSASRequest *req;\n    int i, n;\n\n    req = g_new(MPTSASRequest, 1);\n    qemu_get_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n\n    n = qemu_get_be32(f);\n#ifdef NDEBUG\n#error building with NDEBUG is not supported\n#endif\n    assert(n >= 0);\n\n    pci_dma_sglist_init(&req->qsg, pci, n);\n    for (i = 0; i < n; i++) {\n        uint64_t base = qemu_get_be64(f);\n        uint64_t len = qemu_get_be64(f);\n        qemu_sglist_add(&req->qsg, base, len);\n    }\n\n    scsi_req_ref(sreq);\n    req->sreq = sreq;\n    req->dev = s;\n\n    return req;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8927, "func": "static void vrend_resource_buffer_copy(struct vrend_context *ctx,\n                                       struct vrend_resource *src_res,\n                                       struct vrend_resource *dst_res,\n                                       uint32_t dstx, uint32_t srcx,\n                                       uint32_t width)\n{\n\n   glBindBuffer(GL_COPY_READ_BUFFER, src_res->id);\n   glBindBuffer(GL_COPY_WRITE_BUFFER, dst_res->id);\n\n   glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, srcx, dstx, width);\n   glBindBuffer(GL_COPY_READ_BUFFER, 0);\n   glBindBuffer(GL_COPY_WRITE_BUFFER, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187665, "func": "image_transform_png_set_rgb_to_gray_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0)\n    {\n       double gray, err;\n \n      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n         image_pixel_convert_PLTE(that);\n \n #  if DIGITIZE\n       {\n         PNG_CONST png_modifier *pm = display->pm;\n          const unsigned int sample_depth = that->sample_depth;\n          const unsigned int calc_depth = (pm->assume_16_bit_calculations ? 16 :\n             sample_depth);\n         const unsigned int gamma_depth = (sample_depth == 16 ? 16 :\n            (pm->assume_16_bit_calculations ? PNG_MAX_GAMMA_8 : sample_depth));\n          int isgray;\n          double r, g, b;\n          double rlo, rhi, glo, ghi, blo, bhi, graylo, grayhi;\n\n          r = rlo = rhi = that->redf;\n          rlo -= that->rede;\n         rlo = digitize(rlo, calc_depth, 1\n);\n          rhi += that->rede;\n         rhi = digitize(rhi, calc_depth, 1\n);\n \n          g = glo = ghi = that->greenf;\n          glo -= that->greene;\n         glo = digitize(glo, calc_depth, 1\n);\n          ghi += that->greene;\n         ghi = digitize(ghi, calc_depth, 1\n);\n \n          b = blo = bhi = that->bluef;\n          blo -= that->bluee;\n         blo = digitize(blo, calc_depth, 1\n);\n         bhi += that->greene;\n         bhi = digitize(bhi, calc_depth, 1\n);\n \n          isgray = r==g && g==b;\n \n          if (data.gamma != 1)\n          {\n            PNG_CONST double power = 1/data.gamma;\n            PNG_CONST double abse = calc_depth == 16 ? .5/65535 : .5/255;\n \n             r = pow(r, power);\n            rlo = digitize(pow(rlo, power)-abse, calc_depth, 1);\n            rhi = digitize(pow(rhi, power)+abse, calc_depth, 1);\n \n             g = pow(g, power);\n            glo = digitize(pow(glo, power)-abse, calc_depth, 1);\n            ghi = digitize(pow(ghi, power)+abse, calc_depth, 1);\n \n             b = pow(b, power);\n            blo = digitize(pow(blo, power)-abse, calc_depth, 1);\n            bhi = digitize(pow(bhi, power)+abse, calc_depth, 1);\n          }\n \n         gray = r * data.red_coefficient + g * data.green_coefficient +\n\n             b * data.blue_coefficient;\n \n          {\n            PNG_CONST int do_round = data.gamma != 1 || calc_depth == 16;\n            PNG_CONST double ce = 1. / 32768;\n \n            graylo = digitize(rlo * (data.red_coefficient-ce) +\n                glo * (data.green_coefficient-ce) +\n               blo * (data.blue_coefficient-ce), gamma_depth, do_round);\n            if (graylo <= 0)\n               graylo = 0;\n \n            grayhi = digitize(rhi * (data.red_coefficient+ce) +\n                ghi * (data.green_coefficient+ce) +\n               bhi * (data.blue_coefficient+ce), gamma_depth, do_round);\n            if (grayhi >= 1)\n               grayhi = 1;\n          }\n \n          if (data.gamma != 1)\n          {\n            PNG_CONST double power = data.gamma;\n \n             gray = pow(gray, power);\n            graylo = digitize(pow(graylo, power), sample_depth, 1);\n            grayhi = digitize(pow(grayhi, power), sample_depth, 1);\n          }\n \n if (isgray)\n            err = (that->rede + that->greene + that->bluee)/3;\n\n else\n {\n            err = fabs(grayhi-gray);\n if (fabs(gray - graylo) > err)\n               err = fabs(graylo-gray);\n\n if (err > pm->limit)\n {\n size_t pos = 0;\n char buffer[128];\n\n               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");\n               pos = safecatd(buffer, sizeof buffer, pos, err, 6);\n               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");\n               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);\n               png_error(pp, buffer);\n }\n }\n }\n#  else  \n {\n double r = that->redf;\n double re = that->rede;\n double g = that->greenf;\n double ge = that->greene;\n\n          double b = that->bluef;\n          double be = that->bluee;\n \n         if (r == g && r == b)\n         {\n            gray = r;\n            err = re;\n            if (err < ge) err = ge;\n            if (err < be) err = be;\n         }\n \n         else if (data.gamma == 1)\n          {\n             gray = r * data.red_coefficient + g * data.green_coefficient +\n                b * data.blue_coefficient;\n             err = re * data.red_coefficient + ge * data.green_coefficient +\n               be * data.blue_coefficient + 1./32768 + gray * 5 * DBL_EPSILON;\n          }\n \n          else\n {\n            PNG_CONST png_modifier *pm = display->pm;\n             double in_qe = (that->sample_depth > 8 ? .5/65535 : .5/255);\n             double out_qe = (that->sample_depth > 8 ? .5/65535 :\n               (pm->assume_16_bit_calculations ? .5/(1<<PNG_MAX_GAMMA_8) :\n                .5/255));\n             double rhi, ghi, bhi, grayhi;\n             double g1 = 1/data.gamma;\n\n            rhi = r + re + in_qe; if (rhi > 1) rhi = 1;\n            r -= re + in_qe; if (r < 0) r = 0;\n            ghi = g + ge + in_qe; if (ghi > 1) ghi = 1;\n            g -= ge + in_qe; if (g < 0) g = 0;\n            bhi = b + be + in_qe; if (bhi > 1) bhi = 1;\n            b -= be + in_qe; if (b < 0) b = 0;\n\n            r = pow(r, g1)*(1-DBL_EPSILON); rhi = pow(rhi, g1)*(1+DBL_EPSILON);\n            g = pow(g, g1)*(1-DBL_EPSILON); ghi = pow(ghi, g1)*(1+DBL_EPSILON);\n            b = pow(b, g1)*(1-DBL_EPSILON); bhi = pow(bhi, g1)*(1+DBL_EPSILON);\n\n             gray = r * data.red_coefficient + g * data.green_coefficient +\n               b * data.blue_coefficient - 1./32768 - out_qe;\n             if (gray <= 0)\n                gray = 0;\n             else\n {\n               gray *= (1 - 6 * DBL_EPSILON);\n               gray = pow(gray, data.gamma) * (1-DBL_EPSILON);\n\n             }\n \n             grayhi = rhi * data.red_coefficient + ghi * data.green_coefficient +\n               bhi * data.blue_coefficient + 1./32768 + out_qe;\n             grayhi *= (1 + 6 * DBL_EPSILON);\n             if (grayhi >= 1)\n                grayhi = 1;\n else\n               grayhi = pow(grayhi, data.gamma) * (1+DBL_EPSILON);\n\n            err = (grayhi - gray) / 2;\n            gray = (grayhi + gray) / 2;\n\n if (err <= in_qe)\n               err = gray * DBL_EPSILON;\n\n else\n               err -= in_qe;\n\n if (err > pm->limit)\n {\n size_t pos = 0;\n char buffer[128];\n\n               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");\n               pos = safecatd(buffer, sizeof buffer, pos, err, 6);\n               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");\n               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);\n               png_error(pp, buffer);\n }\n }\n }\n#  endif \n\n      that->bluef = that->greenf = that->redf = gray;\n      that->bluee = that->greene = that->rede = err;\n\n if (that->red_sBIT > that->green_sBIT)\n         that->red_sBIT = that->green_sBIT;\n if (that->red_sBIT > that->blue_sBIT)\n         that->red_sBIT = that->blue_sBIT;\n      that->blue_sBIT = that->green_sBIT = that->red_sBIT;\n\n if (that->colour_type == PNG_COLOR_TYPE_RGB)\n         that->colour_type = PNG_COLOR_TYPE_GRAY;\n else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         that->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n }\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "3,9,10,14,18,19,27,30,35,38,43,44,46,52,53,54,56,57,60,61,64,65,73,74,76,78,79,80,82,84,85,86,91,94,95,129,130,131,132,133,134,135,136,138,143,148,151,168,179"}
{"idx": 8753, "func": "int FAST_FUNC sprint_nip6(char *dest, \n const uint8_t *ip)\n{\n\tchar hexstrbuf[16 * 2];\n\tbin2hex(hexstrbuf, (void*)ip, 16);\n\treturn sprintf(dest, \n\t\t\"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\",\n\t\thexstrbuf + 0 * 4,\n\t\thexstrbuf + 1 * 4,\n\t\thexstrbuf + 2 * 4,\n\t\thexstrbuf + 3 * 4,\n\t\thexstrbuf + 4 * 4,\n\t\thexstrbuf + 5 * 4,\n\t\thexstrbuf + 6 * 4,\n\t\thexstrbuf + 7 * 4\n\t);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187614, "func": "validate_T(void)\n\n {\n    unsigned int i;\n \n   for (i=0; i<TTABLE_SIZE; ++i)\n    {\n       if (transform_info[i].when & TRANSFORM_R)\n          read_transforms |= transform_info[i].transform;\n\n if (transform_info[i].when & TRANSFORM_W)\n         write_transforms |= transform_info[i].transform;\n }\n\n   rw_transforms = read_transforms & write_transforms;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187788, "func": "status_t SampleIterator::seekTo(uint32_t sampleIndex) {\n    ALOGV(\"seekTo(%d)\", sampleIndex);\n\n if (sampleIndex >= mTable->mNumSampleSizes) {\n return ERROR_END_OF_STREAM;\n }\n\n if (mTable->mSampleToChunkOffset < 0\n || mTable->mChunkOffsetOffset < 0\n || mTable->mSampleSizeOffset < 0\n || mTable->mTimeToSampleCount == 0) {\n\n return ERROR_MALFORMED;\n }\n\n if (mInitialized && mCurrentSampleIndex == sampleIndex) {\n return OK;\n }\n\n if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {\n        reset();\n }\n\n if (sampleIndex >= mStopChunkSampleIndex) {\n status_t err;\n if ((err = findChunkRange(sampleIndex)) != OK) {\n            ALOGE(\"findChunkRange failed\");\n return err;\n }\n }\n\n \n     CHECK(sampleIndex < mStopChunkSampleIndex);\n \n     uint32_t chunk =\n         (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk\n         + mFirstChunk;\n\n if (!mInitialized || chunk != mCurrentChunkIndex) {\n        mCurrentChunkIndex = chunk;\n\n status_t err;\n if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {\n            ALOGE(\"getChunkOffset return error\");\n return err;\n }\n\n        mCurrentChunkSampleSizes.clear();\n\n uint32_t firstChunkSampleIndex =\n            mFirstChunkSampleIndex\n + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);\n\n for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {\n size_t sampleSize;\n if ((err = getSampleSizeDirect(\n                            firstChunkSampleIndex + i, &sampleSize)) != OK) {\n                ALOGE(\"getSampleSizeDirect return error\");\n return err;\n }\n\n            mCurrentChunkSampleSizes.push(sampleSize);\n }\n }\n\n uint32_t chunkRelativeSampleIndex =\n (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;\n\n    mCurrentSampleOffset = mCurrentChunkOffset;\n for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {\n        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];\n }\n\n    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];\n if (sampleIndex < mTTSSampleIndex) {\n        mTimeToSampleIndex = 0;\n        mTTSSampleIndex = 0;\n        mTTSSampleTime = 0;\n        mTTSCount = 0;\n        mTTSDuration = 0;\n }\n\n status_t err;\n if ((err = findSampleTimeAndDuration(\n            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {\n        ALOGE(\"findSampleTime return error\");\n return err;\n }\n\n    mCurrentSampleIndex = sampleIndex;\n\n    mInitialized = true;\n\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188181, "func": "void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attributes)\n{\n    attributes->usage = (audio_usage_t) parcel.readInt32();\n    attributes->content_type = (audio_content_type_t) parcel.readInt32();\n    attributes->source = (audio_source_t) parcel.readInt32();\n    attributes->flags = (audio_flags_mask_t) parcel.readInt32();\n const bool hasFlattenedTag = (parcel.readInt32() == kAudioAttributesMarshallTagFlattenTags);\n if (hasFlattenedTag) {\n String16 tags = parcel.readString16();\n ssize_t realTagSize = utf16_to_utf8_length(tags.string(), tags.size());\n if (realTagSize <= 0) {\n            strcpy(attributes->tags, \"\");\n } else {\n\n             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?\n                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;\n            utf16_to_utf8(tags.string(), tagSize, attributes->tags);\n         }\n     } else {\n         ALOGE(\"unmarshallAudioAttributes() received unflattened tags, ignoring tag values\");\n        strcpy(attributes->tags, \"\");\n }\n}\n", "target": 1, "flaw_line_index": "20"}
{"idx": 9152, "func": "vrend_so_target_reference(struct vrend_so_target **ptr, struct vrend_so_target *target)\n{\n   struct vrend_so_target *old_target = *ptr;\n\n   if (pipe_reference(&(*ptr)->reference, &target->reference))\n      vrend_destroy_so_target(old_target);\n   *ptr = target;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8540, "func": "static void ssh2_pkt_addmp(struct Packet *pkt, Bignum b)\n{\n    unsigned char *p;\n    int len;\n    p = ssh2_mpint_fmt(b, &len);\n    ssh_pkt_addstring_start(pkt);\n    ssh_pkt_addstring_data(pkt, (char *)p, len);\n    sfree(p);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187879, "func": "long Segment::ParseNext(const Cluster* pCurr, const Cluster*& pResult,\n long long& pos, long& len) {\n  assert(pCurr);\n  assert(!pCurr->EOS());\n  assert(m_clusters);\n\n  pResult = 0;\n\n if (pCurr->m_index >= 0) { \n    assert(m_clusters[pCurr->m_index] == pCurr);\n\n const long next_idx = pCurr->m_index + 1;\n\n if (next_idx < m_clusterCount) {\n      pResult = m_clusters[next_idx];\n return 0; \n }\n\n\n const long result = LoadCluster(pos, len);\n\n if (result < 0) \n return result;\n\n if (result > 0) \n {\n return 1;\n }\n\n    pResult = GetLast();\n return 0; \n }\n\n  assert(m_pos > 0);\n\n long long total, avail;\n\n long status = m_pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n\n const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n\n\n  pos = pCurr->m_element_start;\n\n if (pCurr->m_element_size >= 0)\n    pos += pCurr->m_element_size;\n else {\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long id = ReadUInt(m_pReader, pos, len);\n\n if (id != 0x0F43B675) \n return -1;\n\n    pos += len; \n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n    pos += len; \n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size) \n return E_FILE_FORMAT_INVALID; \n\n\n if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n\n \n     pos += size;  \n    assert((segment_stop < 0) || (pos <= segment_stop));\n \n }\n\n\n for (;;) {\n const long status = DoParseNext(pResult, pos, len);\n\n if (status <= 1)\n return status;\n }\n}\n", "target": 1, "flaw_line_index": "124"}
{"idx": 8960, "func": "struct virtio_net_hdr *net_tx_pkt_get_vhdr(struct NetTxPkt *pkt)\n{\n    assert(pkt);\n    return &pkt->virt_hdr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188625, "func": "void WT_InterpolateNoLoop (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n    phaseFrac = (EAS_I32)pWTVoice->phaseFrac;\n\n#if defined(_8_BIT_SAMPLES)\n    samp1 = pSamples[0] << 8;\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n        phaseFrac += phaseInc;\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n if (acc0 > 0) {\n\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n#if defined(_8_BIT_SAMPLES)\n            samp1 = pSamples[0] << 8;\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187414, "func": "ID3::ID3(const uint8_t *data, size_t size, bool ignoreV1)\n : mIsValid(false),\n      mData(NULL),\n      mSize(0),\n\n       mFirstFrameOffset(0),\n       mVersion(ID3_UNKNOWN),\n       mRawSize(0) {\n    sp<MemorySource> source = new MemorySource(data, size);\n \n     mIsValid = parseV2(source, 0);\n \n if (!mIsValid && !ignoreV1) {\n        mIsValid = parseV1(source);\n }\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8686, "func": "init_seps (enum url_scheme scheme)\n{\n  static char seps[8] = \":/\";\n  char *p = seps + 2;\n  int flags = supported_schemes[scheme].flags;\n\n  if (flags & scm_has_params)\n    *p++ = ';';\n  if (flags & scm_has_query)\n    *p++ = '?';\n  if (flags & scm_has_fragment)\n    *p++ = '#';\n  *p = '\\0';\n  return seps;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188050, "func": "IHEVCD_ERROR_T ihevcd_parse_sps(codec_t *ps_codec)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 value;\n\n    WORD32 i;\n    WORD32 vps_id;\n    WORD32 sps_max_sub_layers;\n    WORD32 sps_id;\n    WORD32 sps_temporal_id_nesting_flag;\n sps_t *ps_sps;\n profile_tier_lvl_info_t s_ptl;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n    WORD32 ctb_log2_size_y = 0;\n\n\n    BITS_PARSE(\"video_parameter_set_id\", value, ps_bitstrm, 4);\n    vps_id = value;\n    vps_id = CLIP3(vps_id, 0, MAX_VPS_CNT - 1);\n\n    BITS_PARSE(\"sps_max_sub_layers_minus1\", value, ps_bitstrm, 3);\n    sps_max_sub_layers = value + 1;\n    sps_max_sub_layers = CLIP3(sps_max_sub_layers, 1, 7);\n\n    BITS_PARSE(\"sps_temporal_id_nesting_flag\", value, ps_bitstrm, 1);\n    sps_temporal_id_nesting_flag = value;\n\n    ret = ihevcd_profile_tier_level(ps_bitstrm, &(s_ptl), 1,\n (sps_max_sub_layers - 1));\n\n    UEV_PARSE(\"seq_parameter_set_id\", value, ps_bitstrm);\n    sps_id = value;\n\n if((sps_id >= MAX_SPS_CNT) || (sps_id < 0))\n {\n if(ps_codec->i4_sps_done)\n return IHEVCD_UNSUPPORTED_SPS_ID;\n else\n            sps_id = 0;\n }\n\n\n    ps_sps = (ps_codec->s_parse.ps_sps_base + MAX_SPS_CNT - 1);\n    ps_sps->i1_sps_id = sps_id;\n    ps_sps->i1_vps_id = vps_id;\n    ps_sps->i1_sps_max_sub_layers = sps_max_sub_layers;\n    ps_sps->i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag;\n    ps_codec->i4_sps_id = sps_id;\n    memcpy(&ps_sps->s_ptl, &s_ptl, sizeof(profile_tier_lvl_info_t));\n\n    UEV_PARSE(\"chroma_format_idc\", value, ps_bitstrm);\n    ps_sps->i1_chroma_format_idc = value;\n\n if(ps_sps->i1_chroma_format_idc != CHROMA_FMT_IDC_YUV420)\n {\n        ps_codec->s_parse.i4_error_code = IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\n return (IHEVCD_ERROR_T)IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\n }\n\n if(CHROMA_FMT_IDC_YUV444_PLANES == ps_sps->i1_chroma_format_idc)\n {\n        BITS_PARSE(\"separate_colour_plane_flag\", value, ps_bitstrm, 1);\n        ps_sps->i1_separate_colour_plane_flag = value;\n }\n else\n {\n        ps_sps->i1_separate_colour_plane_flag = 0;\n }\n\n    UEV_PARSE(\"pic_width_in_luma_samples\", value, ps_bitstrm);\n    ps_sps->i2_pic_width_in_luma_samples = value;\n\n    UEV_PARSE(\"pic_height_in_luma_samples\", value, ps_bitstrm);\n    ps_sps->i2_pic_height_in_luma_samples = value;\n\n if((0 >= ps_sps->i2_pic_width_in_luma_samples) || (0 >= ps_sps->i2_pic_height_in_luma_samples))\n return IHEVCD_INVALID_PARAMETER;\n\n    ps_sps->i2_pic_width_in_luma_samples = ALIGN8(ps_sps->i2_pic_width_in_luma_samples);\n    ps_sps->i2_pic_height_in_luma_samples = ALIGN8(ps_sps->i2_pic_height_in_luma_samples);\n\n    BITS_PARSE(\"pic_cropping_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_pic_cropping_flag = value;\n\n if(ps_sps->i1_pic_cropping_flag)\n {\n\n        UEV_PARSE(\"pic_crop_left_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_left_offset = value;\n\n        UEV_PARSE(\"pic_crop_right_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_right_offset = value;\n\n        UEV_PARSE(\"pic_crop_top_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_top_offset = value;\n\n        UEV_PARSE(\"pic_crop_bottom_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_bottom_offset = value;\n }\n else\n {\n        ps_sps->i2_pic_crop_left_offset = 0;\n        ps_sps->i2_pic_crop_right_offset = 0;\n        ps_sps->i2_pic_crop_top_offset = 0;\n        ps_sps->i2_pic_crop_bottom_offset = 0;\n }\n\n\n    UEV_PARSE(\"bit_depth_luma_minus8\", value, ps_bitstrm);\n if(0 != value)\n return IHEVCD_UNSUPPORTED_BIT_DEPTH;\n\n    UEV_PARSE(\"bit_depth_chroma_minus8\", value, ps_bitstrm);\n if(0 != value)\n return IHEVCD_UNSUPPORTED_BIT_DEPTH;\n\n    UEV_PARSE(\"log2_max_pic_order_cnt_lsb_minus4\", value, ps_bitstrm);\n    ps_sps->i1_log2_max_pic_order_cnt_lsb = value + 4;\n\n    BITS_PARSE(\"sps_sub_layer_ordering_info_present_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_sps_sub_layer_ordering_info_present_flag = value;\n\n\n    i = (ps_sps->i1_sps_sub_layer_ordering_info_present_flag ? 0 : (ps_sps->i1_sps_max_sub_layers - 1));\n for(; i < ps_sps->i1_sps_max_sub_layers; i++)\n {\n        UEV_PARSE(\"max_dec_pic_buffering\", value, ps_bitstrm);\n        ps_sps->ai1_sps_max_dec_pic_buffering[i] = value + 1;\n\n if(ps_sps->ai1_sps_max_dec_pic_buffering[i] > MAX_DPB_SIZE)\n {\n return IHEVCD_INVALID_PARAMETER;\n }\n\n        UEV_PARSE(\"num_reorder_pics\", value, ps_bitstrm);\n        ps_sps->ai1_sps_max_num_reorder_pics[i] = value;\n\n if(ps_sps->ai1_sps_max_num_reorder_pics[i] > ps_sps->ai1_sps_max_dec_pic_buffering[i])\n {\n return IHEVCD_INVALID_PARAMETER;\n }\n\n        UEV_PARSE(\"max_latency_increase\", value, ps_bitstrm);\n        ps_sps->ai1_sps_max_latency_increase[i] = value;\n }\n    UEV_PARSE(\"log2_min_coding_block_size_minus3\", value, ps_bitstrm);\n    ps_sps->i1_log2_min_coding_block_size = value + 3;\n\n    UEV_PARSE(\"log2_diff_max_min_coding_block_size\", value, ps_bitstrm);\n    ps_sps->i1_log2_diff_max_min_coding_block_size = value;\n\n    ctb_log2_size_y = ps_sps->i1_log2_min_coding_block_size + ps_sps->i1_log2_diff_max_min_coding_block_size;\n\n    UEV_PARSE(\"log2_min_transform_block_size_minus2\", value, ps_bitstrm);\n    ps_sps->i1_log2_min_transform_block_size = value + 2;\n\n    UEV_PARSE(\"log2_diff_max_min_transform_block_size\", value, ps_bitstrm);\n    ps_sps->i1_log2_diff_max_min_transform_block_size = value;\n\n    ps_sps->i1_log2_max_transform_block_size = ps_sps->i1_log2_min_transform_block_size +\n                    ps_sps->i1_log2_diff_max_min_transform_block_size;\n\n if ((ps_sps->i1_log2_max_transform_block_size < 0) ||\n (ps_sps->i1_log2_max_transform_block_size > MIN(ctb_log2_size_y, 5)))\n {\n return IHEVCD_INVALID_PARAMETER;\n }\n\n    ps_sps->i1_log2_ctb_size = ps_sps->i1_log2_min_coding_block_size +\n                    ps_sps->i1_log2_diff_max_min_coding_block_size;\n\n if((ps_sps->i1_log2_min_coding_block_size < 3) ||\n (ps_sps->i1_log2_min_transform_block_size < 2) ||\n (ps_sps->i1_log2_diff_max_min_transform_block_size < 0) ||\n (ps_sps->i1_log2_max_transform_block_size > ps_sps->i1_log2_ctb_size) ||\n (ps_sps->i1_log2_ctb_size < 4) ||\n (ps_sps->i1_log2_ctb_size > 6))\n {\n return IHEVCD_INVALID_PARAMETER;\n }\n\n    ps_sps->i1_log2_min_pcm_coding_block_size = 0;\n    ps_sps->i1_log2_diff_max_min_pcm_coding_block_size = 0;\n\n    UEV_PARSE(\"max_transform_hierarchy_depth_inter\", value, ps_bitstrm);\n    ps_sps->i1_max_transform_hierarchy_depth_inter = value;\n\n    UEV_PARSE(\"max_transform_hierarchy_depth_intra\", value, ps_bitstrm);\n    ps_sps->i1_max_transform_hierarchy_depth_intra = value;\n\n    BITS_PARSE(\"scaling_list_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_scaling_list_enable_flag = value;\n\n if(ps_sps->i1_scaling_list_enable_flag)\n {\n        COPY_DEFAULT_SCALING_LIST(ps_sps->pi2_scaling_mat);\n        BITS_PARSE(\"sps_scaling_list_data_present_flag\", value, ps_bitstrm, 1);\n        ps_sps->i1_sps_scaling_list_data_present_flag = value;\n\n if(ps_sps->i1_sps_scaling_list_data_present_flag)\n            ihevcd_scaling_list_data(ps_codec, ps_sps->pi2_scaling_mat);\n }\n else\n {\n        COPY_FLAT_SCALING_LIST(ps_sps->pi2_scaling_mat);\n }\n    BITS_PARSE(\"asymmetric_motion_partitions_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_amp_enabled_flag = value;\n\n    BITS_PARSE(\"sample_adaptive_offset_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_sample_adaptive_offset_enabled_flag = value;\n\n    BITS_PARSE(\"pcm_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_pcm_enabled_flag = value;\n\n if(ps_sps->i1_pcm_enabled_flag)\n {\n        BITS_PARSE(\"pcm_sample_bit_depth_luma\", value, ps_bitstrm, 4);\n        ps_sps->i1_pcm_sample_bit_depth_luma = value + 1;\n\n        BITS_PARSE(\"pcm_sample_bit_depth_chroma\", value, ps_bitstrm, 4);\n        ps_sps->i1_pcm_sample_bit_depth_chroma = value + 1;\n\n        UEV_PARSE(\"log2_min_pcm_coding_block_size_minus3\", value, ps_bitstrm);\n        ps_sps->i1_log2_min_pcm_coding_block_size = value + 3;\n\n        UEV_PARSE(\"log2_diff_max_min_pcm_coding_block_size\", value, ps_bitstrm);\n        ps_sps->i1_log2_diff_max_min_pcm_coding_block_size = value;\n        BITS_PARSE(\"pcm_loop_filter_disable_flag\", value, ps_bitstrm, 1);\n        ps_sps->i1_pcm_loop_filter_disable_flag = value;\n\n }\n    UEV_PARSE(\"num_short_term_ref_pic_sets\", value, ps_bitstrm);\n    ps_sps->i1_num_short_term_ref_pic_sets = value;\n\n    ps_sps->i1_num_short_term_ref_pic_sets = CLIP3(ps_sps->i1_num_short_term_ref_pic_sets, 0, MAX_STREF_PICS_SPS);\n\n for(i = 0; i < ps_sps->i1_num_short_term_ref_pic_sets; i++)\n        ihevcd_short_term_ref_pic_set(ps_bitstrm, &ps_sps->as_stref_picset[0], ps_sps->i1_num_short_term_ref_pic_sets, i, &ps_sps->as_stref_picset[i]);\n\n    BITS_PARSE(\"long_term_ref_pics_present_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_long_term_ref_pics_present_flag = value;\n\n if(ps_sps->i1_long_term_ref_pics_present_flag)\n {\n        UEV_PARSE(\"num_long_term_ref_pics_sps\", value, ps_bitstrm);\n        ps_sps->i1_num_long_term_ref_pics_sps = value;\n\n for(i = 0; i < ps_sps->i1_num_long_term_ref_pics_sps; i++)\n {\n            BITS_PARSE(\"lt_ref_pic_poc_lsb_sps[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n            ps_sps->ai1_lt_ref_pic_poc_lsb_sps[i] = value;\n\n            BITS_PARSE(\"used_by_curr_pic_lt_sps_flag[ i ]\", value, ps_bitstrm, 1);\n            ps_sps->ai1_used_by_curr_pic_lt_sps_flag[i] = value;\n }\n }\n\n    BITS_PARSE(\"sps_temporal_mvp_enable_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_sps_temporal_mvp_enable_flag = value;\n\n    BITS_PARSE(\"sps_strong_intra_smoothing_enable_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_strong_intra_smoothing_enable_flag = value;\n\n    BITS_PARSE(\"vui_parameters_present_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_vui_parameters_present_flag = value;\n\n if(ps_sps->i1_vui_parameters_present_flag)\n        ihevcd_parse_vui_parameters(ps_bitstrm,\n &ps_sps->s_vui_parameters,\n                                    ps_sps->i1_sps_max_sub_layers - 1);\n\n \n     BITS_PARSE(\"sps_extension_flag\", value, ps_bitstrm, 1);\n \n \n     {\n         WORD32 numerator;\n        WORD32 ceil_offset;\n\n        ceil_offset = (1 << ps_sps->i1_log2_ctb_size) - 1;\n        numerator = ps_sps->i2_pic_width_in_luma_samples;\n\n        ps_sps->i2_pic_wd_in_ctb = ((numerator + ceil_offset) /\n (1 << ps_sps->i1_log2_ctb_size));\n\n        numerator = ps_sps->i2_pic_height_in_luma_samples;\n        ps_sps->i2_pic_ht_in_ctb = ((numerator + ceil_offset) /\n (1 << ps_sps->i1_log2_ctb_size));\n\n        ps_sps->i4_pic_size_in_ctb = ps_sps->i2_pic_ht_in_ctb *\n                        ps_sps->i2_pic_wd_in_ctb;\n\n if(0 == ps_codec->i4_sps_done)\n            ps_codec->s_parse.i4_next_ctb_indx = ps_sps->i4_pic_size_in_ctb;\n\n        numerator = ps_sps->i2_pic_width_in_luma_samples;\n        ps_sps->i2_pic_wd_in_min_cb = numerator  /\n (1 << ps_sps->i1_log2_min_coding_block_size);\n\n        numerator = ps_sps->i2_pic_height_in_luma_samples;\n        ps_sps->i2_pic_ht_in_min_cb = numerator  /\n (1 << ps_sps->i1_log2_min_coding_block_size);\n }\n if((0 != ps_codec->i4_first_pic_done) &&\n ((ps_codec->i4_wd != ps_sps->i2_pic_width_in_luma_samples) ||\n (ps_codec->i4_ht != ps_sps->i2_pic_height_in_luma_samples)))\n {\n        ps_codec->i4_reset_flag = 1;\n return (IHEVCD_ERROR_T)IVD_RES_CHANGED;\n }\n\n {\n        WORD32 disp_wd, disp_ht;\n        WORD32 crop_unit_x, crop_unit_y;\n        crop_unit_x = 1;\n        crop_unit_y = 1;\n\n if(CHROMA_FMT_IDC_YUV420 == ps_sps->i1_chroma_format_idc)\n {\n            crop_unit_x = 2;\n            crop_unit_y = 2;\n }\n\n        disp_wd = ps_sps->i2_pic_width_in_luma_samples;\n        disp_wd -= ps_sps->i2_pic_crop_left_offset * crop_unit_x;\n        disp_wd -= ps_sps->i2_pic_crop_right_offset * crop_unit_x;\n\n\n        disp_ht = ps_sps->i2_pic_height_in_luma_samples;\n        disp_ht -= ps_sps->i2_pic_crop_top_offset * crop_unit_y;\n        disp_ht -= ps_sps->i2_pic_crop_bottom_offset * crop_unit_y;\n\n if((0 >= disp_wd) || (0 >= disp_ht))\n return IHEVCD_INVALID_PARAMETER;\n\n        ps_codec->i4_disp_wd = disp_wd;\n        ps_codec->i4_disp_ht = disp_ht;\n\n\n        ps_codec->i4_wd = ps_sps->i2_pic_width_in_luma_samples;\n        ps_codec->i4_ht = ps_sps->i2_pic_height_in_luma_samples;\n\n {\n            WORD32 ref_strd;\n            ref_strd = ALIGN32(ps_sps->i2_pic_width_in_luma_samples + PAD_WD);\n if(ps_codec->i4_strd < ref_strd)\n {\n                ps_codec->i4_strd = ref_strd;\n }\n }\n\n if(0 == ps_codec->i4_share_disp_buf)\n {\n if(ps_codec->i4_disp_strd < ps_codec->i4_disp_wd)\n {\n                ps_codec->i4_disp_strd = ps_codec->i4_disp_wd;\n }\n }\n else\n {\n if(ps_codec->i4_disp_strd < ps_codec->i4_strd)\n {\n                ps_codec->i4_disp_strd = ps_codec->i4_strd;\n }\n }\n }\n\n    ps_codec->i4_sps_done = 1;\n return ret;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8672, "func": "static SCSIDevice *mptsas_phy_get_device(MPTSASState *s, int i,\n                                         int *phy_handle, int *dev_handle)\n{\n    SCSIDevice *d = scsi_device_find(&s->bus, 0, i, 0);\n\n    if (phy_handle) {\n        *phy_handle = i + 1;\n    }\n    if (dev_handle) {\n        *dev_handle = d ? i + 1 + MPTSAS_NUM_PORTS : 0;\n    }\n    return d;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187630, "func": "static double digitize(double value, int depth, int do_round)\n{\n   PNG_CONST unsigned int digitization_factor = (1U << depth) -1;\n \n if (value <= 0)\n      value = 0;\n\n else if (value >= 1)\n      value = 1;\n\n   value *= digitization_factor;\n if (do_round) value += .5;\n return floor(value)/digitization_factor;\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187985, "func": "int SoundPool::play(int sampleID, float leftVolume, float rightVolume,\n int priority, int loop, float rate)\n\n {\n     ALOGV(\"play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f\",\n             sampleID, leftVolume, rightVolume, priority, loop, rate);\n    sp<Sample> sample;\n     SoundChannel* channel;\n     int channelID;\n \n Mutex::Autolock lock(&mLock);\n\n if (mQuit) {\n\n         return 0;\n     }\n    sample = findSample(sampleID);\n     if ((sample == 0) || (sample->state() != Sample::READY)) {\n         ALOGW(\"  sample %d not READY\", sampleID);\n         return 0;\n }\n\n    dump();\n\n    channel = allocateChannel_l(priority);\n\n if (!channel) {\n        ALOGV(\"No channel allocated\");\n return 0;\n }\n\n    channelID = ++mNextChannelID;\n\n    ALOGV(\"play channel %p state = %d\", channel, channel->state());\n    channel->play(sample, channelID, leftVolume, rightVolume, priority, loop, rate);\n return channelID;\n}\n", "target": 1, "flaw_line_index": "7,18"}
{"idx": 188295, "func": "Chapters::Edition::Edition()\n{\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8342, "func": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIStreamContext *stctx;\n    XHCIEPContext *epctx;\n    XHCIRing *ring;\n    USBEndpoint *ep = NULL;\n    uint64_t mfindex;\n    int length;\n    int i;\n\n    trace_usb_xhci_ep_kick(slotid, epid, streamid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n    }\n\n    if (!xhci->slots[slotid - 1].uport ||\n        !xhci->slots[slotid - 1].uport->dev ||\n        !xhci->slots[slotid - 1].uport->dev->attached) {\n        return;\n    }\n\n    if (epctx->retry) {\n        XHCITransfer *xfer = epctx->retry;\n\n        trace_usb_xhci_xfer_retry(xfer);\n        assert(xfer->running_retry);\n        if (xfer->timed_xfer) {\n            mfindex = xhci_mfindex_get(xhci);\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n            if (xfer->running_retry) {\n                return;\n            }\n            xfer->timed_xfer = 0;\n            xfer->running_retry = 1;\n        }\n        if (xfer->iso_xfer) {\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            assert(xfer->packet.status != USB_RET_NAK);\n            xhci_complete_packet(xfer);\n        } else {\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            if (xfer->packet.status == USB_RET_NAK) {\n                return;\n            }\n            xhci_complete_packet(xfer);\n        }\n        assert(!xfer->running_retry);\n        epctx->retry = NULL;\n    }\n\n    if (epctx->state == EP_HALTED) {\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n        return;\n    }\n\n\n    if (epctx->nr_pstreams) {\n        uint32_t err;\n        stctx = xhci_find_stream(epctx, streamid, &err);\n        if (stctx == NULL) {\n            return;\n        }\n        ring = &stctx->ring;\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n    } else {\n        ring = &epctx->ring;\n        streamid = 0;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n    }\n    assert(ring->dequeue != 0);\n\n    while (1) {\n        XHCITransfer *xfer = &epctx->transfers[epctx->next_xfer];\n        if (xfer->running_async || xfer->running_retry) {\n            break;\n        }\n        length = xhci_ring_chain_length(xhci, ring);\n        if (length < 0) {\n            break;\n        } else if (length == 0) {\n            break;\n        }\n        if (xfer->trbs && xfer->trb_alloced < length) {\n            xfer->trb_count = 0;\n            xfer->trb_alloced = 0;\n            g_free(xfer->trbs);\n            xfer->trbs = NULL;\n        }\n        if (!xfer->trbs) {\n            xfer->trbs = g_new(XHCITRB, length);\n            xfer->trb_alloced = length;\n        }\n        xfer->trb_count = length;\n\n        for (i = 0; i < length; i++) {\n            TRBType type;\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n            assert(type);\n        }\n        xfer->streamid = streamid;\n\n        if (epid == 1) {\n            if (xhci_fire_ctl_transfer(xhci, xfer) >= 0) {\n                epctx->next_xfer = (epctx->next_xfer + 1) % TD_QUEUE;\n            } else {\n                DPRINTF(\"xhci: error firing CTL transfer\\n\");\n            }\n        } else {\n            if (xhci_fire_transfer(xhci, xfer, epctx) >= 0) {\n                epctx->next_xfer = (epctx->next_xfer + 1) % TD_QUEUE;\n            } else {\n                if (!xfer->timed_xfer) {\n                    DPRINTF(\"xhci: error firing data transfer\\n\");\n                }\n            }\n        }\n\n        if (epctx->state == EP_HALTED) {\n            break;\n        }\n        if (xfer->running_retry) {\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n            epctx->retry = xfer;\n            break;\n        }\n    }\n\n    ep = xhci_epid_to_usbep(xhci, slotid, epid);\n    if (ep) {\n        usb_device_flush_ep_queue(ep->dev, ep);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8756, "func": "int FAST_FUNC udhcp_end_option(uint8_t *optionptr)\n{\n\tint i = 0;\n\n\twhile (optionptr[i] != DHCP_END) {\n\t\tif (optionptr[i] != DHCP_PADDING)\n\t\t\ti += optionptr[i + OPT_LEN] + OPT_DATA-1;\n\t\ti++;\n\t}\n\treturn i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8398, "func": "void virtqueue_flush(VirtQueue *vq, unsigned int count)\n{\n    uint16_t old, new;\n    smp_wmb();\n    trace_virtqueue_flush(vq, count);\n    old = vq->used_idx;\n    new = old + count;\n    vring_used_idx_set(vq, new);\n    vq->inuse -= count;\n    if (unlikely((int16_t)(new - vq->signalled_used) < (uint16_t)(new - old)))\n        vq->signalled_used_valid = false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187925, "func": "static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)\n{\n\n     char block_dev[PATH_MAX+1];\n     size_t size;\n     unsigned int blksize;\n    unsigned int blocks;\n     unsigned int range_count;\n     unsigned int i;\n \n if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {\n        LOGW(\"failed to read block device from header\\n\");\n return -1;\n }\n for (i = 0; i < sizeof(block_dev); ++i) {\n if (block_dev[i] == '\\n') {\n            block_dev[i] = 0;\n break;\n }\n }\n\n if (fscanf(mapf, \"%zu %u\\n%u\\n\", &size, &blksize, &range_count) != 3) {\n\n         LOGW(\"failed to parse block map header\\n\");\n         return -1;\n     }\n    blocks = ((size-1) / blksize) + 1;\n \n     pMap->range_count = range_count;\n    pMap->ranges = malloc(range_count * sizeof(MappedRange));\n    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));\n \n     unsigned char* reserve;\n     reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);\n     if (reserve == MAP_FAILED) {\n         LOGW(\"failed to reserve address space: %s\\n\", strerror(errno));\n         return -1;\n     }\n \n    pMap->ranges[range_count-1].addr = reserve;\n    pMap->ranges[range_count-1].length = blocks * blksize;\n     int fd = open(block_dev, O_RDONLY);\n     if (fd < 0) {\n         LOGW(\"failed to open block device %s: %s\\n\", block_dev, strerror(errno));\n         return -1;\n     }\n \n     unsigned char* next = reserve;\n     for (i = 0; i < range_count; ++i) {\n        int start, end;\n        if (fscanf(mapf, \"%d %d\\n\", &start, &end) != 2) {\n             LOGW(\"failed to parse range %d in block map\\n\", i);\n            return -1;\n         }\n \n        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);\n         if (addr == MAP_FAILED) {\n             LOGW(\"failed to map block %d: %s\\n\", i, strerror(errno));\n            return -1;\n         }\n         pMap->ranges[i].addr = addr;\n        pMap->ranges[i].length = (end-start)*blksize;\n \n        next += pMap->ranges[i].length;\n     }\n \n     pMap->addr = reserve;\n     pMap->length = size;\n \n    LOGI(\"mmapped %d ranges\\n\", range_count);\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "7,27,30,31,41,42,51,52,54,57,60,63,65"}
{"idx": 8896, "func": "static struct vrend_resource *vrend_renderer_ctx_res_lookup(struct vrend_context *ctx, int res_handle)\n{\n   struct vrend_resource *res = vrend_object_lookup(ctx->res_hash, res_handle, 1);\n\n   return res;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8348, "func": "static int xhci_xfer_create_sgl(XHCITransfer *xfer, int in_xfer)\n{\n    XHCIState *xhci = xfer->xhci;\n    int i;\n\n    xfer->int_req = false;\n    pci_dma_sglist_init(&xfer->sgl, PCI_DEVICE(xhci), xfer->trb_count);\n    for (i = 0; i < xfer->trb_count; i++) {\n        XHCITRB *trb = &xfer->trbs[i];\n        dma_addr_t addr;\n        unsigned int chunk = 0;\n\n        if (trb->control & TRB_TR_IOC) {\n            xfer->int_req = true;\n        }\n\n        switch (TRB_TYPE(*trb)) {\n        case TR_DATA:\n            if ((!(trb->control & TRB_TR_DIR)) != (!in_xfer)) {\n                DPRINTF(\"xhci: data direction mismatch for TR_DATA\\n\");\n                goto err;\n            }\n        case TR_NORMAL:\n        case TR_ISOCH:\n            addr = xhci_mask64(trb->parameter);\n            chunk = trb->status & 0x1ffff;\n            if (trb->control & TRB_TR_IDT) {\n                if (chunk > 8 || in_xfer) {\n                    DPRINTF(\"xhci: invalid immediate data TRB\\n\");\n                    goto err;\n                }\n                qemu_sglist_add(&xfer->sgl, trb->addr, chunk);\n            } else {\n                qemu_sglist_add(&xfer->sgl, addr, chunk);\n            }\n            break;\n        }\n    }\n\n    return 0;\n\nerr:\n    qemu_sglist_destroy(&xfer->sgl);\n    xhci_die(xhci);\n    return -1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187876, "func": "long ContentEncoding::ParseEncryptionEntry(long long start, long long size,\n IMkvReader* pReader,\n ContentEncryption* encryption) {\n  assert(pReader);\n  assert(encryption);\n\n long long pos = start;\n const long long stop = start + size;\n\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) \n return status;\n\n if (id == 0x7E1) {\n      encryption->algo = UnserializeUInt(pReader, pos, size);\n if (encryption->algo != 5)\n\n         return E_FILE_FORMAT_INVALID;\n     } else if (id == 0x7E2) {\n      delete[] encryption -> key_id;\n       encryption->key_id = NULL;\n       encryption->key_id_len = 0;\n \n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      encryption->key_id = buf;\n\n       encryption->key_id_len = buflen;\n     } else if (id == 0x7E3) {\n      delete[] encryption -> signature;\n       encryption->signature = NULL;\n       encryption->signature_len = 0;\n \n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      encryption->signature = buf;\n\n       encryption->signature_len = buflen;\n     } else if (id == 0x7E4) {\n      delete[] encryption -> sig_key_id;\n       encryption->sig_key_id = NULL;\n       encryption->sig_key_id_len = 0;\n \n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      encryption->sig_key_id = buf;\n      encryption->sig_key_id_len = buflen;\n } else if (id == 0x7E5) {\n      encryption->sig_algo = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x7E6) {\n      encryption->sig_hash_algo = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x7E7) {\n const long status = ParseContentEncAESSettingsEntry(\n          pos, size, pReader, &encryption->aes_settings);\n if (status)\n return status;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n   return 0;\n}\n", "target": 1, "flaw_line_index": "24,33,34,50,59,60,76,85,86"}
{"idx": 9209, "func": "void virtio_notify_config(VirtIODevice *vdev)\n{\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))\n        return;\n\n    vdev->isr |= 0x03;\n    vdev->generation++;\n    virtio_notify_vector(vdev, vdev->config_vector);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187422, "func": "status_t SoundTriggerHwService::Module::startRecognition(sound_model_handle_t handle,\n const sp<IMemory>& dataMemory)\n{\n    ALOGV(\"startRecognition() model handle %d\", handle);\n if (!captureHotwordAllowed()) {\n\n         return PERMISSION_DENIED;\n     }\n \n    if (dataMemory != 0 && dataMemory->pointer() == NULL) {\n        ALOGE(\"startRecognition() dataMemory is non-0 but has NULL pointer()\");\n         return BAD_VALUE;\n \n     }\n     AutoMutex lock(mLock);\n     if (mServiceState == SOUND_TRIGGER_STATE_DISABLED) {\n         return INVALID_OPERATION;\n }\n    sp<Model> model = getModel(handle);\n\n     if (model == 0) {\n         return BAD_VALUE;\n     }\n    if ((dataMemory == 0) ||\n            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {\n        return BAD_VALUE;\n    }\n \n     if (model->mState == Model::STATE_ACTIVE) {\n         return INVALID_OPERATION;\n     }\n \n    struct sound_trigger_recognition_config *config =\n            (struct sound_trigger_recognition_config *)dataMemory->pointer();\n \n     config->capture_handle = model->mCaptureIOHandle;\n    config->capture_device = model->mCaptureDevice;\n status_t status = mHwDevice->start_recognition(mHwDevice, handle, config,\n SoundTriggerHwService::recognitionCallback,\n this);\n\n if (status == NO_ERROR) {\n        model->mState = Model::STATE_ACTIVE;\n        model->mConfig = *config;\n }\n\n return status;\n}\n", "target": 1, "flaw_line_index": "10,11,24,25,26,27,33,34"}
{"idx": 8574, "func": "static void ssh_pkt_addstring_str(struct Packet *pkt, const char *data)\n{\n  ssh_pkt_addstring_data(pkt, data, strlen(data));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8935, "func": "void vrend_set_index_buffer(struct vrend_context *ctx,\n                            uint32_t res_handle,\n                            uint32_t index_size,\n                            uint32_t offset)\n{\n   struct vrend_resource *res;\n\n   ctx->sub->ib.index_size = index_size;\n   ctx->sub->ib.offset = offset;\n   if (res_handle) {\n      if (ctx->sub->index_buffer_res_id != res_handle) {\n         res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n         if (!res) {\n            vrend_resource_reference((struct vrend_resource **)&ctx->sub->ib.buffer, NULL);\n            ctx->sub->index_buffer_res_id = 0;\n            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n            return;\n         }\n         vrend_resource_reference((struct vrend_resource **)&ctx->sub->ib.buffer, res);\n         ctx->sub->index_buffer_res_id = res_handle;\n      }\n   } else {\n      vrend_resource_reference((struct vrend_resource **)&ctx->sub->ib.buffer, NULL);\n      ctx->sub->index_buffer_res_id = 0;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187482, "func": "int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)\n{\n if(h < 0 || h >= MAX_THREAD)\n {\n        APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\n return FALSE;\n }\n if(ts[h].cmd_fdw == -1)\n {\n        APPL_TRACE_ERROR(\"cmd socket is not created. socket thread may not initialized\");\n return FALSE;\n }\n if(flags & SOCK_THREAD_ADD_FD_SYNC)\n {\n if(ts[h].thread_id == pthread_self())\n {\n            flags &= ~SOCK_THREAD_ADD_FD_SYNC;\n            add_poll(h, fd, type, flags, user_id);\n return TRUE;\n }\n        APPL_TRACE_DEBUG(\"THREAD_ADD_FD_SYNC is not called in poll thread, fallback to async\");\n\n     }\n     sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};\n     APPL_TRACE_DEBUG(\"adding fd:%d, flags:0x%x\", fd, flags);\n    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n }\n", "target": 1, "flaw_line_index": "28"}
{"idx": 8856, "func": "static void vrend_draw_bind_vertex_binding(struct vrend_context *ctx,\n                                           struct vrend_vertex_element_array *va)\n{\n   int i;\n\n   glBindVertexArray(va->id);\n\n   if (ctx->sub->vbo_dirty) {\n      for (i = 0; i < ctx->sub->num_vbos; i++) {\n         struct vrend_resource *res = (struct vrend_resource *)ctx->sub->vbo[i].buffer;\n         if (!res)\n            glBindVertexBuffer(i, 0, 0, 0);\n         else\n            glBindVertexBuffer(i,\n                               res->id,\n                               ctx->sub->vbo[i].buffer_offset,\n                               ctx->sub->vbo[i].stride);\n      }\n      for (i = ctx->sub->num_vbos; i < ctx->sub->old_num_vbos; i++) {\n         glBindVertexBuffer(i, 0, 0, 0);\n      }\n      ctx->sub->vbo_dirty = false;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187737, "func": "transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)\n{\n   standard_info_part1(&dp->this, pp, pi);\n\n   dp->transform_list->set(dp->transform_list, dp, pp, pi);\n\n {\n int i = dp->this.use_update_info;\n do\n         png_read_update_info(pp, pi);\n while (--i > 0);\n }\n\n   standard_info_part2(&dp->this, pp, pi, 1\n);\n\n\n    dp->output_colour_type = png_get_color_type(pp, pi);\n    dp->output_bit_depth = png_get_bit_depth(pp, pi);\n \n switch (dp->output_colour_type)\n {\n case PNG_COLOR_TYPE_PALETTE:\n if (dp->output_bit_depth > 8) goto error;\n case PNG_COLOR_TYPE_GRAY:\n if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 ||\n         dp->output_bit_depth == 4)\n break;\n default:\n if (dp->output_bit_depth == 8 || dp->output_bit_depth == 16)\n break;\n   error:\n {\n char message[128];\n size_t pos;\n\n         pos = safecat(message, sizeof message, 0,\n \"invalid final bit depth: colour type(\");\n         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);\n         pos = safecat(message, sizeof message, pos, \") with bit depth: \");\n         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);\n\n         png_error(pp, message);\n }\n\n    }\n \n    {\n       image_pixel test_pixel;\n\n      memset(&test_pixel, 0, sizeof test_pixel);\n      test_pixel.colour_type = dp->this.colour_type; \n      test_pixel.bit_depth = dp->this.bit_depth;\n if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)\n         test_pixel.sample_depth = 8;\n else\n         test_pixel.sample_depth = test_pixel.bit_depth;\n\n      test_pixel.have_tRNS = dp->this.is_transparent;\n       test_pixel.red_sBIT = test_pixel.green_sBIT = test_pixel.blue_sBIT =\n          test_pixel.alpha_sBIT = test_pixel.sample_depth;\n \n      dp->transform_list->mod(dp->transform_list, &test_pixel, pp, dp);\n\n if (test_pixel.colour_type != dp->output_colour_type)\n {\n char message[128];\n size_t pos = safecat(message, sizeof message, 0, \"colour type \");\n\n         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);\n         pos = safecat(message, sizeof message, pos, \" expected \");\n         pos = safecatn(message, sizeof message, pos, test_pixel.colour_type);\n\n         png_error(pp, message);\n }\n\n if (test_pixel.bit_depth != dp->output_bit_depth)\n {\n char message[128];\n size_t pos = safecat(message, sizeof message, 0, \"bit depth \");\n\n         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);\n         pos = safecat(message, sizeof message, pos, \" expected \");\n         pos = safecatn(message, sizeof message, pos, test_pixel.bit_depth);\n\n         png_error(pp, message);\n\n       }\n \n      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (test_pixel.sample_depth != 8) \n            png_error(pp, \"pngvalid: internal: palette sample depth not 8\");\n      }\n      else if (test_pixel.sample_depth != dp->output_bit_depth)\n       {\n          char message[128];\n          size_t pos = safecat(message, sizeof message, 0,\n             \"internal: sample depth \");\n \n          pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);\n          pos = safecat(message, sizeof message, pos, \" expected \");\n         pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth);\n \n          png_error(pp, message);\n       }\n }\n}\n", "target": 1, "flaw_line_index": "59,90,91,92,93,94,95,103"}
{"idx": 187861, "func": "long Chapters::Edition::Parse(IMkvReader* pReader, long long pos,\n long long size) {\n const long long stop = pos + size;\n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (size == 0) \n continue;\n\n if (id == 0x36) { \n      status = ParseAtom(pReader, pos, size);\n\n if (status < 0) \n return status;\n\n     }\n \n     pos += size;\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n   return 0;\n }\n", "target": 1, "flaw_line_index": "25,28"}
{"idx": 9212, "func": "hwaddr virtio_queue_get_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.desc;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9112, "func": "static int vrend_decode_resource_inline_write(struct vrend_decode_ctx *ctx, uint16_t length)\n{\n   struct vrend_transfer_info info;\n   struct pipe_box box;\n   uint32_t res_handle;\n   uint32_t level, usage, stride, layer_stride, data_len;\n   struct iovec dataiovec;\n   void *data;\n\n   if (length < 12)\n      return EINVAL;\n\n   if (length + ctx->ds->buf_offset > ctx->ds->buf_total)\n      return EINVAL;\n\n   res_handle = get_buf_entry(ctx, VIRGL_RESOURCE_IW_RES_HANDLE);\n   data_len = (length - 11) * 4;\n   level = get_buf_entry(ctx, VIRGL_RESOURCE_IW_LEVEL);\n   usage = get_buf_entry(ctx, VIRGL_RESOURCE_IW_USAGE);\n   stride = get_buf_entry(ctx, VIRGL_RESOURCE_IW_STRIDE);\n   layer_stride = get_buf_entry(ctx, VIRGL_RESOURCE_IW_LAYER_STRIDE);\n   box.x = get_buf_entry(ctx, VIRGL_RESOURCE_IW_X);\n   box.y = get_buf_entry(ctx, VIRGL_RESOURCE_IW_Y);\n   box.z = get_buf_entry(ctx, VIRGL_RESOURCE_IW_Z);\n   box.width = get_buf_entry(ctx, VIRGL_RESOURCE_IW_W);\n   box.height = get_buf_entry(ctx, VIRGL_RESOURCE_IW_H);\n   box.depth = get_buf_entry(ctx, VIRGL_RESOURCE_IW_D);\n\n   data = get_buf_ptr(ctx, VIRGL_RESOURCE_IW_DATA_START);\n\n   info.handle = res_handle;\n   info.ctx_id = 0;\n   info.level = level;\n   info.stride = stride;\n   info.layer_stride = layer_stride;\n   info.box = &box;\n   info.offset = 0;\n\n   dataiovec.iov_base = data;\n   dataiovec.iov_len = data_len;\n\n   info.iovec = &dataiovec;\n   info.iovec_cnt = 1;\n   return vrend_transfer_inline_write(ctx->grctx, &info, usage);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8469, "func": "BOOL CSoundFile::Destroy()\n\n{\n\tint i;\n\tfor (i=0; i<MAX_PATTERNS; i++) if (Patterns[i])\n\t{\n\t\tFreePattern(Patterns[i]);\n\t\tPatterns[i] = NULL;\n\t}\n\tm_nPatternNames = 0;\n\tif (m_lpszPatternNames)\n\t{\n\t\tdelete m_lpszPatternNames;\n\t\tm_lpszPatternNames = NULL;\n\t}\n\tif (m_lpszSongComments)\n\t{\n\t\tdelete m_lpszSongComments;\n\t\tm_lpszSongComments = NULL;\n\t}\n\tfor (i=1; i<MAX_SAMPLES; i++)\n\t{\n\t\tMODINSTRUMENT *pins = &Ins[i];\n\t\tif (pins->pSample)\n\t\t{\n\t\t\tFreeSample(pins->pSample);\n\t\t\tpins->pSample = NULL;\n\t\t}\n\t}\n\tfor (i=0; i<MAX_INSTRUMENTS; i++)\n\t{\n\t\tif (Headers[i])\n\t\t{\n\t\t\tdelete Headers[i];\n\t\t\tHeaders[i] = NULL;\n\t\t}\n\t}\n\tfor (i=0; i<MAX_MIXPLUGINS; i++)\n\t{\n\t\tif ((m_MixPlugins[i].nPluginDataSize) && (m_MixPlugins[i].pPluginData))\n\t\t{\n\t\t\tm_MixPlugins[i].nPluginDataSize = 0;\n\t\t\tdelete [] (signed char*)m_MixPlugins[i].pPluginData;\n\t\t\tm_MixPlugins[i].pPluginData = NULL;\n\t\t}\n\t\tm_MixPlugins[i].pMixState = NULL;\n\t\tif (m_MixPlugins[i].pMixPlugin)\n\t\t{\n\t\t\tm_MixPlugins[i].pMixPlugin->Release();\n\t\t\tm_MixPlugins[i].pMixPlugin = NULL;\n\t\t}\n\t}\n\tm_nType = MOD_TYPE_NONE;\n\tm_nChannels = m_nSamples = m_nInstruments = 0;\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9206, "func": "void virtio_irq(VirtQueue *vq)\n{\n    trace_virtio_irq(vq);\n    vq->vdev->isr |= 0x01;\n    virtio_notify_vector(vq->vdev, vq->vector);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8376, "func": "static void mptsas_process_port_facts(MPTSASState *s,\n                                     MPIMsgPortFacts *req)\n{\n    MPIMsgPortFactsReply reply;\n\n    mptsas_fix_port_facts_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    memset(&reply, 0, sizeof(reply));\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.Function   = req->Function;\n    reply.PortNumber = req->PortNumber;\n    reply.MsgContext = req->MsgContext;\n\n    if (req->PortNumber < MPTSAS_NUM_PORTS) {\n        reply.PortType      = MPI_PORTFACTS_PORTTYPE_SAS;\n        reply.MaxDevices    = MPTSAS_NUM_PORTS;\n        reply.PortSCSIID    = MPTSAS_NUM_PORTS;\n        reply.ProtocolFlags = MPI_PORTFACTS_PROTOCOL_LOGBUSADDR | MPI_PORTFACTS_PROTOCOL_INITIATOR;\n    }\n\n    mptsas_fix_port_facts_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187966, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    UWORD32     u4_start_code;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    ps_stream      = &ps_dec->s_bit_stream;\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n            impeg2d_dec_user_data(ps_dec);\n }\n else\n {\n            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\n switch(u4_start_code)\n {\n case QUANT_MATRIX_EXT_ID:\n                impeg2d_dec_quant_matrix_ext(ps_dec);\n break;\n case COPYRIGHT_EXT_ID:\n                impeg2d_dec_copyright_ext(ps_dec);\n break;\n case PIC_DISPLAY_EXT_ID:\n                impeg2d_dec_pic_disp_ext(ps_dec);\n break;\n case CAMERA_PARAM_EXT_ID:\n                impeg2d_dec_cam_param_ext(ps_dec);\n break;\n case ITU_T_EXT_ID:\n                impeg2d_dec_itu_t_ext(ps_dec);\n break;\n case PIC_SPATIAL_SCALABLE_EXT_ID:\n case PIC_TEMPORAL_SCALABLE_EXT_ID:\n                e_error = IMPEG2D_SCALABLITY_NOT_SUP;\n break;\n default:\n                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\n                impeg2d_next_start_code(ps_dec);\n break;\n }\n }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n }\n return e_error;\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 8911, "func": "void vrend_renderer_reset(void)\n{\n   if (vrend_state.sync_thread) {\n      vrend_free_sync_thread();\n      vrend_state.stop_sync_thread = false;\n   }\n   vrend_reset_fences();\n   vrend_decode_reset(false);\n   vrend_object_fini_resource_table();\n   vrend_decode_reset(true);\n   vrend_object_init_resource_table();\n   vrend_renderer_context_create_internal(0, 0, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187831, "func": " long Segment::DoLoadClusterUnknownSize(long long& pos, long& len) {\n  assert(m_pos < 0);\n  assert(m_pUnknownSize);\n \n#if 0\n    assert(m_pUnknownSize->GetElementSize() < 0);  \n    const long long element_start = m_pUnknownSize->m_element_start;\n    pos = -m_pos;\n    assert(pos > element_start);\n    long long total, avail;\n    long status = m_pReader->Length(&total, &avail);\n    if (status < 0)  \n        return status;\n    assert((total < 0) || (avail <= total));\n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n    long long element_size = -1;\n    for (;;) {  \n        if ((total >= 0) && (pos >= total))\n        {\n            element_size = total - element_start;\n            assert(element_size > 0);\n            break;\n        }\n        if ((segment_stop >= 0) && (pos >= segment_stop))\n        {\n            element_size = segment_stop - element_start;\n            assert(element_size > 0);\n            break;\n        }\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(m_pReader, pos, len);\n        if (result < 0)  \n            return static_cast<long>(result);\n        if (result > 0)  \n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long idpos = pos;\n        const long long id = ReadUInt(m_pReader, idpos, len);\n        if (id < 0)  \n            return static_cast<long>(id);\n        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) {  \n            element_size = pos - element_start;\n            assert(element_size > 0);\n            break;\n        }\n#ifdef _DEBUG\n        switch (id)\n        {\n            case 0x20:  \n            case 0x23:  \n            case 0x67:  \n            case 0x2B:  \n                break;\n            default:\n                assert(false);\n                break;\n        }\n#endif\n        pos += len;  \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(m_pReader, pos, len);\n        if (result < 0)  \n            return static_cast<long>(result);\n        if (result > 0)  \n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(m_pReader, pos, len);\n        if (size < 0)  \n            return static_cast<long>(size);\n        pos += len;  \n        if (size == 0)  \n            continue;\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;  \n        if ((segment_stop >= 0) && ((pos + size) > segment_stop))  \n            return E_FILE_FORMAT_INVALID;\n        pos += size;  \n        assert((segment_stop < 0) || (pos <= segment_stop));\n    }  \n    assert(element_size >= 0);\n    m_pos = element_start + element_size;\n    m_pUnknownSize = 0;\n    return 2;  \n#else\n   const long status = m_pUnknownSize->Parse(pos, len);\n \n   if (status < 0)  \n return status;\n\n\n   if (status == 0)  \n     return 2;  \n \n  assert(status > 0);  \n   const long long start = m_pUnknownSize->m_element_start;\n   const long long size = m_pUnknownSize->GetElementSize();\n  assert(size >= 0);\n \n   pos = start + size;\n   m_pos = pos;\n\n\n   m_pUnknownSize = 0;\n \n   return 2;  \n#endif\n }\n", "target": 1, "flaw_line_index": "2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,118,121"}
{"idx": 8794, "func": "static inline int conv_shader_type(int type)\n{\n   switch (type) {\n   case PIPE_SHADER_VERTEX: return GL_VERTEX_SHADER;\n   case PIPE_SHADER_FRAGMENT: return GL_FRAGMENT_SHADER;\n   case PIPE_SHADER_GEOMETRY: return GL_GEOMETRY_SHADER;\n   default:\n      return 0;\n   };\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187584, "func": " int res_unpack(vorbis_info_residue *info,\n\t\tvorbis_info *vi,oggpack_buffer *opb){\n   int j,k;\n   codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;\n   memset(info,0,sizeof(*info));\n\n  info->type=oggpack_read(opb,16);\n if(info->type>2 || info->type<0)goto errout;\n  info->begin=oggpack_read(opb,24);\n  info->end=oggpack_read(opb,24);\n  info->grouping=oggpack_read(opb,24)+1;\n  info->partitions=(char)(oggpack_read(opb,6)+1);\n  info->groupbook=(unsigned char)oggpack_read(opb,8);\n if(info->groupbook>=ci->books)goto errout;\n\n  info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));\n  info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));\n\n for(j=0;j<info->partitions;j++){\n int cascade=oggpack_read(opb,3);\n if(oggpack_read(opb,1))\n      cascade|=(oggpack_read(opb,5)<<3);\n    info->stagemasks[j]=cascade;\n }\n\n\n   for(j=0;j<info->partitions;j++){\n     for(k=0;k<8;k++){\n       if((info->stagemasks[j]>>k)&1){\n\tunsigned char book=(unsigned char)oggpack_read(opb,8);\n\tif(book>=ci->books)goto errout;\n\tinfo->stagebooks[j*8+k]=book;\n\tif(k+1>info->stages)info->stages=k+1;\n       }else\n\tinfo->stagebooks[j*8+k]=0xff;\n     }\n   }\n \n if(oggpack_eop(opb))goto errout;\n\n return 0;\n errout:\n  res_clear_info(info);\n return 1;\n\n }\n", "target": 1, "flaw_line_index": "2,30,31,32,33,35"}
{"idx": 9193, "func": "static enum virtio_device_endian virtio_current_cpu_endian(void)\n{\n    CPUClass *cc = CPU_GET_CLASS(current_cpu);\n\n    if (cc->virtio_is_big_endian(current_cpu)) {\n        return VIRTIO_DEVICE_ENDIAN_BIG;\n    } else {\n        return VIRTIO_DEVICE_ENDIAN_LITTLE;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8555, "func": "static int ssh_channelfind(void *av, void *bv)\n{\n    unsigned *a = (unsigned *) av;\n    struct ssh_channel *b = (struct ssh_channel *) bv;\n    if (*a < b->localid)\n\treturn -1;\n    if (*a > b->localid)\n\treturn +1;\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8723, "func": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n    int bad_chain = 0;\n    X509_VERIFY_PARAM *param = ctx->param;\n    int depth, i, ok = 0;\n    int num, j, retry;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    STACK_OF(X509) *sktmp = NULL;\n    int trust = X509_TRUST_UNTRUSTED;\n    int err;\n\n    if (ctx->cert == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n        ctx->error = X509_V_ERR_INVALID_CALL;\n        return -1;\n    }\n    if (ctx->chain != NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        ctx->error = X509_V_ERR_INVALID_CALL;\n        return -1;\n    }\n\n    cb = ctx->verify_cb;\n\n    if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n        (!sk_X509_push(ctx->chain, ctx->cert))) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        ok = -1;\n        goto err;\n    }\n    CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n    ctx->last_untrusted = 1;\n\n    if (ctx->untrusted != NULL\n        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        ok = -1;\n        goto err;\n    }\n\n    num = sk_X509_num(ctx->chain);\n    x = sk_X509_value(ctx->chain, num - 1);\n    depth = param->depth;\n\n    for (;;) {\n        if (depth < num)\n            break;              \n\n        if (cert_self_signed(x))\n            break;\n        if (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n            if (ok < 0) {\n                ctx->error = X509_V_ERR_STORE_LOOKUP;\n                goto err;\n            }\n            if (ok > 0) {\n                X509_free(xtmp);\n                break;\n            }\n        }\n\n        if (ctx->untrusted != NULL) {\n            xtmp = find_issuer(ctx, sktmp, x);\n            if (xtmp != NULL) {\n                if (!sk_X509_push(ctx->chain, xtmp)) {\n                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                    ctx->error = X509_V_ERR_OUT_OF_MEM;\n                    ok = -1;\n                    goto err;\n                }\n                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                (void)sk_X509_delete_ptr(sktmp, xtmp);\n                ctx->last_untrusted++;\n                x = xtmp;\n                num++;\n                continue;\n            }\n        }\n        break;\n    }\n\n    j = num;\n\n    do {\n        i = sk_X509_num(ctx->chain);\n        x = sk_X509_value(ctx->chain, i - 1);\n        if (cert_self_signed(x)) {\n            if (sk_X509_num(ctx->chain) == 1) {\n                ok = ctx->get_issuer(&xtmp, ctx, x);\n                if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                    ctx->current_cert = x;\n                    ctx->error_depth = i - 1;\n                    if (ok == 1)\n                        X509_free(xtmp);\n                    bad_chain = 1;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto err;\n                } else {\n                    X509_free(x);\n                    x = xtmp;\n                    (void)sk_X509_set(ctx->chain, i - 1, x);\n                    ctx->last_untrusted = 0;\n                }\n            } else {\n                chain_ss = sk_X509_pop(ctx->chain);\n                ctx->last_untrusted--;\n                num--;\n                j--;\n                x = sk_X509_value(ctx->chain, num - 1);\n            }\n        }\n        for (;;) {\n            if (depth < num)\n                break;\n            if (cert_self_signed(x))\n                break;\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n\n            if (ok < 0) {\n                ctx->error = X509_V_ERR_STORE_LOOKUP;\n                goto err;\n            }\n            if (ok == 0)\n                break;\n            x = xtmp;\n            if (!sk_X509_push(ctx->chain, x)) {\n                X509_free(xtmp);\n                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                ctx->error = X509_V_ERR_OUT_OF_MEM;\n                ok = -1;\n                goto err;\n            }\n            num++;\n        }\n\n        if ((trust = check_trust(ctx)) == X509_TRUST_REJECTED) {\n            ok = 0;\n            goto err;\n        }\n\n        retry = 0;\n        if (trust != X509_TRUST_TRUSTED\n            && !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)\n            && !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n            while (j-- > 1) {\n                xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                if (ok < 0) {\n                    ctx->error = X509_V_ERR_STORE_LOOKUP;\n                    goto err;\n                }\n                if (ok > 0) {\n                    X509_free(xtmp);\n\n                    while (num > j) {\n                        xtmp = sk_X509_pop(ctx->chain);\n                        X509_free(xtmp);\n                        num--;\n                    }\n                    ctx->last_untrusted = sk_X509_num(ctx->chain);\n                    retry = 1;\n                    break;\n                }\n            }\n        }\n    } while (retry);\n\n    if (trust != X509_TRUST_TRUSTED && !bad_chain) {\n        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n            if (ctx->last_untrusted >= num)\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n            else\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n            ctx->current_cert = x;\n        } else {\n\n            sk_X509_push(ctx->chain, chain_ss);\n            num++;\n            ctx->last_untrusted = num;\n            ctx->current_cert = chain_ss;\n            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n            chain_ss = NULL;\n        }\n\n        ctx->error_depth = num - 1;\n        bad_chain = 1;\n        ok = cb(0, ctx);\n        if (!ok)\n            goto err;\n    }\n\n    ok = check_chain_extensions(ctx);\n\n    if (!ok)\n        goto err;\n\n\n    ok = check_name_constraints(ctx);\n\n    if (!ok)\n        goto err;\n\n    ok = check_id(ctx);\n\n    if (!ok)\n        goto err;\n\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n\n\n    ok = ctx->check_revocation(ctx);\n    if (!ok)\n        goto err;\n\n    err = X509_chain_check_suiteb(&ctx->error_depth, NULL, ctx->chain,\n                                  ctx->param->flags);\n    if (err != X509_V_OK) {\n        ctx->error = err;\n        ctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);\n        ok = cb(0, ctx);\n        if (!ok)\n            goto err;\n    }\n\n    if (ctx->verify != NULL)\n        ok = ctx->verify(ctx);\n    else\n        ok = internal_verify(ctx);\n    if (!ok)\n        goto err;\n\n#ifndef OPENSSL_NO_RFC3779\n    ok = v3_asid_validate_path(ctx);\n    if (!ok)\n        goto err;\n    ok = v3_addr_validate_path(ctx);\n    if (!ok)\n        goto err;\n#endif\n\n    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n        ok = ctx->check_policy(ctx);\n    if (!ok)\n        goto err;\n    if (0) {\n err:\n        if (ok > 0)\n            ok = 0;\n        X509_get_pubkey_parameters(NULL, ctx->chain);\n    }\n    if (sktmp != NULL)\n        sk_X509_free(sktmp);\n    if (chain_ss != NULL)\n        X509_free(chain_ss);\n\n    if (ok <= 0 && ctx->error == X509_V_OK)\n        ctx->error = X509_V_ERR_UNSPECIFIED;\n    return ok;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187967, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n    impeg2d_bit_stream_get(ps_stream,10);\n\n    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);\n if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))\n {\n        impeg2d_next_code(ps_dec, PICTURE_START_CODE);\n return IMPEG2D_INVALID_PIC_TYPE;\n }\n\n    impeg2d_bit_stream_get(ps_stream,16);\n\n if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)\n {\n        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n }\n if(ps_dec->e_pic_type == B_PIC)\n {\n        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n }\n\n if(ps_dec->u2_is_mpeg2 == 0)\n {\n        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;\n        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;\n }\n\n\n    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n    impeg2d_bit_stream_get_bit(ps_stream);\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "flaw_line_index": "36"}
{"idx": 188183, "func": "static jboolean enableNative(JNIEnv* env, jobject obj) {\n     ALOGV(\"%s:\",__FUNCTION__);\n \n     jboolean result = JNI_FALSE;\n     if (!sBluetoothInterface) return result;\n    int ret = sBluetoothInterface->enable();\n     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;\n     return result;\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8346, "func": "static void xhci_stall_ep(XHCITransfer *xfer)\n{\n    XHCIState *xhci = xfer->xhci;\n    XHCISlot *slot = &xhci->slots[xfer->slotid-1];\n    XHCIEPContext *epctx = slot->eps[xfer->epid-1];\n    uint32_t err;\n    XHCIStreamContext *sctx;\n\n    if (epctx->nr_pstreams) {\n        sctx = xhci_find_stream(epctx, xfer->streamid, &err);\n        if (sctx == NULL) {\n            return;\n        }\n        sctx->ring.dequeue = xfer->trbs[0].addr;\n        sctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, sctx, EP_HALTED);\n    } else {\n        epctx->ring.dequeue = xfer->trbs[0].addr;\n        epctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_HALTED);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187596, "func": "int main(int argc, char **argv)\n{\n#ifdef sgi\n char tmpline[80];\n#endif\n char *p, *bgstr = NULL;\n int rc, alen, flen;\n int error = 0;\n int timing = FALSE;\n int have_bg = FALSE;\n#ifdef FEATURE_LOOP\n int loop = FALSE;\n long loop_interval = -1; \n#endif\n double LUT_exponent; \n double CRT_exponent = 2.2; \n double default_display_exponent; \n XEvent e;\n KeySym k;\n\n\n\n    displayname = (char *)NULL;\n    filename = (char *)NULL;\n    memset(&rpng2_info, 0, sizeof(mainprog_info));\n\n\n\n#if defined(NeXT)\n    LUT_exponent = 1.0 / 2.2;\n#elif defined(sgi)\n    LUT_exponent = 1.0 / 1.7;\n    infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");\n if (infile) {\n double sgi_gamma;\n\n        fgets(tmpline, 80, infile);\n        fclose(infile);\n        sgi_gamma = atof(tmpline);\n if (sgi_gamma > 0.0)\n            LUT_exponent = 1.0 / sgi_gamma;\n }\n#elif defined(Macintosh)\n    LUT_exponent = 1.8 / 2.61;\n#else\n    LUT_exponent = 1.0; \n#endif\n\n    default_display_exponent = LUT_exponent * CRT_exponent;\n\n\n\n if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)\n        rpng2_info.display_exponent = atof(p);\n else\n        rpng2_info.display_exponent = default_display_exponent;\n\n\n\n while (*++argv && !error) {\n if (!strncmp(*argv, \"-display\", 2)) {\n if (!*++argv)\n ++error;\n else\n                displayname = *argv;\n } else if (!strncmp(*argv, \"-gamma\", 2)) {\n if (!*++argv)\n ++error;\n else {\n                rpng2_info.display_exponent = atof(*argv);\n if (rpng2_info.display_exponent <= 0.0)\n ++error;\n }\n } else if (!strncmp(*argv, \"-bgcolor\", 4)) {\n if (!*++argv)\n ++error;\n else {\n                bgstr = *argv;\n if (strlen(bgstr) != 7 || bgstr[0] != '#')\n ++error;\n else {\n                    have_bg = TRUE;\n                    bg_image = FALSE;\n }\n }\n } else if (!strncmp(*argv, \"-bgpat\", 4)) {\n if (!*++argv)\n ++error;\n else {\n                pat = atoi(*argv);\n if (pat >= 0 && pat < num_bgpat) {\n                    bg_image = TRUE;\n                    have_bg = FALSE;\n } else\n ++error;\n }\n } else if (!strncmp(*argv, \"-usleep\", 2)) {\n if (!*++argv)\n ++error;\n else {\n                usleep_duration = (ulg)atol(*argv);\n                demo_timing = TRUE;\n }\n } else if (!strncmp(*argv, \"-pause\", 2)) {\n            pause_after_pass = TRUE;\n } else if (!strncmp(*argv, \"-timing\", 2)) {\n            timing = TRUE;\n#ifdef FEATURE_LOOP\n } else if (!strncmp(*argv, \"-loop\", 2)) {\n            loop = TRUE;\n if (!argv[1] || !is_number(argv[1]))\n                loop_interval = 2;\n else {\n ++argv;\n                loop_interval = atol(*argv);\n if (loop_interval < 0)\n                    loop_interval = 2;\n else if (loop_interval > 100000) \n                    loop_interval = 100000;\n }\n#endif\n } else {\n if (**argv != '-') {\n                filename = *argv;\n if (argv[1]) \n ++error;\n } else\n ++error; \n }\n }\n\n if (!filename)\n ++error;\n\n\n\n if (error) {\n\n         fprintf(stderr, \"\\n%s %s:  %s\\n\\n\", PROGNAME, VERSION, appname);\n         readpng2_version_info();\n         fprintf(stderr, \"\\n\"\n          \"Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg | -bgpat pat]\\n\"\n #ifdef FEATURE_LOOP\n          \"        %*s [-usleep dur | -timing] [-pause] [-loop [sec]] file.png\\n\\n\"\n#else\n          \"        %*s [-usleep dur | -timing] [-pause] file.png\\n\\n\"\n #endif\n           \"    xdpy\\tname of the target X display (e.g., ``hostname:0'')\\n\"\n           \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"\n           \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"\n          \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"\n           \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"\n           \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"\n           \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"\n           \"\\t\\t  used with transparent images; overrides -bgpat\\n\"\n           \"    pat \\tdesired background pattern number (0-%d); used with\\n\"\n          \"\\t\\t  transparent images; overrides -bgcolor\\n\"\n #ifdef FEATURE_LOOP\n           \"    -loop\\tloops through background images after initial display\\n\"\n           \"\\t\\t  is complete (depends on -bgpat)\\n\"\n          \"    sec \\tseconds to display each background image (default = 2)\\n\"\n #endif\n           \"    dur \\tduration in microseconds to wait after displaying each\\n\"\n           \"\\t\\t  row (for demo purposes)\\n\"\n           \"    -timing\\tenables delay for every block read, to simulate modem\\n\"\n           \"\\t\\t  download of image (~36 Kbps)\\n\"\n           \"    -pause\\tpauses after displaying each pass until mouse clicked\\n\"\n           \"\\nPress Q, Esc or mouse button 1 (within image window, after image\\n\"\n          \"is displayed) to quit.\\n\"\n          \"\\n\", PROGNAME,\n          (int)strlen(PROGNAME), \" \", default_display_exponent, num_bgpat-1);\n         exit(1);\n     }\n \n     if (!(infile = fopen(filename, \"rb\"))) {\n         fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);\n         ++error;\n } else {\n        incount = fread(inbuf, 1, INBUFSIZE, infile);\n if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {\n            fprintf(stderr, PROGNAME\n \":  [%s] is not a PNG file: incorrect signature\\n\",\n              filename);\n ++error;\n } else if ((rc = readpng2_init(&rpng2_info)) != 0) {\n switch (rc) {\n case 2:\n                    fprintf(stderr, PROGNAME\n \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);\n break;\n case 4:\n                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");\n break;\n default:\n                    fprintf(stderr, PROGNAME\n \":  unknown readpng2_init() error\\n\");\n break;\n }\n ++error;\n } else {\n Trace((stderr, \"about to call XOpenDisplay()\\n\"))\n            display = XOpenDisplay(displayname);\n if (!display) {\n                readpng2_cleanup(&rpng2_info);\n                fprintf(stderr, PROGNAME \":  can't open X display [%s]\\n\",\n                  displayname? displayname : \"default\");\n ++error;\n }\n }\n if (error)\n            fclose(infile);\n }\n\n\n if (error) {\n        fprintf(stderr, PROGNAME \":  aborting.\\n\");\n        exit(2);\n }\n\n\n\n    alen = strlen(appname);\n    flen = strlen(filename);\n if (alen + flen + 3 > 1023)\n        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));\n else\n        sprintf(titlebar, \"%s:  %s\", appname, filename);\n\n\n\n if (have_bg) {\n unsigned r, g, b; \n\n        sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);\n        rpng2_info.bg_red   = (uch)r;\n        rpng2_info.bg_green = (uch)g;\n        rpng2_info.bg_blue  = (uch)b;\n } else\n        rpng2_info.need_bgcolor = TRUE;\n\n    rpng2_info.state = kPreInit;\n    rpng2_info.mainprog_init = rpng2_x_init;\n    rpng2_info.mainprog_display_row = rpng2_x_display_row;\n    rpng2_info.mainprog_finish_display = rpng2_x_finish_display;\n\n\n\n for (;;) {\n Trace((stderr, \"about to call readpng2_decode_data()\\n\"))\n if (readpng2_decode_data(&rpng2_info, inbuf, incount))\n ++error;\n Trace((stderr, \"done with readpng2_decode_data()\\n\"))\n\n if (error || incount != INBUFSIZE || rpng2_info.state == kDone) {\n if (rpng2_info.state == kDone) {\n Trace((stderr, \"done decoding PNG image\\n\"))\n } else if (ferror(infile)) {\n                fprintf(stderr, PROGNAME\n \":  error while reading PNG image file\\n\");\n                exit(3);\n } else if (feof(infile)) {\n                fprintf(stderr, PROGNAME \":  end of file reached \"\n \"(unexpectedly) while reading PNG image file\\n\");\n                exit(3);\n } else \n {\n }\n break;\n }\n\n if (timing)\n            sleep(1);\n\n        incount = fread(inbuf, 1, INBUFSIZE, infile);\n }\n\n\n\n    fclose(infile);\n Trace((stderr, \"about to call readpng2_cleanup()\\n\"))\n    readpng2_cleanup(&rpng2_info);\n\n if (error) {\n        fprintf(stderr, PROGNAME \":  libpng error while decoding PNG image\\n\");\n        exit(3);\n }\n\n\n#ifdef FEATURE_LOOP\n\n if (loop && bg_image) {\n Trace((stderr, \"entering -loop loop (FEATURE_LOOP)\\n\"))\n for (;;) {\n int i, use_sleep;\n struct timeval now, then;\n\n if (gettimeofday(&then, NULL) == 0) {\n                then.tv_sec += loop_interval;\n                use_sleep = FALSE;\n } else\n                use_sleep = TRUE;\n\n if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask, &e))\n if (QUIT(e,k))\n break;\n\n if (++pat >= num_bgpat)\n                pat = 0;\n            rpng2_x_reload_bg_image();\n\n if (use_sleep || gettimeofday(&now, NULL) != 0) {\n for (i = loop_interval;  i > 0; --i) {\n                    sleep(1);\n if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask,\n &e) && QUIT(e,k))\n break;\n }\n } else {\n if (now.tv_sec < then.tv_sec ||\n (now.tv_sec == then.tv_sec && now.tv_usec < then.tv_usec))\n {\n int quit = FALSE;\n long seconds_to_go = then.tv_sec - now.tv_sec;\n long usleep_usec;\n\n while (seconds_to_go-- > 1) {\n int seconds_done = 0;\n\n for (i = seconds_to_go;  i > 0 && !quit; --i) {\n                            sleep(1);\n if (XCheckMaskEvent(display, KeyPressMask |\n ButtonPressMask, &e) && QUIT(e,k))\n                                quit = TRUE;\n if (++seconds_done > 1000)\n break; \n }\n if (quit)\n break;\n\n if (gettimeofday(&now, NULL) == 0) {\n if (now.tv_sec >= then.tv_sec)\n break;\n                            seconds_to_go = then.tv_sec - now.tv_sec;\n } else\n ++seconds_to_go; \n }\n if (quit)\n break; \n\n if (gettimeofday(&now, NULL) == 0) {\n                        usleep_usec = 1000000L*(then.tv_sec - now.tv_sec) +\n                          then.tv_usec - now.tv_usec;\n if (usleep_usec > 0)\n                            usleep((ulg)usleep_usec);\n }\n }\n }\n\n            rpng2_x_redisplay_image (0, 0, rpng2_info.width, rpng2_info.height);\n }\n\n } else \n\n#endif \n\n\n if (rpng2_info.state >= kWindowInit) {\n Trace((stderr, \"entering final wait-for-quit-event loop\\n\"))\n do {\n XNextEvent(display, &e);\n if (e.type == Expose) {\n XExposeEvent *ex = (XExposeEvent *)&e;\n                rpng2_x_redisplay_image (ex->x, ex->y, ex->width, ex->height);\n }\n } while (!QUIT(e,k));\n } else {\n        fprintf(stderr, PROGNAME \":  init callback never called:  probable \"\n \"libpng error while decoding PNG metadata\\n\");\n        exit(4);\n }\n\n\n\n\n     Trace((stderr, \"about to call rpng2_x_cleanup()\\n\"))\n     rpng2_x_cleanup();\n \n     return 0;\n }\n", "target": 1, "flaw_line_index": "142,144,145,146,151,157,161,169,170,171"}
{"idx": 8690, "func": "ps (char *path)\n{\n  char *copy = xstrdup (path);\n  path_simplify (copy);\n  return copy;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8772, "func": "static ALWAYS_INLINE uint32_t random_xid(void)\n{\n\treturn rand();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8471, "func": "UINT CSoundFile::DetectUnusedSamples(BOOL *pbIns)\n{\n\tUINT nExt = 0;\n\n\tif (!pbIns) return 0;\n\tif (m_nInstruments)\n\t{\n\t\tmemset(pbIns, 0, MAX_SAMPLES * sizeof(BOOL));\n\t\tfor (UINT ipat=0; ipat<MAX_PATTERNS; ipat++)\n\t\t{\n\t\t\tMODCOMMAND *p = Patterns[ipat];\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\tUINT jmax = PatternSize[ipat] * m_nChannels;\n\t\t\t\tfor (UINT j=0; j<jmax; j++, p++)\n\t\t\t\t{\n\t\t\t\t\tif ((p->note) && (p->note <= 120))\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((p->instr) && (p->instr < MAX_INSTRUMENTS))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tINSTRUMENTHEADER *penv = Headers[p->instr];\n\t\t\t\t\t\t\tif (penv)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tUINT n = penv->Keyboard[p->note-1];\n\t\t\t\t\t\t\t\tif (n < MAX_SAMPLES) pbIns[n] = TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (UINT k=1; k<=m_nInstruments; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tINSTRUMENTHEADER *penv = Headers[k];\n\t\t\t\t\t\t\t\tif (penv)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tUINT n = penv->Keyboard[p->note-1];\n\t\t\t\t\t\t\t\t\tif (n < MAX_SAMPLES) pbIns[n] = TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (UINT ichk=1; ichk<=m_nSamples; ichk++)\n\t\t{\n\t\t\tif ((!pbIns[ichk]) && (Ins[ichk].pSample)) nExt++;\n\t\t}\n\t}\n\treturn nExt;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8320, "func": "XDeleteModifiermapEntry(XModifierKeymap *map,\n#if NeedWidePrototypes\n\t\t\tunsigned int keycode,\n#else\n\t\t\tKeyCode keycode,\n#endif\n\t\t\tint modifier)\n{\n    int i,\n\trow = modifier * map->max_keypermod;\n\n    for (i=0; i<map->max_keypermod; i++) {\n        if (map->modifiermap[ row+i ] == keycode)\n            map->modifiermap[ row+i ] = 0;\n    }\n    return (map);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187795, "func": " status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (!mTimeToSample.empty() || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n if ((uint64_t)mTimeToSampleCount >\n (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n return ERROR_OUT_OF_RANGE;\n }\n\n if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n return ERROR_IO;\n }\n\n\n     for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n     }\n     return OK;\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187636, "func": "gamma_test(png_modifier *pmIn, PNG_CONST png_byte colour_typeIn,\n    PNG_CONST png_byte bit_depthIn, PNG_CONST int palette_numberIn,\n    PNG_CONST int interlace_typeIn,\n    PNG_CONST double file_gammaIn, PNG_CONST double screen_gammaIn,\n    PNG_CONST png_byte sbitIn, PNG_CONST int threshold_testIn,\n    PNG_CONST char *name,\n    PNG_CONST int use_input_precisionIn, PNG_CONST int scale16In,\n    PNG_CONST int expand16In, PNG_CONST int do_backgroundIn,\n    PNG_CONST png_color_16 *bkgd_colorIn, double bkgd_gammaIn)\n {\n    gamma_display d;\n    context(&pmIn->this, fault);\n\n   gamma_display_init(&d, pmIn, FILEID(colour_typeIn, bit_depthIn,\n      palette_numberIn, interlace_typeIn, 0, 0, 0),\n      file_gammaIn, screen_gammaIn, sbitIn,\n      threshold_testIn, use_input_precisionIn, scale16In,\n      expand16In, do_backgroundIn, bkgd_colorIn, bkgd_gammaIn);\n\n Try\n {\n      png_structp pp;\n      png_infop pi;\n      gama_modification gama_mod;\n      srgb_modification srgb_mod;\n      sbit_modification sbit_mod;\n\n      d.pm->encoding_counter = 0;\n      modifier_set_encoding(d.pm); \n      d.pm->current_gamma = d.file_gamma;\n\n      d.pm->modifications = NULL;\n      gama_modification_init(&gama_mod, d.pm, d.file_gamma);\n      srgb_modification_init(&srgb_mod, d.pm, 127 \n);\n if (d.sbit > 0)\n         sbit_modification_init(&sbit_mod, d.pm, d.sbit);\n\n \n       modification_reset(d.pm->modifications);\n \n       pp = set_modifier_for_read(d.pm, &pi, d.this.id, name);\n       standard_palette_init(&d.this);\n \n if (d.pm->this.progressive)\n {\n         png_set_progressive_read_fn(pp, &d, gamma_info, progressive_row,\n            gamma_end);\n\n         modifier_progressive_read(d.pm, pp, pi);\n }\n else\n {\n         png_set_read_fn(pp, d.pm, modifier_read);\n\n         png_read_info(pp, pi);\n\n         gamma_info_imp(&d, pp, pi);\n\n         sequential_row(&d.this, pp, pi, -1, 0);\n\n if (!d.this.speed)\n            gamma_image_validate(&d, pp, pi);\n else\n            d.this.ps->validated = 1;\n }\n\n      modifier_reset(d.pm);\n\n if (d.pm->log && !d.threshold_test && !d.this.speed)\n         fprintf(stderr, \"%d bit %s %s: max error %f (%.2g, %2g%%)\\n\",\n            d.this.bit_depth, colour_types[d.this.colour_type], name,\n            d.maxerrout, d.maxerrabs, 100*d.maxerrpc);\n\n if (d.this.colour_type == 0 || d.this.colour_type == 4)\n {\n switch (d.this.bit_depth)\n {\n case 1:\n break;\n\n case 2:\n if (d.maxerrout > d.pm->error_gray_2)\n               d.pm->error_gray_2 = d.maxerrout;\n\n break;\n\n case 4:\n if (d.maxerrout > d.pm->error_gray_4)\n               d.pm->error_gray_4 = d.maxerrout;\n\n break;\n\n case 8:\n if (d.maxerrout > d.pm->error_gray_8)\n               d.pm->error_gray_8 = d.maxerrout;\n\n break;\n\n case 16:\n if (d.maxerrout > d.pm->error_gray_16)\n               d.pm->error_gray_16 = d.maxerrout;\n\n break;\n\n default:\n            png_error(pp, \"bad bit depth (internal: 1)\");\n }\n }\n\n else if (d.this.colour_type == 2 || d.this.colour_type == 6)\n {\n switch (d.this.bit_depth)\n {\n case 8:\n\n if (d.maxerrout > d.pm->error_color_8)\n               d.pm->error_color_8 = d.maxerrout;\n\n break;\n\n case 16:\n\n if (d.maxerrout > d.pm->error_color_16)\n               d.pm->error_color_16 = d.maxerrout;\n\n break;\n\n default:\n            png_error(pp, \"bad bit depth (internal: 2)\");\n }\n }\n\n else if (d.this.colour_type == 3)\n {\n if (d.maxerrout > d.pm->error_indexed)\n            d.pm->error_indexed = d.maxerrout;\n }\n }\n\n Catch(fault)\n      modifier_reset(voidcast(png_modifier*,(void*)fault));\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,41"}
{"idx": 187761, "func": "usage(const char *prog)\n{\n size_t i;\n static const char *usage_string[] = {\n\"  Tests, optimizes and optionally fixes the zlib header in PNG files.\",\n\"  Optionally, when fixing, strips ancilliary chunks from the file.\",\n0,\n\"OPTIONS\",\n\"  OPERATION\",\n\"      By default files are just checked for readability with a summary of the\",\n\"      of zlib issues founds for each compressed chunk and the IDAT stream in\",\n\"      the file.\",\n\"    --optimize (-o):\",\n\"      Find the smallest deflate window size for the compressed data.\",\n\"    --strip=[none|crc|unsafe|unused|transform|color|all]:\",\n\"        none (default):   Retain all chunks.\",\n\"        crc:    Remove chunks with a bad CRC.\",\n\"        unsafe: Remove chunks that may be unsafe to retain if the image data\",\n\"                is modified.  This is set automatically if --max is given but\",\n\"                may be cancelled by a later --strip=none.\",\n\"        unused: Remove chunks not used by libpng when decoding an image.\",\n\"                This retains any chunks that might be used by libpng image\",\n\"                transformations.\",\n\"        transform: unused+bKGD.\",\n\"        color:  transform+iCCP and cHRM.\",\n\"        all:    color+gAMA and sRGB.\",\n\"      Only ancillary chunks are ever removed.  In addition the tRNS and sBIT\",\n\"      chunks are never removed as they affect exact interpretation of the\",\n\"      image pixel values.  The following known chunks are treated specially\",\n\"      by the above options:\",\n\n \"        gAMA, sRGB [all]: These specify the gamma encoding used for the pixel\",\n \"            values.\",\n \"        cHRM, iCCP [color]: These specify how colors are encoded.  iCCP also\",\n\"            specifies the exact encoding of a pixel value however in practice\",\n\"            most programs will ignore it.\",\n \"        bKGD [transform]: This is used by libpng transforms.\"\n \"    --max=<number>:\",\n \"      Use IDAT chunks sized <number>.  If no number is given the the IDAT\",\n \"      chunks will be the maximum size permitted; 2^31-1 bytes.  If the option\",\n \"      is omitted the original chunk sizes will not be changed.  When the\",\n\"      option is given --strip=unsafe is set automatically, this may be\",\n \"      cancelled if you know that all unknown unsafe-to-copy chunks really are\",\n \"      safe to copy across an IDAT size change.  This is true of all chunks\",\n \"      that have ever been formally proposed as PNG extensions.\",\n \"  MESSAGES\",\n \"      By default the program only outputs summaries for each file.\",\n \"    --quiet (-q):\",\n\"      Do not output the summaries except for files which cannot be read. With\",\n \"      two --quiets these are not output either.\",\n \"    --errors (-e):\",\n \"      Output errors from libpng and the program (except too-far-back).\",\n\"    --warnings (-w):\",\n\"      Output warnings from libpng.\",\n\"  OUTPUT\",\n\"      By default nothing is written.\",\n\"    --out=<file>:\",\n\"      Write the optimized/corrected version of the next PNG to <file>.  This\",\n\"      overrides the following two options\",\n\"    --suffix=<suffix>:\",\n\"      Set --out=<name><suffix> for all following files unless overridden on\",\n\"      a per-file basis by explicit --out.\",\n\"    --prefix=<prefix>:\",\n\"      Set --out=<prefix><name> for all the following files unless overridden\",\n\"      on a per-file basis by explicit --out.\",\n\"      These two options can be used together to produce a suffix and prefix.\",\n\"  INTERNAL OPTIONS\",\n#if 0 \n#ifdef PNG_MAXIMUM_INFLATE_WINDOW\n\"    --test:\",\n\"      Test the PNG_MAXIMUM_INFLATE_WINDOW option.  Setting this disables\",\n\"      output as this would produce a broken file.\",\n#endif\n#endif\n0,\n\"EXIT CODES\",\n\"  *** SUBJECT TO CHANGE ***\",\n\"  The program exit code is value in the range 0..127 holding a bit mask of\",\n\n \"  the following codes.  Notice that the results for each file are combined\",\n \"  together - check one file at a time to get a meaningful error code!\",\n \"    0x01: The zlib too-far-back error existed in at least one chunk.\",\n\"    0x02: At least once chunk had a CRC error.\",\n \"    0x04: A chunk length was incorrect.\",\n \"    0x08: The file was truncated.\",\n \"  Errors less than 16 are potentially recoverable, for a single file if the\",\n\"  exit code is less than 16 the file could be read (with corrections if a\",\n\n \"  non-zero code is returned).\",\n \"    0x10: The file could not be read, even with corrections.\",\n \"    0x20: The output file could not be written.\",\n\"    0x40: An unexpected, potentially internal, error occured.\",\n \"  If the command line arguments are incorrect the program exits with exit\",\n \"  255.  Some older operating systems only support 7-bit exit codes, on those\",\n \"  systems it is suggested that this program is first tested by supplying\",\n\"  invalid arguments.\",\n0,\n\"DESCRIPTION\",\n\"  \" PROGRAM_NAME \":\",\n\"  checks each PNG file on the command line for errors.  By default errors are\",\n\"  not output and the program just returns an exit code and prints a summary.\",\n\"  With the --quiet (-q) option the summaries are suppressed too and the\",\n\"  program only outputs unexpected errors (internal errors and file open\",\n\"  errors).\",\n\"  Various known problems in PNG files are fixed while the file is being read\",\n\"  The exit code says what problems were fixed.  In particular the zlib error:\",\n0,\n\"        \\\"invalid distance too far back\\\"\",\n0,\n\"  caused by an incorrect optimization of a zlib stream is fixed in any\",\n\"  compressed chunk in which it is encountered.  An integrity problem of the\",\n\"  PNG stream caused by a bug in libpng which wrote an incorrect chunk length\",\n\"  is also fixed.  Chunk CRC errors are automatically fixed up.\",\n0,\n\"  Setting one of the \\\"OUTPUT\\\" options causes the possibly modified file to\",\n\"  be written to a new file.\",\n0,\n\"  Notice that some PNG files with the zlib optimization problem can still be\",\n\"  read by libpng under some circumstances.  This program will still detect\",\n\"  and, if requested, correct the error.\",\n0,\n\"  The program will reliably process all files on the command line unless\",\n\"  either an invalid argument causes the usage message (this message) to be\",\n\"  produced or the program crashes.\",\n0,\n\"  The summary lines describe issues encountered with the zlib compressed\",\n\"  stream of a chunk.  They have the following format, which is SUBJECT TO\",\n\"  CHANGE in the future:\",\n0,\n\"     chunk reason comp-level p1 p2 p3 p4 file\",\n0,\n\"  p1 through p4 vary according to the 'reason'.  There are always 8 space\",\n\"  separated fields.  Reasons specific formats are:\",\n0,\n\"     chunk ERR status code read-errno write-errno message file\",\n\"     chunk SKP comp-level file-bits zlib-rc compressed message file\",\n\"     chunk ??? comp-level file-bits ok-bits compressed uncompress file\",\n0,\n\"  The various fields are\",\n0,\n\"$1 chunk:      The chunk type of a chunk in the file or 'HEAD' if a problem\",\n\"               is reported by libpng at the start of the IDAT stream.\",\n\"$2 reason:     One of:\",\n\"          CHK: A zlib header checksum was detected and fixed.\",\n\"          TFB: The zlib too far back error was detected and fixed.\",\n\"          OK : No errors were detected in the zlib stream and optimization\",\n\"               was not requested, or was not possible.\",\n\"          OPT: The zlib stream window bits value could be improved (and was).\",\n\n \"          SKP: The chunk was skipped because of a zlib issue (zlib-rc) with\",\n \"               explanation 'message'\",\n \"          ERR: The read of the file was aborted.  The parameters explain why.\",\n\"$3 status:     For 'ERR' the accumulate status code from 'EXIT CODES' above.\",\n \"               This is printed as a 2 digit hexadecimal value\",\n \"   comp-level: The recorded compression level (FLEVEL) of a zlib stream\",\n \"               expressed as a string {supfast,stdfast,default,maximum}\",\n\"$4 code:       The file exit code; where stop was called, as a fairly terse\",\n\"               string {warning,libpng,zlib,invalid,read,write,unexpected}.\",\n\"   file-bits:  The zlib window bits recorded in the file.\",\n\"$5 read-errno: A system errno value from a read translated by strerror(3).\",\n\"   zlib-rc:    A zlib return code as a string (see zlib.h).\",\n\"   ok-bits:    The smallest zlib window bits value that works.\",\n\"$6 write-errno:A system errno value from a write translated by strerror(3).\",\n\"   compressed: The count of compressed bytes in the zlib stream, when the\",\n\"               reason is 'SKP'; this is a count of the bytes read from the\",\n\"               stream when the fatal error was encountered.\",\n\"$7 message:    An error message (spaces replaced by _, as in all parameters),\",\n\"   uncompress: The count of bytes from uncompressing the zlib stream; this\",\n\"               may not be the same as the number of bytes in the image.\",\n\"$8 file:       The name of the file (this may contain spaces).\",\n};\n\n   fprintf(stderr, \"Usage: %s {[options] png-file}\\n\", prog);\n\n for (i=0; i < (sizeof usage_string)/(sizeof usage_string[0]); ++i)\n {\n if (usage_string[i] != 0)\n         fputs(usage_string[i], stderr);\n\n      fputc('\\n', stderr);\n }\n\n   exit(255);\n}\n", "target": 1, "flaw_line_index": "35,36,42,49,83,92,153"}
{"idx": 8406, "func": "pvscsi_complete_request(PVSCSIState *s, PVSCSIRequest *r)\n{\n    assert(!r->completed);\n\n    trace_pvscsi_complete_request(r->cmp.context, r->cmp.dataLen,\n                                  r->sense_key);\n    if (r->sreq != NULL) {\n        scsi_req_unref(r->sreq);\n        r->sreq = NULL;\n    }\n    r->completed = 1;\n    QTAILQ_REMOVE(&s->pending_queue, r, next);\n    QTAILQ_INSERT_TAIL(&s->completion_queue, r, next);\n    pvscsi_schedule_completion_processing(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8533, "func": "static struct Packet *ssh1_rdpkt(Ssh ssh, const unsigned char **data,\n                                 int *datalen)\n{\n    struct rdpkt1_state_tag *st = &ssh->rdpkt1_state;\n\n    crBegin(ssh->ssh1_rdpkt_crstate);\n\n    st->pktin = ssh_new_packet();\n\n    st->pktin->type = 0;\n    st->pktin->length = 0;\n\n    for (st->i = st->len = 0; st->i < 4; st->i++) {\n\twhile ((*datalen) == 0)\n\t    crReturn(NULL);\n\tst->len = (st->len << 8) + **data;\n\t(*data)++, (*datalen)--;\n    }\n\n    st->pad = 8 - (st->len % 8);\n    st->biglen = st->len + st->pad;\n    st->pktin->length = st->len - 5;\n\n    if (st->biglen < 0) {\n        bombout((\"Extremely large packet length from server suggests\"\n\t\t \" data stream corruption\"));\n\tssh_free_packet(st->pktin);\n        crStop(NULL);\n    }\n\n    st->pktin->maxlen = st->biglen;\n    st->pktin->data = snewn(st->biglen + APIEXTRA, unsigned char);\n\n    st->to_read = st->biglen;\n    st->p = st->pktin->data;\n    while (st->to_read > 0) {\n\tst->chunk = st->to_read;\n\twhile ((*datalen) == 0)\n\t    crReturn(NULL);\n\tif (st->chunk > (*datalen))\n\t    st->chunk = (*datalen);\n\tmemcpy(st->p, *data, st->chunk);\n\t*data += st->chunk;\n\t*datalen -= st->chunk;\n\tst->p += st->chunk;\n\tst->to_read -= st->chunk;\n    }\n\n    if (ssh->cipher && detect_attack(ssh->crcda_ctx, st->pktin->data,\n\t\t\t\t     st->biglen, NULL)) {\n        bombout((\"Network attack (CRC compensation) detected!\"));\n\tssh_free_packet(st->pktin);\n        crStop(NULL);\n    }\n\n    if (ssh->cipher)\n\tssh->cipher->decrypt(ssh->v1_cipher_ctx, st->pktin->data, st->biglen);\n\n    st->realcrc = crc32_compute(st->pktin->data, st->biglen - 4);\n    st->gotcrc = GET_32BIT(st->pktin->data + st->biglen - 4);\n    if (st->gotcrc != st->realcrc) {\n\tbombout((\"Incorrect CRC received on packet\"));\n\tssh_free_packet(st->pktin);\n\tcrStop(NULL);\n    }\n\n    st->pktin->body = st->pktin->data + st->pad + 1;\n\n    if (ssh->v1_compressing) {\n\tunsigned char *decompblk;\n\tint decomplen;\n\tif (!zlib_decompress_block(ssh->sc_comp_ctx,\n\t\t\t\t   st->pktin->body - 1, st->pktin->length + 1,\n\t\t\t\t   &decompblk, &decomplen)) {\n\t    bombout((\"Zlib decompression encountered invalid data\"));\n\t    ssh_free_packet(st->pktin);\n\t    crStop(NULL);\n\t}\n\n\tif (st->pktin->maxlen < st->pad + decomplen) {\n\t    st->pktin->maxlen = st->pad + decomplen;\n\t    st->pktin->data = sresize(st->pktin->data,\n\t\t\t\t      st->pktin->maxlen + APIEXTRA,\n\t\t\t\t      unsigned char);\n\t    st->pktin->body = st->pktin->data + st->pad + 1;\n\t}\n\n\tmemcpy(st->pktin->body - 1, decompblk, decomplen);\n\tsfree(decompblk);\n\tst->pktin->length = decomplen - 1;\n    }\n\n    st->pktin->type = st->pktin->body[-1];\n\n\n    if (ssh->logctx)\n        ssh1_log_incoming_packet(ssh, st->pktin);\n\n    st->pktin->savedpos = 0;\n\n    crFinish(st->pktin);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187723, "func": "standard_row_validate(standard_display *dp, png_const_structp pp,\n int iImage, int iDisplay, png_uint_32 y)\n{\n int where;\n   png_byte std[STANDARD_ROWMAX];\n\n   memset(std, 178, sizeof std);\n   standard_row(pp, std, dp->id, y);\n\n    if (iImage >= 0 &&\n       (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),\n            dp->bit_width)) != 0)\n {\n char msg[64];\n      sprintf(msg, \"PNG image row[%lu][%d] changed from %.2x to %.2x\",\n (unsigned long)y, where-1, std[where-1],\n         store_image_row(dp->ps, pp, iImage, y)[where-1]);\n\n       png_error(pp, msg);\n    }\n \n#if PNG_LIBPNG_VER < 10506\n#endif\n    if (iDisplay >= 0 &&\n       (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),\n          dp->bit_width)) != 0)\n    {\n       char msg[64];\n      sprintf(msg, \"display  row[%lu][%d] changed from %.2x to %.2x\",\n          (unsigned long)y, where-1, std[where-1],\n          store_image_row(dp->ps, pp, iDisplay, y)[where-1]);\n       png_error(pp, msg);\n }\n}\n", "target": 1, "flaw_line_index": "22,22,22,23,29"}
{"idx": 8534, "func": "static void ssh2_add_sigblob(Ssh ssh, struct Packet *pkt,\n\t\t\t     void *pkblob_v, int pkblob_len,\n\t\t\t     void *sigblob_v, int sigblob_len)\n{\n    unsigned char *pkblob = (unsigned char *)pkblob_v;\n    unsigned char *sigblob = (unsigned char *)sigblob_v;\n\n\n    if ((ssh->remote_bugs & BUG_SSH2_RSA_PADDING) && pkblob_len > 4+7+4 &&\n\t(GET_32BIT(pkblob) == 7 && !memcmp(pkblob+4, \"ssh-rsa\", 7))) {\n\tint pos, len, siglen;\n\n\n\tpos = 4+7;\t\t       \n        len = toint(GET_32BIT(pkblob+pos)); \n        if (len < 0 || len > pkblob_len - pos - 4)\n            goto give_up;\n\tpos += 4 + len;                \n        if (pkblob_len - pos < 4)\n            goto give_up;\n\tlen = toint(GET_32BIT(pkblob+pos)); \n        if (len < 0 || len > pkblob_len - pos - 4)\n            goto give_up;\n\tpos += 4;\t\t       \n\twhile (len > 0 && pkblob[pos] == 0)\n\t    len--, pos++;\n\n\tpos = 4+7;\t\t       \n        if (sigblob_len < pos+4)\n            goto give_up;\n\tsiglen = toint(GET_32BIT(sigblob+pos));\n        if (siglen != sigblob_len - pos - 4)\n            goto give_up;\n\n\tif (len != siglen) {\n\t    unsigned char newlen[4];\n\t    ssh2_pkt_addstring_start(pkt);\n\t    ssh2_pkt_addstring_data(pkt, (char *)sigblob, pos);\n\t    pos += 4;\t\t       \n\t    PUT_32BIT(newlen, len);\n\t    ssh2_pkt_addstring_data(pkt, (char *)newlen, 4);\n\t    newlen[0] = 0;\n\t    while (len-- > siglen) {\n\t\tssh2_pkt_addstring_data(pkt, (char *)newlen, 1);\n\t    }\n\t    ssh2_pkt_addstring_data(pkt, (char *)(sigblob+pos), siglen);\n\t    return;\n\t}\n\n      give_up:;\n    }\n\n    ssh2_pkt_addstring_start(pkt);\n    ssh2_pkt_addstring_data(pkt, (char *)sigblob, sigblob_len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9059, "func": "static void vmxnet3_rx_update_descr(struct NetRxPkt *pkt,\n    struct Vmxnet3_RxCompDesc *rxcd)\n{\n    int csum_ok, is_gso;\n    bool isip4, isip6, istcp, isudp;\n    struct virtio_net_hdr *vhdr;\n    uint8_t offload_type;\n\n    if (net_rx_pkt_is_vlan_stripped(pkt)) {\n        rxcd->ts = 1;\n        rxcd->tci = net_rx_pkt_get_vlan_tag(pkt);\n    }\n\n    if (!net_rx_pkt_has_virt_hdr(pkt)) {\n        goto nocsum;\n    }\n\n    vhdr = net_rx_pkt_get_vhdr(pkt);\n    csum_ok = VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_DATA_VALID) ||\n              VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM);\n\n    offload_type = vhdr->gso_type & ~VIRTIO_NET_HDR_GSO_ECN;\n    is_gso = (offload_type != VIRTIO_NET_HDR_GSO_NONE) ? 1 : 0;\n\n    if (!csum_ok && !is_gso) {\n        goto nocsum;\n    }\n\n    net_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n    if ((!istcp && !isudp) || (!isip4 && !isip6)) {\n        goto nocsum;\n    }\n\n    rxcd->cnc = 0;\n    rxcd->v4 = isip4 ? 1 : 0;\n    rxcd->v6 = isip6 ? 1 : 0;\n    rxcd->tcp = istcp ? 1 : 0;\n    rxcd->udp = isudp ? 1 : 0;\n    rxcd->fcs = rxcd->tuc = rxcd->ipc = 1;\n    return;\n\nnocsum:\n    rxcd->cnc = 1;\n    return;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187496, "func": "void btsnoop_net_write(const void *data, size_t length) {\n#if (!defined(BT_NET_DEBUG) || (BT_NET_DEBUG != TRUE))\n return; \n#endif\n\n \n   pthread_mutex_lock(&client_socket_lock_);\n   if (client_socket_ != -1) {\n    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {\n       safe_close_(&client_socket_);\n     }\n   }\n  pthread_mutex_unlock(&client_socket_lock_);\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8955, "func": "static bool net_tx_pkt_do_sw_fragmentation(struct NetTxPkt *pkt,\n    NetClientState *nc)\n{\n    struct iovec fragment[NET_MAX_FRAG_SG_LIST];\n    size_t fragment_len = 0;\n    bool more_frags = false;\n\n    void *l2_iov_base, *l3_iov_base;\n    size_t l2_iov_len, l3_iov_len;\n    int src_idx =  NET_TX_PKT_PL_START_FRAG, dst_idx;\n    size_t src_offset = 0;\n    size_t fragment_offset = 0;\n\n    l2_iov_base = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base;\n    l2_iov_len = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len;\n    l3_iov_base = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    l3_iov_len = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len;\n\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base = l2_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len = l2_iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base = l3_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len = l3_iov_len;\n\n\n    do {\n        fragment_len = net_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset,\n            fragment, &dst_idx);\n\n        more_frags = (fragment_offset + fragment_len < pkt->payload_len);\n\n        eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base,\n            l3_iov_len, fragment_len, fragment_offset, more_frags);\n\n        eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);\n\n        net_tx_pkt_sendv(pkt, nc, fragment, dst_idx);\n\n        fragment_offset += fragment_len;\n\n    } while (fragment_len && more_frags);\n\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187851, "func": "void CuePoint::Load(IMkvReader* pReader) {\n \n   if (m_timecode >= 0)  \n    return;\n \n   assert(m_track_positions == NULL);\n   assert(m_track_positions_count == 0);\n\n long long pos_ = -m_timecode;\n const long long element_start = pos_;\n\n long long stop;\n\n\n   {\n     long len;\n \n    const long long id = ReadUInt(pReader, pos_, len);\n    assert(id == 0x3B);  \n     if (id != 0x3B)\n      return;\n \n     pos_ += len;  \n \n const long long size = ReadUInt(pReader, pos_, len);\n    assert(size >= 0);\n\n    pos_ += len; \n\n    stop = pos_ + size;\n }\n\n const long long element_size = stop - element_start;\n\n long long pos = pos_;\n\n\n\n   while (pos < stop) {\n     long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  \n    assert((pos + len) <= stop);\n \n     pos += len;  \n \n     const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert((pos + len) <= stop);\n \n     pos += len;  \n    assert((pos + size) <= stop);\n \n     if (id == 0x33)  \n       m_timecode = UnserializeUInt(pReader, pos, size);\n\n else if (id == 0x37) \n\n       ++m_track_positions_count;\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(m_timecode >= 0);\n  assert(m_track_positions_count > 0);\n \n \n  m_track_positions = new TrackPosition[m_track_positions_count];\n \n \n TrackPosition* p = m_track_positions;\n  pos = pos_;\n\n\n   while (pos < stop) {\n     long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  \n    assert((pos + len) <= stop);\n \n     pos += len;  \n \n const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert((pos + len) <= stop);\n\n    pos += len; \n    assert((pos + size) <= stop);\n\n \n     if (id == 0x37) {  \n       TrackPosition& tp = *p++;\n      tp.Parse(pReader, pos, size);\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n   assert(size_t(p - m_track_positions) == m_track_positions_count);\n \n   m_element_start = element_start;\n   m_element_size = element_size;\n }\n", "target": 1, "flaw_line_index": "6,20,21,23,46,47,48,53,54,57,67,70,71,77,88,89,90,104,108"}
{"idx": 187726, "func": "store_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage)\n {\n    png_const_bytep image = ps->image;\n \n if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)\n      png_error(pp, \"image overwrite\");\n else\n {\n png_size_t cbRow = ps->cb_row;\n      png_uint_32 rows = ps->image_h;\n\n      image += iImage * (cbRow+5) * ps->image_h;\n\n      image += 2; \n\n while (rows-- > 0)\n {\n if (image[-2] != 190 || image[-1] != 239)\n            png_error(pp, \"row start overwritten\");\n\n if (image[cbRow] != 222 || image[cbRow+1] != 173 ||\n            image[cbRow+2] != 17)\n            png_error(pp, \"row end overwritten\");\n\n         image += cbRow+5;\n }\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187647, "func": "image_transform_png_set_background_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_byte colour_type, bit_depth;\n   png_byte random_bytes[8]; \n int expand;\n   png_color_16 back;\n\n   RANDOMIZE(random_bytes);\n\n   colour_type = that->this.colour_type;\n if (colour_type == 3)\n {\n      colour_type = PNG_COLOR_TYPE_RGB;\n      bit_depth = 8;\n      expand = 0; \n }\n\n \n    else\n    {\n       bit_depth = that->this.bit_depth;\n       expand = 1;\n    }\n \n    image_pixel_init(&data, random_bytes, colour_type,\n      bit_depth, 0\n);\n \n   RANDOMIZE(back);\n\n if (colour_type & PNG_COLOR_MASK_COLOR)\n {\n      back.red = (png_uint_16)data.red;\n      back.green = (png_uint_16)data.green;\n      back.blue = (png_uint_16)data.blue;\n }\n\n else\n      back.gray = (png_uint_16)data.red;\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\n      png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);\n#  else\n      png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);\n#  endif\n\n this->next->set(this->next, that, pp, pi);\n\n }\n", "target": 1, "flaw_line_index": "28"}
{"idx": 9197, "func": "static bool virtio_device_endian_needed(void *opaque)\n{\n    VirtIODevice *vdev = opaque;\n\n    assert(vdev->device_endian != VIRTIO_DEVICE_ENDIAN_UNKNOWN);\n    if (!virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n        return vdev->device_endian != virtio_default_endian();\n    }\n    return vdev->device_endian != VIRTIO_DEVICE_ENDIAN_LITTLE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8648, "func": "size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"s16s8s16s16s16\",\n                              \"QEMU MPT Fusion\",\n                              \"2.5\",\n                              \"QEMU MPT Fusion\",\n                              \"QEMU\",\n                              \"0000111122223333\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187534, "func": "void StreamingProcessor::releaseRecordingFrame(const sp<IMemory>& mem) {\n    ATRACE_CALL();\n status_t res;\n\n Mutex::Autolock m(mMutex);\n ssize_t offset;\n size_t size;\n    sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);\n if (heap->getHeapID() != mRecordingHeap->mHeap->getHeapID()) {\n        ALOGW(\"%s: Camera %d: Mismatched heap ID, ignoring release \"\n \"(got %x, expected %x)\", __FUNCTION__, mId,\n                heap->getHeapID(), mRecordingHeap->mHeap->getHeapID());\n return;\n }\n\n VideoNativeMetadata *payload = reinterpret_cast<VideoNativeMetadata*>(\n (uint8_t*)heap->getBase() + offset);\n\n if (payload->eType != kMetadataBufferTypeANWBuffer) {\n        ALOGE(\"%s: Camera %d: Recording frame type invalid (got %x, expected %x)\",\n                __FUNCTION__, mId, payload->eType,\n                kMetadataBufferTypeANWBuffer);\n\n         return;\n     }\n \n     size_t itemIndex;\n     for (itemIndex = 0; itemIndex < mRecordingBuffers.size(); itemIndex++) {\n const BufferItem item = mRecordingBuffers[itemIndex];\n if (item.mBuf != BufferItemConsumer::INVALID_BUFFER_SLOT &&\n                item.mGraphicBuffer->getNativeBuffer() == payload->pBuffer) {\n break;\n }\n }\n\n if (itemIndex == mRecordingBuffers.size()) {\n        ALOGE(\"%s: Camera %d: Can't find returned ANW Buffer %p in list of \"\n \"outstanding buffers\", __FUNCTION__, mId,\n                payload->pBuffer);\n return;\n }\n\n    ALOGVV(\"%s: Camera %d: Freeing returned ANW buffer %p index %d\", __FUNCTION__,\n            mId, payload->pBuffer, itemIndex);\n\n    res = mRecordingConsumer->releaseBuffer(mRecordingBuffers[itemIndex]);\n if (res != OK) {\n        ALOGE(\"%s: Camera %d: Unable to free recording frame \"\n \"(Returned ANW buffer: %p): %s (%d)\", __FUNCTION__,\n                mId, payload->pBuffer, strerror(-res), res);\n return;\n }\n    mRecordingBuffers.replaceAt(itemIndex);\n\n    mRecordingHeapFree++;\n    ALOGV_IF(mRecordingHeapFree == mRecordingHeapCount,\n \"%s: Camera %d: All %d recording buffers returned\",\n            __FUNCTION__, mId, mRecordingHeapCount);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8996, "func": "vmxnet3_get_next_rx_descr(VMXNET3State *s, bool is_head,\n                          struct Vmxnet3_RxDesc *descr_buf,\n                          uint32_t *descr_idx,\n                          uint32_t *ridx)\n{\n    if (is_head || !s->rx_packets_compound) {\n        return vmxnet3_get_next_head_rx_descr(s, descr_buf, descr_idx, ridx);\n    } else {\n        return vmxnet3_get_next_body_rx_descr(s, descr_buf, descr_idx, ridx);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187754, "func": "get_control(png_const_structrp png_ptr)\n{\n\n   struct control *control = png_voidcast(struct control*,\n       png_get_error_ptr(png_ptr));\n    return &control->file;\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 188008, "func": " long vorbis_book_decodev_add(codebook *book,ogg_int32_t *a,\n\t\t\t     oggpack_buffer *b,int n,int point){\n   if(book->used_entries>0){\n     ogg_int32_t *v = book->dec_buf;\n     int i,j;\n\n\n     if (!v) return -1;\n     for(i=0;i<n;){\n       if(decode_map(book,b,v,point))return -1;\n      for (j=0;j<book->dim;j++)\n\ta[i++]+=v[j];\n     }\n   }\n   return 0;\n }\n", "target": 1, "flaw_line_index": "2,11,12"}
{"idx": 188504, "func": " int main(int argc, char **argv) {\n   FILE *infile = NULL;\n  vpx_codec_ctx_t codec = {0};\n  vpx_codec_enc_cfg_t cfg = {0};\n   int frame_count = 0;\n  vpx_image_t raw = {0};\n   vpx_codec_err_t res;\n  VpxVideoInfo info = {0};\n   VpxVideoWriter *writer = NULL;\n   const VpxInterface *encoder = NULL;\n   const int fps = 2;        \n   const double bits_per_pixel_per_frame = 0.067;\n \n   exec_name = argv[0];\n   if (argc != 6)\n     die(\"Invalid number of arguments\");\n \n  encoder = get_vpx_encoder_by_name(argv[1]);\n  if (!encoder)\n    die(\"Unsupported codec.\");\n \n   info.codec_fourcc = encoder->fourcc;\n   info.frame_width = strtol(argv[2], NULL, 0);\n   info.frame_height = strtol(argv[3], NULL, 0);\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n\n if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n (info.frame_width % 2) != 0 ||\n (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n }\n\n if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n\n     die(\"Failed to allocate image.\");\n   }\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n \n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n  cfg.rc_target_bitrate = (unsigned int)(bits_per_pixel_per_frame * cfg.g_w *\n                                         cfg.g_h * fps / 1000);\n  cfg.g_lag_in_frames = 0;\n\n  writer = vpx_video_writer_open(argv[5], kContainerIVF, &info);\n if (!writer)\n    die(\"Failed to open %s for writing.\", argv[5]);\n\n\n   if (!(infile = fopen(argv[4], \"rb\")))\n     die(\"Failed to open %s for reading.\", argv[4]);\n \n  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n     die_codec(&codec, \"Failed to initialize encoder\");\n \n   while (vpx_img_read(&raw, infile)) {\n     ++frame_count;\n \n if (frame_count == 22 && encoder->fourcc == VP8_FOURCC) {\n      set_roi_map(&cfg, &codec);\n } else if (frame_count == 33) {\n      set_active_map(&cfg, &codec);\n } else if (frame_count == 44) {\n      unset_active_map(&cfg, &codec);\n }\n\n \n     encode_frame(&codec, &raw, frame_count, writer);\n   }\n  encode_frame(&codec, NULL, -1, writer);\n   printf(\"\\n\");\n   fclose(infile);\n   printf(\"Processed %d frames.\\n\", frame_count);\n\n  vpx_img_free(&raw);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_writer_close(writer);\n\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "3,4,6,8,18,19,20,41,43,63,80"}
{"idx": 9217, "func": "EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)\n{\n    return &vq->guest_notifier;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8355, "func": "static uint64_t mptsas_diag_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    MPTSASState *s = opaque;\n    trace_mptsas_diag_read(s, addr, 0);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8390, "func": "static void mptsas_update_interrupt(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    uint32_t state = s->intr_status & ~(s->intr_mask | MPI_HIS_IOP_DOORBELL_STATUS);\n\n    if (msi_enabled(pci)) {\n        if (state) {\n            trace_mptsas_irq_msi(s);\n            msi_notify(pci, 0);\n        }\n    }\n\n    trace_mptsas_irq_intx(s, !!state);\n    pci_set_irq(pci, !!state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8933, "func": "void vrend_set_constants(struct vrend_context *ctx,\n                         uint32_t shader,\n                         uint32_t index,\n                         uint32_t num_constant,\n                         float *data)\n{\n   struct vrend_constants *consts;\n   int i;\n\n   consts = &ctx->sub->consts[shader];\n   ctx->sub->const_dirty[shader] = true;\n\n   consts->consts = realloc(consts->consts, num_constant * sizeof(float));\n   if (!consts->consts)\n      return;\n\n   consts->num_consts = num_constant;\n   for (i = 0; i < num_constant; i++)\n      consts->consts[i] = ((unsigned int *)data)[i];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8450, "func": "pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n{\n    int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n    uint32_t req_ring_size, cmp_ring_size;\n    m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n\n    req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n    cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n    txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    rxr_len_log2 = pvscsi_log2(cmp_ring_size - 1);\n\n    m->txr_len_mask = MASK(txr_len_log2);\n    m->rxr_len_mask = MASK(rxr_len_log2);\n\n    m->consumed_ptr = 0;\n    m->filled_cmp_ptr = 0;\n\n    for (i = 0; i < ri->reqRingNumPages; i++) {\n        m->req_ring_pages_pa[i] = ri->reqRingPPNs[i] << VMW_PAGE_SHIFT;\n    }\n\n    for (i = 0; i < ri->cmpRingNumPages; i++) {\n        m->cmp_ring_pages_pa[i] = ri->cmpRingPPNs[i] << VMW_PAGE_SHIFT;\n    }\n\n    RS_SET_FIELD(m, reqProdIdx, 0);\n    RS_SET_FIELD(m, reqConsIdx, 0);\n    RS_SET_FIELD(m, reqNumEntriesLog2, txr_len_log2);\n\n    RS_SET_FIELD(m, cmpProdIdx, 0);\n    RS_SET_FIELD(m, cmpConsIdx, 0);\n    RS_SET_FIELD(m, cmpNumEntriesLog2, rxr_len_log2);\n\n    trace_pvscsi_ring_init_data(txr_len_log2, rxr_len_log2);\n\n    smp_wmb();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188577, "func": " virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fdct4x4_ref;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188093, "func": "void silk_NLSF_stabilize(\n          opus_int16            *NLSF_Q15, \n const opus_int16            *NDeltaMin_Q15, \n const opus_int              L                   \n)\n{\n    opus_int   i, I=0, k, loops;\n    opus_int16 center_freq_Q15;\n    opus_int32 diff_Q15, min_diff_Q15, min_center_Q15, max_center_Q15;\n\n    silk_assert( NDeltaMin_Q15[L] >= 1 );\n\n for( loops = 0; loops < MAX_LOOPS; loops++ ) {\n        min_diff_Q15 = NLSF_Q15[0] - NDeltaMin_Q15[0];\n        I = 0;\n for( i = 1; i <= L-1; i++ ) {\n            diff_Q15 = NLSF_Q15[i] - ( NLSF_Q15[i-1] + NDeltaMin_Q15[i] );\n if( diff_Q15 < min_diff_Q15 ) {\n                min_diff_Q15 = diff_Q15;\n                I = i;\n }\n }\n        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );\n if( diff_Q15 < min_diff_Q15 ) {\n            min_diff_Q15 = diff_Q15;\n            I = L;\n }\n\n if( min_diff_Q15 >= 0 ) {\n return;\n }\n\n if( I == 0 ) {\n            NLSF_Q15[0] = NDeltaMin_Q15[0];\n\n } else if( I == L) {\n            NLSF_Q15[L-1] = ( 1 << 15 ) - NDeltaMin_Q15[L];\n\n } else {\n            min_center_Q15 = 0;\n for( k = 0; k < I; k++ ) {\n                min_center_Q15 += NDeltaMin_Q15[k];\n }\n            min_center_Q15 += silk_RSHIFT( NDeltaMin_Q15[I], 1 );\n\n            max_center_Q15 = 1 << 15;\n for( k = L; k > I; k-- ) {\n                max_center_Q15 -= NDeltaMin_Q15[k];\n }\n            max_center_Q15 -= silk_RSHIFT( NDeltaMin_Q15[I], 1 );\n\n            center_freq_Q15 = (opus_int16)silk_LIMIT_32( silk_RSHIFT_ROUND( (opus_int32)NLSF_Q15[I-1] + (opus_int32)NLSF_Q15[I], 1 ),\n                min_center_Q15, max_center_Q15 );\n            NLSF_Q15[I-1] = center_freq_Q15 - silk_RSHIFT( NDeltaMin_Q15[I], 1 );\n            NLSF_Q15[I] = NLSF_Q15[I-1] + NDeltaMin_Q15[I];\n }\n }\n\n if( loops == MAX_LOOPS )\n {\n        silk_insertion_sort_increasing_all_values_int16( &NLSF_Q15[0], L );\n\n        NLSF_Q15[0] = silk_max_int( NLSF_Q15[0], NDeltaMin_Q15[0] );\n\n \n         for( i = 1; i < L; i++ )\n            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], NLSF_Q15[i-1] + NDeltaMin_Q15[i] );\n \n         NLSF_Q15[L-1] = silk_min_int( NLSF_Q15[L-1], (1<<15) - NDeltaMin_Q15[L] );\n\n for( i = L-2; i >= 0; i-- )\n            NLSF_Q15[i] = silk_min_int( NLSF_Q15[i], NLSF_Q15[i+1] - NDeltaMin_Q15[i+1] );\n }\n}\n", "target": 1, "flaw_line_index": "67"}
{"idx": 9174, "func": "void *qemu_get_virtqueue_element(QEMUFile *f, size_t sz)\n{\n    VirtQueueElement *elem;\n    VirtQueueElementOld data;\n    int i;\n\n    qemu_get_buffer(f, (uint8_t *)&data, sizeof(VirtQueueElementOld));\n\n    elem = virtqueue_alloc_element(sz, data.out_num, data.in_num);\n    elem->index = data.index;\n\n    for (i = 0; i < elem->in_num; i++) {\n        elem->in_addr[i] = data.in_addr[i];\n    }\n\n    for (i = 0; i < elem->out_num; i++) {\n        elem->out_addr[i] = data.out_addr[i];\n    }\n\n    for (i = 0; i < elem->in_num; i++) {\n        elem->in_sg[i].iov_base = 0;\n        elem->in_sg[i].iov_len = data.in_sg[i].iov_len;\n    }\n\n    for (i = 0; i < elem->out_num; i++) {\n        elem->out_sg[i].iov_base = 0;\n        elem->out_sg[i].iov_len = data.out_sg[i].iov_len;\n    }\n\n    virtqueue_map(elem);\n    return elem;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188038, "func": " static void copyMono24(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned \n) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i] >> 8;\n }\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8661, "func": "size_t mptsas_config_phy_1(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_phy_addr_get(s, address);\n\n    if (i < 0) {\n        trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);\n        return i;\n    }\n\n    (void) mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n    trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);\n\n    return MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,\n                                  \"*l*l*l*l*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8547, "func": "static void ssh2_pkt_queue(Ssh ssh, struct Packet *pkt)\n{\n    assert(ssh->queueing);\n\n    if (ssh->queuelen >= ssh->queuesize) {\n\tssh->queuesize = ssh->queuelen + 32;\n\tssh->queue = sresize(ssh->queue, ssh->queuesize, struct Packet *);\n    }\n\n    ssh->queue[ssh->queuelen++] = pkt;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9035, "func": "static void vmxnet3_put_ring_to_file(QEMUFile *f, Vmxnet3Ring *r)\n{\n    qemu_put_be64(f, r->pa);\n    qemu_put_be32(f, r->size);\n    qemu_put_be32(f, r->cell_size);\n    qemu_put_be32(f, r->next);\n    qemu_put_byte(f, r->gen);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187349, "func": "xsltForEach(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,\n\t    xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemForEachPtr comp = (xsltStyleItemForEachPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    int i;\n    xmlXPathObjectPtr res = NULL;\n    xmlNodePtr cur, curInst;\n    xmlNodeSetPtr list = NULL;\n    xmlNodeSetPtr oldList;\n    int oldXPProximityPosition, oldXPContextSize;\n    xmlNodePtr oldContextNode;\n    xsltTemplatePtr oldCurTemplRule;\n    xmlDocPtr oldXPDoc;\n    xsltDocumentPtr oldDocInfo;\n    xmlXPathContextPtr xpctxt;\n\n    if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL)) {\n\txsltGenericError(xsltGenericErrorContext,\n\t    \"xsltForEach(): Bad arguments.\\n\");\n\treturn;\n    }\n\n    if (comp == NULL) {\n        xsltTransformError(ctxt, NULL, inst,\n\t    \"Internal error in xsltForEach(): \"\n\t    \"The XSLT 'for-each' instruction was not compiled.\\n\");\n        return;\n    }\n    if ((comp->select == NULL) || (comp->comp == NULL)) {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"Internal error in xsltForEach(): \"\n\t    \"The selecting expression of the XSLT 'for-each' \"\n\t    \"instruction was not compiled correctly.\\n\");\n\treturn;\n    }\n    xpctxt = ctxt->xpathCtxt;\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,\n\t \"xsltForEach: select %s\\n\", comp->select));\n#endif\n\n    oldDocInfo = ctxt->document;\n    oldList = ctxt->nodeList;\n    oldContextNode = ctxt->node;\n    oldCurTemplRule = ctxt->currentTemplateRule;\n    ctxt->currentTemplateRule = NULL;\n\n     oldXPDoc = xpctxt->doc;\n     oldXPProximityPosition = xpctxt->proximityPosition;\n     oldXPContextSize = xpctxt->contextSize;\n    xpctxt->node = contextNode;\n#ifdef XSLT_REFACTORED\n    if (comp->inScopeNs != NULL) {\n\txpctxt->namespaces = comp->inScopeNs->list;\n\txpctxt->nsNr = comp->inScopeNs->xpathNumber;\n    } else {\n\txpctxt->namespaces = NULL;\n\txpctxt->nsNr = 0;\n    }\n#else\n    xpctxt->namespaces = comp->nsList;\n    xpctxt->nsNr = comp->nsNr;\n#endif\n \n    res = xmlXPathCompiledEval(comp->comp, ctxt->xpathCtxt);\n \n     if (res != NULL) {\n \tif (res->type == XPATH_NODESET)\n\t    list = res->nodesetval;\n\telse {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\"The 'select' expression does not evaluate to a node set.\\n\");\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"xsltForEach: select didn't evaluate to a node list\\n\"));\n#endif\n\t    goto error;\n\t}\n    } else {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"Failed to evaluate the 'select' expression.\\n\");\n\tctxt->state = XSLT_STATE_STOPPED;\n\tgoto error;\n    }\n\n    if ((list == NULL) || (list->nodeNr <= 0))\n\tgoto exit;\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,\n \t\"xsltForEach: select evaluates to %d nodes\\n\", list->nodeNr));\n #endif\n \n    xpctxt->contextSize = oldXPContextSize;\n    xpctxt->proximityPosition = oldXPProximityPosition;\n    xpctxt->node = contextNode;\n    ctxt->nodeList = list;\n    curInst = inst->children;\n    if (IS_XSLT_ELEM(curInst) && IS_XSLT_NAME(curInst, \"sort\")) {\n\tint nbsorts = 0;\n\txmlNodePtr sorts[XSLT_MAX_SORT];\n\n\tsorts[nbsorts++] = curInst;\n\n#ifdef WITH_DEBUGGER\n\tif (xslDebugStatus != XSLT_DEBUG_NONE)\n\t    xslHandleDebugger(curInst, contextNode, NULL, ctxt);\n#endif\n\n\tcurInst = curInst->next;\n\twhile (IS_XSLT_ELEM(curInst) && IS_XSLT_NAME(curInst, \"sort\")) {\n\t    if (nbsorts >= XSLT_MAX_SORT) {\n\t\txsltTransformError(ctxt, NULL, curInst,\n\t\t    \"The number of xsl:sort instructions exceeds the \"\n\t\t    \"maximum (%d) allowed by this processor.\\n\",\n\t\t    XSLT_MAX_SORT);\n\t\tgoto error;\n\t    } else {\n\t\tsorts[nbsorts++] = curInst;\n\t    }\n\n#ifdef WITH_DEBUGGER\n\t    if (xslDebugStatus != XSLT_DEBUG_NONE)\n\t\txslHandleDebugger(curInst, contextNode, NULL, ctxt);\n#endif\n\t    curInst = curInst->next;\n\t}\n\txsltDoSortFunction(ctxt, sorts, nbsorts);\n    }\n    xpctxt->contextSize = list->nodeNr;\n    for (i = 0; i < list->nodeNr; i++) {\n\tcur = list->nodeTab[i];\n\tctxt->node = cur;\n\tif ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n\t    xpctxt->doc = cur->doc;\n\n\txpctxt->proximityPosition = i + 1;\n\n\txsltApplySequenceConstructor(ctxt, cur, curInst, NULL);\n    }\n\nexit:\nerror:\n    if (res != NULL)\n\txmlXPathFreeObject(res);\n    ctxt->document = oldDocInfo;\n    ctxt->nodeList = oldList;\n    ctxt->node = oldContextNode;\n    ctxt->currentTemplateRule = oldCurTemplRule;\n\n    xpctxt->doc = oldXPDoc;\n    xpctxt->contextSize = oldXPContextSize;\n    xpctxt->proximityPosition = oldXPProximityPosition;\n}\n", "target": 1, "flaw_line_index": "55,55,56,57,58,59,60,61,62,63,64,65,66,67,68,70,99,99,100,101,102"}
{"idx": 8485, "func": "UINT CSoundFile::GetSampleName(UINT nSample,LPSTR s) const\n{\n        char sztmp[40] = \"\";      \n\tmemcpy(sztmp, m_szNames[nSample],32);\n\tsztmp[31] = 0;\n\tif (s) strcpy(s, sztmp);\n\treturn strlen(sztmp);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187858, "func": "long SeekHead::Parse() {\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = m_start;\n const long long stop = m_start + m_size;\n\n\n int entry_count = 0;\n int void_element_count = 0;\n\n while (pos < stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (id == 0x0DBB) \n ++entry_count;\n else if (id == 0x6C) \n\n       ++void_element_count;\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   m_entries = new (std::nothrow) Entry[entry_count];\n \n if (m_entries == NULL)\n return -1;\n\n  m_void_elements = new (std::nothrow) VoidElement[void_element_count];\n\n if (m_void_elements == NULL)\n return -1;\n\n\n Entry* pEntry = m_entries;\n VoidElement* pVoidElement = m_void_elements;\n\n  pos = m_start;\n\n while (pos < stop) {\n const long long idpos = pos;\n\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (id == 0x0DBB) { \n if (ParseEntry(pReader, pos, size, pEntry)) {\n Entry& e = *pEntry++;\n\n        e.element_start = idpos;\n        e.element_size = (pos + size) - idpos;\n }\n } else if (id == 0x6C) { \n VoidElement& e = *pVoidElement++;\n\n      e.element_start = idpos;\n      e.element_size = (pos + size) - idpos;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);\n   assert(count_ >= 0);\n  assert(count_ <= entry_count);\n\n  m_entry_count = static_cast<int>(count_);\n\n  count_ = ptrdiff_t(pVoidElement - m_void_elements);\n  assert(count_ >= 0);\n  assert(count_ <= void_element_count);\n\n  m_void_element_count = static_cast<int>(count_);\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "27,30,75,78"}
{"idx": 187562, "func": "MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSource(NULL)\n\n {\n     ALOGV(\"constructor\");\n \n    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n     if (service != NULL) {\n         mMediaRecorder = service->createMediaRecorder(opPackageName);\n     }\n if (mMediaRecorder != NULL) {\n        mCurrentState = MEDIA_RECORDER_IDLE;\n }\n\n\n    doCleanUp();\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187790, "func": "status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {\n Mutex::Autolock autoLock(mDRMLock);\n status_t err;\n if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {\n return err;\n }\n\n size_t len = (*buffer)->range_length();\n\n char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();\n\n DrmBuffer encryptedDrmBuffer(src, len);\n DrmBuffer decryptedDrmBuffer;\n    decryptedDrmBuffer.length = len;\n    decryptedDrmBuffer.data = new char[len];\n DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;\n\n if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,\n &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {\n\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n            decryptedDrmBuffer.data = NULL;\n }\n\n return err;\n }\n    CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);\n\n const char *mime;\n    CHECK(getFormat()->findCString(kKeyMIMEType, &mime));\n\n if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {\n uint8_t *dstData = (uint8_t*)src;\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n        len = decryptedDrmBuffer.length;\n while (srcOffset < len) {\n            CHECK(srcOffset + mNALLengthSize <= len);\n size_t nalLength = 0;\n const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);\n\n switch (mNALLengthSize) {\n case 1:\n                    nalLength = *data;\n break;\n case 2:\n                    nalLength = U16_AT(data);\n break;\n case 3:\n                    nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);\n break;\n case 4:\n                    nalLength = U32_AT(data);\n break;\n default:\n                    CHECK(!\"Should not be here.\");\n break;\n }\n\n            srcOffset += mNALLengthSize;\n\n size_t end = srcOffset + nalLength;\n if (end > len || end < srcOffset) {\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n                    decryptedDrmBuffer.data = NULL;\n }\n\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                 continue;\n             }\n \n            CHECK(dstOffset + 4 <= (*buffer)->size());\n \n             dstData[dstOffset++] = 0;\n             dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 1;\n            memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);\n            srcOffset += nalLength;\n            dstOffset += nalLength;\n }\n\n        CHECK_EQ(srcOffset, len);\n (*buffer)->set_range((*buffer)->range_offset(), dstOffset);\n\n } else {\n        memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);\n (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);\n }\n\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n        decryptedDrmBuffer.data = NULL;\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "79"}
{"idx": 188591, "func": "   void CheckSADs() {\n     unsigned int reference_sad, exp_sad[4];\n \n     SADs(exp_sad);\n    for (int block = 0; block < 4; block++) {\n      reference_sad = ReferenceSAD(UINT_MAX, block);\n \n      EXPECT_EQ(exp_sad[block], reference_sad) << \"block \" << block;\n     }\n   }\n", "target": 1, "flaw_line_index": "5,6,8"}
{"idx": 9043, "func": "vmxnet3_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    VMXNET3State *s = qemu_get_nic_opaque(nc);\n    size_t bytes_indicated;\n    uint8_t min_buf[MIN_BUF_SIZE];\n\n    if (!vmxnet3_can_receive(nc)) {\n        VMW_PKPRN(\"Cannot receive now\");\n        return -1;\n    }\n\n    if (s->peer_has_vhdr) {\n        net_rx_pkt_set_vhdr(s->rx_pkt, (struct virtio_net_hdr *)buf);\n        buf += sizeof(struct virtio_net_hdr);\n        size -= sizeof(struct virtio_net_hdr);\n    }\n\n    if (size < sizeof(min_buf)) {\n        memcpy(min_buf, buf, size);\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n        buf = min_buf;\n        size = sizeof(min_buf);\n    }\n\n    net_rx_pkt_set_packet_type(s->rx_pkt,\n        get_eth_packet_type(PKT_GET_ETH_HDR(buf)));\n\n    if (vmxnet3_rx_filter_may_indicate(s, buf, size)) {\n        net_rx_pkt_set_protocols(s->rx_pkt, buf, size);\n        vmxnet3_rx_need_csum_calculate(s->rx_pkt, buf, size);\n        net_rx_pkt_attach_data(s->rx_pkt, buf, size, s->rx_vlan_stripping);\n        bytes_indicated = vmxnet3_indicate_packet(s) ? size : -1;\n        if (bytes_indicated < size) {\n            VMW_PKPRN(\"RX: %zu of %zu bytes indicated\", bytes_indicated, size);\n        }\n    } else {\n        VMW_PKPRN(\"Packet dropped by RX filter\");\n        bytes_indicated = size;\n    }\n\n    assert(size > 0);\n    assert(bytes_indicated != 0);\n    return bytes_indicated;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188012, "func": "int vorbis_book_unpack(oggpack_buffer *opb,codebook *s){\n char *lengthlist=NULL;\n int           quantvals=0;\n long          i,j;\n int           maptype;\n\n  memset(s,0,sizeof(*s));\n\n if(oggpack_read(opb,24)!=0x564342)goto _eofout;\n\n  s->dim=oggpack_read(opb,16);\n  s->dec_buf=_ogg_malloc(sizeof(ogg_int32_t)*s->dim);\n if (s->dec_buf == NULL)\n goto _errout;\n  s->entries=oggpack_read(opb,24);\n if(s->entries<=0)goto _eofout;\n if(s->dim<=0)goto _eofout;\n if(_ilog(s->dim)+_ilog(s->entries)>24)goto _eofout; \n if (s->dim > INT_MAX/s->entries) goto _eofout;\n\n switch((int)oggpack_read(opb,1)){\n case 0:\n    lengthlist=(char *)calloc(s->entries, sizeof(*lengthlist));\n if(!lengthlist) goto _eofout;\n\n if(oggpack_read(opb,1)){\n\n \n       for(i=0;i<s->entries;i++){\n\tif(oggpack_read(opb,1)){\n\t  long num=oggpack_read(opb,5);\n\t  if(num==-1)goto _eofout;\n\t  lengthlist[i]=(char)(num+1);\n\t  s->used_entries++;\n\t  if(num+1>s->dec_maxlength)s->dec_maxlength=num+1;\n\t}else\n\t  lengthlist[i]=0;\n       }\n     }else{\n       s->used_entries=s->entries;\n       for(i=0;i<s->entries;i++){\n\tlong num=oggpack_read(opb,5);\n\tif(num==-1)goto _eofout;\n\tlengthlist[i]=(char)(num+1);\n\tif(num+1>s->dec_maxlength)s->dec_maxlength=num+1;\n       }\n     }\n \n break;\n case 1:\n {\n long length=oggpack_read(opb,5)+1;\n\n      s->used_entries=s->entries;\n      lengthlist=(char *)calloc(s->entries, sizeof(*lengthlist));\n\n       if (!lengthlist) goto _eofout;\n \n       for(i=0;i<s->entries;){\n\tlong num=oggpack_read(opb,_ilog(s->entries-i));\n\tif(num<0)goto _eofout;\n\tfor(j=0;j<num && i<s->entries;j++,i++)\n\t  lengthlist[i]=(char)length;\n\ts->dec_maxlength=length;\n\tlength++;\n       }\n     }\n     break;\n default:\n goto _eofout;\n }\n\n\n\n if((maptype=oggpack_read(opb,4))>0){\n    s->q_min=_float32_unpack(oggpack_read(opb,32),&s->q_minp);\n    s->q_del=_float32_unpack(oggpack_read(opb,32),&s->q_delp);\n    s->q_bits=oggpack_read(opb,4)+1;\n    s->q_seq=oggpack_read(opb,1);\n\n    s->q_del>>=s->q_bits;\n    s->q_delp+=s->q_bits;\n }\n\n switch(maptype){\n case 0:\n\n\n    s->dec_nodeb=_determine_node_bytes(s->used_entries,_ilog(s->entries)/8+1);\n    s->dec_leafw=_determine_leaf_words(s->dec_nodeb,_ilog(s->entries)/8+1);\n    s->dec_type=0;\n\n if(_make_decode_table(s,lengthlist,quantvals,opb,maptype)) goto _errout;\n break;\n\n case 1:\n\n    quantvals=_book_maptype1_quantvals(s);\n\n {\n long total1=(s->q_bits*s->dim+8)/8; \n if (s->dim > (INT_MAX-8)/s->q_bits) goto _eofout;\n long total2=(_ilog(quantvals-1)*s->dim+8)/8+(s->q_bits+7)/8;\n\n \n \n       if(total1<=4 && total1<=total2){\n \n\ts->q_val=calloc(sizeof(ogg_uint16_t), quantvals);\n\tif (!s->q_val) goto _eofout;\n\tfor(i=0;i<quantvals;i++)\n\t  ((ogg_uint16_t *)s->q_val)[i]=(ogg_uint16_t)oggpack_read(opb,s->q_bits);\n \n\tif(oggpack_eop(opb)){\n\t  goto _eofout;\n\t}\n \n\ts->dec_type=1;\n\ts->dec_nodeb=_determine_node_bytes(s->used_entries,\n\t\t\t\t\t   (s->q_bits*s->dim+8)/8);\n\ts->dec_leafw=_determine_leaf_words(s->dec_nodeb,\n\t\t\t\t\t   (s->q_bits*s->dim+8)/8);\n\tif(_make_decode_table(s,lengthlist,quantvals,opb,maptype)){\n\t  goto _errout;\n\t}\n \n\tfree(s->q_val);\n\ts->q_val=0;\n \n       }else{\n \n\tif(s->q_bits<=8){\n\t  s->q_val=_ogg_malloc(quantvals);\n\t  if (!s->q_val) goto _eofout;\n\t  for(i=0;i<quantvals;i++)\n\t    ((unsigned char *)s->q_val)[i]=(unsigned char)oggpack_read(opb,s->q_bits);\n\t}else{\n\t  s->q_val=_ogg_malloc(quantvals*2);\n\t  if (!s->q_val) goto _eofout;\n\t  for(i=0;i<quantvals;i++)\n\t    ((ogg_uint16_t *)s->q_val)[i]=(ogg_uint16_t)oggpack_read(opb,s->q_bits);\n\t}\n \n\tif(oggpack_eop(opb))goto _eofout;\n \n\ts->q_pack=_ilog(quantvals-1);\n\ts->dec_type=2;\n\ts->dec_nodeb=_determine_node_bytes(s->used_entries,\n\t\t\t\t\t   (_ilog(quantvals-1)*s->dim+8)/8);\n\ts->dec_leafw=_determine_leaf_words(s->dec_nodeb,\n\t\t\t\t\t   (_ilog(quantvals-1)*s->dim+8)/8);\n\tif(_make_decode_table(s,lengthlist,quantvals,opb,maptype))goto _errout;\n \n       }\n     }\n break;\n case 2:\n\n    quantvals=s->entries*s->dim;\n\n if( (s->q_bits*s->dim+8)/8 <=4){ \n\n      s->dec_type=1;\n      s->dec_nodeb=_determine_node_bytes(s->used_entries,(s->q_bits*s->dim+8)/8);\n      s->dec_leafw=_determine_leaf_words(s->dec_nodeb,(s->q_bits*s->dim+8)/8);\n if(_make_decode_table(s,lengthlist,quantvals,opb,maptype))goto _errout;\n\n }else{\n\n      s->dec_type=3;\n      s->dec_nodeb=_determine_node_bytes(s->used_entries,_ilog(s->used_entries-1)/8+1);\n      s->dec_leafw=_determine_leaf_words(s->dec_nodeb,_ilog(s->used_entries-1)/8+1);\n if(_make_decode_table(s,lengthlist,quantvals,opb,maptype))goto _errout;\n\n      s->q_pack=(s->q_bits+7)/8*s->dim;\n\n       s->q_val=_ogg_malloc(s->q_pack*s->used_entries);\n \n       if(s->q_bits<=8){\n\tfor(i=0;i<s->used_entries*s->dim;i++)\n\t  ((unsigned char *)(s->q_val))[i]=(unsigned char)oggpack_read(opb,s->q_bits);\n       }else{\n\tfor(i=0;i<s->used_entries*s->dim;i++)\n\t  ((ogg_uint16_t *)(s->q_val))[i]=(ogg_uint16_t)oggpack_read(opb,s->q_bits);\n       }\n     }\n     break;\n default:\n goto _errout;\n }\n\n if (s->dec_nodeb==1)\n if (s->dec_leafw == 1)\n      s->dec_method = 0;\n else\n      s->dec_method = 1;\n else if (s->dec_nodeb==2)\n if (s->dec_leafw == 1)\n      s->dec_method = 2;\n else\n      s->dec_method = 3;\n else\n    s->dec_method = 4;\n\n if(oggpack_eop(opb))goto _eofout;\n\n  free(lengthlist);\n return 0;\n _errout:\n _eofout:\n  vorbis_book_clear(s);\n  free(lengthlist);\n  free(s->q_val);\n return -1;\n}\n", "target": 1, "flaw_line_index": "30,31,32,33,34,35,36,37,42,43,44,45,60,61,62,63,64,65,107,108,109,110,111,112,114,115,116,118,119,120,121,122,123,124,125,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,144,146,147,148,149,150,151,152,180,181,183,184"}
{"idx": 8321, "func": "XFreeModifiermap(XModifierKeymap *map)\n{\n    if (map) {\n        Xfree(map->modifiermap);\n\tXfree(map);\n    }\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188191, "func": " bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {\n    return x >= frameLeft && x <= frameRight\n            && y >= frameTop && y <= frameBottom;\n }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8328, "func": "static void mcf_fec_write_bd(mcf_fec_bd *bd, uint32_t addr)\n{\n    mcf_fec_bd tmp;\n    tmp.flags = cpu_to_be16(bd->flags);\n    tmp.length = cpu_to_be16(bd->length);\n    tmp.data = cpu_to_be32(bd->data);\n    cpu_physical_memory_write(addr, &tmp, sizeof(tmp));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188515, "func": " int main(int argc, char **argv) {\n   FILE *infile = NULL;\n  VpxVideoWriter *writer = NULL;\n   vpx_codec_ctx_t codec;\n   vpx_codec_enc_cfg_t cfg;\n   vpx_image_t raw;\n   vpx_codec_err_t res;\n  vpx_fixed_buf_t stats = {0};\n  VpxVideoInfo info = {0};\n   const VpxInterface *encoder = NULL;\n  int pass;\n   const int fps = 30;        \n   const int bitrate = 200;   \n   const char *const codec_arg = argv[1];\n const char *const width_arg = argv[2];\n const char *const height_arg = argv[3];\n const char *const infile_arg = argv[4];\n const char *const outfile_arg = argv[5];\n  exec_name = argv[0];\n\n if (argc != 6)\n    die(\"Invalid number of arguments.\");\n\n  encoder = get_vpx_encoder_by_name(codec_arg);\n\n   if (!encoder)\n     die(\"Unsupported codec.\");\n \n  info.codec_fourcc = encoder->fourcc;\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n  info.frame_width = strtol(width_arg, NULL, 0);\n  info.frame_height = strtol(height_arg, NULL, 0);\n \n  if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n      (info.frame_width % 2) != 0 ||\n      (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n  }\n \n  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n    die(\"Failed to allocate image\", info.frame_width, info.frame_height);\n  }\n \n  writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);\n  if (!writer)\n    die(\"Failed to open %s for writing\", outfile_arg);\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n   cfg.rc_target_bitrate = bitrate;\n \n  for (pass = 0; pass < 2; ++pass) {\n    int frame_count = 0;\n \n    if (pass == 0) {\n      cfg.g_pass = VPX_RC_FIRST_PASS;\n    } else {\n      cfg.g_pass = VPX_RC_LAST_PASS;\n      cfg.rc_twopass_stats_in = stats;\n    }\n \n    if (!(infile = fopen(infile_arg, \"rb\")))\n      die(\"Failed to open %s for reading\", infile_arg);\n    if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n      die_codec(&codec, \"Failed to initialize encoder\");\n    while (vpx_img_read(&raw, infile)) {\n      ++frame_count;\n      if (pass == 0) {\n        get_frame_stats(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n                        &stats);\n      } else {\n        encode_frame(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n                     writer);\n      }\n    }\n    if (pass == 0) {\n      get_frame_stats(&codec, NULL, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n                      &stats);\n    } else {\n      printf(\"\\n\");\n    }\n    fclose(infile);\n    printf(\"Pass %d complete. Processed %d frames.\\n\", pass + 1, frame_count);\n    if (vpx_codec_destroy(&codec))\n      die_codec(&codec, \"Failed to destroy codec.\");\n  }\n  vpx_img_free(&raw);\n   free(stats.buf);\n \n  vpx_video_writer_close(writer);\n \n   return EXIT_SUCCESS;\n }\n", "target": 1, "flaw_line_index": "3,8,9,11,29,30,31,32,33,35,36,37,38,39,40,42,43,44,45,47,48,49,51,52,56,57,58,59,62,63,65,66,67,68,69,70,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,100"}
{"idx": 8480, "func": "UINT CSoundFile::GetNumChannels() const\n{\n\tUINT n = 0;\n\tfor (UINT i=0; i<m_nChannels; i++) if (ChnSettings[i].nVolume) n++;\n\treturn n;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8836, "func": "int vrend_create_surface(struct vrend_context *ctx,\n                         uint32_t handle,\n                         uint32_t res_handle, uint32_t format,\n                         uint32_t val0, uint32_t val1)\n{\n   struct vrend_surface *surf;\n   struct vrend_resource *res;\n   uint32_t ret_handle;\n\n   if (format >= PIPE_FORMAT_COUNT) {\n      return EINVAL;\n   }\n\n   res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n   if (!res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n      return EINVAL;\n   }\n\n   surf = CALLOC_STRUCT(vrend_surface);\n   if (!surf)\n      return ENOMEM;\n\n   surf->res_handle = res_handle;\n   surf->format = format;\n   surf->val0 = val0;\n   surf->val1 = val1;\n   pipe_reference_init(&surf->reference, 1);\n\n   vrend_resource_reference(&surf->texture, res);\n\n   ret_handle = vrend_renderer_object_insert(ctx, surf, sizeof(*surf), handle, VIRGL_OBJECT_SURFACE);\n   if (ret_handle == 0) {\n      FREE(surf);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188142, "func": "xmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n if (RAW != '%')\n return;\n    NEXT;\n    name = xmlParseName(ctxt);\n if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n \"xmlParsePEReference: no name\\n\");\n return;\n }\n if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n return;\n }\n\n    NEXT;\n\n    ctxt->nbentities++;\n\n if ((ctxt->sax != NULL) &&\n (ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n if (ctxt->instate == XML_PARSER_EOF)\n return;\n if (entity == NULL) {\n if ((ctxt->standalone == 1) ||\n ((ctxt->hasExternalSubset == 0) &&\n (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n } else {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n }\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n } else {\n if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n } else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n\t     * c.f. http:\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n if (xmlPushInput(ctxt, input) < 0)\n return;\n if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n (IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n if (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t    xmlHaltParser(ctxt);\n return;\n }\n }\n }\n }\n    ctxt->hasPErefs = 1;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188123, "func": "static void btif_av_event_free_data(btif_sm_event_t event, void* p_data) {\n switch (event) {\n case BTA_AV_META_MSG_EVT: {\n      tBTA_AV* av = (tBTA_AV*)p_data;\n      osi_free_and_reset((void**)&av->meta_msg.p_data);\n\n if (av->meta_msg.p_msg) {\n\n         if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_VENDOR) {\n           osi_free(av->meta_msg.p_msg->vendor.p_vendor_data);\n         }\n         osi_free_and_reset((void**)&av->meta_msg.p_msg);\n       }\n     } break;\n\n default:\n break;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188557, "func": "void DecoderTest::RunLoop(CompressedVideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = {0};\n  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n   ASSERT_TRUE(decoder != NULL);\n \n  for (video->Begin(); video->cxdata(); video->Next()) {\n     PreDecodeFrameHook(*video, decoder);\n    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),\n                                                   video->frame_size());\n    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n \n     DxDataIterator dec_iter = decoder->GetDxData();\n     const vpx_image_t *img = NULL;\n\n\n     while ((img = dec_iter.Next()))\n       DecompressedFrameHook(*img, video->frame_number());\n   }\n   delete decoder;\n }\n", "target": 1, "flaw_line_index": "2,3,7,9,10,11"}
{"idx": 188543, "func": "  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9164, "func": "static void blitter_set_dst_dim(struct vrend_blitter_ctx *blit_ctx,\n                                unsigned width, unsigned height)\n{\n   blit_ctx->dst_width = width;\n   blit_ctx->dst_height = height;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187907, "func": "status_t IPCThreadState::executeCommand(int32_t cmd)\n{\n BBinder* obj;\n RefBase::weakref_type* refs;\n status_t result = NO_ERROR;\n \n switch ((uint32_t)cmd) {\n case BR_ERROR:\n        result = mIn.readInt32();\n break;\n \n case BR_OK:\n break;\n \n case BR_ACQUIRE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        ALOG_ASSERT(refs->refBase() == obj,\n \"BR_ACQUIRE: object %p does not match cookie %p (expected %p)\",\n                   refs, obj, refs->refBase());\n        obj->incStrong(mProcess.get());\n        IF_LOG_REMOTEREFS() {\n            LOG_REMOTEREFS(\"BR_ACQUIRE from driver on %p\", obj);\n            obj->printRefs();\n }\n        mOut.writeInt32(BC_ACQUIRE_DONE);\n        mOut.writePointer((uintptr_t)refs);\n        mOut.writePointer((uintptr_t)obj);\n break;\n \n case BR_RELEASE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        ALOG_ASSERT(refs->refBase() == obj,\n \"BR_RELEASE: object %p does not match cookie %p (expected %p)\",\n                   refs, obj, refs->refBase());\n        IF_LOG_REMOTEREFS() {\n            LOG_REMOTEREFS(\"BR_RELEASE from driver on %p\", obj);\n            obj->printRefs();\n }\n        mPendingStrongDerefs.push(obj);\n break;\n \n case BR_INCREFS:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        refs->incWeak(mProcess.get());\n        mOut.writeInt32(BC_INCREFS_DONE);\n        mOut.writePointer((uintptr_t)refs);\n        mOut.writePointer((uintptr_t)obj);\n break;\n \n case BR_DECREFS:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        mPendingWeakDerefs.push(refs);\n break;\n \n case BR_ATTEMPT_ACQUIRE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n \n {\n const bool success = refs->attemptIncStrong(mProcess.get());\n            ALOG_ASSERT(success && refs->refBase() == obj,\n \"BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)\",\n                       refs, obj, refs->refBase());\n \n            mOut.writeInt32(BC_ACQUIRE_RESULT);\n            mOut.writeInt32((int32_t)success);\n }\n break;\n \n case BR_TRANSACTION:\n {\n            binder_transaction_data tr;\n            result = mIn.read(&tr, sizeof(tr));\n            ALOG_ASSERT(result == NO_ERROR,\n \"Not enough command data for brTRANSACTION\");\n if (result != NO_ERROR) break;\n \n Parcel buffer;\n            buffer.ipcSetDataReference(\n reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),\n                tr.data_size,\n reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),\n                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);\n \n const pid_t origPid = mCallingPid;\n const uid_t origUid = mCallingUid;\n const int32_t origStrictModePolicy = mStrictModePolicy;\n const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;\n\n            mCallingPid = tr.sender_pid;\n            mCallingUid = tr.sender_euid;\n            mLastTransactionBinderFlags = tr.flags;\n\n int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);\n if (gDisableBackgroundScheduling) {\n if (curPrio > ANDROID_PRIORITY_NORMAL) {\n                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);\n }\n } else {\n if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {\n                    set_sched_policy(mMyThreadId, SP_BACKGROUND);\n }\n }\n\n\n Parcel reply;\n status_t error;\n            IF_LOG_TRANSACTIONS() {\n TextOutput::Bundle _b(alog);\n                alog << \"BR_TRANSACTION thr \" << (void*)pthread_self()\n << \" / obj \" << tr.target.ptr << \" / code \"\n << TypeCode(tr.code) << \": \" << indent << buffer\n << dedent << endl\n << \"Data addr = \"\n << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)\n << \", offsets addr=\"\n\n                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;\n             }\n             if (tr.target.ptr) {\n                sp<BBinder> b((BBinder*)tr.cookie);\n                error = b->transact(tr.code, buffer, &reply, tr.flags);\n \n             } else {\n                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);\n }\n\n \n if ((tr.flags & TF_ONE_WAY) == 0) {\n                LOG_ONEWAY(\"Sending reply to %d!\", mCallingPid);\n if (error < NO_ERROR) reply.setError(error);\n                sendReply(reply, 0);\n } else {\n                LOG_ONEWAY(\"NOT sending reply to %d!\", mCallingPid);\n }\n \n            mCallingPid = origPid;\n            mCallingUid = origUid;\n            mStrictModePolicy = origStrictModePolicy;\n            mLastTransactionBinderFlags = origTransactionBinderFlags;\n\n            IF_LOG_TRANSACTIONS() {\n TextOutput::Bundle _b(alog);\n                alog << \"BC_REPLY thr \" << (void*)pthread_self() << \" / obj \"\n << tr.target.ptr << \": \" << indent << reply << dedent << endl;\n }\n \n }\n break;\n \n case BR_DEAD_BINDER:\n {\n BpBinder *proxy = (BpBinder*)mIn.readPointer();\n            proxy->sendObituary();\n            mOut.writeInt32(BC_DEAD_BINDER_DONE);\n            mOut.writePointer((uintptr_t)proxy);\n } break;\n \n case BR_CLEAR_DEATH_NOTIFICATION_DONE:\n {\n BpBinder *proxy = (BpBinder*)mIn.readPointer();\n            proxy->getWeakRefs()->decWeak(proxy);\n } break;\n \n case BR_FINISHED:\n        result = TIMED_OUT;\n break;\n \n case BR_NOOP:\n break;\n \n case BR_SPAWN_LOOPER:\n        mProcess->spawnPooledThread(false);\n break;\n \n default:\n        printf(\"*** BAD COMMAND %d received from Binder driver\\n\", cmd);\n        result = UNKNOWN_ERROR;\n break;\n }\n\n if (result != NO_ERROR) {\n        mLastError = result;\n }\n \n return result;\n}\n", "target": 1, "flaw_line_index": "141,142"}
{"idx": 188523, "func": " virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n ::libvpx_test::Encoder *encoder) {\n\n     if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n     } else if (video->frame() == 3) {\n      vpx_active_map_t map = {0};\n       uint8_t active_map[9 * 13] = {\n         1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n         1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1,\n 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1,\n 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1,\n 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1,\n 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,\n };\n map.cols = (kWidth + 15) / 16;\n map.rows = (kHeight + 15) / 16;\n      ASSERT_EQ(map.cols, 13u);\n      ASSERT_EQ(map.rows, 9u);\n\n       map.active_map = active_map;\n       encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n     } else if (video->frame() == 15) {\n      vpx_active_map_t map = {0};\n       map.cols = (kWidth + 15) / 16;\n       map.rows = (kHeight + 15) / 16;\n       map.active_map = NULL;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n }\n }\n", "target": 1, "flaw_line_index": "7,27"}
{"idx": 188185, "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(prev_slice_err == 1)\n {\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n\n                    if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                        j = i;\n             {\n                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                         ps_dec->ps_cur_slice->u2_frame_num,\n                         &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n {\n            num_entries *= 2;\n }\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n\n     }\n \n     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n     if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n \n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187632, "func": " static void gamma_composition_test(png_modifier *pm,\n   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,\n   PNG_CONST int palette_number,\n   PNG_CONST int interlace_type, PNG_CONST double file_gamma,\n   PNG_CONST double screen_gamma,\n   PNG_CONST int use_input_precision, PNG_CONST int do_background,\n   PNG_CONST int expand_16)\n {\n    size_t pos = 0;\n    png_const_charp base;\n double bg;\n char name[128];\n   png_color_16 background;\n\n switch (do_background)\n {\n default:\n         base = \"\";\n         bg = 4; \n break;\n case PNG_BACKGROUND_GAMMA_SCREEN:\n         base = \" bckg(Screen):\";\n         bg = 1/screen_gamma;\n break;\n case PNG_BACKGROUND_GAMMA_FILE:\n         base = \" bckg(File):\";\n         bg = file_gamma;\n break;\n case PNG_BACKGROUND_GAMMA_UNIQUE:\n         base = \" bckg(Unique):\";\n         bg = (file_gamma + screen_gamma) / 3;\n break;\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n case ALPHA_MODE_OFFSET + PNG_ALPHA_PNG:\n         base = \" alpha(PNG)\";\n         bg = 4; \n break;\n case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:\n         base = \" alpha(Porter-Duff)\";\n         bg = 4; \n break;\n case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:\n         base = \" alpha(Optimized)\";\n         bg = 4; \n break;\n case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:\n         base = \" alpha(Broken)\";\n         bg = 4; \n break;\n#endif\n }\n\n if (expand_16 || bit_depth == 16)\n {\n      png_uint_32 r = random_32();\n\n      background.red = (png_uint_16)r;\n      background.green = (png_uint_16)(r >> 16);\n      r = random_32();\n      background.blue = (png_uint_16)r;\n      background.gray = (png_uint_16)(r >> 16);\n\n#     if DIGITIZE\n if (expand_16 && (do_background == PNG_BACKGROUND_GAMMA_UNIQUE ||\n                           do_background == PNG_BACKGROUND_GAMMA_FILE) &&\n            fabs(bg*screen_gamma-1) > PNG_GAMMA_THRESHOLD)\n {\n            background.red = (png_uint_16)((background.red >> 8) * 257);\n            background.green = (png_uint_16)((background.green >> 8) * 257);\n            background.blue = (png_uint_16)((background.blue >> 8) * 257);\n            background.gray = (png_uint_16)((background.gray >> 8) * 257);\n }\n#     endif\n }\n\n else \n {\n      png_uint_32 r = random_32();\n\n      background.red = (png_byte)r;\n      background.green = (png_byte)(r >> 8);\n      background.blue = (png_byte)(r >> 16);\n      background.gray = (png_byte)(r >> 24);\n\n    }\n \n    background.index = 193; \n    if (!(colour_type & PNG_COLOR_MASK_COLOR))\n    {\n      background.red = background.green = background.blue = background.gray;\n }\n\n   pos = safecat(name, sizeof name, pos, \"gamma \");\n   pos = safecatd(name, sizeof name, pos, file_gamma, 3);\n   pos = safecat(name, sizeof name, pos, \"->\");\n   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);\n\n   pos = safecat(name, sizeof name, pos, base);\n if (do_background < ALPHA_MODE_OFFSET)\n {\n      pos = safecat(name, sizeof name, pos, \"(\");\n if (colour_type & PNG_COLOR_MASK_COLOR)\n {\n         pos = safecatn(name, sizeof name, pos, background.red);\n         pos = safecat(name, sizeof name, pos, \",\");\n         pos = safecatn(name, sizeof name, pos, background.green);\n         pos = safecat(name, sizeof name, pos, \",\");\n         pos = safecatn(name, sizeof name, pos, background.blue);\n }\n else\n         pos = safecatn(name, sizeof name, pos, background.gray);\n      pos = safecat(name, sizeof name, pos, \")^\");\n      pos = safecatd(name, sizeof name, pos, bg, 3);\n }\n\n   gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,\n      file_gamma, screen_gamma, 0\n, 0, name, use_input_precision,\n 0\n, expand_16, do_background, &background, bg);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 187828, "func": "long Cluster::CreateBlockGroup(long long start_offset, long long size,\n long long discard_padding) {\n  assert(m_entries);\n  assert(m_entries_size > 0);\n  assert(m_entries_count >= 0);\n  assert(m_entries_count < m_entries_size);\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = start_offset;\n const long long stop = start_offset + size;\n\n\n long long prev = 1; \n long long next = 0; \n long long duration = -1; \n\n long long bpos = -1;\n long long bsize = -1;\n\n \n   while (pos < stop) {\n     long len;\n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  \n    assert((pos + len) <= stop);\n \n     pos += len;  \n \n const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0); \n    assert((pos + len) <= stop);\n\n    pos += len; \n\n if (id == 0x21) { \n if (bpos < 0) { \n        bpos = pos;\n\n         bsize = size;\n       }\n     } else if (id == 0x1B) {  \n      assert(size <= 8);\n \n       duration = UnserializeUInt(pReader, pos, size);\n      assert(duration >= 0);  \n     } else if (id == 0x7B) {  \n      assert(size <= 8);\n       const long size_ = static_cast<long>(size);\n \n       long long time;\n\n long status = UnserializeInt(pReader, pos, size_, time);\n      assert(status == 0);\n if (status != 0)\n return -1;\n\n if (time <= 0) \n        prev = time;\n else \n        next = time;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n  assert(bpos >= 0);\n   assert(bsize >= 0);\n \n   const long idx = m_entries_count;\n\n BlockEntry** const ppEntry = m_entries + idx;\n BlockEntry*& pEntry = *ppEntry;\n\n  pEntry = new (std::nothrow)\n BlockGroup(this, idx, bpos, bsize, prev, next, duration, discard_padding);\n\n if (pEntry == NULL)\n return -1; \n\n BlockGroup* const p = static_cast<BlockGroup*>(pEntry);\n\n const long status = p->Parse();\n\n if (status == 0) { \n ++m_entries_count;\n return 0;\n }\n\n delete pEntry;\n  pEntry = 0;\n\n return status;\n}\n", "target": 1, "flaw_line_index": "29,30,31,48,51,53,71,74,75"}
{"idx": 187366, "func": "static int Downmix_Command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n downmix_module_t *pDwmModule = (downmix_module_t *) self;\n downmix_object_t *pDownmixer;\n int retsize;\n\n if (pDwmModule == NULL || pDwmModule->context.state == DOWNMIX_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n    pDownmixer = (downmix_object_t*) &pDwmModule->context;\n\n    ALOGV(\"Downmix_Command command %\" PRIu32 \" cmdSize %\" PRIu32, cmdCode, cmdSize);\n\n \n     switch (cmdCode) {\n     case EFFECT_CMD_INIT:\n        if (pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         *(int *) pReplyData = Downmix_Init(pDwmModule);\n break;\n\n \n     case EFFECT_CMD_SET_CONFIG:\n         if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n                || pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         *(int *) pReplyData = Downmix_Configure(pDwmModule,\n (effect_config_t *)pCmdData, false);\n break;\n\n case EFFECT_CMD_RESET:\n Downmix_Reset(pDownmixer, false);\n break;\n\n case EFFECT_CMD_GET_PARAM:\n\n         ALOGV(\"Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %\" PRIu32 \", pReplyData: %p\",\n                 pCmdData, *replySize, pReplyData);\n         if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||\n                pReplyData == NULL ||\n                 *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {\n             return -EINVAL;\n         }\n effect_param_t *rep = (effect_param_t *) pReplyData;\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(int32_t));\n        ALOGV(\"Downmix_Command EFFECT_CMD_GET_PARAM param %\" PRId32 \", replySize %\" PRIu32,\n *(int32_t *)rep->data, rep->vsize);\n        rep->status = Downmix_getParameter(pDownmixer, *(int32_t *)rep->data, &rep->vsize,\n                rep->data + sizeof(int32_t));\n *replySize = sizeof(effect_param_t) + sizeof(int32_t) + rep->vsize;\n break;\n\n case EFFECT_CMD_SET_PARAM:\n\n         ALOGV(\"Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %\" PRIu32\n                 \", pReplyData %p\", cmdSize, pCmdData, *replySize, pReplyData);\n         if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))\n                || pReplyData == NULL || *replySize != (int)sizeof(int32_t)) {\n             return -EINVAL;\n         }\n         effect_param_t *cmd = (effect_param_t *) pCmdData;\n *(int *)pReplyData = Downmix_setParameter(pDownmixer, *(int32_t *)cmd->data,\n                cmd->vsize, cmd->data + sizeof(int32_t));\n break;\n\n case EFFECT_CMD_SET_PARAM_DEFERRED:\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_PARAM_DEFERRED not supported, FIXME\");\n break;\n\n case EFFECT_CMD_SET_PARAM_COMMIT:\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_PARAM_COMMIT not supported, FIXME\");\n\n         break;\n \n     case EFFECT_CMD_ENABLE:\n        if (pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pDownmixer->state = DOWNMIX_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n *(int *)pReplyData = 0;\n\n         break;\n \n     case EFFECT_CMD_DISABLE:\n        if (pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pDownmixer->state = DOWNMIX_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {\n return -EINVAL;\n }\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_DEVICE: 0x%08\" PRIx32, *(uint32_t *)pCmdData);\n break;\n\n case EFFECT_CMD_SET_VOLUME: {\n if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t) * 2) {\n return -EINVAL;\n }\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_VOLUME not supported, FIXME\");\n float left = (float)(*(uint32_t *)pCmdData) / (1 << 24);\n float right = (float)(*((uint32_t *)pCmdData + 1)) / (1 << 24);\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_VOLUME: left %f, right %f \", left, right);\n break;\n }\n\n case EFFECT_CMD_SET_AUDIO_MODE:\n if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {\n return -EINVAL;\n }\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_AUDIO_MODE: %\" PRIu32, *(uint32_t *)pCmdData);\n break;\n\n case EFFECT_CMD_SET_CONFIG_REVERSE:\n case EFFECT_CMD_SET_INPUT_DEVICE:\n break;\n\n default:\n        ALOGW(\"Downmix_Command invalid command %\" PRIu32, cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "19,28,44,62,82,95"}
{"idx": 187631, "func": "gamma_component_validate(PNG_CONST char *name, PNG_CONST validate_info *vi,\n    PNG_CONST unsigned int id, PNG_CONST unsigned int od,\n    PNG_CONST double alpha \n,\n    PNG_CONST double background \n)\n {\n   PNG_CONST unsigned int isbit = id >> vi->isbit_shift;\n   PNG_CONST unsigned int sbit_max = vi->sbit_max;\n   PNG_CONST unsigned int outmax = vi->outmax;\n   PNG_CONST int do_background = vi->do_background;\n \n    double i;\n \n   i = isbit; i /= sbit_max;\n\n if (alpha == 1 \n || !do_background\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n || do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_PNG\n#endif\n || (alpha < 0 \n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n && do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN\n#endif\n ))\n {\n double encoded_sample = i;\n double encoded_error;\n\n if (alpha >= 0 && vi->gamma_correction > 0)\n         encoded_sample = pow(encoded_sample, vi->gamma_correction);\n      encoded_sample *= outmax;\n\n      encoded_error = fabs(od-encoded_sample);\n\n if (encoded_error > vi->dp->maxerrout)\n         vi->dp->maxerrout = encoded_error;\n\n if (encoded_error < vi->maxout_total && encoded_error < vi->outlog)\n return i;\n }\n\n {\n double input_sample = i; \n double output, error, encoded_sample, encoded_error;\n double es_lo, es_hi;\n int compose = 0; \n int output_is_encoded; \n int log_max_error = 1; \n      png_const_charp pass = 0; \n\n if (alpha >= 0)\n {\n int tcompose;\n\n if (vi->file_inverse > 0)\n            input_sample = pow(input_sample, vi->file_inverse);\n\n         tcompose = 0;\n         input_sample = gamma_component_compose(do_background, input_sample,\n            alpha, background, &tcompose);\n\n if (tcompose)\n            compose = 1;\n }\n\n      output = od;\n      output /= outmax;\n\n      output_is_encoded = vi->screen_gamma > 0;\n\n if (alpha < 0) \n {\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n if (do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN)\n#endif\n {\n            output_is_encoded = 0;\n            log_max_error = 0;\n }\n }\n\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n else \n {\n if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&\n            alpha < 1) \n {\n if (alpha > 0) log_max_error = 0;\n            output_is_encoded = 0;\n }\n }\n#endif\n\n if (output_is_encoded)\n         output = pow(output, vi->screen_gamma);\n\n      encoded_sample = input_sample;\n if (output_is_encoded)\n         encoded_sample = pow(encoded_sample, vi->screen_inverse);\n      encoded_sample *= outmax;\n\n      encoded_error = fabs(od-encoded_sample);\n\n if (log_max_error && encoded_error > vi->dp->maxerrout)\n         vi->dp->maxerrout = encoded_error;\n\n if (encoded_error < vi->maxout_total)\n {\n if (encoded_error < vi->outlog)\n return i;\n\n         pass = \"less than maxout:\\n\";\n }\n\n\n      error = fabs(input_sample-output);\n\n if (log_max_error && error > vi->dp->maxerrabs)\n         vi->dp->maxerrabs = error;\n\n if (log_max_error && input_sample > .5)\n {\n double percentage_error = error/input_sample;\n if (percentage_error > vi->dp->maxerrpc)\n            vi->dp->maxerrpc = percentage_error;\n }\n\n {\n double tmp = input_sample * vi->maxpc;\n if (tmp < vi->maxabs) tmp = vi->maxabs;\n if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc;\n\n         es_lo = encoded_sample - vi->maxout;\n\n if (es_lo > 0 && input_sample-tmp > 0)\n {\n double low_value = input_sample-tmp;\n if (output_is_encoded)\n               low_value = pow(low_value, vi->screen_inverse);\n            low_value *= outmax;\n if (low_value < es_lo) es_lo = low_value;\n\n            es_lo = ceil(es_lo / vi->outquant - .5) * vi->outquant;\n }\n\n else\n            es_lo = 0;\n\n         es_hi = encoded_sample + vi->maxout;\n\n if (es_hi < outmax && input_sample+tmp < 1)\n {\n double high_value = input_sample+tmp;\n if (output_is_encoded)\n               high_value = pow(high_value, vi->screen_inverse);\n            high_value *= outmax;\n if (high_value > es_hi) es_hi = high_value;\n\n            es_hi = floor(es_hi / vi->outquant + .5) * vi->outquant;\n }\n\n else\n            es_hi = outmax;\n }\n\n if (od >= es_lo && od <= es_hi)\n {\n if (encoded_error < vi->outlog)\n return i;\n\n if (pass == 0)\n            pass = \"within digitization limits:\\n\";\n }\n\n {\n double is_lo, is_hi;\n\n if (pass == 0 && vi->use_input_precision && vi->dp->sbit)\n {\n#           if PNG_LIBPNG_VER < 10700\n#              define SBIT_ERROR .5\n#           else\n#              define SBIT_ERROR 1.\n#           endif\n double tmp = (isbit - SBIT_ERROR)/sbit_max;\n\n if (tmp <= 0)\n               tmp = 0;\n\n else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)\n               tmp = pow(tmp, vi->file_inverse);\n\n            tmp = gamma_component_compose(do_background, tmp, alpha, background,\n               NULL);\n\n if (output_is_encoded && tmp > 0 && tmp < 1)\n               tmp = pow(tmp, vi->screen_inverse);\n\n            is_lo = ceil(outmax * tmp - vi->maxout_total);\n\n if (is_lo < 0)\n               is_lo = 0;\n\n            tmp = (isbit + SBIT_ERROR)/sbit_max;\n\n if (tmp >= 1)\n               tmp = 1;\n\n else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)\n               tmp = pow(tmp, vi->file_inverse);\n\n            tmp = gamma_component_compose(do_background, tmp, alpha, background,\n               NULL);\n\n if (output_is_encoded && tmp > 0 && tmp < 1)\n               tmp = pow(tmp, vi->screen_inverse);\n\n            is_hi = floor(outmax * tmp + vi->maxout_total);\n\n if (is_hi > outmax)\n               is_hi = outmax;\n\n if (!(od < is_lo || od > is_hi))\n {\n if (encoded_error < vi->outlog)\n return i;\n\n               pass = \"within input precision limits:\\n\";\n }\n\n#           ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED\n#              if PNG_LIBPNG_VER < 10504\n if (pass == 0 && alpha < 0 && vi->scale16 && vi->sbit > 8 &&\n                     vi->sbit + vi->isbit_shift == 16)\n {\n                     tmp = ((id >> 8) - .5)/255;\n\n if (tmp > 0)\n {\n                        is_lo = ceil(outmax * tmp - vi->maxout_total);\n if (is_lo < 0) is_lo = 0;\n }\n\n else\n                        is_lo = 0;\n\n                     tmp = ((id >> 8) + .5)/255;\n\n if (tmp < 1)\n {\n                        is_hi = floor(outmax * tmp + vi->maxout_total);\n if (is_hi > outmax) is_hi = outmax;\n }\n\n else\n                        is_hi = outmax;\n\n if (!(od < is_lo || od > is_hi))\n {\n if (encoded_error < vi->outlog)\n return i;\n\n                        pass = \"within 8 bit limits:\\n\";\n }\n }\n#              endif\n#           endif\n }\n else \n            is_lo = es_lo, is_hi = es_hi;\n\n {\n size_t pos = 0;\n int precision = (outmax >= 1000 ? 6 : 3);\n int use_input=1, use_background=0, do_compose=0;\n char msg[256];\n\n if (pass != 0)\n               pos = safecat(msg, sizeof msg, pos, \"\\n\\t\");\n\n switch (do_background)\n {\n#           ifdef PNG_READ_BACKGROUND_SUPPORTED\n case PNG_BACKGROUND_GAMMA_SCREEN:\n case PNG_BACKGROUND_GAMMA_FILE:\n case PNG_BACKGROUND_GAMMA_UNIQUE:\n                  use_background = (alpha >= 0 && alpha < 1);\n#           endif\n#           ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:\n case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:\n case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:\n#           endif \n               do_compose = (alpha > 0 && alpha < 1);\n               use_input = (alpha != 0);\n break;\n\n default:\n break;\n }\n\n if (compose != do_compose)\n               png_error(vi->pp, \"internal error (compose)\");\n\n            pos = safecat(msg, sizeof msg, pos, name);\n            pos = safecat(msg, sizeof msg, pos, \"(\");\n            pos = safecatn(msg, sizeof msg, pos, id);\n if (use_input || pass != 0\n)\n {\n if (isbit != id)\n {\n                  pos = safecat(msg, sizeof msg, pos, \", sbit(\");\n                  pos = safecatn(msg, sizeof msg, pos, vi->sbit);\n                  pos = safecat(msg, sizeof msg, pos, \"): \");\n                  pos = safecatn(msg, sizeof msg, pos, isbit);\n }\n               pos = safecat(msg, sizeof msg, pos, \"/\");\n               pos = safecatn(msg, sizeof msg, pos, vi->sbit_max);\n }\n            pos = safecat(msg, sizeof msg, pos, \")\");\n\n if (compose || pass != 0)\n {\n if (use_input || pass != 0)\n {\n if (vi->file_inverse > 0)\n {\n                     pos = safecat(msg, sizeof msg, pos, \"^\");\n                     pos = safecatd(msg, sizeof msg, pos, vi->file_inverse, 2);\n }\n\n else\n                     pos = safecat(msg, sizeof msg, pos, \"[linear]\");\n\n                  pos = safecat(msg, sizeof msg, pos, \"*(alpha)\");\n                  pos = safecatd(msg, sizeof msg, pos, alpha, precision);\n }\n\n if (use_background)\n {\n                  pos = safecat(msg, sizeof msg, pos, use_input ? \"+\" : \" \");\n                  pos = safecat(msg, sizeof msg, pos, \"(background)\");\n                  pos = safecatd(msg, sizeof msg, pos, background, precision);\n                  pos = safecat(msg, sizeof msg, pos, \"*\");\n                  pos = safecatd(msg, sizeof msg, pos, 1-alpha, precision);\n }\n }\n\n if (compose || alpha < 0 || pass != 0)\n {\n               pos = safecat(msg, sizeof msg, pos,\n                  pass != 0 ? \" =\\n\\t\" : \" = \");\n               pos = safecatd(msg, sizeof msg, pos, input_sample, precision);\n               pos = safecat(msg, sizeof msg, pos, \" (libpng: \");\n               pos = safecatd(msg, sizeof msg, pos, output, precision);\n               pos = safecat(msg, sizeof msg, pos, \")\");\n\n if (output_is_encoded)\n {\n                  pos = safecat(msg, sizeof msg, pos, \" ^\");\n                  pos = safecatd(msg, sizeof msg, pos, vi->screen_inverse, 2);\n                  pos = safecat(msg, sizeof msg, pos, \"(to screen) =\");\n }\n\n else\n                  pos = safecat(msg, sizeof msg, pos, \" [screen is linear] =\");\n }\n\n if ((!compose && alpha >= 0) || pass != 0)\n {\n if (pass != 0) \n                  pos = safecat(msg, sizeof msg, pos, \"\\n\\t[overall:\");\n\n if (vi->gamma_correction > 0)\n {\n                  pos = safecat(msg, sizeof msg, pos, \" ^\");\n                  pos = safecatd(msg, sizeof msg, pos, vi->gamma_correction, 2);\n                  pos = safecat(msg, sizeof msg, pos, \"(gamma correction) =\");\n }\n\n else\n                  pos = safecat(msg, sizeof msg, pos,\n \" [no gamma correction] =\");\n\n if (pass != 0)\n                  pos = safecat(msg, sizeof msg, pos, \"]\");\n }\n\n            pos = safecat(msg, sizeof msg, pos, pass != 0 ? \"\\n\\t\" : \" \");\n            pos = safecatd(msg, sizeof msg, pos, is_lo, 1);\n            pos = safecat(msg, sizeof msg, pos, \" < \");\n            pos = safecatd(msg, sizeof msg, pos, encoded_sample, 1);\n            pos = safecat(msg, sizeof msg, pos, \" (libpng: \");\n            pos = safecatn(msg, sizeof msg, pos, od);\n            pos = safecat(msg, sizeof msg, pos, \")\");\n            pos = safecat(msg, sizeof msg, pos, \"/\");\n            pos = safecatn(msg, sizeof msg, pos, outmax);\n            pos = safecat(msg, sizeof msg, pos, \" < \");\n            pos = safecatd(msg, sizeof msg, pos, is_hi, 1);\n\n if (pass == 0) \n {\n#              ifdef PNG_WARNINGS_SUPPORTED\n                  png_warning(vi->pp, msg);\n#              else\n                  store_warning(vi->pp, msg);\n#              endif\n }\n\n else \n               store_verbose(&vi->dp->pm->this, vi->pp, pass, msg);\n }\n }\n }\n\n return i;\n}\n", "target": 1, "flaw_line_index": "2,4,6,8,9,10,11"}
{"idx": 8841, "func": "static void vrend_destroy_resource_object(void *obj_ptr)\n{\n   struct vrend_resource *res = obj_ptr;\n\n   if (pipe_reference(&res->base.reference, NULL))\n       vrend_renderer_resource_destroy(res, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8456, "func": "pvscsi_send_msg(PVSCSIState *s, SCSIDevice *dev, uint32_t msg_type)\n{\n    if (s->msg_ring_info_valid && pvscsi_ring_msg_has_room(&s->rings)) {\n        PVSCSIMsgDescDevStatusChanged msg = {0};\n\n        msg.type = msg_type;\n        msg.bus = dev->channel;\n        msg.target = dev->id;\n        msg.lun[1] = dev->lun;\n\n        pvscsi_msg_ring_put(s, (PVSCSIRingMsgDesc *)&msg);\n        pvscsi_ring_flush_msg(&s->rings);\n        pvscsi_raise_message_interrupt(s);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8989, "func": "static uint64_t vmxnet3_get_command_status(VMXNET3State *s)\n{\n    uint64_t ret;\n\n    switch (s->last_command) {\n    case VMXNET3_CMD_ACTIVATE_DEV:\n        ret = (s->device_active) ? 0 : 1;\n        VMW_CFPRN(\"Device active: %\" PRIx64, ret);\n        break;\n\n    case VMXNET3_CMD_RESET_DEV:\n    case VMXNET3_CMD_QUIESCE_DEV:\n    case VMXNET3_CMD_GET_QUEUE_STATUS:\n    case VMXNET3_CMD_GET_DEV_EXTRA_INFO:\n        ret = 0;\n        break;\n\n    case VMXNET3_CMD_GET_LINK:\n        ret = s->link_status_and_speed;\n        VMW_CFPRN(\"Link and speed: %\" PRIx64, ret);\n        break;\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n        ret = vmxnet3_get_mac_low(&s->perm_mac);\n        break;\n\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n        ret = vmxnet3_get_mac_high(&s->perm_mac);\n        break;\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n        ret = vmxnet3_get_interrupt_config(s);\n        break;\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n        ret = VMXNET3_DISABLE_ADAPTIVE_RING;\n        break;\n\n    case VMXNET3_CMD_GET_DID_LO:\n        ret = PCI_DEVICE_ID_VMWARE_VMXNET3;\n        break;\n\n    case VMXNET3_CMD_GET_DID_HI:\n        ret = VMXNET3_DEVICE_REVISION;\n        break;\n\n    default:\n        VMW_WRPRN(\"Received request for unknown command: %x\", s->last_command);\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187343, "func": "xsltChoose(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,\n\t   xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED)\n{\n    xmlNodePtr cur;\n\n    if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL))\n\treturn;\n\n    cur = inst->children;\n    if (cur == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"xsl:choose: The instruction has no content.\\n\");\n\treturn;\n    }\n\n#ifdef XSLT_REFACTORED\n#else\n    if ((! IS_XSLT_ELEM(cur)) || (! IS_XSLT_NAME(cur, \"when\"))) {\n\txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:choose: xsl:when expected first\\n\");\n\treturn;\n    }\n#endif\n \n     {\n \tint testRes = 0, res = 0;\n\txmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n\txmlDocPtr oldXPContextDoc = xpctxt->doc;\n\tint oldXPProximityPosition = xpctxt->proximityPosition;\n\tint oldXPContextSize = xpctxt->contextSize;\n\txmlNsPtr *oldXPNamespaces = xpctxt->namespaces;\n\tint oldXPNsNr = xpctxt->nsNr;\n \n #ifdef XSLT_REFACTORED\n \txsltStyleItemWhenPtr wcomp = NULL;\n#else\n\txsltStylePreCompPtr wcomp = NULL;\n#endif\n\n\twhile (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"when\")) {\n\t    wcomp = cur->psvi;\n\n\t    if ((wcomp == NULL) || (wcomp->test == NULL) ||\n\t\t(wcomp->comp == NULL))\n\t    {\n\t\txsltTransformError(ctxt, NULL, cur,\n\t\t    \"Internal error in xsltChoose(): \"\n\t\t    \"The XSLT 'when' instruction was not compiled.\\n\");\n\t\tgoto error;\n\t    }\n\n\n#ifdef WITH_DEBUGGER\n\t    if (xslDebugStatus != XSLT_DEBUG_NONE) {\n\t\txslHandleDebugger(cur, contextNode, NULL, ctxt);\n\t    }\n#endif\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n \t\t\"xsltChoose: test %s\\n\", wcomp->test));\n #endif\n \n\t    xpctxt->node = contextNode;\n\t    xpctxt->doc = oldXPContextDoc;\n\t    xpctxt->proximityPosition = oldXPProximityPosition;\n\t    xpctxt->contextSize = oldXPContextSize;\n#ifdef XSLT_REFACTORED\n\t    if (wcomp->inScopeNs != NULL) {\n\t\txpctxt->namespaces = wcomp->inScopeNs->list;\n\t\txpctxt->nsNr = wcomp->inScopeNs->xpathNumber;\n\t    } else {\n\t\txpctxt->namespaces = NULL;\n\t\txpctxt->nsNr = 0;\n\t    }\n#else\n\t    xpctxt->namespaces = wcomp->nsList;\n\t    xpctxt->nsNr = wcomp->nsNr;\n#endif\n #ifdef XSLT_FAST_IF\n\t    res = xmlXPathCompiledEvalToBoolean(wcomp->comp, xpctxt);\n \n \t    if (res == -1) {\n \t\tctxt->state = XSLT_STATE_STOPPED;\n\t\tgoto error;\n\t    }\n\t    testRes = (res == 1) ? 1 : 0;\n \n #else \n \n\t    res = xmlXPathCompiledEval(wcomp->comp, xpctxt);\n \n \t    if (res != NULL) {\n \t\tif (res->type != XPATH_BOOLEAN)\n\t\t    res = xmlXPathConvertBoolean(res);\n\t\tif (res->type == XPATH_BOOLEAN)\n\t\t    testRes = res->boolval;\n\t\telse {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\t    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\t\"xsltChoose: test didn't evaluate to a boolean\\n\"));\n#endif\n\t\t    goto error;\n\t\t}\n\t\txmlXPathFreeObject(res);\n\t\tres = NULL;\n\t    } else {\n\t\tctxt->state = XSLT_STATE_STOPPED;\n\t\tgoto error;\n\t    }\n\n#endif \n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"xsltChoose: test evaluate to %d\\n\", testRes));\n#endif\n\t    if (testRes)\n\t\tgoto test_is_true;\n\n\t    cur = cur->next;\n\t}\n\n\tif (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"otherwise\")) {\n\n#ifdef WITH_DEBUGGER\n\t    if (xslDebugStatus != XSLT_DEBUG_NONE)\n\t\txslHandleDebugger(cur, contextNode, NULL, ctxt);\n#endif\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"evaluating xsl:otherwise\\n\"));\n #endif\n \t    goto test_is_true;\n \t}\n\txpctxt->node = contextNode;\n\txpctxt->doc = oldXPContextDoc;\n\txpctxt->proximityPosition = oldXPProximityPosition;\n\txpctxt->contextSize = oldXPContextSize;\n\txpctxt->namespaces = oldXPNamespaces;\n\txpctxt->nsNr = oldXPNsNr;\n \tgoto exit;\n \n test_is_true:\n \n\txpctxt->node = contextNode;\n\txpctxt->doc = oldXPContextDoc;\n\txpctxt->proximityPosition = oldXPProximityPosition;\n\txpctxt->contextSize = oldXPContextSize;\n\txpctxt->namespaces = oldXPNamespaces;\n\txpctxt->nsNr = oldXPNsNr;\n \tgoto process_sequence;\n     }\n \nprocess_sequence:\n\n    xsltApplySequenceConstructor(ctxt, ctxt->node, cur->children,\n\tNULL);\n\nexit:\nerror:\n    return;\n}\n", "target": 1, "flaw_line_index": "27,28,29,30,31,32,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,80,90,136,137,138,139,140,141,146,147,148,149,150,151"}
{"idx": 188046, "func": " static void copyTrespass(\n         short * \n,\n        const int *const * \n,\n         unsigned \n,\n         unsigned \n) {\n     TRESPASS();\n}\n", "target": 1, "flaw_line_index": "5"}
{"idx": 187906, "func": "ssize_t NuPlayer::NuPlayerStreamListener::read(\n void *data, size_t size, sp<AMessage> *extra) {\n    CHECK_GT(size, 0u);\n\n    extra->clear();\n\n Mutex::Autolock autoLock(mLock);\n\n if (mEOS) {\n return 0;\n }\n\n if (mQueue.empty()) {\n        mSendDataNotification = true;\n\n return -EWOULDBLOCK;\n }\n\n QueueEntry *entry = &*mQueue.begin();\n\n if (entry->mIsCommand) {\n switch (entry->mCommand) {\n case EOS:\n {\n                mQueue.erase(mQueue.begin());\n                entry = NULL;\n\n                mEOS = true;\n return 0;\n }\n\n case DISCONTINUITY:\n {\n *extra = entry->mExtra;\n\n                mQueue.erase(mQueue.begin());\n                entry = NULL;\n\n return INFO_DISCONTINUITY;\n }\n\n default:\n                TRESPASS();\n break;\n }\n }\n\n size_t copy = entry->mSize;\n if (copy > size) {\n\n         copy = size;\n     }\n \n     memcpy(data,\n           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()\n             + entry->mOffset,\n            copy);\n \n    entry->mOffset += copy;\n    entry->mSize -= copy;\n\n if (entry->mSize == 0) {\n        mSource->onBufferAvailable(entry->mIndex);\n        mQueue.erase(mQueue.begin());\n        entry = NULL;\n }\n\n return copy;\n}\n", "target": 1, "flaw_line_index": "55"}
{"idx": 188609, "func": " void SubpelVarianceTest<SubpelVarianceFunctionType>::RefTest() {\n  for (int x = 0; x < 16; ++x) {\n    for (int y = 0; y < 16; ++y) {\n      for (int j = 0; j < block_size_; j++) {\n        src_[j] = rnd.Rand8();\n      }\n      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n        ref_[j] = rnd.Rand8();\n       }\n       unsigned int sse1, sse2;\n       unsigned int var1;\n      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,\n                                                   src_, width_, &sse1));\n      const unsigned int var2 = subpel_variance_ref(ref_, src_, log2width_,\n                                                    log2height_, x, y, &sse2);\n       EXPECT_EQ(sse1, sse2) << \"at position \" << x << \", \" << y;\n       EXPECT_EQ(var1, var2) << \"at position \" << x << \", \" << y;\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,12,13,14,15"}
{"idx": 188525, "func": "  ConvolveFunctions(convolve_fn_t h8, convolve_fn_t h8_avg,\n                    convolve_fn_t v8, convolve_fn_t v8_avg,\n                    convolve_fn_t hv8, convolve_fn_t hv8_avg)\n      : h8_(h8), v8_(v8), hv8_(hv8), h8_avg_(h8_avg), v8_avg_(v8_avg),\n        hv8_avg_(hv8_avg) {}\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 187638, "func": "image_pixel_add_alpha(image_pixel *this, PNG_CONST standard_display *display)\n {\n    if (this->colour_type == PNG_COLOR_TYPE_PALETTE)\n       image_pixel_convert_PLTE(this);\n\n if ((this->colour_type & PNG_COLOR_MASK_ALPHA) == 0)\n\n    {\n       if (this->colour_type == PNG_COLOR_TYPE_GRAY)\n       {\n         if (this->bit_depth < 8)\n            this->bit_depth = 8;\n \n          if (this->have_tRNS)\n          {\n             this->have_tRNS = 0;\n \n if (this->red == display->transparent.red)\n this->alphaf = 0;\n else\n this->alphaf = 1;\n }\n else\n this->alphaf = 1;\n\n this->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n }\n\n else if (this->colour_type == PNG_COLOR_TYPE_RGB)\n {\n if (this->have_tRNS)\n {\n this->have_tRNS = 0;\n\n if (this->red == display->transparent.red &&\n this->green == display->transparent.green &&\n this->blue == display->transparent.blue)\n\n                this->alphaf = 0;\n             else\n                this->alphaf = 1;\n            this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;\n          }\n       }\n \n this->alphae = 0;\n\n       this->alpha_sBIT = display->alpha_sBIT;\n    }\n }\n", "target": 1, "flaw_line_index": "11,12,42"}
{"idx": 9205, "func": "void virtio_init(VirtIODevice *vdev, const char *name,\n                 uint16_t device_id, size_t config_size)\n{\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n    int i;\n    int nvectors = k->query_nvectors ? k->query_nvectors(qbus->parent) : 0;\n\n    if (nvectors) {\n        vdev->vector_queues =\n            g_malloc0(sizeof(*vdev->vector_queues) * nvectors);\n    }\n\n    vdev->device_id = device_id;\n    vdev->status = 0;\n    vdev->isr = 0;\n    vdev->queue_sel = 0;\n    vdev->config_vector = VIRTIO_NO_VECTOR;\n    vdev->vq = g_malloc0(sizeof(VirtQueue) * VIRTIO_QUEUE_MAX);\n    vdev->vm_running = runstate_is_running();\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n        vdev->vq[i].vector = VIRTIO_NO_VECTOR;\n        vdev->vq[i].vdev = vdev;\n        vdev->vq[i].queue_index = i;\n    }\n\n    vdev->name = name;\n    vdev->config_len = config_size;\n    if (vdev->config_len) {\n        vdev->config = g_malloc0(config_size);\n    } else {\n        vdev->config = NULL;\n    }\n    vdev->vmstate = qemu_add_vm_change_state_handler(virtio_vmstate_change,\n                                                     vdev);\n    vdev->device_endian = virtio_default_endian();\n    vdev->use_guest_notifier_mask = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188223, "func": "OMX_ERRORTYPE SoftAVC::internalSetParameter(OMX_INDEXTYPE index, const OMX_PTR params) {\n int32_t indexFull = index;\n\n\n     switch (indexFull) {\n         case OMX_IndexParamVideoBitrate:\n         {\n            return internalSetBitrateParams(\n                    (const OMX_VIDEO_PARAM_BITRATETYPE *)params);\n         }\n \n         case OMX_IndexParamVideoAvc:\n         {\n             OMX_VIDEO_PARAM_AVCTYPE *avcType = (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcType->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mEntropyMode = 0;\n\n if (OMX_TRUE == avcType->bEntropyCodingCABAC)\n                mEntropyMode = 1;\n\n if ((avcType->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) &&\n                    avcType->nPFrames) {\n                mBframes = avcType->nBFrames / avcType->nPFrames;\n }\n\n            mIInterval = avcType->nPFrames + avcType->nBFrames;\n\n if (OMX_VIDEO_AVCLoopFilterDisable == avcType->eLoopFilterMode)\n                mDisableDeblkLevel = 4;\n\n if (avcType->nRefFrames != 1\n || avcType->bUseHadamard != OMX_TRUE\n || avcType->nRefIdx10ActiveMinus1 != 0\n || avcType->nRefIdx11ActiveMinus1 != 0\n || avcType->bWeightedPPrediction != OMX_FALSE\n || avcType->bconstIpred != OMX_FALSE\n || avcType->bDirect8x8Inference != OMX_FALSE\n || avcType->bDirectSpatialTemporal != OMX_FALSE\n || avcType->nCabacInitIdc != 0) {\n return OMX_ErrorUndefined;\n }\n\n if (OK != ConvertOmxAvcLevelToAvcSpecLevel(avcType->eLevel, &mAVCEncLevel)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": "8,9"}
{"idx": 9150, "func": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n         fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n      fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n      glDeleteProgram(prog_id);\n      return NULL;\n   }\n\n   sprog->ss[PIPE_SHADER_VERTEX] = vs;\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187696, "func": "static double outerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n if (out_depth == 2)\n return .73182-.5;\n\n if (out_depth == 4)\n return .90644-.5;\n\n if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxout16;\n\n else if (out_depth == 16)\n return pm->maxout8 * 257;\n\n else\n return pm->maxout8;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8665, "func": "size_t mptsas_config_sas_io_unit_0(MPTSASState *s, uint8_t **data, int address)\n{\n    size_t size = MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x04,\n                                         \"*w*wb*b*w\"\n                                         repl(MPTSAS_NUM_PORTS, \"*s16\"),\n                                         MPTSAS_NUM_PORTS);\n\n    if (data) {\n        size_t ofs = size - MPTSAS_NUM_PORTS * MPTSAS_CONFIG_SAS_IO_UNIT_0_SIZE;\n        int i;\n\n        for (i = 0; i < MPTSAS_NUM_PORTS; i++) {\n            int phy_handle, dev_handle;\n            SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n\n            fill(*data + ofs, MPTSAS_CONFIG_SAS_IO_UNIT_0_SIZE,\n                 \"bbbblwwl\", i, 0, 0,\n                 (dev\n                  ? MPI_SAS_IOUNIT0_RATE_3_0\n                  : MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION),\n                 (dev\n                  ? MPI_SAS_DEVICE_INFO_END_DEVICE | MPI_SAS_DEVICE_INFO_SSP_TARGET\n                  : MPI_SAS_DEVICE_INFO_NO_DEVICE),\n                 dev_handle,\n                 dev_handle,\n                 0);\n            ofs += MPTSAS_CONFIG_SAS_IO_UNIT_0_SIZE;\n        }\n        assert(ofs == size);\n    }\n    return size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187550, "func": "OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {\n     if (buffer == 0) {\n         return NULL;\n     }\n Mutex::Autolock autoLock(mBufferIDLock);\n ssize_t index = mBufferIDToBufferHeader.indexOfKey(buffer);\n if (index < 0) {\n\n         CLOGW(\"findBufferHeader: buffer %u not found\", buffer);\n         return NULL;\n     }\n    return mBufferIDToBufferHeader.valueAt(index);\n }\n", "target": 1, "flaw_line_index": "12"}
{"idx": 8727, "func": "static int check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)\n{\n    X509 *issuer = NULL;\n    EVP_PKEY *ikey = NULL;\n    int ok = 0, chnum, cnum;\n    cnum = ctx->error_depth;\n    chnum = sk_X509_num(ctx->chain) - 1;\n    if (ctx->current_issuer)\n        issuer = ctx->current_issuer;\n\n    else if (cnum < chnum)\n        issuer = sk_X509_value(ctx->chain, cnum + 1);\n    else {\n        issuer = sk_X509_value(ctx->chain, chnum);\n        if (!ctx->check_issued(ctx, issuer, issuer)) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;\n            ok = ctx->verify_cb(0, ctx);\n            if (!ok)\n                goto err;\n        }\n    }\n\n    if (issuer) {\n        if (!crl->base_crl_number) {\n            if ((issuer->ex_flags & EXFLAG_KUSAGE) &&\n                !(issuer->ex_kusage & KU_CRL_SIGN)) {\n                ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;\n                ok = ctx->verify_cb(0, ctx);\n                if (!ok)\n                    goto err;\n            }\n\n            if (!(ctx->current_crl_score & CRL_SCORE_SCOPE)) {\n                ctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;\n                ok = ctx->verify_cb(0, ctx);\n                if (!ok)\n                    goto err;\n            }\n\n            if (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH)) {\n                if (check_crl_path(ctx, ctx->current_issuer) <= 0) {\n                    ctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;\n                    ok = ctx->verify_cb(0, ctx);\n                    if (!ok)\n                        goto err;\n                }\n            }\n\n            if (crl->idp_flags & IDP_INVALID) {\n                ctx->error = X509_V_ERR_INVALID_EXTENSION;\n                ok = ctx->verify_cb(0, ctx);\n                if (!ok)\n                    goto err;\n            }\n\n        }\n\n        if (!(ctx->current_crl_score & CRL_SCORE_TIME)) {\n            ok = check_crl_time(ctx, crl, 1);\n            if (!ok)\n                goto err;\n        }\n\n        ikey = X509_get_pubkey(issuer);\n\n        if (!ikey) {\n            ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n            ok = ctx->verify_cb(0, ctx);\n            if (!ok)\n                goto err;\n        } else {\n            int rv;\n            rv = X509_CRL_check_suiteb(crl, ikey, ctx->param->flags);\n            if (rv != X509_V_OK) {\n                ctx->error = rv;\n                ok = ctx->verify_cb(0, ctx);\n                if (!ok)\n                    goto err;\n            }\n            if (X509_CRL_verify(crl, ikey) <= 0) {\n                ctx->error = X509_V_ERR_CRL_SIGNATURE_FAILURE;\n                ok = ctx->verify_cb(0, ctx);\n                if (!ok)\n                    goto err;\n            }\n        }\n    }\n\n    ok = 1;\n\n err:\n    EVP_PKEY_free(ikey);\n    return ok;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188037, "func": " static void copyMono16(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned \n) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i];\n }\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187515, "func": "UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)\n{\n int n;\n int n_read = 0;\n int fd = uipc_main.ch[ch_id].fd;\n struct pollfd pfd;\n    UNUSED(p_msg_evt);\n\n if (ch_id >= UIPC_CH_NUM)\n {\n        BTIF_TRACE_ERROR(\"UIPC_Read : invalid ch id %d\", ch_id);\n return 0;\n }\n\n if (fd == UIPC_DISCONNECTED)\n {\n        BTIF_TRACE_ERROR(\"UIPC_Read : channel %d closed\", ch_id);\n return 0;\n }\n\n\n while (n_read < (int)len)\n {\n        pfd.fd = fd;\n        pfd.events = POLLIN|POLLHUP;\n\n \n        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)\n         {\n             BTIF_TRACE_EVENT(\"poll timeout (%d ms)\", uipc_main.ch[ch_id].read_poll_tmo_ms);\n             break;\n }\n\n\n if (pfd.revents & (POLLHUP|POLLNVAL) )\n {\n            BTIF_TRACE_EVENT(\"poll : channel detached remotely\");\n            UIPC_LOCK();\n            uipc_close_locked(ch_id);\n            UIPC_UNLOCK();\n\n             return 0;\n         }\n \n        n = recv(fd, p_buf+n_read, len-n_read, 0);\n \n \n if (n == 0)\n {\n            BTIF_TRACE_EVENT(\"UIPC_Read : channel detached remotely\");\n            UIPC_LOCK();\n            uipc_close_locked(ch_id);\n            UIPC_UNLOCK();\n return 0;\n }\n\n if (n < 0)\n {\n            BTIF_TRACE_EVENT(\"UIPC_Read : read failed (%s)\", strerror(errno));\n return 0;\n }\n\n        n_read+=n;\n\n }\n\n return n_read;\n}\n", "target": 1, "flaw_line_index": "30,48"}
{"idx": 187991, "func": "void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) {\n if (err != OK) {\n        mMetaDataSize = -1ll;\n        mContentType = \"\";\n        mSniffedMIME = \"\";\n {\n            sp<DataSource> dataSource = mDataSource;\n            sp<NuCachedSource2> cachedSource = mCachedSource;\n            sp<DataSource> httpSource = mHttpSource;\n\n             {\n                 Mutex::Autolock _l(mDisconnectLock);\n                 mDataSource.clear();\n                 mCachedSource.clear();\n                 mHttpSource.clear();\n             }\n }\n\n        cancelPollBuffering();\n }\n    notifyPrepared(err);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8402, "func": "static void pvscsi_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n    PVSCSIClass *pvs_k = PVSCSI_DEVICE_CLASS(klass);\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);\n\n    k->init = pvscsi_init;\n    k->exit = pvscsi_uninit;\n    k->vendor_id = PCI_VENDOR_ID_VMWARE;\n    k->device_id = PCI_DEVICE_ID_VMWARE_PVSCSI;\n    k->class_id = PCI_CLASS_STORAGE_SCSI;\n    k->subsystem_id = 0x1000;\n    pvs_k->parent_dc_realize = dc->realize;\n    dc->realize = pvscsi_realize;\n    dc->reset = pvscsi_reset;\n    dc->vmsd = &vmstate_pvscsi;\n    dc->props = pvscsi_properties;\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n    hc->unplug = pvscsi_hot_unplug;\n    hc->plug = pvscsi_hotplug;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9029, "func": "static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (qemu_has_vnet_hdr(nc->peer)) {\n        return true;\n    }\n\n    return false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8564, "func": "static void ssh_fix_verstring(char *str)\n{\n    while (*str && *str != '-') str++;\n    assert(*str == '-'); str++;\n\n    while (*str) {\n        if (*str == '-' || *str == ' ')\n            *str = '_';\n        str++;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188585, "func": " virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 8;\n     fwd_txfm_ref = fht8x8_ref;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8999, "func": "static void vmxnet3_get_rx_stats_from_file(QEMUFile *f,\n    struct UPT1_RxStats *rx_stat)\n{\n    rx_stat->LROPktsRxOK = qemu_get_be64(f);\n    rx_stat->LROBytesRxOK = qemu_get_be64(f);\n    rx_stat->ucastPktsRxOK = qemu_get_be64(f);\n    rx_stat->ucastBytesRxOK = qemu_get_be64(f);\n    rx_stat->mcastPktsRxOK = qemu_get_be64(f);\n    rx_stat->mcastBytesRxOK = qemu_get_be64(f);\n    rx_stat->bcastPktsRxOK = qemu_get_be64(f);\n    rx_stat->bcastBytesRxOK = qemu_get_be64(f);\n    rx_stat->pktsRxOutOfBuf = qemu_get_be64(f);\n    rx_stat->pktsRxError = qemu_get_be64(f);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187682, "func": " int main(int argc, char **argv)\n {\n   volatile int summary = 1;  \n   volatile int memstats = 0; \n \n   PNG_CONST char *volatile touch = NULL;\n \n static double\n      gammas[]={2.2, 1.0, 2.2/1.45, 1.8, 1.5, 2.4, 2.5, 2.62, 2.9};\n\n size_t cp = 0;\n char command[1024];\n\n \n    anon_context(&pm.this);\n \n    signal(SIGABRT, signal_handler);\n    signal(SIGFPE, signal_handler);\n   signal(SIGILL, signal_handler);\n   signal(SIGINT, signal_handler);\n   signal(SIGSEGV, signal_handler);\n   signal(SIGTERM, signal_handler);\n\n#ifdef HAVE_FEENABLEEXCEPT\n   feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);\n#endif\n\n   modifier_init(&pm);\n\n   store_ensure_image(&pm.this, NULL, 2, TRANSFORM_ROWMAX, TRANSFORM_HEIGHTMAX);\n\n   cp = safecat(command, sizeof command, cp, \"pngvalid\");\n\n   pm.this.treat_warnings_as_errors = 1;\n\n   pm.assume_16_bit_calculations = PNG_LIBPNG_VER >= 10700;\n\n   pm.calculations_use_input_precision = 1U;\n\n \n    pm.gammas = gammas;\n   pm.ngammas = (sizeof gammas) / (sizeof gammas[0]);\n    pm.ngamma_tests = 0; \n \n    pm.encodings = test_encodings;\n   pm.nencodings = (sizeof test_encodings) / (sizeof test_encodings[0]);\n \n   pm.sbitlow = 8U; \n \n   pm.use_input_precision_16to8 = 1U;\n   pm.use_input_precision_sbit = 1U; \n\n   pm.maxout8 = .1; \n   pm.maxabs8 = .00005; \n   pm.maxcalc8 = 1./255; \n   pm.maxpc8 = .499; \n\n    pm.maxout16 = .499;  \n    pm.maxabs16 = .00005;\n    pm.maxcalc16 =1./65535;\n   pm.maxcalcG = 1./((1<<PNG_MAX_GAMMA_8)-1);\n \n   pm.maxpc16 = .005; \n\n while (--argc >= 1)\n {\n int catmore = 0; \n\n      cp = safecat(command, sizeof command, cp, \" \");\n      cp = safecat(command, sizeof command, cp, *++argv);\n\n if (strcmp(*argv, \"-v\") == 0)\n         pm.this.verbose = 1;\n\n else if (strcmp(*argv, \"-l\") == 0)\n         pm.log = 1;\n\n\n       else if (strcmp(*argv, \"-q\") == 0)\n          summary = pm.this.verbose = pm.log = 0;\n \n      else if (strcmp(*argv, \"-w\") == 0)\n          pm.this.treat_warnings_as_errors = 0;\n \n       else if (strcmp(*argv, \"--speed\") == 0)\n         pm.this.speed = 1, pm.ngamma_tests = pm.ngammas, pm.test_standard = 0,\n            summary = 0;\n\n else if (strcmp(*argv, \"--memory\") == 0)\n         memstats = 1;\n\n else if (strcmp(*argv, \"--size\") == 0)\n         pm.test_size = 1;\n\n else if (strcmp(*argv, \"--nosize\") == 0)\n         pm.test_size = 0;\n\n else if (strcmp(*argv, \"--standard\") == 0)\n         pm.test_standard = 1;\n\n else if (strcmp(*argv, \"--nostandard\") == 0)\n         pm.test_standard = 0;\n\n else if (strcmp(*argv, \"--transform\") == 0)\n         pm.test_transform = 1;\n\n else if (strcmp(*argv, \"--notransform\") == 0)\n         pm.test_transform = 0;\n\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\n else if (strncmp(*argv, \"--transform-disable=\",\n sizeof \"--transform-disable\") == 0)\n {\n         pm.test_transform = 1;\n         transform_disable(*argv + sizeof \"--transform-disable\");\n }\n\n else if (strncmp(*argv, \"--transform-enable=\",\n sizeof \"--transform-enable\") == 0)\n {\n         pm.test_transform = 1;\n         transform_enable(*argv + sizeof \"--transform-enable\");\n }\n#endif \n\n else if (strcmp(*argv, \"--gamma\") == 0)\n {\n         pm.ngamma_tests = 2U;\n         pm.test_gamma_threshold = 1;\n\n          pm.test_gamma_transform = 1;\n          pm.test_gamma_sbit = 1;\n          pm.test_gamma_scale16 = 1;\n         pm.test_gamma_background = 1;\n          pm.test_gamma_alpha_mode = 1;\n          }\n \n else if (strcmp(*argv, \"--nogamma\") == 0)\n         pm.ngamma_tests = 0;\n\n else if (strcmp(*argv, \"--gamma-threshold\") == 0)\n         pm.ngamma_tests = 2U, pm.test_gamma_threshold = 1;\n\n else if (strcmp(*argv, \"--nogamma-threshold\") == 0)\n         pm.test_gamma_threshold = 0;\n\n else if (strcmp(*argv, \"--gamma-transform\") == 0)\n         pm.ngamma_tests = 2U, pm.test_gamma_transform = 1;\n\n else if (strcmp(*argv, \"--nogamma-transform\") == 0)\n         pm.test_gamma_transform = 0;\n\n else if (strcmp(*argv, \"--gamma-sbit\") == 0)\n         pm.ngamma_tests = 2U, pm.test_gamma_sbit = 1;\n\n else if (strcmp(*argv, \"--nogamma-sbit\") == 0)\n         pm.test_gamma_sbit = 0;\n\n else if (strcmp(*argv, \"--gamma-16-to-8\") == 0)\n         pm.ngamma_tests = 2U, pm.test_gamma_scale16 = 1;\n\n else if (strcmp(*argv, \"--nogamma-16-to-8\") == 0)\n         pm.test_gamma_scale16 = 0;\n\n else if (strcmp(*argv, \"--gamma-background\") == 0)\n         pm.ngamma_tests = 2U, pm.test_gamma_background = 1;\n\n else if (strcmp(*argv, \"--nogamma-background\") == 0)\n         pm.test_gamma_background = 0;\n\n else if (strcmp(*argv, \"--gamma-alpha-mode\") == 0)\n         pm.ngamma_tests = 2U, pm.test_gamma_alpha_mode = 1;\n\n else if (strcmp(*argv, \"--nogamma-alpha-mode\") == 0)\n         pm.test_gamma_alpha_mode = 0;\n\n else if (strcmp(*argv, \"--expand16\") == 0)\n         pm.test_gamma_expand16 = 1;\n\n\n       else if (strcmp(*argv, \"--noexpand16\") == 0)\n          pm.test_gamma_expand16 = 0;\n \n       else if (strcmp(*argv, \"--more-gammas\") == 0)\n          pm.ngamma_tests = 3U;\n \n else if (strcmp(*argv, \"--all-gammas\") == 0)\n         pm.ngamma_tests = pm.ngammas;\n\n else if (strcmp(*argv, \"--progressive-read\") == 0)\n         pm.this.progressive = 1;\n\n else if (strcmp(*argv, \"--use-update-info\") == 0)\n ++pm.use_update_info; \n\n \n       else if (strcmp(*argv, \"--interlace\") == 0)\n       {\n#        ifdef PNG_WRITE_INTERLACING_SUPPORTED\n             pm.interlace_type = PNG_INTERLACE_ADAM7;\n#        else\n             fprintf(stderr, \"pngvalid: no write interlace support\\n\");\n             return SKIP;\n#        endif\n       }\n \n       else if (strcmp(*argv, \"--use-input-precision\") == 0)\n         pm.use_input_precision = 1U;\n\n else if (strcmp(*argv, \"--use-calculation-precision\") == 0)\n         pm.use_input_precision = 0;\n\n else if (strcmp(*argv, \"--calculations-use-input-precision\") == 0)\n         pm.calculations_use_input_precision = 1U;\n\n else if (strcmp(*argv, \"--assume-16-bit-calculations\") == 0)\n         pm.assume_16_bit_calculations = 1U;\n\n else if (strcmp(*argv, \"--calculations-follow-bit-depth\") == 0)\n         pm.calculations_use_input_precision =\n            pm.assume_16_bit_calculations = 0;\n\n else if (strcmp(*argv, \"--exhaustive\") == 0)\n         pm.test_exhaustive = 1;\n\n else if (argc > 1 && strcmp(*argv, \"--sbitlow\") == 0)\n --argc, pm.sbitlow = (png_byte)atoi(*++argv), catmore = 1;\n\n else if (argc > 1 && strcmp(*argv, \"--touch\") == 0)\n --argc, touch = *++argv, catmore = 1;\n\n else if (argc > 1 && strncmp(*argv, \"--max\", 5) == 0)\n {\n --argc;\n\n if (strcmp(5+*argv, \"abs8\") == 0)\n            pm.maxabs8 = atof(*++argv);\n\n else if (strcmp(5+*argv, \"abs16\") == 0)\n            pm.maxabs16 = atof(*++argv);\n\n else if (strcmp(5+*argv, \"calc8\") == 0)\n            pm.maxcalc8 = atof(*++argv);\n\n else if (strcmp(5+*argv, \"calc16\") == 0)\n            pm.maxcalc16 = atof(*++argv);\n\n else if (strcmp(5+*argv, \"out8\") == 0)\n            pm.maxout8 = atof(*++argv);\n\n else if (strcmp(5+*argv, \"out16\") == 0)\n            pm.maxout16 = atof(*++argv);\n\n else if (strcmp(5+*argv, \"pc8\") == 0)\n            pm.maxpc8 = atof(*++argv);\n\n else if (strcmp(5+*argv, \"pc16\") == 0)\n            pm.maxpc16 = atof(*++argv);\n\n else\n {\n            fprintf(stderr, \"pngvalid: %s: unknown 'max' option\\n\", *argv);\n            exit(99);\n }\n\n         catmore = 1;\n }\n\n else if (strcmp(*argv, \"--log8\") == 0)\n --argc, pm.log8 = atof(*++argv), catmore = 1;\n\n else if (strcmp(*argv, \"--log16\") == 0)\n --argc, pm.log16 = atof(*++argv), catmore = 1;\n\n#ifdef PNG_SET_OPTION_SUPPORTED\n else if (strncmp(*argv, \"--option=\", 9) == 0)\n {\n\n          const char *arg = 9+*argv;\n          unsigned char option=0, setting=0;\n \n#ifdef PNG_ARM_NEON_API_SUPPORTED\n          if (strncmp(arg, \"arm-neon:\", 9) == 0)\n             option = PNG_ARM_NEON, arg += 9;\n \n          else\n #endif\n #ifdef PNG_MAXIMUM_INFLATE_WINDOW\n          if (strncmp(arg, \"max-inflate-window:\", 19) == 0)\n             option = PNG_MAXIMUM_INFLATE_WINDOW, arg += 19;\n\n else\n#endif\n {\n            fprintf(stderr, \"pngvalid: %s: %s: unknown option\\n\", *argv, arg);\n            exit(99);\n }\n\n if (strcmp(arg, \"off\") == 0)\n            setting = PNG_OPTION_OFF;\n\n else if (strcmp(arg, \"on\") == 0)\n            setting = PNG_OPTION_ON;\n\n else\n {\n            fprintf(stderr,\n \"pngvalid: %s: %s: unknown setting (use 'on' or 'off')\\n\",\n *argv, arg);\n            exit(99);\n }\n\n         pm.this.options[pm.this.noptions].option = option;\n         pm.this.options[pm.this.noptions++].setting = setting;\n }\n#endif \n\n else\n {\n         fprintf(stderr, \"pngvalid: %s: unknown argument\\n\", *argv);\n         exit(99);\n }\n\n if (catmore) \n {\n         cp = safecat(command, sizeof command, cp, \" \");\n         cp = safecat(command, sizeof command, cp, *argv);\n }\n }\n\n if (pm.test_standard == 0 && pm.test_size == 0 && pm.test_transform == 0 &&\n      pm.ngamma_tests == 0)\n {\n      pm.test_standard = 1;\n      pm.test_size = 1;\n      pm.test_transform = 1;\n      pm.ngamma_tests = 2U;\n }\n\n if (pm.ngamma_tests > 0 &&\n      pm.test_gamma_threshold == 0 && pm.test_gamma_transform == 0 &&\n      pm.test_gamma_sbit == 0 && pm.test_gamma_scale16 == 0 &&\n      pm.test_gamma_background == 0 && pm.test_gamma_alpha_mode == 0)\n {\n      pm.test_gamma_threshold = 1;\n      pm.test_gamma_transform = 1;\n      pm.test_gamma_sbit = 1;\n      pm.test_gamma_scale16 = 1;\n      pm.test_gamma_background = 1;\n      pm.test_gamma_alpha_mode = 1;\n }\n\n else if (pm.ngamma_tests == 0)\n {\n      pm.test_gamma_threshold = 0;\n      pm.test_gamma_transform = 0;\n      pm.test_gamma_sbit = 0;\n      pm.test_gamma_scale16 = 0;\n      pm.test_gamma_background = 0;\n      pm.test_gamma_alpha_mode = 0;\n }\n\n\n    Try\n    {\n      make_transform_images(&pm.this);\n \n       if (pm.test_standard)\n {\n         perform_interlace_macro_validation();\n         perform_formatting_test(&pm.this);\n#        ifdef PNG_READ_SUPPORTED\n            perform_standard_test(&pm);\n#        endif\n         perform_error_test(&pm);\n }\n\n if (pm.test_size)\n {\n         make_size_images(&pm.this);\n#        ifdef PNG_READ_SUPPORTED\n            perform_size_test(&pm);\n#        endif\n }\n\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\n if (pm.test_transform)\n         perform_transform_test(&pm);\n#endif \n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n if (pm.ngamma_tests > 0)\n         perform_gamma_test(&pm, summary);\n#endif\n }\n\n Catch_anonymous\n {\n      fprintf(stderr, \"pngvalid: test aborted (probably failed in cleanup)\\n\");\n if (!pm.this.verbose)\n {\n if (pm.this.error[0] != 0)\n            fprintf(stderr, \"pngvalid: first error: %s\\n\", pm.this.error);\n\n         fprintf(stderr, \"pngvalid: run with -v to see what happened\\n\");\n }\n      exit(1);\n }\n\n if (summary)\n {\n      printf(\"%s: %s (%s point arithmetic)\\n\",\n (pm.this.nerrors || (pm.this.treat_warnings_as_errors &&\n            pm.this.nwarnings)) ? \"FAIL\" : \"PASS\",\n         command,\n#if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || PNG_LIBPNG_VER < 10500\n \"floating\"\n#else\n \"fixed\"\n#endif\n );\n }\n\n if (memstats)\n {\n      printf(\"Allocated memory statistics (in bytes):\\n\"\n \"\\tread  %lu maximum single, %lu peak, %lu total\\n\"\n \"\\twrite %lu maximum single, %lu peak, %lu total\\n\",\n (unsigned long)pm.this.read_memory_pool.max_max,\n (unsigned long)pm.this.read_memory_pool.max_limit,\n (unsigned long)pm.this.read_memory_pool.max_total,\n (unsigned long)pm.this.write_memory_pool.max_max,\n (unsigned long)pm.this.write_memory_pool.max_limit,\n (unsigned long)pm.this.write_memory_pool.max_total);\n }\n\n   store_delete(&pm.this);\n\n if (pm.this.nerrors || (pm.this.treat_warnings_as_errors &&\n       pm.this.nwarnings))\n {\n if (!pm.this.verbose)\n         fprintf(stderr, \"pngvalid: %s\\n\", pm.this.error);\n\n      fprintf(stderr, \"pngvalid: %d errors, %d warnings\\n\", pm.this.nerrors,\n          pm.this.nwarnings);\n\n      exit(1);\n }\n\n if (touch != NULL)\n {\n FILE *fsuccess = fopen(touch, \"wt\");\n\n if (fsuccess != NULL)\n {\n int error = 0;\n         fprintf(fsuccess, \"PNG validation succeeded\\n\");\n         fflush(fsuccess);\n         error = ferror(fsuccess);\n\n if (fclose(fsuccess) || error)\n {\n            fprintf(stderr, \"%s: write failed\\n\", touch);\n            exit(1);\n }\n }\n\n else\n {\n         fprintf(stderr, \"%s: open failed\\n\", touch);\n         exit(1);\n }\n }\n\n   UNUSED(fail)\n return 0;\n}\n", "target": 1, "flaw_line_index": "3,4,6,42,46,48,61,82,134,199,201,204,282,366"}
{"idx": 8920, "func": "int vrend_renderer_transfer_iov(const struct vrend_transfer_info *info,\n                                int transfer_mode)\n{\n   struct vrend_resource *res;\n   struct vrend_context *ctx;\n   struct iovec *iov;\n   int num_iovs;\n\n   if (!info->box)\n      return EINVAL;\n\n   ctx = vrend_lookup_renderer_ctx(info->ctx_id);\n   if (!ctx)\n      return EINVAL;\n\n   if (info->ctx_id == 0)\n      res = vrend_resource_lookup(info->handle, 0);\n   else\n      res = vrend_renderer_ctx_res_lookup(ctx, info->handle);\n\n   if (!res) {\n      if (info->ctx_id)\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, info->handle);\n      return EINVAL;\n   }\n\n   iov = info->iovec;\n   num_iovs = info->iovec_cnt;\n\n   if (res->iov && (!iov || num_iovs == 0)) {\n      iov = res->iov;\n      num_iovs = res->num_iovs;\n   }\n\n   if (!iov) {\n      if (info->ctx_id)\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, info->handle);\n      return EINVAL;\n   }\n\n   if (!check_transfer_bounds(res, info))\n      return EINVAL;\n\n   if (!check_iov_bounds(res, info, iov, num_iovs))\n      return EINVAL;\n\n   vrend_hw_switch_context(vrend_lookup_renderer_ctx(0), true);\n\n   if (transfer_mode == VREND_TRANSFER_WRITE)\n      return vrend_renderer_transfer_write_iov(ctx, res, iov, num_iovs,\n                                               info);\n   else\n      return vrend_renderer_transfer_send_iov(ctx, res, iov, num_iovs,\n                                              info);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8577, "func": "static void ssh_pkt_ensure(struct Packet *pkt, int length)\n{\n    if (pkt->maxlen < length) {\n\tunsigned char *body = pkt->body;\n\tint offset = body ? body - pkt->data : 0;\n\tpkt->maxlen = length + 256;\n\tpkt->data = sresize(pkt->data, pkt->maxlen + APIEXTRA, unsigned char);\n\tif (body) pkt->body = pkt->data + offset;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8956, "func": "void net_tx_pkt_dump(struct NetTxPkt *pkt)\n{\n#ifdef NET_TX_PKT_DEBUG\n    assert(pkt);\n\n    printf(\"TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, \"\n        \"l3hdr_len: %lu, payload_len: %u\\n\", pkt->hdr_len, pkt->packet_type,\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8663, "func": "size_t mptsas_config_sas_device_1(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_device_addr_get(s, address);\n    SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n\n    trace_mptsas_config_sas_device(s, address, i, phy_handle, dev_handle, 1);\n    if (!dev) {\n        return -ENOENT;\n    }\n\n    return MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE, 0x00,\n                                  \"*lq*lwbb*s20\",\n                                  dev->wwn, dev_handle, i, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187951, "func": "void btif_config_save(void) {\n\n   assert(alarm_timer != NULL);\n   assert(config != NULL);\n \n  alarm_set(alarm_timer, CONFIG_SETTLE_PERIOD_MS, timer_config_save, NULL);\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8817, "func": "translate_logicop(GLuint pipe_logicop)\n{\n   switch (pipe_logicop) {\n#define CASE(x) case PIPE_LOGICOP_##x: return GL_##x\n      CASE(CLEAR);\n      CASE(NOR);\n      CASE(AND_INVERTED);\n      CASE(COPY_INVERTED);\n      CASE(AND_REVERSE);\n      CASE(INVERT);\n      CASE(XOR);\n      CASE(NAND);\n      CASE(AND);\n      CASE(EQUIV);\n      CASE(NOOP);\n      CASE(OR_INVERTED);\n      CASE(COPY);\n      CASE(OR_REVERSE);\n      CASE(OR);\n      CASE(SET);\n   default:\n      assert(\"invalid logicop token()\" == NULL);\n      return 0;\n   }\n#undef CASE\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8341, "func": "static int xhci_fire_transfer(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    trace_usb_xhci_xfer_start(xfer, xfer->slotid, xfer->epid, xfer->streamid);\n    return xhci_submit(xhci, xfer, epctx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187959, "func": " status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"Client2[%d] (%p) Client: %s PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n String8(mClientPackageName).string(),\n            mClientPid);\n    result.append(\"  State: \");\n#define CASE_APPEND_ENUM(x) case x: result.append(#x \"\\n\"); break;\n\n const Parameters& p = mParameters.unsafeAccess();\n\n    result.append(Parameters::getStateName(p.state));\n\n    result.append(\"\\n  Current parameters:\\n\");\n    result.appendFormat(\"    Preview size: %d x %d\\n\",\n            p.previewWidth, p.previewHeight);\n    result.appendFormat(\"    Preview FPS range: %d - %d\\n\",\n            p.previewFpsRange[0], p.previewFpsRange[1]);\n    result.appendFormat(\"    Preview HAL pixel format: 0x%x\\n\",\n            p.previewFormat);\n    result.appendFormat(\"    Preview transform: %x\\n\",\n            p.previewTransform);\n    result.appendFormat(\"    Picture size: %d x %d\\n\",\n            p.pictureWidth, p.pictureHeight);\n    result.appendFormat(\"    Jpeg thumbnail size: %d x %d\\n\",\n            p.jpegThumbSize[0], p.jpegThumbSize[1]);\n    result.appendFormat(\"    Jpeg quality: %d, thumbnail quality: %d\\n\",\n            p.jpegQuality, p.jpegThumbQuality);\n    result.appendFormat(\"    Jpeg rotation: %d\\n\", p.jpegRotation);\n    result.appendFormat(\"    GPS tags %s\\n\",\n            p.gpsEnabled ? \"enabled\" : \"disabled\");\n if (p.gpsEnabled) {\n        result.appendFormat(\"    GPS lat x long x alt: %f x %f x %f\\n\",\n                p.gpsCoordinates[0], p.gpsCoordinates[1],\n                p.gpsCoordinates[2]);\n        result.appendFormat(\"    GPS timestamp: %lld\\n\",\n                p.gpsTimestamp);\n        result.appendFormat(\"    GPS processing method: %s\\n\",\n                p.gpsProcessingMethod.string());\n }\n\n    result.append(\"    White balance mode: \");\n switch (p.wbMode) {\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)\n default: result.append(\"UNKNOWN\\n\");\n }\n\n    result.append(\"    Effect mode: \");\n switch (p.effectMode) {\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)\n default: result.append(\"UNKNOWN\\n\");\n }\n\n    result.append(\"    Antibanding mode: \");\n switch (p.antibandingMode) {\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)\n default: result.append(\"UNKNOWN\\n\");\n }\n\n    result.append(\"    Scene mode: \");\n switch (p.sceneMode) {\n case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:\n            result.append(\"AUTO\\n\"); break;\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)\n default: result.append(\"UNKNOWN\\n\");\n }\n\n    result.append(\"    Flash mode: \");\n switch (p.flashMode) {\n        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)\n        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)\n        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)\n        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)\n        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)\n        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)\n default: result.append(\"UNKNOWN\\n\");\n }\n\n    result.append(\"    Focus mode: \");\n switch (p.focusMode) {\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)\n        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)\n default: result.append(\"UNKNOWN\\n\");\n }\n\n    result.append(\"   Focus state: \");\n switch (p.focusState) {\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)\n        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)\n default: result.append(\"UNKNOWN\\n\");\n }\n\n    result.append(\"    Focusing areas:\\n\");\n for (size_t i = 0; i < p.focusingAreas.size(); i++) {\n        result.appendFormat(\"      [ (%d, %d, %d, %d), weight %d ]\\n\",\n                p.focusingAreas[i].left,\n                p.focusingAreas[i].top,\n                p.focusingAreas[i].right,\n                p.focusingAreas[i].bottom,\n                p.focusingAreas[i].weight);\n }\n\n    result.appendFormat(\"    Exposure compensation index: %d\\n\",\n            p.exposureCompensation);\n\n    result.appendFormat(\"    AE lock %s, AWB lock %s\\n\",\n            p.autoExposureLock ? \"enabled\" : \"disabled\",\n            p.autoWhiteBalanceLock ? \"enabled\" : \"disabled\" );\n\n    result.appendFormat(\"    Metering areas:\\n\");\n for (size_t i = 0; i < p.meteringAreas.size(); i++) {\n        result.appendFormat(\"      [ (%d, %d, %d, %d), weight %d ]\\n\",\n                p.meteringAreas[i].left,\n                p.meteringAreas[i].top,\n                p.meteringAreas[i].right,\n                p.meteringAreas[i].bottom,\n                p.meteringAreas[i].weight);\n }\n\n    result.appendFormat(\"    Zoom index: %d\\n\", p.zoom);\n    result.appendFormat(\"    Video size: %d x %d\\n\", p.videoWidth,\n            p.videoHeight);\n\n    result.appendFormat(\"    Recording hint is %s\\n\",\n            p.recordingHint ? \"set\" : \"not set\");\n\n    result.appendFormat(\"    Video stabilization is %s\\n\",\n            p.videoStabilization ? \"enabled\" : \"disabled\");\n\n    result.appendFormat(\"    Selected still capture FPS range: %d - %d\\n\",\n            p.fastInfo.bestStillCaptureFpsRange[0],\n            p.fastInfo.bestStillCaptureFpsRange[1]);\n\n    result.append(\"  Current streams:\\n\");\n    result.appendFormat(\"    Preview stream ID: %d\\n\",\n            getPreviewStreamId());\n    result.appendFormat(\"    Capture stream ID: %d\\n\",\n            getCaptureStreamId());\n    result.appendFormat(\"    Recording stream ID: %d\\n\",\n            getRecordingStreamId());\n\n    result.append(\"  Quirks for this camera:\\n\");\n bool haveQuirk = false;\n if (p.quirks.triggerAfWithAuto) {\n        result.appendFormat(\"    triggerAfWithAuto\\n\");\n        haveQuirk = true;\n }\n if (p.quirks.useZslFormat) {\n        result.appendFormat(\"    useZslFormat\\n\");\n        haveQuirk = true;\n }\n if (p.quirks.meteringCropRegion) {\n        result.appendFormat(\"    meteringCropRegion\\n\");\n        haveQuirk = true;\n }\n if (p.quirks.partialResults) {\n        result.appendFormat(\"    usePartialResult\\n\");\n        haveQuirk = true;\n }\n if (!haveQuirk) {\n        result.appendFormat(\"    none\\n\");\n }\n\n    write(fd, result.string(), result.size());\n\n    mStreamingProcessor->dump(fd, args);\n\n    mCaptureSequencer->dump(fd, args);\n\n    mFrameProcessor->dump(fd, args);\n\n    mZslProcessor->dump(fd, args);\n\n return dumpDevice(fd, args);\n#undef CASE_APPEND_ENUM\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188127, "func": "WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)\n\n {\n     UWORD8 i;\n     dec_seq_params_t *ps_seq = NULL;\n    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;\n     UWORD16 i2_max_frm_num;\n     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;\n    WORD32 i4_cropped_ht, i4_cropped_wd;\n    UWORD32 u4_temp;\n    WORD32 pic_height_in_map_units_minus1 = 0;\n    UWORD32 u2_pic_wd = 0;\n    UWORD32 u2_pic_ht = 0;\n    UWORD32 u2_frm_wd_y = 0;\n    UWORD32 u2_frm_ht_y = 0;\n    UWORD32 u2_frm_wd_uv = 0;\n    UWORD32 u2_frm_ht_uv = 0;\n    UWORD32 u2_crop_offset_y = 0;\n    UWORD32 u2_crop_offset_uv = 0;\n    WORD32 ret;\n    UWORD32 u4_num_reorder_frames;\n    WORD32 i4_i;\n    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,\n                    u1_frame_cropping_rect_right_ofst,\n                    u1_frame_cropping_rect_top_ofst,\n                    u1_frame_cropping_rect_bottom_ofst;\n    SWITCHONTRACE;\n    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);\n    COPYTHECONTEXT(\"SPS: profile_idc\",u1_profile_idc);\n\n    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);\n    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);\n    ih264d_get_bit_h264(ps_bitstrm);\n\n    ih264d_get_bits_h264(ps_bitstrm, 5);\n\n if((u1_profile_idc != MAIN_PROFILE_IDC) &&\n\n (u1_profile_idc != BASE_PROFILE_IDC) &&\n\n (u1_profile_idc != HIGH_PROFILE_IDC)\n\n )\n {\n\n if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||\n ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))\n {\n return (ERROR_FEATURE_UNAVAIL);\n }\n }\n\n    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);\n\n\n\n    COPYTHECONTEXT(\"SPS: u4_level_idc\",u1_level_idc);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_SEQ_SET_ID)\n return ERROR_INV_SPS_PPS_T;\n    u1_seq_parameter_set_id = u4_temp;\n    COPYTHECONTEXT(\"SPS: seq_parameter_set_id\",\n                    u1_seq_parameter_set_id);\n\n\n    ps_seq = ps_dec->pv_scratch_sps_pps;\n if(ps_dec->i4_header_decoded & 1)\n {\n *ps_seq = *ps_dec->ps_cur_sps;\n }\n\n\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_profile_idc = u1_profile_idc;\n    ps_seq->u1_level_idc = u1_level_idc;\n    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;\n\n    ps_seq->i4_chroma_format_idc = 1;\n    ps_seq->i4_bit_depth_luma_minus8 = 0;\n    ps_seq->i4_bit_depth_chroma_minus8 = 0;\n    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;\n    ps_seq->i4_seq_scaling_matrix_present_flag = 0;\n if(u1_profile_idc == HIGH_PROFILE_IDC)\n {\n\n        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,\n                                                  pu4_bitstrm_buf);\n\n if(ps_seq->i4_chroma_format_idc != 1)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,\n                                                      pu4_bitstrm_buf);\n\n if(ps_seq->i4_bit_depth_luma_minus8 != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,\n                                                        pu4_bitstrm_buf);\n\n if(ps_seq->i4_bit_depth_chroma_minus8 != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =\n (WORD32)ih264d_get_bit_h264(ps_bitstrm);\n\n if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n        ps_seq->i4_seq_scaling_matrix_present_flag =\n (WORD32)ih264d_get_bit_h264(ps_bitstrm);\n\n if(ps_seq->i4_seq_scaling_matrix_present_flag)\n {\n for(i4_i = 0; i4_i < 8; i4_i++)\n {\n                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =\n                                ih264d_get_bit_h264(ps_bitstrm);\n\n                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;\n\n if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])\n {\n if(i4_i < 6)\n {\n                        ih264d_scaling_list(\n                                        ps_seq->i2_scalinglist4x4[i4_i],\n 16,\n &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],\n                                        ps_bitstrm);\n }\n else\n {\n                        ih264d_scaling_list(\n                                        ps_seq->i2_scalinglist8x8[i4_i - 6],\n 64,\n &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],\n                                        ps_bitstrm);\n }\n }\n }\n }\n }\n    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_BITS_IN_FRAME_NUM)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n    ps_seq->u1_bits_in_frm_num = u4_temp;\n    COPYTHECONTEXT(\"SPS: log2_max_frame_num_minus4\",\n (ps_seq->u1_bits_in_frm_num - 4));\n\n    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));\n    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)\n {\n return ERROR_INV_POC_TYPE_T;\n }\n    ps_seq->u1_pic_order_cnt_type = u4_temp;\n    COPYTHECONTEXT(\"SPS: pic_order_cnt_type\",ps_seq->u1_pic_order_cnt_type);\n\n    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;\n if(ps_seq->u1_pic_order_cnt_type == 0)\n {\n        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_BITS_IN_POC_LSB)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;\n        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);\n        COPYTHECONTEXT(\"SPS: log2_max_pic_order_cnt_lsb_minus4\",(u4_temp - 4));\n }\n else if(ps_seq->u1_pic_order_cnt_type == 1)\n {\n        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SPS: delta_pic_order_always_zero_flag\",\n                        ps_seq->u1_delta_pic_order_always_zero_flag);\n\n        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,\n                                                     pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: offset_for_non_ref_pic\",\n                        ps_seq->i4_ofst_for_non_ref_pic);\n\n        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(\n                        pu4_bitstrm_ofst, pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: offset_for_top_to_bottom_field\",\n                        ps_seq->i4_ofst_for_top_to_bottom_field);\n\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > 255)\n return ERROR_INV_SPS_PPS_T;\n        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;\n        COPYTHECONTEXT(\"SPS: num_ref_frames_in_pic_order_cnt_cycle\",\n                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);\n\n for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)\n {\n            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SPS: offset_for_ref_frame\",\n                            ps_seq->i4_ofst_for_ref_frame[i]);\n }\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if((u4_temp > H264_MAX_REF_PICS))\n {\n return ERROR_NUM_REF;\n }\n\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_num_ref_frames = u4_temp;\n    COPYTHECONTEXT(\"SPS: num_ref_frames\",ps_seq->u1_num_ref_frames);\n\n    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(\n                    ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: gaps_in_frame_num_value_allowed_flag\",\n                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);\n\n    ps_seq->u2_frm_wd_in_mbs = 1\n + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n    COPYTHECONTEXT(\"SPS: pic_width_in_mbs_minus1\",\n                    ps_seq->u2_frm_wd_in_mbs - 1);\n    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);\n\n    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,\n                                                pu4_bitstrm_buf);\n    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;\n\n    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);\n\n    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs\n * ps_seq->u2_frm_ht_in_mbs) - 1;\n\n    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;\n\n    ps_seq->u1_level_idc = ih264d_correct_level_idc(\n                    u1_level_idc, ps_seq->u2_total_num_of_mbs);\n\n    u1_frm = ih264d_get_bit_h264(ps_bitstrm);\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_frame_mbs_only_flag = u1_frm;\n\n\n     COPYTHECONTEXT(\"SPS: frame_mbs_only_flag\", u1_frm);\n \n     if(!u1_frm)\n     {\n         u2_pic_ht <<= 1;\n        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);\n         COPYTHECONTEXT(\"SPS: mb_adaptive_frame_field_flag\",\n                         ps_seq->u1_mb_aff_flag);\n \n }\n else\n        ps_seq->u1_mb_aff_flag = 0;\n\n    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);\n\n    COPYTHECONTEXT(\"SPS: direct_8x8_inference_flag\",\n                    ps_seq->u1_direct_8x8_inference_flag);\n\n    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: frame_cropping_flag\",u1_frame_cropping_flag);\n\n if(u1_frame_cropping_flag)\n {\n        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                      pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_left_offset\",\n                        u1_frame_cropping_rect_left_ofst);\n        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_right_offset\",\n                        u1_frame_cropping_rect_right_ofst);\n        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                     pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_top_offset\",\n                        u1_frame_cropping_rect_top_ofst);\n        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                        pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_bottom_offset\",\n                        u1_frame_cropping_rect_bottom_ofst);\n }\n\n    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: vui_parameters_present_flag\",\n                    ps_seq->u1_vui_parameters_present_flag);\n\n    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);\n if(1 == ps_dec->u4_share_disp_buf)\n {\n if(ps_dec->u4_app_disp_width > u2_frm_wd_y)\n            u2_frm_wd_y = ps_dec->u4_app_disp_width;\n }\n\n    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);\n    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);\n    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);\n\n    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);\n    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));\n\n\n {\n        UWORD16 u2_rgt_ofst = 0;\n        UWORD16 u2_lft_ofst = 0;\n        UWORD16 u2_top_ofst = 0;\n        UWORD16 u2_btm_ofst = 0;\n        UWORD8 u1_frm_mbs_flag;\n        UWORD8 u1_vert_mult_factor;\n\n if(u1_frame_cropping_flag)\n {\n            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;\n            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;\n\n            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);\n\n            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);\n\n            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst\n << u1_vert_mult_factor);\n            u2_top_ofst = (u1_frame_cropping_rect_top_ofst\n << u1_vert_mult_factor);\n }\n\n        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);\n        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))\n + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;\n        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);\n        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);\n\n if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))\n {\n            ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))\n {\n            ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)\n || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)\n || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))\n {\n return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;\n }\n\n if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)\n {\n return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;\n }\n\n }\n\n if((ps_dec->i4_header_decoded & 1) &&\n (1 == ps_seq->u1_vui_parameters_present_flag) &&\n (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))\n {\n        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;\n }\n else\n {\n        u4_num_reorder_frames = -1;\n }\n if(1 == ps_seq->u1_vui_parameters_present_flag)\n {\n        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);\n if(ret != OK)\n return ret;\n }\n\n if((ps_dec->i4_header_decoded & 1) &&\n (-1 != (WORD32)u4_num_reorder_frames) &&\n (1 == ps_seq->u1_vui_parameters_present_flag) &&\n (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&\n (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n    ps_dec->u2_disp_height = i4_cropped_ht;\n    ps_dec->u2_disp_width = i4_cropped_wd;\n\n    ps_dec->u2_pic_wd = u2_pic_wd;\n    ps_dec->u2_pic_ht = u2_pic_ht;\n\n    ps_dec->u2_frm_wd_y = u2_frm_wd_y;\n    ps_dec->u2_frm_ht_y = u2_frm_ht_y;\n\n    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;\n    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;\n    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));\n    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));\n\n    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;\n\n    ps_dec->u2_crop_offset_y = u2_crop_offset_y;\n    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;\n\n    ps_seq->u1_is_valid = TRUE;\n    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;\n    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "6,287"}
{"idx": 9158, "func": "static GLuint blit_build_frag_tex_col_emu_alpha(struct vrend_blitter_ctx *blit_ctx, int tgsi_tex_target)\n{\n   GLuint fs_id;\n   char shader_buf[4096];\n   int is_shad;\n   const char *twm;\n   const char *ext_str = \"\";\n   switch (tgsi_tex_target) {\n   case TGSI_TEXTURE_1D:\n   case TGSI_TEXTURE_BUFFER:\n      twm = \".x\";\n      break;\n   case TGSI_TEXTURE_1D_ARRAY:\n   case TGSI_TEXTURE_2D:\n   case TGSI_TEXTURE_RECT:\n   case TGSI_TEXTURE_2D_MSAA:\n   default:\n      twm = \".xy\";\n      break;\n   case TGSI_TEXTURE_SHADOW1D:\n   case TGSI_TEXTURE_SHADOW2D:\n   case TGSI_TEXTURE_SHADOW1D_ARRAY:\n   case TGSI_TEXTURE_SHADOWRECT:\n   case TGSI_TEXTURE_3D:\n   case TGSI_TEXTURE_CUBE:\n   case TGSI_TEXTURE_2D_ARRAY:\n   case TGSI_TEXTURE_2D_ARRAY_MSAA:\n      twm = \".xyz\";\n      break;\n   case TGSI_TEXTURE_SHADOWCUBE:\n   case TGSI_TEXTURE_SHADOW2D_ARRAY:\n   case TGSI_TEXTURE_SHADOWCUBE_ARRAY:\n   case TGSI_TEXTURE_CUBE_ARRAY:\n      twm = \"\";\n      break;\n   }\n\n   if (tgsi_tex_target == TGSI_TEXTURE_CUBE_ARRAY ||\n       tgsi_tex_target == TGSI_TEXTURE_SHADOWCUBE_ARRAY)\n      ext_str = \"#extension GL_ARB_texture_cube_map_array : require\\n\";\n\n   snprintf(shader_buf, 4096, FS_TEXFETCH_COL_ALPHA_DEST, ext_str, vrend_shader_samplertypeconv(tgsi_tex_target, &is_shad), twm, \"\");\n\n   fs_id = glCreateShader(GL_FRAGMENT_SHADER);\n\n   if (!build_and_check(fs_id, shader_buf)) {\n      glDeleteShader(fs_id);\n      return 0;\n   }\n\n   return fs_id;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8885, "func": "void vrend_object_bind_rasterizer(struct vrend_context *ctx,\n                                  uint32_t handle)\n{\n   struct pipe_rasterizer_state *state;\n\n   if (handle == 0) {\n      memset(&ctx->sub->rs_state, 0, sizeof(ctx->sub->rs_state));\n      return;\n   }\n\n   state = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_RASTERIZER);\n\n   if (!state) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_HANDLE, handle);\n      return;\n   }\n\n   ctx->sub->rs_state = *state;\n   ctx->sub->scissor_state_dirty = (1 << 0);\n   ctx->sub->shader_dirty = true;\n   vrend_hw_emit_rs(ctx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187370, "func": "int Effect_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n EffectContext * pContext = (EffectContext *) self;\n int retsize;\n\n\n if(pContext->EffectType == LVM_BASS_BOOST){\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n }\n if(pContext->EffectType == LVM_VOLUME){\n }\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Effect_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n\n\n \n     switch (cmdCode){\n         case EFFECT_CMD_INIT:\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                 ALOGV(\"\\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d\",\n                         pContext->EffectType);\n                 return -EINVAL;\n }\n *(int *) pReplyData = 0;\n if(pContext->EffectType == LVM_BASS_BOOST){\n                android::BassSetStrength(pContext, 0);\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n                android::VirtualizerSetStrength(pContext, 0);\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n                android::EqualizerSetPreset(pContext, 0);\n }\n if(pContext->EffectType == LVM_VOLUME){\n *(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);\n }\n break;\n\n \n         case EFFECT_CMD_SET_CONFIG:\n            if (pCmdData    == NULL||\n                cmdSize     != sizeof(effect_config_t)||\n                pReplyData  == NULL||\n                *replySize  != sizeof(int)){\n                 ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                         \"EFFECT_CMD_SET_CONFIG: ERROR\");\n                 return -EINVAL;\n }\n *(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);\n\n             break;\n \n         case EFFECT_CMD_GET_CONFIG:\n            if (pReplyData == NULL ||\n                *replySize != sizeof(effect_config_t)) {\n                 ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                         \"EFFECT_CMD_GET_CONFIG: ERROR\");\n                 return -EINVAL;\n }\n\n            android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n            android::Effect_setConfig(pContext, &pContext->config);\n break;\n\n\n         case EFFECT_CMD_GET_PARAM:{\n \n             if(pContext->EffectType == LVM_BASS_BOOST){\n                if (pCmdData == NULL ||\n                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL ||\n                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n                            \"EFFECT_CMD_GET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *)pCmdData;\n                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n                p = (effect_param_t *)pReplyData;\n                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n                 p->status = android::BassBoost_getParameter(pContext,\n                                                             p->data,\n                                                             &p->vsize,\n                                                             p->data + voffset);\n                *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n             }\n \n             if(pContext->EffectType == LVM_VIRTUALIZER){\n                if (pCmdData == NULL ||\n                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL ||\n                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_GET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *)pCmdData;\n                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n                p = (effect_param_t *)pReplyData;\n                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n                 p->status = android::Virtualizer_getParameter(pContext,\n                                                               (void *)p->data,\n                                                               &p->vsize,\n                                                               p->data + voffset);\n                *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n \n }\n\n             if(pContext->EffectType == LVM_EQUALIZER){\n                if (pCmdData == NULL ||\n                    cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                    pReplyData == NULL ||\n                    *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))) {\n                    ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_GET_PARAM\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *)pCmdData;\n                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n                p = (effect_param_t *)pReplyData;\n                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n                 p->status = android::Equalizer_getParameter(pContext,\n                                                             p->data,\n                                                             &p->vsize,\n                                                             p->data + voffset);\n \n                *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n             }\n             if(pContext->EffectType == LVM_VOLUME){\n                if (pCmdData == NULL ||\n                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL ||\n                        *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){\n                    ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"\n                            \"EFFECT_CMD_GET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *)pCmdData;\n                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n                p = (effect_param_t *)pReplyData;\n                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n                 p->status = android::Volume_getParameter(pContext,\n                                                          (void *)p->data,\n                                                          &p->vsize,\n                                                          p->data + voffset);\n \n                *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n             }\n         } break;\n         case EFFECT_CMD_SET_PARAM:{\n if(pContext->EffectType == LVM_BASS_BOOST){\n\n \n                if (pCmdData   == NULL||\n                    cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t))||\n                    pReplyData == NULL||\n                    *replySize != sizeof(int32_t)){\n                     ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n                             \"EFFECT_CMD_SET_PARAM: ERROR\");\n                     return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::BassBoost_setParameter(pContext,\n (void *)p->data,\n                                                                    p->data + p->psize);\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n\n \n                 if (pCmdData   == NULL ||\n                    cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||\n                    cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                    pReplyData == NULL ||\n                    *replySize != sizeof(int32_t)){\n                     ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n                             \"EFFECT_CMD_SET_PARAM: ERROR\");\n                     return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::Virtualizer_setParameter(pContext,\n (void *)p->data,\n                                                                       p->data + p->psize);\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n\n \n                 if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                    pReplyData == NULL || *replySize != sizeof(int32_t)) {\n                     ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"\n                             \"EFFECT_CMD_SET_PARAM: ERROR\");\n                     return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n *(int *)pReplyData = android::Equalizer_setParameter(pContext,\n (void *)p->data,\n                                                                     p->data + p->psize);\n }\n if(pContext->EffectType == LVM_VOLUME){\n\n \n                if (    pCmdData   == NULL||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t))||\n                        pReplyData == NULL||\n                        *replySize != sizeof(int32_t)){\n                     ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"\n                             \"EFFECT_CMD_SET_PARAM: ERROR\");\n                     return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n *(int *)pReplyData = android::Volume_setParameter(pContext,\n (void *)p->data,\n                                                                 p->data + p->psize);\n }\n } break;\n\n \n         case EFFECT_CMD_ENABLE:\n             ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start\");\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                 ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR\");\n                 return -EINVAL;\n             }\n\n *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);\n break;\n\n \n         case EFFECT_CMD_DISABLE:\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                 ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR\");\n                 return -EINVAL;\n             }\n *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);\n break;\n\n\n         case EFFECT_CMD_SET_DEVICE:\n         {\n             ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start\");\n             uint32_t device = *(uint32_t *)pCmdData;\n             pContext->pBundledContext->nOutputDevice = (audio_devices_t) device;\n \n if (pContext->EffectType == LVM_BASS_BOOST) {\n if((device == AUDIO_DEVICE_OUT_SPEAKER) ||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST\");\n\n\n if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;\n } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n\n\n if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;\n }\n }\n if (pContext->EffectType == LVM_VIRTUALIZER) {\n if (pContext->pBundledContext->nVirtualizerForcedDevice == AUDIO_DEVICE_NONE) {\n if (android::VirtualizerIsDeviceSupported(device) != 0) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER\");\n\n\n if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {\n                            ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                            android::LvmEffect_disable(pContext);\n }\n                        pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;\n } else {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n\n\n if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){\n                            ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                            android::LvmEffect_enable(pContext);\n }\n                        pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;\n }\n } \n }\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end\");\n break;\n }\n case EFFECT_CMD_SET_VOLUME:\n {\n uint32_t leftVolume, rightVolume;\n int16_t  leftdB, rightdB;\n int16_t  maxdB, pandB;\n int32_t  vol_ret[2] = {1<<24,1<<24}; \n int      status = 0;\n LVM_ControlParams_t ActiveParams; \n            LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; \n\n if(pReplyData == LVM_NULL){\n\n                 break;\n             }\n \n            if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                 ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                         \"EFFECT_CMD_SET_VOLUME: ERROR\");\n                 return -EINVAL;\n }\n\n            leftVolume  = ((*(uint32_t *)pCmdData));\n            rightVolume = ((*((uint32_t *)pCmdData + 1)));\n\n if(leftVolume == 0x1000000){\n                leftVolume -= 1;\n }\n if(rightVolume == 0x1000000){\n                rightVolume -= 1;\n }\n\n            leftdB  = android::LVC_Convert_VolToDb(leftVolume);\n            rightdB = android::LVC_Convert_VolToDb(rightVolume);\n\n            pandB = rightdB - leftdB;\n\n            maxdB = leftdB;\n if(rightdB > maxdB){\n                maxdB = rightdB;\n }\n\n            memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);\n            android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));\n\n LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_GetControlParameters\", \"VolumeSetStereoPosition\")\n if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n\n ActiveParams.VC_Balance  = pandB;\n            ALOGV(\"\\t\\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\\n\", ActiveParams.VC_Balance );\n\n LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_SetControlParameters\", \"VolumeSetStereoPosition\")\n if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n break;\n }\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n default:\n return -EINVAL;\n }\n\n return 0;\n} \n", "target": 1, "flaw_line_index": "43,71,72,73,74,85,86,106,107,108,109,110,111,112,113,114,115,116,117,122,132,133,134,135,136,137,138,139,140,141,142,143,148,160,161,162,163,164,165,166,167,168,169,170,171,177,188,189,190,191,192,193,194,195,196,197,198,199,205,223,224,225,226,259,260,261,262,263,297,316,317,318,319,336,347"}
{"idx": 8385, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n{\n    DeviceState *d = DEVICE(dev);\n    MPTSASState *s = MPT_SAS(dev);\n    Error *err = NULL;\n    int ret;\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n        ret = msi_init(dev, 0, 1, true, false, &err);\n        assert(!ret || ret == -ENOTSUP);\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n                    \"msi=off with this machine type.\\n\");\n            error_propagate(errp, err);\n            return;\n        }\n        assert(!err || s->msi == ON_OFF_AUTO_AUTO);\n        error_free(err);\n\n        s->msi_in_use = (ret == 0);\n    }\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n                          \"mptsas-mmio\", 0x4000);\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n                          \"mptsas-io\", 256);\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n                          \"mptsas-diag\", 0x10000);\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n    if (!s->sas_addr) {\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n    }\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n    QTAILQ_INIT(&s->pending);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n    if (!d->hotplugged) {\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187833, "func": " bool Cues::Find(long long time_ns, const Track* pTrack, const CuePoint*& pCP,\n                 const CuePoint::TrackPosition*& pTP) const {\n  assert(time_ns >= 0);\n  assert(pTrack);\n#if 0\n    LoadCuePoint();  \n    assert(m_cue_points);\n    assert(m_count > 0);\n    CuePoint** const ii = m_cue_points;\n    CuePoint** i = ii;\n    CuePoint** const jj = ii + m_count + m_preload_count;\n    CuePoint** j = jj;\n    pCP = *i;\n    assert(pCP);\n    if (time_ns <= pCP->GetTime(m_pSegment))\n    {\n        pTP = pCP->Find(pTrack);\n        return (pTP != NULL);\n    }\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    while (i < j)\n    {\n        CuePoint** const k = i + (j - i) / 2;\n        assert(k < jj);\n        CuePoint* const pCP = *k;\n        assert(pCP);\n        pCP->Load(pReader);\n        const long long t = pCP->GetTime(m_pSegment);\n        if (t <= time_ns)\n            i = k + 1;\n        else\n            j = k;\n        assert(i <= j);\n    }\n    assert(i == j);\n    assert(i <= jj);\n    assert(i > ii);\n    pCP = *--i;\n    assert(pCP);\n    assert(pCP->GetTime(m_pSegment) <= time_ns);\n#else\n  if (m_cue_points == NULL)\n    return false;\n  if (m_count == 0)\n     return false;\n \n   CuePoint** const ii = m_cue_points;\n CuePoint** i = ii;\n\n CuePoint** const jj = ii + m_count;\n\n   CuePoint** j = jj;\n \n   pCP = *i;\n  assert(pCP);\n \n   if (time_ns <= pCP->GetTime(m_pSegment)) {\n     pTP = pCP->Find(pTrack);\n return (pTP != NULL);\n }\n\n while (i < j) {\n\n \n     CuePoint** const k = i + (j - i) / 2;\n    assert(k < jj);\n \n     CuePoint* const pCP = *k;\n    assert(pCP);\n \n     const long long t = pCP->GetTime(m_pSegment);\n \n if (t <= time_ns)\n      i = k + 1;\n\n     else\n       j = k;\n \n    assert(i <= j);\n   }\n \n  assert(i == j);\n  assert(i <= jj);\n  assert(i > ii);\n \n   pCP = *--i;\n  assert(pCP);\n  assert(pCP->GetTime(m_pSegment) <= time_ns);\n#endif\n \n\n  pTP = pCP->Find(pTrack);\n\n   return (pTP != NULL);\n }\n", "target": 1, "flaw_line_index": "3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,59,74,77,87,90,91,92,95,96"}
{"idx": 187588, "func": "print_pixel(png_structp png_ptr, png_infop info_ptr, png_const_bytep row,\n   png_uint_32 x)\n{\n   PNG_CONST unsigned int bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n\n switch (png_get_color_type(png_ptr, info_ptr))\n {\n case PNG_COLOR_TYPE_GRAY:\n         printf(\"GRAY %u\\n\", component(row, x, 0, bit_depth, 1));\n return;\n\n       case PNG_COLOR_TYPE_PALETTE:\n          {\n            PNG_CONST unsigned int index = component(row, x, 0, bit_depth, 1);\n             png_colorp palette = NULL;\n             int num_palette = 0;\n \n if ((png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette) &\n               PNG_INFO_PLTE) && num_palette > 0 && palette != NULL)\n {\n               png_bytep trans_alpha = NULL;\n int num_trans = 0;\n if ((png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans,\n                  NULL) & PNG_INFO_tRNS) && num_trans > 0 &&\n                  trans_alpha != NULL)\n                  printf(\"INDEXED %u = %d %d %d %d\\n\", index,\n                     palette[index].red, palette[index].green,\n                     palette[index].blue,\n                     index < num_trans ? trans_alpha[index] : 255);\n\n else \n                  printf(\"INDEXED %u = %d %d %d\\n\", index,\n                     palette[index].red, palette[index].green,\n                     palette[index].blue);\n }\n\n else\n               printf(\"INDEXED %u = invalid index\\n\", index);\n }\n return;\n\n case PNG_COLOR_TYPE_RGB:\n         printf(\"RGB %u %u %u\\n\", component(row, x, 0, bit_depth, 3),\n            component(row, x, 1, bit_depth, 3),\n            component(row, x, 2, bit_depth, 3));\n return;\n\n case PNG_COLOR_TYPE_GRAY_ALPHA:\n         printf(\"GRAY+ALPHA %u %u\\n\", component(row, x, 0, bit_depth, 2),\n            component(row, x, 1, bit_depth, 2));\n return;\n\n case PNG_COLOR_TYPE_RGB_ALPHA:\n         printf(\"RGBA %u %u %u %u\\n\", component(row, x, 0, bit_depth, 4),\n            component(row, x, 1, bit_depth, 4),\n            component(row, x, 2, bit_depth, 4),\n            component(row, x, 3, bit_depth, 4));\n return;\n\n default:\n         png_error(png_ptr, \"pngpixel: invalid color type\");\n }\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 188201, "func": "void SoftAVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (NULL == mCodecCtx) {\n if (OK != initDecoder()) {\n            ALOGE(\"Failed to initialize decoder\");\n            notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);\n            mSignalledError = true;\n return;\n }\n }\n if (outputBufferWidth() != mStride) {\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n                    inQueue.erase(inQueue.begin());\n                    inInfo->mOwnedByUs = false;\n continue;\n }\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL) {\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n\n if (!(inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n continue;\n }\n\n                mReceivedEOS = true;\n                inHeader = NULL;\n                setFlushMode();\n } else if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mReceivedEOS = true;\n }\n }\n\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n             DUMP_TO_FILE(mInFile, s_dec_ip.pv_stream_buffer, s_dec_ip.u4_num_Bytes);\n \n            GETTIME(&mTimeStart, NULL);\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool unsupportedResolution =\n (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == (s_dec_op.u4_error_code & 0xFF));\n\n if (unsupportedResolution) {\n                ALOGE(\"Unsupported resolution : %dx%d\", mWidth, mHeight);\n                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n bool allocationFailed = (IVD_MEM_ALLOC_FAILED == (s_dec_op.u4_error_code & 0xFF));\n if (allocationFailed) {\n                ALOGE(\"Allocation failure in decoder\");\n                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            PRINT_TIME(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n                mIsInFlush = false;\n\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n", "target": 1, "flaw_line_index": "103"}
{"idx": 187475, "func": "void btsock_l2cap_signaled(int fd, int flags, uint32_t user_id)\n{\n    l2cap_socket *sock;\n char drop_it = FALSE;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(user_id);\n if (sock) {\n if ((flags & SOCK_THREAD_FD_RD) && !sock->server) {\n\n             if (sock->connected) {\n                 int size = 0;\n \n                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(sock->our_fd, FIONREAD, &size)\n                         == 0 && size)) {\n                     uint8_t *buffer = osi_malloc(L2CAP_MAX_SDU_LENGTH);\n if (buffer != NULL) {\n \n                        int count = recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,\n                                MSG_NOSIGNAL | MSG_DONTWAIT);\n                         APPL_TRACE_DEBUG(\"btsock_l2cap_signaled - %d bytes received from socket\",\n                                 count);\n                         if (sock->fixed_chan) {\n if(BTA_JvL2capWriteFixed(sock->channel, (BD_ADDR*)&sock->addr,\n (UINT32)buffer, btsock_l2cap_cbk, buffer, count,\n (void *)user_id) != BTA_JV_SUCCESS) {\n                                on_l2cap_write_fixed_done(buffer, user_id);\n }\n } else {\n if(BTA_JvL2capWrite(sock->handle, (UINT32)buffer, buffer, count,\n (void *)user_id) != BTA_JV_SUCCESS) {\n                                on_l2cap_write_done(buffer, user_id);\n }\n }\n } else {\n                        APPL_TRACE_ERROR(\"Unable to allocate memory for data packet from JAVA...\")\n }\n }\n } else\n                drop_it = TRUE;\n }\n if (flags & SOCK_THREAD_FD_WR) {\n if (flush_incoming_que_on_wr_signal_l(sock) && sock->connected)\n                btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_WR, sock->id);\n\n         }\n         if (drop_it || (flags & SOCK_THREAD_FD_EXCEPTION)) {\n             int size = 0;\n            if (drop_it || ioctl(sock->our_fd, FIONREAD, &size) != 0 || size == 0)\n                 btsock_l2cap_free_l(sock);\n         }\n     }\n    pthread_mutex_unlock(&state_lock);\n}\n", "target": 1, "flaw_line_index": "15,21,22,55"}
{"idx": 187680, "func": " init_validate_info(validate_info *vi, gamma_display *dp, png_const_structp pp,\n     int in_depth, int out_depth)\n {\n   PNG_CONST unsigned int outmax = (1U<<out_depth)-1;\n \n    vi->pp = pp;\n    vi->dp = dp;\n\n if (dp->sbit > 0 && dp->sbit < in_depth)\n {\n      vi->sbit = dp->sbit;\n      vi->isbit_shift = in_depth - dp->sbit;\n }\n\n else\n {\n      vi->sbit = (png_byte)in_depth;\n      vi->isbit_shift = 0;\n }\n\n   vi->sbit_max = (1U << vi->sbit)-1;\n\n   vi->screen_gamma = dp->screen_gamma;\n if (fabs(vi->screen_gamma-1) < PNG_GAMMA_THRESHOLD)\n      vi->screen_gamma = vi->screen_inverse = 0;\n else\n      vi->screen_inverse = 1/vi->screen_gamma;\n\n   vi->use_input_precision = dp->use_input_precision;\n   vi->outmax = outmax;\n   vi->maxabs = abserr(dp->pm, in_depth, out_depth);\n   vi->maxpc = pcerr(dp->pm, in_depth, out_depth);\n   vi->maxcalc = calcerr(dp->pm, in_depth, out_depth);\n   vi->maxout = outerr(dp->pm, in_depth, out_depth);\n   vi->outquant = output_quantization_factor(dp->pm, in_depth, out_depth);\n   vi->maxout_total = vi->maxout + vi->outquant * .5;\n\n    vi->outlog = outlog(dp->pm, in_depth, out_depth);\n \n    if ((dp->this.colour_type & PNG_COLOR_MASK_ALPHA) != 0 ||\n      (dp->this.colour_type == 3 && dp->this.is_transparent))\n    {\n       vi->do_background = dp->do_background;\n \n       if (vi->do_background != 0)\n       {\n         PNG_CONST double bg_inverse = 1/dp->background_gamma;\n          double r, g, b;\n \n         r = dp->background_color.red; r /= outmax;\n         g = dp->background_color.green; g /= outmax;\n         b = dp->background_color.blue; b /= outmax;\n\n#     if 0\n if (fabs(bg_inverse-1) >= PNG_GAMMA_THRESHOLD)\n#     endif\n {\n            r = pow(r, bg_inverse);\n            g = pow(g, bg_inverse);\n            b = pow(b, bg_inverse);\n }\n\n         vi->background_red = r;\n         vi->background_green = g;\n\n          vi->background_blue = b;\n       }\n    }\n   else\n       vi->do_background = 0;\n \n    if (vi->do_background == 0)\n      vi->background_red = vi->background_green = vi->background_blue = 0;\n\n   vi->gamma_correction = 1/(dp->file_gamma*dp->screen_gamma);\n if (fabs(vi->gamma_correction-1) < PNG_GAMMA_THRESHOLD)\n      vi->gamma_correction = 0;\n\n   vi->file_inverse = 1/dp->file_gamma;\n if (fabs(vi->file_inverse-1) < PNG_GAMMA_THRESHOLD)\n      vi->file_inverse = 0;\n\n   vi->scale16 = dp->scale16;\n}\n", "target": 1, "flaw_line_index": "4,41,47,69"}
{"idx": 188438, "func": "long Cluster::ParseBlockGroup(\n    long long payload_size,\n    long long& pos,\n    long& len)\n{\n    const long long payload_start = pos;\n    const long long payload_stop = pos + payload_size;\n \n    IMkvReader* const pReader = m_pSegment->m_pReader;\n \n    long long total, avail;\n \n    long status = pReader->Length(&total, &avail);\n \n    if (status < 0)  \n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    if ((total >= 0) && (payload_stop > total))\n        return E_FILE_FORMAT_INVALID;\n \n    if (payload_stop > avail)\n    {\n         len = static_cast<long>(payload_size);\n         return E_BUFFER_NOT_FULL;\n     }\n \n    long long discard_padding = 0;\n \n    while (pos < payload_stop)\n    {\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  \n            return static_cast<long>(result);\n \n        if (result > 0)  \n            return E_BUFFER_NOT_FULL;\n \n        if ((pos + len) > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long id = ReadUInt(pReader, pos, len);\n \n        if (id < 0) \n            return static_cast<long>(id);\n \n        if (id == 0)  \n            return E_FILE_FORMAT_INVALID;\n \n        pos += len;  \n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  \n            return static_cast<long>(result);\n \n        if (result > 0)  \n            return E_BUFFER_NOT_FULL;\n \n        if ((pos + len) > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long size = ReadUInt(pReader, pos, len);\n \n        if (size < 0)  \n            return static_cast<long>(size);\n \n        pos += len;  \n \n \n        if (pos > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if (size == 0)  \n            continue;\n \n        const long long unknown_size = (1LL << (7 * len)) - 1;\n \n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n \n        if (id == 0x35A2)  \n        {\n            result = GetUIntLength(pReader, pos, len);\n \n            if (result < 0)  \n                return static_cast<long>(result);\n \n            status = UnserializeInt(pReader, pos, len, discard_padding);\n \n            if (status < 0)  \n                return status;\n        }\n \n        if (id != 0x21)  \n        {\n            pos += size;  \n \n            if (pos > payload_stop)\n                return E_FILE_FORMAT_INVALID;\n \n            continue;\n        }\n \n        const long long block_stop = pos + size;\n \n        if (block_stop > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  \n            return static_cast<long>(result);\n \n        if (result > 0)  \n            return E_BUFFER_NOT_FULL;\n        if ((pos + len) > block_stop)\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long track = ReadUInt(pReader, pos, len);\n        if (track < 0) \n            return static_cast<long>(track);\n        if (track == 0)\n            return E_FILE_FORMAT_INVALID;\n \n #if 0\n\n const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n\n const long tn = static_cast<long>(track);\n\n const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n\n if (pTrack == NULL)\n\n             return E_FILE_FORMAT_INVALID;\n #endif\n \n        pos += len;  \n \n        if ((pos + 2) > block_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + 2) > avail)\n        {\n            len = 2;\n            return E_BUFFER_NOT_FULL;\n        }\n        pos += 2;  \n        if ((pos + 1) > block_stop)\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        unsigned char flags;\n        status = pReader->Read(pos, 1, &flags);\n        if (status < 0)  \n        {\n            len = 1;\n            return status;\n        }\n        ++pos;  \n        assert(pos <= avail);\n        if (pos >= block_stop)\n            return E_FILE_FORMAT_INVALID;\n        const int lacing = int(flags & 0x06) >> 1;\n        if ((lacing != 0) && (block_stop > avail))\n        {\n            len = static_cast<long>(block_stop - pos);\n            return E_BUFFER_NOT_FULL;\n        }\n        pos = block_stop;  \n        assert(pos <= payload_stop);\n     }\n \n    assert(pos == payload_stop);\n \n    status = CreateBlock(0x20,  \n                         payload_start, payload_size,\n                         discard_padding);\n    if (status != 0)\n        return status;\n \n    m_pos = payload_stop;\n    return 0;  \n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,9,11,13,15,16,18,20,21,23,24,25,26,29,31,32,33,35,36,37,38,39,41,43,44,46,47,49,50,52,53,55,57,58,60,61,63,65,67,68,69,70,71,73,75,76,78,79,81,82,84,85,87,89,90,92,94,96,97,99,100,102,104,105,107,108,109,111,112,114,116,117,118,120,121,122,124,125,127,128,130,132,133,135,137,138,139,140,141,143,145,146,148,149,150,151,152,153,154,155,156,157,158,191,193,194,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220"}
{"idx": 187587, "func": "png_have_neon(png_structp png_ptr)\n{\n FILE *f = fopen(\"/proc/cpuinfo\", \"rb\");\n\n if (f != NULL)\n {\n static const char ch_feature[] = { 70, 69, 65, 84, 85, 82, 69, 83 };\n static const char ch_neon[] = { 78, 69, 79, 78 };\n\n enum\n {\n StartLine, Feature, Colon, StartTag, Neon, HaveNeon, SkipTag, SkipLine\n }  state;\n int counter;\n\n for (state=StartLine, counter=0;;)\n {\n int ch = fgetc(f);\n\n if (ch == EOF)\n {\n            fclose(f);\n return 0;\n }\n\n switch (state)\n {\n case StartLine:\n if (ch <= 32) \n break;\n\n               counter=0;\n               state = Feature;\n\n case Feature:\n if ((ch & ~0x20) == ch_feature[counter])\n {\n if (++counter == (sizeof ch_feature))\n\n                      state = Colon;\n                   break;\n                }\n                state = SkipLine;\n\n case SkipLine:\n            skipLine:\n if (ch != 10 && ch != 13)\n break;\n\n               state = StartLine;\n break;\n\n case Colon:\n if (ch == 32 || ch == 9)\n break;\n\n if (ch == 58) \n {\n                  state = StartTag;\n break;\n }\n\n               state = SkipLine;\n goto skipLine;\n\n case StartTag:\n if (ch == 32 || ch == 9)\n break;\n\n               state = Neon;\n               counter = 0;\n\n case Neon:\n if ((ch & ~0x20) == ch_neon[counter])\n {\n if (++counter == (sizeof ch_neon))\n                     state = HaveNeon;\n break;\n }\n\n               state = SkipTag;\n\n case SkipTag:\n if (ch == 10 || ch == 13)\n                  state = StartLine;\n\n else if (ch == 32 || ch == 9)\n                  state = StartTag;\n break;\n\n case HaveNeon:\n if (ch == 10 || ch == 13 || ch == 32 || ch == 9)\n {\n                  fclose(f);\n return 1;\n }\n\n               state = SkipTag;\n break;\n\n default:\n               png_error(png_ptr, \"png_have_neon: internal error (bug)\");\n }\n\n       }\n    }\n \n    else\n       png_warning(png_ptr, \"/proc/cpuinfo open failed\");\n \n    return 0;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188520, "func": " int main(int argc, char **argv) {\n FILE *infile = NULL;\n vpx_codec_ctx_t codec = {0};\n vpx_codec_enc_cfg_t cfg = {0};\n int frame_count = 0;\n vpx_image_t raw;\n vpx_codec_err_t res;\n VpxVideoInfo info = {0};\n VpxVideoWriter *writer = NULL;\n const VpxInterface *encoder = NULL;\n int update_frame_num = 0;\n const int fps = 30; \n const int bitrate = 200; \n\n  exec_name = argv[0];\n\n if (argc != 6)\n    die(\"Invalid number of arguments\");\n\n  encoder = get_vpx_encoder_by_name(\"vp8\");\n if (!encoder)\n    die(\"Unsupported codec.\");\n\n  update_frame_num = atoi(argv[5]);\n if (!update_frame_num)\n    die(\"Couldn't parse frame number '%s'\\n\", argv[5]);\n\n  info.codec_fourcc = encoder->fourcc;\n  info.frame_width = strtol(argv[1], NULL, 0);\n  info.frame_height = strtol(argv[2], NULL, 0);\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n\n if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n (info.frame_width % 2) != 0 ||\n (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n }\n\n if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n\n     die(\"Failed to allocate image.\");\n   }\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n \n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n  cfg.rc_target_bitrate = bitrate;\n\n  writer = vpx_video_writer_open(argv[4], kContainerIVF, &info);\n if (!writer)\n    die(\"Failed to open %s for writing.\", argv[4]);\n\n\n   if (!(infile = fopen(argv[3], \"rb\")))\n     die(\"Failed to open %s for reading.\", argv[3]);\n \n  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n     die_codec(&codec, \"Failed to initialize encoder\");\n \n   while (vpx_img_read(&raw, infile)) {\n     if (frame_count + 1 == update_frame_num) {\n       vpx_ref_frame_t ref;\n      ref.frame_type = VP8_LAST_FRAME;\n      ref.img = raw;\n if (vpx_codec_control(&codec, VP8_SET_REFERENCE, &ref))\n        die_codec(&codec, \"Failed to set reference frame\");\n }\n\n \n     encode_frame(&codec, &raw, frame_count++, writer);\n   }\n  encode_frame(&codec, NULL, -1, writer);\n \n   printf(\"\\n\");\n   fclose(infile);\n  printf(\"Processed %d frames.\\n\", frame_count);\n\n  vpx_img_free(&raw);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_writer_close(writer);\n\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "48,50,68,83"}
{"idx": 187917, "func": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n const size_t kGroupSize = 12;\n const size_t kStartCharCodeOffset = 0;\n const size_t kEndCharCodeOffset = 4;\n const size_t kMaxNGroups = 0xfffffff0 / kGroupSize; \n if (kFirstGroupOffset > size) {\n return false;\n\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n     if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {\n uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n\n         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n         if (end < start) {\n             return false;\n         }\n         addRange(coverage, start, end + 1);  \n }\n return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8530, "func": "static Bignum ssh1_pkt_getmp(struct Packet *pkt)\n{\n    int j;\n    Bignum b;\n\n    j = ssh1_read_bignum(pkt->body + pkt->savedpos,\n\t\t\t pkt->length - pkt->savedpos, &b);\n\n    if (j < 0)\n\treturn NULL;\n\n    pkt->savedpos += j;\n    return b;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8875, "func": "static void vrend_hw_emit_streamout_targets(struct vrend_context *ctx, struct vrend_streamout_object *so_obj)\n{\n   int i;\n\n   for (i = 0; i < so_obj->num_targets; i++) {\n      if (so_obj->so_targets[i]->buffer_offset || so_obj->so_targets[i]->buffer_size < so_obj->so_targets[i]->buffer->base.width0)\n         glBindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER, i, so_obj->so_targets[i]->buffer->id, so_obj->so_targets[i]->buffer_offset, so_obj->so_targets[i]->buffer_size);\n      else\n         glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, i, so_obj->so_targets[i]->buffer->id);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8890, "func": "void vrend_renderer_blit(struct vrend_context *ctx,\n                         uint32_t dst_handle, uint32_t src_handle,\n                         const struct pipe_blit_info *info)\n{\n   struct vrend_resource *src_res, *dst_res;\n   src_res = vrend_renderer_ctx_res_lookup(ctx, src_handle);\n   dst_res = vrend_renderer_ctx_res_lookup(ctx, dst_handle);\n\n   if (!src_res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, src_handle);\n      return;\n   }\n   if (!dst_res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, dst_handle);\n      return;\n   }\n\n   if (ctx->in_error)\n      return;\n\n   if (info->render_condition_enable == false)\n      vrend_pause_render_condition(ctx, true);\n\n   vrend_renderer_blit_int(ctx, src_res, dst_res, info);\n\n   if (info->render_condition_enable == false)\n      vrend_pause_render_condition(ctx, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187506, "func": " socket_t *socket_accept(const socket_t *socket) {\n   assert(socket != NULL);\n \n  int fd = accept(socket->fd, NULL, NULL);\n   if (fd == INVALID_FD) {\n     LOG_ERROR(\"%s unable to accept socket: %s\", __func__, strerror(errno));\n     return NULL;\n }\n\n socket_t *ret = (socket_t *)osi_calloc(sizeof(socket_t));\n if (!ret) {\n    close(fd);\n    LOG_ERROR(\"%s unable to allocate memory for socket.\", __func__);\n return NULL;\n }\n\n  ret->fd = fd;\n return ret;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8709, "func": "url_escape_allow_passthrough (const char *s)\n{\n  return url_escape_1 (s, urlchr_unsafe, true);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187713, "func": " safecat_current_encoding(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST png_modifier *pm)\n {\n    pos = safecat_color_encoding(buffer, bufsize, pos, pm->current_encoding,\n       pm->current_gamma);\n\n if (pm->encoding_ignored)\n      pos = safecat(buffer, bufsize, pos, \"[overridden]\");\n\n \n    return pos;\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8635, "func": "static void xilinx_ethlite_reset(DeviceState *dev)\n{\n    struct xlx_ethlite *s = XILINX_ETHLITE(dev);\n\n    s->rxbuf = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187511, "func": " static void msleep(uint64_t ms) {\n  usleep(ms * 1000);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187731, "func": "test_size(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,\n    int bdlo, int PNG_CONST bdhi)\n {\n   static PNG_CONST png_byte hinc[] = {1, 3, 11, 1, 5};\n   static PNG_CONST png_byte winc[] = {1, 9, 5, 7, 1};\n    for (; bdlo <= bdhi; ++bdlo)\n    {\n       png_uint_32 h, w;\n\n for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo])\n {\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0\n,\n            PNG_INTERLACE_NONE, w, h, 0), 0\n,\n            pm->use_update_info);\n\n if (fail(pm))\n return 0;\n\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0\n,\n            PNG_INTERLACE_NONE, w, h, 1), 0\n,\n            pm->use_update_info);\n\n\n          if (fail(pm))\n             return 0;\n \n#     ifdef PNG_WRITE_INTERLACING_SUPPORTED\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0\n,\n            PNG_INTERLACE_ADAM7, w, h, 0), 0\n,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0\n,\n            PNG_INTERLACE_ADAM7, w, h, 1), 0\n,\n            pm->use_update_info);\n         if (fail(pm))\n            return 0;\n#     endif\n         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0\n,\n            PNG_INTERLACE_NONE, w, h, 0), 1\n,\n            pm->use_update_info);\n\n\n          if (fail(pm))\n             return 0;\n \n #     ifdef PNG_WRITE_INTERLACING_SUPPORTED\n          standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0\n,\n             PNG_INTERLACE_ADAM7, w, h, 0), 1\n,\n             pm->use_update_info);\n\n\n          if (fail(pm))\n             return 0;\n #     endif\n       }\n    }\n \n return 1; \n}\n", "target": 1, "flaw_line_index": "2,4,5,31,33,35,36,37,38,40,42,43,44,45,46"}
{"idx": 8918, "func": "void vrend_renderer_resource_unref(uint32_t res_handle)\n{\n   struct vrend_resource *res;\n   struct vrend_context *ctx;\n\n   res = vrend_resource_lookup(res_handle, 0);\n   if (!res)\n      return;\n\n\n   LIST_FOR_EACH_ENTRY(ctx, &vrend_state.active_ctx_list, ctx_entry) {\n      vrend_renderer_detach_res_ctx_p(ctx, res->handle);\n   }\n\n   vrend_resource_remove(res->handle);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8803, "func": "static GLenum get_xfb_mode(GLenum mode)\n{\n   switch (mode) {\n   case GL_POINTS:\n      return GL_POINTS;\n   case GL_TRIANGLES:\n   case GL_TRIANGLE_STRIP:\n   case GL_TRIANGLE_FAN:\n   case GL_QUADS:\n   case GL_QUAD_STRIP:\n   case GL_POLYGON:\n      return GL_TRIANGLES;\n   case GL_LINES:\n   case GL_LINE_LOOP:\n   case GL_LINE_STRIP:\n      return GL_LINES;\n   default:\n      fprintf(stderr, \"failed to translate TFB %d\\n\", mode);\n      return GL_POINTS;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188000, "func": "static int Downmix_Command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n downmix_module_t *pDwmModule = (downmix_module_t *) self;\n downmix_object_t *pDownmixer;\n\n if (pDwmModule == NULL || pDwmModule->context.state == DOWNMIX_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n    pDownmixer = (downmix_object_t*) &pDwmModule->context;\n\n    ALOGV(\"Downmix_Command command %\" PRIu32 \" cmdSize %\" PRIu32, cmdCode, cmdSize);\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Downmix_Init(pDwmModule);\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Downmix_Configure(pDwmModule,\n (effect_config_t *)pCmdData, false);\n break;\n\n case EFFECT_CMD_RESET:\n Downmix_Reset(pDownmixer, false);\n break;\n\n case EFFECT_CMD_GET_PARAM:\n        ALOGV(\"Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %\" PRIu32 \", pReplyData: %p\",\n                pCmdData, *replySize, pReplyData);\n if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||\n                pReplyData == NULL || replySize == NULL ||\n *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {\n return -EINVAL;\n }\n effect_param_t *rep = (effect_param_t *) pReplyData;\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(int32_t));\n        ALOGV(\"Downmix_Command EFFECT_CMD_GET_PARAM param %\" PRId32 \", replySize %\" PRIu32,\n *(int32_t *)rep->data, rep->vsize);\n        rep->status = Downmix_getParameter(pDownmixer, *(int32_t *)rep->data, &rep->vsize,\n                rep->data + sizeof(int32_t));\n *replySize = sizeof(effect_param_t) + sizeof(int32_t) + rep->vsize;\n break;\n\n case EFFECT_CMD_SET_PARAM:\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %\" PRIu32\n \", pReplyData %p\", cmdSize, pCmdData, *replySize, pReplyData);\n if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))\n || pReplyData == NULL || replySize == NULL || *replySize != (int)sizeof(int32_t)) {\n\n             return -EINVAL;\n         }\n         effect_param_t *cmd = (effect_param_t *) pCmdData;\n         *(int *)pReplyData = Downmix_setParameter(pDownmixer, *(int32_t *)cmd->data,\n                 cmd->vsize, cmd->data + sizeof(int32_t));\n         break;\n\n case EFFECT_CMD_SET_PARAM_DEFERRED:\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_PARAM_DEFERRED not supported, FIXME\");\n break;\n\n case EFFECT_CMD_SET_PARAM_COMMIT:\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_PARAM_COMMIT not supported, FIXME\");\n break;\n\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pDownmixer->state = DOWNMIX_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pDownmixer->state = DOWNMIX_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {\n return -EINVAL;\n }\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_DEVICE: 0x%08\" PRIx32, *(uint32_t *)pCmdData);\n break;\n\n case EFFECT_CMD_SET_VOLUME: {\n if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t) * 2) {\n return -EINVAL;\n }\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_VOLUME not supported, FIXME\");\n float left = (float)(*(uint32_t *)pCmdData) / (1 << 24);\n float right = (float)(*((uint32_t *)pCmdData + 1)) / (1 << 24);\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_VOLUME: left %f, right %f \", left, right);\n break;\n }\n\n case EFFECT_CMD_SET_AUDIO_MODE:\n if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {\n return -EINVAL;\n }\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_AUDIO_MODE: %\" PRIu32, *(uint32_t *)pCmdData);\n break;\n\n case EFFECT_CMD_SET_CONFIG_REVERSE:\n case EFFECT_CMD_SET_INPUT_DEVICE:\n break;\n\n default:\n        ALOGW(\"Downmix_Command invalid command %\" PRIu32, cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187835, "func": " const BlockEntry* Cues::GetBlock(const CuePoint* pCP,\n                                  const CuePoint::TrackPosition* pTP) const {\n  if (pCP == NULL)\n    return NULL;\n  if (pTP == NULL)\n     return NULL;\n \n   return m_pSegment->GetBlock(*pCP, *pTP);\n}\n", "target": 1, "flaw_line_index": "3,4,5"}
{"idx": 187478, "func": "int bta_co_rfc_data_outgoing_size(void *user_data, int *size) {\n  pthread_mutex_lock(&slot_lock);\n\n uint32_t id = (uintptr_t)user_data;\n int ret = false;\n *size = 0;\n rfc_slot_t *slot = find_rfc_slot_by_id(id);\n\n   if (!slot)\n     goto out;\n \n  if (ioctl(slot->fd, FIONREAD, size) == 0) {\n     ret = true;\n   } else {\n     LOG_ERROR(\"%s unable to determine bytes remaining to be read on fd %d: %s\", __func__, slot->fd, strerror(errno));\n    cleanup_rfc_slot(slot);\n }\n\nout:;\n  pthread_mutex_unlock(&slot_lock);\n return ret;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 187902, "func": "bool SoftVPX::outputBuffers(bool flushDecoder, bool display, bool eos, bool *portWillReset) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n BufferInfo *outInfo = NULL;\n    OMX_BUFFERHEADERTYPE *outHeader = NULL;\n vpx_codec_iter_t iter = NULL;\n\n if (flushDecoder && mFrameParallelMode) {\n if (vpx_codec_decode((vpx_codec_ctx_t *)mCtx, NULL, 0, NULL, 0)) {\n            ALOGE(\"Failed to flush on2 decoder.\");\n return false;\n }\n }\n\n if (!display) {\n if (!flushDecoder) {\n            ALOGE(\"Invalid operation.\");\n return false;\n }\n while ((mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter))) {\n }\n return true;\n }\n\n while (!outQueue.empty()) {\n if (mImg == NULL) {\n            mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);\n if (mImg == NULL) {\n break;\n }\n }\n uint32_t width = mImg->d_w;\n uint32_t height = mImg->d_h;\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        CHECK_EQ(mImg->fmt, VPX_IMG_FMT_I420);\n        handlePortSettingsChange(portWillReset, width, height);\n if (*portWillReset) {\n return true;\n }\n\n        outHeader->nOffset = 0;\n\n         outHeader->nFlags = 0;\n         outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n         outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv;\n        uint8_t *dst = outHeader->pBuffer;\n        const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];\n        const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];\n        const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V];\n        size_t srcYStride = mImg->stride[VPX_PLANE_Y];\n        size_t srcUStride = mImg->stride[VPX_PLANE_U];\n        size_t srcVStride = mImg->stride[VPX_PLANE_V];\n        copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);\n \n         mImg = NULL;\n         outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n\n if (!eos) {\n return true;\n }\n\n if (!outQueue.empty()) {\n        outInfo = *outQueue.begin();\n        outQueue.erase(outQueue.begin());\n        outHeader = outInfo->mHeader;\n        outHeader->nTimeStamp = 0;\n        outHeader->nFilledLen = 0;\n        outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n        outInfo->mOwnedByUs = false;\n        notifyFillBufferDone(outHeader);\n        mEOSStatus = OUTPUT_FRAMES_FLUSHED;\n }\n return true;\n}\n", "target": 1, "flaw_line_index": "50,51,52,53,54,55,56,57"}
{"idx": 8805, "func": "static inline bool is_dst_blend(int blend_factor)\n{\n   return (blend_factor == PIPE_BLENDFACTOR_DST_ALPHA ||\n           blend_factor == PIPE_BLENDFACTOR_INV_DST_ALPHA);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187864, "func": "long SegmentInfo::Parse() {\n  assert(m_pMuxingAppAsUTF8 == NULL);\n  assert(m_pWritingAppAsUTF8 == NULL);\n  assert(m_pTitleAsUTF8 == NULL);\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = m_start;\n const long long stop = m_start + m_size;\n\n  m_timecodeScale = 1000000;\n  m_duration = -1;\n\n while (pos < stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (id == 0x0AD7B1) { \n      m_timecodeScale = UnserializeUInt(pReader, pos, size);\n\n if (m_timecodeScale <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x0489) { \n const long status = UnserializeFloat(pReader, pos, size, m_duration);\n\n if (status < 0)\n return status;\n\n if (m_duration < 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x0D80) { \n const long status =\n UnserializeString(pReader, pos, size, m_pMuxingAppAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x1741) { \n const long status =\n UnserializeString(pReader, pos, size, m_pWritingAppAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x3BA9) { \n const long status = UnserializeString(pReader, pos, size, m_pTitleAsUTF8);\n\n if (status)\n return status;\n\n     }\n \n     pos += size;\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   return 0;\n }\n", "target": 1, "flaw_line_index": "56,59"}
{"idx": 187859, "func": "void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,\n                                     long long size_) {\n   const long long stop = start_ + size_;\n   long long pos = start_;\n\n  m_track = -1;\n  m_pos = -1;\n  m_block = 1; \n\n\n   while (pos < stop) {\n     long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  \n    assert((pos + len) <= stop);\n \n     pos += len;  \n \n     const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert((pos + len) <= stop);\n \n     pos += len;  \n    assert((pos + size) <= stop);\n \n     if (id == 0x77)  \n       m_track = UnserializeUInt(pReader, pos, size);\n\n else if (id == 0x71) \n      m_pos = UnserializeUInt(pReader, pos, size);\n\n else if (id == 0x1378) \n\n       m_block = UnserializeUInt(pReader, pos, size);\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(m_pos >= 0);\n  assert(m_track > 0);\n }\n", "target": 1, "flaw_line_index": "14,15,16,21,22,25,38,41,42,43"}
{"idx": 187640, "func": "image_pixel_setf(image_pixel *this, unsigned int max)\n {\n   this->redf = this->red / (double)max;\n   this->greenf = this->green / (double)max;\n   this->bluef = this->blue / (double)max;\n   this->alphaf = this->alpha / (double)max;\n \n   if (this->red < max)\n       this->rede = this->redf * DBL_EPSILON;\n    else\n       this->rede = 0;\n   if (this->green < max)\n       this->greene = this->greenf * DBL_EPSILON;\n    else\n       this->greene = 0;\n   if (this->blue < max)\n       this->bluee = this->bluef * DBL_EPSILON;\n    else\n       this->bluee = 0;\n   if (this->alpha < max)\n       this->alphae = this->alphaf * DBL_EPSILON;\n    else\n       this->alphae = 0;\n}\n", "target": 1, "flaw_line_index": "3,4,5,6,8,12,16,20"}
{"idx": 8971, "func": "void net_tx_pkt_update_ip_checksums(struct NetTxPkt *pkt)\n{\n    uint16_t csum;\n    uint32_t cntr, cso;\n    assert(pkt);\n    uint8_t gso_type = pkt->virt_hdr.gso_type & ~VIRTIO_NET_HDR_GSO_ECN;\n    void *ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n\n    if (pkt->payload_len + pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len >\n        ETH_MAX_IP_DGRAM_LEN) {\n        return;\n    }\n\n    if (gso_type == VIRTIO_NET_HDR_GSO_TCPV4 ||\n        gso_type == VIRTIO_NET_HDR_GSO_UDP) {\n        net_tx_pkt_update_ip_hdr_checksum(pkt);\n\n        cntr = eth_calc_ip4_pseudo_hdr_csum(ip_hdr, pkt->payload_len, &cso);\n        csum = cpu_to_be16(~net_checksum_finish(cntr));\n    } else if (gso_type == VIRTIO_NET_HDR_GSO_TCPV6) {\n        cntr = eth_calc_ip6_pseudo_hdr_csum(ip_hdr, pkt->payload_len,\n                                            IP_PROTO_TCP, &cso);\n        csum = cpu_to_be16(~net_checksum_finish(cntr));\n    } else {\n        return;\n    }\n\n    iov_from_buf(&pkt->vec[NET_TX_PKT_PL_START_FRAG], pkt->payload_frags,\n                 pkt->virt_hdr.csum_offset, &csum, sizeof(csum));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8825, "func": "static void vrend_blend_enable(struct vrend_context *ctx, bool blend_enable)\n{\n   if (ctx->sub->blend_enabled != blend_enable) {\n      ctx->sub->blend_enabled = blend_enable;\n      if (blend_enable)\n         glEnable(GL_BLEND);\n      else\n         glDisable(GL_BLEND);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187883, "func": "void Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {\n  assert(m_count == 0);\n \n   if (m_preload_count >= cue_points_size) {\n     const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;\n \n    CuePoint** const qq = new CuePoint* [n];\n     CuePoint** q = qq;  \n \n     CuePoint** p = m_cue_points;  \n CuePoint** const pp = p + m_preload_count; \n\n while (p != pp)\n *q++ = *p++;\n\n delete[] m_cue_points;\n\n    m_cue_points = qq;\n\n     cue_points_size = n;\n   }\n \n  CuePoint* const pCP = new CuePoint(m_preload_count, pos);\n   m_cue_points[m_preload_count++] = pCP;\n }\n", "target": 1, "flaw_line_index": "2,7,23"}
{"idx": 188205, "func": "void SoftMPEG2::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n if (mInitNeeded && !mIsInFlush) {\n bool portWillReset = false;\n            handlePortSettingsChange(&portWillReset, mNewWidth, mNewHeight);\n\n            CHECK_EQ(reInitDecoder(), (status_t)OK);\n return;\n }\n\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n             DUMP_TO_FILE(mInFile, s_dec_ip.pv_stream_buffer, s_dec_ip.u4_num_Bytes);\n \n if (s_dec_ip.u4_num_Bytes > 0) {\n char *ptr = (char *)s_dec_ip.pv_stream_buffer;\n }\n\n            GETTIME(&mTimeStart, NULL);\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool unsupportedDimensions = (IMPEG2D_UNSUPPORTED_DIMENSIONS == s_dec_op.u4_error_code);\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (unsupportedDimensions && !mFlushNeeded) {\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, s_dec_op.u4_pic_wd, s_dec_op.u4_pic_ht);\n\n \n                 CHECK_EQ(reInitDecoder(), (status_t)OK);\n \n                setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n                ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n                 return;\n             }\n \n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (unsupportedDimensions || resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n\n if (unsupportedDimensions) {\n                    mNewWidth = s_dec_op.u4_pic_wd;\n                    mNewHeight = s_dec_op.u4_pic_ht;\n                    mInitNeeded = true;\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n size_t timeStampIdx;\n                outHeader->nFilledLen = (mWidth * mHeight * 3) / 2;\n\n                timeStampIdx = getMinTimestampIdx(mTimeStamps, mTimeStampsValid);\n                outHeader->nTimeStamp = mTimeStamps[timeStampIdx];\n                mTimeStampsValid[timeStampIdx] = false;\n\n                mWaitForI = mWaitForI && !(IV_I_FRAME == s_dec_op.e_pic_type);\n\n if (mWaitForI) {\n                    s_dec_op.u4_output_present = false;\n } else {\n                    ALOGV(\"Output timestamp: %lld, res: %ux%u\",\n (long long)outHeader->nTimeStamp, mWidth, mHeight);\n                    DUMP_TO_FILE(mOutFile, outHeader->pBuffer, outHeader->nFilledLen);\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n }\n } else {\n                mIsInFlush = false;\n\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n", "target": 1, "flaw_line_index": "85,124,125"}
{"idx": 187941, "func": "void WT_InterpolateNoLoop (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n \n     numSamples = pWTIntFrame->numSamples;\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n \n     phaseInc = pWTIntFrame->frame.phaseIncrement;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n    phaseFrac = (EAS_I32)pWTVoice->phaseFrac;\n\n#if defined(_8_BIT_SAMPLES)\n    samp1 = pSamples[0] << 8;\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n        phaseFrac += phaseInc;\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n if (acc0 > 0) {\n\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n#if defined(_8_BIT_SAMPLES)\n            samp1 = pSamples[0] << 8;\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8658, "func": "static size_t mptsas_config_pack(uint8_t **data, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vpack(data, fmt, ap);\n    va_end(ap);\n\n    if (data) {\n        assert(ret / 4 < 256 && (ret % 4) == 0);\n        stb_p(*data + 1, ret / 4);\n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8386, "func": "static void mptsas_scsi_uninit(PCIDevice *dev)\n{\n    MPTSASState *s = MPT_SAS(dev);\n\n    qemu_bh_delete(s->request_bh);\n    msi_uninit(dev);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187760, "func": "read_png(struct control *control)\n\n {\n    png_structp png_ptr;\n    png_infop info_ptr = NULL;\n   volatile png_bytep row = NULL, display = NULL;\n    volatile int rc;\n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, control,\n      error_handler, warning_handler);\n\n if (png_ptr == NULL)\n {\n      log_error(&control->file, LIBPNG_ERROR_CODE, \"OOM allocating png_struct\");\n      control->file.status_code |= INTERNAL_ERROR;\n return LIBPNG_ERROR_CODE;\n }\n\n\n    rc = setjmp(control->file.jmpbuf);\n    if (rc == 0)\n    {\n       png_set_read_fn(png_ptr, control, read_callback);\n \n       info_ptr = png_create_info_struct(png_ptr);\n if (info_ptr == NULL)\n         png_error(png_ptr, \"OOM allocating info structure\");\n\n if (control->file.global->verbose)\n         fprintf(stderr, \" INFO\\n\");\n\n\n       png_read_info(png_ptr, info_ptr);\n \n       {\n         png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n \n         row = png_voidcast(png_byte*, malloc(rowbytes));\n         display = png_voidcast(png_byte*, malloc(rowbytes));\n \n         if (row == NULL || display == NULL)\n            png_error(png_ptr, \"OOM allocating row buffers\");\n \n         {\n            png_uint_32 height = png_get_image_height(png_ptr, info_ptr);\n            int passes = png_set_interlace_handling(png_ptr);\n            int pass;\n            png_start_read_image(png_ptr);\n            for (pass = 0; pass < passes; ++pass)\n            {\n               png_uint_32 y = height;\n               while (y-- > 0)\n                  png_read_row(png_ptr, row, display);\n            }\n         }\n       }\n \n       if (control->file.global->verbose)\n         fprintf(stderr, \" END\\n\");\n\n      png_read_end(png_ptr, info_ptr);\n\n    }\n \n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n   if (row != NULL) free(row);\n   if (display != NULL) free(display);\n    return rc;\n }\n", "target": 1, "flaw_line_index": "6,36,38,39,41,42,44,45,46,47,48,49,50,51,51,51,52,53,54,55,66,67"}
{"idx": 188146, "func": "    BufferMeta(const sp<IMemory> &mem, OMX_U32 portIndex, bool is_backup = false)\n         : mMem(mem),\n          mIsBackup(is_backup),\n          mPortIndex(portIndex) {\n     }\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 8849, "func": "static void vrend_destroy_streamout_object(struct vrend_streamout_object *obj)\n{\n   int i;\n   list_del(&obj->head);\n   for (i = 0; i < obj->num_targets; i++)\n      vrend_so_target_reference(&obj->so_targets[i], NULL);\n   if (vrend_state.have_tf2)\n      glDeleteTransformFeedbacks(1, &obj->id);\n   FREE(obj);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188531, "func": "void filter_block2d_8_c(const uint8_t *src_ptr,\n const unsigned int src_stride,\n const int16_t *HFilter,\n const int16_t *VFilter,\n uint8_t *dst_ptr,\n unsigned int dst_stride,\n unsigned int output_width,\n unsigned int output_height) {\n\n   const int kInterp_Extend = 4;\n   const unsigned int intermediate_height =\n       (kInterp_Extend - 1) + output_height + kInterp_Extend;\n \n  uint8_t intermediate_buffer[71 * 64];\n   const int intermediate_next_stride = 1 - intermediate_height * output_width;\n \n  {\n    uint8_t *output_ptr = intermediate_buffer;\n    const int src_next_row_stride = src_stride - output_width;\n    unsigned int i, j;\n    src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);\n    for (i = 0; i < intermediate_height; ++i) {\n      for (j = 0; j < output_width; ++j) {\n        const int temp = (src_ptr[0] * HFilter[0]) +\n                         (src_ptr[1] * HFilter[1]) +\n                         (src_ptr[2] * HFilter[2]) +\n                         (src_ptr[3] * HFilter[3]) +\n                         (src_ptr[4] * HFilter[4]) +\n                         (src_ptr[5] * HFilter[5]) +\n                         (src_ptr[6] * HFilter[6]) +\n                         (src_ptr[7] * HFilter[7]) +\n                         (VP9_FILTER_WEIGHT >> 1);  \n \n        *output_ptr = clip_pixel(temp >> VP9_FILTER_SHIFT);\n        ++src_ptr;\n        output_ptr += intermediate_height;\n      }\n      src_ptr += src_next_row_stride;\n      output_ptr += intermediate_next_stride;\n     }\n   }\n \n  {\n    uint8_t *src_ptr = intermediate_buffer;\n    const int dst_next_row_stride = dst_stride - output_width;\n    unsigned int i, j;\n    for (i = 0; i < output_height; ++i) {\n      for (j = 0; j < output_width; ++j) {\n        const int temp = (src_ptr[0] * VFilter[0]) +\n                         (src_ptr[1] * VFilter[1]) +\n                         (src_ptr[2] * VFilter[2]) +\n                         (src_ptr[3] * VFilter[3]) +\n                         (src_ptr[4] * VFilter[4]) +\n                         (src_ptr[5] * VFilter[5]) +\n                         (src_ptr[6] * VFilter[6]) +\n                         (src_ptr[7] * VFilter[7]) +\n                         (VP9_FILTER_WEIGHT >> 1);  \n \n        *dst_ptr++ = clip_pixel(temp >> VP9_FILTER_SHIFT);\n        src_ptr += intermediate_height;\n      }\n      src_ptr += intermediate_next_stride;\n      dst_ptr += dst_next_row_stride;\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "13,14,15,16,17,18,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,40,41,42,43,44,45,46,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66"}
{"idx": 187955, "func": "status_t BnGraphicBufferConsumer::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n case ACQUIRE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n BufferItem item;\n int64_t presentWhen = data.readInt64();\n status_t result = acquireBuffer(&item, presentWhen);\n status_t err = reply->write(item);\n if (err) return err;\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n int slot = data.readInt32();\n int result = detachBuffer(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case ATTACH_BUFFER: {\n\n             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n             sp<GraphicBuffer> buffer = new GraphicBuffer();\n             data.read(*buffer.get());\n            int slot;\n             int result = attachBuffer(&slot, buffer);\n             reply->writeInt32(slot);\n             reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case RELEASE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n int buf = data.readInt32();\n uint64_t frameNumber = data.readInt64();\n            sp<Fence> releaseFence = new Fence();\n status_t err = data.read(*releaseFence);\n if (err) return err;\n status_t result = releaseBuffer(buf, frameNumber,\n                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case CONSUMER_CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );\n bool controlledByApp = data.readInt32();\n status_t result = consumerConnect(consumer, controlledByApp);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case CONSUMER_DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n status_t result = consumerDisconnect();\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case GET_RELEASED_BUFFERS: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint64_t slotMask;\n status_t result = getReleasedBuffers(&slotMask);\n            reply->writeInt64(slotMask);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case SET_DEFAULT_BUFFER_SIZE: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t w = data.readInt32();\n uint32_t h = data.readInt32();\n status_t result = setDefaultBufferSize(w, h);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case SET_DEFAULT_MAX_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t bufferCount = data.readInt32();\n status_t result = setDefaultMaxBufferCount(bufferCount);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case DISABLE_ASYNC_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n status_t result = disableAsyncBuffer();\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case SET_MAX_ACQUIRED_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t maxAcquiredBuffers = data.readInt32();\n status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case SET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            setConsumerName( data.readString8() );\n return NO_ERROR;\n } break;\n case SET_DEFAULT_BUFFER_FORMAT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t defaultFormat = data.readInt32();\n status_t result = setDefaultBufferFormat(defaultFormat);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case SET_CONSUMER_USAGE_BITS: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t usage = data.readInt32();\n status_t result = setConsumerUsageBits(usage);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case SET_TRANSFORM_HINT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n uint32_t hint = data.readInt32();\n status_t result = setTransformHint(hint);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case DUMP: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n String8 result = data.readString8();\n String8 prefix = data.readString8();\n static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);\n            reply->writeString8(result);\n return NO_ERROR;\n }\n }\n return BBinder::onTransact(code, data, reply, flags);\n}\n", "target": 1, "flaw_line_index": "27"}
{"idx": 8768, "func": "static void init_packet(struct dhcp_packet *packet, char type)\n{\n\tuint16_t secs;\n\n\tudhcp_init_header(packet, type);\n\n\tpacket->xid = random_xid();\n\n\tclient_config.last_secs = monotonic_sec();\n\tif (client_config.first_secs == 0)\n\t\tclient_config.first_secs = client_config.last_secs;\n\tsecs = client_config.last_secs - client_config.first_secs;\n\tpacket->secs = htons(secs);\n\n\tmemcpy(packet->chaddr, client_config.client_mac, 6);\n\tif (client_config.clientid)\n\t\tudhcp_add_binary_option(packet, client_config.clientid);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188162, "func": " status_t OMXNodeInstance::storeMetaDataInBuffers_l(\n         OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {\n     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n         android_errorWriteLog(0x534e4554, \"26324358\");\n         if (type != NULL) {\n *type = kMetadataBufferTypeInvalid;\n }\n return BAD_VALUE;\n }\n\n    OMX_INDEXTYPE index;\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeMetaDataInBuffers\");\n\n    OMX_STRING nativeBufferName = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeANWBufferInMetadata\");\n MetadataBufferType negotiatedType;\n MetadataBufferType requestedType = type != NULL ? *type : kMetadataBufferTypeANWBuffer;\n\n StoreMetaDataInBuffersParams params;\n InitOMXParams(&params);\n    params.nPortIndex = portIndex;\n    params.bStoreMetaData = enable;\n\n    OMX_ERRORTYPE err =\n        requestedType == kMetadataBufferTypeANWBuffer\n ? OMX_GetExtensionIndex(mHandle, nativeBufferName, &index)\n : OMX_ErrorUnsupportedIndex;\n    OMX_ERRORTYPE xerr = err;\n if (err == OMX_ErrorNone) {\n        err = OMX_SetParameter(mHandle, index, &params);\n if (err == OMX_ErrorNone) {\n            name = nativeBufferName; \n            negotiatedType = requestedType;\n }\n }\n if (err != OMX_ErrorNone) {\n        err = OMX_GetExtensionIndex(mHandle, name, &index);\n        xerr = err;\n if (err == OMX_ErrorNone) {\n            negotiatedType =\n                requestedType == kMetadataBufferTypeANWBuffer\n ? kMetadataBufferTypeGrallocSource : requestedType;\n            err = OMX_SetParameter(mHandle, index, &params);\n }\n }\n\n if (err != OMX_ErrorNone) {\n if (err == OMX_ErrorUnsupportedIndex && portIndex == kPortIndexOutput) {\n            CLOGW(\"component does not support metadata mode; using fallback\");\n } else if (xerr != OMX_ErrorNone) {\n            CLOG_ERROR(getExtensionIndex, xerr, \"%s\", name);\n } else {\n            CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u en=%d type=%d\", name, index,\n                    portString(portIndex), portIndex, enable, negotiatedType);\n }\n        negotiatedType = mMetadataType[portIndex];\n } else {\n if (!enable) {\n            negotiatedType = kMetadataBufferTypeInvalid;\n }\n        mMetadataType[portIndex] = negotiatedType;\n }\n    CLOG_CONFIG(storeMetaDataInBuffers, \"%s:%u %srequested %s:%d negotiated %s:%d\",\n            portString(portIndex), portIndex, enable ? \"\" : \"UN\",\n            asString(requestedType), requestedType, asString(negotiatedType), negotiatedType);\n\n if (type != NULL) {\n *type = negotiatedType;\n }\n\n return StatusFromOMXError(err);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9008, "func": "vmxnet3_indicate_packet(VMXNET3State *s)\n{\n    struct Vmxnet3_RxDesc rxd;\n    PCIDevice *d = PCI_DEVICE(s);\n    bool is_head = true;\n    uint32_t rxd_idx;\n    uint32_t rx_ridx = 0;\n\n    struct Vmxnet3_RxCompDesc rxcd;\n    uint32_t new_rxcd_gen = VMXNET3_INIT_GEN;\n    hwaddr new_rxcd_pa = 0;\n    hwaddr ready_rxcd_pa = 0;\n    struct iovec *data = net_rx_pkt_get_iovec(s->rx_pkt);\n    size_t bytes_copied = 0;\n    size_t bytes_left = net_rx_pkt_get_total_len(s->rx_pkt);\n    uint16_t num_frags = 0;\n    size_t chunk_size;\n\n    net_rx_pkt_dump(s->rx_pkt);\n\n    while (bytes_left > 0) {\n\n        if (num_frags == s->max_rx_frags) {\n            break;\n        }\n\n        new_rxcd_pa = vmxnet3_pop_rxc_descr(s, RXQ_IDX, &new_rxcd_gen);\n        if (!new_rxcd_pa) {\n            break;\n        }\n\n        if (!vmxnet3_get_next_rx_descr(s, is_head, &rxd, &rxd_idx, &rx_ridx)) {\n            break;\n        }\n\n        chunk_size = MIN(bytes_left, rxd.len);\n        vmxnet3_pci_dma_writev(d, data, bytes_copied,\n                               le64_to_cpu(rxd.addr), chunk_size);\n        bytes_copied += chunk_size;\n        bytes_left -= chunk_size;\n\n        vmxnet3_dump_rx_descr(&rxd);\n\n        if (ready_rxcd_pa != 0) {\n            pci_dma_write(d, ready_rxcd_pa, &rxcd, sizeof(rxcd));\n        }\n\n        memset(&rxcd, 0, sizeof(struct Vmxnet3_RxCompDesc));\n        rxcd.rxdIdx = rxd_idx;\n        rxcd.len = chunk_size;\n        rxcd.sop = is_head;\n        rxcd.gen = new_rxcd_gen;\n        rxcd.rqID = RXQ_IDX + rx_ridx * s->rxq_num;\n\n        if (bytes_left == 0) {\n            vmxnet3_rx_update_descr(s->rx_pkt, &rxcd);\n        }\n\n        VMW_RIPRN(\"RX Completion descriptor: rxRing: %lu rxIdx %lu len %lu \"\n                  \"sop %d csum_correct %lu\",\n                  (unsigned long) rx_ridx,\n                  (unsigned long) rxcd.rxdIdx,\n                  (unsigned long) rxcd.len,\n                  (int) rxcd.sop,\n                  (unsigned long) rxcd.tuc);\n\n        is_head = false;\n        ready_rxcd_pa = new_rxcd_pa;\n        new_rxcd_pa = 0;\n        num_frags++;\n    }\n\n    if (ready_rxcd_pa != 0) {\n        rxcd.eop = 1;\n        rxcd.err = (bytes_left != 0);\n\n        pci_dma_write(d, ready_rxcd_pa, &rxcd, sizeof(rxcd));\n\n        smp_wmb();\n    }\n\n    if (new_rxcd_pa != 0) {\n        vmxnet3_revert_rxc_descr(s, RXQ_IDX);\n    }\n\n    vmxnet3_trigger_interrupt(s, s->rxq_descr[RXQ_IDX].intr_idx);\n\n    if (bytes_left == 0) {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX, VMXNET3_PKT_STATUS_OK);\n        return true;\n    } else if (num_frags == s->max_rx_frags) {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX, VMXNET3_PKT_STATUS_ERROR);\n        return false;\n    } else {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX,\n                                        VMXNET3_PKT_STATUS_OUT_OF_BUF);\n        return false;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9024, "func": "vmxnet3_on_interrupt_mask_changed(VMXNET3State *s, int lidx, bool is_masked)\n{\n    s->interrupt_states[lidx].is_masked = is_masked;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187750, "func": "IDAT_list_extend(struct IDAT_list *tail)\n{\n struct IDAT_list *next = tail->next;\n\n if (next == NULL)\n {\n unsigned int length = 2 * tail->length;\n\n \n       if (length < tail->length) \n          length = tail->length;\n      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));\n       CLEAR(*next);\n \n if (next == NULL)\n return NULL;\n\n      next->next = NULL;\n      next->length = length;\n      tail->next = next;\n }\n\n return next;\n}\n", "target": 1, "flaw_line_index": "12,13"}
{"idx": 8494, "func": "void CSoundFile::SetCurrentOrder(UINT nPos)\n{\n\twhile ((nPos < MAX_ORDERS) && (Order[nPos] == 0xFE)) nPos++;\n\tif ((nPos >= MAX_ORDERS) || (Order[nPos] >= MAX_PATTERNS)) return;\n\tfor (UINT j=0; j<MAX_CHANNELS; j++)\n\t{\n\t\tChn[j].nPeriod = 0;\n\t\tChn[j].nNote = 0;\n\t\tChn[j].nPortamentoDest = 0;\n\t\tChn[j].nCommand = 0;\n\t\tChn[j].nPatternLoopCount = 0;\n\t\tChn[j].nPatternLoop = 0;\n\t\tChn[j].nTremorCount = 0;\n\t}\n\tif (!nPos)\n\t{\n\t\tSetCurrentPos(0);\n\t} else\n\t{\n\t\tm_nNextPattern = nPos;\n\t\tm_nRow = m_nNextRow = 0;\n\t\tm_nPattern = 0;\n\t\tm_nTickCount = m_nMusicSpeed;\n\t\tm_nBufferCount = 0;\n\t\tm_nTotalCount = 0;\n\t\tm_nPatternDelay = 0;\n\t\tm_nFrameDelay = 0;\n\t}\n\tm_dwSongFlags &= ~(SONG_PATTERNLOOP|SONG_CPUVERYHIGH|SONG_FADINGSONG|SONG_ENDREACHED|SONG_GLOBALFADE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188530, "func": "void filter_average_block2d_8_c(const uint8_t *src_ptr,\n const unsigned int src_stride,\n const int16_t *HFilter,\n const int16_t *VFilter,\n uint8_t *dst_ptr,\n\n                                 unsigned int dst_stride,\n                                 unsigned int output_width,\n                                 unsigned int output_height) {\n  uint8_t tmp[64 * 64];\n \n  assert(output_width <= 64);\n  assert(output_height <= 64);\n   filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,\n                      output_width, output_height);\n   block2d_average_c(tmp, 64, dst_ptr, dst_stride,\n                     output_width, output_height);\n }\n", "target": 1, "flaw_line_index": "10,12,13"}
{"idx": 187608, "func": " write_png(const char **name, FILE *fp, int color_type, int bit_depth,\n    volatile png_fixed_point gamma, chunk_insert * volatile insert,\n   unsigned int filters, unsigned int *colors)\n {\n    png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n       name, makepng_error, makepng_warning);\n volatile png_infop info_ptr = NULL;\n volatile png_bytep row = NULL;\n\n if (png_ptr == NULL)\n {\n      fprintf(stderr, \"makepng: OOM allocating write structure\\n\");\n return 1;\n }\n\n if (setjmp(png_jmpbuf(png_ptr)))\n {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n if (row != NULL) free(row);\n return 1;\n }\n\n \n    png_set_benign_errors(png_ptr, 1\n);\n    png_init_io(png_ptr, fp);\n \n    info_ptr = png_create_info_struct(png_ptr);\n if (info_ptr == NULL)\n\n       png_error(png_ptr, \"OOM allocating info structure\");\n \n    {\n      unsigned int size = image_size_of_type(color_type, bit_depth, colors);\n       png_fixed_point real_gamma = 45455; \n       png_byte gamma_table[256];\n       double conv;\n \n if (gamma == PNG_GAMMA_MAC_18)\n         gamma = 65909;\n\n else if (gamma > 0 && gamma < 1000)\n         gamma = PNG_FP_1;\n\n if (gamma > 0)\n         real_gamma = gamma;\n\n {\n unsigned int i;\n\n if (real_gamma == 45455) for (i=0; i<256; ++i)\n {\n            gamma_table[i] = (png_byte)i;\n            conv = 1.;\n }\n\n else\n {\n            conv = real_gamma;\n            conv /= 45455;\n\n\n             gamma_table[0] = 0;\n \n             for (i=1; i<255; ++i)\n               gamma_table[i] = (png_byte)floor(pow(i/255.,conv) * 255 + .5);\n \n             gamma_table[255] = 255;\n          }\n       }\n \n      png_set_IHDR(png_ptr, info_ptr, size, size, bit_depth, color_type,\n          PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n \n       if (color_type & PNG_COLOR_MASK_PALETTE)\n {\n int npalette;\n         png_color palette[256];\n         png_byte trans[256];\n\n\n          npalette = generate_palette(palette, trans, bit_depth, gamma_table,\n             colors);\n          png_set_PLTE(png_ptr, info_ptr, palette, npalette);\n         png_set_tRNS(png_ptr, info_ptr, trans, npalette-1,\n            NULL\n);\n \n          for (npalette=0; npalette<256; ++npalette)\n             gamma_table[npalette] = (png_byte)npalette;\n       }\n \n       if (gamma == PNG_DEFAULT_sRGB)\n          png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_ABSOLUTE);\n \n else if (gamma > 0) \n {\n         png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma);\n\n         png_set_cHRM_fixed(png_ptr, info_ptr,\n 31270, 32900,\n 64000, 33000,\n 30000, 60000,\n 15000, 6000\n );\n }\n\n while (insert != NULL)\n {\n         insert->insert(png_ptr, info_ptr, insert->nparams, insert->parameters);\n         insert = insert->next;\n }\n\n      png_write_info(png_ptr, info_ptr);\n\n\n       png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters);\n \n       {\n         int passes = png_set_interlace_handling(png_ptr);\n          int pass;\n          png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n \n         row = malloc(rowbytes);\n\n if (row == NULL)\n            png_error(png_ptr, \"OOM allocating row buffer\");\n\n for (pass = 0; pass < passes; ++pass)\n\n          {\n             unsigned int y;\n \n            for (y=0; y<size; ++y)\n             {\n               generate_row(row, rowbytes, y, color_type, bit_depth,\n                  gamma_table, conv, colors);\n                png_write_row(png_ptr, row);\n             }\n          }\n }\n }\n\n   png_write_end(png_ptr, info_ptr);\n\n {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n }\n   free(row);\n return 0;\n}\n", "target": 1, "flaw_line_index": "3,39,71,77,90,92,125,139,141,142"}
{"idx": 188192, "func": " bool InputWindowInfo::isTrustedOverlay() const {\n     return layoutParamsType == TYPE_INPUT_METHOD\n             || layoutParamsType == TYPE_INPUT_METHOD_DIALOG\n             || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY\n             || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8474, "func": "int CSoundFile::FrequencyToTranspose(DWORD freq)\n{\n\treturn int(1536*(log(freq/8363.0)/log(2.0)));\n\n#ifdef MSC_VER\n\tconst float _f1_8363 = 1.0f / 8363.0f;\n\tconst float _factor = 128 * 12;\n\tLONG result;\n\n\tif (!freq) return 0;\n\t_asm {\n\tfld _factor\n\tfild freq\n\tfld _f1_8363\n\tfmulp st(1), st(0)\n\tfyl2x\n\tfistp result\n\t}\n\treturn result;\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8741, "func": "vcard_make_response(vcard_7816_status_t status)\n{\n    VCardResponse *response;\n\n    switch (status) {\n    case VCARD7816_STATUS_SUCCESS:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_SUCCESS);\n    case VCARD7816_STATUS_WARNING:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_WARNING);\n    case VCARD7816_STATUS_WARNING_RET_CORUPT:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_WARNING_RET_CORUPT);\n    case VCARD7816_STATUS_WARNING_BUF_END_BEFORE_LE:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_WARNING_BUF_END_BEFORE_LE);\n    case VCARD7816_STATUS_WARNING_INVALID_FILE_SELECTED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_WARNING_INVALID_FILE_SELECTED);\n    case VCARD7816_STATUS_WARNING_FCI_FORMAT_INVALID:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_WARNING_FCI_FORMAT_INVALID);\n    case VCARD7816_STATUS_WARNING_CHANGE:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_WARNING_CHANGE);\n    case VCARD7816_STATUS_WARNING_FILE_FILLED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_WARNING_FILE_FILLED);\n    case VCARD7816_STATUS_EXC_ERROR:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_EXC_ERROR);\n    case VCARD7816_STATUS_EXC_ERROR_CHANGE:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_EXC_ERROR_CHANGE);\n    case VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE);\n    case VCARD7816_STATUS_ERROR_WRONG_LENGTH:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_WRONG_LENGTH);\n    case VCARD7816_STATUS_ERROR_CLA_NOT_SUPPORTED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_CLA_NOT_SUPPORTED);\n    case VCARD7816_STATUS_ERROR_CHANNEL_NOT_SUPPORTED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_CHANNEL_NOT_SUPPORTED);\n    case VCARD7816_STATUS_ERROR_SECURE_NOT_SUPPORTED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_SECURE_NOT_SUPPORTED);\n    case VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);\n    case VCARD7816_STATUS_ERROR_COMMAND_INCOMPATIBLE_WITH_FILE:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_COMMAND_INCOMPATIBLE_WITH_FILE);\n    case VCARD7816_STATUS_ERROR_SECURITY_NOT_SATISFIED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_SECURITY_NOT_SATISFIED);\n    case VCARD7816_STATUS_ERROR_AUTHENTICATION_BLOCKED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_AUTHENTICATION_BLOCKED);\n    case VCARD7816_STATUS_ERROR_DATA_INVALID:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_DATA_INVALID);\n    case VCARD7816_STATUS_ERROR_CONDITION_NOT_SATISFIED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_CONDITION_NOT_SATISFIED);\n    case VCARD7816_STATUS_ERROR_DATA_NO_EF:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_DATA_NO_EF);\n    case VCARD7816_STATUS_ERROR_SM_OBJECT_MISSING:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_SM_OBJECT_MISSING);\n    case VCARD7816_STATUS_ERROR_SM_OBJECT_INCORRECT:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_SM_OBJECT_INCORRECT);\n    case VCARD7816_STATUS_ERROR_WRONG_PARAMETERS:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_WRONG_PARAMETERS);\n    case VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_IN_DATA:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_IN_DATA);\n    case VCARD7816_STATUS_ERROR_FUNCTION_NOT_SUPPORTED:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_FUNCTION_NOT_SUPPORTED);\n    case VCARD7816_STATUS_ERROR_FILE_NOT_FOUND:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_FILE_NOT_FOUND);\n    case VCARD7816_STATUS_ERROR_RECORD_NOT_FOUND:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_RECORD_NOT_FOUND);\n    case VCARD7816_STATUS_ERROR_NO_SPACE_FOR_FILE:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_NO_SPACE_FOR_FILE);\n    case VCARD7816_STATUS_ERROR_LC_TLV_INCONSISTENT:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_LC_TLV_INCONSISTENT);\n    case VCARD7816_STATUS_ERROR_P1_P2_INCORRECT:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_P1_P2_INCORRECT);\n    case VCARD7816_STATUS_ERROR_LC_P1_P2_INCONSISTENT:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_LC_P1_P2_INCONSISTENT);\n    case VCARD7816_STATUS_ERROR_DATA_NOT_FOUND:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_DATA_NOT_FOUND);\n    case VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_2:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_2);\n    case VCARD7816_STATUS_ERROR_INS_CODE_INVALID:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_INS_CODE_INVALID);\n    case VCARD7816_STATUS_ERROR_CLA_INVALID:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_CLA_INVALID);\n    case VCARD7816_STATUS_ERROR_GENERAL:\n        return VCARD_RESPONSE_GET_STATIC(\n                    VCARD7816_STATUS_ERROR_GENERAL);\n    default:\n        response = vcard_response_new_status(status);\n        if (response == NULL) {\n            return VCARD_RESPONSE_GET_STATIC(\n                        VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE);\n        }\n        return response;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188569, "func": "  void RunAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     uint32_t max_error = 0;\n     int64_t total_error = 0;\n     const int count_test_block = 10000;\n     for (int i = 0; i < count_test_block; ++i) {\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n                                      test_temp_block, pitch_));\n      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n        total_error += error;\n\n       }\n     }\n \n    EXPECT_GE(1u, max_error)\n        << \"Error: 4x4 FHT/IHT has an individual round trip error > 1\";\n \n    EXPECT_GE(count_test_block , total_error)\n        << \"Error: 4x4 FHT/IHT has average round trip error > 1 per block\";\n   }\n", "target": 1, "flaw_line_index": "7,8,9,10,14,15,16,19,20,21,33,34,36,37"}
{"idx": 9211, "func": "void virtio_queue_aio_set_host_notifier_handler(VirtQueue *vq, AioContext *ctx,\n                                                VirtIOHandleOutput handle_output)\n{\n    if (handle_output) {\n        vq->handle_aio_output = handle_output;\n        aio_set_event_notifier(ctx, &vq->host_notifier, true,\n                               virtio_queue_host_notifier_aio_read);\n    } else {\n        aio_set_event_notifier(ctx, &vq->host_notifier, true, NULL);\n        virtio_queue_host_notifier_aio_read(&vq->host_notifier);\n        vq->handle_aio_output = NULL;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8985, "func": "vmxnet3_dump_rx_descr(struct Vmxnet3_RxDesc *descr)\n{\n    VMW_PKPRN(\"RX DESCR: addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n              \"dtype: %d, ext1: %d, btype: %d\",\n              le64_to_cpu(descr->addr), descr->len, descr->gen,\n              descr->rsvd, descr->dtype, descr->ext1, descr->btype);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8901, "func": "vrend_renderer_fini(void)\n{\n   if (!vrend_state.inited)\n      return;\n\n   vrend_free_sync_thread();\n   if (vrend_state.eventfd != -1) {\n      close(vrend_state.eventfd);\n      vrend_state.eventfd = -1;\n   }\n\n   vrend_decode_reset(false);\n   vrend_object_fini_resource_table();\n   vrend_decode_reset(true);\n\n   vrend_state.inited = false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188564, "func": "  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video) {\n     frame_flags_ &= ~(VP8_EFLAG_NO_UPD_LAST |\n                       VP8_EFLAG_NO_UPD_GF |\n                       VP8_EFLAG_NO_UPD_ARF);\n    if (droppable_nframes_ > 0 &&\n        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n       for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n         if (droppable_frames_[i] == video->frame()) {\n          std::cout << \"             Encoding droppable frame: \"\n                     << droppable_frames_[i] << \"\\n\";\n          frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST |\n                           VP8_EFLAG_NO_UPD_GF |\n                           VP8_EFLAG_NO_UPD_ARF);\n          return;\n         }\n       }\n     }\n   }\n", "target": 1, "flaw_line_index": "5,6,9,11,12,13,14"}
{"idx": 8315, "func": "XFixesSetRegion (Display *dpy, XserverRegion region,\n\t\t XRectangle *rectangles, int nrectangles)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesSetRegionReq\t\t*req;\n    long    \t\t\tlen;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesSetRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesSetRegion;\n    req->region = region;\n    len = ((long) nrectangles) << 1;\n    SetReqLen (req, len, len);\n    len <<= 2;\n    Data16 (dpy, (short *) rectangles, len);\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9048, "func": "vmxnet3_revert_rxc_descr(VMXNET3State *s, int qidx)\n{\n    vmxnet3_dec_rx_completion_counter(s, qidx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8626, "func": "static inline bool vmsvga_verify_rect(DisplaySurface *surface,\n                                      const char *name,\n                                      int x, int y, int w, int h)\n{\n    if (x < 0) {\n        fprintf(stderr, \"%s: x was < 0 (%d)\\n\", name, x);\n        return false;\n    }\n    if (x > SVGA_MAX_WIDTH) {\n        fprintf(stderr, \"%s: x was > %d (%d)\\n\", name, SVGA_MAX_WIDTH, x);\n        return false;\n    }\n    if (w < 0) {\n        fprintf(stderr, \"%s: w was < 0 (%d)\\n\", name, w);\n        return false;\n    }\n    if (w > SVGA_MAX_WIDTH) {\n        fprintf(stderr, \"%s: w was > %d (%d)\\n\", name, SVGA_MAX_WIDTH, w);\n        return false;\n    }\n    if (x + w > surface_width(surface)) {\n        fprintf(stderr, \"%s: width was > %d (x: %d, w: %d)\\n\",\n                name, surface_width(surface), x, w);\n        return false;\n    }\n\n    if (y < 0) {\n        fprintf(stderr, \"%s: y was < 0 (%d)\\n\", name, y);\n        return false;\n    }\n    if (y > SVGA_MAX_HEIGHT) {\n        fprintf(stderr, \"%s: y was > %d (%d)\\n\", name, SVGA_MAX_HEIGHT, y);\n        return false;\n    }\n    if (h < 0) {\n        fprintf(stderr, \"%s: h was < 0 (%d)\\n\", name, h);\n        return false;\n    }\n    if (h > SVGA_MAX_HEIGHT) {\n        fprintf(stderr, \"%s: h was > %d (%d)\\n\", name, SVGA_MAX_HEIGHT, h);\n        return false;\n    }\n    if (y + h > surface_height(surface)) {\n        fprintf(stderr, \"%s: update height > %d (y: %d, h: %d)\\n\",\n                name, surface_height(surface), y, h);\n        return false;\n    }\n\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188603, "func": "   SvcTest()\n       : codec_iface_(0),\n         test_file_name_(\"hantro_collage_w352h288.yuv\"),\n        stats_file_name_(\"hantro_collage_w352h288.stat\"),\n         codec_initialized_(false),\n         decoder_(0) {\n     memset(&svc_, 0, sizeof(svc_));\n    memset(&codec_, 0, sizeof(codec_));\n    memset(&codec_enc_, 0, sizeof(codec_enc_));\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8645, "func": "size_t mptsas_config_ioc_4(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(4, MPI_CONFIG_PAGETYPE_IOC, 0x00,\n                              \"*b*b*w\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188497, "func": "void usage_exit() {\n   fprintf(stderr, \"Usage: %s <infile> <outfile>\\n\", exec_name);\n   exit(EXIT_FAILURE);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8404, "func": "pvscsi_cmp_ring_put(PVSCSIState *s, struct PVSCSIRingCmpDesc *cmp_desc)\n{\n    hwaddr cmp_descr_pa;\n\n    cmp_descr_pa = pvscsi_ring_pop_cmp_descr(&s->rings);\n    trace_pvscsi_cmp_ring_put(cmp_descr_pa);\n    cpu_physical_memory_write(cmp_descr_pa, (void *)cmp_desc,\n                              sizeof(*cmp_desc));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8351, "func": "static void gmc_motion(MpegEncContext *s,\n                       uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                       uint8_t **ref_picture)\n{\n    uint8_t *ptr;\n    int linesize, uvlinesize;\n    const int a = s->sprite_warping_accuracy;\n    int ox, oy;\n\n    linesize   = s->linesize;\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0];\n\n    ox = s->sprite_offset[0][0] + s->sprite_delta[0][0] * s->mb_x * 16 +\n         s->sprite_delta[0][1] * s->mb_y * 16;\n    oy = s->sprite_offset[0][1] + s->sprite_delta[1][0] * s->mb_x * 16 +\n         s->sprite_delta[1][1] * s->mb_y * 16;\n\n    s->mdsp.gmc(dest_y, ptr, linesize, 16,\n                ox, oy,\n                s->sprite_delta[0][0], s->sprite_delta[0][1],\n                s->sprite_delta[1][0], s->sprite_delta[1][1],\n                a + 1, (1 << (2 * a + 1)) - s->no_rounding,\n                s->h_edge_pos, s->v_edge_pos);\n    s->mdsp.gmc(dest_y + 8, ptr, linesize, 16,\n                ox + s->sprite_delta[0][0] * 8,\n                oy + s->sprite_delta[1][0] * 8,\n                s->sprite_delta[0][0], s->sprite_delta[0][1],\n                s->sprite_delta[1][0], s->sprite_delta[1][1],\n                a + 1, (1 << (2 * a + 1)) - s->no_rounding,\n                s->h_edge_pos, s->v_edge_pos);\n\n    if (CONFIG_GRAY && s->avctx->flags & AV_CODEC_FLAG_GRAY)\n        return;\n\n    ox = s->sprite_offset[1][0] + s->sprite_delta[0][0] * s->mb_x * 8 +\n         s->sprite_delta[0][1] * s->mb_y * 8;\n    oy = s->sprite_offset[1][1] + s->sprite_delta[1][0] * s->mb_x * 8 +\n         s->sprite_delta[1][1] * s->mb_y * 8;\n\n    ptr = ref_picture[1];\n    s->mdsp.gmc(dest_cb, ptr, uvlinesize, 8,\n                ox, oy,\n                s->sprite_delta[0][0], s->sprite_delta[0][1],\n                s->sprite_delta[1][0], s->sprite_delta[1][1],\n                a + 1, (1 << (2 * a + 1)) - s->no_rounding,\n                s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n    ptr = ref_picture[2];\n    s->mdsp.gmc(dest_cr, ptr, uvlinesize, 8,\n                ox, oy,\n                s->sprite_delta[0][0], s->sprite_delta[0][1],\n                s->sprite_delta[1][0], s->sprite_delta[1][1],\n                a + 1, (1 << (2 * a + 1)) - s->no_rounding,\n                s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8584, "func": "static void ssh_process_queued_incoming_data(Ssh ssh)\n{\n    void *vdata;\n    const unsigned char *data;\n    int len, origlen;\n\n    while (!ssh->frozen && bufchain_size(&ssh->queued_incoming_data)) {\n\tbufchain_prefix(&ssh->queued_incoming_data, &vdata, &len);\n\tdata = vdata;\n\toriglen = len;\n\n\twhile (!ssh->frozen && len > 0)\n\t    ssh_process_incoming_data(ssh, &data, &len);\n\n\tif (origlen > len)\n\t    bufchain_consume(&ssh->queued_incoming_data, origlen - len);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8948, "func": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                       uint32_t handle,\n                                       unsigned num_elements,\n                                       const struct pipe_vertex_element *elements)\n{\n   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n   const struct util_format_description *desc;\n   GLenum type;\n   int i;\n   uint32_t ret_handle;\n\n   if (!v)\n      return ENOMEM;\n\n   if (num_elements > PIPE_MAX_ATTRIBS)\n      return EINVAL;\n\n   v->count = num_elements;\n   for (i = 0; i < num_elements; i++) {\n      memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n\n      desc = util_format_description(elements[i].src_format);\n      if (!desc) {\n         FREE(v);\n         return EINVAL;\n      }\n\n      type = GL_FALSE;\n      if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\n         if (desc->channel[0].size == 32)\n            type = GL_FLOAT;\n         else if (desc->channel[0].size == 64)\n            type = GL_DOUBLE;\n         else if (desc->channel[0].size == 16)\n            type = GL_HALF_FLOAT;\n      } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n                 desc->channel[0].size == 8)\n         type = GL_UNSIGNED_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 8)\n         type = GL_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_UNSIGNED_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_UNSIGNED_INT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_INT;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\n         type = GL_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\n         type = GL_UNSIGNED_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         type = GL_UNSIGNED_INT_10F_11F_11F_REV;\n\n      if (type == GL_FALSE) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\n         FREE(v);\n         return EINVAL;\n      }\n\n      v->elements[i].type = type;\n      if (desc->channel[0].normalized)\n         v->elements[i].norm = GL_TRUE;\n      if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\n         v->elements[i].nr_chan = GL_BGRA;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         v->elements[i].nr_chan = 3;\n      else\n         v->elements[i].nr_chan = desc->nr_channels;\n   }\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      glGenVertexArrays(1, &v->id);\n      glBindVertexArray(v->id);\n      for (i = 0; i < num_elements; i++) {\n         struct vrend_vertex_element *ve = &v->elements[i];\n\n         if (util_format_is_pure_integer(ve->base.src_format))\n            glVertexAttribIFormat(i, ve->nr_chan, ve->type, ve->base.src_offset);\n         else\n            glVertexAttribFormat(i, ve->nr_chan, ve->type, ve->norm, ve->base.src_offset);\n         glVertexAttribBinding(i, ve->base.vertex_buffer_index);\n         glVertexBindingDivisor(i, ve->base.instance_divisor);\n         glEnableVertexAttribArray(i);\n      }\n   }\n   ret_handle = vrend_renderer_object_insert(ctx, v, sizeof(struct vrend_vertex_element), handle,\n                                             VIRGL_OBJECT_VERTEX_ELEMENTS);\n   if (!ret_handle) {\n      FREE(v);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188116, "func": " static Maybe<bool> CollectValuesOrEntriesImpl(\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n    int count = 0;\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n    for (int i = 0; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n      if (get_entries) {\n        value = MakeEntryPair(isolate, index, value);\n       }\n       values_or_entries->set(count++, *value);\n     }\n \n *nof_items = count;\n return Just(true);\n }\n", "target": 1, "flaw_line_index": "6,13,15,32,33"}
{"idx": 187520, "func": "static void uipc_read_task(void *arg)\n{\n int ch_id;\n int result;\n    UNUSED(arg);\n\n    prctl(PR_SET_NAME, (unsigned long)\"uipc-main\", 0, 0, 0);\n\n    raise_priority_a2dp(TASK_UIPC_READ);\n\n while (uipc_main.running)\n\n     {\n         uipc_main.read_set = uipc_main.active_set;\n \n        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);\n \n         if (result == 0)\n         {\n            BTIF_TRACE_EVENT(\"select timeout\");\n continue;\n }\n else if (result < 0)\n {\n            BTIF_TRACE_EVENT(\"select failed %s\", strerror(errno));\n continue;\n }\n\n        UIPC_LOCK();\n\n        uipc_check_interrupt_locked();\n\n        uipc_check_task_flags_locked();\n\n        uipc_check_fd_locked(UIPC_CH_ID_AV_AUDIO);\n\n for (ch_id = 0; ch_id < UIPC_CH_NUM; ch_id++)\n {\n if (ch_id != UIPC_CH_ID_AV_AUDIO)\n                uipc_check_fd_locked(ch_id);\n }\n\n        UIPC_UNLOCK();\n }\n\n    BTIF_TRACE_EVENT(\"UIPC READ THREAD EXITING\");\n\n    uipc_main_cleanup();\n\n    uipc_main.tid = 0;\n\n    BTIF_TRACE_EVENT(\"UIPC READ THREAD DONE\");\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 9023, "func": "static void vmxnet3_net_uninit(VMXNET3State *s)\n{\n    g_free(s->mcast_list);\n    vmxnet3_deactivate_device(s);\n    qemu_del_nic(s->nic);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187441, "func": "void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst)\n {\n     if (src == NULL || src_len == 0 || dst == NULL) {\n         return;\n }\n\n const char16_t* cur_utf16 = src;\n const char16_t* const end_utf16 = src + src_len;\n char *cur = dst;\n while (cur_utf16 < end_utf16) {\n char32_t utf32;\n if((*cur_utf16 & 0xFC00) == 0xD800 && (cur_utf16 + 1) < end_utf16\n && (*(cur_utf16 + 1) & 0xFC00) == 0xDC00) {\n            utf32 = (*cur_utf16++ - 0xD800) << 10;\n            utf32 |= *cur_utf16++ - 0xDC00;\n            utf32 += 0x10000;\n } else {\n\n             utf32 = (char32_t) *cur_utf16++;\n         }\n         const size_t len = utf32_codepoint_utf8_length(utf32);\n         utf32_codepoint_to_utf8((uint8_t*)cur, utf32, len);\n         cur += len;\n     }\n     *cur = '\\0';\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188511, "func": " int main(int argc, char **argv) {\n FILE *infile = NULL;\n vpx_codec_ctx_t codec;\n vpx_codec_enc_cfg_t cfg;\n int frame_count = 0;\n vpx_image_t raw;\n vpx_codec_err_t res;\n VpxVideoInfo info = {0};\n VpxVideoWriter *writer = NULL;\n const VpxInterface *encoder = NULL;\n const int fps = 30; \n const int bitrate = 200; \n int keyframe_interval = 0;\n\n const char *codec_arg = NULL;\n const char *width_arg = NULL;\n const char *height_arg = NULL;\n const char *infile_arg = NULL;\n const char *outfile_arg = NULL;\n const char *keyframe_interval_arg = NULL;\n\n  exec_name = argv[0];\n\n if (argc < 7)\n    die(\"Invalid number of arguments\");\n\n  codec_arg = argv[1];\n  width_arg = argv[2];\n  height_arg = argv[3];\n  infile_arg = argv[4];\n  outfile_arg = argv[5];\n  keyframe_interval_arg = argv[6];\n\n  encoder = get_vpx_encoder_by_name(codec_arg);\n if (!encoder)\n     die(\"Unsupported codec.\");\n\n  info.codec_fourcc = encoder->fourcc;\n  info.frame_width = strtol(width_arg, NULL, 0);\n  info.frame_height = strtol(height_arg, NULL, 0);\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n\n if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n (info.frame_width % 2) != 0 ||\n (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n }\n\n if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n    die(\"Failed to allocate image.\");\n }\n\n  keyframe_interval = strtol(keyframe_interval_arg, NULL, 0);\n\n   if (keyframe_interval < 0)\n     die(\"Invalid keyframe interval value.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n \n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n  cfg.rc_target_bitrate = bitrate;\n  cfg.g_error_resilient = argc > 7 ? strtol(argv[7], NULL, 0) : 0;\n\n  writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);\n if (!writer)\n    die(\"Failed to open %s for writing.\", outfile_arg);\n\n\n   if (!(infile = fopen(infile_arg, \"rb\")))\n     die(\"Failed to open %s for reading.\", infile_arg);\n \n  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n     die_codec(&codec, \"Failed to initialize encoder\");\n \n   while (vpx_img_read(&raw, infile)) {\n     int flags = 0;\n     if (keyframe_interval > 0 && frame_count % keyframe_interval == 0)\n       flags |= VPX_EFLAG_FORCE_KF;\n     encode_frame(&codec, &raw, frame_count++, flags, writer);\n   }\n  encode_frame(&codec, NULL, -1, 0, writer);  \n \n   printf(\"\\n\");\n   fclose(infile);\n  printf(\"Processed %d frames.\\n\", frame_count);\n\n  vpx_img_free(&raw);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_writer_close(writer);\n\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "63,65,84,93"}
{"idx": 8732, "func": "static int check_policy(X509_STORE_CTX *ctx)\n{\n    int ret;\n    if (ctx->parent)\n        return 1;\n    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n                            ctx->param->policies, ctx->param->flags);\n    if (ret == 0) {\n        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        return 0;\n    }\n    if (ret == -1) {\n        X509 *x;\n        int i;\n        for (i = 1; i < sk_X509_num(ctx->chain); i++) {\n            x = sk_X509_value(ctx->chain, i);\n            if (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n                continue;\n            ctx->current_cert = x;\n            ctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\n            if (!ctx->verify_cb(0, ctx))\n                return 0;\n        }\n        return 1;\n    }\n    if (ret == -2) {\n        ctx->current_cert = NULL;\n        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n        return ctx->verify_cb(0, ctx);\n    }\n\n    if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {\n        ctx->current_cert = NULL;\n        if (!ctx->verify_cb(2, ctx))\n            return 0;\n    }\n\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8588, "func": "static int ssh_rportcmp_ssh2(void *av, void *bv)\n{\n    struct ssh_rportfwd *a = (struct ssh_rportfwd *) av;\n    struct ssh_rportfwd *b = (struct ssh_rportfwd *) bv;\n    int i;\n    if ( (i = strcmp(a->shost, b->shost)) != 0)\n\treturn i < 0 ? -1 : +1;\n    if (a->sport > b->sport)\n\treturn +1;\n    if (a->sport < b->sport)\n\treturn -1;\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188001, "func": "int Reverb_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n    LVREV_ControlParams_st    ActiveParams; \n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; \n\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_INIT: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Reverb_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n Reverb_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n                android_errorWriteLog(0x534e4554, \"26347509\");\n return -EINVAL;\n }\n if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n (void *)p->data,\n &p->vsize,\n                                                          p->data + voffset);\n\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n\n\n if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n \n             *(int *)pReplyData = android::Reverb_setParameter(pContext,\n                                                              (void *)p->data,\n                                                              p->data + p->psize);\n         } break;\n \n         case EFFECT_CMD_ENABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n break;\n case EFFECT_CMD_DISABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n\n if (pReplyData != NULL) { \n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n *(uint32_t *)pReplyData = (1 << 24);\n *((uint32_t *)pReplyData + 1) = (1 << 24);\n if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n }\n } else { \n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"DEFAULT start %d ERROR\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n} \n", "target": 1, "flaw_line_index": "131"}
{"idx": 8977, "func": "vmxnet3_can_receive(NetClientState *nc)\n{\n    VMXNET3State *s = qemu_get_nic_opaque(nc);\n    return s->device_active &&\n           VMXNET_FLAG_IS_SET(s->link_status_and_speed, VMXNET3_LINK_STATUS_UP);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188056, "func": "void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,\n impeg2d_video_decode_op_t *ps_op)\n{\n\n    UWORD32 u4_bits_read;\n dec_state_t *ps_dec;\n\n    ps_dec = (dec_state_t *)pv_dec;\n    ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;\n\n    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream),ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer,\n        ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes);\n\n {\n {\n            IMPEG2D_ERROR_CODES_T e_error;\n            e_error = impeg2d_process_video_header(ps_dec);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n                ps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;\n\n                u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n\n                ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n }\n\n                 if(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)\n                     ps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;\n \n \n                 impeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);\n                 return;\n             }\n }\n        ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;\n        ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;\n\n        ps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;\n        ps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;\n\n        u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n            ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n }\n        ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;\n        ps_dec->u2_header_done = 1;\n\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188617, "func": "static unsigned int subpel_variance_ref(const uint8_t *ref, const uint8_t *src,\n                                        int l2w, int l2h, int xoff, int yoff,\n                                        unsigned int *sse_ptr) {\n  int se = 0;\n  unsigned int sse = 0;\n  const int w = 1 << l2w, h = 1 << l2h;\n   for (int y = 0; y < h; y++) {\n     for (int x = 0; x < w; x++) {\n      const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n      const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n      const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n      const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n      const int r = a + (((b - a) * yoff + 8) >> 4);\n      int diff = r - src[w * y + x];\n      se += diff;\n      sse += diff * diff;\n     }\n   }\n  *sse_ptr = sse;\n  return sse - (((int64_t) se * se) >> (l2w + l2h));\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,9,10,11,12,13,14,15,16,17,18,19,22,23"}
{"idx": 8827, "func": "void vrend_clear(struct vrend_context *ctx,\n                 unsigned buffers,\n                 const union pipe_color_union *color,\n                 double depth, unsigned stencil)\n{\n   GLbitfield bits = 0;\n\n   if (ctx->in_error)\n      return;\n\n   if (ctx->ctx_switch_pending)\n      vrend_finish_context_switch(ctx);\n\n   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);\n\n   vrend_update_frontface_state(ctx);\n   if (ctx->sub->stencil_state_dirty)\n      vrend_update_stencil_state(ctx);\n   if (ctx->sub->scissor_state_dirty)\n      vrend_update_scissor_state(ctx);\n   if (ctx->sub->viewport_state_dirty)\n      vrend_update_viewport_state(ctx);\n\n   vrend_use_program(ctx, 0);\n\n   if (buffers & PIPE_CLEAR_COLOR) {\n      if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {\n         glClearColor(color->f[3], 0.0, 0.0, 0.0);\n      } else {\n         glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);\n      }\n   }\n\n   if (buffers & PIPE_CLEAR_DEPTH) {\n      glDepthMask(GL_TRUE);\n      glClearDepth(depth);\n   }\n\n   if (buffers & PIPE_CLEAR_STENCIL)\n      glClearStencil(stencil);\n\n   if (buffers & PIPE_CLEAR_COLOR) {\n      uint32_t mask = 0;\n      int i;\n      for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n         if (ctx->sub->surf[i])\n            mask |= (1 << i);\n      }\n      if (mask != (buffers >> 2)) {\n         mask = buffers >> 2;\n         while (mask) {\n            i = u_bit_scan(&mask);\n            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))\n               glClearBufferuiv(GL_COLOR,\n                                i, (GLuint *)color);\n            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))\n               glClearBufferiv(GL_COLOR,\n                                i, (GLint *)color);\n            else\n               glClearBufferfv(GL_COLOR,\n                                i, (GLfloat *)color);\n         }\n      }\n      else\n         bits |= GL_COLOR_BUFFER_BIT;\n   }\n   if (buffers & PIPE_CLEAR_DEPTH)\n      bits |= GL_DEPTH_BUFFER_BIT;\n   if (buffers & PIPE_CLEAR_STENCIL)\n      bits |= GL_STENCIL_BUFFER_BIT;\n\n   if (bits)\n      glClear(bits);\n\n   if (buffers & PIPE_CLEAR_DEPTH)\n      if (!ctx->sub->dsa_state.depth.writemask)\n         glDepthMask(GL_FALSE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8954, "func": "static void net_tx_pkt_do_sw_csum(struct NetTxPkt *pkt)\n{\n    struct iovec *iov = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n    uint32_t csum_cntr;\n    uint16_t csum = 0;\n    uint32_t cso;\n    uint32_t iov_len = pkt->payload_frags + NET_TX_PKT_PL_START_FRAG - 1;\n    uint16_t csl;\n    struct ip_header *iphdr;\n    size_t csum_offset = pkt->virt_hdr.csum_start + pkt->virt_hdr.csum_offset;\n\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n\n    csl = pkt->payload_len;\n\n    iphdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    csum_cntr = eth_calc_ip4_pseudo_hdr_csum(iphdr, csl, &cso);\n\n    csum_cntr +=\n        net_checksum_add_iov(iov, iov_len, pkt->virt_hdr.csum_start, csl, cso);\n\n    csum = cpu_to_be16(net_checksum_finish(csum_cntr));\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187442, "func": "ssize_t utf16_to_utf8_length(const char16_t *src, size_t src_len)\n{\n if (src == NULL || src_len == 0) {\n return -1;\n }\n\n size_t ret = 0;\n\n     const char16_t* const end = src + src_len;\n     while (src < end) {\n         if ((*src & 0xFC00) == 0xD800 && (src + 1) < end\n                && (*++src & 0xFC00) == 0xDC00) {\n             ret += 4;\n            src++;\n         } else {\n             ret += utf32_codepoint_utf8_length((char32_t) *src++);\n         }\n }\n return ret;\n}\n", "target": 1, "flaw_line_index": "12,15"}
{"idx": 187688, "func": "make_transform_images(png_store *ps)\n {\n    png_byte colour_type = 0;\n    png_byte bit_depth = 0;\n    unsigned int palette_number = 0;\n \n   safecat(ps->test, sizeof ps->test, 0, \"make standard images\");\n \n   while (next_format(&colour_type, &bit_depth, &palette_number, 0))\n    {\n       int interlace_type;\n \n for (interlace_type = PNG_INTERLACE_NONE;\n           interlace_type < INTERLACE_LAST; ++interlace_type)\n {\n\n          char name[FILE_NAME_SIZE];\n \n          standard_name(name, sizeof name, 0, colour_type, bit_depth,\n            palette_number, interlace_type, 0, 0, 0);\n         make_transform_image(ps, colour_type, bit_depth, palette_number,\n             interlace_type, name);\n       }\n    }\n }\n", "target": 1, "flaw_line_index": "7,9,20,21"}
{"idx": 8327, "func": "static void mcf_fec_update(mcf_fec_state *s)\n{\n    uint32_t active;\n    uint32_t changed;\n    uint32_t mask;\n    int i;\n\n    active = s->eir & s->eimr;\n    changed = active ^s->irq_state;\n    for (i = 0; i < FEC_NUM_IRQ; i++) {\n        mask = mcf_fec_irq_map[i];\n        if (changed & mask) {\n            DPRINTF(\"IRQ %d = %d\\n\", i, (active & mask) != 0);\n            qemu_set_irq(s->irq[i], (active & mask) != 0);\n        }\n    }\n    s->irq_state = active;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8444, "func": "pvscsi_reset_adapter(PVSCSIState *s)\n{\n    s->resetting++;\n    qbus_reset_all_fn(&s->bus);\n    s->resetting--;\n    pvscsi_process_completion_queue(s);\n    assert(QTAILQ_EMPTY(&s->pending_queue));\n    pvscsi_reset_state(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188043, "func": " static void copyStereo16(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned \n) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i];\n *dst++ = src[1][i];\n\n     }\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8882, "func": "static bool vrend_is_timer_query(GLenum gltype)\n{\n   return gltype == GL_TIMESTAMP ||\n      gltype == GL_TIME_ELAPSED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8700, "func": "sync_path (struct url *u)\n{\n  char *newpath, *efile, *edir;\n\n  xfree (u->path);\n\n  edir = url_escape_dir (u->dir);\n  efile = url_escape_1 (u->file, urlchr_unsafe | urlchr_reserved, 1);\n\n  if (!*edir)\n    newpath = xstrdup (efile);\n  else\n    {\n      int dirlen = strlen (edir);\n      int filelen = strlen (efile);\n\n      char *p = newpath = xmalloc (dirlen + 1 + filelen + 1);\n      memcpy (p, edir, dirlen);\n      p += dirlen;\n      *p++ = '/';\n      memcpy (p, efile, filelen);\n      p += filelen;\n      *p = '\\0';\n    }\n\n  u->path = newpath;\n\n  if (edir != u->dir)\n    xfree (edir);\n  if (efile != u->file)\n    xfree (efile);\n\n  xfree (u->url);\n  u->url = url_string (u, URL_AUTH_SHOW);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8747, "func": "vcard_response_new_status(vcard_7816_status_t status)\n{\n    VCardResponse *new_response;\n\n    new_response = g_new(VCardResponse, 1);\n    new_response->b_data = &new_response->b_sw1;\n    new_response->b_len = 0;\n    new_response->b_total_len = 2;\n    new_response->b_type = VCARD_MALLOC_STRUCT;\n    vcard_response_set_status(new_response, status);\n    return new_response;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9221, "func": "hwaddr virtio_queue_get_ring_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.desc;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188614, "func": "   virtual void TearDown() {\n     vpx_free(src_);\n     delete[] ref_;\n    vpx_free(sec_);\n     libvpx_test::ClearSystemState();\n   }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187752, "func": "chunk_type_valid(png_uint_32 c)\n{\n   png_uint_32 t;\n\n\n    c &= ~PNG_U32(32,32,0,32);\n    t = (c & ~0x1f1f1f1f) ^ 0x40404040;\n \n    c -= PNG_U32(65,65,65,65);\n   t |=c ;\n\n   c -= PNG_U32(25,25,25,26);\n   t |= ~c;\n\n return (t & 0xe0e0e0e0) == 0;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 8457, "func": "pvscsi_uninit(PCIDevice *pci_dev)\n{\n    PVSCSIState *s = PVSCSI(pci_dev);\n\n    trace_pvscsi_state(\"uninit\");\n    qemu_bh_delete(s->completion_worker);\n\n    pvscsi_cleanup_msi(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187377, "func": "int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n VisualizerContext * pContext = (VisualizerContext *)self;\n int retsize;\n\n if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n\n \n     switch (cmdCode) {\n     case EFFECT_CMD_INIT:\n        if (pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         *(int *) pReplyData = Visualizer_init(pContext);\n         break;\n     case EFFECT_CMD_SET_CONFIG:\n         if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n                || pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         *(int *) pReplyData = Visualizer_setConfig(pContext,\n                 (effect_config_t *) pCmdData);\n         break;\n     case EFFECT_CMD_GET_CONFIG:\n        if (pReplyData == NULL ||\n             *replySize != sizeof(effect_config_t)) {\n             return -EINVAL;\n         }\n Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n\n         Visualizer_reset(pContext);\n         break;\n     case EFFECT_CMD_ENABLE:\n        if (pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n\n         *(int *)pReplyData = 0;\n         break;\n     case EFFECT_CMD_DISABLE:\n        if (pReplyData == NULL || *replySize != sizeof(int)) {\n             return -EINVAL;\n         }\n         if (pContext->mState != VISUALIZER_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n\n     case EFFECT_CMD_GET_PARAM: {\n         if (pCmdData == NULL ||\n             cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL ||\n             *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {\n             return -EINVAL;\n         }\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));\n effect_param_t *p = (effect_param_t *)pReplyData;\n        p->status = 0;\n *replySize = sizeof(effect_param_t) + sizeof(uint32_t);\n if (p->psize != sizeof(uint32_t)) {\n            p->status = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case VISUALIZER_PARAM_CAPTURE_SIZE:\n            ALOGV(\"get mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n *((uint32_t *)p->data + 1) = pContext->mCaptureSize;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_SCALING_MODE:\n            ALOGV(\"get mScalingMode = %\" PRIu32, pContext->mScalingMode);\n *((uint32_t *)p->data + 1) = pContext->mScalingMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_MEASUREMENT_MODE:\n            ALOGV(\"get mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n default:\n            p->status = -EINVAL;\n }\n } break;\n\n     case EFFECT_CMD_SET_PARAM: {\n         if (pCmdData == NULL ||\n             cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || *replySize != sizeof(int32_t)) {\n             return -EINVAL;\n         }\n         *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {\n *(int32_t *)pReplyData = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case VISUALIZER_PARAM_CAPTURE_SIZE:\n            pContext->mCaptureSize = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n break;\n case VISUALIZER_PARAM_SCALING_MODE:\n            pContext->mScalingMode = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mScalingMode = %\" PRIu32, pContext->mScalingMode);\n break;\n case VISUALIZER_PARAM_LATENCY:\n            pContext->mLatency = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mLatency = %\" PRIu32, pContext->mLatency);\n break;\n case VISUALIZER_PARAM_MEASUREMENT_MODE:\n            pContext->mMeasurementMode = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n break;\n default:\n *(int32_t *)pReplyData = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n\n \n     case VISUALIZER_CMD_CAPTURE: {\n         uint32_t captureSize = pContext->mCaptureSize;\n        if (pReplyData == NULL || *replySize != captureSize) {\n             ALOGV(\"VISUALIZER_CMD_CAPTURE() error *replySize %\" PRIu32 \" captureSize %\" PRIu32,\n                     *replySize, captureSize);\n             return -EINVAL;\n }\n if (pContext->mState == VISUALIZER_STATE_ACTIVE) {\n const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n\n if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&\n (pContext->mBufferUpdateTime.tv_sec != 0) &&\n (deltaMs > MAX_STALL_TIME_MS)) {\n                    ALOGV(\"capture going to idle\");\n                    pContext->mBufferUpdateTime.tv_sec = 0;\n                    memset(pReplyData, 0x80, captureSize);\n } else {\n int32_t latencyMs = pContext->mLatency;\n                latencyMs -= deltaMs;\n if (latencyMs < 0) {\n                    latencyMs = 0;\n }\n const uint32_t deltaSmpl =\n                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;\n int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;\n\n if (capturePoint < 0) {\n uint32_t size = -capturePoint;\n if (size > captureSize) {\n                        size = captureSize;\n }\n                    memcpy(pReplyData,\n                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,\n                           size);\n                    pReplyData = (char *)pReplyData + size;\n                    captureSize -= size;\n                    capturePoint = 0;\n }\n                memcpy(pReplyData,\n                       pContext->mCaptureBuf + capturePoint,\n                       captureSize);\n }\n\n            pContext->mLastCaptureIdx = pContext->mCaptureIdx;\n } else {\n            memset(pReplyData, 0x80, captureSize);\n }\n\n } break;\n\n case VISUALIZER_CMD_MEASURE: {\n uint16_t peakU16 = 0;\n float sumRmsSquared = 0.0f;\n uint8_t nbValidMeasurements = 0;\n const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {\n            ALOGV(\"Discarding measurements, last measurement is %\" PRId32 \"ms old\", delayMs);\n for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {\n                pContext->mPastMeasurements[i].mIsValid = false;\n                pContext->mPastMeasurements[i].mPeakU16 = 0;\n                pContext->mPastMeasurements[i].mRmsSquared = 0;\n }\n            pContext->mMeasurementBufferIdx = 0;\n } else {\n for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {\n if (pContext->mPastMeasurements[i].mIsValid) {\n if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {\n                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;\n }\n                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;\n                    nbValidMeasurements++;\n }\n }\n }\n float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);\n int32_t* pIntReplyData = (int32_t*)pReplyData;\n if (rms < 0.000016f) {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; \n } else {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));\n }\n if (peakU16 == 0) {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; \n } else {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));\n }\n        ALOGV(\"VISUALIZER_CMD_MEASURE peak=%\" PRIu16 \" (%\" PRId32 \"mB), rms=%.1f (%\" PRId32 \"mB)\",\n                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],\n                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);\n }\n break;\n\n default:\n        ALOGW(\"Visualizer_command invalid command %\" PRIu32, cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "16,23,30,41,53,67,106,145"}
{"idx": 8470, "func": "BOOL CSoundFile::DestroySample(UINT nSample)\n{\n\tif ((!nSample) || (nSample >= MAX_SAMPLES)) return FALSE;\n\tif (!Ins[nSample].pSample) return TRUE;\n\tMODINSTRUMENT *pins = &Ins[nSample];\n\tsigned char *pSample = pins->pSample;\n\tpins->pSample = NULL;\n\tpins->nLength = 0;\n\tpins->uFlags &= ~(CHN_16BIT);\n\tfor (UINT i=0; i<MAX_CHANNELS; i++)\n\t{\n\t\tif (Chn[i].pSample == pSample)\n\t\t{\n\t\t\tChn[i].nPos = Chn[i].nLength = 0;\n\t\t\tChn[i].pSample = Chn[i].pCurrentSample = NULL;\n\t\t}\n\t}\n\tFreeSample(pSample);\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8525, "func": "static int s_wrpkt_prepare(Ssh ssh, struct Packet *pkt, int *offset_p)\n{\n    int pad, biglen, i, pktoffs;\n    unsigned long crc;\n#ifdef __SC__\n    volatile\n#endif\n    int len;\n\n    if (ssh->logctx)\n        ssh1_log_outgoing_packet(ssh, pkt);\n\n    if (ssh->v1_compressing) {\n\tunsigned char *compblk;\n\tint complen;\n\tzlib_compress_block(ssh->cs_comp_ctx,\n\t\t\t    pkt->data + 12, pkt->length - 12,\n\t\t\t    &compblk, &complen);\n\tssh_pkt_ensure(pkt, complen + 2);   \n\tmemcpy(pkt->data + 12, compblk, complen);\n\tsfree(compblk);\n\tpkt->length = complen + 12;\n    }\n\n    ssh_pkt_ensure(pkt, pkt->length + 4); \n    pkt->length += 4;\n    len = pkt->length - 4 - 8;\t\n    pad = 8 - (len % 8);\n    pktoffs = 8 - pad;\n    biglen = len + pad;\t\t\n\n    for (i = pktoffs; i < 4+8; i++)\n\tpkt->data[i] = random_byte();\n    crc = crc32_compute(pkt->data + pktoffs + 4, biglen - 4); \n    PUT_32BIT(pkt->data + pktoffs + 4 + biglen - 4, crc);\n    PUT_32BIT(pkt->data + pktoffs, len);\n\n    if (ssh->cipher)\n\tssh->cipher->encrypt(ssh->v1_cipher_ctx,\n\t\t\t     pkt->data + pktoffs + 4, biglen);\n\n    if (offset_p) *offset_p = pktoffs;\n    return biglen + 4;\t\t\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8639, "func": "size_t mptsas_config_io_unit_2(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDevice *pci = PCI_DEVICE(s);\n    uint8_t devfn = pci->devfn;\n    return MPTSAS_CONFIG_PACK(2, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x02,\n                              \"llbbw*b*b*w*b*b*w*b*b*w*l\",\n                              0, 0x100, 0 \n, devfn, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8371, "func": "static void mptsas_process_event_notification(MPTSASState *s,\n                                              MPIMsgEventNotify *req)\n{\n    MPIMsgEventNotifyReply reply;\n\n    mptsas_fix_event_notification_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n\n    memset(&reply, 0, sizeof(reply));\n    reply.EventDataLength = sizeof(reply.Data) / 4;\n    reply.MsgLength       = sizeof(reply) / 4;\n    reply.Function        = req->Function;\n\n    reply.MsgFlags        = MPI_MSGFLAGS_CONTINUATION_REPLY;\n\n    reply.MsgContext      = req->MsgContext;\n    reply.Event           = MPI_EVENT_EVENT_CHANGE;\n    reply.Data[0]         = !!req->Switch;\n\n    mptsas_fix_event_notification_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8749, "func": "vcard_response_set_status(VCardResponse *response, vcard_7816_status_t status)\n{\n    unsigned char sw1, sw2;\n    response->b_status = status; \n    sw1 = (status >> 8) & 0xff;\n    sw2 = status & 0xff;\n    response->b_sw1 = sw1;\n    response->b_sw2 = sw2;\n    response->b_data[response->b_len] = sw1;\n    response->b_data[response->b_len+1] = sw2;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9055, "func": "static inline void vmxnet3_ring_read_curr_cell(PCIDevice *d, Vmxnet3Ring *ring,\n\t\t\t\t\t       void *buff)\n{\n    vmw_shmem_read(d, vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell_size);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9020, "func": "vmxnet3_msix_load(QEMUFile *f, void *opaque, int version_id)\n{\n    PCIDevice *d = PCI_DEVICE(opaque);\n    msix_load(d, f);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188048, "func": "FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(\n const FLAC__Frame *frame, const FLAC__int32 * const buffer[])\n{\n if (mWriteRequested) {\n\n         mWriteRequested = false;\n         mWriteHeader = frame->header;\n        mWriteBuffer = buffer;\n         mWriteCompleted = true;\n         return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;\n     } else {\n        ALOGE(\"FLACParser::writeCallback unexpected\");\n return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;\n }\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 187440, "func": " static char* allocFromUTF32(const char32_t* in, size_t len)\n{\n if (len == 0) {\n\n         return getEmptyString();\n     }\n \n    const ssize_t bytes = utf32_to_utf8_length(in, len);\n    if (bytes < 0) {\n         return getEmptyString();\n     }\n \n    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);\n     ALOG_ASSERT(buf, \"Unable to allocate shared buffer\");\n     if (!buf) {\n         return getEmptyString();\n     }\n \n    char* str = (char*) buf->data();\n    utf32_to_utf8(in, len, str);\n \n    return str;\n }\n", "target": 1, "flaw_line_index": "8,9,13,19,20,22"}
{"idx": 8644, "func": "size_t mptsas_config_ioc_3(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IOC, 0x00,\n                              \"*b*b*w\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8759, "func": "unsigned FAST_FUNC udhcp_option_idx(const char *name, const char *option_strings)\n{\n\tint n = index_in_strings(option_strings, name);\n\tif (n >= 0)\n\t\treturn n;\n\n\t{\n\t\tchar *buf, *d;\n\t\tconst char *s;\n\n\t\ts = option_strings;\n\t\twhile (*s)\n\t\t\ts += strlen(s) + 1;\n\n\t\td = buf = xzalloc(s - option_strings);\n\t\ts = option_strings;\n\t\twhile (!(*s == '\\0' && s[1] == '\\0')) {\n\t\t\t*d++ = (*s == '\\0' ? ' ' : *s);\n\t\t\ts++;\n\t\t}\n\t\tbb_error_msg_and_die(\"unknown option '%s', known options: %s\", name, buf);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8607, "func": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n                struct vmsvga_cursor_definition_s *c)\n{\n    QEMUCursor *qc;\n    int i, pixels;\n\n    qc = cursor_alloc(c->width, c->height);\n    qc->hot_x = c->hot_x;\n    qc->hot_y = c->hot_y;\n    switch (c->bpp) {\n    case 1:\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void *)c->image,\n                        1, (void *)c->mask);\n#ifdef DEBUG\n        cursor_print_ascii_art(qc, \"vmware/mono\");\n#endif\n        break;\n    case 32:\n        cursor_set_mono(qc, 0x000000, 0x000000, (void *)c->mask,\n                        1, (void *)c->mask);\n        pixels = c->width * c->height;\n        for (i = 0; i < pixels; i++) {\n            qc->data[i] |= c->image[i] & 0xffffff;\n        }\n#ifdef DEBUG\n        cursor_print_ascii_art(qc, \"vmware/32bit\");\n#endif\n        break;\n    default:\n        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\",\n                __func__, c->bpp);\n        cursor_put(qc);\n        qc = cursor_builtin_left_ptr();\n    }\n\n    dpy_cursor_define(s->vga.con, qc);\n    cursor_put(qc);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187597, "func": "static void rpng2_x_redisplay_image(ulg startcol, ulg startrow,\n                                    ulg width, ulg height)\n{\n    uch bg_red   = rpng2_info.bg_red;\n    uch bg_green = rpng2_info.bg_green;\n    uch bg_blue  = rpng2_info.bg_blue;\n    uch *src, *src2=NULL;\n char *dest;\n    uch r, g, b, a;\n    ulg i, row, lastrow = 0;\n    ulg pixel;\n int ximage_rowbytes = ximage->bytes_per_line;\n\n\n Trace((stderr, \"beginning display loop (image_channels == %d)\\n\",\n      rpng2_info.channels))\n Trace((stderr, \"   (width = %ld, rowbytes = %d, ximage_rowbytes = %d)\\n\",\n      rpng2_info.width, rpng2_info.rowbytes, ximage_rowbytes))\n Trace((stderr, \"   (bpp = %d)\\n\", ximage->bits_per_pixel))\n Trace((stderr, \"   (byte_order = %s)\\n\", ximage->byte_order == MSBFirst?\n \"MSBFirst\" : (ximage->byte_order == LSBFirst? \"LSBFirst\" : \"unknown\")))\n\n\n if (depth == 24 || depth == 32) {\n        ulg red, green, blue;\n int bpp = ximage->bits_per_pixel;\n\n for (lastrow = row = startrow;  row < startrow+height; ++row) {\n            src = rpng2_info.image_data + row*rpng2_info.rowbytes;\n if (bg_image)\n                src2 = bg_data + row*bg_rowbytes;\n            dest = ximage->data + row*ximage_rowbytes;\n if (rpng2_info.channels == 3) {\n for (i = rpng2_info.width;  i > 0; --i) {\n                    red   = *src++;\n                    green = *src++;\n                    blue  = *src++;\n#ifdef NO_24BIT_MASKS\n                    pixel = (red   << RShift) |\n (green << GShift) |\n (blue  << BShift);\n if (bpp == 32) {\n *dest++ = (char)((pixel >> 24) & 0xff);\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n } else {\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n }\n#else\n                    red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;\n                    green = (GShift < 0)? green << (-GShift) : green >> GShift;\n                    blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;\n                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);\n if (bpp == 32) {\n *dest++ = (char)((pixel >> 24) & 0xff);\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n } else {\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n }\n#endif\n }\n\n } else \n {\n for (i = rpng2_info.width;  i > 0; --i) {\n                    r = *src++;\n                    g = *src++;\n                    b = *src++;\n                    a = *src++;\n if (bg_image) {\n                        bg_red   = *src2++;\n                        bg_green = *src2++;\n                        bg_blue  = *src2++;\n }\n if (a == 255) {\n                        red   = r;\n                        green = g;\n                        blue  = b;\n } else if (a == 0) {\n                        red   = bg_red;\n                        green = bg_green;\n                        blue  = bg_blue;\n } else {\n                        alpha_composite(red,   r, a, bg_red);\n                        alpha_composite(green, g, a, bg_green);\n                        alpha_composite(blue,  b, a, bg_blue);\n }\n#ifdef NO_24BIT_MASKS\n                    pixel = (red   << RShift) |\n (green << GShift) |\n (blue  << BShift);\n if (bpp == 32) {\n *dest++ = (char)((pixel >> 24) & 0xff);\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n } else {\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n }\n#else\n                    red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;\n                    green = (GShift < 0)? green << (-GShift) : green >> GShift;\n                    blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;\n                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);\n if (bpp == 32) {\n *dest++ = (char)((pixel >> 24) & 0xff);\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n } else {\n *dest++ = (char)((pixel >> 16) & 0xff);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n }\n#endif\n }\n }\n if (((row+1) & 0xf) == 0) {\n XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,\n (int)lastrow, rpng2_info.width, 16);\n XFlush(display);\n                lastrow = row + 1;\n }\n }\n\n } else if (depth == 16) {\n        ush red, green, blue;\n\n for (lastrow = row = startrow;  row < startrow+height; ++row) {\n            src = rpng2_info.row_pointers[row];\n if (bg_image)\n                src2 = bg_data + row*bg_rowbytes;\n            dest = ximage->data + row*ximage_rowbytes;\n if (rpng2_info.channels == 3) {\n for (i = rpng2_info.width;  i > 0; --i) {\n                    red   = ((ush)(*src) << 8);\n ++src;\n                    green = ((ush)(*src) << 8);\n ++src;\n                    blue  = ((ush)(*src) << 8);\n ++src;\n                    pixel = ((red   >> RShift) & RMask) |\n ((green >> GShift) & GMask) |\n ((blue  >> BShift) & BMask);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n }\n } else \n {\n for (i = rpng2_info.width;  i > 0; --i) {\n                    r = *src++;\n                    g = *src++;\n                    b = *src++;\n                    a = *src++;\n if (bg_image) {\n                        bg_red   = *src2++;\n                        bg_green = *src2++;\n                        bg_blue  = *src2++;\n }\n if (a == 255) {\n                        red   = ((ush)r << 8);\n                        green = ((ush)g << 8);\n                        blue  = ((ush)b << 8);\n } else if (a == 0) {\n                        red   = ((ush)bg_red   << 8);\n                        green = ((ush)bg_green << 8);\n                        blue  = ((ush)bg_blue  << 8);\n } else {\n                        alpha_composite(r, r, a, bg_red);\n                        alpha_composite(g, g, a, bg_green);\n                        alpha_composite(b, b, a, bg_blue);\n                        red   = ((ush)r << 8);\n                        green = ((ush)g << 8);\n                        blue  = ((ush)b << 8);\n }\n                    pixel = ((red   >> RShift) & RMask) |\n ((green >> GShift) & GMask) |\n ((blue  >> BShift) & BMask);\n *dest++ = (char)((pixel >> 8) & 0xff);\n *dest++ = (char)( pixel        & 0xff);\n }\n }\n if (((row+1) & 0xf) == 0) {\n XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,\n (int)lastrow, rpng2_info.width, 16);\n XFlush(display);\n                lastrow = row + 1;\n }\n }\n\n } else \n {\n\n\n }\n\n Trace((stderr, \"calling final XPutImage()\\n\"))\n if (lastrow < startrow+height) {\n XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,\n (int)lastrow, rpng2_info.width, rpng2_info.height-lastrow);\n\n         XFlush(display);\n     }\n \n } \n", "target": 1, "flaw_line_index": ""}
{"idx": 8674, "func": "static size_t vfill(uint8_t *data, size_t size, const char *fmt, va_list ap)\n{\n    size_t ofs;\n    PackValue val;\n    const char *p;\n\n    ofs = 0;\n    p = fmt;\n    while (*p) {\n        memset(&val, 0, sizeof(val));\n        switch (*p) {\n        case '*':\n            p++;\n            break;\n        case 'b':\n        case 'w':\n        case 'l':\n            val.ll = va_arg(ap, int);\n            break;\n        case 'q':\n            val.ll = va_arg(ap, int64_t);\n            break;\n        case 's':\n            val.str = va_arg(ap, void *);\n            break;\n        }\n        switch (*p++) {\n        case 'b':\n            if (data) {\n                stb_p(data + ofs, val.ll);\n            }\n            ofs++;\n            break;\n        case 'w':\n            if (data) {\n                stw_le_p(data + ofs, val.ll);\n            }\n            ofs += 2;\n            break;\n        case 'l':\n            if (data) {\n                stl_le_p(data + ofs, val.ll);\n            }\n            ofs += 4;\n            break;\n        case 'q':\n            if (data) {\n                stq_le_p(data + ofs, val.ll);\n            }\n            ofs += 8;\n            break;\n        case 's':\n            {\n                int cnt = atoi(p);\n                if (data) {\n                    if (val.str) {\n                        strncpy((void *)data + ofs, val.str, cnt);\n                    } else {\n                        memset((void *)data + ofs, 0, cnt);\n                    }\n                }\n                ofs += cnt;\n                break;\n            }\n        }\n    }\n\n    return ofs;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8787, "func": "static void __report_core_warn(const char *fname, struct vrend_context *ctx, enum virgl_ctx_errors error, uint32_t value)\n{\n   fprintf(stderr,\"%s: core profile violation reported %d \\\"%s\\\" %s %d\\n\", fname, ctx->ctx_id, ctx->debug_name, vrend_core_profile_warn_strings[error], value);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9201, "func": "static bool virtio_extra_state_needed(void *opaque)\n{\n    VirtIODevice *vdev = opaque;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    return k->has_extra_state &&\n        k->has_extra_state(qbus->parent);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8411, "func": "pvscsi_get_next_sg_elem(PVSCSISGState *sg)\n{\n    struct PVSCSISGElement elem;\n\n    cpu_physical_memory_read(sg->elemAddr, (void *)&elem, sizeof(elem));\n    if ((elem.flags & ~PVSCSI_KNOWN_FLAGS) != 0) {\n        trace_pvscsi_get_next_sg_elem(elem.flags);\n    }\n\n    sg->elemAddr += sizeof(elem);\n    sg->dataAddr = elem.addr;\n    sg->resid = elem.length;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8721, "func": "void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n{\n    if (ctx->cleanup != NULL) {\n        ctx->cleanup(ctx);\n        ctx->cleanup = NULL;\n    }\n    if (ctx->param != NULL) {\n        if (ctx->parent == NULL)\n            X509_VERIFY_PARAM_free(ctx->param);\n        ctx->param = NULL;\n    }\n    if (ctx->tree != NULL) {\n        X509_policy_tree_free(ctx->tree);\n        ctx->tree = NULL;\n    }\n    if (ctx->chain != NULL) {\n        sk_X509_pop_free(ctx->chain, X509_free);\n        ctx->chain = NULL;\n    }\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\n    memset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8401, "func": "pvscsi_build_sglist(PVSCSIState *s, PVSCSIRequest *r)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    pci_dma_sglist_init(&r->sgl, d, 1);\n    if (r->req.flags & PVSCSI_FLAG_CMD_WITH_SG_LIST) {\n        pvscsi_convert_sglist(r);\n    } else {\n        qemu_sglist_add(&r->sgl, r->req.dataAddr, r->req.dataLen);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8538, "func": "static unsigned char *ssh2_mpint_fmt(Bignum b, int *len)\n{\n    unsigned char *p;\n    int i, n = (bignum_bitcount(b) + 7) / 8;\n    p = snewn(n + 1, unsigned char);\n    p[0] = 0;\n    for (i = 1; i <= n; i++)\n\tp[i] = bignum_byte(b, n - i);\n    i = 0;\n    while (i <= n && p[i] == 0 && (p[i + 1] & 0x80) == 0)\n\ti++;\n    memmove(p, p + i, n + 1 - i);\n    *len = n + 1 - i;\n    return p;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8604, "func": "static inline void vmsvga_check_size(struct vmsvga_state_s *s)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n\n    if (s->new_width != surface_width(surface) ||\n        s->new_height != surface_height(surface) ||\n        s->new_depth != surface_bits_per_pixel(surface)) {\n        int stride = (s->new_depth * s->new_width) / 8;\n        pixman_format_code_t format =\n            qemu_default_pixman_format(s->new_depth, true);\n        trace_vmware_setmode(s->new_width, s->new_height, s->new_depth);\n        surface = qemu_create_displaysurface_from(s->new_width, s->new_height,\n                                                  format, stride,\n                                                  s->vga.vram_ptr);\n        dpy_gfx_replace_surface(s->vga.con, surface);\n        s->invalidated = 1;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187635, "func": "gamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi)\n{\n   standard_info_part1(&dp->this, pp, pi);\n\n\n    if (dp->scale16)\n #     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n         png_set_scale_16(pp);\n#     else\n#        ifdef PNG_READ_16_TO_8_SUPPORTED\n            png_set_strip_16(pp);\n#        else\n            png_error(pp, \"scale16 (16 to 8 bit conversion) not supported\");\n#        endif\n#     endif\n\n if (dp->expand16)\n#     ifdef PNG_READ_EXPAND_16_SUPPORTED\n         png_set_expand_16(pp);\n#     else\n         png_error(pp, \"expand16 (8 to 16 bit conversion) not supported\");\n#     endif\n\n if (dp->do_background >= ALPHA_MODE_OFFSET)\n {\n#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n {\n int mode = dp->do_background - ALPHA_MODE_OFFSET;\n\n         PNG_CONST double sg = dp->screen_gamma;\n #        ifndef PNG_FLOATING_POINT_SUPPORTED\n            PNG_CONST png_fixed_point g = fix(sg);\n #        endif\n \n #        ifdef PNG_FLOATING_POINT_SUPPORTED\n            png_set_alpha_mode(pp, mode, sg);\n#        else\n            png_set_alpha_mode_fixed(pp, mode, g);\n#        endif\n\n if (mode == PNG_ALPHA_STANDARD && sg != 1)\n {\n#           ifdef PNG_FLOATING_POINT_SUPPORTED\n               png_set_gamma(pp, sg, dp->file_gamma);\n#           else\n               png_fixed_point f = fix(dp->file_gamma);\n               png_set_gamma_fixed(pp, g, f);\n#           endif\n }\n }\n#     else\n         png_error(pp, \"alpha mode handling not supported\");\n#     endif\n }\n\n else\n {\n#     ifdef PNG_FLOATING_POINT_SUPPORTED\n         png_set_gamma(pp, dp->screen_gamma, dp->file_gamma);\n#     else\n {\n         png_fixed_point s = fix(dp->screen_gamma);\n         png_fixed_point f = fix(dp->file_gamma);\n         png_set_gamma_fixed(pp, s, f);\n }\n#     endif\n\n if (dp->do_background)\n {\n\n #     ifdef PNG_READ_BACKGROUND_SUPPORTED\n         PNG_CONST double bg = dp->background_gamma;\n #        ifndef PNG_FLOATING_POINT_SUPPORTED\n            PNG_CONST png_fixed_point g = fix(bg);\n #        endif\n \n #        ifdef PNG_FLOATING_POINT_SUPPORTED\n            png_set_background(pp, &dp->background_color, dp->do_background,\n 0\n, bg);\n#        else\n            png_set_background_fixed(pp, &dp->background_color,\n               dp->do_background, 0\n, g);\n#        endif\n#     else\n         png_error(pp, \"png_set_background not supported\");\n#     endif\n }\n }\n\n {\n int i = dp->this.use_update_info;\n do\n         png_read_update_info(pp, pi);\n while (--i > 0);\n }\n\n   standard_info_part2(&dp->this, pp, pi, 1 \n);\n}\n", "target": 1, "flaw_line_index": "30,32,72,74"}
{"idx": 8744, "func": "vcard_response_new(VCard *card, unsigned char *buf,\n                   int len, int Le, vcard_7816_status_t status)\n{\n    VCardResponse *new_response;\n\n    if (len > Le) {\n        return vcard_init_buffer_response(card, buf, len);\n    }\n    new_response = vcard_response_new_data(buf, len);\n    if (new_response == NULL) {\n        return NULL;\n    }\n    vcard_response_set_status(new_response, status);\n    return new_response;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187659, "func": "image_transform_png_set_gray_to_rgb_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_gray_to_rgb(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187371, "func": " extern \"C\" int EffectCreate(const effect_uuid_t *uuid,\n                            int32_t             sessionId,\n                            int32_t             ioId,\n                             effect_handle_t  *pHandle){\n     int ret;\n     int i;\n int length = sizeof(gDescriptors) / sizeof(const effect_descriptor_t *);\n const effect_descriptor_t *desc;\n\n    ALOGV(\"\\t\\nEffectCreate start\");\n\n if (pHandle == NULL || uuid == NULL){\n        ALOGV(\"\\tLVM_ERROR : EffectCreate() called with NULL pointer\");\n return -EINVAL;\n }\n\n for (i = 0; i < length; i++) {\n        desc = gDescriptors[i];\n if (memcmp(uuid, &desc->uuid, sizeof(effect_uuid_t))\n == 0) {\n            ALOGV(\"\\tEffectCreate - UUID matched Reverb type %d, UUID = %x\", i, desc->uuid.timeLow);\n break;\n }\n }\n\n if (i == length) {\n return -ENOENT;\n }\n\n ReverbContext *pContext = new ReverbContext;\n\n    pContext->itfe      = &gReverbInterface;\n    pContext->hInstance = NULL;\n\n    pContext->auxiliary = false;\n if ((desc->flags & EFFECT_FLAG_TYPE_MASK) == EFFECT_FLAG_TYPE_AUXILIARY){\n        pContext->auxiliary = true;\n        ALOGV(\"\\tEffectCreate - AUX\");\n }else{\n        ALOGV(\"\\tEffectCreate - INS\");\n }\n\n    pContext->preset = false;\n if (memcmp(&desc->type, SL_IID_PRESETREVERB, sizeof(effect_uuid_t)) == 0) {\n        pContext->preset = true;\n        pContext->curPreset = REVERB_PRESET_LAST + 1;\n        pContext->nextPreset = REVERB_DEFAULT_PRESET;\n        ALOGV(\"\\tEffectCreate - PRESET\");\n }else{\n        ALOGV(\"\\tEffectCreate - ENVIRONMENTAL\");\n }\n\n    ALOGV(\"\\tEffectCreate - Calling Reverb_init\");\n    ret = Reverb_init(pContext);\n\n if (ret < 0){\n        ALOGV(\"\\tLVM_ERROR : EffectCreate() init failed\");\n delete pContext;\n return ret;\n }\n\n *pHandle = (effect_handle_t)pContext;\n\n #ifdef LVM_PCM\n    pContext->PcmInPtr = NULL;\n    pContext->PcmOutPtr = NULL;\n\n    pContext->PcmInPtr = fopen(\"/data/tmp/reverb_pcm_in.pcm\", \"w\");\n    pContext->PcmOutPtr = fopen(\"/data/tmp/reverb_pcm_out.pcm\", \"w\");\n\n if((pContext->PcmInPtr == NULL)||\n (pContext->PcmOutPtr == NULL)){\n return -EINVAL;\n }\n #endif\n\n\n    pContext->InFrames32 = (LVM_INT32 *)malloc(LVREV_MAX_FRAME_SIZE * sizeof(LVM_INT32) * 2);\n    pContext->OutFrames32 = (LVM_INT32 *)malloc(LVREV_MAX_FRAME_SIZE * sizeof(LVM_INT32) * 2);\n\n    ALOGV(\"\\tEffectCreate %p, size %zu\", pContext, sizeof(ReverbContext));\n    ALOGV(\"\\tEffectCreate end\\n\");\n return 0;\n} \n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8839, "func": "static void vrend_destroy_program(struct vrend_linked_shader_program *ent)\n{\n   int i;\n   glDeleteProgram(ent->id);\n   list_del(&ent->head);\n\n   for (i = PIPE_SHADER_VERTEX; i <= PIPE_SHADER_GEOMETRY; i++) {\n      if (ent->ss[i])\n         list_del(&ent->sl[i]);\n      free(ent->shadow_samp_mask_locs[i]);\n      free(ent->shadow_samp_add_locs[i]);\n      free(ent->samp_locs[i]);\n      free(ent->const_locs[i]);\n      free(ent->ubo_locs[i]);\n   }\n   free(ent->attrib_locs);\n   free(ent);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187374, "func": "int NsSetParameter (preproc_effect_t *effect, void *pParam, void *pValue)\n {\n     int status = 0;\n     return status;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187815, "func": "OMX_ERRORTYPE  omx_video::get_config(OMX_IN OMX_HANDLETYPE      hComp,\n        OMX_IN OMX_INDEXTYPE configIndex,\n        OMX_INOUT OMX_PTR     configData)\n{\n (void)hComp;\n\n if (configData == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: param is null\");\n return OMX_ErrorBadParameter;\n }\n\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"ERROR: can't be in invalid state\");\n return OMX_ErrorIncorrectStateOperation;\n }\n\n\n     switch ((int)configIndex) {\n         case OMX_IndexConfigVideoBitrate:\n             {\n                 OMX_VIDEO_CONFIG_BITRATETYPE* pParam = reinterpret_cast<OMX_VIDEO_CONFIG_BITRATETYPE*>(configData);\n                 memcpy(pParam, &m_sConfigBitrate, sizeof(m_sConfigBitrate));\n                 break;\n             }\n         case OMX_IndexConfigVideoFramerate:\n             {\n                 OMX_CONFIG_FRAMERATETYPE* pParam = reinterpret_cast<OMX_CONFIG_FRAMERATETYPE*>(configData);\n                 memcpy(pParam, &m_sConfigFramerate, sizeof(m_sConfigFramerate));\n                 break;\n             }\n         case OMX_IndexConfigCommonRotate:\n             {\n                 OMX_CONFIG_ROTATIONTYPE* pParam = reinterpret_cast<OMX_CONFIG_ROTATIONTYPE*>(configData);\n                 memcpy(pParam, &m_sConfigFrameRotation, sizeof(m_sConfigFrameRotation));\n                 break;\n }\n\n         case QOMX_IndexConfigVideoIntraperiod:\n             {\n                 DEBUG_PRINT_LOW(\"get_config:QOMX_IndexConfigVideoIntraperiod\");\n                 QOMX_VIDEO_INTRAPERIODTYPE* pParam = reinterpret_cast<QOMX_VIDEO_INTRAPERIODTYPE*>(configData);\n                 memcpy(pParam, &m_sIntraperiod, sizeof(m_sIntraperiod));\n                 break;\n             }\n         case OMX_IndexConfigVideoAVCIntraPeriod:\n             {\n                 OMX_VIDEO_CONFIG_AVCINTRAPERIOD *pParam =\n                     reinterpret_cast<OMX_VIDEO_CONFIG_AVCINTRAPERIOD*>(configData);\n                 DEBUG_PRINT_LOW(\"get_config: OMX_IndexConfigVideoAVCIntraPeriod\");\n                memcpy(pParam, &m_sConfigAVCIDRPeriod, sizeof(m_sConfigAVCIDRPeriod));\n break;\n\n             }\n         case OMX_IndexConfigCommonDeinterlace:\n             {\n                 OMX_VIDEO_CONFIG_DEINTERLACE *pParam =\n                     reinterpret_cast<OMX_VIDEO_CONFIG_DEINTERLACE*>(configData);\n                 DEBUG_PRINT_LOW(\"get_config: OMX_IndexConfigCommonDeinterlace\");\n                memcpy(pParam, &m_sConfigDeinterlace, sizeof(m_sConfigDeinterlace));\n break;\n\n             }\n        case OMX_IndexConfigVideoVp8ReferenceFrame:\n            {\n                OMX_VIDEO_VP8REFERENCEFRAMETYPE* pParam =\n                    reinterpret_cast<OMX_VIDEO_VP8REFERENCEFRAMETYPE*>(configData);\n                DEBUG_PRINT_LOW(\"get_config: OMX_IndexConfigVideoVp8ReferenceFrame\");\n               memcpy(pParam, &m_sConfigVp8ReferenceFrame, sizeof(m_sConfigVp8ReferenceFrame));\n break;\n\n            }\n         case OMX_QcomIndexConfigPerfLevel:\n             {\n                 OMX_U32 perflevel;\n                 OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *pParam =\n                     reinterpret_cast<OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL*>(configData);\n                DEBUG_PRINT_LOW(\"get_config: OMX_QcomIndexConfigPerfLevel\");\n if (!dev_get_performance_level(&perflevel)) {\n                    DEBUG_PRINT_ERROR(\"Invalid entry returned from get_performance_level %d\",\n                        pParam->ePerfLevel);\n } else {\n                    pParam->ePerfLevel = (QOMX_VIDEO_PERF_LEVEL)perflevel;\n }\n break;\n }\n default:\n            DEBUG_PRINT_ERROR(\"ERROR: unsupported index %d\", (int) configIndex);\n return OMX_ErrorUnsupportedIndex;\n }\n return OMX_ErrorNone;\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8662, "func": "size_t mptsas_config_sas_device_0(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_device_addr_get(s, address);\n    SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n\n    trace_mptsas_config_sas_device(s, address, i, phy_handle, dev_handle, 0);\n    if (!dev) {\n        return -ENOENT;\n    }\n\n    return MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE, 0x05,\n                                  \"*w*wqwbbwbblwb*b\",\n                                  dev->wwn, phy_handle, i,\n                                  MPI_SAS_DEVICE0_ASTATUS_NO_ERRORS,\n                                  dev_handle, i, 0,\n                                  MPI_SAS_DEVICE_INFO_END_DEVICE | MPI_SAS_DEVICE_INFO_SSP_TARGET,\n                                  (MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT |\n                                   MPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED |\n                                   MPI_SAS_DEVICE0_FLAGS_MAPPING_PERSISTENT), i);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8310, "func": "XFixesIntersectRegion (Display *dpy, XserverRegion dst,\n\t\t       XserverRegion src1, XserverRegion src2)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesIntersectRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesIntersectRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesIntersectRegion;\n    req->source1 = src1;\n    req->source2 = src2;\n    req->destination = dst;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8412, "func": "static QEMUSGList *pvscsi_get_sg_list(SCSIRequest *r)\n{\n    PVSCSIRequest *req = r->hba_private;\n\n    trace_pvscsi_get_sg_list(req->sgl.nsg, req->sgl.size);\n\n    return &req->sgl;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188073, "func": "UWORD32 ihevcd_cabac_decode_bypass_bins_egk(cab_ctxt_t *ps_cabac,\n bitstrm_t *ps_bitstrm,\n                                            WORD32 k)\n{\n\n    UWORD32 u4_sym;\n    WORD32 numones;\n    WORD32 bin;\n\n    ASSERT((k >= 0));\n\n\n     numones = k;\n     bin = 1;\n     u4_sym = 0;\n    while(bin)\n     {\n         IHEVCD_CABAC_DECODE_BYPASS_BIN(bin, ps_cabac, ps_bitstrm);\n         u4_sym += bin << numones++;\n     }\n \n     numones -= 1;\n    numones = CLIP3(numones, 0, 16);\n \n     if(numones)\n     {\n        UWORD32 u4_suffix;\n\n        IHEVCD_CABAC_DECODE_BYPASS_BINS(u4_suffix, ps_cabac, ps_bitstrm, numones);\n        u4_sym += u4_suffix;\n }\n return (u4_sym);\n}\n", "target": 1, "flaw_line_index": "16,23"}
{"idx": 187494, "func": " static void btsnoop_write(const void *data, size_t length) {\n   if (logfile_fd != INVALID_FD)\n    write(logfile_fd, data, length);\n \n   btsnoop_net_write(data, length);\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8808, "func": "static void read_transfer_data(struct pipe_resource *res,\n                               struct iovec *iov,\n                               unsigned int num_iovs,\n                               char *data,\n                               uint32_t src_stride,\n                               struct pipe_box *box,\n                               uint64_t offset, bool invert)\n{\n   int blsize = util_format_get_blocksize(res->format);\n   uint32_t size = vrend_get_iovec_size(iov, num_iovs);\n   uint32_t send_size = util_format_get_nblocks(res->format, box->width,\n                                              box->height) * blsize * box->depth;\n   uint32_t bwx = util_format_get_nblocksx(res->format, box->width) * blsize;\n   uint32_t bh = util_format_get_nblocksy(res->format, box->height);\n   int h;\n   uint32_t myoffset = offset;\n\n   if ((send_size == size || bh == 1) && !invert)\n      vrend_read_from_iovec(iov, num_iovs, offset, data, send_size);\n   else {\n      if (invert) {\n         for (h = bh - 1; h >= 0; h--) {\n            void *ptr = data + (h * bwx);\n            vrend_read_from_iovec(iov, num_iovs, myoffset, ptr, bwx);\n            myoffset += src_stride;\n         }\n      } else {\n         for (h = 0; h < bh; h++) {\n            void *ptr = data + (h * bwx);\n            vrend_read_from_iovec(iov, num_iovs, myoffset, ptr, bwx);\n            myoffset += src_stride;\n         }\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8319, "func": "XFixesUnionRegion (Display *dpy, XserverRegion dst,\n\t\t   XserverRegion src1, XserverRegion src2)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesUnionRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesUnionRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesUnionRegion;\n    req->source1 = src1;\n    req->source2 = src2;\n    req->destination = dst;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8974, "func": "static void vmxnet3_ack_events(VMXNET3State *s, uint32_t val)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    uint32_t events;\n\n    VMW_CBPRN(\"Clearing events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, ecr) & ~val;\n    VMXNET3_WRITE_DRV_SHARED32(d, s->drv_shmem, ecr, events);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8392, "func": "int virtio_queue_empty(VirtQueue *vq)\n{\n    if (vq->shadow_avail_idx != vq->last_avail_idx) {\n        return 0;\n    }\n\n    return vring_avail_idx(vq) == vq->last_avail_idx;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188049, "func": "WORD32 ih264d_decode_gaps_in_frame_num(dec_struct_t *ps_dec,\n                                       UWORD16 u2_frame_num)\n{\n    UWORD32 u4_next_frm_num, u4_start_frm_num;\n    UWORD32 u4_max_frm_num;\n pocstruct_t s_tmp_poc;\n    WORD32 i4_poc;\n dec_slice_params_t *ps_cur_slice;\n\n dec_pic_params_t *ps_pic_params;\n    WORD8 i1_gap_idx;\n    WORD32 *i4_gaps_start_frm_num;\n dpb_manager_t *ps_dpb_mgr;\n    WORD32 i4_frame_gaps;\n    WORD8 *pi1_gaps_per_seq;\n    WORD32 ret;\n\n    ps_cur_slice = ps_dec->ps_cur_slice;\n if(ps_cur_slice->u1_field_pic_flag)\n {\n if(ps_dec->u2_prev_ref_frame_num == u2_frame_num)\n return 0;\n }\n\n    u4_next_frm_num = ps_dec->u2_prev_ref_frame_num + 1;\n    u4_max_frm_num = ps_dec->ps_cur_sps->u2_u4_max_pic_num_minus1 + 1;\n\n if(u4_next_frm_num >= u4_max_frm_num)\n {\n        u4_next_frm_num -= u4_max_frm_num;\n }\n\n if(u4_next_frm_num == u2_frame_num)\n {\n return (0);\n }\n\n if((ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n && (u4_next_frm_num >= u2_frame_num))\n {\n return (0);\n }\n    u4_start_frm_num = u4_next_frm_num;\n\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n\n \n     ps_cur_slice = ps_dec->ps_cur_slice;\n     ps_pic_params = ps_dec->ps_cur_pps;\n    ps_cur_slice->u1_field_pic_flag = 0;\n \n     i4_frame_gaps = 0;\n     ps_dpb_mgr = ps_dec->ps_dpb_mgr;\n\n    i4_gaps_start_frm_num = ps_dpb_mgr->ai4_gaps_start_frm_num;\n for(i1_gap_idx = 0; i1_gap_idx < MAX_FRAMES; i1_gap_idx++)\n {\n if(INVALID_FRAME_NUM == i4_gaps_start_frm_num[i1_gap_idx])\n break;\n }\n if(MAX_FRAMES == i1_gap_idx)\n {\n        UWORD32 i4_error_code;\n        i4_error_code = ERROR_DBP_MANAGER_T;\n return i4_error_code;\n }\n\n    i4_poc = 0;\n    i4_gaps_start_frm_num[i1_gap_idx] = u4_start_frm_num;\n    ps_dpb_mgr->ai4_gaps_end_frm_num[i1_gap_idx] = u2_frame_num - 1;\n    pi1_gaps_per_seq = ps_dpb_mgr->ai1_gaps_per_seq;\n    pi1_gaps_per_seq[i1_gap_idx] = 0;\n while(u4_next_frm_num != u2_frame_num)\n {\n        ih264d_delete_nonref_nondisplay_pics(ps_dpb_mgr);\n if(ps_pic_params->ps_sps->u1_pic_order_cnt_type)\n {\n            ret = ih264d_decode_pic_order_cnt(0, u4_next_frm_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice,\n                                              ps_pic_params, 1, 0, 0,\n &i4_poc);\n if(ret != OK)\n return ret;\n\n if(i4_poc >= ps_dec->i4_max_poc)\n                ps_dec->i4_max_poc = i4_poc;\n if(i4_poc == 0)\n {\n                ps_dec->i4_prev_max_display_seq =\n                                ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering\n + 1;\n                ps_dec->i4_max_poc = 0;\n }\n\n            ps_cur_slice->u1_mmco_equalto5 = 0;\n            ps_cur_slice->u2_frame_num = u4_next_frm_num;\n }\n\n if(ps_dpb_mgr->i1_poc_buf_id_entries\n >= ps_dec->u1_max_dec_frame_buffering)\n {\n            ret = ih264d_assign_display_seq(ps_dec);\n if(ret != OK)\n return ret;\n }\n\n        ret = ih264d_insert_pic_in_display_list(\n                        ps_dec->ps_dpb_mgr, (WORD8) DO_NOT_DISP,\n (WORD32)(ps_dec->i4_prev_max_display_seq + i4_poc),\n                        u4_next_frm_num);\n if(ret != OK)\n return ret;\n\n        pi1_gaps_per_seq[i1_gap_idx]++;\n        ret = ih264d_do_mmco_for_gaps(ps_dpb_mgr,\n                                ps_dec->ps_cur_sps->u1_num_ref_frames);\n if(ret != OK)\n return ret;\n\n        ih264d_delete_nonref_nondisplay_pics(ps_dpb_mgr);\n\n        u4_next_frm_num++;\n if(u4_next_frm_num >= u4_max_frm_num)\n {\n            u4_next_frm_num -= u4_max_frm_num;\n }\n\n        i4_frame_gaps++;\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "57"}
{"idx": 188007, "func": " static ogg_uint32_t decpack(long entry,long used_entry,long quantvals,\n\t\t\t    codebook *b,oggpack_buffer *opb,int maptype){\n   ogg_uint32_t ret=0;\n   int j;\n \n switch(b->dec_type){\n\n case 0:\n return (ogg_uint32_t)entry;\n\n case 1:\n\n     if(maptype==1){\n       for(j=0;j<b->dim;j++){\n\togg_uint32_t off=entry%quantvals;\n\tentry/=quantvals;\n\tret|=((ogg_uint16_t *)(b->q_val))[off]<<(b->q_bits*j);\n       }\n     }else{\n       for(j=0;j<b->dim;j++)\n\tret|=oggpack_read(opb,b->q_bits)<<(b->q_bits*j);\n     }\n     return ret;\n \n case 2:\n for(j=0;j<b->dim;j++){\n ogg_uint32_t off=entry%quantvals;\n      entry/=quantvals;\n      ret|=off<<(b->q_pack*j);\n }\n return ret;\n\n case 3:\n return (ogg_uint32_t)used_entry;\n\n }\n return 0; \n}\n", "target": 1, "flaw_line_index": "2,15,16,17,21"}
{"idx": 188075, "func": "IHEVCD_ERROR_T ihevcd_parse_sps(codec_t *ps_codec)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 value;\n\n    WORD32 i;\n    WORD32 vps_id;\n    WORD32 sps_max_sub_layers;\n    WORD32 sps_id;\n    WORD32 sps_temporal_id_nesting_flag;\n sps_t *ps_sps;\n profile_tier_lvl_info_t s_ptl;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n\n\n    BITS_PARSE(\"video_parameter_set_id\", value, ps_bitstrm, 4);\n    vps_id = value;\n    vps_id = CLIP3(vps_id, 0, MAX_VPS_CNT - 1);\n\n    BITS_PARSE(\"sps_max_sub_layers_minus1\", value, ps_bitstrm, 3);\n    sps_max_sub_layers = value + 1;\n    sps_max_sub_layers = CLIP3(sps_max_sub_layers, 1, 7);\n\n    BITS_PARSE(\"sps_temporal_id_nesting_flag\", value, ps_bitstrm, 1);\n    sps_temporal_id_nesting_flag = value;\n\n    ret = ihevcd_profile_tier_level(ps_bitstrm, &(s_ptl), 1,\n (sps_max_sub_layers - 1));\n\n    UEV_PARSE(\"seq_parameter_set_id\", value, ps_bitstrm);\n    sps_id = value;\n\n if((sps_id >= MAX_SPS_CNT) || (sps_id < 0))\n {\n if(ps_codec->i4_sps_done)\n return IHEVCD_UNSUPPORTED_SPS_ID;\n else\n            sps_id = 0;\n }\n\n\n    ps_sps = (ps_codec->s_parse.ps_sps_base + MAX_SPS_CNT - 1);\n    ps_sps->i1_sps_id = sps_id;\n    ps_sps->i1_vps_id = vps_id;\n    ps_sps->i1_sps_max_sub_layers = sps_max_sub_layers;\n    ps_sps->i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag;\n    ps_codec->i4_sps_id = sps_id;\n    memcpy(&ps_sps->s_ptl, &s_ptl, sizeof(profile_tier_lvl_info_t));\n\n    UEV_PARSE(\"chroma_format_idc\", value, ps_bitstrm);\n    ps_sps->i1_chroma_format_idc = value;\n\n if(ps_sps->i1_chroma_format_idc != CHROMA_FMT_IDC_YUV420)\n {\n        ps_codec->s_parse.i4_error_code = IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\n return (IHEVCD_ERROR_T)IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC;\n }\n\n if(CHROMA_FMT_IDC_YUV444_PLANES == ps_sps->i1_chroma_format_idc)\n {\n        BITS_PARSE(\"separate_colour_plane_flag\", value, ps_bitstrm, 1);\n        ps_sps->i1_separate_colour_plane_flag = value;\n }\n else\n {\n        ps_sps->i1_separate_colour_plane_flag = 0;\n }\n\n    UEV_PARSE(\"pic_width_in_luma_samples\", value, ps_bitstrm);\n    ps_sps->i2_pic_width_in_luma_samples = value;\n\n    UEV_PARSE(\"pic_height_in_luma_samples\", value, ps_bitstrm);\n    ps_sps->i2_pic_height_in_luma_samples = value;\n\n if((0 >= ps_sps->i2_pic_width_in_luma_samples) || (0 >= ps_sps->i2_pic_height_in_luma_samples))\n return IHEVCD_INVALID_PARAMETER;\n\n    ps_sps->i2_pic_width_in_luma_samples = ALIGN8(ps_sps->i2_pic_width_in_luma_samples);\n    ps_sps->i2_pic_height_in_luma_samples = ALIGN8(ps_sps->i2_pic_height_in_luma_samples);\n\n if((ps_sps->i2_pic_width_in_luma_samples > ps_codec->i4_max_wd) ||\n (ps_sps->i2_pic_width_in_luma_samples * ps_sps->i2_pic_height_in_luma_samples >\n                       ps_codec->i4_max_wd * ps_codec->i4_max_ht) ||\n (ps_sps->i2_pic_height_in_luma_samples > MAX(ps_codec->i4_max_wd, ps_codec->i4_max_ht)))\n {\n        ps_codec->i4_new_max_wd = ps_sps->i2_pic_width_in_luma_samples;\n        ps_codec->i4_new_max_ht = ps_sps->i2_pic_height_in_luma_samples;\n return (IHEVCD_ERROR_T)IHEVCD_UNSUPPORTED_DIMENSIONS;\n }\n\n    BITS_PARSE(\"pic_cropping_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_pic_cropping_flag = value;\n\n if(ps_sps->i1_pic_cropping_flag)\n {\n\n        UEV_PARSE(\"pic_crop_left_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_left_offset = value;\n\n        UEV_PARSE(\"pic_crop_right_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_right_offset = value;\n\n        UEV_PARSE(\"pic_crop_top_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_top_offset = value;\n\n        UEV_PARSE(\"pic_crop_bottom_offset\", value, ps_bitstrm);\n        ps_sps->i2_pic_crop_bottom_offset = value;\n }\n else\n {\n        ps_sps->i2_pic_crop_left_offset = 0;\n        ps_sps->i2_pic_crop_right_offset = 0;\n        ps_sps->i2_pic_crop_top_offset = 0;\n        ps_sps->i2_pic_crop_bottom_offset = 0;\n }\n\n\n    UEV_PARSE(\"bit_depth_luma_minus8\", value, ps_bitstrm);\n if(0 != value)\n return IHEVCD_UNSUPPORTED_BIT_DEPTH;\n\n    UEV_PARSE(\"bit_depth_chroma_minus8\", value, ps_bitstrm);\n if(0 != value)\n return IHEVCD_UNSUPPORTED_BIT_DEPTH;\n\n    UEV_PARSE(\"log2_max_pic_order_cnt_lsb_minus4\", value, ps_bitstrm);\n    ps_sps->i1_log2_max_pic_order_cnt_lsb = value + 4;\n\n    BITS_PARSE(\"sps_sub_layer_ordering_info_present_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_sps_sub_layer_ordering_info_present_flag = value;\n\n\n    i = (ps_sps->i1_sps_sub_layer_ordering_info_present_flag ? 0 : (ps_sps->i1_sps_max_sub_layers - 1));\n for(; i < ps_sps->i1_sps_max_sub_layers; i++)\n {\n\n         UEV_PARSE(\"max_dec_pic_buffering\", value, ps_bitstrm);\n         ps_sps->ai1_sps_max_dec_pic_buffering[i] = value + 1;\n \n         UEV_PARSE(\"num_reorder_pics\", value, ps_bitstrm);\n         ps_sps->ai1_sps_max_num_reorder_pics[i] = value;\n \n         UEV_PARSE(\"max_latency_increase\", value, ps_bitstrm);\n         ps_sps->ai1_sps_max_latency_increase[i] = value;\n     }\n    UEV_PARSE(\"log2_min_coding_block_size_minus3\", value, ps_bitstrm);\n    ps_sps->i1_log2_min_coding_block_size = value + 3;\n\n    UEV_PARSE(\"log2_diff_max_min_coding_block_size\", value, ps_bitstrm);\n    ps_sps->i1_log2_diff_max_min_coding_block_size = value;\n\n    UEV_PARSE(\"log2_min_transform_block_size_minus2\", value, ps_bitstrm);\n    ps_sps->i1_log2_min_transform_block_size = value + 2;\n\n    UEV_PARSE(\"log2_diff_max_min_transform_block_size\", value, ps_bitstrm);\n    ps_sps->i1_log2_diff_max_min_transform_block_size = value;\n\n    ps_sps->i1_log2_max_transform_block_size = ps_sps->i1_log2_min_transform_block_size +\n                    ps_sps->i1_log2_diff_max_min_transform_block_size;\n\n    ps_sps->i1_log2_ctb_size = ps_sps->i1_log2_min_coding_block_size +\n                    ps_sps->i1_log2_diff_max_min_coding_block_size;\n\n if((ps_sps->i1_log2_min_coding_block_size < 3) ||\n (ps_sps->i1_log2_min_transform_block_size < 2) ||\n (ps_sps->i1_log2_diff_max_min_transform_block_size < 0) ||\n (ps_sps->i1_log2_max_transform_block_size > ps_sps->i1_log2_ctb_size) ||\n (ps_sps->i1_log2_ctb_size < 4) ||\n (ps_sps->i1_log2_ctb_size > 6))\n {\n return IHEVCD_INVALID_PARAMETER;\n }\n\n    ps_sps->i1_log2_min_pcm_coding_block_size = 0;\n    ps_sps->i1_log2_diff_max_min_pcm_coding_block_size = 0;\n\n    UEV_PARSE(\"max_transform_hierarchy_depth_inter\", value, ps_bitstrm);\n    ps_sps->i1_max_transform_hierarchy_depth_inter = value;\n\n    UEV_PARSE(\"max_transform_hierarchy_depth_intra\", value, ps_bitstrm);\n    ps_sps->i1_max_transform_hierarchy_depth_intra = value;\n\n    BITS_PARSE(\"scaling_list_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_scaling_list_enable_flag = value;\n\n if(ps_sps->i1_scaling_list_enable_flag)\n {\n        COPY_DEFAULT_SCALING_LIST(ps_sps->pi2_scaling_mat);\n        BITS_PARSE(\"sps_scaling_list_data_present_flag\", value, ps_bitstrm, 1);\n        ps_sps->i1_sps_scaling_list_data_present_flag = value;\n\n if(ps_sps->i1_sps_scaling_list_data_present_flag)\n            ihevcd_scaling_list_data(ps_codec, ps_sps->pi2_scaling_mat);\n }\n else\n {\n        COPY_FLAT_SCALING_LIST(ps_sps->pi2_scaling_mat);\n }\n    BITS_PARSE(\"asymmetric_motion_partitions_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_amp_enabled_flag = value;\n\n    BITS_PARSE(\"sample_adaptive_offset_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_sample_adaptive_offset_enabled_flag = value;\n\n    BITS_PARSE(\"pcm_enabled_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_pcm_enabled_flag = value;\n\n if(ps_sps->i1_pcm_enabled_flag)\n {\n        BITS_PARSE(\"pcm_sample_bit_depth_luma\", value, ps_bitstrm, 4);\n        ps_sps->i1_pcm_sample_bit_depth_luma = value + 1;\n\n        BITS_PARSE(\"pcm_sample_bit_depth_chroma\", value, ps_bitstrm, 4);\n        ps_sps->i1_pcm_sample_bit_depth_chroma = value + 1;\n\n        UEV_PARSE(\"log2_min_pcm_coding_block_size_minus3\", value, ps_bitstrm);\n        ps_sps->i1_log2_min_pcm_coding_block_size = value + 3;\n\n        UEV_PARSE(\"log2_diff_max_min_pcm_coding_block_size\", value, ps_bitstrm);\n        ps_sps->i1_log2_diff_max_min_pcm_coding_block_size = value;\n        BITS_PARSE(\"pcm_loop_filter_disable_flag\", value, ps_bitstrm, 1);\n        ps_sps->i1_pcm_loop_filter_disable_flag = value;\n\n }\n    UEV_PARSE(\"num_short_term_ref_pic_sets\", value, ps_bitstrm);\n    ps_sps->i1_num_short_term_ref_pic_sets = value;\n\n    ps_sps->i1_num_short_term_ref_pic_sets = CLIP3(ps_sps->i1_num_short_term_ref_pic_sets, 0, MAX_STREF_PICS_SPS);\n\n for(i = 0; i < ps_sps->i1_num_short_term_ref_pic_sets; i++)\n        ihevcd_short_term_ref_pic_set(ps_bitstrm, &ps_sps->as_stref_picset[0], ps_sps->i1_num_short_term_ref_pic_sets, i, &ps_sps->as_stref_picset[i]);\n\n    BITS_PARSE(\"long_term_ref_pics_present_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_long_term_ref_pics_present_flag = value;\n\n if(ps_sps->i1_long_term_ref_pics_present_flag)\n {\n        UEV_PARSE(\"num_long_term_ref_pics_sps\", value, ps_bitstrm);\n        ps_sps->i1_num_long_term_ref_pics_sps = value;\n\n for(i = 0; i < ps_sps->i1_num_long_term_ref_pics_sps; i++)\n {\n            BITS_PARSE(\"lt_ref_pic_poc_lsb_sps[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n            ps_sps->ai1_lt_ref_pic_poc_lsb_sps[i] = value;\n\n            BITS_PARSE(\"used_by_curr_pic_lt_sps_flag[ i ]\", value, ps_bitstrm, 1);\n            ps_sps->ai1_used_by_curr_pic_lt_sps_flag[i] = value;\n }\n }\n\n    BITS_PARSE(\"sps_temporal_mvp_enable_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_sps_temporal_mvp_enable_flag = value;\n\n    BITS_PARSE(\"sps_strong_intra_smoothing_enable_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_strong_intra_smoothing_enable_flag = value;\n\n    BITS_PARSE(\"vui_parameters_present_flag\", value, ps_bitstrm, 1);\n    ps_sps->i1_vui_parameters_present_flag = value;\n\n if(ps_sps->i1_vui_parameters_present_flag)\n        ihevcd_parse_vui_parameters(ps_bitstrm,\n &ps_sps->s_vui_parameters,\n                                    ps_sps->i1_sps_max_sub_layers - 1);\n\n    BITS_PARSE(\"sps_extension_flag\", value, ps_bitstrm, 1);\n\n\n {\n        WORD32 numerator;\n        WORD32 ceil_offset;\n\n        ceil_offset = (1 << ps_sps->i1_log2_ctb_size) - 1;\n        numerator = ps_sps->i2_pic_width_in_luma_samples;\n\n        ps_sps->i2_pic_wd_in_ctb = ((numerator + ceil_offset) /\n (1 << ps_sps->i1_log2_ctb_size));\n\n        numerator = ps_sps->i2_pic_height_in_luma_samples;\n        ps_sps->i2_pic_ht_in_ctb = ((numerator + ceil_offset) /\n (1 << ps_sps->i1_log2_ctb_size));\n\n        ps_sps->i4_pic_size_in_ctb = ps_sps->i2_pic_ht_in_ctb *\n                        ps_sps->i2_pic_wd_in_ctb;\n\n if(0 == ps_codec->i4_sps_done)\n            ps_codec->s_parse.i4_next_ctb_indx = ps_sps->i4_pic_size_in_ctb;\n\n        numerator = ps_sps->i2_pic_width_in_luma_samples;\n        ps_sps->i2_pic_wd_in_min_cb = numerator  /\n (1 << ps_sps->i1_log2_min_coding_block_size);\n\n        numerator = ps_sps->i2_pic_height_in_luma_samples;\n        ps_sps->i2_pic_ht_in_min_cb = numerator  /\n (1 << ps_sps->i1_log2_min_coding_block_size);\n }\n if((0 != ps_codec->i4_first_pic_done) &&\n ((ps_codec->i4_wd != ps_sps->i2_pic_width_in_luma_samples) ||\n (ps_codec->i4_ht != ps_sps->i2_pic_height_in_luma_samples)))\n {\n        ps_codec->i4_reset_flag = 1;\n        ps_codec->i4_error_code = IVD_RES_CHANGED;\n return (IHEVCD_ERROR_T)IHEVCD_FAIL;\n }\n\n {\n        WORD32 disp_wd, disp_ht;\n        WORD32 crop_unit_x, crop_unit_y;\n        crop_unit_x = 1;\n        crop_unit_y = 1;\n\n if(CHROMA_FMT_IDC_YUV420 == ps_sps->i1_chroma_format_idc)\n {\n            crop_unit_x = 2;\n            crop_unit_y = 2;\n }\n\n        disp_wd = ps_sps->i2_pic_width_in_luma_samples;\n        disp_wd -= ps_sps->i2_pic_crop_left_offset * crop_unit_x;\n        disp_wd -= ps_sps->i2_pic_crop_right_offset * crop_unit_x;\n\n\n        disp_ht = ps_sps->i2_pic_height_in_luma_samples;\n        disp_ht -= ps_sps->i2_pic_crop_top_offset * crop_unit_y;\n        disp_ht -= ps_sps->i2_pic_crop_bottom_offset * crop_unit_y;\n\n if((0 >= disp_wd) || (0 >= disp_ht))\n return IHEVCD_INVALID_PARAMETER;\n\n        ps_codec->i4_disp_wd = disp_wd;\n        ps_codec->i4_disp_ht = disp_ht;\n\n\n        ps_codec->i4_wd = ps_sps->i2_pic_width_in_luma_samples;\n        ps_codec->i4_ht = ps_sps->i2_pic_height_in_luma_samples;\n\n {\n            WORD32 ref_strd;\n            ref_strd = ALIGN32(ps_sps->i2_pic_width_in_luma_samples + PAD_WD);\n if(ps_codec->i4_strd < ref_strd)\n {\n                ps_codec->i4_strd = ref_strd;\n }\n }\n\n if(0 == ps_codec->i4_share_disp_buf)\n {\n if(ps_codec->i4_disp_strd < ps_codec->i4_disp_wd)\n {\n                ps_codec->i4_disp_strd = ps_codec->i4_disp_wd;\n }\n }\n else\n {\n if(ps_codec->i4_disp_strd < ps_codec->i4_strd)\n {\n                ps_codec->i4_disp_strd = ps_codec->i4_strd;\n }\n }\n }\n\n    ps_codec->i4_sps_done = 1;\n return ret;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188055, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n if ((u2_width != ps_dec->u2_horizontal_size)\n || (u2_height != ps_dec->u2_vertical_size))\n {\n if (0 == ps_dec->u2_header_done)\n {\n            ps_dec->u2_horizontal_size = u2_width;\n            ps_dec->u2_vertical_size = u2_height;\n if (0 == ps_dec->u4_frm_buf_stride)\n {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);\n }\n }\n else\n {\n if((u2_width > ps_dec->u2_create_max_width)\n || (u2_height > ps_dec->u2_create_max_height))\n {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n return e_error;\n }\n else\n {\n return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n }\n }\n }\n\n if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n\n                     || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n     {\n         IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n        return SET_IVD_FATAL_ERROR(e_error);\n     }\n \n \n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n    ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)\n {\n return IMPEG2D_FRM_HDR_DECODE_ERR;\n }\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n\n }\n else\n {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n }\n\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n }\n else\n {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n }\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "flaw_line_index": "55"}
{"idx": 9133, "func": "void vmxnet_tx_pkt_init(struct VmxnetTxPkt **pkt, uint32_t max_frags,\n    bool has_virt_hdr)\n{\n    struct VmxnetTxPkt *p = g_malloc0(sizeof *p);\n\n    p->vec = g_malloc((sizeof *p->vec) *\n        (max_frags + VMXNET_TX_PKT_PL_START_FRAG));\n\n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n\n    p->max_payload_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[VMXNET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[VMXNET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_base = NULL;\n    p->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len = 0;\n\n    *pkt = p;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8380, "func": "static uint32_t mptsas_reply_post_read(MPTSASState *s)\n{\n    uint32_t ret;\n\n    if (!MPTSAS_FIFO_EMPTY(s, reply_post)) {\n        ret = MPTSAS_FIFO_GET(s, reply_post);\n    } else {\n        ret = -1;\n        s->intr_status &= ~MPI_HIS_REPLY_MESSAGE_INTERRUPT;\n        mptsas_update_interrupt(s);\n    }\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188027, "func": "void SkippedMBMotionComp(\n VideoDecData *video\n)\n{\n Vop *prev = video->prevVop;\n Vop *comp;\n int ypos, xpos;\n    PIXEL *c_comp, *c_prev;\n    PIXEL *cu_comp, *cu_prev;\n    PIXEL *cv_comp, *cv_prev;\n int width, width_uv;\n int32 offset;\n#ifdef PV_POSTPROC_ON \n int imv;\n int32 size = (int32) video->nTotalMB << 8;\n uint8 *pp_dec_y, *pp_dec_u;\n uint8 *pp_prev1;\n int mvwidth = video->nMBPerRow << 1;\n#endif\n\n    width = video->width;\n    width_uv  = width >> 1;\n    ypos = video->mbnum_row << 4 ;\n    xpos = video->mbnum_col << 4 ;\n    offset = (int32)ypos * width + xpos;\n\n\n \n    c_prev  = prev->yChan + offset;\n     cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);\n    cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);\n\n    comp = video->currVop;\n\n    c_comp  = comp->yChan + offset;\n    cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);\n    cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);\n\n\n PutSKIPPED_MB(c_comp,  c_prev, width);\n PutSKIPPED_B(cu_comp, cu_prev, width_uv);\n PutSKIPPED_B(cv_comp, cv_prev, width_uv);\n\n#ifdef PV_POSTPROC_ON \n if (video->postFilterType != PV_NO_POST_PROC)\n {\n        imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);\n        pp_prev1 = video->pstprcTypPrv + imv;\n        pp_dec_y = video->pstprcTypCur + imv;\n *pp_dec_y = *pp_prev1;\n *(pp_dec_y + 1) = *(pp_prev1 + 1);\n *(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);\n *(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);\n\n        pp_prev1 = video->pstprcTypPrv + (size >> 6) +\n ((imv + (xpos >> 3)) >> 2);\n        pp_dec_u = video->pstprcTypCur + (size >> 6) +\n ((imv + (xpos >> 3)) >> 2);\n *pp_dec_u = *pp_prev1;\n        pp_dec_u[size>>8] = pp_prev1[size>>8];\n }\n#endif\n\n return;\n}\n", "target": 1, "flaw_line_index": "29"}
{"idx": 8598, "func": "void agent_cancel_query(agent_pending_query *q)\n{\n    assert(0 && \"Windows agent queries are never asynchronous!\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187553, "func": "status_t OMXNodeInstance::updateGraphicBufferInMeta(\n\n         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n         OMX::buffer_id buffer) {\n     Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header);\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187336, "func": " xsltTestCompMatch(xsltTransformContextPtr ctxt, xsltCompMatchPtr comp,\n\t          xmlNodePtr node, const xmlChar *mode,\n \t\t  const xmlChar *modeURI) {\n     int i;\n     xsltStepOpPtr step, sel = NULL;\n     xsltStepStates states = {0, 0, NULL}; /* \n \n    if ((comp == NULL) || (node == NULL) || (ctxt == NULL)) {\n\txsltTransformError(ctxt, NULL, node,\n\t\t\"xsltTestCompMatch: null arg\\n\");\n        return(-1);\n    }\n    if (mode != NULL) {\n\tif (comp->mode == NULL)\n\t    return(0);\n\tif (comp->mode != mode)\n\t    return(0);\n    } else {\n\tif (comp->mode != NULL)\n\t    return(0);\n    }\n    if (modeURI != NULL) {\n\tif (comp->modeURI == NULL)\n\t    return(0);\n\tif (comp->modeURI != modeURI)\n\t    return(0);\n    } else {\n\tif (comp->modeURI != NULL)\n\t    return(0);\n    }\n\n    i = 0;\nrestart:\n    for (;i < comp->nbStep;i++) {\n\tstep = &comp->steps[i];\n\tif (step->op != XSLT_OP_PREDICATE)\n\t    sel = step;\n\tswitch (step->op) {\n            case XSLT_OP_END:\n\t\tgoto found;\n            case XSLT_OP_ROOT:\n\t\tif ((node->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t\t    (node->type == XML_HTML_DOCUMENT_NODE))\n\t\t    continue;\n\t\tif ((node->type == XML_ELEMENT_NODE) && (node->name[0] == ' '))\n\t\t    continue;\n\t\tgoto rollback;\n            case XSLT_OP_ELEM:\n\t\tif (node->type != XML_ELEMENT_NODE)\n\t\t    goto rollback;\n\t\tif (step->value == NULL)\n\t\t    continue;\n\t\tif (step->value[0] != node->name[0])\n\t\t    goto rollback;\n\t\tif (!xmlStrEqual(step->value, node->name))\n\t\t    goto rollback;\n\n\t\tif (node->ns == NULL) {\n\t\t    if (step->value2 != NULL)\n\t\t\tgoto rollback;\n\t\t} else if (node->ns->href != NULL) {\n\t\t    if (step->value2 == NULL)\n\t\t\tgoto rollback;\n\t\t    if (!xmlStrEqual(step->value2, node->ns->href))\n\t\t\tgoto rollback;\n\t\t}\n\t\tcontinue;\n            case XSLT_OP_ATTR:\n\t\tif (node->type != XML_ATTRIBUTE_NODE)\n\t\t    goto rollback;\n\t\tif (step->value != NULL) {\n\t\t    if (step->value[0] != node->name[0])\n\t\t\tgoto rollback;\n\t\t    if (!xmlStrEqual(step->value, node->name))\n\t\t\tgoto rollback;\n\t\t}\n\t\tif (node->ns == NULL) {\n\t\t    if (step->value2 != NULL)\n\t\t\tgoto rollback;\n\t\t} else if (step->value2 != NULL) {\n\t\t    if (!xmlStrEqual(step->value2, node->ns->href))\n\t\t\tgoto rollback;\n\t\t}\n\t\tcontinue;\n            case XSLT_OP_PARENT:\n\t\tif ((node->type == XML_DOCUMENT_NODE) ||\n\t\t    (node->type == XML_HTML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t\t    (node->type == XML_NAMESPACE_DECL))\n\t\t    goto rollback;\n\t\tnode = node->parent;\n\t\tif (node == NULL)\n\t\t    goto rollback;\n\t\tif (step->value == NULL)\n\t\t    continue;\n\t\tif (step->value[0] != node->name[0])\n\t\t    goto rollback;\n\t\tif (!xmlStrEqual(step->value, node->name))\n\t\t    goto rollback;\n\t\tif (node->ns == NULL) {\n\t\t    if (step->value2 != NULL)\n\t\t\tgoto rollback;\n\t\t} else if (node->ns->href != NULL) {\n\t\t    if (step->value2 == NULL)\n\t\t\tgoto rollback;\n\t\t    if (!xmlStrEqual(step->value2, node->ns->href))\n\t\t\tgoto rollback;\n\t\t}\n\t\tcontinue;\n            case XSLT_OP_ANCESTOR:\n\t\tif (step->value == NULL) {\n\t\t    step = &comp->steps[i+1];\n\t\t    if (step->op == XSLT_OP_ROOT)\n\t\t\tgoto found;\n\t\t    if ((step->op != XSLT_OP_ELEM) &&\n\t\t\t(step->op != XSLT_OP_ALL) &&\n\t\t\t(step->op != XSLT_OP_NS) &&\n\t\t\t(step->op != XSLT_OP_ID) &&\n\t\t\t(step->op != XSLT_OP_KEY))\n\t\t\tgoto rollback;\n\t\t}\n\t\tif (node == NULL)\n\t\t    goto rollback;\n\t\tif ((node->type == XML_DOCUMENT_NODE) ||\n\t\t    (node->type == XML_HTML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t\t    (node->type == XML_NAMESPACE_DECL))\n\t\t    goto rollback;\n\t\tnode = node->parent;\n\t\tif ((step->op != XSLT_OP_ELEM) && step->op != XSLT_OP_ALL) {\n\t\t    xsltPatPushState(ctxt, &states, i, node);\n\t\t    continue;\n\t\t}\n\t\ti++;\n\t\tif (step->value == NULL) {\n\t\t    xsltPatPushState(ctxt, &states, i - 1, node);\n\t\t    continue;\n\t\t}\n\t\twhile (node != NULL) {\n\t\t    if ((node->type == XML_ELEMENT_NODE) &&\n\t\t\t(step->value[0] == node->name[0]) &&\n\t\t\t(xmlStrEqual(step->value, node->name))) {\n\t\t\tif (node->ns == NULL) {\n\t\t\t    if (step->value2 == NULL)\n\t\t\t\tbreak;\n\t\t\t} else if (node->ns->href != NULL) {\n\t\t\t    if ((step->value2 != NULL) &&\n\t\t\t        (xmlStrEqual(step->value2, node->ns->href)))\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    node = node->parent;\n\t\t}\n\t\tif (node == NULL)\n\t\t    goto rollback;\n\t\txsltPatPushState(ctxt, &states, i - 1, node);\n\t\tcontinue;\n            case XSLT_OP_ID: {\n\t\txmlAttrPtr id;\n\n\t\tif (node->type != XML_ELEMENT_NODE)\n\t\t    goto rollback;\n\n\t\tid = xmlGetID(node->doc, step->value);\n\t\tif ((id == NULL) || (id->parent != node))\n\t\t    goto rollback;\n\t\tbreak;\n\t    }\n            case XSLT_OP_KEY: {\n\t\txmlNodeSetPtr list;\n\t\tint indx;\n\n\t\tlist = xsltGetKey(ctxt, step->value,\n\t\t\t          step->value3, step->value2);\n\t\tif (list == NULL)\n\t\t    goto rollback;\n\t\tfor (indx = 0;indx < list->nodeNr;indx++)\n\t\t    if (list->nodeTab[indx] == node)\n\t\t\tbreak;\n\t\tif (indx >= list->nodeNr)\n\t\t    goto rollback;\n\t\tbreak;\n\t    }\n            case XSLT_OP_NS:\n\t\tif (node->type != XML_ELEMENT_NODE)\n\t\t    goto rollback;\n\t\tif (node->ns == NULL) {\n\t\t    if (step->value != NULL)\n\t\t\tgoto rollback;\n\t\t} else if (node->ns->href != NULL) {\n\t\t    if (step->value == NULL)\n\t\t\tgoto rollback;\n\t\t    if (!xmlStrEqual(step->value, node->ns->href))\n\t\t\tgoto rollback;\n\t\t}\n\t\tbreak;\n            case XSLT_OP_ALL:\n\t\tif (node->type != XML_ELEMENT_NODE)\n \t\t    goto rollback;\n \t\tbreak;\n \t    case XSLT_OP_PREDICATE: {\n\t\txmlNodePtr oldNode;\n\t\txmlDocPtr doc;\n\t\tint oldCS, oldCP;\n\t\tint pos = 0, len = 0;\n\t\tint isRVT;\n\t\tif (comp->direct) {\n\t\t    if (states.states != NULL) {\n \t\t\txmlFree(states.states);\n \t\t    }\n\t\t    return(xsltTestCompMatchDirect(ctxt, comp, node,\n \t\t\t\t\t\t   comp->nsList, comp->nsNr));\n \t\t}\n \n\t\tdoc = node->doc;\n\t\tif (XSLT_IS_RES_TREE_FRAG(doc))\n\t\t    isRVT = 1;\n\t\telse\n\t\t    isRVT = 0;\n\t\toldCS = ctxt->xpathCtxt->contextSize;\n\t\toldCP = ctxt->xpathCtxt->proximityPosition;\n\t\tif ((sel != NULL) &&\n\t\t    (sel->op == XSLT_OP_ELEM) &&\n\t\t    (sel->value != NULL) &&\n\t\t    (node->type == XML_ELEMENT_NODE) &&\n\t\t    (node->parent != NULL)) {\n\t\t    xmlNodePtr previous;\n\t\t    int nocache = 0;\n\t\t    previous = (xmlNodePtr)\n\t\t\tXSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr);\n\t\t    if ((previous != NULL) &&\n\t\t\t(previous->parent == node->parent)) {\n\t\t\tint indx = 0;\n\t\t\txmlNodePtr sibling = node;\n\t\t\twhile (sibling != NULL) {\n\t\t\t    if (sibling == previous)\n\t\t\t\tbreak;\n\t\t\t    if ((sibling->type == XML_ELEMENT_NODE) &&\n\t\t\t\t(previous->name != NULL) &&\n\t\t\t\t(sibling->name != NULL) &&\n\t\t\t\t(previous->name[0] == sibling->name[0]) &&\n\t\t\t\t(xmlStrEqual(previous->name, sibling->name)))\n\t\t\t    {\n\t\t\t\tif ((sel->value2 == NULL) ||\n\t\t\t\t    ((sibling->ns != NULL) &&\n\t\t\t\t     (xmlStrEqual(sel->value2,\n\t\t\t\t\t\t  sibling->ns->href))))\n\t\t\t\t    indx++;\n\t\t\t    }\n\t\t\t    sibling = sibling->prev;\n\t\t\t}\n\t\t\tif (sibling == NULL) {\n\t\t\t    indx = 0;\n\t\t\t    sibling = node;\n\t\t\t    while (sibling != NULL) {\n\t\t\t\tif (sibling == previous)\n\t\t\t\t    break;\n\t\t\t\tif ((sibling->type == XML_ELEMENT_NODE) &&\n\t\t\t\t    (previous->name != NULL) &&\n\t\t\t\t    (sibling->name != NULL) &&\n\t\t\t\t    (previous->name[0] == sibling->name[0]) &&\n\t\t\t\t    (xmlStrEqual(previous->name, sibling->name)))\n\t\t\t\t{\n\t\t\t\t    if ((sel->value2 == NULL) ||\n\t\t\t\t\t((sibling->ns != NULL) &&\n\t\t\t\t\t(xmlStrEqual(sel->value2,\n\t\t\t\t\tsibling->ns->href))))\n\t\t\t\t    {\n\t\t\t\t\tindx--;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tsibling = sibling->next;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (sibling != NULL) {\n\t\t            pos = XSLT_RUNTIME_EXTRA(ctxt,\n                                sel->indexExtra, ival) + indx;\n\t\t\t    if (node->doc != NULL) {\n\t\t\t\tlen = XSLT_RUNTIME_EXTRA(ctxt,\n\t\t\t\t        sel->lenExtra, ival);\n\t\t\t\tif (!isRVT) {\n\t\t\t\t    XSLT_RUNTIME_EXTRA(ctxt,\n\t\t\t\t\tsel->previousExtra, ptr) = node;\n\t\t\t\t    XSLT_RUNTIME_EXTRA(ctxt,\n\t\t\t\t        sel->indexExtra, ival) = pos;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else\n\t\t\t    pos = 0;\n\t\t    } else {\n\t\t\txmlNodePtr parent = node->parent;\n\t\t\txmlNodePtr siblings = NULL;\n                        if (parent) siblings = parent->children;\n\t\t\twhile (siblings != NULL) {\n\t\t\t    if (siblings->type == XML_ELEMENT_NODE) {\n\t\t\t\tif (siblings == node) {\n\t\t\t\t    len++;\n\t\t\t\t    pos = len;\n\t\t\t\t} else if ((node->name != NULL) &&\n\t\t\t\t\t   (siblings->name != NULL) &&\n\t\t\t\t    (node->name[0] == siblings->name[0]) &&\n\t\t\t\t    (xmlStrEqual(node->name, siblings->name))) {\n\t\t\t\t    if ((sel->value2 == NULL) ||\n\t\t\t\t\t((siblings->ns != NULL) &&\n\t\t\t\t\t (xmlStrEqual(sel->value2,\n\t\t\t\t\t\t      siblings->ns->href))))\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    siblings = siblings->next;\n\t\t\t}\n\t\t\tif ((parent == NULL) || (node->doc == NULL))\n\t\t\t    nocache = 1;\n\t\t\telse {\n\t\t\t    while (parent->parent != NULL)\n\t\t\t\tparent = parent->parent;\n\t\t\t    if (((parent->type != XML_DOCUMENT_NODE) &&\n\t\t\t\t (parent->type != XML_HTML_DOCUMENT_NODE)) ||\n\t\t\t\t (parent != (xmlNodePtr) node->doc))\n\t\t\t\tnocache = 1;\n\t\t\t}\n\t\t    }\n\t\t    if (pos != 0) {\n\t\t\tctxt->xpathCtxt->contextSize = len;\n\t\t\tctxt->xpathCtxt->proximityPosition = pos;\n\t\t\tif ((!isRVT) && (node->doc != NULL) &&\n\t\t\t    (nocache == 0)) {\n\t\t\t    XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr) =\n\t\t\t\tnode;\n\t\t\t    XSLT_RUNTIME_EXTRA(ctxt, sel->indexExtra, ival) =\n\t\t\t\tpos;\n\t\t\t    XSLT_RUNTIME_EXTRA(ctxt, sel->lenExtra, ival) =\n\t\t\t\tlen;\n\t\t\t}\n\t\t    }\n\t\t} else if ((sel != NULL) && (sel->op == XSLT_OP_ALL) &&\n\t\t\t   (node->type == XML_ELEMENT_NODE)) {\n\t\t    xmlNodePtr previous;\n\t\t    int nocache = 0;\n\t\t    previous = (xmlNodePtr)\n\t\t\tXSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr);\n\t\t    if ((previous != NULL) &&\n\t\t\t(previous->parent == node->parent)) {\n\t\t\tint indx = 0;\n\t\t\txmlNodePtr sibling = node;\n\t\t\twhile (sibling != NULL) {\n\t\t\t    if (sibling == previous)\n\t\t\t\tbreak;\n\t\t\t    if (sibling->type == XML_ELEMENT_NODE)\n\t\t\t\tindx++;\n\t\t\t    sibling = sibling->prev;\n\t\t\t}\n\t\t\tif (sibling == NULL) {\n\t\t\t    indx = 0;\n\t\t\t    sibling = node;\n\t\t\t    while (sibling != NULL) {\n\t\t\t\tif (sibling == previous)\n\t\t\t\t    break;\n\t\t\t\tif (sibling->type == XML_ELEMENT_NODE)\n\t\t\t\t    indx--;\n\t\t\t\tsibling = sibling->next;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (sibling != NULL) {\n\t\t\t    pos = XSLT_RUNTIME_EXTRA(ctxt,\n                                sel->indexExtra, ival) + indx;\n\t\t\t    if ((node->doc != NULL) && !isRVT) {\n\t\t\t\tlen = XSLT_RUNTIME_EXTRA(ctxt,\n\t\t\t\t        sel->lenExtra, ival);\n\t\t\t\tXSLT_RUNTIME_EXTRA(ctxt,\n\t\t\t\t\tsel->previousExtra, ptr) = node;\n\t\t\t\tXSLT_RUNTIME_EXTRA(ctxt,\n\t\t\t\t\tsel->indexExtra, ival) = pos;\n\t\t\t    }\n\t\t\t} else\n\t\t\t    pos = 0;\n\t\t    } else {\n\t\t\txmlNodePtr parent = node->parent;\n\t\t\txmlNodePtr siblings = NULL;\n                        if (parent) siblings = parent->children;\n\t\t\twhile (siblings != NULL) {\n\t\t\t    if (siblings->type == XML_ELEMENT_NODE) {\n\t\t\t\tlen++;\n\t\t\t\tif (siblings == node) {\n\t\t\t\t    pos = len;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    siblings = siblings->next;\n\t\t\t}\n\t\t\tif ((parent == NULL) || (node->doc == NULL))\n\t\t\t    nocache = 1;\n\t\t\telse {\n\t\t\t    while (parent->parent != NULL)\n\t\t\t\tparent = parent->parent;\n\t\t\t    if (((parent->type != XML_DOCUMENT_NODE) &&\n\t\t\t\t (parent->type != XML_HTML_DOCUMENT_NODE)) ||\n\t\t\t\t (parent != (xmlNodePtr) node->doc))\n\t\t\t\tnocache = 1;\n\t\t\t}\n\t\t    }\n\t\t    if (pos != 0) {\n\t\t\tctxt->xpathCtxt->contextSize = len;\n\t\t\tctxt->xpathCtxt->proximityPosition = pos;\n\t\t\tif ((node->doc != NULL) && (nocache == 0) && !isRVT) {\n\t\t\t    XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr) =\n\t\t\t\tnode;\n\t\t\t    XSLT_RUNTIME_EXTRA(ctxt, sel->indexExtra, ival) =\n\t\t\t\tpos;\n\t\t\t    XSLT_RUNTIME_EXTRA(ctxt, sel->lenExtra, ival) =\n\t\t\t\tlen;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\toldNode = ctxt->node;\n\t\tctxt->node = node;\n\t\tif (step->value == NULL)\n\t\t    goto wrong_index;\n\t\tif (step->comp == NULL)\n\t\t    goto wrong_index;\n\t\tif (!xsltEvalXPathPredicate(ctxt, step->comp, comp->nsList,\n\t\t\t                    comp->nsNr))\n\t\t    goto wrong_index;\n \n\t\tif (pos != 0) {\n\t\t    ctxt->xpathCtxt->contextSize = oldCS;\n\t\t    ctxt->xpathCtxt->proximityPosition = oldCP;\n\t\t}\n\t\tctxt->node = oldNode;\n \t\tbreak;\nwrong_index:\n\t\tif (pos != 0) {\n\t\t    ctxt->xpathCtxt->contextSize = oldCS;\n\t\t    ctxt->xpathCtxt->proximityPosition = oldCP;\n\t\t}\n\t\tctxt->node = oldNode;\n\t\tgoto rollback;\n \t    }\n             case XSLT_OP_PI:\n \t\tif (node->type != XML_PI_NODE)\n\t\t    goto rollback;\n\t\tif (step->value != NULL) {\n\t\t    if (!xmlStrEqual(step->value, node->name))\n\t\t\tgoto rollback;\n\t\t}\n\t\tbreak;\n            case XSLT_OP_COMMENT:\n\t\tif (node->type != XML_COMMENT_NODE)\n\t\t    goto rollback;\n\t\tbreak;\n            case XSLT_OP_TEXT:\n\t\tif ((node->type != XML_TEXT_NODE) &&\n\t\t    (node->type != XML_CDATA_SECTION_NODE))\n\t\t    goto rollback;\n\t\tbreak;\n            case XSLT_OP_NODE:\n\t\tswitch (node->type) {\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_TEXT_NODE:\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto rollback;\n\t\t}\n\t\tbreak;\n\t}\n    }\nfound:\n    if (states.states != NULL) {\n\txmlFree(states.states);\n    }\n    return(1);\nrollback:\n    if (states.states == NULL)\n\treturn(0);\n    if (states.nbstates <= 0) {\n\txmlFree(states.states);\n\treturn(0);\n    }\n    states.nbstates--;\n    i = states.states[states.nbstates].step;\n    node = states.states[states.nbstates].node;\n#if 0\n    fprintf(stderr, \"Pop: %d, %s\\n\", i, node->name);\n#endif\n    goto restart;\n}\n", "target": 1, "flaw_line_index": "2,209,210,211,212,213,218,222,223,224,225,226,226,226,227,228,229,230,231,232,233,234,235,236,237,238,239,239,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,284,284,285,286,287,288,289,290,291,292,293,294,295,296,297,297,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,332,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,350,350,351,352,353,354,355,356,357,358,359,360,360,361,362,363,364,365,366,367,368,369,370,371,372,373,373,373,374,375,376,377,378,379,380,381,382,383,384,384,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,410,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,431,432,433,434,435,437,438,439,440,441,442,443"}
{"idx": 9073, "func": "static void vmxnet3_update_rx_mode(VMXNET3State *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    s->rx_mode = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem,\n                                           devRead.rxFilterConf.rxMode);\n    VMW_CFPRN(\"RX mode: 0x%08X\", s->rx_mode);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188212, "func": "OMX_ERRORTYPE SoftAACEncoder2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = (OMX_AUDIO_AACPROFILETYPE) mAACProfile;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n switch (mSBRMode) {\n case 1: \n switch (mSBRRatio) {\n case 0:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                    ALOGE(\"invalid SBR ratio %d\", mSBRRatio);\n                    TRESPASS();\n }\n break;\n case 0: \n case -1: \n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                ALOGE(\"invalid SBR mode %d\", mSBRMode);\n                TRESPASS();\n }\n\n\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187971, "func": "void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n stream_t *ps_stream;\n\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n }\n}\n", "target": 1, "flaw_line_index": "10,13"}
{"idx": 188170, "func": "void SoftMPEG4::onQueueFilled(OMX_U32 \n) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n PortInfo *port = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n\n\n             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;\n             if ((outHeader->nAllocLen < yFrameSize) ||\n                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {\n                ALOGE(\"Too small output buffer for reference frame: %zu bytes\",\n                        outHeader->nAllocLen);\n                 android_errorWriteLog(0x534e4554, \"30033990\");\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                 mSignalledError = true;\n return;\n }\n PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n            mFramesConfigured = true;\n }\n\n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n int32_t bufferSize = inHeader->nFilledLen;\n int32_t tmp = bufferSize;\n\n        OMX_U32 frameSize;\n        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;\n if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {\n            ALOGE(\"Frame size too large\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));\n\n if (outHeader->nAllocLen < frameSize) {\n            android_errorWriteLog(0x534e4554, \"27833616\");\n            ALOGE(\"Insufficient output buffer size\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = frameSize;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n", "target": 1, "flaw_line_index": "124,125"}
{"idx": 188206, "func": "void SoftMPEG2::setDecodeArgs(\n         ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n        OMX_BUFFERHEADERTYPE *outHeader,\n\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer = inHeader->pBuffer\n + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY / 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n", "target": 1, "flaw_line_index": "10,29,30,31,32,33,43"}
{"idx": 187757, "func": " main(void)\n {\n   fprintf(stderr, \"pngfix does not work without read support\\n\");\n    return 77;\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187500, "func": "static void command_timed_out(UNUSED_ATTR void *context) {\n  pthread_mutex_lock(&commands_pending_response_lock);\n\n if (list_is_empty(commands_pending_response)) {\n    LOG_ERROR(\"%s with no commands pending response\", __func__);\n } else {\n waiting_command_t *wait_entry = list_front(commands_pending_response);\n    pthread_mutex_unlock(&commands_pending_response_lock);\n\n    LOG_ERROR(\"%s hci layer timeout waiting for response to a command. opcode: 0x%x\", __func__, wait_entry->opcode);\n\n   }\n \n   LOG_ERROR(\"%s restarting the bluetooth process.\", __func__);\n  usleep(10000);\n   kill(getpid(), SIGKILL);\n }\n", "target": 1, "flaw_line_index": "17"}
{"idx": 8352, "func": "static void mptsas1068_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);\n\n    pc->realize = mptsas_scsi_init;\n    pc->exit = mptsas_scsi_uninit;\n    pc->romfile = 0;\n    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;\n    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;\n    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;\n    pc->subsystem_id = 0x8000;\n    pc->class_id = PCI_CLASS_STORAGE_SCSI;\n    dc->props = mptsas_properties;\n    dc->reset = mptsas_reset;\n    dc->vmsd = &vmstate_mptsas;\n    dc->desc = \"LSI SAS 1068\";\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187461, "func": "static inline int btif_hl_close_select_thread(void)\n{\n\n     int result = 0;\n     char sig_on = btif_hl_signal_select_exit;\n     BTIF_TRACE_DEBUG(\"btif_hl_signal_select_exit\");\n    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n     if (btif_is_enabled())\n     {\n if (select_thread_id != -1) {\n            pthread_join(select_thread_id, NULL);\n            select_thread_id = -1;\n }\n }\n    list_free(soc_queue);\n return result;\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 9195, "func": "void virtio_del_queue(VirtIODevice *vdev, int n)\n{\n    if (n < 0 || n >= VIRTIO_QUEUE_MAX) {\n        abort();\n    }\n\n    vdev->vq[n].vring.num = 0;\n    vdev->vq[n].vring.num_default = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9071, "func": "static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    uint16_t list_bytes =\n        VMXNET3_READ_DRV_SHARED16(d, s->drv_shmem,\n                                  devRead.rxFilterConf.mfTableLen);\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n    if (!s->mcast_list) {\n        if (s->mcast_list_len == 0) {\n            VMW_CFPRN(\"Current multicast list is empty\");\n        } else {\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n                      s->mcast_list_len);\n        }\n        s->mcast_list_len = 0;\n    } else {\n        int i;\n        hwaddr mcast_list_pa =\n            VMXNET3_READ_DRV_SHARED64(d, s->drv_shmem,\n                                      devRead.rxFilterConf.mfTablePA);\n\n        pci_dma_read(d, mcast_list_pa, s->mcast_list, list_bytes);\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n        for (i = 0; i < s->mcast_list_len; i++) {\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8757, "func": "struct option_set* FAST_FUNC udhcp_find_option(struct option_set *opt_list, uint8_t code)\n{\n\twhile (opt_list && opt_list->data[OPT_CODE] < code)\n\t\topt_list = opt_list->next;\n\n\tif (opt_list && opt_list->data[OPT_CODE] == code)\n\t\treturn opt_list;\n\treturn NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9056, "func": "static inline void vmxnet3_ring_write_curr_cell(PCIDevice *d, Vmxnet3Ring *ring,\n\t\t\t\t\t\tvoid *buff)\n{\n    vmw_shmem_write(d, vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell_size);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9113, "func": "static int vrend_decode_set_blend_color(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_blend_color color;\n   int i;\n\n   if (length != VIRGL_SET_BLEND_COLOR_SIZE)\n      return EINVAL;\n\n   for (i = 0; i < 4; i++)\n      color.color[i] = uif(get_buf_entry(ctx, VIRGL_SET_BLEND_COLOR(i)));\n\n   vrend_set_blend_color(ctx->grctx, &color);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188618, "func": "static unsigned int variance_ref(const uint8_t *ref, const uint8_t *src,\n                                 int l2w, int l2h, unsigned int *sse_ptr) {\n  int se = 0;\n  unsigned int sse = 0;\n  const int w = 1 << l2w, h = 1 << l2h;\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      int diff = ref[w * y + x] - src[w * y + x];\n      se += diff;\n      sse += diff * diff;\n    }\n   }\n  *sse_ptr = sse;\n  return sse - (((int64_t) se * se) >> (l2w + l2h));\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,11,11"}
{"idx": 9199, "func": "void virtio_device_set_child_bus_name(VirtIODevice *vdev, char *bus_name)\n{\n    g_free(vdev->bus_name);\n    vdev->bus_name = g_strdup(bus_name);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187988, "func": " static uint32_t readU16(const uint8_t* data, size_t offset) {\n    return data[offset] << 8 | data[offset + 1];\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 188582, "func": " void RunRoundTripErrorCheck() {\n ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n     int max_error = 0;\n     int total_error = 0;\n     const int count_test_block = 100000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n       for (int j = 0; j < 64; ++j) {\n           if (test_temp_block[j] > 0) {\n            test_temp_block[j] += 2;\n            test_temp_block[j] /= 4;\n            test_temp_block[j] *= 4;\n } else {\n            test_temp_block[j] -= 2;\n            test_temp_block[j] /= 4;\n\n             test_temp_block[j] *= 4;\n           }\n       }\n      REGISTER_STATE_CHECK(\n          RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n         const int diff = dst[j] - src[j];\n         const int error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n        total_error += error;\n\n       }\n     }\n \n    EXPECT_GE(1, max_error)\n       << \"Error: 8x8 FDCT/IDCT or FHT/IHT has an individual\"\n       << \" roundtrip error > 1\";\n \n    EXPECT_GE(count_test_block/5, total_error)\n       << \"Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip \"\n       << \"error > 1/5 per block\";\n   }\n", "target": 1, "flaw_line_index": "7,8,9,10,13,15,16,17,20,34,35,47,51"}
{"idx": 187590, "func": "static void readpng2_end_callback(png_structp png_ptr, png_infop info_ptr)\n{\n    mainprog_info  *mainprog_ptr;\n\n\n\n    mainprog_ptr = png_get_progressive_ptr(png_ptr);\n\n\n\n (*mainprog_ptr->mainprog_finish_display)();\n\n\n \n \n     return;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8761, "func": "int FAST_FUNC udhcp_str2optset(const char *const_str, void *arg,\n\t\tconst struct dhcp_optflag *optflags, const char *option_strings,\n\t\tbool dhcpv6)\n{\n\tstruct option_set **opt_list = arg;\n\tchar *opt;\n\tchar *str;\n\tconst struct dhcp_optflag *optflag;\n\tstruct dhcp_optflag userdef_optflag;\n\tunsigned optcode;\n\tint retval;\n\tchar buffer[9] ALIGNED(4);\n\tuint16_t *result_u16 = (uint16_t *) buffer;\n\tuint32_t *result_u32 = (uint32_t *) buffer;\n\n\tstr = (char *) const_str;\n\topt = strtok(str, \" \\t=:\");\n\tif (!opt)\n\t\treturn 0;\n\n\toptcode = bb_strtou(opt, NULL, 0);\n\tif (!errno && optcode < 255) {\n\t\tuserdef_optflag.flags = OPTION_BIN;\n\t\tuserdef_optflag.code = optcode;\n\t\toptflag = &userdef_optflag;\n\t} else {\n\t\toptflag = &optflags[udhcp_option_idx(opt, option_strings)];\n\t}\n\n\tretval = 0;\n\tdo {\n\t\tint length;\n\t\tchar *val;\n\n\t\tif (optflag->flags == OPTION_BIN) {\n\t\t\tval = strtok(NULL, \"\"); \n\t\t\ttrim(val);\n\t\t} else\n\t\t\tval = strtok(NULL, \", \\t\");\n\t\tif (!val)\n\t\t\tbreak;\n\n\t\tlength = dhcp_option_lengths[optflag->flags & OPTION_TYPE_MASK];\n\t\tretval = 0;\n\t\topt = buffer; \n\n\t\tswitch (optflag->flags & OPTION_TYPE_MASK) {\n\t\tcase OPTION_IP:\n\t\t\tretval = udhcp_str2nip(val, buffer);\n\t\t\tbreak;\n\t\tcase OPTION_IP_PAIR:\n\t\t\tretval = udhcp_str2nip(val, buffer);\n\t\t\tval = strtok(NULL, \", \\t/-\");\n\t\t\tif (!val)\n\t\t\t\tretval = 0;\n\t\t\tif (retval)\n\t\t\t\tretval = udhcp_str2nip(val, buffer + 4);\n\t\t\tbreak;\n case_OPTION_STRING:\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_STRING_HOST:\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n#endif\n\t\t\tlength = strnlen(val, 254);\n\t\t\tif (length > 0) {\n\t\t\t\topt = val;\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPTION_U8:\n\t\t\tbuffer[0] = bb_strtou32(val, NULL, 0);\n\t\t\tretval = (errno == 0);\n\t\t\tbreak;\n\t\tcase OPTION_U16: {\n\t\t\tuint32_t tmp = bb_strtou32(val, NULL, 0);\n\t\t\t*result_u16 = htons(tmp);\n\t\t\tretval = (errno == 0 \n);\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_U32: {\n\t\t\tuint32_t tmp = bb_strtou32(val, NULL, 0);\n\t\t\t*result_u32 = htonl(tmp);\n\t\t\tretval = (errno == 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32: {\n\t\t\tint32_t tmp = bb_strtoi32(val, NULL, 0);\n\t\t\t*result_u32 = htonl(tmp);\n\t\t\tretval = (errno == 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_STATIC_ROUTES: {\n\t\t\tunsigned mask;\n\t\t\tchar *slash = strchr(val, '/');\n\t\t\tif (slash) {\n\t\t\t\t*slash = '\\0';\n\t\t\t\tretval = udhcp_str2nip(val, buffer + 1);\n\t\t\t\tbuffer[0] = mask = bb_strtou(slash + 1, NULL, 10);\n\t\t\t\tval = strtok(NULL, \", \\t/-\");\n\t\t\t\tif (!val || mask > 32 || errno)\n\t\t\t\t\tretval = 0;\n\t\t\t\tif (retval) {\n\t\t\t\t\tlength = ((mask + 7) >> 3) + 5;\n\t\t\t\t\tretval = udhcp_str2nip(val, buffer + (length - 4));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_BIN:\n\t\t\tif (val[0] == '\"' || val[0] == '\\'') {\n\t\t\t\tchar delim = val[0];\n\t\t\t\tchar *end = last_char_is(val + 1, delim);\n\t\t\t\tif (end) {\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\tval++;\n\t\t\t\t\tuserdef_optflag.flags = OPTION_STRING;\n\t\t\t\t\tgoto case_OPTION_STRING;\n\t\t\t\t}\n\t\t\t}\n\t\t\topt = val;\n\t\t\tretval = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (retval)\n\t\t\tattach_option(opt_list, optflag, opt, length, dhcpv6);\n\t} while (retval && (optflag->flags & OPTION_LIST));\n\n\treturn retval;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8664, "func": "size_t mptsas_config_sas_device_2(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_device_addr_get(s, address);\n    SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n\n    trace_mptsas_config_sas_device(s, address, i, phy_handle, dev_handle, 2);\n    if (!dev) {\n        return -ENOENT;\n    }\n\n    return MPTSAS_CONFIG_PACK_EXT(2, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE, 0x01,\n                                  \"ql\", dev->wwn, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8362, "func": "static QEMUSGList *mptsas_get_sg_list(SCSIRequest *sreq)\n{\n    MPTSASRequest *req = sreq->hba_private;\n\n    return &req->qsg;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9204, "func": "uint16_t virtio_get_queue_index(VirtQueue *vq)\n{\n    return vq->queue_index;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187649, "func": "image_transform_png_set_expand_16_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n\n       image_pixel_convert_PLTE(that);\n \n    if (that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n \n    if (that->bit_depth < 16)\n       that->sample_depth = that->bit_depth = 16;\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "3,10"}
{"idx": 187469, "func": "static void btu_exec_tap_fd_read(void *p_param) {\n struct pollfd ufd;\n int fd = (int)p_param;\n\n if (fd == INVALID_FD || fd != btpan_cb.tap_fd)\n return;\n\n for (int i = 0; i < PAN_POOL_MAX && btif_is_enabled() && btpan_cb.flow; i++) {\n        BT_HDR *buffer = (BT_HDR *)GKI_getpoolbuf(PAN_POOL_ID);\n if (!buffer) {\n            BTIF_TRACE_WARNING(\"%s unable to allocate buffer for packet.\", __func__);\n break;\n }\n        buffer->offset = PAN_MINIMUM_OFFSET;\n        buffer->len = GKI_get_buf_size(buffer) - sizeof(BT_HDR) - buffer->offset;\n\n        UINT8 *packet = (UINT8 *)buffer + sizeof(BT_HDR) + buffer->offset;\n\n\n         if (!btpan_cb.congest_packet_size) {\n            ssize_t ret = read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet));\n             switch (ret) {\n                 case -1:\n                     BTIF_TRACE_ERROR(\"%s unable to read from driver: %s\", __func__, strerror(errno));\n                    GKI_freebuf(buffer);\n                    btsock_thread_add_fd(pan_pth, fd, 0, SOCK_THREAD_FD_RD, 0);\n return;\n case 0:\n                    BTIF_TRACE_WARNING(\"%s end of file reached.\", __func__);\n                    GKI_freebuf(buffer);\n                    btsock_thread_add_fd(pan_pth, fd, 0, SOCK_THREAD_FD_RD, 0);\n return;\n default:\n                    btpan_cb.congest_packet_size = ret;\n break;\n }\n }\n\n        memcpy(packet, btpan_cb.congest_packet, MIN(btpan_cb.congest_packet_size, buffer->len));\n        buffer->len = MIN(btpan_cb.congest_packet_size, buffer->len);\n\n if (buffer->len > sizeof(tETH_HDR) && should_forward((tETH_HDR *)packet)) {\n            tETH_HDR hdr;\n            memcpy(&hdr, packet, sizeof(tETH_HDR));\n\n            buffer->len -= sizeof(tETH_HDR);\n            buffer->offset += sizeof(tETH_HDR);\n if (forward_bnep(&hdr, buffer) != FORWARD_CONGEST)\n                btpan_cb.congest_packet_size = 0;\n } else {\n            BTIF_TRACE_WARNING(\"%s dropping packet of length %d\", __func__, buffer->len);\n            btpan_cb.congest_packet_size = 0;\n            GKI_freebuf(buffer);\n }\n\n\n         ufd.fd = fd;\n         ufd.events = POLLIN;\n         ufd.revents = 0;\n        if (poll(&ufd, 1, 0) <= 0 || IS_EXCEPTION(ufd.revents))\n             break;\n     }\n    btsock_thread_add_fd(pan_pth, fd, 0, SOCK_THREAD_FD_RD, 0);\n}\n", "target": 1, "flaw_line_index": "27"}
{"idx": 8356, "func": "static void mptsas_diag_write(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    MPTSASState *s = opaque;\n    trace_mptsas_diag_write(s, addr, val);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8668, "func": "size_t mptsas_config_sas_io_unit_3(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK_EXT(3, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x06,\n                                  \"*l*l*l*l*l*l*l*l*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188581, "func": " void RunExtremalCheck() {\n\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     int max_error = 0;\n     int total_error = 0;\n     const int count_test_block = 100000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j) {\n        src[j] = rnd.Rand8() % 2 ? 255 : 0;\n        dst[j] = src[j] > 0 ? 0 : 255;\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      REGISTER_STATE_CHECK(\n          RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n         const int diff = dst[j] - src[j];\n         const int error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n         total_error += error;\n       }\n \n      EXPECT_GE(1, max_error)\n           << \"Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has\"\n           << \"an individual roundtrip error > 1\";\n \n      EXPECT_GE(count_test_block/5, total_error)\n           << \"Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has average\"\n           << \" roundtrip error > 1/5 per block\";\n     }\n   }\n", "target": 1, "flaw_line_index": "7,8,9,10,13,15,16,17,20,22,23,33,37"}
{"idx": 188099, "func": "void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = (uint8_t*)p_data;\n\n   uint8_t reason = SMP_INVALID_PARAMETERS;\n \n   SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->status = *(uint8_t*)p_data;\n \n   if (smp_command_has_invalid_parameters(p_cb)) {\n     smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);\n     return;\n   }\n \n   if (p != NULL) {\n     STREAM_TO_UINT8(p_cb->peer_keypress_notification, p);\n   } else {\n    p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;\n }\n  p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;\n}\n", "target": 1, "flaw_line_index": "7"}
{"idx": 8739, "func": "vcard_apdu_set_length(VCardAPDU *apdu)\n{\n    int L, Le;\n\n    L = apdu->a_len-4; \n    apdu->a_Lc = 0;\n    apdu->a_Le = 0;\n    apdu->a_body = NULL;\n    switch (L) {\n    case 0:\n        return VCARD7816_STATUS_SUCCESS;\n    case 1:\n        apdu->a_Le = apdu->a_header->ah_Le ?\n                         apdu->a_header->ah_Le : 256;\n        return VCARD7816_STATUS_SUCCESS;\n    default:\n        if (apdu->a_header->ah_Le == 0) {\n            if (L < 3) {\n                return VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n            }\n            Le = (apdu->a_header->ah_body[0] << 8)\n                | apdu->a_header->ah_body[1];\n            if (L == 3) {\n                apdu->a_Le = Le ? Le : 65536;\n                return VCARD7816_STATUS_SUCCESS;\n            }\n            if (Le == 0) {\n                return VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n            }\n            apdu->a_Lc = Le;\n            apdu->a_body = &apdu->a_header->ah_body[2];\n            if (L == Le+3) {\n                return VCARD7816_STATUS_SUCCESS;\n            }\n            if (L == Le+5) {\n                Le = (apdu->a_data[apdu->a_len-2] << 8)\n                    | apdu->a_data[apdu->a_len-1];\n                apdu->a_Le = Le ? Le : 65536;\n                return VCARD7816_STATUS_SUCCESS;\n            }\n            return VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n        }\n        apdu->a_Lc = apdu->a_header->ah_Le;\n        apdu->a_body = &apdu->a_header->ah_body[0];\n        if (L ==  apdu->a_Lc + 1) {\n            return VCARD7816_STATUS_SUCCESS;\n        }\n        if (L ==  apdu->a_Lc + 2) {\n            Le = apdu->a_data[apdu->a_len-1];\n            apdu->a_Le = Le ?  Le : 256;\n            return VCARD7816_STATUS_SUCCESS;\n        }\n        break;\n    }\n    return VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188518, "func": "static void die_codec(vpx_codec_ctx_t *ctx, const char *s) {\n    const char *detail = vpx_codec_error_detail(ctx);\n    printf(\"%s: %s\\n\", s, vpx_codec_error(ctx));\n    if(detail)\n        printf(\"    %s\\n\",detail);\n    exit(EXIT_FAILURE);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 187734, "func": " transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,\n    PNG_CONST image_transform *transform_list)\n {\n    memset(dp, 0, sizeof *dp);\n \n   standard_display_init(&dp->this, &pm->this, id, 0\n,\n       pm->use_update_info);\n \n    dp->pm = pm;\n    dp->transform_list = transform_list;\n \n    dp->output_colour_type = 255; \n    dp->output_bit_depth = 255;  \n }\n", "target": 1, "flaw_line_index": "2,7"}
{"idx": 187463, "func": "void btif_hl_select_monitor_callback(fd_set *p_cur_set ,fd_set *p_org_set) {\n    UNUSED(p_org_set);\n\n    BTIF_TRACE_DEBUG(\"entering %s\",__FUNCTION__);\n\n for (const list_node_t *node = list_begin(soc_queue);\n            node != list_end(soc_queue); node = list_next(node)) {\n btif_hl_soc_cb_t *p_scb = list_node(node);\n if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_W4_READ) {\n if (FD_ISSET(p_scb->socket_id[1], p_cur_set)) {\n                BTIF_TRACE_DEBUG(\"read data state= BTIF_HL_SOC_STATE_W4_READ\");\n btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(p_scb->app_idx,\n                        p_scb->mcl_idx, p_scb->mdl_idx);\n                assert(p_dcb != NULL);\n if (p_dcb->p_tx_pkt) {\n                    BTIF_TRACE_ERROR(\"Rcv new pkt but the last pkt is still not been\"\n \"  sent tx_size=%d\", p_dcb->tx_size);\n                    btif_hl_free_buf((void **) &p_dcb->p_tx_pkt);\n\n                 }\n                 p_dcb->p_tx_pkt = btif_hl_get_buf (p_dcb->mtu);\n                 if (p_dcb) {\n                    int r = (int)recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,\n                            p_dcb->mtu, MSG_DONTWAIT);\n                     if (r > 0) {\n                         BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_callback send data r =%d\", r);\n                         p_dcb->tx_size = r;\n                        BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_callback send data tx_size=%d\", p_dcb->tx_size );\n                        BTA_HlSendData(p_dcb->mdl_handle, p_dcb->tx_size);\n } else {\n                        BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_callback receive failed r=%d\",r);\n                        BTA_HlDchClose(p_dcb->mdl_handle);\n }\n }\n }\n }\n }\n\n if (list_is_empty(soc_queue))\n        BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_queue is empty\");\n\n    BTIF_TRACE_DEBUG(\"leaving %s\",__FUNCTION__);\n}\n", "target": 1, "flaw_line_index": "23,24"}
{"idx": 188586, "func": "void fdct8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct8x8_c(in, out, stride);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187428, "func": "static void ptrace_siblings(pid_t pid, pid_t main_tid, std::set<pid_t>& tids) {\n  char task_path[64];\n \n  snprintf(task_path, sizeof(task_path), \"/proc/%d/task\", pid);\n \n   std::unique_ptr<DIR, int (*)(DIR*)> d(opendir(task_path), closedir);\n \n if (!d) {\n    ALOGE(\"debuggerd: failed to open /proc/%d/task: %s\", pid, strerror(errno));\n return;\n }\n\n struct dirent* de;\n while ((de = readdir(d.get())) != NULL) {\n if (!strcmp(de->d_name, \".\") || !strcmp(de->d_name, \"..\")) {\n continue;\n }\n\n char* end;\n pid_t tid = strtoul(de->d_name, &end, 10);\n if (*end) {\n continue;\n }\n\n if (tid == main_tid) {\n\n       continue;\n     }\n \n    if (ptrace(PTRACE_ATTACH, tid, 0, 0) < 0) {\n       ALOGE(\"debuggerd: ptrace attach to %d failed: %s\", tid, strerror(errno));\n       continue;\n     }\n\n    tids.insert(tid);\n }\n}\n", "target": 1, "flaw_line_index": "2,3,31"}
{"idx": 8742, "func": "vcard_process_apdu(VCard *card, VCardAPDU *apdu, VCardResponse **response)\n{\n    VCardStatus status;\n    VCardBufferResponse *buffer_response;\n\n    if (apdu->a_type == VCARD_7816_PTS) {\n        *response = vcard_response_new_data(apdu->a_data, apdu->a_len);\n        (*response)->b_total_len = (*response)->b_len;\n        return VCARD_DONE;\n    }\n    buffer_response = vcard_get_buffer_response(card);\n    if (buffer_response && apdu->a_ins != VCARD7816_INS_GET_RESPONSE) {\n        vcard_set_buffer_response(card, NULL);\n        vcard_buffer_response_delete(buffer_response);\n    }\n\n    status = vcard_process_applet_apdu(card, apdu, response);\n    if (status != VCARD_NEXT) {\n        return status;\n    }\n    switch (vcard_get_type(card)) {\n    case VCARD_FILE_SYSTEM:\n        return vcard7816_file_system_process_apdu(card, apdu, response);\n    case VCARD_VM:\n        return vcard7816_vm_process_apdu(card, apdu, response);\n    case VCARD_DIRECT:\n        assert(!\"VCARD_DIRECT: applet failure\");\n        break;\n    default:\n        g_warn_if_reached();\n    }\n    *response =\n        vcard_make_response(VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);\n    return VCARD_DONE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187711, "func": " static size_t safecat(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST char *cat)\n {\n    while (pos < bufsize && cat != NULL && *cat != 0)\n       buffer[pos++] = *cat++;\n\n if (pos >= bufsize)\n      pos = bufsize-1;\n\n   buffer[pos] = 0;\n return pos;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 9156, "func": "static GLuint blit_build_frag_blit_msaa_depth(struct vrend_blitter_ctx *blit_ctx, int tgsi_tex_target)\n{\n   GLuint fs_id;\n   char shader_buf[4096];\n   int is_shad;\n   const char *twm;\n   const char *ivec;\n\n   switch (tgsi_tex_target) {\n   case TGSI_TEXTURE_2D_MSAA:\n      twm = \".xy\";\n      ivec = \"ivec2\";\n      break;\n   case TGSI_TEXTURE_2D_ARRAY_MSAA:\n      twm = \".xyz\";\n      ivec = \"ivec3\";\n      break;\n   default:\n      return 0;\n   }\n\n   snprintf(shader_buf, 4096, FS_TEXFETCH_DS_MSAA, vrend_shader_samplertypeconv(tgsi_tex_target, &is_shad), ivec, twm);\n\n   fs_id = glCreateShader(GL_FRAGMENT_SHADER);\n\n   if (!build_and_check(fs_id, shader_buf)) {\n      glDeleteShader(fs_id);\n      return 0;\n   }\n\n   return fs_id;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8766, "func": "static void client_background(void)\n{\n\tbb_daemonize(0);\n\tlogmode &= ~LOGMODE_STDIO;\n\twrite_pidfile(client_config.pidfile);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8606, "func": "static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,\n                int x0, int y0, int x1, int y1, int w, int h)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    uint8_t *vram = s->vga.vram_ptr;\n    int bypl = surface_stride(surface);\n    int bypp = surface_bytes_per_pixel(surface);\n    int width = bypp * w;\n    int line = h;\n    uint8_t *ptr[2];\n\n    if (!vmsvga_verify_rect(surface, \"vmsvga_copy_rect/src\", x0, y0, w, h)) {\n        return -1;\n    }\n    if (!vmsvga_verify_rect(surface, \"vmsvga_copy_rect/dst\", x1, y1, w, h)) {\n        return -1;\n    }\n\n    if (y1 > y0) {\n        ptr[0] = vram + bypp * x0 + bypl * (y0 + h - 1);\n        ptr[1] = vram + bypp * x1 + bypl * (y1 + h - 1);\n        for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl) {\n            memmove(ptr[1], ptr[0], width);\n        }\n    } else {\n        ptr[0] = vram + bypp * x0 + bypl * y0;\n        ptr[1] = vram + bypp * x1 + bypl * y1;\n        for (; line > 0; line --, ptr[0] += bypl, ptr[1] += bypl) {\n            memmove(ptr[1], ptr[0], width);\n        }\n    }\n\n    vmsvga_update_rect_delayed(s, x1, y1, w, h);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187609, "func": "compare_read(struct display *dp, int applied_transforms)\n{\n size_t rowbytes;\n   png_uint_32 width, height;\n int bit_depth, color_type;\n int interlace_method, compression_method, filter_method;\n const char *e = NULL;\n\n   png_get_IHDR(dp->read_pp, dp->read_ip, &width, &height, &bit_depth,\n &color_type, &interlace_method, &compression_method, &filter_method);\n\n#  define C(item) if (item != dp->item) \\\n      display_log(dp, APP_WARNING, \"IHDR \" #item \"(%lu) changed to %lu\",\\\n (unsigned long)dp->item, (unsigned long)item), e = #item\n\n   C(width);\n   C(height);\n   C(bit_depth);\n   C(color_type);\n   C(interlace_method);\n   C(compression_method);\n   C(filter_method);\n\n if (e)\n      display_log(dp, APP_ERROR, \"IHDR changed (%s)\", e);\n\n\n    {\n       unsigned long chunks =\n          png_get_valid(dp->read_pp, dp->read_ip, 0xffffffff);\n       if (chunks != dp->chunks)\n          display_log(dp, APP_FAIL, \"PNG chunks changed from 0x%lx to 0x%lx\",\n             (unsigned long)dp->chunks, chunks);\n }\n\n   rowbytes = png_get_rowbytes(dp->read_pp, dp->read_ip);\n\n if (rowbytes != dp->original_rowbytes)\n      display_log(dp, APP_ERROR, \"PNG rowbytes changed from %lu to %lu\",\n (unsigned long)dp->original_rowbytes, (unsigned long)rowbytes);\n\n {\n      png_bytepp rows = png_get_rows(dp->read_pp, dp->read_ip);\n unsigned int mask; \n\n if (bit_depth < 8)\n {\n         mask = 0xff & (0xff00 >> ((bit_depth * width) & 7));\n }\n\n else\n         mask = 0;\n\n if (rows == NULL)\n         display_log(dp, LIBPNG_BUG, \"png_get_rows returned NULL\");\n\n if ((applied_transforms & PNG_TRANSFORM_SHIFT) == 0 ||\n (dp->active_transforms & PNG_TRANSFORM_SHIFT) == 0 ||\n         color_type == PNG_COLOR_TYPE_PALETTE)\n {\n unsigned long y;\n\n for (y=0; y<height; ++y)\n {\n            png_bytep row = rows[y];\n            png_bytep orig = dp->original_rows[y];\n\n if (memcmp(row, orig, rowbytes-(mask != 0)) != 0 || (mask != 0 &&\n ((row[rowbytes-1] & mask) != (orig[rowbytes-1] & mask))))\n {\n size_t x;\n\n for (x=0; x<rowbytes-1; ++x) if (row[x] != orig[x])\n break;\n\n               display_log(dp, APP_FAIL,\n \"byte(%lu,%lu) changed 0x%.2x -> 0x%.2x\",\n (unsigned long)x, (unsigned long)y, orig[x], row[x]);\n return 0; \n }\n }\n }\n\n else\n {\n unsigned long y;\n int bpp; \n         png_byte sig_bits[8];\n         png_color_8p sBIT;\n\n if (png_get_sBIT(dp->read_pp, dp->read_ip, &sBIT) != PNG_INFO_sBIT)\n            display_log(dp, INTERNAL_ERROR,\n \"active shift transform but no sBIT in file\");\n\n switch (color_type)\n {\n case PNG_COLOR_TYPE_GRAY:\n               sig_bits[0] = sBIT->gray;\n               bpp = bit_depth;\n break;\n\n case PNG_COLOR_TYPE_GA:\n               sig_bits[0] = sBIT->gray;\n               sig_bits[1] = sBIT->alpha;\n               bpp = 2 * bit_depth;\n break;\n\n case PNG_COLOR_TYPE_RGB:\n               sig_bits[0] = sBIT->red;\n               sig_bits[1] = sBIT->green;\n               sig_bits[2] = sBIT->blue;\n               bpp = 3 * bit_depth;\n break;\n\n case PNG_COLOR_TYPE_RGBA:\n               sig_bits[0] = sBIT->red;\n               sig_bits[1] = sBIT->green;\n               sig_bits[2] = sBIT->blue;\n               sig_bits[3] = sBIT->alpha;\n               bpp = 4 * bit_depth;\n break;\n\n default:\n               display_log(dp, LIBPNG_ERROR, \"invalid colour type %d\",\n                  color_type);\n               bpp = 0;\n break;\n }\n\n {\n int b;\n\n for (b=0; 8*b<bpp; ++b)\n {\n if (sig_bits[b] == 0 || sig_bits[b] > bit_depth\n)\n                  display_log(dp, LIBPNG_BUG,\n \"invalid sBIT[%u]  value %d returned for PNG bit depth %d\",\n                     b, sig_bits[b], bit_depth);\n }\n }\n\n if (bpp < 8 && bpp != bit_depth)\n {\n            display_log(dp, INTERNAL_ERROR, \"invalid bpp %u for bit_depth %u\",\n               bpp, bit_depth);\n }\n\n switch (bit_depth)\n\n          {\n             int b;\n \n            case 16: \n               for (b = (bpp >> 4); b > 0; )\n                {\n                   unsigned int sig = (unsigned int)(0xffff0000 >> sig_bits[b]);\n \n                  sig_bits[2*b+1] = (png_byte)sig;\n                  sig_bits[2*b+0] = (png_byte)(sig >> 8); \n }\n break;\n\n case 8: \n for (b=0; b*8 < bpp; ++b)\n                  sig_bits[b] = (png_byte)(0xff00 >> sig_bits[b]);\n break;\n\n case 1: \n               sig_bits[0] = 0xff;\n break;\n\n case 2: \n               b = 0x3 & ((0x3<<2) >> sig_bits[0]);\n               b |= b << 2;\n               b |= b << 4;\n               sig_bits[0] = (png_byte)b;\n break;\n\n case 4: \n               b = 0xf & ((0xf << 4) >> sig_bits[0]);\n               b |= b << 4;\n               sig_bits[0] = (png_byte)b;\n break;\n\n default:\n               display_log(dp, LIBPNG_BUG, \"invalid bit depth %d\", bit_depth);\n break;\n }\n\n         bpp = (bpp+7) >> 3;\n\n if (mask != 0)\n {\n            mask &= sig_bits[0];\n\n if (bpp != 1 || mask == 0)\n               display_log(dp, INTERNAL_ERROR, \"mask calculation error %u, %u\",\n                  bpp, mask);\n }\n\n for (y=0; y<height; ++y)\n {\n            png_bytep row = rows[y];\n            png_bytep orig = dp->original_rows[y];\n unsigned long x;\n\n for (x=0; x<(width-(mask!=0)); ++x)\n {\n int b;\n\n for (b=0; b<bpp; ++b)\n {\n if ((*row++ & sig_bits[b]) != (*orig++ & sig_bits[b]))\n {\n                     display_log(dp, APP_FAIL,\n \"significant bits at (%lu[%u],%lu) changed %.2x->%.2x\",\n                        x, b, y, orig[-1], row[-1]);\n return 0;\n }\n }\n }\n\n if (mask != 0 && (*row & mask) != (*orig & mask))\n {\n               display_log(dp, APP_FAIL,\n \"significant bits at (%lu[end],%lu) changed\", x, y);\n return 0;\n }\n } \n }\n }\n\n return 1; \n}\n", "target": 1, "flaw_line_index": "31,155,156"}
{"idx": 187639, "func": " image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,\n    png_byte bit_depth, png_uint_32 x, store_palette palette)\n {\n   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==\n       PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);\n   PNG_CONST unsigned int max = (1U<<sample_depth)-1;\n \n    this->palette_index = this->red = this->green = this->blue =\n      sample(row, colour_type, bit_depth, x, 0);\n    this->alpha = max;\n    this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =\n       sample_depth;\n\n if (colour_type == 3) \n {\n\n       if (palette != 0)\n       {\n         PNG_CONST unsigned int i = this->palette_index;\n \n          this->red = palette[i].red;\n          this->green = palette[i].green;\n this->blue = palette[i].blue;\n this->alpha = palette[i].alpha;\n }\n }\n\n else \n\n    {\n       unsigned int i = 0;\n \n       if (colour_type & 2)\n       {\n         this->green = sample(row, colour_type, bit_depth, x, 1);\n         this->blue = sample(row, colour_type, bit_depth, x, 2);\n         i = 2;\n       }\n      if (colour_type & 4)\n         this->alpha = sample(row, colour_type, bit_depth, x, ++i);\n    }\n \n   image_pixel_setf(this, max);\n \n this->colour_type = colour_type;\n\n    this->bit_depth = bit_depth;\n    this->sample_depth = sample_depth;\n    this->have_tRNS = 0;\n }\n", "target": 1, "flaw_line_index": "2,4,6,9,19,35,36,37,39,40,43"}
{"idx": 8548, "func": "static void ssh2_pkt_queuesend(Ssh ssh)\n{\n    int i;\n\n    assert(!ssh->queueing);\n\n    for (i = 0; i < ssh->queuelen; i++)\n\tssh2_pkt_defer_noqueue(ssh, ssh->queue[i], FALSE);\n    ssh->queuelen = 0;\n\n    ssh_pkt_defersend(ssh);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9042, "func": "static void vmxnet3_realize(DeviceState *qdev, Error **errp)\n{\n    VMXNET3Class *vc = VMXNET3_DEVICE_GET_CLASS(qdev);\n    PCIDevice *pci_dev = PCI_DEVICE(qdev);\n    VMXNET3State *s = VMXNET3(qdev);\n\n    if (!(s->compat_flags & VMXNET3_COMPAT_FLAG_DISABLE_PCIE)) {\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n    }\n\n    vc->parent_dc_realize(qdev, errp);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8312, "func": "XFixesRegionExtents (Display *dpy, XserverRegion dst, XserverRegion src)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesRegionExtentsReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesRegionExtents, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesRegionExtents;\n    req->source = src;\n    req->destination = dst;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188467, "func": "Track::Track(\n    Segment* pSegment,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    content_encoding_entries_(NULL),\n    content_encoding_entries_end_(NULL)\n{\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10"}
{"idx": 188401, "func": "void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision)\n{\n    major = 1;\n    minor = 0;\n    build = 0;\n    revision = 27;\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7"}
{"idx": 8614, "func": "static void vmsvga_init(DeviceState *dev, struct vmsvga_state_s *s,\n                        MemoryRegion *address_space, MemoryRegion *io)\n{\n    s->scratch_size = SVGA_SCRATCH_SIZE;\n    s->scratch = g_malloc(s->scratch_size * 4);\n\n    s->vga.con = graphic_console_init(dev, 0, &vmsvga_ops, s);\n\n    s->fifo_size = SVGA_FIFO_SIZE;\n    memory_region_init_ram(&s->fifo_ram, NULL, \"vmsvga.fifo\", s->fifo_size,\n                           &error_fatal);\n    vmstate_register_ram_global(&s->fifo_ram);\n    s->fifo_ptr = memory_region_get_ram_ptr(&s->fifo_ram);\n\n    vga_common_init(&s->vga, OBJECT(dev), true);\n    vga_init(&s->vga, OBJECT(dev), address_space, io, true);\n    vmstate_register(NULL, 0, &vmstate_vga_common, &s->vga);\n    s->new_depth = 32;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187961, "func": " status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    result.append(\"  State: \");\n\n    mFrameProcessor->dump(fd, args);\n\n return dumpDevice(fd, args);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9116, "func": "static int vrend_decode_set_framebuffer_state(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length < 2)\n      return EINVAL;\n\n   uint32_t nr_cbufs = get_buf_entry(ctx, VIRGL_SET_FRAMEBUFFER_STATE_NR_CBUFS);\n   uint32_t zsurf_handle = get_buf_entry(ctx, VIRGL_SET_FRAMEBUFFER_STATE_NR_ZSURF_HANDLE);\n   uint32_t surf_handle[8];\n   int i;\n\n   if (length != (2 + nr_cbufs))\n      return EINVAL;\n\n   if (nr_cbufs > 8)\n      return EINVAL;\n\n   for (i = 0; i < nr_cbufs; i++)\n      surf_handle[i] = get_buf_entry(ctx, VIRGL_SET_FRAMEBUFFER_STATE_CBUF_HANDLE(i));\n   vrend_set_framebuffer_state(ctx->grctx, nr_cbufs, surf_handle, zsurf_handle);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187437, "func": "void SoftMP3::onQueueFilled(OMX_U32 \n) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n if (inHeader) {\n if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n }\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n }\n        mConfig->inputBufferMaxLength = 0;\n        mConfig->inputBufferUsedLength = 0;\n\n        mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {\n            ALOGE(\"input buffer too small: got %u, expected %u\",\n                outHeader->nAllocLen, mConfig->outputFrameSize);\n            android_errorWriteLog(0x534e4554, \"27793371\");\n            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n            mSignalledError = true;\n return;\n }\n\n        mConfig->pOutputBuffer =\n reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n return;\n }\n\n if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n }\n\n if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n if (!mIsFirst) {\n\n                     outHeader->nOffset = 0;\n                     outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n \n                    memset(outHeader->pBuffer, 0, outHeader->nFilledLen);\n                 }\n                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                 mSignalledOutputEos = true;\n } else {\n\n\n                 ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                memset(outHeader->pBuffer,\n                       0,\n                       mConfig->outputFrameSize * sizeof(int16_t));\n \n                 if (inHeader) {\n                     mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n }\n }\n } else if (mConfig->samplingRate != mSamplingRate\n || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n return;\n }\n\n if (mIsFirst) {\n            mIsFirst = false;\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n }\n }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n", "target": 1, "flaw_line_index": "82,95,96,97"}
{"idx": 187655, "func": "image_transform_png_set_expand_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n      image_pixel_convert_PLTE(that);\n else if (that->bit_depth < 8) \n\n       that->sample_depth = that->bit_depth = 8;\n \n    if (that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n \n    this->next->mod(this->next, that, pp, display);\n }\n", "target": 1, "flaw_line_index": "3,12"}
{"idx": 8495, "func": "void CSoundFile::SetCurrentPos(UINT nPos)\n{\n\tUINT i, nPattern;\n\n\tfor (i=0; i<MAX_CHANNELS; i++)\n\t{\n\t\tChn[i].nNote = Chn[i].nNewNote = Chn[i].nNewIns = 0;\n\t\tChn[i].pInstrument = NULL;\n\t\tChn[i].pHeader = NULL;\n\t\tChn[i].nPortamentoDest = 0;\n\t\tChn[i].nCommand = 0;\n\t\tChn[i].nPatternLoopCount = 0;\n\t\tChn[i].nPatternLoop = 0;\n\t\tChn[i].nFadeOutVol = 0;\n\t\tChn[i].dwFlags |= CHN_KEYOFF|CHN_NOTEFADE;\n\t\tChn[i].nTremorCount = 0;\n\t}\n\tif (!nPos)\n\t{\n\t\tfor (i=0; i<MAX_CHANNELS; i++)\n\t\t{\n\t\t\tChn[i].nPeriod = 0;\n\t\t\tChn[i].nPos = Chn[i].nLength = 0;\n\t\t\tChn[i].nLoopStart = 0;\n\t\t\tChn[i].nLoopEnd = 0;\n\t\t\tChn[i].nROfs = Chn[i].nLOfs = 0;\n\t\t\tChn[i].pSample = NULL;\n\t\t\tChn[i].pInstrument = NULL;\n\t\t\tChn[i].pHeader = NULL;\n\t\t\tChn[i].nCutOff = 0x7F;\n\t\t\tChn[i].nResonance = 0;\n\t\t\tChn[i].nLeftVol = Chn[i].nRightVol = 0;\n\t\t\tChn[i].nNewLeftVol = Chn[i].nNewRightVol = 0;\n\t\t\tChn[i].nLeftRamp = Chn[i].nRightRamp = 0;\n\t\t\tChn[i].nVolume = 256;\n\t\t\tif (i < MAX_BASECHANNELS)\n\t\t\t{\n\t\t\t\tChn[i].dwFlags = ChnSettings[i].dwFlags;\n\t\t\t\tChn[i].nPan = ChnSettings[i].nPan;\n\t\t\t\tChn[i].nGlobalVol = ChnSettings[i].nVolume;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tChn[i].dwFlags = 0;\n\t\t\t\tChn[i].nPan = 128;\n\t\t\t\tChn[i].nGlobalVol = 64;\n\t\t\t}\n\t\t}\n\t\tm_nGlobalVolume = m_nDefaultGlobalVolume;\n\t\tm_nMusicSpeed = m_nDefaultSpeed;\n\t\tm_nMusicTempo = m_nDefaultTempo;\n\t}\n\tm_dwSongFlags &= ~(SONG_PATTERNLOOP|SONG_CPUVERYHIGH|SONG_FADINGSONG|SONG_ENDREACHED|SONG_GLOBALFADE);\n\tfor (nPattern = 0; nPattern < MAX_ORDERS; nPattern++)\n\t{\n\t\tUINT ord = Order[nPattern];\n\t\tif (ord == 0xFE) continue;\n\t\tif (ord == 0xFF) break;\n\t\tif (ord < MAX_PATTERNS)\n\t\t{\n\t\t\tif (nPos < (UINT)PatternSize[ord]) break;\n\t\t\tnPos -= PatternSize[ord];\n\t\t}\n\t}\n\tif ((nPattern >= MAX_ORDERS)\n\t || (Order[nPattern] >= MAX_PATTERNS)\n\t || (nPos >= PatternSize[Order[nPattern]]))\n\t{\n\t\tnPos = 0;\n\t\tnPattern = 0;\n\t}\n\tUINT nRow = nPos;\n\tif ((nRow) && (Order[nPattern] < MAX_PATTERNS))\n\t{\n\t\tMODCOMMAND *p = Patterns[Order[nPattern]];\n\t\tif ((p) && (nRow < PatternSize[Order[nPattern]]))\n\t\t{\n\t\t\tBOOL bOk = FALSE;\n\t\t\twhile ((!bOk) && (nRow > 0))\n\t\t\t{\n\t\t\t\tUINT n = nRow * m_nChannels;\n\t\t\t\tfor (UINT k=0; k<m_nChannels; k++, n++)\n\t\t\t\t{\n\t\t\t\t\tif (p[n].note)\n\t\t\t\t\t{\n\t\t\t\t\t\tbOk = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!bOk) nRow--;\n\t\t\t}\n\t\t}\n\t}\n\tm_nNextPattern = nPattern;\n\tm_nNextRow = nRow;\n\tm_nTickCount = m_nMusicSpeed;\n\tm_nBufferCount = 0;\n\tm_nPatternDelay = 0;\n\tm_nFrameDelay = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188507, "func": " static void unset_active_map(const vpx_codec_enc_cfg_t *cfg,\n                              vpx_codec_ctx_t *codec) {\n  vpx_active_map_t map = {0};\n \n   map.rows = (cfg->g_h + 15) / 16;\n   map.cols = (cfg->g_w + 15) / 16;\n map.active_map = NULL;\n\n if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))\n\n     die_codec(codec, \"Failed to set active map\");\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187662, "func": "image_transform_png_set_palette_to_rgb_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_palette_to_rgb(pp);\n this->next->set(this->next, that, pp, pi);\n\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8884, "func": "void vrend_object_bind_dsa(struct vrend_context *ctx,\n                           uint32_t handle)\n{\n   struct pipe_depth_stencil_alpha_state *state;\n\n   if (handle == 0) {\n      memset(&ctx->sub->dsa_state, 0, sizeof(ctx->sub->dsa_state));\n      ctx->sub->dsa = NULL;\n      ctx->sub->stencil_state_dirty = true;\n      ctx->sub->shader_dirty = true;\n      vrend_hw_emit_dsa(ctx);\n      return;\n   }\n\n   state = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_DSA);\n   if (!state) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_HANDLE, handle);\n      return;\n   }\n\n   if (ctx->sub->dsa != state) {\n      ctx->sub->stencil_state_dirty = true;\n      ctx->sub->shader_dirty = true;\n   }\n   ctx->sub->dsa_state = *state;\n   ctx->sub->dsa = state;\n\n   vrend_hw_emit_dsa(ctx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9085, "func": "static float uif(unsigned int ui)\n{\n   union { float f; unsigned int ui; } myuif;\n   myuif.ui = ui;\n   return myuif.f;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187783, "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\n if(prev_slice_err == 1)\n {\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n\n                        j = i;\n             {\n                ps_dec->ps_cur_slice->u1_bottom_field_flag = 0;\n                ps_dec->ps_cur_slice->u1_field_pic_flag = 0;\n                 ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                 ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                 ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n {\n            num_entries *= 2;\n }\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": "71,72"}
{"idx": 187489, "func": "static void *sock_poll_thread(void *arg)\n{\n struct pollfd pfds[MAX_POLL];\n    memset(pfds, 0, sizeof(pfds));\n int h = (intptr_t)arg;\n\n     for(;;)\n     {\n         prepare_poll_fds(h, pfds);\n        int ret = poll(pfds, ts[h].poll_count, -1);\n         if(ret == -1)\n         {\n             APPL_TRACE_ERROR(\"poll ret -1, exit the thread, errno:%d, err:%s\", errno, strerror(errno));\n break;\n }\n if(ret != 0)\n {\n int need_process_data_fd = TRUE;\n if(pfds[0].revents) \n {\n                asrt(pfds[0].fd == ts[h].cmd_fdr);\n if(!process_cmd_sock(h))\n {\n                    APPL_TRACE_DEBUG(\"h:%d, process_cmd_sock return false, exit...\", h);\n break;\n }\n if(ret == 1)\n                    need_process_data_fd = FALSE;\n else ret--; \n }\n if(need_process_data_fd)\n                process_data_sock(h, pfds, ret);\n }\n else {APPL_TRACE_DEBUG(\"no data, select ret: %d\", ret)};\n }\n    ts[h].thread_id = -1;\n    APPL_TRACE_DEBUG(\"socket poll thread exiting, h:%d\", h);\n return 0;\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 187571, "func": " INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n     }\n     return;\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8916, "func": "void vrend_renderer_resource_detach_iov(int res_handle,\n                                        struct iovec **iov_p,\n                                        int *num_iovs_p)\n{\n   struct vrend_resource *res;\n   res = vrend_resource_lookup(res_handle, 0);\n   if (!res) {\n      return;\n   }\n   if (iov_p)\n      *iov_p = res->iov;\n   if (num_iovs_p)\n      *num_iovs_p = res->num_iovs;\n\n   res->iov = NULL;\n   res->num_iovs = 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9192, "func": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stw_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188539, "func": " virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n\n     first_drop_ = 0;\n     bits_total_ = 0;\n     duration_ = 0.0;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188583, "func": "   void RunSignBiasCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_output_block, 64);\n     int count_sign_block[64][2];\n     const int count_test_block = 100000;\n \n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n\n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = rnd.Rand8() - rnd.Rand8();\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 1125;\n      EXPECT_LT(diff, max_diff)\n           << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-255, 255] at index \" << j\n << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n\n\n     memset(count_sign_block, 0, sizeof(count_sign_block));\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = (rnd.Rand8() >> 4) - (rnd.Rand8() >> 4);\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 10000;\n      EXPECT_LT(diff, max_diff)\n          << \"Error: 4x4 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-15, 15] at index \" << j\n           << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n }\n", "target": 1, "flaw_line_index": "3,4,14,15,29,30,43,45,46,60,61,62"}
{"idx": 9077, "func": "static void vmxnet3_validate_interrupts(VMXNET3State *s)\n{\n    int i;\n\n    VMW_CFPRN(\"Verifying event interrupt index (%d)\", s->event_int_idx);\n    vmxnet3_validate_interrupt_idx(s->msix_used, s->event_int_idx);\n\n    for (i = 0; i < s->txq_num; i++) {\n        int idx = s->txq_descr[i].intr_idx;\n        VMW_CFPRN(\"Verifying TX queue %d interrupt index (%d)\", i, idx);\n        vmxnet3_validate_interrupt_idx(s->msix_used, idx);\n    }\n\n    for (i = 0; i < s->rxq_num; i++) {\n        int idx = s->rxq_descr[i].intr_idx;\n        VMW_CFPRN(\"Verifying RX queue %d interrupt index (%d)\", i, idx);\n        vmxnet3_validate_interrupt_idx(s->msix_used, idx);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9142, "func": "static boolean parse_int( const char **pcur, int *val )\n{\n   const char *cur = *pcur;\n   int sign = (*cur == '-' ? -1 : 1);\n\n   if (*cur == '+' || *cur == '-')\n      cur++;\n\n   if (parse_uint(&cur, (uint *)val)) {\n      *val *= sign;\n      *pcur = cur;\n      return TRUE;\n   }\n\n    return FALSE;\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 8765, "func": "static void change_listen_mode(int new_mode)\n{\n\tlog1(\"entering listen mode: %s\",\n\t\tnew_mode != LISTEN_NONE\n\t\t\t? (new_mode == LISTEN_KERNEL ? \"kernel\" : \"raw\")\n\t\t\t: \"none\"\n\t);\n\n\tlisten_mode = new_mode;\n\tif (sockfd >= 0) {\n\t\tclose(sockfd);\n\t\tsockfd = -1;\n\t}\n\tif (new_mode == LISTEN_KERNEL)\n\t\tsockfd = udhcp_listen_socket(\n CLIENT_PORT, client_config.interface);\n\telse if (new_mode != LISTEN_NONE)\n\t\tsockfd = udhcp_raw_socket(client_config.ifindex);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188439, "func": "long ContentEncoding::ParseCompressionEntry(\n    long long start,\n    long long size,\n    IMkvReader* pReader,\n    ContentCompression* compression) {\n   assert(pReader);\n   assert(compression);\n \n long long pos = start;\n const long long stop = start + size;\n\n bool valid = false;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  \n       return status;\n \n     if (id == 0x254) {\n long long algo = UnserializeUInt(pReader, pos, size);\n if (algo < 0)\n return E_FILE_FORMAT_INVALID;\n      compression->algo = algo;\n      valid = true;\n } else if (id == 0x255) {\n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      compression->settings = buf;\n\n       compression->settings_len = buflen;\n     }\n \n    pos += size;  \n     assert(pos <= stop);\n   }\n \n if (!valid)\n return E_FILE_FORMAT_INVALID;\n\n\n   return 0;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,17,18,19,20,21,22,44,46,55"}
{"idx": 9173, "func": "static void put_extra_state(QEMUFile *f, void *pv, size_t size)\n{\n    VirtIODevice *vdev = pv;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    k->save_extra_state(qbus->parent, f);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8573, "func": "static void ssh_pkt_addstring_start(struct Packet *pkt)\n{\n    ssh_pkt_adduint32(pkt, 0);\n    pkt->savedpos = pkt->length;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9102, "func": "static int vrend_decode_create_sub_ctx(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t ctx_sub_id = get_buf_entry(ctx, 1);\n\n   vrend_renderer_create_sub_ctx(ctx->grctx, ctx_sub_id);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8572, "func": "static void ssh_pkt_addstring_data(struct Packet *pkt, const char *data,\n                                   int len)\n{\n    ssh_pkt_adddata(pkt, data, len);\n    PUT_32BIT(pkt->data + pkt->savedpos - 4, pkt->length - pkt->savedpos);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187743, "func": "int validation_muldiv(int count, int argc, char **argv)\n{\n int tested = 0;\n int overflow = 0;\n int error = 0;\n int error64 = 0;\n int passed = 0;\n int randbits = 0;\n   png_uint_32 randbuffer;\n   png_fixed_point a;\n   png_int_32 times, div;\n\n while (--argc > 0)\n {\n         fprintf(stderr, \"unknown argument %s\\n\", *++argv);\n return 1;\n }\n\n   randbuffer = RAND_MAX;\n while (randbuffer != 0) ++randbits, randbuffer >>= 1;\n   printf(\"Using random number generator that makes %d bits\\n\", randbits);\n for (div=0; div<32; div += randbits)\n      randbuffer = (randbuffer << randbits) ^ rand();\n\n   a = 0;\n   times = div = 0;\n do\n\n    {\n       png_fixed_point result;\n       long long int fp, fpround;\n unsigned long hi, lo;\n int ok;\n\n {\n long u1, u2;\n int n = 0;\n if (a < 0) u1 = -a, n = 1; else u1 = a;\n if (times < 0) u2 = -times, n = !n; else u2 = times;\n         png_64bit_product(u1, u2, &hi, &lo);\n if (n)\n {\n            lo = ((~lo) + 1) & 0xffffffff;\n            hi = ~hi;\n if (lo == 0) ++hi;\n }\n }\n\n      fp = a;\n      fp *= times;\n if ((fp & 0xffffffff) != lo || ((fp >> 32) & 0xffffffff) != hi)\n {\n         fprintf(stderr, \"png_64bit_product %d * %d -> %lx|%.8lx not %llx\\n\",\n            a, times, hi, lo, fp);\n ++error64;\n }\n\n if (div != 0)\n {\n if ((fp < 0) != (div < 0))\n           fp -= div/2;\n else\n           fp += div/2;\n\n         fp /= div;\n         fpround = fp;\n         ok = fpround <= PNG_UINT_31_MAX &&\n              fpround >= -1-(long long int)PNG_UINT_31_MAX;\n if (!ok) ++overflow;\n }\n else\n        ok = 0, ++overflow, fpround = fp\n;\n\n if (verbose)\n         fprintf(stderr, \"TEST %d * %d / %d -> %lld (%s)\\n\", a, times, div,\n            fp, ok ? \"ok\" : \"overflow\");\n\n ++tested;\n if (png_muldiv(&result, a, times, div) != ok)\n {\n ++error;\n if (ok)\n             fprintf(stderr, \"%d * %d / %d -> overflow (expected %lld)\\n\", a,\n                times, div, fp);\n else\n             fprintf(stderr, \"%d * %d / %d -> %d (expected overflow %lld)\\n\", a,\n                times, div, result, fp);\n }\n else if (ok && result != fpround)\n {\n ++error;\n         fprintf(stderr, \"%d * %d / %d -> %d not %lld\\n\", a, times, div, result,\n            fp);\n }\n else\n ++passed;\n\n      a += times;\n      times += div;\n      div = randbuffer;\n      randbuffer = (randbuffer << randbits) ^ rand();\n\n    }\n    while (--count > 0);\n \n   printf(\"%d tests including %d overflows, %d passed, %d failed (%d 64 bit \"\n       \"errors)\\n\", tested, overflow, passed, error, error64);\n    return 0;\n }\n", "target": 1, "flaw_line_index": "107"}
{"idx": 8369, "func": "static int mptsas_post_load(void *opaque, int version_id)\n{\n    MPTSASState *s = opaque;\n\n    if (s->doorbell_idx > s->doorbell_cnt ||\n        s->doorbell_cnt > ARRAY_SIZE(s->doorbell_msg) ||\n        s->doorbell_reply_idx > s->doorbell_reply_size ||\n        s->doorbell_reply_size > ARRAY_SIZE(s->doorbell_reply) ||\n        MPTSAS_FIFO_INVALID(s, request_post) ||\n        MPTSAS_FIFO_INVALID(s, reply_post) ||\n        MPTSAS_FIFO_INVALID(s, reply_free) ||\n        s->diagnostic_idx > 4) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187946, "func": "status_t MPEG4Source::read(\n MediaBuffer **out, const ReadOptions *options) {\n Mutex::Autolock autoLock(mLock);\n\n    CHECK(mStarted);\n\n if (mFirstMoofOffset > 0) {\n return fragmentedRead(out, options);\n }\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n uint32_t findFlags = 0;\n switch (mode) {\n case ReadOptions::SEEK_PREVIOUS_SYNC:\n                findFlags = SampleTable::kFlagBefore;\n break;\n case ReadOptions::SEEK_NEXT_SYNC:\n                findFlags = SampleTable::kFlagAfter;\n break;\n case ReadOptions::SEEK_CLOSEST_SYNC:\n case ReadOptions::SEEK_CLOSEST:\n                findFlags = SampleTable::kFlagClosest;\n break;\n default:\n                CHECK(!\"Should not be here.\");\n break;\n }\n\n uint32_t sampleIndex;\n status_t err = mSampleTable->findSampleAtTime(\n                seekTimeUs, 1000000, mTimescale,\n &sampleIndex, findFlags);\n\n if (mode == ReadOptions::SEEK_CLOSEST) {\n            findFlags = SampleTable::kFlagBefore;\n }\n\n uint32_t syncSampleIndex;\n if (err == OK) {\n            err = mSampleTable->findSyncSampleNear(\n                    sampleIndex, &syncSampleIndex, findFlags);\n }\n\n uint32_t sampleTime;\n if (err == OK) {\n            err = mSampleTable->getMetaDataForSample(\n                    sampleIndex, NULL, NULL, &sampleTime);\n }\n\n if (err != OK) {\n if (err == ERROR_OUT_OF_RANGE) {\n                err = ERROR_END_OF_STREAM;\n }\n            ALOGV(\"end of stream\");\n return err;\n }\n\n if (mode == ReadOptions::SEEK_CLOSEST) {\n            targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;\n }\n\n#if 0\n uint32_t syncSampleTime;\n        CHECK_EQ(OK, mSampleTable->getMetaDataForSample(\n                    syncSampleIndex, NULL, NULL, &syncSampleTime));\n\n        ALOGI(\"seek to time %lld us => sample at time %lld us, \"\n \"sync sample at time %lld us\",\n             seekTimeUs,\n             sampleTime * 1000000ll / mTimescale,\n             syncSampleTime * 1000000ll / mTimescale);\n#endif\n\n        mCurrentSampleIndex = syncSampleIndex;\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset;\n size_t size;\n uint32_t cts, stts;\n bool isSyncSample;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n status_t err =\n            mSampleTable->getMetaDataForSample(\n                    mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);\n\n if (err != OK) {\n return err;\n }\n\n        err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n return err;\n }\n if (size > mBuffer->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());\n return ERROR_BUFFER_TOO_SMALL;\n }\n }\n\n if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {\n if (newBuffer) {\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->clear();\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n            mBuffer->meta_data()->setInt64(\n                    kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC && !mIsHEVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mNALLengthSize > SIZE_MAX - nal_size) {\n            ALOGE(\"b/24441553, b/24445122\");\n }\n if (mBuffer->range_length() - mNALLengthSize < nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n if (usesDRM) {\n            num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);\n } else {\n            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);\n }\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n while (srcOffset < size) {\n bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n size_t nalLength = 0;\n if (!isMalFormed) {\n                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                    srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);\n }\n\n if (isMalFormed) {\n                    ALOGE(\"Video is malformed\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                     continue;\n                 }\n \n                CHECK(dstOffset + 4 <= mBuffer->size());\n \n                 dstData[dstOffset++] = 0;\n                 dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->clear();\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n        mBuffer->meta_data()->setInt64(\n                kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n", "target": 1, "flaw_line_index": "252"}
{"idx": 188190, "func": "int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,\n const MotionEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime,\n bool* outConflictingPointerActions) {\n enum InjectionPermission {\n        INJECTION_PERMISSION_UNKNOWN,\n        INJECTION_PERMISSION_GRANTED,\n        INJECTION_PERMISSION_DENIED\n };\n\n nsecs_t startTime = now();\n\n int32_t displayId = entry->displayId;\n int32_t action = entry->action;\n int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;\n\n int32_t injectionResult = INPUT_EVENT_INJECTION_PENDING;\n InjectionPermission injectionPermission = INJECTION_PERMISSION_UNKNOWN;\n    sp<InputWindowHandle> newHoverWindowHandle;\n\n const TouchState* oldState = NULL;\n ssize_t oldStateIndex = mTouchStatesByDisplay.indexOfKey(displayId);\n if (oldStateIndex >= 0) {\n        oldState = &mTouchStatesByDisplay.valueAt(oldStateIndex);\n        mTempTouchState.copyFrom(*oldState);\n }\n\n bool isSplit = mTempTouchState.split;\n bool switchedDevice = mTempTouchState.deviceId >= 0 && mTempTouchState.displayId >= 0\n && (mTempTouchState.deviceId != entry->deviceId\n || mTempTouchState.source != entry->source\n || mTempTouchState.displayId != displayId);\n bool isHoverAction = (maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_EXIT);\n bool newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN\n || maskedAction == AMOTION_EVENT_ACTION_SCROLL\n || isHoverAction);\n bool wrongDevice = false;\n if (newGesture) {\n bool down = maskedAction == AMOTION_EVENT_ACTION_DOWN;\n if (switchedDevice && mTempTouchState.down && !down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because a pointer for a different device is already down.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            switchedDevice = false;\n            wrongDevice = true;\n goto Failed;\n }\n        mTempTouchState.reset();\n        mTempTouchState.down = down;\n        mTempTouchState.deviceId = entry->deviceId;\n        mTempTouchState.source = entry->source;\n        mTempTouchState.displayId = displayId;\n        isSplit = false;\n }\n\n if (newGesture || (isSplit && maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) {\n\n int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n int32_t x = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_X));\n int32_t y = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_Y));\n        sp<InputWindowHandle> newTouchedWindowHandle;\n bool isTouchModal = false;\n\n size_t numWindows = mWindowHandles.size();\n for (size_t i = 0; i < numWindows; i++) {\n            sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n const InputWindowInfo* windowInfo = windowHandle->getInfo();\n if (windowInfo->displayId != displayId) {\n continue; \n }\n\n int32_t flags = windowInfo->layoutParamsFlags;\n if (windowInfo->visible) {\n if (! (flags & InputWindowInfo::FLAG_NOT_TOUCHABLE)) {\n                    isTouchModal = (flags & (InputWindowInfo::FLAG_NOT_FOCUSABLE\n | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0;\n if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) {\n                        newTouchedWindowHandle = windowHandle;\n break; \n }\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN\n && (flags & InputWindowInfo::FLAG_WATCH_OUTSIDE_TOUCH)) {\n\n                     int32_t outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE;\n                     if (isWindowObscuredAtPointLocked(windowHandle, x, y)) {\n                         outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n                     }\n \n                     mTempTouchState.addOrUpdateWindow(\n                            windowHandle, outsideTargetFlags, BitSet32(0));\n }\n }\n }\n\n if (newTouchedWindowHandle != NULL\n && newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n            isSplit = true;\n } else if (isSplit) {\n            newTouchedWindowHandle = NULL;\n }\n\n if (newTouchedWindowHandle == NULL) {\n            newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle();\n if (newTouchedWindowHandle == NULL) {\n                ALOGI(\"Dropping event because there is no touchable window at (%d, %d).\", x, y);\n                injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n }\n\n int32_t targetFlags = InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS;\n if (isSplit) {\n            targetFlags |= InputTarget::FLAG_SPLIT;\n\n         }\n         if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n             targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n         }\n \n if (isHoverAction) {\n            newHoverWindowHandle = newTouchedWindowHandle;\n } else if (maskedAction == AMOTION_EVENT_ACTION_SCROLL) {\n            newHoverWindowHandle = mLastHoverWindowHandle;\n }\n\n BitSet32 pointerIds;\n if (isSplit) {\n uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n            pointerIds.markBit(pointerId);\n }\n        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n } else {\n\n if (! mTempTouchState.down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because the pointer is not down or we previously \"\n \"dropped the pointer down event.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_MOVE\n && entry->pointerCount == 1\n && mTempTouchState.isSlippery()) {\n int32_t x = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_X));\n int32_t y = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_Y));\n\n            sp<InputWindowHandle> oldTouchedWindowHandle =\n                    mTempTouchState.getFirstForegroundWindowHandle();\n            sp<InputWindowHandle> newTouchedWindowHandle =\n                    findTouchedWindowAtLocked(displayId, x, y);\n if (oldTouchedWindowHandle != newTouchedWindowHandle\n && newTouchedWindowHandle != NULL) {\n#if DEBUG_FOCUS\n                ALOGD(\"Touch is slipping out of window %s into window %s.\",\n                        oldTouchedWindowHandle->getName().string(),\n                        newTouchedWindowHandle->getName().string());\n#endif\n                mTempTouchState.addOrUpdateWindow(oldTouchedWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT, BitSet32(0));\n\n if (newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n                    isSplit = true;\n }\n\n int32_t targetFlags = InputTarget::FLAG_FOREGROUND\n | InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER;\n if (isSplit) {\n                    targetFlags |= InputTarget::FLAG_SPLIT;\n }\n if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n                    targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n }\n\n BitSet32 pointerIds;\n if (isSplit) {\n                    pointerIds.markBit(entry->pointerProperties[0].id);\n }\n                mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n }\n }\n }\n\n if (newHoverWindowHandle != mLastHoverWindowHandle) {\n if (mLastHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover exit event to window %s.\",\n                    mLastHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(mLastHoverWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT, BitSet32(0));\n }\n\n if (newHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover enter event to window %s.\",\n                    newHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(newHoverWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER, BitSet32(0));\n }\n }\n\n {\n bool haveForegroundWindow = false;\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n                haveForegroundWindow = true;\n if (! checkInjectionPermission(touchedWindow.windowHandle,\n                        entry->injectionState)) {\n                    injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;\n                    injectionPermission = INJECTION_PERMISSION_DENIED;\n goto Failed;\n }\n }\n }\n if (! haveForegroundWindow) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because there is no touched foreground window to receive it.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n\n        injectionPermission = INJECTION_PERMISSION_GRANTED;\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n const int32_t foregroundWindowUid = foregroundWindowHandle->getInfo()->ownerUid;\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n                sp<InputWindowHandle> inputWindowHandle = touchedWindow.windowHandle;\n if (inputWindowHandle->getInfo()->ownerUid != foregroundWindowUid) {\n                    mTempTouchState.addOrUpdateWindow(inputWindowHandle,\n InputTarget::FLAG_ZERO_COORDS, BitSet32(0));\n }\n }\n }\n }\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n String8 reason = checkWindowReadyForMoreInputLocked(currentTime,\n                    touchedWindow.windowHandle, entry, \"touched\");\n if (!reason.isEmpty()) {\n                injectionResult = handleTargetsNotReadyLocked(currentTime, entry,\n                        NULL, touchedWindow.windowHandle, nextWakeupTime, reason.string());\n goto Unresponsive;\n }\n }\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n if (foregroundWindowHandle->getInfo()->hasWallpaper) {\n for (size_t i = 0; i < mWindowHandles.size(); i++) {\n                sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n const InputWindowInfo* info = windowHandle->getInfo();\n if (info->displayId == displayId\n && windowHandle->getInfo()->layoutParamsType\n\n                                 == InputWindowInfo::TYPE_WALLPAPER) {\n                     mTempTouchState.addOrUpdateWindow(windowHandle,\n                             InputTarget::FLAG_WINDOW_IS_OBSCURED\n                                     | InputTarget::FLAG_DISPATCH_AS_IS,\n                             BitSet32(0));\n                 }\n }\n }\n }\n\n    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows.itemAt(i);\n        addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags,\n                touchedWindow.pointerIds, inputTargets);\n }\n\n    mTempTouchState.filterNonAsIsTouchWindows();\n\nFailed:\n if (injectionPermission == INJECTION_PERMISSION_UNKNOWN) {\n if (checkInjectionPermission(NULL, entry->injectionState)) {\n            injectionPermission = INJECTION_PERMISSION_GRANTED;\n } else {\n            injectionPermission = INJECTION_PERMISSION_DENIED;\n }\n }\n\n if (injectionPermission == INJECTION_PERMISSION_GRANTED) {\n if (!wrongDevice) {\n if (switchedDevice) {\n#if DEBUG_FOCUS\n                ALOGD(\"Conflicting pointer actions: Switched to a different device.\");\n#endif\n *outConflictingPointerActions = true;\n }\n\n if (isHoverAction) {\n if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Hover received while pointer was down.\");\n#endif\n *outConflictingPointerActions = true;\n }\n                mTempTouchState.reset();\n if (maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE) {\n                    mTempTouchState.deviceId = entry->deviceId;\n                    mTempTouchState.source = entry->source;\n                    mTempTouchState.displayId = displayId;\n }\n } else if (maskedAction == AMOTION_EVENT_ACTION_UP\n || maskedAction == AMOTION_EVENT_ACTION_CANCEL) {\n                mTempTouchState.reset();\n } else if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Down received while already down.\");\n#endif\n *outConflictingPointerActions = true;\n }\n } else if (maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {\n if (isSplit) {\n int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); ) {\n TouchedWindow& touchedWindow = mTempTouchState.windows.editItemAt(i);\n if (touchedWindow.targetFlags & InputTarget::FLAG_SPLIT) {\n                            touchedWindow.pointerIds.clearBit(pointerId);\n if (touchedWindow.pointerIds.isEmpty()) {\n                                mTempTouchState.windows.removeAt(i);\n continue;\n }\n }\n                        i += 1;\n }\n }\n }\n\n if (maskedAction != AMOTION_EVENT_ACTION_SCROLL) {\n if (mTempTouchState.displayId >= 0) {\n if (oldStateIndex >= 0) {\n                        mTouchStatesByDisplay.editValueAt(oldStateIndex).copyFrom(mTempTouchState);\n } else {\n                        mTouchStatesByDisplay.add(displayId, mTempTouchState);\n }\n } else if (oldStateIndex >= 0) {\n                    mTouchStatesByDisplay.removeItemsAt(oldStateIndex);\n }\n }\n\n            mLastHoverWindowHandle = newHoverWindowHandle;\n }\n } else {\n#if DEBUG_FOCUS\n        ALOGD(\"Not updating touch focus because injection was denied.\");\n#endif\n }\n\nUnresponsive:\n    mTempTouchState.reset();\n\n nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);\n    updateDispatchStatisticsLocked(currentTime, entry,\n            injectionResult, timeSpentWaitingForApplication);\n#if DEBUG_FOCUS\n    ALOGD(\"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, \"\n \"timeSpentWaitingForApplication=%0.1fms\",\n            injectionResult, injectionPermission, timeSpentWaitingForApplication / 1000000.0);\n#endif\n return injectionResult;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9103, "func": "static int vrend_decode_create_surface(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   uint32_t res_handle, format, val0, val1;\n   int ret;\n\n   if (length != VIRGL_OBJ_SURFACE_SIZE)\n      return EINVAL;\n\n   res_handle = get_buf_entry(ctx, VIRGL_OBJ_SURFACE_RES_HANDLE);\n   format = get_buf_entry(ctx, VIRGL_OBJ_SURFACE_FORMAT);\n   val0 = get_buf_entry(ctx, VIRGL_OBJ_SURFACE_BUFFER_FIRST_ELEMENT);\n   val1 = get_buf_entry(ctx, VIRGL_OBJ_SURFACE_BUFFER_LAST_ELEMENT);\n   ret = vrend_create_surface(ctx->grctx, handle, res_handle, format, val0, val1);\n   return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187923, "func": "void BTM_PINCodeReply (BD_ADDR bd_addr, UINT8 res, UINT8 pin_len, UINT8 *p_pin, UINT32 trusted_mask[])\n{\n    tBTM_SEC_DEV_REC *p_dev_rec;\n\n    BTM_TRACE_API (\"BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  Result:%d\",\n                    btm_pair_state_descr(btm_cb.pairing_state), btm_cb.pairing_flags, pin_len, res);\n\n if (btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_LOCAL_PIN)\n {\n        BTM_TRACE_WARNING (\"BTM_PINCodeReply() - Wrong State: %d\", btm_cb.pairing_state);\n return;\n }\n\n if (memcmp (bd_addr, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)\n {\n        BTM_TRACE_ERROR (\"BTM_PINCodeReply() - Wrong BD Addr\");\n return;\n }\n\n if ((p_dev_rec = btm_find_dev (bd_addr)) == NULL)\n {\n        BTM_TRACE_ERROR (\"BTM_PINCodeReply() - no dev CB\");\n return;\n }\n\n if ( (pin_len > PIN_CODE_LEN) || (pin_len == 0) || (p_pin == NULL) )\n        res = BTM_ILLEGAL_VALUE;\n\n if (res != BTM_SUCCESS)\n {\n if ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_PEER_STARTED_DD) ||\n ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&\n (btm_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)) )\n {\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n            btm_cb.acl_disc_reason = HCI_ERR_HOST_REJECT_SECURITY;\n\n            btsnd_hcic_pin_code_neg_reply (bd_addr);\n }\n else\n {\n            p_dev_rec->security_required = BTM_SEC_NONE;\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);\n }\n return;\n }\n if (trusted_mask)\n        BTM_SEC_COPY_TRUSTED_DEVICE(trusted_mask, p_dev_rec->trusted_mask);\n    p_dev_rec->sec_flags   |= BTM_SEC_LINK_KEY_AUTHED;\n\n if ( (btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD)\n && (p_dev_rec->hci_handle == BTM_SEC_INVALID_HANDLE)\n && (btm_cb.security_mode_changed == FALSE) )\n {\n        btm_cb.pin_code_len = pin_len;\n        memcpy (btm_cb.pin_code, p_pin, pin_len);\n\n        btm_cb.security_mode_changed = TRUE;\n#ifdef APPL_AUTH_WRITE_EXCEPTION\n if(!(APPL_AUTH_WRITE_EXCEPTION)(p_dev_rec->bd_addr))\n#endif\n        btsnd_hcic_write_auth_enable (TRUE);\n\n        btm_cb.acl_disc_reason = 0xff ;\n\n if (btm_cb.pairing_flags & BTM_PAIR_FLAGS_REJECTED_CONNECT)\n {\n            BTM_TRACE_WARNING (\"BTM_PINCodeReply(): waiting HCI_Connection_Complete after rejected incoming connection\");\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);\n }\n else if (p_dev_rec->sm4 & BTM_SM4_CONN_PEND)\n {\n            BTM_TRACE_WARNING (\"BTM_PINCodeReply(): link is connecting so wait pin code request from peer\");\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);\n }\n else if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED)\n {\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);\n            p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;\n\n if (btm_cb.api.p_auth_complete_callback)\n (*btm_cb.api.p_auth_complete_callback) (p_dev_rec->bd_addr,  p_dev_rec->dev_class,\n                                                    p_dev_rec->sec_bd_name, HCI_ERR_AUTH_FAILURE);\n }\n return;\n }\n\n\n     btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n     btm_cb.acl_disc_reason = HCI_SUCCESS;\n \n#ifdef PORCHE_PAIRING_CONFLICT\n    BTM_TRACE_EVENT(\"BTM_PINCodeReply(): Saving pin_len: %d btm_cb.pin_code_len: %d\", pin_len, btm_cb.pin_code_len);\n    if (btm_cb.pin_code_len == 0)\n        memcpy (btm_cb.pin_code, p_pin, pin_len);\n    btm_cb.pin_code_len_saved = pin_len;\n#endif\n     btsnd_hcic_pin_code_req_reply (bd_addr, pin_len, p_pin);\n }\n", "target": 1, "flaw_line_index": "92,93,93,94,95,96,97"}
{"idx": 187829, "func": " long long Segment::CreateInstance(IMkvReader* pReader, long long pos,\n                                   Segment*& pSegment) {\n  assert(pReader);\n  assert(pos >= 0);\n \n   pSegment = NULL;\n \n long long total, available;\n\n const long status = pReader->Length(&total, &available);\n\n if (status < 0) \n return status;\n\n if (available < 0)\n return -1;\n\n if ((total >= 0) && (available > total))\n return -1;\n\n\n for (;;) {\n if ((total >= 0) && (pos >= total))\n return E_FILE_FORMAT_INVALID;\n\n long len;\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result) \n return result;\n\n if ((total >= 0) && ((pos + len) > total))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > available)\n\n       return pos + len;\n \n     const long long idpos = pos;\n    const long long id = ReadUInt(pReader, pos, len);\n \n    if (id < 0)  \n      return id;\n \n     pos += len;  \n \n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result) \n return result;\n\n if ((total >= 0) && ((pos + len) > total))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > available)\n return pos + len;\n\n long long size = ReadUInt(pReader, pos, len);\n\n if (size < 0) \n return size;\n\n    pos += len; \n\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (id == 0x08538067) { \n if (size == unknown_size)\n        size = -1;\n\n else if (total < 0)\n        size = -1;\n\n else if ((pos + size) > total)\n        size = -1;\n\n      pSegment = new (std::nothrow) Segment(pReader, idpos,\n                                            pos, size);\n\n if (pSegment == 0)\n return -1; \n\n return 0; \n }\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID;\n\n if ((total >= 0) && ((pos + size) > total))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + size) > available)\n return pos + size;\n\n    pos += size; \n }\n}\n", "target": 1, "flaw_line_index": "3,4,57,59,60"}
{"idx": 8383, "func": "static void mptsas_save_request(QEMUFile *f, SCSIRequest *sreq)\n{\n    MPTSASRequest *req = sreq->hba_private;\n    int i;\n\n    qemu_put_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n    qemu_put_be32(f, req->qsg.nsg);\n    for (i = 0; i < req->qsg.nsg; i++) {\n        qemu_put_be64(f, req->qsg.sg[i].base);\n        qemu_put_be64(f, req->qsg.sg[i].len);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187633, "func": " gamma_display_init(gamma_display *dp, png_modifier *pm, png_uint_32 id,\n     double file_gamma, double screen_gamma, png_byte sbit, int threshold_test,\n     int use_input_precision, int scale16, int expand16,\n    int do_background, PNG_CONST png_color_16 *pointer_to_the_background_color,\n     double background_gamma)\n {\n   standard_display_init(&dp->this, &pm->this, id, 0\n,\n       pm->use_update_info);\n \n   dp->pm = pm;\n   dp->file_gamma = file_gamma;\n   dp->screen_gamma = screen_gamma;\n   dp->background_gamma = background_gamma;\n   dp->sbit = sbit;\n   dp->threshold_test = threshold_test;\n   dp->use_input_precision = use_input_precision;\n   dp->scale16 = scale16;\n   dp->expand16 = expand16;\n   dp->do_background = do_background;\n if (do_background && pointer_to_the_background_color != 0)\n      dp->background_color = *pointer_to_the_background_color;\n else\n      memset(&dp->background_color, 0, sizeof dp->background_color);\n\n   dp->maxerrout = dp->maxerrpc = dp->maxerrabs = 0;\n}\n", "target": 1, "flaw_line_index": "4,8"}
{"idx": 8532, "func": "static struct Packet *ssh1_pkt_init(int pkt_type)\n{\n    struct Packet *pkt = ssh_new_packet();\n    pkt->length = 4 + 8;\t    \n    ssh_pkt_addbyte(pkt, pkt_type);\n    pkt->body = pkt->data + pkt->length;\n    pkt->type = pkt_type;\n    pkt->downstream_id = 0;\n    pkt->additional_log_text = NULL;\n    return pkt;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188087, "func": "int vp8_remove_decoder_instances(struct frame_buffers *fb)\n{\n if(!fb->use_frame_threads)\n {\n        VP8D_COMP *pbi = fb->pbi[0];\n\n\n         if (!pbi)\n             return VPX_CODEC_ERROR;\n #if CONFIG_MULTITHREAD\n        if (pbi->b_multithreaded_rd)\n            vp8mt_de_alloc_temp_buffers(pbi, pbi->common.mb_rows);\n         vp8_decoder_remove_threads(pbi);\n #endif\n \n        remove_decompressor(pbi);\n }\n else\n {\n }\n\n return VPX_CODEC_OK;\n}\n", "target": 1, "flaw_line_index": "11,12"}
{"idx": 187399, "func": "status_t SampleTable::setTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n if (mTimeToSample != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n     mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n \n     size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188180, "func": "status_t Parcel::readUtf8FromUtf16(std::string* str) const {\n size_t utf16Size = 0;\n const char16_t* src = readString16Inplace(&utf16Size);\n if (!src) {\n return UNEXPECTED_NULL;\n }\n\n if (utf16Size == 0u) {\n        str->clear();\n\n        return NO_ERROR;\n     }\n \n    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);\n    if (utf8Size < 0) {\n         return BAD_VALUE;\n     }\n    str->resize(utf8Size + 1);\n    utf16_to_utf8(src, utf16Size, &((*str)[0]));\n     str->resize(utf8Size);\n     return NO_ERROR;\n }\n", "target": 1, "flaw_line_index": "15,16,20,21,22"}
{"idx": 9090, "func": "static int vrend_decode_blit(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_blit_info info;\n   uint32_t dst_handle, src_handle, temp;\n\n   if (length != VIRGL_CMD_BLIT_SIZE)\n      return EINVAL;\n   temp = get_buf_entry(ctx, VIRGL_CMD_BLIT_S0);\n   info.mask = temp & 0xff;\n   info.filter = (temp >> 8) & 0x3;\n   info.scissor_enable = (temp >> 10) & 0x1;\n   info.render_condition_enable = (temp >> 11) & 0x1;\n   info.alpha_blend = (temp >> 12) & 0x1;\n   temp = get_buf_entry(ctx, VIRGL_CMD_BLIT_SCISSOR_MINX_MINY);\n   info.scissor.minx = temp & 0xffff;\n   info.scissor.miny = (temp >> 16) & 0xffff;\n   temp = get_buf_entry(ctx, VIRGL_CMD_BLIT_SCISSOR_MAXX_MAXY);\n   info.scissor.maxx = temp & 0xffff;\n   info.scissor.maxy = (temp >> 16) & 0xffff;\n   dst_handle = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_RES_HANDLE);\n   info.dst.level = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_LEVEL);\n   info.dst.format = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_FORMAT);\n   info.dst.box.x = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_X);\n   info.dst.box.y = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_Y);\n   info.dst.box.z = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_Z);\n   info.dst.box.width = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_W);\n   info.dst.box.height = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_H);\n   info.dst.box.depth = get_buf_entry(ctx, VIRGL_CMD_BLIT_DST_D);\n\n   src_handle = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_RES_HANDLE);\n   info.src.level = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_LEVEL);\n   info.src.format = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_FORMAT);\n   info.src.box.x = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_X);\n   info.src.box.y = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_Y);\n   info.src.box.z = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_Z);\n   info.src.box.width = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_W);\n   info.src.box.height = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_H);\n   info.src.box.depth = get_buf_entry(ctx, VIRGL_CMD_BLIT_SRC_D);\n\n   vrend_renderer_blit(ctx->grctx, dst_handle, src_handle, &info);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187700, "func": "perform_formatting_test(png_store *volatile ps)\n {\n #ifdef PNG_TIME_RFC1123_SUPPORTED\n   context(ps, fault);\n\n Try\n {\n      png_const_charp correct = \"29 Aug 2079 13:53:60 +0000\";\n      png_const_charp result;\n#     if PNG_LIBPNG_VER >= 10600\n char timestring[29];\n#     endif\n      png_structp pp;\n      png_time pt;\n\n      pp = set_store_for_write(ps, NULL, \"libpng formatting test\");\n\n if (pp == NULL)\n Throw ps;\n\n\n      pt.year = 2079;\n      pt.month = 8;\n      pt.day = 29;\n      pt.hour = 13;\n      pt.minute = 53;\n      pt.second = 60; \n\n#     if PNG_LIBPNG_VER < 10600\n         result = png_convert_to_rfc1123(pp, &pt);\n#     else\n if (png_convert_to_rfc1123_buffer(timestring, &pt))\n            result = timestring;\n\n else\n            result = NULL;\n#     endif\n\n if (result == NULL)\n         png_error(pp, \"png_convert_to_rfc1123 failed\");\n\n if (strcmp(result, correct) != 0)\n {\n size_t pos = 0;\n char msg[128];\n\n         pos = safecat(msg, sizeof msg, pos, \"png_convert_to_rfc1123(\");\n         pos = safecat(msg, sizeof msg, pos, correct);\n         pos = safecat(msg, sizeof msg, pos, \") returned: '\");\n         pos = safecat(msg, sizeof msg, pos, result);\n         pos = safecat(msg, sizeof msg, pos, \"'\");\n\n         png_error(pp, msg);\n }\n\n      store_write_reset(ps);\n }\n\n Catch(fault)\n {\n      store_write_reset(fault);\n }\n#else\n   UNUSED(ps)\n#endif\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187865, "func": "long VideoTrack::Parse(Segment* pSegment, const Info& info,\n long long element_start, long long element_size,\n VideoTrack*& pResult) {\n if (pResult)\n return -1;\n\n if (info.type != Track::kVideo)\n return -1;\n\n \n   long long width = 0;\n   long long height = 0;\n   double rate = 0.0;\n \n   IMkvReader* const pReader = pSegment->m_pReader;\n\n const Settings& s = info.settings;\n  assert(s.start >= 0);\n  assert(s.size >= 0);\n\n long long pos = s.start;\n  assert(pos >= 0);\n\n const long long stop = pos + s.size;\n\n while (pos < stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (id == 0x30) { \n      width = UnserializeUInt(pReader, pos, size);\n\n if (width <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x3A) { \n      height = UnserializeUInt(pReader, pos, size);\n\n \n       if (height <= 0)\n         return E_FILE_FORMAT_INVALID;\n     } else if (id == 0x0383E3) {  \n       const long status = UnserializeFloat(pReader, pos, size, rate);\n \n if (status < 0)\n return status;\n\n if (rate <= 0)\n return E_FILE_FORMAT_INVALID;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   VideoTrack* const pTrack =\n       new (std::nothrow) VideoTrack(pSegment, element_start, element_size);\n\n if (pTrack == NULL)\n return -1; \n\n const int status = info.Copy(pTrack->m_info);\n\n if (status) { \n delete pTrack;\n return status;\n }\n\n \n   pTrack->m_width = width;\n   pTrack->m_height = height;\n   pTrack->m_rate = rate;\n \n   pResult = pTrack;\n return 0; \n}\n", "target": 1, "flaw_line_index": "57,60"}
{"idx": 8928, "func": "static void vrend_resource_copy_fallback(struct vrend_context *ctx,\n                                         struct vrend_resource *src_res,\n                                         struct vrend_resource *dst_res,\n                                         uint32_t dst_level,\n                                         uint32_t dstx, uint32_t dsty,\n                                         uint32_t dstz, uint32_t src_level,\n                                         const struct pipe_box *src_box)\n{\n   char *tptr;\n   uint32_t transfer_size;\n   GLenum glformat, gltype;\n   int elsize = util_format_get_blocksize(dst_res->base.format);\n   int compressed = util_format_is_compressed(dst_res->base.format);\n   int cube_slice = 1;\n   uint32_t slice_size, slice_offset;\n   int i;\n   if (src_res->target == GL_TEXTURE_CUBE_MAP)\n      cube_slice = 6;\n\n   if (src_res->base.format != dst_res->base.format) {\n      fprintf(stderr, \"copy fallback failed due to mismatched formats %d %d\\n\", src_res->base.format, dst_res->base.format);\n      return;\n   }\n\n   slice_size = util_format_get_nblocks(src_res->base.format, u_minify(src_res->base.width0, src_level), u_minify(src_res->base.height0, src_level)) *\n      u_minify(src_res->base.depth0, src_level) * util_format_get_blocksize(src_res->base.format);\n   transfer_size = slice_size * src_res->base.array_size;\n\n   tptr = malloc(transfer_size);\n   if (!tptr)\n      return;\n\n   glformat = tex_conv_table[src_res->base.format].glformat;\n   gltype = tex_conv_table[src_res->base.format].gltype;\n\n   if (compressed)\n      glformat = tex_conv_table[src_res->base.format].internalformat;\n\n   switch (elsize) {\n   case 1:\n      glPixelStorei(GL_PACK_ALIGNMENT, 1);\n      break;\n   case 2:\n      glPixelStorei(GL_PACK_ALIGNMENT, 2);\n      break;\n   case 4:\n   default:\n      glPixelStorei(GL_PACK_ALIGNMENT, 4);\n      break;\n   case 8:\n      glPixelStorei(GL_PACK_ALIGNMENT, 8);\n      break;\n   }\n   glBindTexture(src_res->target, src_res->id);\n\n   slice_offset = 0;\n   for (i = 0; i < cube_slice; i++) {\n      GLenum ctarget = src_res->target == GL_TEXTURE_CUBE_MAP ? GL_TEXTURE_CUBE_MAP_POSITIVE_X + i : src_res->target;\n      if (compressed) {\n         if (vrend_state.have_robustness)\n            glGetnCompressedTexImageARB(ctarget, src_level, transfer_size, tptr + slice_offset);\n         else\n            glGetCompressedTexImage(ctarget, src_level, tptr + slice_offset);\n      } else {\n         if (vrend_state.have_robustness)\n            glGetnTexImageARB(ctarget, src_level, glformat, gltype, transfer_size, tptr + slice_offset);\n         else\n            glGetTexImage(ctarget, src_level, glformat, gltype, tptr + slice_offset);\n      }\n      slice_offset += slice_size;\n   }\n\n   glPixelStorei(GL_PACK_ALIGNMENT, 4);\n   switch (elsize) {\n   case 1:\n      glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n      break;\n   case 2:\n      glPixelStorei(GL_UNPACK_ALIGNMENT, 2);\n      break;\n   case 4:\n   default:\n      glPixelStorei(GL_UNPACK_ALIGNMENT, 4);\n      break;\n   case 8:\n      glPixelStorei(GL_UNPACK_ALIGNMENT, 8);\n      break;\n   }\n\n   glBindTexture(dst_res->target, dst_res->id);\n   slice_offset = 0;\n   for (i = 0; i < cube_slice; i++) {\n      GLenum ctarget = dst_res->target == GL_TEXTURE_CUBE_MAP ? GL_TEXTURE_CUBE_MAP_POSITIVE_X + i : dst_res->target;\n      if (compressed) {\n         if (ctarget == GL_TEXTURE_1D) {\n            glCompressedTexSubImage1D(ctarget, dst_level, dstx,\n                                      src_box->width,\n                                      glformat, transfer_size, tptr + slice_offset);\n         } else {\n            glCompressedTexSubImage2D(ctarget, dst_level, dstx, dsty,\n                                      src_box->width, src_box->height,\n                                      glformat, transfer_size, tptr + slice_offset);\n         }\n      } else {\n         if (ctarget == GL_TEXTURE_1D) {\n            glTexSubImage1D(ctarget, dst_level, dstx, src_box->width, glformat, gltype, tptr + slice_offset);\n         } else if (ctarget == GL_TEXTURE_3D ||\n                    ctarget == GL_TEXTURE_2D_ARRAY ||\n                    ctarget == GL_TEXTURE_CUBE_MAP_ARRAY) {\n            glTexSubImage3D(ctarget, dst_level, dstx, dsty, 0,src_box->width, src_box->height, src_box->depth, glformat, gltype, tptr + slice_offset);\n         } else {\n            glTexSubImage2D(ctarget, dst_level, dstx, dsty, src_box->width, src_box->height, glformat, gltype, tptr + slice_offset);\n         }\n      }\n      slice_offset += slice_size;\n   }\n\n   glPixelStorei(GL_UNPACK_ALIGNMENT, 4);\n   free(tptr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8778, "func": "static NOINLINE int send_select(uint32_t xid, uint32_t server, uint32_t requested)\n{\n\tstruct dhcp_packet packet;\n\tstruct in_addr temp_addr;\n\n\tinit_packet(&packet, DHCPREQUEST);\n\n\tpacket.xid = xid;\n\tudhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);\n\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\n\tadd_client_options(&packet);\n\n\ttemp_addr.s_addr = requested;\n\tbb_error_msg(\"sending select for %s\", inet_ntoa(temp_addr));\n\treturn raw_bcast_from_client_config_ifindex(&packet, INADDR_ANY);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187512, "func": " void *atomic_thread(void *context) {\n   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;\n   for (int i = 0; i < at->max_val; i++) {\n    usleep(1);\n     atomic_inc_prefix_s32(&at->data[i]);\n   }\n   return NULL;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 9120, "func": "static int vrend_decode_set_sample_mask(struct vrend_decode_ctx *ctx, int length)\n{\n   unsigned mask;\n\n   if (length != VIRGL_SET_SAMPLE_MASK_SIZE)\n      return EINVAL;\n   mask = get_buf_entry(ctx, VIRGL_SET_SAMPLE_MASK_MASK);\n   vrend_set_sample_mask(ctx->grctx, mask);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187814, "func": "OMX_ERRORTYPE omx_vdec::update_portdef(OMX_PARAM_PORTDEFINITIONTYPE *portDefn)\n{\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n struct v4l2_format fmt;\n if (!portDefn) {\n return OMX_ErrorBadParameter;\n\n     }\n     DEBUG_PRINT_LOW(\"omx_vdec::update_portdef\");\n     portDefn->nVersion.nVersion = OMX_SPEC_VERSION;\n    portDefn->nSize = sizeof(portDefn);\n     portDefn->eDomain    = OMX_PortDomainVideo;\n     if (drv_ctx.frame_rate.fps_denominator > 0)\n         portDefn->format.video.xFramerate = (drv_ctx.frame_rate.fps_numerator /\n            drv_ctx.frame_rate.fps_denominator) << 16; \n else {\n        DEBUG_PRINT_ERROR(\"Error: Divide by zero\");\n return OMX_ErrorBadParameter;\n }\n    memset(&fmt, 0x0, sizeof(struct v4l2_format));\n if (0 == portDefn->nPortIndex) {\n        portDefn->eDir =  OMX_DirInput;\n        portDefn->nBufferCountActual = drv_ctx.ip_buf.actualcount;\n        portDefn->nBufferCountMin    = drv_ctx.ip_buf.mincount;\n        portDefn->nBufferSize        = drv_ctx.ip_buf.buffer_size;\n        portDefn->format.video.eColorFormat = OMX_COLOR_FormatUnused;\n        portDefn->format.video.eCompressionFormat = eCompressionFormat;\n        portDefn->bEnabled   = m_inp_bEnabled;\n        portDefn->bPopulated = m_inp_bPopulated;\n\n        fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n        fmt.fmt.pix_mp.pixelformat = output_capability;\n } else if (1 == portDefn->nPortIndex) {\n unsigned int buf_size = 0;\n if (!client_buffers.update_buffer_req()) {\n            DEBUG_PRINT_ERROR(\"client_buffers.update_buffer_req Failed\");\n return OMX_ErrorHardware;\n }\n if (!client_buffers.get_buffer_req(buf_size)) {\n            DEBUG_PRINT_ERROR(\"update buffer requirements\");\n return OMX_ErrorHardware;\n }\n        portDefn->nBufferSize = buf_size;\n        portDefn->eDir =  OMX_DirOutput;\n        portDefn->nBufferCountActual = drv_ctx.op_buf.actualcount;\n        portDefn->nBufferCountMin    = drv_ctx.op_buf.mincount;\n        portDefn->format.video.eCompressionFormat = OMX_VIDEO_CodingUnused;\n        portDefn->bEnabled   = m_out_bEnabled;\n        portDefn->bPopulated = m_out_bPopulated;\n if (!client_buffers.get_color_format(portDefn->format.video.eColorFormat)) {\n            DEBUG_PRINT_ERROR(\"Error in getting color format\");\n return OMX_ErrorHardware;\n }\n        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n        fmt.fmt.pix_mp.pixelformat = capture_capability;\n } else {\n        portDefn->eDir = OMX_DirMax;\n        DEBUG_PRINT_LOW(\" get_parameter: Bad Port idx %d\",\n (int)portDefn->nPortIndex);\n        eRet = OMX_ErrorBadPortIndex;\n }\n if (is_down_scalar_enabled) {\n int ret = 0;\n        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_G_FMT, &fmt);\n if (ret) {\n            DEBUG_PRINT_ERROR(\"update_portdef : Error in getting port resolution\");\n return OMX_ErrorHardware;\n } else {\n            portDefn->format.video.nFrameWidth = fmt.fmt.pix_mp.width;\n            portDefn->format.video.nFrameHeight = fmt.fmt.pix_mp.height;\n            portDefn->format.video.nStride = fmt.fmt.pix_mp.plane_fmt[0].bytesperline;\n            portDefn->format.video.nSliceHeight = fmt.fmt.pix_mp.plane_fmt[0].reserved[0];\n }\n } else {\n    portDefn->format.video.nFrameHeight =  drv_ctx.video_resolution.frame_height;\n    portDefn->format.video.nFrameWidth  =  drv_ctx.video_resolution.frame_width;\n    portDefn->format.video.nStride = drv_ctx.video_resolution.stride;\n    portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.scan_lines;\n }\n\n if ((portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420Planar) ||\n (portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar)) {\n           portDefn->format.video.nStride = ALIGN(drv_ctx.video_resolution.frame_width, 16);\n        portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.frame_height;\n }\n    DEBUG_PRINT_HIGH(\"update_portdef(%u): Width = %u Height = %u Stride = %d \"\n \"SliceHeight = %u eColorFormat = %d nBufSize %u nBufCnt %u\",\n (unsigned int)portDefn->nPortIndex,\n (unsigned int)portDefn->format.video.nFrameWidth,\n (unsigned int)portDefn->format.video.nFrameHeight,\n (int)portDefn->format.video.nStride,\n (unsigned int)portDefn->format.video.nSliceHeight,\n (unsigned int)portDefn->format.video.eColorFormat,\n (unsigned int)portDefn->nBufferSize,\n (unsigned int)portDefn->nBufferCountActual);\n\n return eRet;\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 8496, "func": "BOOL CSoundFile::SetMasterVolume(UINT nVol, BOOL bAdjustAGC)\n{\n\tif (nVol < 1) nVol = 1;\n\tif (nVol > 0x200) nVol = 0x200;\t\n\tif ((nVol < m_nMasterVolume) && (nVol) && (gdwSoundSetup & SNDMIX_AGC) && (bAdjustAGC))\n\t{\n\t\tgnAGC = gnAGC * m_nMasterVolume / nVol;\n\t\tif (gnAGC > AGC_UNITY) gnAGC = AGC_UNITY;\n\t}\n\tm_nMasterVolume = nVol;\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187724, "func": "standard_test(png_store* PNG_CONST psIn, png_uint_32 PNG_CONST id,\n    int do_interlace, int use_update_info)\n {\n    standard_display d;\n   context(psIn, fault);\n\n   standard_display_init(&d, psIn, id, do_interlace, use_update_info);\n\n Try\n {\n      png_structp pp;\n      png_infop pi;\n\n      pp = set_store_for_read(d.ps, &pi, d.id,\n         d.do_interlace ? (d.ps->progressive ?\n \"pngvalid progressive deinterlacer\" :\n \"pngvalid sequential deinterlacer\") : (d.ps->progressive ?\n \"progressive reader\" : \"sequential reader\"));\n\n      standard_palette_init(&d);\n\n if (d.ps->progressive)\n {\n         png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,\n            standard_end);\n\n         store_progressive_read(d.ps, pp, pi);\n }\n else\n {\n         png_set_read_fn(pp, d.ps, store_read);\n\n         png_read_info(pp, pi);\n\n         standard_info_imp(&d, pp, pi, 2 \n);\n\n {\n            sequential_row(&d, pp, pi, 0, 1);\n\n if (!d.speed)\n {\n               standard_text_validate(&d, pp, pi, 1\n);\n               standard_image_validate(&d, pp, 0, 1);\n }\n else\n               d.ps->validated = 1;\n }\n }\n\n if (!d.ps->validated)\n         png_error(pp, \"image read failed silently\");\n\n }\n\n Catch(fault)\n      d.ps = fault; \n\n   store_read_reset(d.ps);\n\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187558, "func": "static void ProcessExifDir(unsigned char * DirStart, unsigned char * OffsetBase,\n unsigned ExifLength, int NestingLevel)\n{\n int de;\n int a;\n int NumDirEntries;\n unsigned ThumbnailOffset = 0;\n unsigned ThumbnailSize = 0;\n char IndentString[25];\n\n    printf(\"ProcessExifDir\");\n if (NestingLevel > 4){\n ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);\n return;\n }\n\n    memset(IndentString, ' ', 25);\n IndentString[NestingLevel * 4] = '\\0';\n\n\n NumDirEntries = Get16u(DirStart);\n #define DIR_ENTRY_ADDR(Start, Entry) (Start+2+12*(Entry))\n\n {\n unsigned char * DirEnd;\n DirEnd = DIR_ENTRY_ADDR(DirStart, NumDirEntries);\n if (DirEnd+4 > (OffsetBase+ExifLength)){\n if (DirEnd+2 == OffsetBase+ExifLength || DirEnd == OffsetBase+ExifLength){\n }else{\n ErrNonfatal(\"Illegally sized exif subdirectory (%d entries)\",NumDirEntries,0);\n return;\n }\n }\n if (DumpExifMap){\n            printf(\"Map: %05d-%05d: Directory\\n\",(int)(DirStart-OffsetBase), (int)(DirEnd+4-OffsetBase));\n }\n\n\n }\n\n if (ShowTags){\n        printf(\"(dir has %d entries)\\n\",NumDirEntries);\n }\n\n for (de=0;de<NumDirEntries;de++){\n int Tag, Format, Components;\n unsigned char * ValuePtr;\n int ByteCount;\n unsigned char * DirEntry;\n DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n Tag = Get16u(DirEntry);\n Format = Get16u(DirEntry+2);\n Components = Get32u(DirEntry+4);\n\n if ((Format-1) >= NUM_FORMATS) {\n ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n continue;\n }\n\n if ((unsigned)Components > 0x10000){\n ErrNonfatal(\"Illegal number of components %d for tag %04x\", Components, Tag);\n continue;\n }\n\n ByteCount = Components * BytesPerFormat[Format];\n\n if (ByteCount > 4){\n\n             unsigned OffsetVal;\n             OffsetVal = Get32u(DirEntry+8);\n            if (OffsetVal+ByteCount > ExifLength){\n                 ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n                 continue;\n }\n ValuePtr = OffsetBase+OffsetVal;\n\n if (OffsetVal > ImageInfo.LargestExifOffset){\n ImageInfo.LargestExifOffset = OffsetVal;\n }\n\n if (DumpExifMap){\n                printf(\"Map: %05d-%05d:   Data for tag %04x\\n\",OffsetVal, OffsetVal+ByteCount, Tag);\n }\n }else{\n ValuePtr = DirEntry+8;\n }\n\n if (Tag == TAG_MAKER_NOTE){\n if (ShowTags){\n                printf(\"%s    Maker note: \",IndentString);\n }\n ProcessMakerNote(ValuePtr, ByteCount, OffsetBase, ExifLength);\n continue;\n }\n\n if (ShowTags){\n for (a=0;;a++){\n if (a >= (int)TAG_TABLE_SIZE){\n                    printf(\"%s\", IndentString);\n                    printf(\"    Unknown Tag %04x Value = \", Tag);\n break;\n }\n if (TagTable[a].Tag == Tag){\n                    printf(\"%s\", IndentString);\n                    printf(\"    %s = \",TagTable[a].Desc);\n break;\n }\n }\n\n switch(Format){\n case FMT_BYTE:\n if(ByteCount>1){\n                        printf(\"%.*ls\\n\", ByteCount/2, (wchar_t *)ValuePtr);\n }else{\n PrintFormatNumber(ValuePtr, Format, ByteCount);\n                        printf(\"\\n\");\n }\n break;\n\n case FMT_UNDEFINED:\n\n case FMT_STRING:\n {\n                          printf(\"\\\"%s\\\"\", ValuePtr);\n }\n break;\n\n default:\n PrintFormatNumber(ValuePtr, Format, ByteCount);\n                    printf(\"\\n\");\n }\n }\n\n switch(Tag){\n\n case TAG_MAKE:\n                strncpy(ImageInfo.CameraMake, (char *)ValuePtr, ByteCount < 31 ? ByteCount : 31);\n break;\n\n case TAG_MODEL:\n                strncpy(ImageInfo.CameraModel, (char *)ValuePtr, ByteCount < 39 ? ByteCount : 39);\n break;\n\n case TAG_SUBSEC_TIME:\n                strlcpy(ImageInfo.SubSecTime, (char *)ValuePtr, sizeof(ImageInfo.SubSecTime));\n break;\n\n case TAG_SUBSEC_TIME_ORIG:\n                strlcpy(ImageInfo.SubSecTimeOrig, (char *)ValuePtr,\n sizeof(ImageInfo.SubSecTimeOrig));\n break;\n\n case TAG_SUBSEC_TIME_DIG:\n                strlcpy(ImageInfo.SubSecTimeDig, (char *)ValuePtr,\n sizeof(ImageInfo.SubSecTimeDig));\n break;\n\n case TAG_DATETIME_DIGITIZED:\n                strlcpy(ImageInfo.DigitizedTime, (char *)ValuePtr,\n sizeof(ImageInfo.DigitizedTime));\n\n if (ImageInfo.numDateTimeTags >= MAX_DATE_COPIES){\n ErrNonfatal(\"More than %d date fields!  This is nuts\", MAX_DATE_COPIES, 0);\n break;\n }\n ImageInfo.DateTimeOffsets[ImageInfo.numDateTimeTags++] =\n (char *)ValuePtr - (char *)OffsetBase;\n break;\n\n case TAG_DATETIME_ORIGINAL:\n                strncpy(ImageInfo.DateTime, (char *)ValuePtr, 19);\n\n case TAG_DATETIME:\n if (!isdigit(ImageInfo.DateTime[0])){\n                    strncpy(ImageInfo.DateTime, (char *)ValuePtr, 19);\n }\n\n if (ImageInfo.numDateTimeTags >= MAX_DATE_COPIES){\n ErrNonfatal(\"More than %d date fields!  This is nuts\", MAX_DATE_COPIES, 0);\n break;\n }\n ImageInfo.DateTimeOffsets[ImageInfo.numDateTimeTags++] =\n (char *)ValuePtr - (char *)OffsetBase;\n break;\n\n case TAG_WINXP_COMMENT:\n if (ImageInfo.Comments[0]){ \n if (ShowTags) printf(\"Windows XP commend and other comment in header\\n\");\n break; \n }\n\n if (ByteCount > 1){\n if (ByteCount > MAX_COMMENT_SIZE) ByteCount = MAX_COMMENT_SIZE;\n                    memcpy(ImageInfo.Comments, ValuePtr, ByteCount);\n ImageInfo.CommentWidchars = ByteCount/2;\n }\n break;\n\n case TAG_USERCOMMENT:\n if (ImageInfo.Comments[0]){ \n if (ShowTags) printf(\"Multiple comments in exif header\\n\");\n break; \n }\n\n for (a=ByteCount;;){\n                    a--;\n if ((ValuePtr)[a] == ' '){\n (ValuePtr)[a] = '\\0';\n }else{\n break;\n }\n if (a == 0) break;\n }\n\n {\n int msiz = ExifLength - (ValuePtr-OffsetBase);\n if (msiz > ByteCount) msiz = ByteCount;\n if (msiz > MAX_COMMENT_SIZE - 1) msiz = MAX_COMMENT_SIZE - 1;\n if (msiz > 5 && memcmp(ValuePtr, \"ASCII\", 5) == 0) {\n for (a = 5; a < 10 && a < msiz; a++) {\n int c = (ValuePtr)[a];\n if (c != '\\0' && c != ' ') {\n                                strncpy(ImageInfo.Comments,\n (char *)ValuePtr + a, msiz - a);\n break;\n }\n }\n } else {\n                        strncpy(ImageInfo.Comments, (char *)ValuePtr, msiz);\n }\n }\n break;\n\n case TAG_FNUMBER:\n ImageInfo.ApertureFNumber = (float)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_APERTURE:\n case TAG_MAXAPERTURE:\n if (ImageInfo.ApertureFNumber == 0){\n ImageInfo.ApertureFNumber\n = (float)exp(ConvertAnyFormat(ValuePtr, Format)*log(2)*0.5);\n }\n break;\n\n case TAG_FOCALLENGTH:\n ImageInfo.FocalLength.num = Get32u(ValuePtr);\n ImageInfo.FocalLength.denom = Get32u(4+(char *)ValuePtr);\n break;\n\n case TAG_SUBJECT_DISTANCE:\n ImageInfo.Distance = (float)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_EXPOSURETIME:\n ImageInfo.ExposureTime = (float)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_SHUTTERSPEED:\n if (ImageInfo.ExposureTime == 0){\n ImageInfo.ExposureTime\n = (float)(1/exp(ConvertAnyFormat(ValuePtr, Format)*log(2)));\n }\n break;\n\n\n case TAG_FLASH:\n ImageInfo.FlashUsed=(int)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_ORIENTATION:\n if (NumOrientations >= 2){\n ErrNonfatal(\"More than two orientation tags!\",0,0);\n break;\n }\n OrientationPtr[NumOrientations] = ValuePtr;\n OrientationNumFormat[NumOrientations] = Format;\n if (NumOrientations == 0){\n ImageInfo.Orientation = (int)ConvertAnyFormat(ValuePtr, Format);\n }\n if (ImageInfo.Orientation < 0 || ImageInfo.Orientation > 8){\n ErrNonfatal(\"Undefined rotation value %d\", ImageInfo.Orientation, 0);\n ImageInfo.Orientation = 0;\n }\n NumOrientations += 1;\n break;\n\n case TAG_EXIF_IMAGELENGTH:\n case TAG_EXIF_IMAGEWIDTH:\n                a = (int)ConvertAnyFormat(ValuePtr, Format);\n if (ExifImageWidth < a) ExifImageWidth = a;\n break;\n\n case TAG_FOCAL_PLANE_XRES:\n FocalplaneXRes = ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_FOCAL_PLANE_UNITS:\n switch((int)ConvertAnyFormat(ValuePtr, Format)){\n case 1: FocalplaneUnits = 25.4; break; \n case 2:\n FocalplaneUnits = 25.4;\n break;\n\n case 3: FocalplaneUnits = 10; break; \n case 4: FocalplaneUnits = 1; break; \n case 5: FocalplaneUnits = .001; break; \n }\n break;\n\n case TAG_EXPOSURE_BIAS:\n ImageInfo.ExposureBias = (float)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_WHITEBALANCE:\n ImageInfo.Whitebalance = (int)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_LIGHT_SOURCE:\n ImageInfo.LightSource = (int)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_METERING_MODE:\n ImageInfo.MeteringMode = (int)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_EXPOSURE_PROGRAM:\n ImageInfo.ExposureProgram = (int)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_EXPOSURE_INDEX:\n if (ImageInfo.ISOequivalent == 0){\n ImageInfo.ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n }\n break;\n\n case TAG_EXPOSURE_MODE:\n ImageInfo.ExposureMode = (int)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_ISO_EQUIVALENT:\n ImageInfo.ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_DIGITALZOOMRATIO:\n ImageInfo.DigitalZoomRatio = (float)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_THUMBNAIL_OFFSET:\n ThumbnailOffset = (unsigned)ConvertAnyFormat(ValuePtr, Format);\n DirWithThumbnailPtrs = DirStart;\n break;\n\n case TAG_THUMBNAIL_LENGTH:\n ThumbnailSize = (unsigned)ConvertAnyFormat(ValuePtr, Format);\n ImageInfo.ThumbnailSizeOffset = ValuePtr-OffsetBase;\n break;\n\n case TAG_EXIF_OFFSET:\n if (ShowTags) printf(\"%s    Exif Dir:\",IndentString);\n\n case TAG_INTEROP_OFFSET:\n if (Tag == TAG_INTEROP_OFFSET && ShowTags) printf(\"%s    Interop Dir:\",IndentString);\n {\n unsigned char * SubdirStart;\n SubdirStart = OffsetBase + Get32u(ValuePtr);\n if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength){\n ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);\n }else{\n ProcessExifDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n }\n continue;\n }\n break;\n\n case TAG_GPSINFO:\n if (ShowTags) printf(\"%s    GPS info dir:\",IndentString);\n {\n unsigned char * SubdirStart;\n SubdirStart = OffsetBase + Get32u(ValuePtr);\n if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength){\n ErrNonfatal(\"Illegal GPS directory link\",0,0);\n }else{\n ProcessGpsInfo(SubdirStart, ByteCount, OffsetBase, ExifLength);\n }\n continue;\n }\n break;\n\n case TAG_FOCALLENGTH_35MM:\n ImageInfo.FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(ValuePtr, Format);\n break;\n\n case TAG_DISTANCE_RANGE:\n ImageInfo.DistanceRange = (int)ConvertAnyFormat(ValuePtr, Format);\n break;\n }\n }\n\n\n {\n unsigned char * SubdirStart;\n unsigned Offset;\n\n if (DIR_ENTRY_ADDR(DirStart, NumDirEntries) + 4 <= OffsetBase+ExifLength){\n            printf(\"DirStart %p offset from dirstart %d\", DirStart, 2+12*NumDirEntries);\n Offset = Get32u(DirStart+2+12*NumDirEntries);\n if (Offset){\n SubdirStart = OffsetBase + Offset;\n if (SubdirStart > OffsetBase+ExifLength || SubdirStart < OffsetBase){\n                    printf(\"SubdirStart %p OffsetBase %p ExifLength %d Offset %d\",\n SubdirStart, OffsetBase, ExifLength, Offset);\n if (SubdirStart > OffsetBase && SubdirStart < OffsetBase+ExifLength+20){\n if (ShowTags) printf(\"Thumbnail removed with Jhead 1.3 or earlier\\n\");\n }else{\n ErrNonfatal(\"Illegal subdirectory link\",0,0);\n }\n }else{\n if (SubdirStart <= OffsetBase+ExifLength){\n if (ShowTags) printf(\"%s    Continued directory \",IndentString);\n ProcessExifDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n }\n }\n if (Offset > ImageInfo.LargestExifOffset){\n ImageInfo.LargestExifOffset = Offset;\n }\n }\n }else{\n }\n }\n\n if (ThumbnailOffset){\n ImageInfo.ThumbnailAtEnd = FALSE;\n\n if (DumpExifMap){\n            printf(\"Map: %05d-%05d: Thumbnail\\n\",ThumbnailOffset, ThumbnailOffset+ThumbnailSize);\n }\n\n if (ThumbnailOffset <= ExifLength){\n if (ThumbnailSize > ExifLength-ThumbnailOffset){\n ThumbnailSize = ExifLength-ThumbnailOffset;\n if (ShowTags) printf(\"Thumbnail incorrectly placed in header\\n\");\n\n }\n ImageInfo.ThumbnailOffset = ThumbnailOffset;\n ImageInfo.ThumbnailSize = ThumbnailSize;\n\n if (ShowTags){\n                printf(\"Thumbnail size: %d bytes\\n\",ThumbnailSize);\n }\n }\n }\n    printf(\"returning from ProcessExifDir\");\n}\n", "target": 1, "flaw_line_index": "76"}
{"idx": 8823, "func": "void vrend_bind_shader(struct vrend_context *ctx,\n                       uint32_t handle, uint32_t type)\n{\n   struct vrend_shader_selector *sel;\n\n   if (type > PIPE_SHADER_GEOMETRY)\n      return;\n\n   if (handle == 0) {\n      ctx->sub->shader_dirty = true;\n      vrend_shader_state_reference(&ctx->sub->shaders[type], NULL);\n      return;\n   }\n\n   sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);\n   if (!sel)\n      return;\n\n   if (sel->type != type)\n      return;\n\n   if (ctx->sub->shaders[sel->type] != sel)\n      ctx->sub->shader_dirty = true;\n   vrend_shader_state_reference(&ctx->sub->shaders[sel->type], sel);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187591, "func": "static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr)\n{\n    mainprog_info  *mainprog_ptr;\n int  color_type, bit_depth;\n    png_uint_32 width, height;\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n double  gamma;\n#else\n    png_fixed_point gamma;\n#endif\n\n\n\n\n\n    mainprog_ptr = png_get_progressive_ptr(png_ptr);\n\n if (mainprog_ptr == NULL) { \n        fprintf(stderr,\n \"readpng2 error:  main struct not recoverable in info_callback.\\n\");\n        fflush(stderr);\n return;\n }\n\n\n\n    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\n       NULL, NULL, NULL);\n    mainprog_ptr->width = (ulg)width;\n    mainprog_ptr->height = (ulg)height;\n\n\n\n \n    if (mainprog_ptr->need_bgcolor &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))\n     {\n         png_color_16p pBackground;\n \n        png_get_bKGD(png_ptr, info_ptr, &pBackground);\n \n        if (bit_depth == 16) {\n            mainprog_ptr->bg_red   = pBackground->red   >> 8;\n            mainprog_ptr->bg_green = pBackground->green >> 8;\n            mainprog_ptr->bg_blue  = pBackground->blue  >> 8;\n        } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {\n            if (bit_depth == 1)\n                mainprog_ptr->bg_red = mainprog_ptr->bg_green =\n                  mainprog_ptr->bg_blue = pBackground->gray? 255 : 0;\n            else if (bit_depth == 2)\n                mainprog_ptr->bg_red = mainprog_ptr->bg_green =\n                  mainprog_ptr->bg_blue = (255/3) * pBackground->gray;\n            else \n                mainprog_ptr->bg_red = mainprog_ptr->bg_green =\n                  mainprog_ptr->bg_blue = (255/15) * pBackground->gray;\n        } else {\n            mainprog_ptr->bg_red   = (uch)pBackground->red;\n            mainprog_ptr->bg_green = (uch)pBackground->green;\n            mainprog_ptr->bg_blue  = (uch)pBackground->blue;\n         }\n     }\n \n\n\n if (color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_expand(png_ptr);\n if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\n        png_set_expand(png_ptr);\n if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\n        png_set_expand(png_ptr);\n#ifdef PNG_READ_16_TO_8_SUPPORTED\n if (bit_depth == 16)\n#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n        png_set_scale_16(png_ptr);\n#  else\n        png_set_strip_16(png_ptr);\n#  endif\n#endif\n if (color_type == PNG_COLOR_TYPE_GRAY ||\n        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        png_set_gray_to_rgb(png_ptr);\n\n\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n if (png_get_gAMA(png_ptr, info_ptr, &gamma))\n        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);\n else\n        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);\n#else\n if (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma))\n        png_set_gamma_fixed(png_ptr,\n (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma);\n else\n        png_set_gamma_fixed(png_ptr,\n (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455);\n#endif\n\n\n    mainprog_ptr->passes = png_set_interlace_handling(png_ptr);\n\n\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    mainprog_ptr->rowbytes = (int)png_get_rowbytes(png_ptr, info_ptr);\n    mainprog_ptr->channels = png_get_channels(png_ptr, info_ptr);\n\n\n\n (*mainprog_ptr->mainprog_init)();\n\n\n\n return;\n}\n", "target": 1, "flaw_line_index": "35,36,40,41,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59"}
{"idx": 8710, "func": "url_escape_dir (const char *dir)\n{\n  char *newdir = url_escape_1 (dir, urlchr_unsafe | urlchr_reserved, 1);\n  if (newdir == dir)\n    return (char *)dir;\n\n  unescape_single_char (newdir, '/');\n  return newdir;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187817, "func": "OMX_ERRORTYPE  omx_venc::set_config(OMX_IN OMX_HANDLETYPE      hComp,\n        OMX_IN OMX_INDEXTYPE configIndex,\n        OMX_IN OMX_PTR        configData)\n{\n (void)hComp;\n if (configData == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: param is null\");\n return OMX_ErrorBadParameter;\n }\n\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"ERROR: config called in Invalid state\");\n return OMX_ErrorIncorrectStateOperation;\n }\n\n\n     switch ((int)configIndex) {\n         case OMX_IndexConfigVideoBitrate:\n             {\n                 OMX_VIDEO_CONFIG_BITRATETYPE* pParam =\n                     reinterpret_cast<OMX_VIDEO_CONFIG_BITRATETYPE*>(configData);\n                 DEBUG_PRINT_HIGH(\"set_config(): OMX_IndexConfigVideoBitrate (%u)\", (unsigned int)pParam->nEncodeBitrate);\n\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n if (handle->venc_set_config(configData, OMX_IndexConfigVideoBitrate) != true) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setting OMX_IndexConfigVideoBitrate failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n\n                    m_sConfigBitrate.nEncodeBitrate = pParam->nEncodeBitrate;\n                    m_sParamBitrate.nTargetBitrate = pParam->nEncodeBitrate;\n                    m_sOutPortDef.format.video.nBitrate = pParam->nEncodeBitrate;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Unsupported port index: %u\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n break;\n\n             }\n         case OMX_IndexConfigVideoFramerate:\n             {\n                 OMX_CONFIG_FRAMERATETYPE* pParam =\n                     reinterpret_cast<OMX_CONFIG_FRAMERATETYPE*>(configData);\n                 DEBUG_PRINT_HIGH(\"set_config(): OMX_IndexConfigVideoFramerate (0x%x)\", (unsigned int)pParam->xEncodeFramerate);\n\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n if (handle->venc_set_config(configData, OMX_IndexConfigVideoFramerate) != true) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setting OMX_IndexConfigVideoFramerate failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n\n                    m_sConfigFramerate.xEncodeFramerate = pParam->xEncodeFramerate;\n                    m_sOutPortDef.format.video.xFramerate = pParam->xEncodeFramerate;\n                    m_sOutPortFormat.xFramerate = pParam->xEncodeFramerate;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Unsupported port index: %u\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n\n break;\n\n             }\n         case QOMX_IndexConfigVideoIntraperiod:\n             {\n                 QOMX_VIDEO_INTRAPERIODTYPE* pParam =\n                     reinterpret_cast<QOMX_VIDEO_INTRAPERIODTYPE*>(configData);\n \n                DEBUG_PRINT_HIGH(\"set_config(): QOMX_IndexConfigVideoIntraperiod\");\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n#ifdef MAX_RES_720P\n if (pParam->nBFrames > 0) {\n                        DEBUG_PRINT_ERROR(\"B frames not supported\");\n return OMX_ErrorUnsupportedSetting;\n }\n#endif\n                    DEBUG_PRINT_HIGH(\"Old: P/B frames = %u/%u, New: P/B frames = %u/%u\",\n (unsigned int)m_sIntraperiod.nPFrames, (unsigned int)m_sIntraperiod.nBFrames,\n (unsigned int)pParam->nPFrames, (unsigned int)pParam->nBFrames);\n if (m_sIntraperiod.nBFrames != pParam->nBFrames) {\n if(hier_b_enabled && m_state == OMX_StateLoaded) {\n                            DEBUG_PRINT_INFO(\"B-frames setting is supported if HierB is enabled\");\n }\n else {\n                        DEBUG_PRINT_HIGH(\"Dynamically changing B-frames not supported\");\n return OMX_ErrorUnsupportedSetting;\n }\n }\n if (handle->venc_set_config(configData, (OMX_INDEXTYPE) QOMX_IndexConfigVideoIntraperiod) != true) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setting QOMX_IndexConfigVideoIntraperiod failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                    m_sIntraperiod.nPFrames = pParam->nPFrames;\n                    m_sIntraperiod.nBFrames = pParam->nBFrames;\n                    m_sIntraperiod.nIDRPeriod = pParam->nIDRPeriod;\n\n if (m_sOutPortFormat.eCompressionFormat == OMX_VIDEO_CodingMPEG4) {\n                        m_sParamMPEG4.nPFrames = pParam->nPFrames;\n if (m_sParamMPEG4.eProfile != OMX_VIDEO_MPEG4ProfileSimple)\n                            m_sParamMPEG4.nBFrames = pParam->nBFrames;\n else\n                            m_sParamMPEG4.nBFrames = 0;\n } else if (m_sOutPortFormat.eCompressionFormat == OMX_VIDEO_CodingH263) {\n                        m_sParamH263.nPFrames = pParam->nPFrames;\n } else {\n                        m_sParamAVC.nPFrames = pParam->nPFrames;\n if ((m_sParamAVC.eProfile != OMX_VIDEO_AVCProfileBaseline) &&\n (m_sParamAVC.eProfile != (OMX_VIDEO_AVCPROFILETYPE) QOMX_VIDEO_AVCProfileConstrainedBaseline))\n                            m_sParamAVC.nBFrames = pParam->nBFrames;\n else\n                            m_sParamAVC.nBFrames = 0;\n }\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: (QOMX_IndexConfigVideoIntraperiod) Unsupported port index: %u\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n\n break;\n }\n\n \n         case OMX_IndexConfigVideoIntraVOPRefresh:\n             {\n                 OMX_CONFIG_INTRAREFRESHVOPTYPE* pParam =\n                     reinterpret_cast<OMX_CONFIG_INTRAREFRESHVOPTYPE*>(configData);\n \n                DEBUG_PRINT_HIGH(\"set_config(): OMX_IndexConfigVideoIntraVOPRefresh\");\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n if (handle->venc_set_config(configData,\n                                OMX_IndexConfigVideoIntraVOPRefresh) != true) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setting OMX_IndexConfigVideoIntraVOPRefresh failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n\n                    m_sConfigIntraRefreshVOP.IntraRefreshVOP = pParam->IntraRefreshVOP;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Unsupported port index: %u\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n\n break;\n\n             }\n         case OMX_IndexConfigCommonRotate:\n             {\n                 OMX_CONFIG_ROTATIONTYPE *pParam =\n                     reinterpret_cast<OMX_CONFIG_ROTATIONTYPE*>(configData);\n                 OMX_S32 nRotation;\n\n if (pParam->nPortIndex != PORT_INDEX_OUT) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Unsupported port index: %u\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n if ( pParam->nRotation == 0 ||\n                        pParam->nRotation == 90 ||\n                        pParam->nRotation == 180 ||\n                        pParam->nRotation == 270 ) {\n                    DEBUG_PRINT_HIGH(\"set_config: Rotation Angle %u\", (unsigned int)pParam->nRotation);\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: un supported Rotation %u\", (unsigned int)pParam->nRotation);\n return OMX_ErrorUnsupportedSetting;\n }\n                nRotation = pParam->nRotation - m_sConfigFrameRotation.nRotation;\n if (nRotation < 0)\n                    nRotation = -nRotation;\n if (nRotation == 90 || nRotation == 270) {\n                    DEBUG_PRINT_HIGH(\"set_config: updating device Dims\");\n if (handle->venc_set_config(configData,\n                                OMX_IndexConfigCommonRotate) != true) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Set OMX_IndexConfigCommonRotate failed\");\n return OMX_ErrorUnsupportedSetting;\n } else {\n                        OMX_U32 nFrameWidth;\n                        OMX_U32 nFrameHeight;\n\n                        DEBUG_PRINT_HIGH(\"set_config: updating port Dims\");\n\n                        nFrameWidth = m_sOutPortDef.format.video.nFrameWidth;\n                        nFrameHeight = m_sOutPortDef.format.video.nFrameHeight;\n                        m_sOutPortDef.format.video.nFrameWidth  = nFrameHeight;\n                        m_sOutPortDef.format.video.nFrameHeight = nFrameWidth;\n                        m_sConfigFrameRotation.nRotation = pParam->nRotation;\n }\n } else {\n                    m_sConfigFrameRotation.nRotation = pParam->nRotation;\n }\n break;\n }\n case OMX_QcomIndexConfigVideoFramePackingArrangement:\n\n             {\n                 DEBUG_PRINT_HIGH(\"set_config(): OMX_QcomIndexConfigVideoFramePackingArrangement\");\n                 if (m_sOutPortFormat.eCompressionFormat == OMX_VIDEO_CodingAVC) {\n                     OMX_QCOM_FRAME_PACK_ARRANGEMENT *configFmt =\n                         (OMX_QCOM_FRAME_PACK_ARRANGEMENT *) configData;\n                     extra_data_handle.set_frame_pack_data(configFmt);\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: FramePackingData not supported for non AVC compression\");\n }\n break;\n\n             }\n         case QOMX_IndexConfigVideoLTRPeriod:\n             {\n                 QOMX_VIDEO_CONFIG_LTRPERIOD_TYPE* pParam = (QOMX_VIDEO_CONFIG_LTRPERIOD_TYPE*)configData;\n                 if (!handle->venc_set_config(configData, (OMX_INDEXTYPE)QOMX_IndexConfigVideoLTRPeriod)) {\n                     DEBUG_PRINT_ERROR(\"ERROR: Setting LTR period failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sConfigLTRPeriod, pParam, sizeof(m_sConfigLTRPeriod));\n break;\n }\n\n \n        case OMX_IndexConfigVideoVp8ReferenceFrame:\n            {\n                OMX_VIDEO_VP8REFERENCEFRAMETYPE* pParam = (OMX_VIDEO_VP8REFERENCEFRAMETYPE*) configData;\n                if (!handle->venc_set_config(pParam, (OMX_INDEXTYPE) OMX_IndexConfigVideoVp8ReferenceFrame)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting VP8 reference frame\");\n return OMX_ErrorUnsupportedSetting;\n }\n               memcpy(&m_sConfigVp8ReferenceFrame, pParam, sizeof(m_sConfigVp8ReferenceFrame));\n break;\n }\n\n \n         case QOMX_IndexConfigVideoLTRUse:\n             {\n                 QOMX_VIDEO_CONFIG_LTRUSE_TYPE* pParam = (QOMX_VIDEO_CONFIG_LTRUSE_TYPE*)configData;\n                 if (!handle->venc_set_config(pParam, (OMX_INDEXTYPE)QOMX_IndexConfigVideoLTRUse)) {\n                     DEBUG_PRINT_ERROR(\"ERROR: Setting LTR use failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sConfigLTRUse, pParam, sizeof(m_sConfigLTRUse));\n break;\n\n             }\n         case QOMX_IndexConfigVideoLTRMark:\n             {\n                 QOMX_VIDEO_CONFIG_LTRMARK_TYPE* pParam = (QOMX_VIDEO_CONFIG_LTRMARK_TYPE*)configData;\n                 if (!handle->venc_set_config(pParam, (OMX_INDEXTYPE)QOMX_IndexConfigVideoLTRMark)) {\n                     DEBUG_PRINT_ERROR(\"ERROR: Setting LTR mark failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n\n             }\n         case OMX_IndexConfigVideoAVCIntraPeriod:\n             {\n                 OMX_VIDEO_CONFIG_AVCINTRAPERIOD *pParam = (OMX_VIDEO_CONFIG_AVCINTRAPERIOD*) configData;\n                 DEBUG_PRINT_LOW(\"set_config: OMX_IndexConfigVideoAVCIntraPeriod\");\n                 if (!handle->venc_set_config(pParam, (OMX_INDEXTYPE)OMX_IndexConfigVideoAVCIntraPeriod)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting OMX_IndexConfigVideoAVCIntraPeriod failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sConfigAVCIDRPeriod, pParam, sizeof(m_sConfigAVCIDRPeriod));\n break;\n\n             }\n         case OMX_IndexConfigCommonDeinterlace:\n             {\n                 OMX_VIDEO_CONFIG_DEINTERLACE *pParam = (OMX_VIDEO_CONFIG_DEINTERLACE*) configData;\n                 DEBUG_PRINT_LOW(\"set_config: OMX_IndexConfigCommonDeinterlace\");\n                 if (!handle->venc_set_config(pParam, (OMX_INDEXTYPE)OMX_IndexConfigCommonDeinterlace)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting OMX_IndexConfigCommonDeinterlace failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sConfigDeinterlace, pParam, sizeof(m_sConfigDeinterlace));\n break;\n\n             }\n         case OMX_QcomIndexConfigVideoVencPerfMode:\n             {\n                 QOMX_EXTNINDEX_VIDEO_PERFMODE* pParam = (QOMX_EXTNINDEX_VIDEO_PERFMODE*)configData;\n                 if (!handle->venc_set_config(pParam, (OMX_INDEXTYPE)OMX_QcomIndexConfigVideoVencPerfMode)) {\n                     DEBUG_PRINT_ERROR(\"ERROR: Setting OMX_QcomIndexConfigVideoVencPerfMode failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n\n             }\n         case OMX_IndexConfigPriority:\n             {\n                 if (!handle->venc_set_config(configData, (OMX_INDEXTYPE)OMX_IndexConfigPriority)) {\n                     DEBUG_PRINT_ERROR(\"Failed to set OMX_IndexConfigPriority\");\n                     return OMX_ErrorUnsupportedSetting;\n }\n break;\n\n             }\n         case OMX_IndexConfigOperatingRate:\n             {\n                 if (!handle->venc_set_config(configData, (OMX_INDEXTYPE)OMX_IndexConfigOperatingRate)) {\n                     DEBUG_PRINT_ERROR(\"Failed to set OMX_IndexConfigOperatingRate\");\n                     return handle->hw_overload ? OMX_ErrorInsufficientResources :\n                            OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n default:\n            DEBUG_PRINT_ERROR(\"ERROR: unsupported index %d\", (int) configIndex);\n break;\n }\n\n return OMX_ErrorNone;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8642, "func": "size_t mptsas_config_ioc_1(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_IOC, 0x03,\n                              \"*l*l*b*b*b*b\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8795, "func": "static inline GLenum convert_mag_filter(unsigned int filter)\n{\n   if (filter == PIPE_TEX_FILTER_NEAREST)\n      return GL_NEAREST;\n   return GL_LINEAR;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8338, "func": "static USBEndpoint *xhci_epid_to_usbep(XHCIState *xhci,\n                                       unsigned int slotid, unsigned int epid)\n{\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    if (!xhci->slots[slotid - 1].uport) {\n        return NULL;\n    }\n\n    return usb_ep_get(xhci->slots[slotid - 1].uport->dev,\n                      (epid & 1) ? USB_TOKEN_IN : USB_TOKEN_OUT, epid >> 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187654, "func": " image_transform_png_set_expand_gray_1_2_4_to_8_set(\n    PNG_CONST image_transform *this, transform_display *that, png_structp pp,\n     png_infop pi)\n {\n    png_set_expand_gray_1_2_4_to_8(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 188004, "func": " static int _make_words(char *l,long n,ogg_uint32_t *r,long quantvals,\n\t\t       codebook *b, oggpack_buffer *opb,int maptype){\n   long i,j,count=0;\n   long top=0;\n   ogg_uint32_t marker[MARKER_SIZE];\n\n if (n<1)\n return 1;\n\n if(n<2){\n    r[0]=0x80000000;\n }else{\n    memset(marker,0,sizeof(marker));\n\n for(i=0;i<n;i++){\n long length=l[i];\n if(length){\n if (length < 0 || length >= MARKER_SIZE) {\n\n           ALOGE(\"b/23881715\");\n           return 1;\n         }\n\togg_uint32_t entry=marker[length];\n\tlong chase=0;\n\tif(count && !entry)return -1; \n \n\tfor(j=0;j<length-1;j++){\n\t  int bit=(entry>>(length-j-1))&1;\n\t  if(chase>=top){\n\t    if (chase < 0 || chase >= n) return 1;\n\t    top++;\n\t    r[chase*2]=top;\n\t    r[chase*2+1]=0;\n\t  }else\n\t    if (chase < 0 || chase >= n || chase*2+bit > n*2+1) return 1;\n\t    if(!r[chase*2+bit])\n\t      r[chase*2+bit]=top;\n\t  chase=r[chase*2+bit];\n\t  if (chase < 0 || chase >= n) return 1;\n\t}\n\t{\n\t  int bit=(entry>>(length-j-1))&1;\n\t  if(chase>=top){\n\t    top++;\n\t    r[chase*2+1]=0;\n\t  }\n\t  r[chase*2+bit]= decpack(i,count++,quantvals,b,opb,maptype) |\n\t    0x80000000;\n\t}\n \n\tfor(j=length;j>0;j--){\n\t  if(marker[j]&1){\n\t    marker[j]=marker[j-1]<<1;\n\t    break;\n\t  }\n\t  marker[j]++;\n\t}\n \n\tfor(j=length+1;j<MARKER_SIZE;j++)\n\t  if((marker[j]>>1) == entry){\n\t    entry=marker[j];\n\t    marker[j]=marker[j-1]<<1;\n\t  }else\n\t    break;\n       }\n     }\n   }\n\n if(b->used_entries != 1){\n for(i=1;i<MARKER_SIZE;i++)\n if(marker[i] & (0xffffffffUL>>(32-i))){\n return 1;\n }\n }\n\n\n return 0;\n\n }\n", "target": 1, "flaw_line_index": "2,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,50,51,52,53,54,55,56,57,58,58,59,60,61,62,63,64"}
{"idx": 8981, "func": "static void vmxnet3_clear_interrupt(VMXNET3State *s, int int_idx)\n{\n    s->interrupt_states[int_idx].is_pending = false;\n    if (s->auto_int_masking) {\n        s->interrupt_states[int_idx].is_masked = true;\n    }\n    vmxnet3_update_interrupt_line_state(s, int_idx);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187821, "func": "sp<MediaSource> OMXCodec::Create(\n const sp<IOMX> &omx,\n const sp<MetaData> &meta, bool createEncoder,\n const sp<MediaSource> &source,\n const char *matchComponentName,\n uint32_t flags,\n const sp<ANativeWindow> &nativeWindow) {\n int32_t requiresSecureBuffers;\n if (source->getFormat()->findInt32(\n                kKeyRequiresSecureBuffers,\n &requiresSecureBuffers)\n && requiresSecureBuffers) {\n        flags |= kIgnoreCodecSpecificData;\n        flags |= kUseSecureInputBuffers;\n }\n\n const char *mime;\n bool success = meta->findCString(kKeyMIMEType, &mime);\n    CHECK(success);\n\n Vector<CodecNameAndQuirks> matchingCodecs;\n    findMatchingCodecs(\n            mime, createEncoder, matchComponentName, flags, &matchingCodecs);\n\n if (matchingCodecs.isEmpty()) {\n        ALOGV(\"No matching codecs! (mime: %s, createEncoder: %s, \"\n \"matchComponentName: %s, flags: 0x%x)\",\n                mime, createEncoder ? \"true\" : \"false\", matchComponentName, flags);\n return NULL;\n }\n\n    sp<OMXCodecObserver> observer = new OMXCodecObserver;\n    IOMX::node_id node = 0;\n\n for (size_t i = 0; i < matchingCodecs.size(); ++i) {\n const char *componentNameBase = matchingCodecs[i].mName.string();\n uint32_t quirks = matchingCodecs[i].mQuirks;\n const char *componentName = componentNameBase;\n\n AString tmp;\n if (flags & kUseSecureInputBuffers) {\n            tmp = componentNameBase;\n            tmp.append(\".secure\");\n\n            componentName = tmp.c_str();\n }\n\n if (createEncoder) {\n            sp<MediaSource> softwareCodec =\n InstantiateSoftwareEncoder(componentName, source, meta);\n\n if (softwareCodec != NULL) {\n                ALOGV(\"Successfully allocated software codec '%s'\", componentName);\n\n return softwareCodec;\n }\n }\n\n \n         ALOGV(\"Attempting to allocate OMX node '%s'\", componentName);\n \n        if (!createEncoder\n                && (quirks & kOutputBuffersAreUnreadable)\n                && (flags & kClientNeedsFramebuffer)) {\n            if (strncmp(componentName, \"OMX.SEC.\", 8)) {\n                ALOGW(\"Component '%s' does not give the client access to \"\n                     \"the framebuffer contents. Skipping.\",\n                     componentName);\n                continue;\n            }\n        }\n         status_t err = omx->allocateNode(componentName, observer, &node);\n         if (err == OK) {\n             ALOGV(\"Successfully allocated OMX node '%s'\", componentName);\n\n            sp<OMXCodec> codec = new OMXCodec(\n                    omx, node, quirks, flags,\n                    createEncoder, mime, componentName,\n                    source, nativeWindow);\n\n            observer->setCodec(codec);\n\n            err = codec->configureCodec(meta);\n if (err == OK) {\n return codec;\n }\n\n            ALOGV(\"Failed to configure codec '%s'\", componentName);\n }\n }\n\n return NULL;\n}\n", "target": 1, "flaw_line_index": "62,63,64,65,66,67,68,69,70,71,72,73"}
{"idx": 187794, "func": "bool SampleTable::isValid() const {\n\n     return mChunkOffsetOffset >= 0\n         && mSampleToChunkOffset >= 0\n         && mSampleSizeOffset >= 0\n        && !mTimeToSample.empty();\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8403, "func": "pvscsi_cleanup_msi(PVSCSIState *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    msi_uninit(d);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9045, "func": "static void vmxnet3_reset(VMXNET3State *s)\n{\n    VMW_CBPRN(\"Resetting vmxnet3...\");\n\n    vmxnet3_deactivate_device(s);\n    vmxnet3_reset_interrupt_states(s);\n    s->drv_shmem = 0;\n    s->tx_sop = true;\n    s->skip_current_tx_pkt = false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8339, "func": "static int xhci_epmask_to_eps_with_streams(XHCIState *xhci,\n                                           unsigned int slotid,\n                                           uint32_t epmask,\n                                           XHCIEPContext **epctxs,\n                                           USBEndpoint **eps)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    USBEndpoint *ep;\n    int i, j;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    slot = &xhci->slots[slotid - 1];\n\n    for (i = 2, j = 0; i <= 31; i++) {\n        if (!(epmask & (1u << i))) {\n            continue;\n        }\n\n        epctx = slot->eps[i - 1];\n        ep = xhci_epid_to_usbep(xhci, slotid, i);\n        if (!epctx || !epctx->nr_pstreams || !ep) {\n            continue;\n        }\n\n        if (epctxs) {\n            epctxs[j] = epctx;\n        }\n        eps[j++] = ep;\n    }\n    return j;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8551, "func": "static void ssh2_pkt_send_with_padding(Ssh ssh, struct Packet *pkt,\n\t\t\t\t       int padsize)\n{\n#if 0\n    if (0) {\n\tpkt->forcepad = padsize;\n\tssh2_pkt_send(ssh, pkt);\n    } else\n#endif\n    {\n\tssh2_pkt_defer(ssh, pkt);\n\n\tif (ssh->cscipher &&\n\t    !(ssh->remote_bugs & BUG_CHOKES_ON_SSH2_IGNORE)) {\n\t    int stringlen, i;\n\n\t    stringlen = (256 - ssh->deferred_len);\n\t    stringlen += ssh->cscipher->blksize - 1;\n\t    stringlen -= (stringlen % ssh->cscipher->blksize);\n\t    if (ssh->cscomp) {\n\t\tstringlen -=\n\t\t    ssh->cscomp->disable_compression(ssh->cs_comp_ctx);\n\t    }\n\t    pkt = ssh2_pkt_init(SSH2_MSG_IGNORE);\n\t    ssh2_pkt_addstring_start(pkt);\n\t    for (i = 0; i < stringlen; i++) {\n\t\tchar c = (char) random_byte();\n\t\tssh2_pkt_addstring_data(pkt, &c, 1);\n\t    }\n\t    ssh2_pkt_defer(ssh, pkt);\n\t}\n\tssh_pkt_defersend(ssh);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187613, "func": "update_display(struct display *dp)\n{\n   png_structp pp;\n   png_infop   ip;\n\n   read_png(dp, &dp->original_file, \"original read\", 0\n);\n\n   dp->original_pp = pp = dp->read_pp, dp->read_pp = NULL;\n   dp->original_ip = ip = dp->read_ip, dp->read_ip = NULL;\n\n   dp->original_rowbytes = png_get_rowbytes(pp, ip);\n if (dp->original_rowbytes == 0)\n      display_log(dp, LIBPNG_BUG, \"png_get_rowbytes returned 0\");\n\n   dp->chunks = png_get_valid(pp, ip, 0xffffffff);\n if ((dp->chunks & PNG_INFO_IDAT) == 0) \n      display_log(dp, LIBPNG_BUG, \"png_read_png did not set IDAT flag\");\n\n   dp->original_rows = png_get_rows(pp, ip);\n if (dp->original_rows == NULL)\n      display_log(dp, LIBPNG_BUG, \"png_read_png did not create row buffers\");\n\n if (!png_get_IHDR(pp, ip,\n &dp->width, &dp->height, &dp->bit_depth, &dp->color_type,\n &dp->interlace_method, &dp->compression_method, &dp->filter_method))\n      display_log(dp, LIBPNG_BUG, \"png_get_IHDR failed\");\n\n {\n      png_uint_32 chunks = dp->chunks;\n int active = 0, inactive = 0;\n int ct = dp->color_type;\n\n       int bd = dp->bit_depth;\n       unsigned int i;\n \n      for (i=0; i<TTABLE_SIZE; ++i)\n       {\n          int transform = transform_info[i].transform;\n \n          if ((transform_info[i].valid_chunks == 0 ||\n                (transform_info[i].valid_chunks & chunks) != 0) &&\n            (transform_info[i].color_mask_required & ct) == \n                transform_info[i].color_mask_required &&\n             (transform_info[i].color_mask_absent & ct) == 0 &&\n             (transform_info[i].bit_depths & bd) != 0 &&\n (transform_info[i].when & TRANSFORM_R) != 0)\n            active |= transform;\n\n else if ((transform_info[i].when & TRANSFORM_R) != 0)\n            inactive |= transform;\n }\n\n      inactive &= ~active;\n\n \n       dp->active_transforms = active;\n       dp->ignored_transforms = inactive; \n      if (active == 0)\n         display_log(dp, INTERNAL_ERROR, \"bad transform table\");\n    }\n }\n", "target": 1, "flaw_line_index": "37,43,59,60"}
{"idx": 9121, "func": "static int vrend_decode_set_sampler_views(struct vrend_decode_ctx *ctx, uint16_t length)\n{\n   int num_samps;\n   int i;\n   uint32_t shader_type, start_slot;\n\n   if (length < 2)\n      return EINVAL;\n   num_samps = length - 2;\n   shader_type = get_buf_entry(ctx, VIRGL_SET_SAMPLER_VIEWS_SHADER_TYPE);\n   start_slot = get_buf_entry(ctx, VIRGL_SET_SAMPLER_VIEWS_START_SLOT);\n\n   if (shader_type >= PIPE_SHADER_TYPES)\n      return EINVAL;\n\n   if (num_samps > PIPE_MAX_SHADER_SAMPLER_VIEWS ||\n       start_slot > (PIPE_MAX_SHADER_SAMPLER_VIEWS - num_samps))\n      return EINVAL;\n\n   for (i = 0; i < num_samps; i++) {\n      uint32_t handle = get_buf_entry(ctx, VIRGL_SET_SAMPLER_VIEWS_V0_HANDLE + i);\n      vrend_set_single_sampler_view(ctx->grctx, shader_type, i + start_slot, handle);\n   }\n   vrend_set_num_sampler_views(ctx->grctx, shader_type, start_slot, num_samps);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9225, "func": "static void virtio_queue_guest_notifier_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, guest_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_irq(vq);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187578, "func": " bool adapter_enable_disable() {\n   int error;\n \n  CALL_AND_WAIT(error = bt_interface->enable(), adapter_state_changed);\n   TASSERT(error == BT_STATUS_SUCCESS, \"Error enabling Bluetooth: %d\", error);\n   TASSERT(adapter_get_state() == BT_STATE_ON, \"Adapter did not turn on.\");\n \n  CALL_AND_WAIT(error = bt_interface->disable(), adapter_state_changed);\n  TASSERT(error == BT_STATUS_SUCCESS, \"Error disabling Bluetooth: %d\", error);\n  TASSERT(adapter_get_state() == BT_STATE_OFF, \"Adapter did not turn off.\");\n\n return true;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187670, "func": " image_transform_png_set_strip_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n return bit_depth > 8;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 187480, "func": "static sent_status_t send_data_to_app(int fd, BT_HDR *p_buf) {\n\n   if (p_buf->len == 0)\n     return SENT_ALL;\n \n  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);\n \n   if (sent == -1) {\n     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n return SENT_NONE;\n    LOG_ERROR(\"%s error writing RFCOMM data back to app: %s\", __func__, strerror(errno));\n return SENT_FAILED;\n }\n\n if (sent == 0)\n return SENT_FAILED;\n\n if (sent == p_buf->len)\n return SENT_ALL;\n\n  p_buf->offset += sent;\n  p_buf->len -= sent;\n return SENT_PARTIAL;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187403, "func": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n if (cm->alloc_mi(cm, new_mi_size))\n goto fail;\n }\n\n if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols))\n goto fail;\n }\n\n if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n 2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n sizeof(*cm->above_context));\n if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n }\n\n\n   return 0;\n \n  fail:\n   vp9_free_context_buffers(cm);\n   return 1;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9044, "func": "static void vmxnet3_register_types(void)\n{\n    VMW_CBPRN(\"vmxnet3_register_types called...\");\n    type_register_static(&vmxnet3_info);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8858, "func": "void vrend_end_query(struct vrend_context *ctx, uint32_t handle)\n{\n   struct vrend_query *q;\n   q = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_QUERY);\n   if (!q)\n      return;\n\n   if (vrend_is_timer_query(q->gltype)) {\n      if (q->gltype == GL_TIMESTAMP)\n         glQueryCounter(q->id, q->gltype);\n      else\n         glEndQuery(q->gltype);\n      return;\n   }\n\n   glEndQuery(q->gltype);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187398, "func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n    mSyncSampleOffset = data_offset;\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumSyncSamples = U32_AT(&header[4]);\n\n if (mNumSyncSamples < 2) {\n\n         ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n     }\n \n     mSyncSamples = new uint32_t[mNumSyncSamples];\n     size_t size = mNumSyncSamples * sizeof(uint32_t);\n     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)\n != (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < mNumSyncSamples; ++i) {\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187913, "func": "status_t BnDrm::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(initCheck());\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n String8 mimeType = data.readString8();\n            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(createPlugin(uuid));\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(destroyPlugin());\n return OK;\n }\n\n case OPEN_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n status_t result = openSession(sessionId);\n            writeVector(reply, sessionId);\n            reply->writeInt32(result);\n return OK;\n }\n\n case CLOSE_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(closeSession(sessionId));\n return OK;\n }\n\n case GET_KEY_REQUEST:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, initData;\n\n            readVector(data, sessionId);\n            readVector(data, initData);\n String8 mimeType = data.readString8();\n DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();\n\n KeyedVector<String8, String8> optionalParameters;\n uint32_t count = data.readInt32();\n for (size_t i = 0; i < count; ++i) {\n String8 key, value;\n                key = data.readString8();\n                value = data.readString8();\n                optionalParameters.add(key, value);\n }\n\n \n             Vector<uint8_t> request;\n             String8 defaultUrl;\n            DrmPlugin::KeyRequestType keyRequestType;\n \n             status_t result = getKeyRequest(sessionId, initData, mimeType,\n                     keyType, optionalParameters, request, defaultUrl,\n &keyRequestType);\n\n            writeVector(reply, request);\n            reply->writeString8(defaultUrl);\n            reply->writeInt32(static_cast<int32_t>(keyRequestType));\n            reply->writeInt32(result);\n return OK;\n }\n\n case PROVIDE_KEY_RESPONSE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, response, keySetId;\n            readVector(data, sessionId);\n            readVector(data, response);\n uint32_t result = provideKeyResponse(sessionId, response, keySetId);\n            writeVector(reply, keySetId);\n            reply->writeInt32(result);\n return OK;\n }\n\n case REMOVE_KEYS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> keySetId;\n            readVector(data, keySetId);\n            reply->writeInt32(removeKeys(keySetId));\n return OK;\n }\n\n case RESTORE_KEYS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keySetId;\n            readVector(data, sessionId);\n            readVector(data, keySetId);\n            reply->writeInt32(restoreKeys(sessionId, keySetId));\n return OK;\n }\n\n case QUERY_KEY_STATUS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n KeyedVector<String8, String8> infoMap;\n status_t result = queryKeyStatus(sessionId, infoMap);\n size_t count = infoMap.size();\n            reply->writeInt32(count);\n for (size_t i = 0; i < count; ++i) {\n                reply->writeString8(infoMap.keyAt(i));\n                reply->writeString8(infoMap.valueAt(i));\n }\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_PROVISION_REQUEST:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 certType = data.readString8();\n String8 certAuthority = data.readString8();\n\n Vector<uint8_t> request;\n String8 defaultUrl;\n status_t result = getProvisionRequest(certType, certAuthority,\n                                                  request, defaultUrl);\n            writeVector(reply, request);\n            reply->writeString8(defaultUrl);\n            reply->writeInt32(result);\n return OK;\n }\n\n case PROVIDE_PROVISION_RESPONSE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> response;\n Vector<uint8_t> certificate;\n Vector<uint8_t> wrappedKey;\n            readVector(data, response);\n status_t result = provideProvisionResponse(response, certificate, wrappedKey);\n            writeVector(reply, certificate);\n            writeVector(reply, wrappedKey);\n            reply->writeInt32(result);\n return OK;\n }\n\n case UNPROVISION_DEVICE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n status_t result = unprovisionDevice();\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n List<Vector<uint8_t> > secureStops;\n status_t result = getSecureStops(secureStops);\n size_t count = secureStops.size();\n            reply->writeInt32(count);\n List<Vector<uint8_t> >::iterator iter = secureStops.begin();\n while(iter != secureStops.end()) {\n size_t size = iter->size();\n                reply->writeInt32(size);\n                reply->write(iter->array(), iter->size());\n                iter++;\n }\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_SECURE_STOP:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> ssid, secureStop;\n            readVector(data, ssid);\n status_t result = getSecureStop(ssid, secureStop);\n            writeVector(reply, secureStop);\n            reply->writeInt32(result);\n return OK;\n }\n\n case RELEASE_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> ssRelease;\n            readVector(data, ssRelease);\n            reply->writeInt32(releaseSecureStops(ssRelease));\n return OK;\n }\n\n case RELEASE_ALL_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(releaseAllSecureStops());\n return OK;\n }\n\n case GET_PROPERTY_STRING:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n String8 value;\n status_t result = getPropertyString(name, value);\n            reply->writeString8(value);\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_PROPERTY_BYTE_ARRAY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n Vector<uint8_t> value;\n status_t result = getPropertyByteArray(name, value);\n            writeVector(reply, value);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SET_PROPERTY_STRING:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n String8 value = data.readString8();\n            reply->writeInt32(setPropertyString(name, value));\n return OK;\n }\n\n case SET_PROPERTY_BYTE_ARRAY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n Vector<uint8_t> value;\n            readVector(data, value);\n            reply->writeInt32(setPropertyByteArray(name, value));\n return OK;\n }\n\n case SET_CIPHER_ALGORITHM:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));\n return OK;\n }\n\n case SET_MAC_ALGORITHM:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));\n return OK;\n }\n\n case ENCRYPT:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, input, iv, output;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, input);\n            readVector(data, iv);\n uint32_t result = encrypt(sessionId, keyId, input, iv, output);\n            writeVector(reply, output);\n            reply->writeInt32(result);\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, input, iv, output;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, input);\n            readVector(data, iv);\n uint32_t result = decrypt(sessionId, keyId, input, iv, output);\n            writeVector(reply, output);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SIGN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, message, signature;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, message);\n uint32_t result = sign(sessionId, keyId, message, signature);\n            writeVector(reply, signature);\n            reply->writeInt32(result);\n return OK;\n }\n\n case VERIFY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, message, signature;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, message);\n            readVector(data, signature);\n bool match;\n uint32_t result = verify(sessionId, keyId, message, signature, match);\n            reply->writeInt32(match);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SIGN_RSA:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, message, wrappedKey, signature;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            readVector(data, message);\n            readVector(data, wrappedKey);\n uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);\n            writeVector(reply, signature);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SET_LISTENER: {\n        CHECK_INTERFACE(IDrm, data, reply);\n        sp<IDrmClient> listener =\n            interface_cast<IDrmClient>(data.readStrongBinder());\n        reply->writeInt32(setListener(listener));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "79"}
{"idx": 8940, "func": "void vrend_set_scissor_state(struct vrend_context *ctx,\n                             uint32_t start_slot,\n                             uint32_t num_scissor,\n                             struct pipe_scissor_state *ss)\n{\n   int i, idx;\n\n   if (start_slot > PIPE_MAX_VIEWPORTS ||\n       num_scissor > (PIPE_MAX_VIEWPORTS - start_slot)) {\n      vrend_report_buffer_error(ctx, 0);\n      return;\n   }\n\n   for (i = 0; i < num_scissor; i++) {\n      idx = start_slot + i;\n      ctx->sub->ss[idx] = ss[i];\n      ctx->sub->scissor_state_dirty |= (1 << idx);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9027, "func": "static void vmxnet3_pci_realize(PCIDevice *pci_dev, Error **errp)\n{\n    DeviceState *dev = DEVICE(pci_dev);\n    VMXNET3State *s = VMXNET3(pci_dev);\n    int ret;\n\n    VMW_CBPRN(\"Starting init...\");\n\n    memory_region_init_io(&s->bar0, OBJECT(s), &b0_ops, s,\n                          \"vmxnet3-b0\", VMXNET3_PT_REG_SIZE);\n    pci_register_bar(pci_dev, VMXNET3_BAR0_IDX,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->bar0);\n\n    memory_region_init_io(&s->bar1, OBJECT(s), &b1_ops, s,\n                          \"vmxnet3-b1\", VMXNET3_VD_REG_SIZE);\n    pci_register_bar(pci_dev, VMXNET3_BAR1_IDX,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->bar1);\n\n    memory_region_init(&s->msix_bar, OBJECT(s), \"vmxnet3-msix-bar\",\n                       VMXNET3_MSIX_BAR_SIZE);\n    pci_register_bar(pci_dev, VMXNET3_MSIX_BAR_IDX,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->msix_bar);\n\n    vmxnet3_reset_interrupt_states(s);\n\n    pci_dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n    ret = msi_init(pci_dev, VMXNET3_MSI_OFFSET(s), VMXNET3_MAX_NMSIX_INTRS,\n                   VMXNET3_USE_64BIT, VMXNET3_PER_VECTOR_MASK, NULL);\n    assert(!ret || ret == -ENOTSUP);\n\n    if (!vmxnet3_init_msix(s)) {\n        VMW_WRPRN(\"Failed to initialize MSI-X, configuration is inconsistent.\");\n    }\n\n    vmxnet3_net_init(s);\n\n    if (pci_is_express(pci_dev)) {\n        if (pci_bus_is_express(pci_dev->bus)) {\n            pcie_endpoint_cap_init(pci_dev, VMXNET3_EXP_EP_OFFSET);\n        }\n\n        pcie_dev_ser_num_init(pci_dev, VMXNET3_DSN_OFFSET,\n                              vmxnet3_device_serial_num(s));\n    }\n\n    register_savevm(dev, \"vmxnet3-msix\", -1, 1,\n                    vmxnet3_msix_save, vmxnet3_msix_load, s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8350, "func": "static void gmc1_motion(MpegEncContext *s,\n                        uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                        uint8_t **ref_picture)\n{\n    uint8_t *ptr;\n    int src_x, src_y, motion_x, motion_y;\n    ptrdiff_t offset, linesize, uvlinesize;\n    int emu = 0;\n\n    motion_x   = s->sprite_offset[0][0];\n    motion_y   = s->sprite_offset[0][1];\n    src_x      = s->mb_x * 16 + (motion_x >> (s->sprite_warping_accuracy + 1));\n    src_y      = s->mb_y * 16 + (motion_y >> (s->sprite_warping_accuracy + 1));\n    motion_x <<= (3 - s->sprite_warping_accuracy);\n    motion_y <<= (3 - s->sprite_warping_accuracy);\n    src_x      = av_clip(src_x, -16, s->width);\n    if (src_x == s->width)\n        motion_x = 0;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y == s->height)\n        motion_y = 0;\n\n    linesize   = s->linesize;\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + src_y * linesize + src_x;\n\n    if ((unsigned)src_x >= FFMAX(s->h_edge_pos - 17, 0) ||\n        (unsigned)src_y >= FFMAX(s->v_edge_pos - 17, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 linesize, linesize,\n                                 17, 17,\n                                 src_x, src_y,\n                                 s->h_edge_pos, s->v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n    }\n\n    if ((motion_x | motion_y) & 7) {\n        s->mdsp.gmc1(dest_y, ptr, linesize, 16,\n                     motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n        s->mdsp.gmc1(dest_y + 8, ptr + 8, linesize, 16,\n                     motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n    } else {\n        int dxy;\n\n        dxy = ((motion_x >> 3) & 1) | ((motion_y >> 2) & 2);\n        if (s->no_rounding) {\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);\n        } else {\n            s->hdsp.put_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);\n        }\n    }\n\n    if (CONFIG_GRAY && s->avctx->flags & AV_CODEC_FLAG_GRAY)\n        return;\n\n    motion_x   = s->sprite_offset[1][0];\n    motion_y   = s->sprite_offset[1][1];\n    src_x      = s->mb_x * 8 + (motion_x >> (s->sprite_warping_accuracy + 1));\n    src_y      = s->mb_y * 8 + (motion_y >> (s->sprite_warping_accuracy + 1));\n    motion_x <<= (3 - s->sprite_warping_accuracy);\n    motion_y <<= (3 - s->sprite_warping_accuracy);\n    src_x      = av_clip(src_x, -8, s->width >> 1);\n    if (src_x == s->width >> 1)\n        motion_x = 0;\n    src_y = av_clip(src_y, -8, s->height >> 1);\n    if (src_y == s->height >> 1)\n        motion_y = 0;\n\n    offset = (src_y * uvlinesize) + src_x;\n    ptr    = ref_picture[1] + offset;\n    if ((unsigned)src_x >= FFMAX((s->h_edge_pos >> 1) - 9, 0) ||\n        (unsigned)src_y >= FFMAX((s->v_edge_pos >> 1) - 9, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 uvlinesize, uvlinesize,\n                                 9, 9,\n                                 src_x, src_y,\n                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n        ptr = s->sc.edge_emu_buffer;\n        emu = 1;\n    }\n    s->mdsp.gmc1(dest_cb, ptr, uvlinesize, 8,\n                 motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n\n    ptr = ref_picture[2] + offset;\n    if (emu) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 uvlinesize, uvlinesize,\n                                 9, 9,\n                                 src_x, src_y,\n                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n        ptr = s->sc.edge_emu_buffer;\n    }\n    s->mdsp.gmc1(dest_cr, ptr, uvlinesize, 8,\n                 motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9069, "func": "static void vmxnet3_update_features(VMXNET3State *s)\n{\n    uint32_t guest_features;\n    int rxcso_supported;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    guest_features = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem,\n                                               devRead.misc.uptFeatures);\n\n    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);\n    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);\n    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);\n\n    VMW_CFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\",\n              s->lro_supported, rxcso_supported,\n              s->rx_vlan_stripping);\n    if (s->peer_has_vhdr) {\n        qemu_set_offload(qemu_get_queue(s->nic)->peer,\n                         rxcso_supported,\n                         s->lro_supported,\n                         s->lro_supported,\n                         0,\n                         0);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8857, "func": "static void vrend_draw_bind_vertex_legacy(struct vrend_context *ctx,\n                                          struct vrend_vertex_element_array *va)\n{\n   uint32_t num_enable;\n   uint32_t enable_bitmask;\n   uint32_t disable_bitmask;\n   int i;\n\n   num_enable = va->count;\n   enable_bitmask = 0;\n   disable_bitmask = ~((1ull << num_enable) - 1);\n   for (i = 0; i < va->count; i++) {\n      struct vrend_vertex_element *ve = &va->elements[i];\n      int vbo_index = ve->base.vertex_buffer_index;\n      struct vrend_resource *res;\n      GLint loc;\n\n      if (i >= ctx->sub->prog->ss[PIPE_SHADER_VERTEX]->sel->sinfo.num_inputs) {\n         num_enable = ctx->sub->prog->ss[PIPE_SHADER_VERTEX]->sel->sinfo.num_inputs;\n         break;\n      }\n      res = (struct vrend_resource *)ctx->sub->vbo[vbo_index].buffer;\n\n      if (!res) {\n         fprintf(stderr,\"cannot find vbo buf %d %d %d\\n\", i, va->count, ctx->sub->prog->ss[PIPE_SHADER_VERTEX]->sel->sinfo.num_inputs);\n         continue;\n      }\n\n      if (vrend_state.use_explicit_locations || vrend_state.have_vertex_attrib_binding) {\n         loc = i;\n      } else {\n         if (ctx->sub->prog->attrib_locs) {\n            loc = ctx->sub->prog->attrib_locs[i];\n         } else loc = -1;\n\n         if (loc == -1) {\n            fprintf(stderr,\"%s: cannot find loc %d %d %d\\n\", ctx->debug_name, i, va->count, ctx->sub->prog->ss[PIPE_SHADER_VERTEX]->sel->sinfo.num_inputs);\n            num_enable--;\n            if (i == 0) {\n               fprintf(stderr,\"%s: shader probably didn't compile - skipping rendering\\n\", ctx->debug_name);\n               return;\n            }\n            continue;\n         }\n      }\n\n      if (ve->type == GL_FALSE) {\n         fprintf(stderr,\"failed to translate vertex type - skipping render\\n\");\n         return;\n      }\n\n      glBindBuffer(GL_ARRAY_BUFFER, res->id);\n\n      if (ctx->sub->vbo[vbo_index].stride == 0) {\n         void *data;\n         data = glMapBufferRange(GL_ARRAY_BUFFER, ctx->sub->vbo[vbo_index].buffer_offset, ve->nr_chan * sizeof(GLfloat), GL_MAP_READ_BIT);\n\n         switch (ve->nr_chan) {\n         case 1:\n            glVertexAttrib1fv(loc, data);\n            break;\n         case 2:\n            glVertexAttrib2fv(loc, data);\n            break;\n         case 3:\n            glVertexAttrib3fv(loc, data);\n            break;\n         case 4:\n         default:\n            glVertexAttrib4fv(loc, data);\n            break;\n         }\n         glUnmapBuffer(GL_ARRAY_BUFFER);\n         disable_bitmask |= (1 << loc);\n      } else {\n         enable_bitmask |= (1 << loc);\n         if (util_format_is_pure_integer(ve->base.src_format)) {\n            glVertexAttribIPointer(loc, ve->nr_chan, ve->type, ctx->sub->vbo[vbo_index].stride, (void *)(unsigned long)(ve->base.src_offset + ctx->sub->vbo[vbo_index].buffer_offset));\n         } else {\n            glVertexAttribPointer(loc, ve->nr_chan, ve->type, ve->norm, ctx->sub->vbo[vbo_index].stride, (void *)(unsigned long)(ve->base.src_offset + ctx->sub->vbo[vbo_index].buffer_offset));\n         }\n         glVertexAttribDivisorARB(loc, ve->base.instance_divisor);\n      }\n   }\n   if (ctx->sub->enabled_attribs_bitmask != enable_bitmask) {\n      uint32_t mask = ctx->sub->enabled_attribs_bitmask & disable_bitmask;\n\n      while (mask) {\n         i = u_bit_scan(&mask);\n         glDisableVertexAttribArray(i);\n      }\n      ctx->sub->enabled_attribs_bitmask &= ~disable_bitmask;\n\n      mask = ctx->sub->enabled_attribs_bitmask ^ enable_bitmask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         glEnableVertexAttribArray(i);\n      }\n\n      ctx->sub->enabled_attribs_bitmask = enable_bitmask;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8848, "func": "static void vrend_destroy_so_target_object(void *obj_ptr)\n{\n   struct vrend_so_target *target = obj_ptr;\n   struct vrend_sub_context *sub_ctx = target->sub_ctx;\n   struct vrend_streamout_object *obj, *tmp;\n   bool found;\n   int i;\n\n   LIST_FOR_EACH_ENTRY_SAFE(obj, tmp, &sub_ctx->streamout_list, head) {\n      found = false;\n      for (i = 0; i < obj->num_targets; i++) {\n         if (obj->so_targets[i] == target) {\n            found = true;\n            break;\n         }\n      }\n      if (found) {\n         if (obj == sub_ctx->current_so)\n            sub_ctx->current_so = NULL;\n         if (obj->xfb_state == XFB_STATE_PAUSED) {\n               if (vrend_state.have_tf2)\n                  glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, obj->id);\n               glEndTransformFeedback();\n            if (sub_ctx->current_so && vrend_state.have_tf2)\n               glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, sub_ctx->current_so->id);\n         }\n         vrend_destroy_streamout_object(obj);\n      }\n   }\n\n   vrend_so_target_reference(&target, NULL);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8897, "func": "void vrend_renderer_destroy_sub_ctx(struct vrend_context *ctx, int sub_ctx_id)\n{\n   struct vrend_sub_context *sub, *tofree = NULL;\n\n   if (sub_ctx_id == 0)\n      return;\n\n   LIST_FOR_EACH_ENTRY(sub, &ctx->sub_ctxs, head) {\n      if (sub->sub_ctx_id == sub_ctx_id) {\n         tofree = sub;\n      }\n   }\n\n   if (tofree) {\n      if (ctx->sub == tofree) {\n         ctx->sub = ctx->sub0;\n         vrend_clicbs->make_current(0, ctx->sub->gl_context);\n      }\n      vrend_destroy_sub_context(tofree);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187637, "func": " static void gamma_transform_test(png_modifier *pm,\n   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,\n   PNG_CONST int palette_number,\n   PNG_CONST int interlace_type, PNG_CONST double file_gamma,\n   PNG_CONST double screen_gamma, PNG_CONST png_byte sbit,\n   PNG_CONST int use_input_precision, PNG_CONST int scale16)\n {\n    size_t pos = 0;\n    char name[64];\n\n if (sbit != bit_depth && sbit != 0)\n {\n      pos = safecat(name, sizeof name, pos, \"sbit(\");\n      pos = safecatn(name, sizeof name, pos, sbit);\n      pos = safecat(name, sizeof name, pos, \") \");\n }\n\n else\n      pos = safecat(name, sizeof name, pos, \"gamma \");\n\n if (scale16)\n      pos = safecat(name, sizeof name, pos, \"16to8 \");\n\n   pos = safecatd(name, sizeof name, pos, file_gamma, 3);\n   pos = safecat(name, sizeof name, pos, \"->\");\n   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);\n\n   gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,\n      file_gamma, screen_gamma, sbit, 0, name, use_input_precision,\n      scale16, pm->test_gamma_expand16, 0 , 0, 0);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 187972, "func": "void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)\n{\n stream_t *ps_stream;\n\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n {\n }\n\n }\n return;\n}\n", "target": 1, "flaw_line_index": "8,9"}
{"idx": 187505, "func": "bool semaphore_try_wait(semaphore_t *semaphore) {\n\n   assert(semaphore != NULL);\n   assert(semaphore->fd != INVALID_FD);\n \n  int flags = fcntl(semaphore->fd, F_GETFL);\n   if (flags == -1) {\n     LOG_ERROR(\"%s unable to get flags for semaphore fd: %s\", __func__, strerror(errno));\n     return false;\n   }\n  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n     LOG_ERROR(\"%s unable to set O_NONBLOCK for semaphore fd: %s\", __func__, strerror(errno));\n     return false;\n   }\n\n eventfd_t value;\n\n   if (eventfd_read(semaphore->fd, &value) == -1)\n     return false;\n \n  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)\n     LOG_ERROR(\"%s unable to resetore flags for semaphore fd: %s\", __func__, strerror(errno));\n   return true;\n }\n", "target": 1, "flaw_line_index": "6,11,21"}
{"idx": 188041, "func": "static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\n {\n     for (unsigned i = 0; i < nSamples; ++i) {\n         for (unsigned c = 0; c < nChannels; ++c) {\n *dst++ = src[c][i] >> 8;\n }\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8655, "func": "size_t mptsas_config_manufacturing_7(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(7, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l*l*l*s16*b*b*w\", MPTSAS_NUM_PORTS);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8865, "func": "static inline bool vrend_format_is_ds(enum virgl_formats format)\n{\n   return tex_conv_table[format].bindings & VREND_BIND_DEPTHSTENCIL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9007, "func": "vmxnet3_inc_tx_consumption_counter(VMXNET3State *s, int qidx)\n{\n    vmxnet3_ring_inc(&s->txq_descr[qidx].tx_ring);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8922, "func": "static int vrend_renderer_transfer_write_iov(struct vrend_context *ctx,\n                                             struct vrend_resource *res,\n                                             struct iovec *iov, int num_iovs,\n                                             const struct vrend_transfer_info *info)\n{\n   void *data;\n\n   if (res->target == 0 && res->ptr) {\n      vrend_read_from_iovec(iov, num_iovs, info->offset, res->ptr + info->box->x, info->box->width);\n      return 0;\n   }\n   if (res->target == GL_TRANSFORM_FEEDBACK_BUFFER ||\n       res->target == GL_ELEMENT_ARRAY_BUFFER_ARB ||\n       res->target == GL_ARRAY_BUFFER_ARB ||\n       res->target == GL_TEXTURE_BUFFER ||\n       res->target == GL_UNIFORM_BUFFER) {\n      struct virgl_sub_upload_data d;\n      d.box = info->box;\n      d.target = res->target;\n\n      glBindBufferARB(res->target, res->id);\n      if (use_sub_data == 1) {\n         vrend_read_from_iovec_cb(iov, num_iovs, info->offset, info->box->width, &iov_buffer_upload, &d);\n      } else {\n         data = glMapBufferRange(res->target, info->box->x, info->box->width, GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_UNSYNCHRONIZED_BIT | GL_MAP_WRITE_BIT);\n         if (data == NULL) {\n            fprintf(stderr,\"map failed for element buffer\\n\");\n            vrend_read_from_iovec_cb(iov, num_iovs, info->offset, info->box->width, &iov_buffer_upload, &d);\n         } else {\n            vrend_read_from_iovec(iov, num_iovs, info->offset, data, info->box->width);\n            glUnmapBuffer(res->target);\n         }\n      }\n   } else {\n      GLenum glformat;\n      GLenum gltype;\n      int need_temp = 0;\n      int elsize = util_format_get_blocksize(res->base.format);\n      int x = 0, y = 0;\n      bool compressed;\n      bool invert = false;\n      float depth_scale;\n      GLuint send_size = 0;\n      uint32_t stride = info->stride;\n\n      vrend_use_program(ctx, 0);\n\n      if (!stride)\n         stride = util_format_get_nblocksx(res->base.format, u_minify(res->base.width0, info->level)) * elsize;\n\n      compressed = util_format_is_compressed(res->base.format);\n      if (num_iovs > 1 || compressed) {\n         need_temp = true;\n      }\n\n      if (vrend_state.use_core_profile == true && (res->y_0_top || (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM))) {\n         need_temp = true;\n         if (res->y_0_top)\n            invert = true;\n      }\n\n      if (need_temp) {\n         send_size = util_format_get_nblocks(res->base.format, info->box->width,\n                                             info->box->height) * elsize * info->box->depth;\n         data = malloc(send_size);\n         if (!data)\n            return ENOMEM;\n         read_transfer_data(&res->base, iov, num_iovs, data, stride,\n                            info->box, info->offset, invert);\n      } else {\n         data = (char*)iov[0].iov_base + info->offset;\n      }\n\n      if (stride && !need_temp) {\n         glPixelStorei(GL_UNPACK_ROW_LENGTH, stride / elsize);\n      } else\n         glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);\n\n      switch (elsize) {\n      case 1:\n         glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n         break;\n      case 2:\n      case 6:\n         glPixelStorei(GL_UNPACK_ALIGNMENT, 2);\n         break;\n      case 4:\n      default:\n         glPixelStorei(GL_UNPACK_ALIGNMENT, 4);\n         break;\n      case 8:\n         glPixelStorei(GL_UNPACK_ALIGNMENT, 8);\n         break;\n      }\n\n      glformat = tex_conv_table[res->base.format].glformat;\n      gltype = tex_conv_table[res->base.format].gltype;\n\n      if ((!vrend_state.use_core_profile) && (res->y_0_top)) {\n         if (res->readback_fb_id == 0 || res->readback_fb_level != info->level) {\n            GLuint fb_id;\n            if (res->readback_fb_id)\n               glDeleteFramebuffers(1, &res->readback_fb_id);\n\n            glGenFramebuffers(1, &fb_id);\n            glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fb_id);\n            vrend_fb_bind_texture(res, 0, info->level, 0);\n\n            res->readback_fb_id = fb_id;\n            res->readback_fb_level = info->level;\n         } else {\n            glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, res->readback_fb_id);\n         }\n         glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);\n         vrend_blend_enable(ctx, false);\n         vrend_depth_test_enable(ctx, false);\n         vrend_alpha_test_enable(ctx, false);\n         vrend_stencil_test_enable(ctx, false);\n         glPixelZoom(1.0f, res->y_0_top ? -1.0f : 1.0f);\n         glWindowPos2i(info->box->x, res->y_0_top ? res->base.height0 - info->box->y : info->box->y);\n         glDrawPixels(info->box->width, info->box->height, glformat, gltype,\n                      data);\n      } else {\n         uint32_t comp_size;\n         glBindTexture(res->target, res->id);\n\n         if (compressed) {\n            glformat = tex_conv_table[res->base.format].internalformat;\n            comp_size = util_format_get_nblocks(res->base.format, info->box->width,\n                                                info->box->height) * util_format_get_blocksize(res->base.format);\n         }\n\n         if (glformat == 0) {\n            glformat = GL_BGRA;\n            gltype = GL_UNSIGNED_BYTE;\n         }\n\n         x = info->box->x;\n         y = invert ? res->base.height0 - info->box->y - info->box->height : info->box->y;\n\n         if (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM) {\n            depth_scale = 256.0;\n            if (!vrend_state.use_core_profile)\n               glPixelTransferf(GL_DEPTH_SCALE, depth_scale);\n            else\n               vrend_scale_depth(data, send_size, depth_scale);\n         }\n         if (res->target == GL_TEXTURE_CUBE_MAP) {\n            GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + info->box->z;\n            if (compressed) {\n               glCompressedTexSubImage2D(ctarget, info->level, x, y,\n                                         info->box->width, info->box->height,\n                                         glformat, comp_size, data);\n            } else {\n               glTexSubImage2D(ctarget, info->level, x, y, info->box->width, info->box->height,\n                               glformat, gltype, data);\n            }\n         } else if (res->target == GL_TEXTURE_3D || res->target == GL_TEXTURE_2D_ARRAY || res->target == GL_TEXTURE_CUBE_MAP_ARRAY) {\n            if (compressed) {\n               glCompressedTexSubImage3D(res->target, info->level, x, y, info->box->z,\n                                         info->box->width, info->box->height, info->box->depth,\n                                         glformat, comp_size, data);\n            } else {\n               glTexSubImage3D(res->target, info->level, x, y, info->box->z,\n                               info->box->width, info->box->height, info->box->depth,\n                               glformat, gltype, data);\n            }\n         } else if (res->target == GL_TEXTURE_1D) {\n            if (compressed) {\n               glCompressedTexSubImage1D(res->target, info->level, info->box->x,\n                                         info->box->width,\n                                         glformat, comp_size, data);\n            } else {\n               glTexSubImage1D(res->target, info->level, info->box->x, info->box->width,\n                               glformat, gltype, data);\n            }\n         } else {\n            if (compressed) {\n               glCompressedTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,\n                                         info->box->width, info->box->height,\n                                         glformat, comp_size, data);\n            } else {\n               glTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,\n                               info->box->width, info->box->height,\n                               glformat, gltype, data);\n            }\n         }\n         if (res->base.format == (enum pipe_format)VIRGL_FORMAT_Z24X8_UNORM) {\n            if (!vrend_state.use_core_profile)\n               glPixelTransferf(GL_DEPTH_SCALE, 1.0);\n         }\n      }\n      if (stride && !need_temp)\n         glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);\n      glPixelStorei(GL_UNPACK_ALIGNMENT, 4);\n\n      if (need_temp)\n         free(data);\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187716, "func": " set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,\n    PNG_CONST char *name)\n {\n   pm->state = modifier_start;\n   pm->bit_depth = 0;\n   pm->colour_type = 255;\n\n   pm->pending_len = 0;\n   pm->pending_chunk = 0;\n   pm->flush = 0;\n   pm->buffer_count = 0;\n   pm->buffer_position = 0;\n\n return set_store_for_read(&pm->this, ppi, id, name);\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8546, "func": "static struct Packet *ssh2_pkt_init(int pkt_type)\n{\n    struct Packet *pkt = ssh_new_packet();\n    pkt->length = 5; \n    pkt->forcepad = 0;\n    pkt->type = pkt_type;\n    ssh_pkt_addbyte(pkt, (unsigned char) pkt_type);\n    pkt->body = pkt->data + pkt->length; \n    pkt->downstream_id = 0;\n    pkt->additional_log_text = NULL;\n    return pkt;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8652, "func": "size_t mptsas_config_manufacturing_4(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(4, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x05,\n                              \"*l*b*b*b*b*b*b*w*s56*l*l*l*l*l*l\"\n                              \"*b*b*w*b*b*w*l*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9078, "func": "static void vmxnet3_validate_queues(VMXNET3State *s)\n{\n\n    if (s->txq_num > VMXNET3_DEVICE_MAX_TX_QUEUES) {\n        hw_error(\"Bad TX queues number: %d\\n\", s->txq_num);\n    }\n\n    if (s->rxq_num > VMXNET3_DEVICE_MAX_RX_QUEUES) {\n        hw_error(\"Bad RX queues number: %d\\n\", s->rxq_num);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188014, "func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n uint32_t numSyncSamples = U32_AT(&header[4]);\n\n if (numSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n }\n\n uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);\n if (allocSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size too large.\");\n return ERROR_OUT_OF_RANGE;\n }\n\n    mTotalSize += allocSize;\n if (mTotalSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size would make sample table too large.\\n\"\n \"    Requested sync sample table size = %llu\\n\"\n \"    Eventual sample table size >= %llu\\n\"\n \"    Allowed sample table size = %llu\\n\",\n (unsigned long long)allocSize,\n (unsigned long long)mTotalSize,\n (unsigned long long)kMaxTotalSize);\n return ERROR_OUT_OF_RANGE;\n }\n\n    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];\n if (!mSyncSamples) {\n        ALOGE(\"Cannot allocate sync sample table with %llu entries.\",\n (unsigned long long)numSyncSamples);\n return ERROR_OUT_OF_RANGE;\n }\n\n \n     if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n             (size_t)allocSize) != (ssize_t)allocSize) {\n        delete mSyncSamples;\n         mSyncSamples = NULL;\n         return ERROR_IO;\n     }\n\n for (size_t i = 0; i < numSyncSamples; ++i) {\n if (mSyncSamples[i] == 0) {\n            ALOGE(\"b/32423862, unexpected zero value in stss\");\n continue;\n }\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n\n    mSyncSampleOffset = data_offset;\n    mNumSyncSamples = numSyncSamples;\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "51"}
{"idx": 8504, "func": "void bndebug(char *string, Bignum b)\n{\n    unsigned char *p;\n    int i, len;\n    p = ssh2_mpint_fmt(b, &len);\n    debug((\"%s\", string));\n    for (i = 0; i < len; i++)\n\tdebug((\" %02x\", p[i]));\n    debug((\"\\n\"));\n    sfree(p);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8683, "func": "convert_fname (char *fname)\n{\n  char *converted_fname = fname;\n  const char *from_encoding = opt.encoding_remote;\n  const char *to_encoding = opt.locale;\n  iconv_t cd;\n  size_t len, done, inlen, outlen;\n  char *s;\n  const char *orig_fname = fname;\n\n  if (!from_encoding)\n    from_encoding = \"UTF-8\";\n  if (!to_encoding)\n    to_encoding = nl_langinfo (CODESET);\n\n  cd = iconv_open (to_encoding, from_encoding);\n  if (cd == (iconv_t)(-1))\n    logprintf (LOG_VERBOSE, _(\"Conversion from %s to %s isn't supported\\n\"),\n\t       quote (from_encoding), quote (to_encoding));\n  else\n    {\n      inlen = strlen (fname);\n      len = outlen = inlen * 2;\n      converted_fname = s = xmalloc (outlen + 1);\n      done = 0;\n\n      for (;;)\n\t{\n\t  if (iconv (cd, (ICONV_CONST char **) &fname, &inlen, &s, &outlen) != (size_t)(-1)\n\t      && iconv (cd, NULL, NULL, &s, &outlen) != (size_t)(-1))\n\t    {\n\t      *(converted_fname + len - outlen - done) = '\\0';\n\t      iconv_close(cd);\n\t      DEBUGP ((\"Converted file name '%s' (%s) -> '%s' (%s)\\n\",\n\t\t       orig_fname, from_encoding, converted_fname, to_encoding));\n\t      xfree (orig_fname);\n\t      return converted_fname;\n\t    }\n\n\t  if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t      logprintf (LOG_VERBOSE,\n\t\t\t _(\"Incomplete or invalid multibyte sequence encountered\\n\"));\n\t      xfree (converted_fname);\n\t      converted_fname = (char *)orig_fname;\n\t      break;\n\t    }\n\t  else if (errno == E2BIG) \n\t    {\n\t      done = len;\n\t      len = outlen = done + inlen * 2;\n\t      converted_fname = xrealloc (converted_fname, outlen + 1);\n\t      s = converted_fname + done;\n\t    }\n\t  else \n\t    {\n\t      logprintf (LOG_VERBOSE, _(\"Unhandled errno %d\\n\"), errno);\n\t      xfree (converted_fname);\n\t      converted_fname = (char *)orig_fname;\n\t      break;\n\t    }\n\t}\n      DEBUGP ((\"Failed to convert file name '%s' (%s) -> '?' (%s)\\n\",\n\t       orig_fname, from_encoding, to_encoding));\n    }\n\n    iconv_close(cd);\n\n  return converted_fname;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188496, "func": "int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n VpxVideoReader *reader = NULL;\n const VpxVideoInfo *info = NULL;\n const VpxInterface *decoder = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n unsigned char digest[16];\n\n      get_image_md5(img, digest);\n      print_md5(outfile, digest);\n      fprintf(outfile, \"  img-%dx%d-%04d.i420\\n\",\n              img->d_w, img->d_h, ++frame_cnt);\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "28,30"}
{"idx": 9063, "func": "static void vmxnet3_set_variable_mac(VMXNET3State *s, uint32_t h, uint32_t l)\n{\n    s->conf.macaddr.a[0] = VMXNET3_GET_BYTE(l,  0);\n    s->conf.macaddr.a[1] = VMXNET3_GET_BYTE(l,  1);\n    s->conf.macaddr.a[2] = VMXNET3_GET_BYTE(l,  2);\n    s->conf.macaddr.a[3] = VMXNET3_GET_BYTE(l,  3);\n    s->conf.macaddr.a[4] = VMXNET3_GET_BYTE(h, 0);\n    s->conf.macaddr.a[5] = VMXNET3_GET_BYTE(h, 1);\n\n    VMW_CFPRN(\"Variable MAC: \" MAC_FMT, MAC_ARG(s->conf.macaddr.a));\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8347, "func": "static int xhci_submit(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    uint64_t mfindex;\n\n    DPRINTF(\"xhci_submit(slotid=%d,epid=%d)\\n\", xfer->slotid, xfer->epid);\n\n    xfer->in_xfer = epctx->type>>2;\n\n    switch(epctx->type) {\n    case ET_INTR_OUT:\n    case ET_INTR_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_intr_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    case ET_BULK_OUT:\n    case ET_BULK_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = false;\n        break;\n    case ET_ISO_OUT:\n    case ET_ISO_IN:\n        xfer->pkts = 1;\n        xfer->iso_xfer = true;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_iso_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    default:\n        trace_usb_xhci_unimplemented(\"endpoint type\", epctx->type);\n        return -1;\n    }\n\n    if (xhci_setup_packet(xfer) < 0) {\n        return -1;\n    }\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n    xhci_complete_packet(xfer);\n    if (!xfer->running_async && !xfer->running_retry) {\n        xhci_kick_ep(xhci, xfer->slotid, xfer->epid, xfer->streamid);\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188528, "func": "   static void SetUpTestCase() {\n    input_ = reinterpret_cast<uint8_t*>(\n\n         vpx_memalign(kDataAlignment, kInputBufferSize + 1)) + 1;\n     output_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kOutputBufferSize));\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187984, "func": " int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)\n {\n     ALOGV(\"load: fd=%d, offset=%\" PRId64 \", length=%\" PRId64 \", priority=%d\",\n             fd, offset, length, priority);\n    Mutex::Autolock lock(&mLock);\n    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);\n    mSamples.add(sample->sampleID(), sample);\n    doLoad(sample);\n    return sample->sampleID();\n}\n", "target": 1, "flaw_line_index": "5,6,7,8,9,10"}
{"idx": 8687, "func": "lowercase_str (char *str)\n{\n  bool changed = false;\n  for (; *str; str++)\n    if (c_isupper (*str))\n      {\n        changed = true;\n        *str = c_tolower (*str);\n      }\n  return changed;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187705, "func": "static void perform_gamma_transform_tests(png_modifier *pm)\n{\n   png_byte colour_type = 0;\n\n    png_byte bit_depth = 0;\n    unsigned int palette_number = 0;\n \n   while (next_format(&colour_type, &bit_depth, &palette_number, 1\n))\n    {\n       unsigned int i, j;\n \n for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)\n if (i != j)\n {\n            gamma_transform_test(pm, colour_type, bit_depth, palette_number,\n               pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], 0\n,\n               pm->use_input_precision, 0 \n);\n\n if (fail(pm))\n return;\n }\n }\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 187979, "func": "WORD32 ih264d_parse_inter_slice_data_cavlc(dec_struct_t * ps_dec,\n dec_slice_params_t * ps_slice,\n                                           UWORD16 u2_first_mb_in_slice)\n{\n    UWORD32 uc_more_data_flag;\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n    UWORD32 u1_read_mb_type;\n\n    UWORD32 u1_mbaff;\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end = 0;\n    UWORD32 u1_tfr_n_mb = 0;\n    UWORD32 u1_decode_nmb = 0;\n\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD32 u1_mb_threshold;\n    WORD32 ret = OK;\n\n\n if(ps_slice->u1_slice_type == P_SLICE)\n {\n        u1_inter_mb_type = P_MB;\n        u1_deblk_mb_type = D_INTER_MB;\n        u1_mb_threshold = 5;\n }\n else \n {\n        u1_inter_mb_type = B_MB;\n        u1_deblk_mb_type = D_B_SLICE;\n        u1_mb_threshold = 23;\n }\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_num_mbsNby2 = 0;\n    u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;\n    i2_mb_skip_run = 0;\n    uc_more_data_flag = 1;\n    u1_read_mb_type = 0;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n {\n            ret = ERROR_MB_ADDRESS_T;\n break;\n }\n\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if((!i2_mb_skip_run) && (!u1_read_mb_type))\n {\n\n            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;\n            UWORD32 u4_word, u4_ldz;\n\n            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);\n\n            u4_ldz = CLZ(u4_word);\n\n            u4_bitstream_offset += (u4_ldz + 1);\n            u4_word = 0;\n if(u4_ldz)\n {\n                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,\n                        u4_ldz);\n }\n *pu4_bitstrm_ofst = u4_bitstream_offset;\n            i2_mb_skip_run = ((1 << u4_ldz) + u4_word - 1);\n            COPYTHECONTEXT(\"mb_skip_run\", i2_mb_skip_run);\n            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);\n            u1_read_mb_type = uc_more_data_flag;\n }\n\n        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n\n if(i2_mb_skip_run)\n {\n            ps_dec->i1_prev_mb_qp_delta = 0;\n            ps_dec->u1_sub_mb_num = 0;\n            ps_cur_mb_info->u1_mb_type = MB_SKIP;\n            ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n            ps_cur_mb_info->u1_cbp = 0;\n\n {\n parse_part_params_t *ps_part_info = ps_dec->ps_part;\n                ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n                ps_part_info->u1_sub_mb_num = 0;\n                ps_dec->ps_part++;\n }\n\n            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n            ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n            ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n            i2_mb_skip_run--;\n }\n else\n {\n            u1_read_mb_type = 0;\n {\n                UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;\n                UWORD32 u4_word, u4_ldz, u4_temp;\n\n\n                NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);\n                u4_ldz = CLZ(u4_word);\n                u4_bitstream_offset += (u4_ldz + 1);\n                u4_word = 0;\n if(u4_ldz)\n                    GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,\n                            u4_ldz);\n *pu4_bitstrm_ofst = u4_bitstream_offset;\n                u4_temp = ((1 << u4_ldz) + u4_word - 1);\n if(u4_temp > (UWORD32)(25 + u1_mb_threshold))\n return ERROR_MB_TYPE;\n                u1_mb_type = u4_temp;\n                COPYTHECONTEXT(\"u1_mb_type\", u1_mb_type);\n }\n            ps_cur_mb_info->u1_mb_type = u1_mb_type;\n\n if(u1_mb_type < u1_mb_threshold)\n {\n                ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n\n                ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,\n                                          u1_num_mbsNby2);\n if(ret != OK)\n return ret;\n                ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n }\n else\n {\n                ps_parse_mb_data->u1_num_part = 0;\n                ps_parse_mb_data->u1_isI_mb = 1;\n\n if((25 + u1_mb_threshold) == u1_mb_type)\n {\n                    ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;\n                    ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);\n if(ret != OK)\n return ret;\n                    ps_dec->u1_qp = 0;\n }\n else\n {\n                    ret = ih264d_parse_imb_cavlc(\n                                    ps_dec, ps_cur_mb_info, u1_num_mbs,\n (UWORD8)(u1_mb_type - u1_mb_threshold));\n if(ret != OK)\n return ret;\n }\n\n                ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;\n }\n            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);\n }\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if(u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n         i2_cur_mb_addr++;\n \n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n         u1_num_mbsNby2++;\n         ps_parse_mb_data++;\n \n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = (!(uc_more_data_flag || i2_mb_skip_run));\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n {\n                ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n                ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n }\n\n if(u1_decode_nmb)\n {\n\n\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n\n                                             u1_num_mbs_next, u1_tfr_n_mb,\n                                             u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - (u2_first_mb_in_slice << u1_mbaff);\n\n\n return ret;\n}\n", "target": 1, "flaw_line_index": "205"}
{"idx": 187519, "func": "static void uipc_flush_ch_locked(tUIPC_CH_ID ch_id)\n{\n char buf[UIPC_FLUSH_BUFFER_SIZE];\n struct pollfd pfd;\n int ret;\n\n    pfd.events = POLLIN;\n    pfd.fd = uipc_main.ch[ch_id].fd;\n\n if (uipc_main.ch[ch_id].fd == UIPC_DISCONNECTED)\n {\n        BTIF_TRACE_EVENT(\"%s() - fd disconnected. Exiting\", __FUNCTION__);\n return;\n }\n\n \n     while (1)\n     {\n        ret = poll(&pfd, 1, 1);\n         BTIF_TRACE_VERBOSE(\"%s() - polling fd %d, revents: 0x%x, ret %d\",\n                 __FUNCTION__, pfd.fd, pfd.revents, ret);\n \n if (pfd.revents & (POLLERR|POLLHUP))\n {\n            BTIF_TRACE_EVENT(\"%s() - POLLERR or POLLHUP. Exiting\", __FUNCTION__);\n return;\n }\n\n if (ret <= 0)\n {\n            BTIF_TRACE_EVENT(\"%s() - error (%d). Exiting\", __FUNCTION__, ret);\n return;\n }\n\n \n        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);\n     }\n }\n", "target": 1, "flaw_line_index": "19,36"}
{"idx": 187812, "func": "OMX_ERRORTYPE  omx_vdec::set_config(OMX_IN OMX_HANDLETYPE      hComp,\n        OMX_IN OMX_INDEXTYPE configIndex,\n        OMX_IN OMX_PTR        configData)\n{\n (void) hComp;\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"Get Config in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n\n    OMX_ERRORTYPE ret = OMX_ErrorNone;\n    OMX_VIDEO_CONFIG_NALSIZE *pNal;\n\n    DEBUG_PRINT_LOW(\"Set Config Called\");\n\n if (configIndex == (OMX_INDEXTYPE)OMX_IndexVendorVideoExtraData) {\n        OMX_VENDOR_EXTRADATATYPE *config = (OMX_VENDOR_EXTRADATATYPE *) configData;\n        DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData called\");\n if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.avc\") ||\n !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mvc\")) {\n            DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData AVC\");\n            OMX_U32 extra_size;\n\n            nal_length = (config->pData[4] & 0x03) + 1;\n\n            extra_size = 0;\n if (nal_length > 2) {\n                extra_size = (nal_length - 2) * 2;\n }\n\n            OMX_U8 *pSrcBuf = (OMX_U8 *) (&config->pData[6]);\n            OMX_U8 *pDestBuf;\n            m_vendor_config.nPortIndex = config->nPortIndex;\n\n            m_vendor_config.nDataSize = config->nDataSize - 6 - 1 + extra_size;\n            m_vendor_config.pData = (OMX_U8 *) malloc(m_vendor_config.nDataSize);\n            OMX_U32 len;\n            OMX_U8 index = 0;\n            pDestBuf = m_vendor_config.pData;\n\n            DEBUG_PRINT_LOW(\"Rxd SPS+PPS nPortIndex[%u] len[%u] data[%p]\",\n (unsigned int)m_vendor_config.nPortIndex,\n (unsigned int)m_vendor_config.nDataSize,\n                    m_vendor_config.pData);\n while (index < 2) {\n uint8 *psize;\n                len = *pSrcBuf;\n                len = len << 8;\n                len |= *(pSrcBuf + 1);\n                psize = (uint8 *) & len;\n                memcpy(pDestBuf + nal_length, pSrcBuf + 2,len);\n for (unsigned int i = 0; i < nal_length; i++) {\n                    pDestBuf[i] = psize[nal_length - 1 - i];\n }\n                pDestBuf += len + nal_length;\n                pSrcBuf += len + 2;\n                index++;\n                pSrcBuf++; \n                len = 0;\n }\n } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg4\") ||\n !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg2\")) {\n            m_vendor_config.nPortIndex = config->nPortIndex;\n            m_vendor_config.nDataSize = config->nDataSize;\n            m_vendor_config.pData = (OMX_U8 *) malloc((config->nDataSize));\n            memcpy(m_vendor_config.pData, config->pData,config->nDataSize);\n } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.vc1\")) {\n if (m_vendor_config.pData) {\n                free(m_vendor_config.pData);\n                m_vendor_config.pData = NULL;\n                m_vendor_config.nDataSize = 0;\n }\n\n if (((*((OMX_U32 *) config->pData)) &\n                        VC1_SP_MP_START_CODE_MASK) ==\n                    VC1_SP_MP_START_CODE) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 simple/main profile\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize = config->nDataSize;\n                m_vendor_config.pData =\n (OMX_U8 *) malloc(config->nDataSize);\n                memcpy(m_vendor_config.pData, config->pData,\n                        config->nDataSize);\n                m_vc1_profile = VC1_SP_MP_RCV;\n } else if (*((OMX_U32 *) config->pData) == VC1_AP_SEQ_START_CODE) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 Advance profile\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize = config->nDataSize;\n                m_vendor_config.pData =\n (OMX_U8 *) malloc((config->nDataSize));\n                memcpy(m_vendor_config.pData, config->pData,\n                        config->nDataSize);\n                m_vc1_profile = VC1_AP;\n } else if ((config->nDataSize == VC1_STRUCT_C_LEN)) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 Simple/Main profile struct C only\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize  = config->nDataSize;\n                m_vendor_config.pData = (OMX_U8*)malloc(config->nDataSize);\n                memcpy(m_vendor_config.pData,config->pData,config->nDataSize);\n                m_vc1_profile = VC1_SP_MP_RCV;\n } else {\n                DEBUG_PRINT_LOW(\"set_config - Error: Unknown VC1 profile\");\n }\n }\n return ret;\n } else if (configIndex == OMX_IndexConfigVideoNalSize) {\n\n         struct v4l2_control temp;\n         temp.id = V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT;\n \n         pNal = reinterpret_cast < OMX_VIDEO_CONFIG_NALSIZE * >(configData);\n         switch (pNal->nNaluBytes) {\n             case 0:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_STARTCODES;\n break;\n case 2:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_TWO_BYTE_LENGTH;\n break;\n case 4:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_FOUR_BYTE_LENGTH;\n break;\n default:\n return OMX_ErrorUnsupportedSetting;\n }\n\n if (!arbitrary_bytes) {\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &temp)) {\n                DEBUG_PRINT_ERROR(\"Failed to set V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT\");\n return OMX_ErrorHardware;\n }\n }\n\n        nal_length = pNal->nNaluBytes;\n        m_frame_parser.init_nal_length(nal_length);\n\n        DEBUG_PRINT_LOW(\"OMX_IndexConfigVideoNalSize called with Size %d\", nal_length);\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexVendorVideoFrameRate) {\n        OMX_VENDOR_VIDEOFRAMERATE *config = (OMX_VENDOR_VIDEOFRAMERATE *) configData;\n        DEBUG_PRINT_HIGH(\"Index OMX_IndexVendorVideoFrameRate %u\", (unsigned int)config->nFps);\n\n if (config->nPortIndex == OMX_CORE_INPUT_PORT_INDEX) {\n if (config->bEnabled) {\n if ((config->nFps >> 16) > 0) {\n                    DEBUG_PRINT_HIGH(\"set_config: frame rate set by omx client : %u\",\n (unsigned int)config->nFps >> 16);\n                    Q16ToFraction(config->nFps, drv_ctx.frame_rate.fps_numerator,\n                            drv_ctx.frame_rate.fps_denominator);\n\n if (!drv_ctx.frame_rate.fps_numerator) {\n                        DEBUG_PRINT_ERROR(\"Numerator is zero setting to 30\");\n                        drv_ctx.frame_rate.fps_numerator = 30;\n }\n\n if (drv_ctx.frame_rate.fps_denominator) {\n                        drv_ctx.frame_rate.fps_numerator = (int)\n                            drv_ctx.frame_rate.fps_numerator / drv_ctx.frame_rate.fps_denominator;\n }\n\n                    drv_ctx.frame_rate.fps_denominator = 1;\n                    frm_int = drv_ctx.frame_rate.fps_denominator * 1e6 /\n                        drv_ctx.frame_rate.fps_numerator;\n\n struct v4l2_outputparm oparm;\n                    oparm.timeperframe.numerator = drv_ctx.frame_rate.fps_denominator;\n                    oparm.timeperframe.denominator = drv_ctx.frame_rate.fps_numerator;\n\n struct v4l2_streamparm sparm;\n                    sparm.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n                    sparm.parm.output = oparm;\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_PARM, &sparm)) {\n                        DEBUG_PRINT_ERROR(\"Unable to convey fps info to driver, \\\n                                performance might be affected\");\n                        ret = OMX_ErrorHardware;\n }\n                    client_set_fps = true;\n } else {\n                    DEBUG_PRINT_ERROR(\"Frame rate not supported.\");\n                    ret = OMX_ErrorUnsupportedSetting;\n }\n } else {\n                DEBUG_PRINT_HIGH(\"set_config: Disabled client's frame rate\");\n                client_set_fps = false;\n }\n } else {\n            DEBUG_PRINT_ERROR(\" Set_config: Bad Port idx %d\",\n (int)config->nPortIndex);\n            ret = OMX_ErrorBadPortIndex;\n }\n\n return ret;\n } else if ((int)configIndex == (int)OMX_QcomIndexConfigPerfLevel) {\n        OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =\n (OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;\n struct v4l2_control control;\n\n        DEBUG_PRINT_LOW(\"Set perf level: %d\", perf->ePerfLevel);\n\n        control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;\n\n switch (perf->ePerfLevel) {\n case OMX_QCOM_PerfLevelNominal:\n                control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL;\n break;\n case OMX_QCOM_PerfLevelTurbo:\n                control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO;\n break;\n default:\n                ret = OMX_ErrorUnsupportedSetting;\n break;\n }\n\n if (ret == OMX_ErrorNone) {\n            ret = (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control) < 0) ?\n                OMX_ErrorUnsupportedSetting : OMX_ErrorNone;\n }\n\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexConfigPriority) {\n        OMX_PARAM_U32TYPE *priority = (OMX_PARAM_U32TYPE *)configData;\n        DEBUG_PRINT_LOW(\"Set_config: priority %d\", priority->nU32);\n\n struct v4l2_control control;\n\n        control.id = V4L2_CID_MPEG_VIDC_VIDEO_PRIORITY;\n if (priority->nU32 == 0)\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_ENABLE;\n else\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_DISABLE;\n\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {\n            DEBUG_PRINT_ERROR(\"Failed to set Priority\");\n            ret = OMX_ErrorUnsupportedSetting;\n }\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexConfigOperatingRate) {\n        OMX_PARAM_U32TYPE *rate = (OMX_PARAM_U32TYPE *)configData;\n        DEBUG_PRINT_LOW(\"Set_config: operating-rate %u fps\", rate->nU32 >> 16);\n\n struct v4l2_control control;\n\n        control.id = V4L2_CID_MPEG_VIDC_VIDEO_OPERATING_RATE;\n        control.value = rate->nU32;\n\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {\n            ret = errno == -EBUSY ? OMX_ErrorInsufficientResources :\n                    OMX_ErrorUnsupportedSetting;\n            DEBUG_PRINT_ERROR(\"Failed to set operating rate %u fps (%s)\",\n                    rate->nU32 >> 16, errno == -EBUSY ? \"HW Overload\" : strerror(errno));\n }\n return ret;\n }\n\n return OMX_ErrorNotImplemented;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188117, "func": "   explicit ElementsAccessorBase(const char* name)\n      : ElementsAccessor(name) { }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 9228, "func": "void virtio_queue_invalidate_signalled_used(VirtIODevice *vdev, int n)\n{\n    vdev->vq[n].signalled_used_valid = false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8594, "func": "static void ssh_throttle_conn(Ssh ssh, int adjust)\n{\n    int old_count = ssh->conn_throttle_count;\n    ssh->conn_throttle_count += adjust;\n    assert(ssh->conn_throttle_count >= 0);\n    if (ssh->conn_throttle_count && !old_count) {\n     }\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 187619, "func": "write_one_file(Image *output, Image *image, int convert_to_8bit)\n{\n if (image->opts & FAST_WRITE)\n      image->image.flags |= PNG_IMAGE_FLAG_FAST;\n\n \n    if (image->opts & USE_STDIO)\n    {\n       FILE *f = tmpfile();\n \n       if (f != NULL)\n       {\n if (png_image_write_to_stdio(&image->image, f, convert_to_8bit,\n            image->buffer+16, (png_int_32)image->stride, image->colormap))\n {\n if (fflush(f) == 0)\n {\n               rewind(f);\n               initimage(output, image->opts, \"tmpfile\", image->stride_extra);\n               output->input_file = f;\n if (!checkopaque(image))\n return 0;\n }\n\n else\n return logclose(image, f, \"tmpfile\", \": flush: \");\n }\n\n else\n {\n            fclose(f);\n return logerror(image, \"tmpfile\", \": write failed\", \"\");\n }\n }\n\n else\n return logerror(image, \"tmpfile\", \": open: \", strerror(errno));\n }\n\n else\n {\n static int counter = 0;\n char name[32];\n\n      sprintf(name, \"%s%d.png\", tmpf, ++counter);\n\n if (png_image_write_to_file(&image->image, name, convert_to_8bit,\n         image->buffer+16, (png_int_32)image->stride, image->colormap))\n {\n         initimage(output, image->opts, output->tmpfile_name,\n            image->stride_extra);\n         strcpy(output->tmpfile_name, name);\n\n if (!checkopaque(image))\n return 0;\n }\n\n else\n return logerror(image, name, \": write failed\", \"\");\n }\n\n if (read_file(output, image->image.format | FORMAT_NO_CHANGE, NULL))\n {\n      png_uint_32 original_format = image->image.format;\n\n if (convert_to_8bit)\n         original_format &= ~PNG_FORMAT_FLAG_LINEAR;\n\n if ((output->image.format & BASE_FORMATS) !=\n (original_format & BASE_FORMATS))\n return logerror(image, image->file_name, \": format changed on read: \",\n            output->file_name);\n\n return compare_two_images(image, output, 0\n, NULL);\n }\n\n else\n return logerror(output, output->tmpfile_name,\n \": read of new file failed\", \"\");\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8560, "func": "static void *ssh_comp_none_init(void)\n{\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8881, "func": "bool vrend_is_ds_format(enum virgl_formats format)\n{\n   return vrend_format_is_ds(format);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9080, "func": "static bool vmxnet3_verify_intx(VMXNET3State *s, int intx)\n{\n    return s->msix_used || msi_enabled(PCI_DEVICE(s))\n        || intx == pci_get_byte(s->parent_obj.config + PCI_INTERRUPT_PIN) - 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9111, "func": "static int vrend_decode_resource_copy_region(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_box box;\n   uint32_t dst_handle, src_handle;\n   uint32_t dst_level, dstx, dsty, dstz;\n   uint32_t src_level;\n\n   if (length != VIRGL_CMD_RESOURCE_COPY_REGION_SIZE)\n      return EINVAL;\n\n   dst_handle = get_buf_entry(ctx, VIRGL_CMD_RCR_DST_RES_HANDLE);\n   dst_level = get_buf_entry(ctx, VIRGL_CMD_RCR_DST_LEVEL);\n   dstx = get_buf_entry(ctx, VIRGL_CMD_RCR_DST_X);\n   dsty = get_buf_entry(ctx, VIRGL_CMD_RCR_DST_Y);\n   dstz = get_buf_entry(ctx, VIRGL_CMD_RCR_DST_Z);\n   src_handle = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_RES_HANDLE);\n   src_level = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_LEVEL);\n   box.x = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_X);\n   box.y = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_Y);\n   box.z = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_Z);\n   box.width = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_W);\n   box.height = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_H);\n   box.depth = get_buf_entry(ctx, VIRGL_CMD_RCR_SRC_D);\n\n   vrend_renderer_resource_copy_region(ctx->grctx, dst_handle,\n                                       dst_level, dstx, dsty, dstz,\n                                       src_handle, src_level,\n                                       &box);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8779, "func": "static int sprint_nip(char *dest, const char *pre, const uint8_t *ip)\n{\n\treturn sprintf(dest, \"%s%u.%u.%u.%u\", pre, ip[0], ip[1], ip[2], ip[3]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187415, "func": "void ID3::Iterator::getstring(String8 *id, bool otherdata) const {\n    id->setTo(\"\");\n\n const uint8_t *frameData = mFrameData;\n if (frameData == NULL) {\n return;\n }\n\n uint8_t encoding = *frameData;\n\n if (mParent.mVersion == ID3_V1 || mParent.mVersion == ID3_V1_1) {\n if (mOffset == 126 || mOffset == 127) {\n char tmp[16];\n            sprintf(tmp, \"%d\", (int)*frameData);\n\n            id->setTo(tmp);\n return;\n }\n\n        id->setTo((const char*)frameData, mFrameSize);\n return;\n }\n\n if (mFrameSize < getHeaderLength() + 1) {\n return;\n }\n size_t n = mFrameSize - getHeaderLength() - 1;\n if (otherdata) {\n        frameData += 4;\n int32_t i = n - 4;\n while(--i >= 0 && *++frameData != 0) ;\n int skipped = (frameData - mFrameData);\n if (skipped >= (int)n) {\n return;\n }\n\n         n -= skipped;\n     }\n \n     if (encoding == 0x00) {\n         id->setTo((const char*)frameData + 1, n);\n } else if (encoding == 0x03) {\n        id->setTo((const char *)(frameData + 1), n);\n } else if (encoding == 0x02) {\n int len = n / 2;\n\n         const char16_t *framedata = (const char16_t *) (frameData + 1);\n         char16_t *framedatacopy = NULL;\n #if BYTE_ORDER == LITTLE_ENDIAN\n        framedatacopy = new char16_t[len];\n        for (int i = 0; i < len; i++) {\n            framedatacopy[i] = bswap_16(framedata[i]);\n         }\n        framedata = framedatacopy;\n #endif\n         id->setTo(framedata, len);\n         if (framedatacopy != NULL) {\n delete[] framedatacopy;\n }\n } else if (encoding == 0x01) {\n int len = n / 2;\n\n         const char16_t *framedata = (const char16_t *) (frameData + 1);\n         char16_t *framedatacopy = NULL;\n         if (*framedata == 0xfffe) {\n            framedatacopy = new char16_t[len];\n             for (int i = 0; i < len; i++) {\n                 framedatacopy[i] = bswap_16(framedata[i]);\n             }\n             framedata = framedatacopy;\n        }\n        if (*framedata == 0xfeff) {\n             framedata++;\n             len--;\n         }\n\n bool eightBit = true;\n for (int i = 0; i < len; i++) {\n if (framedata[i] > 0xff) {\n                eightBit = false;\n break;\n }\n\n         }\n         if (eightBit) {\n            char *frame8 = new char[len];\n            for (int i = 0; i < len; i++) {\n                frame8[i] = framedata[i];\n             }\n            id->setTo(frame8, len);\n            delete [] frame8;\n         } else {\n             id->setTo(framedata, len);\n         }\n\n if (framedatacopy != NULL) {\n delete[] framedatacopy;\n }\n }\n}\n", "target": 1, "flaw_line_index": "58,59,60,62,76,77,82,83,84,100,101"}
{"idx": 188209, "func": "OMX_ERRORTYPE SoftAAC2::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             const OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (const OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (aacParams->eAACStreamFormat == OMX_AUDIO_AACStreamFormatMP4FF) {\n                mIsADTS = false;\n } else if (aacParams->eAACStreamFormat\n == OMX_AUDIO_AACStreamFormatMP4ADTS) {\n                mIsADTS = true;\n } else {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAndroidAacPresentation:\n\n         {\n             const OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE *aacPresParams =\n                     (const OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE *)params;\n if (aacPresParams->nMaxOutputChannels >= 0) {\n int max;\n if (aacPresParams->nMaxOutputChannels >= 8) { max = 8; }\n else if (aacPresParams->nMaxOutputChannels >= 6) { max = 6; }\n else if (aacPresParams->nMaxOutputChannels >= 2) { max = 2; }\n else {\n                    max = aacPresParams->nMaxOutputChannels;\n }\n                ALOGV(\"set nMaxOutputChannels=%d\", max);\n                aacDecoder_SetParam(mAACDecoder, AAC_PCM_MAX_OUTPUT_CHANNELS, max);\n }\n bool updateDrcWrapper = false;\n if (aacPresParams->nDrcBoost >= 0) {\n                ALOGV(\"set nDrcBoost=%d\", aacPresParams->nDrcBoost);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_BOOST_FACTOR,\n                        aacPresParams->nDrcBoost);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nDrcCut >= 0) {\n                ALOGV(\"set nDrcCut=%d\", aacPresParams->nDrcCut);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_ATT_FACTOR, aacPresParams->nDrcCut);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nHeavyCompression >= 0) {\n                ALOGV(\"set nHeavyCompression=%d\", aacPresParams->nHeavyCompression);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_HEAVY,\n                        aacPresParams->nHeavyCompression);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nTargetReferenceLevel >= 0) {\n                ALOGV(\"set nTargetReferenceLevel=%d\", aacPresParams->nTargetReferenceLevel);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_TARGET,\n                        aacPresParams->nTargetReferenceLevel);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nEncodedTargetLevel >= 0) {\n                ALOGV(\"set nEncodedTargetLevel=%d\", aacPresParams->nEncodedTargetLevel);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_ENCODER_TARGET,\n                        aacPresParams->nEncodedTargetLevel);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nPCMLimiterEnable >= 0) {\n                aacDecoder_SetParam(mAACDecoder, AAC_PCM_LIMITER_ENABLE,\n (aacPresParams->nPCMLimiterEnable != 0));\n }\n if (updateDrcWrapper) {\n                mDrcWrap.update();\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9123, "func": "static int vrend_decode_set_stencil_ref(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != VIRGL_SET_STENCIL_REF_SIZE)\n      return EINVAL;\n\n   struct pipe_stencil_ref ref;\n   uint32_t val = get_buf_entry(ctx, VIRGL_SET_STENCIL_REF);\n\n   ref.ref_value[0] = val & 0xff;\n   ref.ref_value[1] = (val >> 8) & 0xff;\n   vrend_set_stencil_ref(ctx->grctx, &ref);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8713, "func": "url_free (struct url *url)\n{\n  if (url)\n    {\n      if (url->idn_allocated) {\n        idn2_free (url->host);      \n        url->host = NULL;\n      }\n      else\n        xfree (url->host);\n\n      xfree (url->path);\n      xfree (url->url);\n\n      xfree (url->params);\n      xfree (url->query);\n      xfree (url->fragment);\n      xfree (url->user);\n      xfree (url->passwd);\n\n      xfree (url->dir);\n      xfree (url->file);\n\n      xfree (url);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8903, "func": "void vrend_renderer_get_cap_set(uint32_t cap_set, uint32_t *max_ver,\n                                uint32_t *max_size)\n{\n   if (cap_set != VREND_CAP_SET) {\n      *max_ver = 0;\n      *max_size = 0;\n      return;\n   }\n\n   *max_ver = 1;\n   *max_size = sizeof(union virgl_caps);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187903, "func": "void OMX::binderDied(const wp<IBinder> &the_late_who) {\n OMXNodeInstance *instance;\n\n {\n\n         Mutex::Autolock autoLock(mLock);\n \n         ssize_t index = mLiveNodes.indexOfKey(the_late_who);\n        CHECK(index >= 0);\n \n         instance = mLiveNodes.editValueAt(index);\n         mLiveNodes.removeItemsAt(index);\n\n        index = mDispatchers.indexOfKey(instance->nodeID());\n        CHECK(index >= 0);\n        mDispatchers.removeItemsAt(index);\n\n        invalidateNodeID_l(instance->nodeID());\n }\n\n    instance->onObserverDied(mMaster);\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 187373, "func": "int NsGetParameter(preproc_effect_t  *effect,\n                   void              *pParam,\n                   uint32_t          *pValueSize,\n                   void              *pValue)\n {\n     int status = 0;\n     return status;\n }\n", "target": 1, "flaw_line_index": "2,3,4"}
{"idx": 9184, "func": "void virtio_config_modern_writeb(VirtIODevice *vdev,\n                                 uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8591, "func": "static void ssh_set_frozen(Ssh ssh, int frozen)\n{\n    if (ssh->s)\n\tsk_set_frozen(ssh->s, frozen);\n    ssh->frozen = frozen;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8502, "func": "CSoundFile::~CSoundFile()\n{\n\tDestroy();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9135, "func": "void vmxnet_tx_pkt_update_ip_checksums(struct VmxnetTxPkt *pkt)\n{\n    uint16_t csum;\n    uint32_t ph_raw_csum;\n    assert(pkt);\n    uint8_t gso_type = pkt->virt_hdr.gso_type & ~VIRTIO_NET_HDR_GSO_ECN;\n    struct ip_header *ip_hdr;\n\n    if (VIRTIO_NET_HDR_GSO_TCPV4 != gso_type &&\n        VIRTIO_NET_HDR_GSO_UDP != gso_type) {\n        return;\n    }\n\n    ip_hdr = pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_base;\n\n    if (pkt->payload_len + pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len >\n        ETH_MAX_IP_DGRAM_LEN) {\n        return;\n    }\n\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n        pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len);\n\n    ip_hdr->ip_sum = 0;\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n        pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n\n    ph_raw_csum = eth_calc_pseudo_hdr_csum(ip_hdr, pkt->payload_len);\n    csum = cpu_to_be16(~net_checksum_finish(ph_raw_csum));\n    iov_from_buf(&pkt->vec[VMXNET_TX_PKT_PL_START_FRAG], pkt->payload_frags,\n                 pkt->virt_hdr.csum_offset, &csum, sizeof(csum));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8921, "func": "static int vrend_renderer_transfer_send_iov(struct vrend_context *ctx,\n                                            struct vrend_resource *res,\n                                            struct iovec *iov, int num_iovs,\n                                            const struct vrend_transfer_info *info)\n{\n   if (res->target == 0 && res->ptr) {\n      uint32_t send_size = info->box->width * util_format_get_blocksize(res->base.format);\n      vrend_write_to_iovec(iov, num_iovs, info->offset, res->ptr + info->box->x, send_size);\n      return 0;\n   }\n\n   if (res->target == GL_ELEMENT_ARRAY_BUFFER_ARB ||\n       res->target == GL_ARRAY_BUFFER_ARB ||\n       res->target == GL_TRANSFORM_FEEDBACK_BUFFER ||\n       res->target == GL_TEXTURE_BUFFER ||\n       res->target == GL_UNIFORM_BUFFER) {\n      uint32_t send_size = info->box->width * util_format_get_blocksize(res->base.format);\n      void *data;\n\n      glBindBufferARB(res->target, res->id);\n      data = glMapBufferRange(res->target, info->box->x, info->box->width, GL_MAP_READ_BIT);\n      if (!data)\n         fprintf(stderr,\"unable to open buffer for reading %d\\n\", res->target);\n      else\n         vrend_write_to_iovec(iov, num_iovs, info->offset, data, send_size);\n      glUnmapBuffer(res->target);\n   } else {\n      bool can_readpixels = true;\n\n      can_readpixels = vrend_format_can_render(res->base.format) || vrend_format_is_ds(res->base.format);\n\n      if (can_readpixels) {\n         return vrend_transfer_send_readpixels(ctx, res,\n                                               iov, num_iovs, info);\n      }\n\n      return vrend_transfer_send_getteximage(ctx, res,\n                                             iov, num_iovs, info);\n\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8521, "func": "static void parse_ttymodes(Ssh ssh,\n                           void (*do_mode)(void *data,\n                                           const struct ssh_ttymode *mode,\n                                           char *val),\n\t\t\t   void *data)\n{\n    int i;\n    const struct ssh_ttymode *mode;\n    char *val;\n    char default_val[2];\n\n    strcpy(default_val, \"A\");\n\n    for (i = 0; i < lenof(ssh_ttymodes); i++) {\n        mode = ssh_ttymodes + i;\n        val = conf_get_str_str_opt(ssh->conf, CONF_ttymodes, mode->mode);\n        if (!val)\n            val = default_val;\n\n\tif (val[0] == 'A') {\n\t    val = get_ttymode(ssh->frontend, mode->mode);\n\t    if (val) {\n\t\tdo_mode(data, mode, val);\n\t\tsfree(val);\n\t    }\n\t} else\n            do_mode(data, mode, val + 1);              \n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187481, "func": "static inline int accept_server_socket(int s)\n\n {\n     struct sockaddr_un client_address;\n     socklen_t clen;\n    int fd = accept(s, (struct sockaddr*)&client_address, &clen);\n     APPL_TRACE_DEBUG(\"accepted fd:%d for server fd:%d\", fd, s);\n     return fd;\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 188533, "func": "  uint8_t* output() const {\n     return output_ + BorderTop() * kOuterBlockSize + BorderLeft();\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8466, "func": "BOOL CSoundFile::CanPackSample(LPSTR pSample, UINT nLen, UINT nPacking, BYTE *result)\n{\n\tint pos, old, oldpos, besttable = 0;\n\tDWORD dwErr, dwTotal, dwResult;\n\tint i,j;\n\n\tif (result) *result = 0;\n\tif ((!pSample) || (nLen < 1024)) return FALSE;\n\tdwResult = 0;\n\tfor (j=1; j<MAX_PACK_TABLES; j++)\n\t{\n\t\tmemcpy(CompressionTable, UnpackTable[j], 16);\n\t\tdwErr = 0;\n\t\tdwTotal = 1;\n\t\told = pos = oldpos = 0;\n\t\tfor (i=0; i<(int)nLen; i++)\n\t\t{\n\t\t\tint s = (int)pSample[i];\n\t\t\tPackSample(pos, s);\n\t\t\tdwErr += abs(pos - oldpos);\n\t\t\tdwTotal += abs(s - old);\n\t\t\told = s;\n\t\t\toldpos = pos;\n\t\t}\n\t\tdwErr = _muldiv(dwErr, 100, dwTotal);\n\t\tif (dwErr >= dwResult)\n\t\t{\n\t\t\tdwResult = dwErr;\n\t\t\tbesttable = j;\n\t\t}\n\t}\n\tmemcpy(CompressionTable, UnpackTable[besttable], 16);\n\tif (result)\n\t{\n\t\tif (dwResult > 100) *result\t= 100; else *result = (BYTE)dwResult;\n\t}\n\treturn (dwResult >= nPacking) ? TRUE : FALSE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8503, "func": "static int alloc_channel_id(Ssh ssh)\n{\n    const unsigned CHANNEL_NUMBER_OFFSET = 256;\n    unsigned low, high, mid;\n    int tsize;\n    struct ssh_channel *c;\n\n    tsize = count234(ssh->channels);\n\n    low = -1;\n    high = tsize;\n    while (high - low > 1) {\n\tmid = (high + low) / 2;\n\tc = index234(ssh->channels, mid);\n\tif (c->localid == mid + CHANNEL_NUMBER_OFFSET)\n\t    low = mid;\t\t       \n\telse\n\t    high = mid;\t\t       \n    }\n    {\n\tunsigned i = low + 1 + CHANNEL_NUMBER_OFFSET;\n\tassert(NULL == find234(ssh->channels, &i, ssh_channelfind));\n    }\n    return low + 1 + CHANNEL_NUMBER_OFFSET;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187697, "func": "static double outlog(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n if (out_depth <= 8)\n {\n if (pm->log8 == 0) \n return 256;\n\n if (out_depth < 8)\n return pm->log8 / 255 * ((1<<out_depth)-1);\n\n return pm->log8;\n }\n\n if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n {\n if (pm->log16 == 0)\n return 65536;\n\n return pm->log16;\n }\n\n if (pm->log8 == 0)\n return 65536;\n\n return pm->log8 * 257;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187848, "func": " long Cluster::HasBlockEntries(\n     const Segment* pSegment,\n     long long off,  \n long long& pos, long& len) {\n  assert(pSegment);\n  assert(off >= 0); \n\n IMkvReader* const pReader = pSegment->m_pReader;\n\n long long total, avail;\n\n long status = pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n\n  pos = pSegment->m_start + off; \n\n if ((total >= 0) && (pos >= total))\n return 0; \n\n const long long segment_stop =\n (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;\n\n long long cluster_stop = -1; \n\n {\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((total >= 0) && ((pos + len) > total))\n return 0;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long id = ReadUInt(pReader, pos, len);\n\n if (id < 0) \n return static_cast<long>(id);\n\n if (id != 0x0F43B675) \n return -1; \n\n    pos += len; \n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((total >= 0) && ((pos + len) > total))\n return 0;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n if (size == 0)\n return 0; \n\n    pos += len; \n\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size != unknown_size) {\n      cluster_stop = pos + size;\n      assert(cluster_stop >= 0);\n\n if ((segment_stop >= 0) && (cluster_stop > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((total >= 0) && (cluster_stop > total))\n return 0; \n }\n }\n\n for (;;) {\n if ((cluster_stop >= 0) && (pos >= cluster_stop))\n return 0; \n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long id = ReadUInt(pReader, pos, len);\n\n if (id < 0) \n return static_cast<long>(id);\n\n\n if (id == 0x0F43B675) \n return 0; \n\n if (id == 0x0C53BB6B) \n return 0; \n\n    pos += len; \n\n if ((cluster_stop >= 0) && (pos >= cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n    pos += len; \n\n\n if ((cluster_stop >= 0) && (pos > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if (size == 0) \n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID; \n\n if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if (id == 0x20) \n return 1; \n\n if (id == 0x23) \n\n       return 1;  \n \n     pos += size;  \n    assert((cluster_stop < 0) || (pos <= cluster_stop));\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9198, "func": "static void virtio_device_realize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(dev);\n    Error *err = NULL;\n\n    if (vdc->realize != NULL) {\n        vdc->realize(dev, &err);\n        if (err != NULL) {\n            error_propagate(errp, err);\n            return;\n        }\n    }\n\n    virtio_bus_device_plugged(vdev, &err);\n    if (err != NULL) {\n        error_propagate(errp, err);\n        return;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8413, "func": "pvscsi_hot_unplug(HotplugHandler *hotplug_dev, DeviceState *dev, Error **errp)\n{\n    PVSCSIState *s = PVSCSI(hotplug_dev);\n\n    pvscsi_send_msg(s, SCSI_DEVICE(dev), PVSCSI_MSG_DEV_REMOVED);\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187400, "func": "status_t SampleIterator::seekTo(uint32_t sampleIndex) {\n    ALOGV(\"seekTo(%d)\", sampleIndex);\n\n if (sampleIndex >= mTable->mNumSampleSizes) {\n return ERROR_END_OF_STREAM;\n }\n\n if (mTable->mSampleToChunkOffset < 0\n || mTable->mChunkOffsetOffset < 0\n || mTable->mSampleSizeOffset < 0\n || mTable->mTimeToSampleCount == 0) {\n\n return ERROR_MALFORMED;\n }\n\n if (mInitialized && mCurrentSampleIndex == sampleIndex) {\n return OK;\n }\n\n if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {\n        reset();\n }\n\n if (sampleIndex >= mStopChunkSampleIndex) {\n status_t err;\n if ((err = findChunkRange(sampleIndex)) != OK) {\n            ALOGE(\"findChunkRange failed\");\n return err;\n }\n }\n\n    CHECK(sampleIndex < mStopChunkSampleIndex);\n\n if (mSamplesPerChunk == 0) {\n        ALOGE(\"b/22802344\");\n return ERROR_MALFORMED;\n }\n\n uint32_t chunk =\n (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk\n\n         + mFirstChunk;\n \n     if (!mInitialized || chunk != mCurrentChunkIndex) {\n        mCurrentChunkIndex = chunk;\n         status_t err;\n         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {\n             ALOGE(\"getChunkOffset return error\");\n return err;\n }\n\n        mCurrentChunkSampleSizes.clear();\n\n \n         uint32_t firstChunkSampleIndex =\n             mFirstChunkSampleIndex\n                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);\n \n         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {\n             size_t sampleSize;\n             if ((err = getSampleSizeDirect(\n                             firstChunkSampleIndex + i, &sampleSize)) != OK) {\n                 ALOGE(\"getSampleSizeDirect return error\");\n                 return err;\n             }\n \n             mCurrentChunkSampleSizes.push(sampleSize);\n         }\n     }\n \n     uint32_t chunkRelativeSampleIndex =\n (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;\n\n    mCurrentSampleOffset = mCurrentChunkOffset;\n for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {\n        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];\n }\n\n    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];\n if (sampleIndex < mTTSSampleIndex) {\n        mTimeToSampleIndex = 0;\n        mTTSSampleIndex = 0;\n        mTTSSampleTime = 0;\n        mTTSCount = 0;\n        mTTSDuration = 0;\n }\n\n status_t err;\n if ((err = findSampleTimeAndDuration(\n            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {\n        ALOGE(\"findSampleTime return error\");\n return err;\n }\n\n    mCurrentSampleIndex = sampleIndex;\n\n    mInitialized = true;\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "45,57"}
{"idx": 8987, "func": "vmxnet3_dump_virt_hdr(struct virtio_net_hdr *vhdr)\n{\n    VMW_PKPRN(\"VHDR: flags 0x%x, gso_type: 0x%x, hdr_len: %d, gso_size: %d, \"\n              \"csum_start: %d, csum_offset: %d\",\n              vhdr->flags, vhdr->gso_type, vhdr->hdr_len, vhdr->gso_size,\n              vhdr->csum_start, vhdr->csum_offset);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9009, "func": "vmxnet3_init_msix(VMXNET3State *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    int res = msix_init(d, VMXNET3_MAX_INTRS,\n                        &s->msix_bar,\n                        VMXNET3_MSIX_BAR_IDX, VMXNET3_OFF_MSIX_TABLE,\n                        &s->msix_bar,\n                        VMXNET3_MSIX_BAR_IDX, VMXNET3_OFF_MSIX_PBA(s),\n                        VMXNET3_MSIX_OFFSET(s));\n\n    if (0 > res) {\n        VMW_WRPRN(\"Failed to initialize MSI-X, error %d\", res);\n        s->msix_used = false;\n    } else {\n        if (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to use MSI-X vectors, error %d\", res);\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n        } else {\n            s->msix_used = true;\n        }\n    }\n    return s->msix_used;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187689, "func": "modifier_color_encoding_is_sRGB(PNG_CONST png_modifier *pm)\n {\n    return pm->current_encoding != 0 && pm->current_encoding == pm->encodings &&\n       pm->current_encoding->gamma == pm->current_gamma;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187944, "func": "void WT_VoiceGain (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n    EAS_PCM *pInputBuffer;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I32 numSamples;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    EAS_I32 gainLeft, gainRight;\n#endif\n\n \n     numSamples = pWTIntFrame->numSamples;\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n     pInputBuffer = pWTIntFrame->pAudioBuffer;\n \n    gainIncrement = (pWTIntFrame->frame.gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    gainLeft = pWTVoice->gainLeft;\n    gainRight = pWTVoice->gainRight;\n#endif\n\n while (numSamples--) {\n\n        tmp0 = *pInputBuffer++;\n        gain += gainIncrement;\n        tmp2 = gain >> 16;\n\n        tmp2 *= tmp0;\n\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n        tmp2 = tmp2 >> 14;\n\n        tmp1 = *pMixBuffer;\n\n        tmp0 = tmp2 * gainLeft;\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n        tmp1 = *pMixBuffer;\n\n        tmp0 = tmp2 * gainRight;\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n#else\n\n        tmp1 = *pMixBuffer;\n        tmp2 = tmp2 >> (NUM_MIXER_GUARD_BITS - 1);\n        tmp1 += tmp2;\n *pMixBuffer++ = tmp1;\n#endif\n\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8691, "func": "reencode_escapes (const char *s)\n{\n  const char *p1;\n  char *newstr, *p2;\n  int oldlen, newlen;\n\n  int encode_count = 0;\n\n  for (p1 = s; *p1; p1++)\n    if (char_needs_escaping (p1))\n      ++encode_count;\n\n  if (!encode_count)\n    return (char *) s;          \n\n  oldlen = p1 - s;\n  newlen = oldlen + 2 * encode_count;\n  newstr = xmalloc (newlen + 1);\n\n  p1 = s;\n  p2 = newstr;\n\n  while (*p1)\n    if (char_needs_escaping (p1))\n      {\n        unsigned char c = *p1++;\n        *p2++ = '%';\n        *p2++ = XNUM_TO_DIGIT (c >> 4);\n        *p2++ = XNUM_TO_DIGIT (c & 0xf);\n      }\n    else\n      *p2++ = *p1++;\n\n  *p2 = '\\0';\n  assert (p2 - newstr == newlen);\n  return newstr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9006, "func": "vmxnet3_inc_tx_completion_counter(VMXNET3State *s, int qidx)\n{\n    vmxnet3_ring_inc(&s->txq_descr[qidx].comp_ring);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188132, "func": "static vpx_image_t *img_alloc_helper(vpx_image_t *img, vpx_img_fmt_t fmt,\n unsigned int d_w, unsigned int d_h,\n unsigned int buf_align,\n unsigned int stride_align,\n unsigned char *img_data) {\n unsigned int h, w, s, xcs, ycs, bps;\n unsigned int stride_in_bytes;\n int align;\n\n if (!buf_align) buf_align = 1;\n\n if (buf_align & (buf_align - 1)) goto fail;\n\n if (!stride_align) stride_align = 1;\n\n if (stride_align & (stride_align - 1)) goto fail;\n\n switch (fmt) {\n case VPX_IMG_FMT_RGB32:\n case VPX_IMG_FMT_RGB32_LE:\n case VPX_IMG_FMT_ARGB:\n case VPX_IMG_FMT_ARGB_LE: bps = 32; break;\n case VPX_IMG_FMT_RGB24:\n case VPX_IMG_FMT_BGR24: bps = 24; break;\n case VPX_IMG_FMT_RGB565:\n case VPX_IMG_FMT_RGB565_LE:\n case VPX_IMG_FMT_RGB555:\n case VPX_IMG_FMT_RGB555_LE:\n case VPX_IMG_FMT_UYVY:\n case VPX_IMG_FMT_YUY2:\n case VPX_IMG_FMT_YVYU: bps = 16; break;\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12: bps = 12; break;\n case VPX_IMG_FMT_I422:\n case VPX_IMG_FMT_I440: bps = 16; break;\n case VPX_IMG_FMT_I444: bps = 24; break;\n case VPX_IMG_FMT_I42016: bps = 24; break;\n case VPX_IMG_FMT_I42216:\n case VPX_IMG_FMT_I44016: bps = 32; break;\n case VPX_IMG_FMT_I44416: bps = 48; break;\n default: bps = 16; break;\n }\n\n switch (fmt) {\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12:\n case VPX_IMG_FMT_I422:\n case VPX_IMG_FMT_I42016:\n case VPX_IMG_FMT_I42216: xcs = 1; break;\n default: xcs = 0; break;\n }\n\n switch (fmt) {\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_I440:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12:\n case VPX_IMG_FMT_I42016:\n case VPX_IMG_FMT_I44016: ycs = 1; break;\n\n     default: ycs = 0; break;\n   }\n \n  align = (1 << xcs) - 1;\n  w = (d_w + align) & ~align;\n  align = (1 << ycs) - 1;\n  h = (d_h + align) & ~align;\n   s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;\n   s = (s + stride_align - 1) & ~(stride_align - 1);\n   stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;\n\n if (!img) {\n    img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));\n\n if (!img) goto fail;\n\n    img->self_allocd = 1;\n } else {\n    memset(img, 0, sizeof(vpx_image_t));\n }\n\n\n   img->img_data = img_data;\n \n   if (!img_data) {\n    const uint64_t alloc_size = (fmt & VPX_IMG_FMT_PLANAR)\n                                    ? (uint64_t)h * s * bps / 8\n                                    : (uint64_t)h * s;\n \n     if (alloc_size != (size_t)alloc_size) goto fail;\n \n    img->img_data = (uint8_t *)vpx_memalign(buf_align, (size_t)alloc_size);\n    img->img_data_owner = 1;\n }\n\n if (!img->img_data) goto fail;\n\n  img->fmt = fmt;\n  img->bit_depth = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 16 : 8;\n  img->w = w;\n  img->h = h;\n  img->x_chroma_shift = xcs;\n  img->y_chroma_shift = ycs;\n  img->bps = bps;\n\n  img->stride[VPX_PLANE_Y] = img->stride[VPX_PLANE_ALPHA] = stride_in_bytes;\n  img->stride[VPX_PLANE_U] = img->stride[VPX_PLANE_V] = stride_in_bytes >> xcs;\n\n if (!vpx_img_set_rect(img, 0, 0, d_w, d_h)) return img;\n\nfail:\n  vpx_img_free(img);\n return NULL;\n}\n", "target": 1, "flaw_line_index": "68,69,70,71,72,91,92,93"}
{"idx": 187387, "func": " virtual ssize_t readAt(off64_t offset, void *buffer, size_t size) {\n Parcel data, reply;\n        data.writeInterfaceToken(\n IMediaHTTPConnection::getInterfaceDescriptor());\n\n        data.writeInt64(offset);\n        data.writeInt32(size);\n\n status_t err = remote()->transact(READ_AT, data, &reply);\n if (err != OK) {\n            ALOGE(\"remote readAt failed\");\n return UNKNOWN_ERROR;\n }\n\n int32_t exceptionCode = reply.readExceptionCode();\n\n if (exceptionCode) {\n\n             return UNKNOWN_ERROR;\n         }\n \n        int32_t len = reply.readInt32();\n \n        if (len > 0) {\n            memcpy(buffer, mMemory->pointer(), len);\n         }\n \n         return len;\n     }\n", "target": 1, "flaw_line_index": "22,24,25"}
{"idx": 187530, "func": "void CameraSource::dataCallbackTimestamp(int64_t timestampUs,\n int32_t msgType __unused, const sp<IMemory> &data) {\n    ALOGV(\"dataCallbackTimestamp: timestamp %lld us\", (long long)timestampUs);\n Mutex::Autolock autoLock(mLock);\n if (!mStarted || (mNumFramesReceived == 0 && timestampUs < mStartTimeUs)) {\n        ALOGV(\"Drop frame at %lld/%lld us\", (long long)timestampUs, (long long)mStartTimeUs);\n        releaseOneRecordingFrame(data);\n return;\n }\n\n if (skipCurrentFrame(timestampUs)) {\n        releaseOneRecordingFrame(data);\n return;\n }\n\n if (mNumFramesReceived > 0) {\n if (timestampUs <= mLastFrameTimestampUs) {\n            ALOGW(\"Dropping frame with backward timestamp %lld (last %lld)\",\n (long long)timestampUs, (long long)mLastFrameTimestampUs);\n            releaseOneRecordingFrame(data);\n return;\n }\n if (timestampUs - mLastFrameTimestampUs > mGlitchDurationThresholdUs) {\n ++mNumGlitches;\n }\n }\n\n    mLastFrameTimestampUs = timestampUs;\n if (mNumFramesReceived == 0) {\n        mFirstFrameTimeUs = timestampUs;\n if (mStartTimeUs > 0) {\n if (timestampUs < mStartTimeUs) {\n                releaseOneRecordingFrame(data);\n return;\n }\n            mStartTimeUs = timestampUs - mStartTimeUs;\n }\n }\n\n     ++mNumFramesReceived;\n \n     CHECK(data != NULL && data->size() > 0);\n     mFramesReceived.push_back(data);\n     int64_t timeUs = mStartTimeUs + (timestampUs - mFirstFrameTimeUs);\n     mFrameTimes.push_back(timeUs);\n    ALOGV(\"initial delay: %\" PRId64 \", current time stamp: %\" PRId64,\n        mStartTimeUs, timeUs);\n    mFrameAvailableCondition.signal();\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8323, "func": "XNewModifiermap(int keyspermodifier)\n{\n    XModifierKeymap *res = Xmalloc((sizeof (XModifierKeymap)));\n    if (res) {\n\tres->max_keypermod = keyspermodifier;\n\tres->modifiermap = (keyspermodifier > 0 ?\n\t\t\t    Xmalloc(8 * keyspermodifier)\n\t\t\t    : (KeyCode *) NULL);\n\tif (keyspermodifier && (res->modifiermap == NULL)) {\n\t    Xfree(res);\n\t    return (XModifierKeymap *) NULL;\n\t}\n    }\n    return (res);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9079, "func": "static bool vmxnet3_verify_driver_magic(PCIDevice *d, hwaddr dshmem)\n{\n    return (VMXNET3_READ_DRV_SHARED32(d, dshmem, magic) == VMXNET3_REV1_MAGIC);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187846, "func": "long long mkvparser::GetUIntLength(IMkvReader* pReader, long long pos,\n                                   long& len) {\n  assert(pReader);\n  assert(pos >= 0);\n \n   long long total, available;\n \n   int status = pReader->Length(&total, &available);\n  assert(status >= 0);\n  assert((total < 0) || (available <= total));\n \n   len = 1;\n \n if (pos >= available)\n return pos; \n\n unsigned char b;\n\n \n   status = pReader->Read(pos, 1, &b);\n \n  if (status < 0)\n     return status;\n \n  assert(status == 0);\n   if (b == 0)  \n     return E_FILE_FORMAT_INVALID;\n \n unsigned char m = 0x80;\n\n while (!(b & m)) {\n    m >>= 1;\n ++len;\n }\n\n return 0; \n}\n", "target": 1, "flaw_line_index": "2,3,4,9,10,22,25"}
{"idx": 9075, "func": "vmxnet3_use_msix_vectors(VMXNET3State *s, int num_vectors)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    int i;\n    for (i = 0; i < num_vectors; i++) {\n        int res = msix_vector_use(d, i);\n        if (0 > res) {\n            VMW_WRPRN(\"Failed to use MSI-X vector %d, error %d\", i, res);\n            vmxnet3_unuse_msix_vectors(s, i);\n            return false;\n        }\n    }\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188537, "func": "   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) / tb.den;\n     duration_ = 0;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8752, "func": "static void log_option(const char *pfx, const uint8_t *opt)\n{\n\tif (dhcp_verbose >= 2) {\n\t\tchar buf[256 * 2 + 2];\n\t\t*bin2hex(buf, (void*) (opt + OPT_DATA), opt[OPT_LEN]) = '\\0';\n\t\tbb_error_msg(\"%s: 0x%02x %s\", pfx, opt[OPT_CODE], buf);\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187444, "func": "static int a2dp_command(struct a2dp_stream_common *common, char cmd)\n{\n char ack;\n\n\n     DEBUG(\"A2DP COMMAND %s\", dump_a2dp_ctrl_event(cmd));\n \n    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)\n     {\n         ERROR(\"cmd failed (%s)\", strerror(errno));\n         skt_disconnect(common->ctrl_fd);\n        common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n return -1;\n }\n\n if (a2dp_ctrl_receive(common, &ack, 1) < 0)\n return -1;\n\n    DEBUG(\"A2DP COMMAND %s DONE STATUS %d\", dump_a2dp_ctrl_event(cmd), ack);\n\n if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)\n return ack;\n if (ack != A2DP_CTRL_ACK_SUCCESS)\n return -1;\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 8667, "func": "size_t mptsas_config_sas_io_unit_2(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK_EXT(2, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x06,\n                                  \"*b*b*w*w*w*b*b*w\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9127, "func": "static int vrend_decode_set_vertex_buffers(struct vrend_decode_ctx *ctx, uint16_t length)\n{\n   int num_vbo;\n   int i;\n\n   if (length && (length % 3))\n      return EINVAL;\n\n   num_vbo = (length / 3);\n   if (num_vbo > PIPE_MAX_ATTRIBS)\n      return EINVAL;\n\n   for (i = 0; i < num_vbo; i++) {\n      vrend_set_single_vbo(ctx->grctx, i,\n                           get_buf_entry(ctx, VIRGL_SET_VERTEX_BUFFER_STRIDE(i)),\n                           get_buf_entry(ctx, VIRGL_SET_VERTEX_BUFFER_OFFSET(i)),\n                           get_buf_entry(ctx, VIRGL_SET_VERTEX_BUFFER_HANDLE(i)));\n   }\n   vrend_set_num_vbo(ctx->grctx, num_vbo);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8909, "func": "vrend_renderer_object_destroy(struct vrend_context *ctx, uint32_t handle)\n{\n   vrend_object_remove(ctx->sub->object_hash, handle, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8414, "func": "pvscsi_hotplug(HotplugHandler *hotplug_dev, DeviceState *dev, Error **errp)\n{\n    PVSCSIState *s = PVSCSI(hotplug_dev);\n\n    pvscsi_send_msg(s, SCSI_DEVICE(dev), PVSCSI_MSG_DEV_ADDED);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187998, "func": "status_t MyOpusExtractor::readNextPacket(MediaBuffer **out) {\n if (mOffset <= mFirstDataOffset && mStartGranulePosition < 0) {\n MediaBuffer *mBuf;\n uint32_t numSamples = 0;\n uint64_t curGranulePosition = 0;\n while (true) {\n status_t err = _readNextPacket(&mBuf, \nfalse);\n if (err != OK && err != ERROR_END_OF_STREAM) {\n return err;\n\n             }\n             if (err == ERROR_END_OF_STREAM || mCurrentPage.mPageNo > 2) {\n                 break;\n             }\n             curGranulePosition = mCurrentPage.mGranulePosition;\n            numSamples += getNumSamplesInPacket(mBuf);\n            mBuf->release();\n            mBuf = NULL;\n }\n\n if (curGranulePosition > numSamples) {\n            mStartGranulePosition = curGranulePosition - numSamples;\n } else {\n            mStartGranulePosition = 0;\n }\n        seekToOffset(0);\n }\n\n status_t err = _readNextPacket(out, \nfalse);\n if (err != OK) {\n return err;\n }\n\n int32_t currentPageSamples;\n if ((*out)->meta_data()->findInt32(kKeyValidSamples, &currentPageSamples)) {\n if (mOffset == mFirstDataOffset) {\n            currentPageSamples -= mStartGranulePosition;\n (*out)->meta_data()->setInt32(kKeyValidSamples, currentPageSamples);\n }\n        mCurGranulePosition = mCurrentPage.mGranulePosition - currentPageSamples;\n }\n\n int64_t timeUs = getTimeUsOfGranule(mCurGranulePosition);\n (*out)->meta_data()->setInt64(kKeyTime, timeUs);\n\n uint32_t frames = getNumSamplesInPacket(*out);\n    mCurGranulePosition += frames;\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188204, "func": "void SoftHEVC::setDecodeArgs(ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n         OMX_BUFFERHEADERTYPE *outHeader,\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer = inHeader->pBuffer\n + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY / 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n", "target": 1, "flaw_line_index": "8,27,28,29,30,31,41"}
{"idx": 187345, "func": "xsltCopyTextString(xsltTransformContextPtr ctxt, xmlNodePtr target,\n\t           const xmlChar *string, int noescape)\n{\n    xmlNodePtr copy;\n    int len;\n\n    if (string == NULL)\n\treturn(NULL);\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltCopyTextString: copy text %s\\n\",\n\t\t     string));\n#endif\n\n    if ((target == NULL) || (target->children == NULL)) {\n\tctxt->lasttext = NULL;\n    }\n\n    len = xmlStrlen(string);\n    if ((ctxt->type == XSLT_OUTPUT_XML) &&\n\t(ctxt->style->cdataSection != NULL) &&\n\t(target != NULL) &&\n\t(target->type == XML_ELEMENT_NODE) &&\n\t(((target->ns == NULL) &&\n\t  (xmlHashLookup2(ctxt->style->cdataSection,\n\t\t          target->name, NULL) != NULL)) ||\n\t ((target->ns != NULL) &&\n\t  (xmlHashLookup2(ctxt->style->cdataSection,\n\t                  target->name, target->ns->href) != NULL))))\n    {\n\tif ((target->last != NULL) &&\n\t    (target->last->type == XML_CDATA_SECTION_NODE))\n\t{\n\t    return(xsltAddTextString(ctxt, target->last, string, len));\n\t}\n\tcopy = xmlNewCDataBlock(ctxt->output, string, len);\n    } else if (noescape) {\n\tif ((target != NULL) && (target->last != NULL) &&\n\t    (target->last->type == XML_TEXT_NODE) &&\n\t    (target->last->name == xmlStringTextNoenc))\n\t{\n\t    return(xsltAddTextString(ctxt, target->last, string, len));\n\t}\n\tcopy = xmlNewTextLen(string, len);\n\tif (copy != NULL)\n\t    copy->name = xmlStringTextNoenc;\n    } else {\n\tif ((target != NULL) && (target->last != NULL) &&\n\t    (target->last->type == XML_TEXT_NODE) &&\n\t    (target->last->name == xmlStringText)) {\n\t    return(xsltAddTextString(ctxt, target->last, string, len));\n \t}\n \tcopy = xmlNewTextLen(string, len);\n     }\n     if (copy != NULL) {\n\tif (target != NULL)\n\t    copy = xsltAddChild(target, copy);\n \tctxt->lasttext = copy->content;\n \tctxt->lasttsize = len;\n \tctxt->lasttuse = len;\n    } else {\n\txsltTransformError(ctxt, NULL, target,\n\t\t\t \"xsltCopyTextString: text copy failed\\n\");\n\tctxt->lasttext = NULL;\n    }\n    return(copy);\n}\n", "target": 1, "flaw_line_index": "57,58"}
{"idx": 9037, "func": "static void vmxnet3_put_rxq_descr(QEMUFile *f, void *pv, size_t size)\n{\n    Vmxnet3RxqDescr *r = pv;\n    int i;\n\n    for (i = 0; i < VMXNET3_RX_RINGS_PER_QUEUE; i++) {\n        vmxnet3_put_ring_to_file(f, &r->rx_ring[i]);\n    }\n\n    vmxnet3_put_ring_to_file(f, &r->comp_ring);\n    qemu_put_byte(f, r->intr_idx);\n    qemu_put_be64(f, r->rx_stats_pa);\n    vmxnet3_put_rx_stats_to_file(f, &r->rxq_stats);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8789, "func": "static bool check_iov_bounds(struct vrend_resource *res,\n                             const struct vrend_transfer_info *info,\n                             struct iovec *iov, int num_iovs)\n{\n   GLuint send_size;\n   GLuint iovsize = vrend_get_iovec_size(iov, num_iovs);\n   GLuint valid_stride, valid_layer_stride;\n\n   valid_stride = util_format_get_stride(res->base.format, info->box->width);\n   if (info->stride) {\n      if (info->box->height > 1) {\n         if (info->stride < valid_stride)\n            return false;\n         valid_stride = info->stride;\n      }\n   }\n\n   valid_layer_stride = util_format_get_2d_size(res->base.format, valid_stride,\n                                                info->box->height);\n\n   if (info->layer_stride) {\n      if ((res->base.target != PIPE_TEXTURE_3D &&\n           res->base.target != PIPE_TEXTURE_CUBE &&\n           res->base.target != PIPE_TEXTURE_1D_ARRAY &&\n           res->base.target != PIPE_TEXTURE_2D_ARRAY &&\n           res->base.target != PIPE_TEXTURE_CUBE_ARRAY))\n         return false;\n\n      if (info->box->depth > 1) {\n         if (info->layer_stride < valid_layer_stride)\n            return false;\n         valid_layer_stride = info->layer_stride;\n      }\n   }\n\n   send_size = valid_layer_stride * info->box->depth;\n   if (iovsize < info->offset)\n      return false;\n   if (iovsize < send_size)\n      return false;\n   if (iovsize < info->offset + send_size)\n      return false;\n\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8616, "func": "static uint64_t vmsvga_io_read(void *opaque, hwaddr addr, unsigned size)\n{\n    struct vmsvga_state_s *s = opaque;\n\n    switch (addr) {\n    case SVGA_IO_MUL * SVGA_INDEX_PORT: return vmsvga_index_read(s, addr);\n    case SVGA_IO_MUL * SVGA_VALUE_PORT: return vmsvga_value_read(s, addr);\n    case SVGA_IO_MUL * SVGA_BIOS_PORT: return vmsvga_bios_read(s, addr);\n    default: return -1u;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187581, "func": "char* dexOptGenerateCacheFileName(const char* fileName, const char* subFileName)\n{\n char nameBuf[512];\n char absoluteFile[sizeof(nameBuf)];\n const size_t kBufLen = sizeof(nameBuf) - 1;\n const char* dataRoot;\n char* cp;\n\n    absoluteFile[0] = '\\0';\n if (fileName[0] != '/') {\n if (getcwd(absoluteFile, kBufLen) == NULL) {\n\n             ALOGE(\"Can't get CWD while opening jar file\");\n             return NULL;\n         }\n        strncat(absoluteFile, \"/\", kBufLen);\n     }\n    strncat(absoluteFile, fileName, kBufLen);\n \n     if (subFileName != NULL) {\n        strncat(absoluteFile, \"/\", kBufLen);\n        strncat(absoluteFile, subFileName, kBufLen);\n     }\n \n    cp = absoluteFile + 1;\n while (*cp != '\\0') {\n if (*cp == '/') {\n *cp = '@';\n }\n        cp++;\n }\n\n    dataRoot = getenv(\"ANDROID_DATA\");\n if (dataRoot == NULL)\n        dataRoot = \"/data\";\n    snprintf(nameBuf, kBufLen, \"%s/%s\", dataRoot, kCacheDirectoryName);\n if (strcmp(dataRoot, \"/data\") != 0) {\n int result = dexOptMkdir(nameBuf, 0700);\n if (result != 0 && errno != EEXIST) {\n            ALOGE(\"Failed to create dalvik-cache directory %s: %s\", nameBuf, strerror(errno));\n return NULL;\n }\n }\n    snprintf(nameBuf, kBufLen, \"%s/%s/%s\", dataRoot, kCacheDirectoryName, kInstructionSet);\n if (strcmp(dataRoot, \"/data\") != 0) {\n int result = dexOptMkdir(nameBuf, 0700);\n if (result != 0 && errno != EEXIST) {\n            ALOGE(\"Failed to create dalvik-cache directory %s: %s\", nameBuf, strerror(errno));\n return NULL;\n }\n }\n\n \n    strncat(nameBuf, absoluteFile, kBufLen);\n \n     ALOGV(\"Cache file for '%s' '%s' is '%s'\", fileName, subFileName, nameBuf);\n     return strdup(nameBuf);\n}\n", "target": 1, "flaw_line_index": "16,18,21,22,54"}
{"idx": 8776, "func": "int send_release(uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\n\tinit_packet(&packet, DHCPRELEASE);\n\n\tpacket.ciaddr = ciaddr;\n\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\n\tbb_error_msg(\"sending %s\", \"release\");\n\treturn bcast_or_ucast(&packet, ciaddr, server);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8427, "func": "pvscsi_on_cmd_setup_rings(PVSCSIState *s)\n{\n    PVSCSICmdDescSetupRings *rc =\n        (PVSCSICmdDescSetupRings *) s->curr_cmd_data;\n\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_SETUP_RINGS\");\n\n    if (!rc->reqRingNumPages\n        || rc->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES\n        || !rc->cmpRingNumPages\n        || rc->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES) {\n        return PVSCSI_COMMAND_PROCESSING_FAILED;\n    }\n\n    pvscsi_dbg_dump_tx_rings_config(rc);\n    pvscsi_ring_init_data(&s->rings, rc);\n\n    s->rings_info_valid = TRUE;\n    return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8793, "func": "static inline int conv_dst_blend(int blend_factor)\n{\n   if (blend_factor == PIPE_BLENDFACTOR_DST_ALPHA)\n      return PIPE_BLENDFACTOR_ONE;\n   if (blend_factor == PIPE_BLENDFACTOR_INV_DST_ALPHA)\n      return PIPE_BLENDFACTOR_ZERO;\n   return blend_factor;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188200, "func": "void SoftAVC::onQueueFilled(OMX_U32 \n) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (mEOSStatus == OUTPUT_FRAMES_FLUSHED) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n if (mHeadersDecoded) {\n\n        drainAllOutputBuffers(false \n);\n }\n\n    H264SwDecRet ret = H264SWDEC_PIC_RDY;\n bool portWillReset = false;\n while ((mEOSStatus != INPUT_DATA_AVAILABLE || !inQueue.empty())\n && outQueue.size() == kNumOutputBuffers) {\n\n if (mEOSStatus == INPUT_EOS_SEEN) {\n            drainAllOutputBuffers(true \n);\n return;\n }\n\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n ++mPicId;\n\n        OMX_BUFFERHEADERTYPE *header = new OMX_BUFFERHEADERTYPE;\n        memset(header, 0, sizeof(OMX_BUFFERHEADERTYPE));\n        header->nTimeStamp = inHeader->nTimeStamp;\n        header->nFlags = inHeader->nFlags;\n if (header->nFlags & OMX_BUFFERFLAG_EOS) {\n            mEOSStatus = INPUT_EOS_SEEN;\n }\n        mPicToHeaderMap.add(mPicId, header);\n        inQueue.erase(inQueue.begin());\n\n        H264SwDecInput inPicture;\n        H264SwDecOutput outPicture;\n        memset(&inPicture, 0, sizeof(inPicture));\n        inPicture.dataLen = inHeader->nFilledLen;\n        inPicture.pStream = inHeader->pBuffer + inHeader->nOffset;\n        inPicture.picId = mPicId;\n        inPicture.intraConcealmentMethod = 1;\n        H264SwDecPicture decodedPicture;\n\n while (inPicture.dataLen > 0) {\n            ret = H264SwDecDecode(mHandle, &inPicture, &outPicture);\n if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY ||\n                ret == H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY) {\n                inPicture.dataLen -= (u32)(outPicture.pStrmCurrPos - inPicture.pStream);\n                inPicture.pStream = outPicture.pStrmCurrPos;\n if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY) {\n                    mHeadersDecoded = true;\n                    H264SwDecInfo decoderInfo;\n                    CHECK(H264SwDecGetInfo(mHandle, &decoderInfo) == H264SWDEC_OK);\n\n SoftVideoDecoderOMXComponent::CropSettingsMode cropSettingsMode =\n                        handleCropParams(decoderInfo);\n                    handlePortSettingsChange(\n &portWillReset, decoderInfo.picWidth, decoderInfo.picHeight,\n                            cropSettingsMode);\n }\n } else {\n if (portWillReset) {\n if (H264SwDecNextPicture(mHandle, &decodedPicture, 0)\n == H264SWDEC_PIC_RDY) {\n\n                        saveFirstOutputBuffer(\n                            decodedPicture.picId,\n (uint8_t *)decodedPicture.pOutputPicture);\n }\n }\n                inPicture.dataLen = 0;\n if (ret < 0) {\n                    ALOGE(\"Decoder failed: %d\", ret);\n\n                    notify(OMX_EventError, OMX_ErrorUndefined,\n                           ERROR_MALFORMED, NULL);\n\n                    mSignalledError = true;\n return;\n }\n }\n }\n        inInfo->mOwnedByUs = false;\n        notifyEmptyBufferDone(inHeader);\n\n if (portWillReset) {\n return;\n\n         }\n \n         if (mFirstPicture && !outQueue.empty()) {\n            drainOneOutputBuffer(mFirstPictureId, mFirstPicture);\n             delete[] mFirstPicture;\n             mFirstPicture = NULL;\n             mFirstPictureId = -1;\n }\n\n        drainAllOutputBuffers(false \n);\n }\n}\n", "target": 1, "flaw_line_index": "109"}
{"idx": 187552, "func": "bool OMXNodeInstance::handleMessage(omx_message &msg) {\n const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());\n\n \n     if (msg.type == omx_message::FILL_BUFFER_DONE) {\n         OMX_BUFFERHEADERTYPE *buffer =\n            findBufferHeader(msg.u.extended_buffer_data.buffer);\n \n         {\n             Mutex::Autolock _l(mDebugLock);\n            mOutputBuffersWithCodec.remove(buffer);\n\n            CLOG_BUMPED_BUFFER(\n                    FBD, WITH_STATS(FULL_BUFFER(\n                            msg.u.extended_buffer_data.buffer, buffer, msg.fenceFd)));\n\n            unbumpDebugLevel_l(kPortIndexOutput);\n }\n\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(buffer->pAppPrivate);\n\n if (buffer->nOffset + buffer->nFilledLen < buffer->nOffset\n || buffer->nOffset + buffer->nFilledLen > buffer->nAllocLen) {\n            CLOG_ERROR(onFillBufferDone, OMX_ErrorBadParameter,\n                    FULL_BUFFER(NULL, buffer, msg.fenceFd));\n }\n        buffer_meta->CopyFromOMX(buffer);\n\n if (bufferSource != NULL) {\n            bufferSource->codecBufferFilled(buffer);\n\n            msg.u.extended_buffer_data.timestamp = buffer->nTimeStamp;\n\n         }\n     } else if (msg.type == omx_message::EMPTY_BUFFER_DONE) {\n         OMX_BUFFERHEADERTYPE *buffer =\n            findBufferHeader(msg.u.buffer_data.buffer);\n \n         {\n             Mutex::Autolock _l(mDebugLock);\n            mInputBuffersWithCodec.remove(buffer);\n\n            CLOG_BUMPED_BUFFER(\n                    EBD, WITH_STATS(EMPTY_BUFFER(msg.u.buffer_data.buffer, buffer, msg.fenceFd)));\n }\n\n if (bufferSource != NULL) {\n            bufferSource->codecBufferEmptied(buffer, msg.fenceFd);\n return true;\n }\n }\n\n return false;\n}\n", "target": 1, "flaw_line_index": "7,39"}
{"idx": 187368, "func": " int LELib_Create(const effect_uuid_t *uuid,\n                         int32_t sessionId,\n                         int32_t ioId,\n                          effect_handle_t *pHandle) {\n     ALOGV(\"LELib_Create()\");\n     int ret;\n int i;\n\n if (pHandle == NULL || uuid == NULL) {\n return -EINVAL;\n }\n\n if (memcmp(uuid, &gLEDescriptor.uuid, sizeof(effect_uuid_t)) != 0) {\n return -EINVAL;\n }\n\n LoudnessEnhancerContext *pContext = new LoudnessEnhancerContext;\n\n    pContext->mItfe = &gLEInterface;\n    pContext->mState = LOUDNESS_ENHANCER_STATE_UNINITIALIZED;\n\n    pContext->mCompressor = NULL;\n    ret = LE_init(pContext);\n if (ret < 0) {\n        ALOGW(\"LELib_Create() init failed\");\n delete pContext;\n return ret;\n }\n\n *pHandle = (effect_handle_t)pContext;\n\n    pContext->mState = LOUDNESS_ENHANCER_STATE_INITIALIZED;\n\n    ALOGV(\"  LELib_Create context is %p\", pContext);\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8801, "func": "static GLenum get_gs_xfb_mode(GLenum mode)\n{\n   switch (mode) {\n   case GL_POINTS:\n      return GL_POINTS;\n   case GL_LINE_STRIP:\n      return GL_LINES;\n   case GL_TRIANGLE_STRIP:\n      return GL_TRIANGLES;\n   default:\n      fprintf(stderr, \"illegal gs transform feedback mode %d\\n\", mode);\n      return GL_POINTS;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8578, "func": "static void *ssh_pkt_getdata(struct Packet *pkt, int length)\n{\n    if (pkt->length - pkt->savedpos < length)\n\treturn NULL;\n    pkt->savedpos += length;\n    return pkt->body + (pkt->savedpos - length);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8676, "func": "pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n{\n    uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n\n    if (ready_ptr != mgr->consumed_ptr) {\n        uint32_t next_ready_ptr =\n            mgr->consumed_ptr++ & mgr->txr_len_mask;\n        uint32_t next_ready_page =\n            next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n        uint32_t inpage_idx =\n            next_ready_ptr % PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8855, "func": "static void vrend_draw_bind_ubo(struct vrend_context *ctx)\n{\n   int i;\n   int ubo_id;\n   int shader_type;\n\n   ubo_id = 0;\n   for (shader_type = PIPE_SHADER_VERTEX; shader_type <= ctx->sub->last_shader_idx; shader_type++) {\n      uint32_t mask;\n      int shader_ubo_idx = 0;\n      struct pipe_constant_buffer *cb;\n      struct vrend_resource *res;\n      if (!ctx->sub->const_bufs_used_mask[shader_type])\n         continue;\n\n      if (!ctx->sub->prog->ubo_locs[shader_type])\n         continue;\n\n      mask = ctx->sub->const_bufs_used_mask[shader_type];\n      while (mask) {\n         i = u_bit_scan(&mask);\n\n         cb = &ctx->sub->cbs[shader_type][i];\n         res = (struct vrend_resource *)cb->buffer;\n         glBindBufferRange(GL_UNIFORM_BUFFER, ubo_id, res->id,\n                           cb->buffer_offset, cb->buffer_size);\n         glUniformBlockBinding(ctx->sub->prog->id, ctx->sub->prog->ubo_locs[shader_type][shader_ubo_idx], ubo_id);\n         shader_ubo_idx++;\n         ubo_id++;\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188109, "func": "VOID ixheaacd_esbr_postradixcompute2(WORD32 *ptr_y, WORD32 *ptr_x,\n const WORD32 *pdig_rev_tbl,\n                                     WORD32 npoints) {\n  WORD32 i, k;\n  WORD32 h2;\n\n   WORD32 x_0, x_1, x_2, x_3;\n   WORD32 x_4, x_5, x_6, x_7;\n   WORD32 x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;\n  WORD32 n00, n10, n20, n30, n01, n11, n21, n31;\n  WORD32 n02, n12, n22, n32, n03, n13, n23, n33;\n   WORD32 n0, j0;\n   WORD32 *x2, *x0;\n   WORD32 *y0, *y1, *y2, *y3;\n\n  y0 = ptr_y;\n  y2 = ptr_y + (WORD32)npoints;\n  x0 = ptr_x;\n  x2 = ptr_x + (WORD32)(npoints >> 1);\n\n  y1 = y0 + (WORD32)(npoints >> 2);\n  y3 = y2 + (WORD32)(npoints >> 2);\n  j0 = 8;\n  n0 = npoints >> 1;\n\n for (k = 0; k < 2; k++) {\n for (i = 0; i<npoints>> 1; i += 8) {\n      h2 = *pdig_rev_tbl++ >> 2;\n\n      x_0 = *x0++;\n      x_1 = *x0++;\n      x_2 = *x0++;\n      x_3 = *x0++;\n      x_4 = *x0++;\n      x_5 = *x0++;\n\n       x_6 = *x0++;\n       x_7 = *x0++;\n \n      n00 = x_0 + x_2;\n      n01 = x_1 + x_3;\n      n20 = x_0 - x_2;\n      n21 = x_1 - x_3;\n      n10 = x_4 + x_6;\n      n11 = x_5 + x_7;\n      n30 = x_4 - x_6;\n      n31 = x_5 - x_7;\n      y0[h2] = n00;\n      y0[h2 + 1] = n01;\n      y1[h2] = n10;\n      y1[h2 + 1] = n11;\n      y2[h2] = n20;\n      y2[h2 + 1] = n21;\n      y3[h2] = n30;\n      y3[h2 + 1] = n31;\n \n       x_8 = *x2++;\n       x_9 = *x2++;\n      x_a = *x2++;\n      x_b = *x2++;\n      x_c = *x2++;\n      x_d = *x2++;\n\n       x_e = *x2++;\n       x_f = *x2++;\n \n      n02 = x_8 + x_a;\n      n03 = x_9 + x_b;\n      n22 = x_8 - x_a;\n      n23 = x_9 - x_b;\n      n12 = x_c + x_e;\n      n13 = x_d + x_f;\n      n32 = x_c - x_e;\n      n33 = x_d - x_f;\n      y0[h2 + 2] = n02;\n      y0[h2 + 3] = n03;\n      y1[h2 + 2] = n12;\n      y1[h2 + 3] = n13;\n      y2[h2 + 2] = n22;\n      y2[h2 + 3] = n23;\n      y3[h2 + 2] = n32;\n      y3[h2 + 3] = n33;\n     }\n     x0 += (WORD32)npoints >> 1;\n     x2 += (WORD32)npoints >> 1;\n }\n}\n", "target": 1, "flaw_line_index": "10,11,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82"}
{"idx": 187533, "func": "status_t StreamingProcessor::processRecordingFrame() {\n    ATRACE_CALL();\n status_t res;\n    sp<Camera2Heap> recordingHeap;\n size_t heapIdx = 0;\n nsecs_t timestamp;\n\n    sp<Camera2Client> client = mClient.promote();\n if (client == 0) {\n BufferItem imgBuffer;\n        res = mRecordingConsumer->acquireBuffer(&imgBuffer, 0);\n if (res != OK) {\n if (res != BufferItemConsumer::NO_BUFFER_AVAILABLE) {\n                ALOGE(\"%s: Camera %d: Can't acquire recording buffer: %s (%d)\",\n                        __FUNCTION__, mId, strerror(-res), res);\n }\n return res;\n }\n        mRecordingConsumer->releaseBuffer(imgBuffer);\n return OK;\n }\n\n {\n SharedParameters::Lock l(client->getParameters());\n Mutex::Autolock m(mMutex);\n BufferItem imgBuffer;\n        res = mRecordingConsumer->acquireBuffer(&imgBuffer, 0);\n if (res != OK) {\n if (res != BufferItemConsumer::NO_BUFFER_AVAILABLE) {\n                ALOGE(\"%s: Camera %d: Can't acquire recording buffer: %s (%d)\",\n                        __FUNCTION__, mId, strerror(-res), res);\n }\n return res;\n }\n        timestamp = imgBuffer.mTimestamp;\n\n        mRecordingFrameCount++;\n        ALOGVV(\"OnRecordingFrame: Frame %d\", mRecordingFrameCount);\n\n if (l.mParameters.state != Parameters::RECORD &&\n                l.mParameters.state != Parameters::VIDEO_SNAPSHOT) {\n            ALOGV(\"%s: Camera %d: Discarding recording image buffers \"\n \"received after recording done\", __FUNCTION__,\n                    mId);\n            mRecordingConsumer->releaseBuffer(imgBuffer);\n return INVALID_OPERATION;\n }\n\n if (mRecordingHeap == 0) {\n size_t payloadSize = sizeof(VideoNativeMetadata);\n            ALOGV(\"%s: Camera %d: Creating recording heap with %zu buffers of \"\n \"size %zu bytes\", __FUNCTION__, mId,\n                    mRecordingHeapCount, payloadSize);\n\n            mRecordingHeap = new Camera2Heap(payloadSize, mRecordingHeapCount,\n \"Camera2Client::RecordingHeap\");\n if (mRecordingHeap->mHeap->getSize() == 0) {\n                ALOGE(\"%s: Camera %d: Unable to allocate memory for recording\",\n                        __FUNCTION__, mId);\n                mRecordingConsumer->releaseBuffer(imgBuffer);\n return NO_MEMORY;\n }\n for (size_t i = 0; i < mRecordingBuffers.size(); i++) {\n if (mRecordingBuffers[i].mBuf !=\n BufferItemConsumer::INVALID_BUFFER_SLOT) {\n                    ALOGE(\"%s: Camera %d: Non-empty recording buffers list!\",\n                            __FUNCTION__, mId);\n }\n }\n            mRecordingBuffers.clear();\n            mRecordingBuffers.setCapacity(mRecordingHeapCount);\n            mRecordingBuffers.insertAt(0, mRecordingHeapCount);\n\n            mRecordingHeapHead = 0;\n            mRecordingHeapFree = mRecordingHeapCount;\n }\n\n if (mRecordingHeapFree == 0) {\n            ALOGE(\"%s: Camera %d: No free recording buffers, dropping frame\",\n                    __FUNCTION__, mId);\n            mRecordingConsumer->releaseBuffer(imgBuffer);\n return NO_MEMORY;\n }\n\n        heapIdx = mRecordingHeapHead;\n        mRecordingHeapHead = (mRecordingHeapHead + 1) % mRecordingHeapCount;\n        mRecordingHeapFree--;\n\n        ALOGVV(\"%s: Camera %d: Timestamp %lld\",\n                __FUNCTION__, mId, timestamp);\n\n ssize_t offset;\n size_t size;\n        sp<IMemoryHeap> heap =\n                mRecordingHeap->mBuffers[heapIdx]->getMemory(&offset,\n &size);\n\n VideoNativeMetadata *payload = reinterpret_cast<VideoNativeMetadata*>(\n\n             (uint8_t*)heap->getBase() + offset);\n         payload->eType = kMetadataBufferTypeANWBuffer;\n         payload->pBuffer = imgBuffer.mGraphicBuffer->getNativeBuffer();\n         payload->nFenceFd = -1;\n \n         ALOGVV(\"%s: Camera %d: Sending out ANWBuffer %p\",\n                __FUNCTION__, mId, payload->pBuffer);\n\n        mRecordingBuffers.replaceAt(imgBuffer, heapIdx);\n        recordingHeap = mRecordingHeap;\n }\n\n Camera2Client::SharedCameraCallbacks::Lock l(client->mSharedCameraCallbacks);\n if (l.mRemoteCallback != 0) {\n        l.mRemoteCallback->dataCallbackTimestamp(timestamp,\n                CAMERA_MSG_VIDEO_FRAME,\n                recordingHeap->mBuffers[heapIdx]);\n } else {\n        ALOGW(\"%s: Camera %d: Remote callback gone\", __FUNCTION__, mId);\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187380, "func": "OMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {\n    return (OMX::buffer_id)bufferHeader;\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 9182, "func": "uint32_t virtio_config_modern_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldl_le_p(vdev->config + addr);\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8344, "func": "static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB *trb,\n                               dma_addr_t *addr)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n\n    while (1) {\n        TRBType type;\n        pci_dma_read(pci_dev, ring->dequeue, trb, TRB_SIZE);\n        trb->addr = ring->dequeue;\n        trb->ccs = ring->ccs;\n        le64_to_cpus(&trb->parameter);\n        le32_to_cpus(&trb->status);\n        le32_to_cpus(&trb->control);\n\n        trace_usb_xhci_fetch_trb(ring->dequeue, trb_name(trb),\n                                 trb->parameter, trb->status, trb->control);\n\n        if ((trb->control & TRB_C) != ring->ccs) {\n            return 0;\n        }\n\n        type = TRB_TYPE(*trb);\n\n        if (type != TR_LINK) {\n            if (addr) {\n                *addr = ring->dequeue;\n            }\n            ring->dequeue += TRB_SIZE;\n            return type;\n        } else {\n            ring->dequeue = xhci_mask64(trb->parameter);\n            if (trb->control & TRB_LK_TC) {\n                ring->ccs = !ring->ccs;\n            }\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8331, "func": "static void xhci_complete(USBPort *port, USBPacket *packet)\n{\n    XHCITransfer *xfer = container_of(packet, XHCITransfer, packet);\n\n    if (packet->status == USB_RET_REMOVE_FROM_QUEUE) {\n        xhci_ep_nuke_one_xfer(xfer, 0);\n        return;\n    }\n    xhci_complete_packet(xfer);\n    xhci_kick_ep(xfer->xhci, xfer->slotid, xfer->epid, xfer->streamid);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8930, "func": "static void vrend_scale_depth(void *ptr, int size, float scale_val)\n{\n   GLuint *ival = ptr;\n   const GLfloat myscale = 1.0f / 0xffffff;\n   int i;\n   for (i = 0; i < size / 4; i++) {\n      GLuint value = ival[i];\n      GLfloat d = ((float)(value >> 8) * myscale) * scale_val;\n      d = CLAMP(d, 0.0F, 1.0F);\n      ival[i] = (int)(d / myscale) << 8;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9014, "func": "vmxnet3_io_bar1_read(void *opaque, hwaddr addr, unsigned size)\n{\n        VMXNET3State *s = opaque;\n        uint64_t ret = 0;\n\n        switch (addr) {\n        case VMXNET3_REG_VRRS:\n            VMW_CBPRN(\"Read BAR1 [VMXNET3_REG_VRRS], size %d\", size);\n            ret = VMXNET3_DEVICE_REVISION;\n            break;\n\n        case VMXNET3_REG_UVRS:\n            VMW_CBPRN(\"Read BAR1 [VMXNET3_REG_UVRS], size %d\", size);\n            ret = VMXNET3_UPT_REVISION;\n            break;\n\n        case VMXNET3_REG_CMD:\n            VMW_CBPRN(\"Read BAR1 [VMXNET3_REG_CMD], size %d\", size);\n            ret = vmxnet3_get_command_status(s);\n            break;\n\n        case VMXNET3_REG_MACL:\n            VMW_CBPRN(\"Read BAR1 [VMXNET3_REG_MACL], size %d\", size);\n            ret = vmxnet3_get_mac_low(&s->conf.macaddr);\n            break;\n\n        case VMXNET3_REG_MACH:\n            VMW_CBPRN(\"Read BAR1 [VMXNET3_REG_MACH], size %d\", size);\n            ret = vmxnet3_get_mac_high(&s->conf.macaddr);\n            break;\n\n        case VMXNET3_REG_ICR:\n            VMW_CBPRN(\"Read BAR1 [VMXNET3_REG_ICR], size %d\", size);\n            if (vmxnet3_interrupt_asserted(s, 0)) {\n                vmxnet3_clear_interrupt(s, 0);\n                ret = true;\n            } else {\n                ret = false;\n            }\n            break;\n\n        default:\n            VMW_CBPRN(\"Unknow read BAR1[%\" PRIx64 \"], %d bytes\", addr, size);\n            break;\n        }\n\n        return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188090, "func": "void vp8mt_de_alloc_temp_buffers(VP8D_COMP *pbi, int mb_rows)\n{\n    int i;\n \n    if (pbi->b_multithreaded_rd)\n    {\n            vpx_free(pbi->mt_current_mb_col);\n            pbi->mt_current_mb_col = NULL ;\n \n        if (pbi->mt_yabove_row)\n        {\n            for (i=0; i< mb_rows; i++)\n            {\n                    vpx_free(pbi->mt_yabove_row[i]);\n                    pbi->mt_yabove_row[i] = NULL ;\n            }\n            vpx_free(pbi->mt_yabove_row);\n            pbi->mt_yabove_row = NULL ;\n        }\n        if (pbi->mt_uabove_row)\n        {\n            for (i=0; i< mb_rows; i++)\n            {\n                    vpx_free(pbi->mt_uabove_row[i]);\n                    pbi->mt_uabove_row[i] = NULL ;\n            }\n            vpx_free(pbi->mt_uabove_row);\n            pbi->mt_uabove_row = NULL ;\n        }\n        if (pbi->mt_vabove_row)\n        {\n            for (i=0; i< mb_rows; i++)\n            {\n                    vpx_free(pbi->mt_vabove_row[i]);\n                    pbi->mt_vabove_row[i] = NULL ;\n            }\n            vpx_free(pbi->mt_vabove_row);\n            pbi->mt_vabove_row = NULL ;\n        }\n        if (pbi->mt_yleft_col)\n        {\n            for (i=0; i< mb_rows; i++)\n            {\n                    vpx_free(pbi->mt_yleft_col[i]);\n                    pbi->mt_yleft_col[i] = NULL ;\n            }\n            vpx_free(pbi->mt_yleft_col);\n            pbi->mt_yleft_col = NULL ;\n        }\n        if (pbi->mt_uleft_col)\n        {\n            for (i=0; i< mb_rows; i++)\n            {\n                    vpx_free(pbi->mt_uleft_col[i]);\n                    pbi->mt_uleft_col[i] = NULL ;\n            }\n            vpx_free(pbi->mt_uleft_col);\n            pbi->mt_uleft_col = NULL ;\n        }\n        if (pbi->mt_vleft_col)\n        {\n            for (i=0; i< mb_rows; i++)\n            {\n                    vpx_free(pbi->mt_vleft_col[i]);\n                    pbi->mt_vleft_col[i] = NULL ;\n            }\n            vpx_free(pbi->mt_vleft_col);\n            pbi->mt_vleft_col = NULL ;\n        }\n     }\n }\n", "target": 1, "flaw_line_index": "2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69"}
{"idx": 188248, "func": "OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n const int32_t indexFull = index;\n\n switch (indexFull) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         mComponentRole,\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoPortFormat:\n {\n\n             OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_VIDEO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > kMaxPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n if (formatParams->nIndex != 0) {\n return OMX_ErrorNoMore;\n }\n\n if (formatParams->nPortIndex == kInputPortIndex) {\n if (formatParams->eCompressionFormat != mCodingType\n || formatParams->eColorFormat != OMX_COLOR_FormatUnused) {\n return OMX_ErrorUnsupportedSetting;\n }\n } else {\n if (formatParams->eCompressionFormat != OMX_VIDEO_CodingUnused\n || formatParams->eColorFormat != OMX_COLOR_FormatYUV420Planar) {\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n return OMX_ErrorNone;\n }\n\n case kPrepareForAdaptivePlaybackIndex:\n\n         {\n             const PrepareForAdaptivePlaybackParams* adaptivePlaybackParams =\n                     (const PrepareForAdaptivePlaybackParams *)params;\n             mIsAdaptive = adaptivePlaybackParams->bEnable;\n             if (mIsAdaptive) {\n                 mAdaptiveMaxWidth = adaptivePlaybackParams->nMaxFrameWidth;\n                mAdaptiveMaxHeight = adaptivePlaybackParams->nMaxFrameHeight;\n                mWidth = mAdaptiveMaxWidth;\n                mHeight = mAdaptiveMaxHeight;\n } else {\n                mAdaptiveMaxWidth = 0;\n                mAdaptiveMaxHeight = 0;\n }\n            updatePortDefinitions(true \n);\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamPortDefinition:\n\n         {\n             OMX_PARAM_PORTDEFINITIONTYPE *newParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n             OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &newParams->format.video;\n             OMX_PARAM_PORTDEFINITIONTYPE *def = &editPortInfo(newParams->nPortIndex)->mDef;\n \n uint32_t oldWidth = def->format.video.nFrameWidth;\n uint32_t oldHeight = def->format.video.nFrameHeight;\n uint32_t newWidth = video_def->nFrameWidth;\n uint32_t newHeight = video_def->nFrameHeight;\n if (newWidth != oldWidth || newHeight != oldHeight) {\n bool outputPort = (newParams->nPortIndex == kOutputPortIndex);\n if (outputPort) {\n                    mWidth = newWidth;\n                    mHeight = newHeight;\n\n                    updatePortDefinitions(true \n);\n                    newParams->nBufferSize = def->nBufferSize;\n } else {\n                    def->format.video.nFrameWidth = newWidth;\n                    def->format.video.nFrameHeight = newHeight;\n }\n }\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8791, "func": "static bool check_transfer_bounds(struct vrend_resource *res,\n                                  const struct vrend_transfer_info *info)\n{\n   int lwidth, lheight;\n\n   if (info->level > res->base.last_level)\n      return false;\n   if (info->box->x < 0 || info->box->y < 0)\n      return false;\n   lwidth = u_minify(res->base.width0, info->level);\n   if (info->box->width > lwidth)\n      return false;\n   if (info->box->x > lwidth)\n      return false;\n   if (info->box->width + info->box->x > lwidth)\n      return false;\n\n   lheight = u_minify(res->base.height0, info->level);\n   if (info->box->height > lheight)\n      return false;\n   if (info->box->y > lheight)\n      return false;\n   if (info->box->height + info->box->y > lheight)\n      return false;\n\n   if (res->base.target == PIPE_TEXTURE_3D) {\n      int ldepth = u_minify(res->base.depth0, info->level);\n      if (info->box->depth > ldepth)\n         return false;\n      if (info->box->z > ldepth)\n         return false;\n      if (info->box->z + info->box->depth > ldepth)\n         return false;\n   } else {\n      if (info->box->depth > res->base.array_size)\n         return false;\n      if (info->box->z > res->base.array_size)\n         return false;\n      if (info->box->z + info->box->depth > res->base.array_size)\n         return false;\n   }\n\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188532, "func": "  uint8_t* input() const {\n     return input_ + BorderTop() * kOuterBlockSize + BorderLeft();\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8593, "func": "static int ssh_test_for_upstream(const char *host, int port, Conf *conf)\n{\n    char *savedhost;\n    int savedport;\n    int ret;\n\n    random_ref(); \n    ssh_hostport_setup(host, port, conf, &savedhost, &savedport, NULL);\n    ret = ssh_share_test_for_upstream(savedhost, savedport, conf);\n    sfree(savedhost);\n    random_unref();\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8932, "func": "void vrend_set_clip_state(struct vrend_context *ctx, struct pipe_clip_state *ucp)\n{\n   if (vrend_state.use_core_profile) {\n      ctx->sub->ucp_state = *ucp;\n   } else {\n      int i, j;\n      GLdouble val[4];\n\n      for (i = 0; i < 8; i++) {\n         for (j = 0; j < 4; j++)\n            val[j] = ucp->ucp[i][j];\n         glClipPlane(GL_CLIP_PLANE0 + i, val);\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188104, "func": "void rfc_process_mx_message(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n uint8_t* p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n  MX_FRAME* p_rx_frame = &rfc_cb.rfc.rx_frame;\n uint16_t length = p_buf->len;\n\n   uint8_t ea, cr, mx_len;\n   bool is_command;\n \n   p_rx_frame->ea = *p_data & RFCOMM_EA;\n   p_rx_frame->cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;\n   p_rx_frame->type = *p_data++ & ~(RFCOMM_CR_MASK | RFCOMM_EA_MASK);\n\n if (!p_rx_frame->ea || !length) {\n    LOG(ERROR) << __func__\n << \": Invalid MX frame ea=\" << std::to_string(p_rx_frame->ea)\n << \", len=\" << length << \", bd_addr=\" << p_mcb->bd_addr;\n    osi_free(p_buf);\n return;\n }\n\n  length--;\n\n  is_command = p_rx_frame->cr;\n\n  ea = *p_data & RFCOMM_EA;\n\n  mx_len = *p_data++ >> RFCOMM_SHIFT_LENGTH1;\n\n   length--;\n \n   if (!ea) {\n     mx_len += *p_data++ << RFCOMM_SHIFT_LENGTH2;\n     length--;\n   }\n\n if (mx_len != length) {\n    LOG(ERROR) << __func__ << \": Bad MX frame, p_mcb=\" << p_mcb\n << \", bd_addr=\" << p_mcb->bd_addr;\n    osi_free(p_buf);\n return;\n }\n\n  RFCOMM_TRACE_DEBUG(\"%s: type=%d, p_mcb=%p\", __func__, p_rx_frame->type,\n                     p_mcb);\n switch (p_rx_frame->type) {\n case RFCOMM_MX_PN:\n if (length != RFCOMM_MX_PN_LEN) {\n        LOG(ERROR) << __func__ << \": Invalid PN length, p_mcb=\" << p_mcb\n << \", bd_addr=\" << p_mcb->bd_addr;\n break;\n }\n\n      p_rx_frame->dlci = *p_data++ & RFCOMM_PN_DLCI_MASK;\n      p_rx_frame->u.pn.frame_type = *p_data & RFCOMM_PN_FRAME_TYPE_MASK;\n      p_rx_frame->u.pn.conv_layer = *p_data++ & RFCOMM_PN_CONV_LAYER_MASK;\n      p_rx_frame->u.pn.priority = *p_data++ & RFCOMM_PN_PRIORITY_MASK;\n      p_rx_frame->u.pn.t1 = *p_data++;\n      p_rx_frame->u.pn.mtu = *p_data + (*(p_data + 1) << 8);\n      p_data += 2;\n      p_rx_frame->u.pn.n2 = *p_data++;\n      p_rx_frame->u.pn.k = *p_data++ & RFCOMM_PN_K_MASK;\n\n if (!p_rx_frame->dlci || !RFCOMM_VALID_DLCI(p_rx_frame->dlci) ||\n (p_rx_frame->u.pn.mtu < RFCOMM_MIN_MTU) ||\n (p_rx_frame->u.pn.mtu > RFCOMM_MAX_MTU)) {\n        LOG(ERROR) << __func__ << \": Bad PN frame, p_mcb=\" << p_mcb\n << \", bd_addr=\" << p_mcb->bd_addr;\n break;\n }\n\n      osi_free(p_buf);\n\n      rfc_process_pn(p_mcb, is_command, p_rx_frame);\n return;\n\n case RFCOMM_MX_TEST:\n if (!length) break;\n\n      p_rx_frame->u.test.p_data = p_data;\n      p_rx_frame->u.test.data_len = length;\n\n      p_buf->offset += 2;\n      p_buf->len -= 2;\n\n if (is_command)\n        rfc_send_test(p_mcb, false, p_buf);\n else\n        rfc_process_test_rsp(p_mcb, p_buf);\n return;\n\n case RFCOMM_MX_FCON:\n if (length != RFCOMM_MX_FCON_LEN) break;\n\n      osi_free(p_buf);\n\n      rfc_process_fcon(p_mcb, is_command);\n return;\n\n case RFCOMM_MX_FCOFF:\n if (length != RFCOMM_MX_FCOFF_LEN) break;\n\n      osi_free(p_buf);\n\n      rfc_process_fcoff(p_mcb, is_command);\n\n       return;\n \n     case RFCOMM_MX_MSC:\n       ea = *p_data & RFCOMM_EA;\n       cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;\n       p_rx_frame->dlci = *p_data++ >> RFCOMM_SHIFT_DLCI;\n\n if (!ea || !cr || !p_rx_frame->dlci ||\n !RFCOMM_VALID_DLCI(p_rx_frame->dlci)) {\n        RFCOMM_TRACE_ERROR(\"Bad MSC frame\");\n break;\n }\n\n      p_rx_frame->u.msc.signals = *p_data++;\n\n if (mx_len == RFCOMM_MX_MSC_LEN_WITH_BREAK) {\n        p_rx_frame->u.msc.break_present =\n *p_data & RFCOMM_MSC_BREAK_PRESENT_MASK;\n        p_rx_frame->u.msc.break_duration =\n (*p_data & RFCOMM_MSC_BREAK_MASK) >> RFCOMM_MSC_SHIFT_BREAK;\n } else {\n        p_rx_frame->u.msc.break_present = false;\n        p_rx_frame->u.msc.break_duration = 0;\n }\n      osi_free(p_buf);\n\n      rfc_process_msc(p_mcb, is_command, p_rx_frame);\n return;\n\n case RFCOMM_MX_NSC:\n if ((length != RFCOMM_MX_NSC_LEN) || !is_command) break;\n\n      p_rx_frame->u.nsc.ea = *p_data & RFCOMM_EA;\n      p_rx_frame->u.nsc.cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;\n      p_rx_frame->u.nsc.type = *p_data++ >> RFCOMM_SHIFT_DLCI;\n\n      osi_free(p_buf);\n\n      rfc_process_nsc(p_mcb, p_rx_frame);\n return;\n\n case RFCOMM_MX_RPN:\n if ((length != RFCOMM_MX_RPN_REQ_LEN) && (length != RFCOMM_MX_RPN_LEN))\n break;\n\n      ea = *p_data & RFCOMM_EA;\n      cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;\n      p_rx_frame->dlci = *p_data++ >> RFCOMM_SHIFT_DLCI;\n\n if (!ea || !cr || !p_rx_frame->dlci ||\n !RFCOMM_VALID_DLCI(p_rx_frame->dlci)) {\n        RFCOMM_TRACE_ERROR(\"Bad RPN frame\");\n break;\n }\n\n      p_rx_frame->u.rpn.is_request = (length == RFCOMM_MX_RPN_REQ_LEN);\n\n if (!p_rx_frame->u.rpn.is_request) {\n        p_rx_frame->u.rpn.baud_rate = *p_data++;\n        p_rx_frame->u.rpn.byte_size =\n (*p_data >> RFCOMM_RPN_BITS_SHIFT) & RFCOMM_RPN_BITS_MASK;\n        p_rx_frame->u.rpn.stop_bits =\n (*p_data >> RFCOMM_RPN_STOP_BITS_SHIFT) & RFCOMM_RPN_STOP_BITS_MASK;\n        p_rx_frame->u.rpn.parity =\n (*p_data >> RFCOMM_RPN_PARITY_SHIFT) & RFCOMM_RPN_PARITY_MASK;\n        p_rx_frame->u.rpn.parity_type =\n (*p_data++ >> RFCOMM_RPN_PARITY_TYPE_SHIFT) &\n            RFCOMM_RPN_PARITY_TYPE_MASK;\n\n        p_rx_frame->u.rpn.fc_type = *p_data++ & RFCOMM_FC_MASK;\n        p_rx_frame->u.rpn.xon_char = *p_data++;\n        p_rx_frame->u.rpn.xoff_char = *p_data++;\n        p_rx_frame->u.rpn.param_mask =\n (*p_data + (*(p_data + 1) << 8)) & RFCOMM_RPN_PM_MASK;\n }\n      osi_free(p_buf);\n\n      rfc_process_rpn(p_mcb, is_command, p_rx_frame->u.rpn.is_request,\n                      p_rx_frame);\n return;\n\n case RFCOMM_MX_RLS:\n if (length != RFCOMM_MX_RLS_LEN) break;\n\n      ea = *p_data & RFCOMM_EA;\n      cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;\n\n      p_rx_frame->dlci = *p_data++ >> RFCOMM_SHIFT_DLCI;\n      p_rx_frame->u.rls.line_status = (*p_data & ~0x01);\n\n if (!ea || !cr || !p_rx_frame->dlci ||\n !RFCOMM_VALID_DLCI(p_rx_frame->dlci)) {\n        RFCOMM_TRACE_ERROR(\"Bad RPN frame\");\n break;\n }\n\n      osi_free(p_buf);\n\n      rfc_process_rls(p_mcb, is_command, p_rx_frame);\n return;\n }\n\n  osi_free(p_buf);\n\n if (is_command) rfc_send_nsc(p_mcb);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187930, "func": "WORD32 ih264d_parse_bslice(dec_struct_t * ps_dec, UWORD16 u2_first_mb_in_slice)\n{\n dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n    UWORD8 u1_ref_idx_re_flag_lx;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n\n    UWORD32 u4_temp, ui_temp1;\n    WORD32 i_temp;\n    WORD32 ret;\n\n {\n        WORD8 *pi1_buf;\n        WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;\n        WORD32 *pi4_mv = (WORD32*)pi2_mv;\n        WORD16 *pi16_refFrame;\n        pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;\n        pi16_refFrame = (WORD16*)pi1_buf;\n *pi4_mv = 0;\n *(pi4_mv + 1) = 0;\n *pi16_refFrame = OUT_OF_RANGE_REF;\n        ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;\n        ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;\n }\n\n    ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(\n                    ps_bitstrm);\n    COPYTHECONTEXT(\"SH: num_ref_idx_override_flag\",\n                    ps_slice->u1_num_ref_idx_active_override_flag);\n\n    u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];\n    ui_temp1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];\n if(ps_slice->u1_num_ref_idx_active_override_flag)\n {\n        u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: num_ref_idx_l0_active_minus1\",\n                        u4_temp - 1);\n        ui_temp1 = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: num_ref_idx_l1_active_minus1\",\n                        ui_temp1 - 1);\n }\n\n {\n        UWORD8 u1_max_ref_idx = MAX_FRAMES;\n if(ps_slice->u1_field_pic_flag)\n {\n            u1_max_ref_idx = MAX_FRAMES << 1;\n }\n if((u4_temp > u1_max_ref_idx) || (ui_temp1 > u1_max_ref_idx))\n {\n return ERROR_NUM_REF;\n }\n        ps_slice->u1_num_ref_idx_lx_active[0] = u4_temp;\n        ps_slice->u1_num_ref_idx_lx_active[1] = ui_temp1;\n }\n\n {\n        UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type\n != ps_dec->ps_cur_slice->u1_slice_type);\n if(ps_dec->u1_first_pb_nal_in_pic\n || (init_idx_flg & !ps_dec->u1_sl_typ_5_9)\n || ps_dec->u1_num_ref_idx_lx_active_prev\n != ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0])\n            ih264d_init_ref_idx_lx_b(ps_dec);\n if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)\n            ps_dec->u1_first_pb_nal_in_pic = 0;\n }\n    ps_dec->u1_num_ref_idx_lx_active_prev =\n                    ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];\n\n    u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SH: ref_pic_list_reordering_flag_l0\",u1_ref_idx_re_flag_lx);\n\n if(u1_ref_idx_re_flag_lx)\n {\n        WORD8 ret;\n        ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];\n        ret = ih264d_ref_idx_reordering(ps_dec, 0);\n if(ret == -1)\n return ERROR_REFIDX_ORDER_T;\n }\n else\n        ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n\n    u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SH: ref_pic_list_reordering_flag_l1\",u1_ref_idx_re_flag_lx);\n\n if(u1_ref_idx_re_flag_lx)\n {\n        WORD8 ret;\n        ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];\n        ret = ih264d_ref_idx_reordering(ps_dec, 1);\n if(ret == -1)\n return ERROR_REFIDX_ORDER_T;\n }\n else\n        ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];\n\n {\n void **ppv_map_ref_idx_to_poc_lx;\n        WORD8 idx;\n struct pic_buffer_t *ps_pic;\n\n        ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;\n        ppv_map_ref_idx_to_poc_lx[0] = 0;\n        ppv_map_ref_idx_to_poc_lx++;\n for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];\n                        idx++)\n {\n            ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];\n            ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);\n }\n\n        ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;\n\n        ppv_map_ref_idx_to_poc_lx[0] = 0;\n        ppv_map_ref_idx_to_poc_lx++;\n for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];\n                        idx++)\n {\n            ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];\n            ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);\n }\n\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)\n {\n void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;\n\n ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc\n + TOP_LIST_FLD_L0;\n            ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc\n + BOT_LIST_FLD_L0;\n\n ppv_map_ref_idx_to_poc_lx_t[0] = 0;\n ppv_map_ref_idx_to_poc_lx_t++;\n            ppv_map_ref_idx_to_poc_lx_b[0] = 0;\n            ppv_map_ref_idx_to_poc_lx_b++;\n for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];\n                            idx++)\n {\n                ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];\n ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);\n                ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);\n\n                ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;\n ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;\n\n ppv_map_ref_idx_to_poc_lx_t += 2;\n                ppv_map_ref_idx_to_poc_lx_b += 2;\n }\n\n ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc\n + TOP_LIST_FLD_L1;\n            ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc\n + BOT_LIST_FLD_L1;\n\n ppv_map_ref_idx_to_poc_lx_t[0] = 0;\n ppv_map_ref_idx_to_poc_lx_t++;\n            ppv_map_ref_idx_to_poc_lx_b[0] = 0;\n            ppv_map_ref_idx_to_poc_lx_b++;\n for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];\n                            idx++)\n {\n                UWORD8 u1_tmp_idx = idx << 1;\n                ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];\n ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);\n                ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);\n\n                ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;\n ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;\n\n }\n }\n\n if(ps_dec->u4_num_cores >= 3)\n {\n            WORD32 num_entries;\n            WORD32 size;\n\n            num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n            num_entries = 2 * ((2 * num_entries) + 1);\n\n            size = num_entries * sizeof(void *);\n            size += PAD_MAP_IDX_POC * sizeof(void *);\n\n            memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,\n               ps_dec->ppv_map_ref_idx_to_poc,\n               size);\n }\n\n }\n\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag\n && (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))\n {\n        ih264d_convert_frm_mbaff_list(ps_dec);\n }\n\n if(ps_pps->u1_wted_bipred_idc == 1)\n {\n        ret = ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);\n if(ret != OK)\n return ret;\n        ih264d_form_pred_weight_matrix(ps_dec);\n        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n }\n else if(ps_pps->u1_wted_bipred_idc == 2)\n {\n        ps_slice->u2_log2Y_crwd = 0x0505;\n        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n        ih264d_get_implicit_weights(ps_dec);\n }\n else\n        ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;\n\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =\n                    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n     if(ps_slice->u1_nal_ref_idc != 0)\n     {\n         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)\n            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);\n         else\n             ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;\n     }\n\n if(ps_pps->u1_entropy_coding_mode == CABAC)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_CABAC_INIT_IDC)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n        ps_slice->u1_cabac_init_idc = u4_temp;\n        COPYTHECONTEXT(\"SH: cabac_init_idc\",ps_slice->u1_cabac_init_idc);\n }\n\n    i_temp = ps_pps->u1_pic_init_qp\n + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if((i_temp < 0) || (i_temp > 51))\n {\n return ERROR_INV_RANGE_QP_T;\n }\n    ps_slice->u1_slice_qp = i_temp;\n    COPYTHECONTEXT(\"SH: slice_qp_delta\",\n (WORD8)(ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));\n\n if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)\n {\n return ERROR_INV_SLICE_HDR_T;\n } COPYTHECONTEXT(\"SH: disable_deblocking_filter_idc\", u4_temp);\n        ps_slice->u1_disable_dblk_filter_idc = u4_temp;\n if(u4_temp != 1)\n {\n            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)\n << 1;\n if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n            ps_slice->i1_slice_alpha_c0_offset = i_temp;\n            COPYTHECONTEXT(\"SH: slice_alpha_c0_offset_div2\",\n                            ps_slice->i1_slice_alpha_c0_offset >> 1);\n\n            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)\n << 1;\n if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n            ps_slice->i1_slice_beta_offset = i_temp;\n            COPYTHECONTEXT(\"SH: slice_beta_offset_div2\",\n                            ps_slice->i1_slice_beta_offset >> 1);\n\n }\n else\n {\n            ps_slice->i1_slice_alpha_c0_offset = 0;\n            ps_slice->i1_slice_beta_offset = 0;\n }\n }\n else\n {\n        ps_slice->u1_disable_dblk_filter_idc = 0;\n        ps_slice->i1_slice_alpha_c0_offset = 0;\n        ps_slice->i1_slice_beta_offset = 0;\n }\n\n    ps_dec->u1_slice_header_done = 2;\n\n if(ps_pps->u1_entropy_coding_mode)\n {\n        SWITCHOFFTRACE; SWITCHONTRACECABAC;\n        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;\n        ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cabac;\n        ih264d_init_cabac_contexts(B_SLICE, ps_dec);\n\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)\n            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;\n else\n            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;\n }\n else\n {\n        SWITCHONTRACE; SWITCHOFFTRACECABAC;\n        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;\n        ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cavlc;\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)\n            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;\n else\n            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;\n }\n\n    ret = ih264d_cal_col_pic(ps_dec);\n if(ret != OK)\n return ret;\n    ps_dec->u1_B = 1;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb;\n    ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_slice, u2_first_mb_in_slice);\n if(ret != OK)\n return ret;\n return OK;\n}\n", "target": 1, "flaw_line_index": "225"}
{"idx": 8575, "func": "static void ssh_pkt_adduint32(struct Packet *pkt, unsigned long value)\n{\n    unsigned char x[4];\n    PUT_32BIT(x, value);\n    ssh_pkt_adddata(pkt, x, 4);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188101, "func": "static void avrc_msg_cback(uint8_t handle, uint8_t label, uint8_t cr,\n                           BT_HDR* p_pkt) {\n uint8_t opcode;\n  tAVRC_MSG msg;\n uint8_t* p_data;\n uint8_t* p_begin;\n bool drop = false;\n bool do_free = true;\n  BT_HDR* p_rsp = NULL;\n uint8_t* p_rsp_data;\n int xx;\n bool reject = false;\n const char* p_drop_msg = \"dropped\";\n  tAVRC_MSG_VENDOR* p_msg = &msg.vendor;\n\n if (cr == AVCT_CMD && (p_pkt->layer_specific & AVCT_DATA_CTRL &&\n                         AVRC_PACKET_LEN < sizeof(p_pkt->len))) {\n    p_drop_msg = \"dropped - too long AV/C cmd frame size\";\n    osi_free(p_pkt);\n return;\n }\n\n if (cr == AVCT_REJ) {\n    osi_free(p_pkt);\n    AVCT_RemoveConn(handle);\n return;\n } else if (cr == AVCT_RSP) {\n    AVRC_TRACE_DEBUG(\"AVRC: stopping timer (handle=0x%02x)\", handle);\n    alarm_cancel(avrc_cb.ccb_int[handle].tle);\n }\n\n  p_data = (uint8_t*)(p_pkt + 1) + p_pkt->offset;\n  memset(&msg, 0, sizeof(tAVRC_MSG));\n\n if (p_pkt->layer_specific == AVCT_DATA_BROWSE) {\n    opcode = AVRC_OP_BROWSE;\n    msg.browse.hdr.ctype = cr;\n    msg.browse.p_browse_data = p_data;\n\n     msg.browse.browse_len = p_pkt->len;\n     msg.browse.p_browse_pkt = p_pkt;\n   } else {\n     msg.hdr.ctype = p_data[0] & AVRC_CTYPE_MASK;\n     AVRC_TRACE_DEBUG(\"%s handle:%d, ctype:%d, offset:%d, len: %d\", __func__,\n                      handle, msg.hdr.ctype, p_pkt->offset, p_pkt->len);\n    msg.hdr.subunit_type =\n (p_data[1] & AVRC_SUBTYPE_MASK) >> AVRC_SUBTYPE_SHIFT;\n    msg.hdr.subunit_id = p_data[1] & AVRC_SUBID_MASK;\n    opcode = p_data[2];\n }\n\n if (((avrc_cb.ccb[handle].control & AVRC_CT_TARGET) && (cr == AVCT_CMD)) ||\n ((avrc_cb.ccb[handle].control & AVRC_CT_CONTROL) && (cr == AVCT_RSP))) {\n switch (opcode) {\n case AVRC_OP_UNIT_INFO:\n if (cr == AVCT_CMD) {\n          p_rsp = avrc_copy_packet(p_pkt, AVRC_OP_UNIT_INFO_RSP_LEN);\n          p_rsp_data = avrc_get_data_ptr(p_rsp);\n *p_rsp_data = AVRC_RSP_IMPL_STBL;\n          p_rsp_data += AVRC_AVC_HDR_SIZE;\n *p_rsp_data++ = 7;\n *p_rsp_data++ = (AVRC_SUB_PANEL << AVRC_SUBTYPE_SHIFT);\n          AVRC_CO_ID_TO_BE_STREAM(p_rsp_data, avrc_cb.ccb[handle].company_id);\n          p_rsp->len =\n (uint16_t)(p_rsp_data - (uint8_t*)(p_rsp + 1) - p_rsp->offset);\n          cr = AVCT_RSP;\n\n           p_drop_msg = \"auto respond\";\n         } else {\n           p_data += 4; \n           msg.unit.unit_type =\n               (*p_data & AVRC_SUBTYPE_MASK) >> AVRC_SUBTYPE_SHIFT;\n          msg.unit.unit = *p_data & AVRC_SUBID_MASK;\n          p_data++;\n          AVRC_BE_STREAM_TO_CO_ID(msg.unit.company_id, p_data);\n }\n break;\n\n case AVRC_OP_SUB_INFO:\n if (cr == AVCT_CMD) {\n          p_rsp = avrc_copy_packet(p_pkt, AVRC_OP_SUB_UNIT_INFO_RSP_LEN);\n          p_rsp_data = avrc_get_data_ptr(p_rsp);\n *p_rsp_data = AVRC_RSP_IMPL_STBL;\n          p_rsp_data += 4;\n *p_rsp_data++ = (AVRC_SUB_PANEL << AVRC_SUBTYPE_SHIFT);\n          memset(p_rsp_data, AVRC_CMD_OPRND_PAD, AVRC_SUBRSP_OPRND_BYTES);\n          p_rsp_data += AVRC_SUBRSP_OPRND_BYTES;\n          p_rsp->len =\n (uint16_t)(p_rsp_data - (uint8_t*)(p_rsp + 1) - p_rsp->offset);\n          cr = AVCT_RSP;\n\n           p_drop_msg = \"auto responded\";\n         } else {\n           p_data += AVRC_AVC_HDR_SIZE; \n           msg.sub.page =\n               (*p_data++ >> AVRC_SUB_PAGE_SHIFT) & AVRC_SUB_PAGE_MASK;\n          xx = 0;\n while (*p_data != AVRC_CMD_OPRND_PAD && xx < AVRC_SUB_TYPE_LEN) {\n            msg.sub.subunit_type[xx] = *p_data++ >> AVRC_SUBTYPE_SHIFT;\n if (msg.sub.subunit_type[xx] == AVRC_SUB_PANEL)\n              msg.sub.panel = true;\n            xx++;\n }\n }\n break;\n\n case AVRC_OP_VENDOR: {\n        p_data = (uint8_t*)(p_pkt + 1) + p_pkt->offset;\n        p_begin = p_data;\n if (p_pkt->len <\n            AVRC_VENDOR_HDR_SIZE) \n {\n if (cr == AVCT_CMD)\n            reject = true;\n else\n            drop = true;\n break;\n }\n        p_data += AVRC_AVC_HDR_SIZE; \n        AVRC_BE_STREAM_TO_CO_ID(p_msg->company_id, p_data);\n        p_msg->p_vendor_data = p_data;\n        p_msg->vendor_len = p_pkt->len - (p_data - p_begin);\n\n uint8_t drop_code = 0;\n if (p_msg->company_id == AVRC_CO_METADATA) {\n if (p_pkt->len < (AVRC_VENDOR_HDR_SIZE + AVRC_MIN_META_HDR_SIZE)) {\n if (cr == AVCT_CMD)\n              reject = true;\n else\n              drop = true;\n break;\n }\n\n          drop_code = avrc_proc_far_msg(handle, label, cr, &p_pkt, p_msg);\n if (drop_code > 0) drop = true;\n }\n if (drop_code > 0) {\n if (drop_code != 4) do_free = false;\n switch (drop_code) {\n case 1:\n              p_drop_msg = \"sent_frag\";\n break;\n case 2:\n              p_drop_msg = \"req_cont\";\n break;\n case 3:\n              p_drop_msg = \"sent_frag3\";\n break;\n case 4:\n              p_drop_msg = \"sent_frag_free\";\n break;\n default:\n              p_drop_msg = \"sent_fragd\";\n }\n }\n if ((cr == AVCT_RSP) && (drop_code != 2)) {\n          avrc_send_next_vendor_cmd(handle);\n }\n } break;\n\n case AVRC_OP_PASS_THRU:\n if (p_pkt->len < 5) \n {\n if (cr == AVCT_CMD)\n            reject = true;\n else\n            drop = true;\n break;\n }\n        p_data += AVRC_AVC_HDR_SIZE; \n        msg.pass.op_id = (AVRC_PASS_OP_ID_MASK & *p_data);\n if (AVRC_PASS_STATE_MASK & *p_data)\n          msg.pass.state = true;\n else\n          msg.pass.state = false;\n        p_data++;\n        msg.pass.pass_len = *p_data++;\n if (msg.pass.pass_len != p_pkt->len - 5)\n          msg.pass.pass_len = p_pkt->len - 5;\n if (msg.pass.pass_len)\n          msg.pass.p_pass_data = p_data;\n else\n          msg.pass.p_pass_data = NULL;\n break;\n\n case AVRC_OP_BROWSE:\n if (cr == AVCT_RSP) {\n          avrc_send_next_vendor_cmd(handle);\n }\n break;\n\n default:\n if ((avrc_cb.ccb[handle].control & AVRC_CT_TARGET) &&\n (cr == AVCT_CMD)) {\n          reject = true;\n }\n        drop = true;\n break;\n }\n } else \n {\n if (opcode != AVRC_OP_BROWSE) drop = true;\n }\n\n if (reject) {\n    p_rsp = avrc_copy_packet(p_pkt, AVRC_OP_REJ_MSG_LEN);\n    p_rsp_data = avrc_get_data_ptr(p_rsp);\n *p_rsp_data = AVRC_RSP_REJ;\n    p_drop_msg = \"rejected\";\n    cr = AVCT_RSP;\n    drop = true;\n }\n\n if (p_rsp) {\n    AVCT_MsgReq(handle, label, cr, p_rsp);\n    drop = true;\n }\n\n if (!drop) {\n    msg.hdr.opcode = opcode;\n    avrc_cb.ccb[handle].msg_cback.Run(handle, label, opcode, &msg);\n } else {\n    AVRC_TRACE_WARNING(\"%s %s msg handle:%d, control:%d, cr:%d, opcode:x%x\",\n                       __func__, p_drop_msg, handle,\n                       avrc_cb.ccb[handle].control, cr, opcode);\n }\n\n if (opcode == AVRC_OP_BROWSE && msg.browse.p_browse_pkt == NULL) {\n    do_free = false;\n }\n\n if (do_free) osi_free(p_pkt);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187644, "func": "image_transform_ini_end(PNG_CONST image_transform *this,\n    transform_display *that)\n {\n    UNUSED(this)\n   UNUSED(that)\n\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187964, "func": "INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)\n{\n    UWORD32     u4_bit,u4_offset,u4_temp;\n    UWORD32     u4_curr_bit;\n\n    u4_offset               = ps_stream->u4_offset;\n    u4_curr_bit             = u4_offset & 0x1F;\n    u4_bit                  = ps_stream->u4_buf;\n\n    u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;\n\n    u4_offset++;\n\n\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n     }\n     ps_stream->u4_offset          = u4_offset;\n \n return (u4_bit & 0x1);\n}\n", "target": 1, "flaw_line_index": "18,20"}
{"idx": 188509, "func": "int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n VpxVideoReader *reader = NULL;\n const VpxInterface *decoder = NULL;\n const VpxVideoInfo *info = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder.\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame.\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n      vpx_img_write(img, outfile);\n ++frame_cnt;\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec\");\n\n  printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n         info->frame_width, info->frame_height, argv[2]);\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "28,30"}
{"idx": 187853, "func": " bool Cues::LoadCuePoint() const {\n   const long long stop = m_start + m_size;\n \n   if (m_pos >= stop)\n     return false;  \n \n  Init();\n \n   IMkvReader* const pReader = m_pSegment->m_pReader;\n \n while (m_pos < stop) {\n const long long idpos = m_pos;\n\n \n     long len;\n \n    const long long id = ReadUInt(pReader, m_pos, len);\n    assert(id >= 0);  \n    assert((m_pos + len) <= stop);\n \n     m_pos += len;  \n \n     const long long size = ReadUInt(pReader, m_pos, len);\n    assert(size >= 0);\n    assert((m_pos + len) <= stop);\n \n     m_pos += len;  \n    assert((m_pos + size) <= stop);\n \n     if (id != 0x3B) {  \n       m_pos += size;  \n      assert(m_pos <= stop);\n \n       continue;\n     }\n \n    assert(m_preload_count > 0);\n    CuePoint* const pCP = m_cue_points[m_count];\n    assert(pCP);\n    assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));\n    if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))\n       return false;\n \n    pCP->Load(pReader);\n     ++m_count;\n     --m_preload_count;\n \n     m_pos += size;  \n    assert(m_pos <= stop);\n \n     return true;  \n   }\n \n }\n", "target": 1, "flaw_line_index": "2,3,9,19,20,21,26,27,30,34,39,40,41,42,43,46,51"}
{"idx": 188571, "func": "  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9124, "func": "static int vrend_decode_set_streamout_targets(struct vrend_decode_ctx *ctx,\n                                              uint16_t length)\n{\n   uint32_t handles[16];\n   uint32_t num_handles = length - 1;\n   uint32_t append_bitmask;\n   int i;\n\n   if (length < 1)\n      return EINVAL;\n   if (num_handles > ARRAY_SIZE(handles))\n      return EINVAL;\n\n   append_bitmask = get_buf_entry(ctx, VIRGL_SET_STREAMOUT_TARGETS_APPEND_BITMASK);\n   for (i = 0; i < num_handles; i++)\n      handles[i] = get_buf_entry(ctx, VIRGL_SET_STREAMOUT_TARGETS_H0 + i);\n   vrend_set_streamout_targets(ctx->grctx, append_bitmask, num_handles, handles);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8535, "func": "static struct Packet *ssh2_bare_connection_rdpkt(Ssh ssh,\n                                                 const unsigned char **data,\n                                                 int *datalen)\n{\n    struct rdpkt2_bare_state_tag *st = &ssh->rdpkt2_bare_state;\n\n    crBegin(ssh->ssh2_bare_rdpkt_crstate);\n\n    for (st->i = 0; st->i < 4; st->i++) {\n        while ((*datalen) == 0)\n            crReturn(NULL);\n        st->length[st->i] = *(*data)++;\n        (*datalen)--;\n    }\n\n    st->packetlen = toint(GET_32BIT_MSB_FIRST(st->length));\n    if (st->packetlen <= 0 || st->packetlen >= OUR_V2_PACKETLIMIT) {\n        bombout((\"Invalid packet length received\"));\n        crStop(NULL);\n    }\n\n    st->pktin = ssh_new_packet();\n    st->pktin->data = snewn(st->packetlen, unsigned char);\n\n    st->pktin->encrypted_len = st->packetlen;\n\n    st->pktin->sequence = st->incoming_sequence++;\n\n    for (st->i = 0; st->i < st->packetlen; st->i++) {\n        while ((*datalen) == 0)\n            crReturn(NULL);\n        st->pktin->data[st->i] = *(*data)++;\n        (*datalen)--;\n    }\n\n    st->pktin->type = st->pktin->data[0];\n    st->pktin->body = st->pktin->data + 1;\n    st->pktin->length = st->packetlen - 1;\n\n    if (ssh->logctx)\n        ssh2_log_incoming_packet(ssh, st->pktin);\n\n    st->pktin->savedpos = 0;\n\n    crFinish(st->pktin);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187965, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n stream_t *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n {\n        u4_frame_width <<= 1;\n if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n {\n            u4_frm_offset = ps_dec->u2_frame_width;\n }\n }\n\n do\n {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n        impeg2d_bit_stream_flush(ps_stream,1);\n\n if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n {\n }\n\n for(i = 0; i < NUM_LUMA_BLKS; ++i)\n {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n }\n\n\n\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n {\n return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n }\n else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n }\n\n        impeg2d_bit_stream_flush(ps_stream,1);\n }\n while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "flaw_line_index": "33"}
{"idx": 187360, "func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n    mSyncSampleOffset = data_offset;\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumSyncSamples = U32_AT(&header[4]);\n\n if (mNumSyncSamples < 2) {\n\n         ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n     }\n \n    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n\n    mSyncSamples = new uint32_t[mNumSyncSamples];\n size_t size = mNumSyncSamples * sizeof(uint32_t);\n if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)\n != (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < mNumSyncSamples; ++i) {\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "26"}
{"idx": 8969, "func": "void net_tx_pkt_setup_vlan_header_ex(struct NetTxPkt *pkt,\n    uint16_t vlan, uint16_t vlan_ethtype)\n{\n    bool is_new;\n    assert(pkt);\n\n    eth_setup_vlan_headers_ex(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n        vlan, vlan_ethtype, &is_new);\n\n    if (is_new) {\n        pkt->hdr_len += sizeof(struct vlan_header);\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len +=\n            sizeof(struct vlan_header);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188147, "func": "     BufferMeta(size_t size, OMX_U32 portIndex)\n         : mSize(size),\n          mIsBackup(false),\n          mPortIndex(portIndex) {\n     }\n", "target": 1, "flaw_line_index": "3,4"}
{"idx": 9003, "func": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n{\n    s->last_command = cmd;\n\n    switch (cmd) {\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_STATS:\n        VMW_CBPRN(\"Set: Get device statistics\");\n        vmxnet3_fill_stats(s);\n        break;\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n        vmxnet3_activate_device(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n        VMW_CBPRN(\"Set: Update rx mode\");\n        vmxnet3_update_rx_mode(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n        vmxnet3_update_vlan_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n        VMW_CBPRN(\"Set: Update MAC filters\");\n        vmxnet3_update_mcast_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n        VMW_CBPRN(\"Set: Update features\");\n        vmxnet3_update_features(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n        VMW_CBPRN(\"Set: Update power management config\");\n        vmxnet3_update_pm_state(s);\n        break;\n\n    case VMXNET3_CMD_GET_LINK:\n        VMW_CBPRN(\"Set: Get link\");\n        break;\n\n    case VMXNET3_CMD_RESET_DEV:\n        VMW_CBPRN(\"Set: Reset device\");\n        vmxnet3_reset(s);\n        break;\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - deactivate the device\");\n        vmxnet3_deactivate_device(s);\n        break;\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n        break;\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n                  \"adaptive ring info flags\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_LO:\n        VMW_CBPRN(\"Set: Get lower part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_HI:\n        VMW_CBPRN(\"Set: Get upper part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DEV_EXTRA_INFO:\n        VMW_CBPRN(\"Set: Get device extra info\");\n        break;\n\n    default:\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9054, "func": "static inline void vmxnet3_ring_init(PCIDevice *d,\n\t\t\t\t     Vmxnet3Ring *ring,\n                                     hwaddr pa,\n                                     size_t size,\n                                     size_t cell_size,\n                                     bool zero_region)\n{\n    ring->pa = pa;\n    ring->size = size;\n    ring->cell_size = cell_size;\n    ring->gen = VMXNET3_INIT_GEN;\n    ring->next = 0;\n\n    if (zero_region) {\n        vmw_shmem_set(d, pa, 0, size * cell_size);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187450, "func": "static int skt_read(int fd, void *p, size_t len)\n{\n int read;\n struct pollfd pfd;\n struct timespec ts;\n\n    FNLOG();\n\n \n     ts_log(\"skt_read recv\", len, NULL);\n \n    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)\n     {\n         ERROR(\"write failed with errno=%d\\n\", errno);\n         return -1;\n }\n\n return read;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 9215, "func": "hwaddr virtio_queue_get_desc_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.desc;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8552, "func": "static const char *ssh2_pkt_type(Pkt_KCtx pkt_kctx, Pkt_ACtx pkt_actx,\n                                 int type)\n{\n    translatea(SSH2_MSG_USERAUTH_GSSAPI_RESPONSE,SSH2_PKTCTX_GSSAPI);\n    translatea(SSH2_MSG_USERAUTH_GSSAPI_TOKEN,SSH2_PKTCTX_GSSAPI);\n    translatea(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,SSH2_PKTCTX_GSSAPI);\n    translatea(SSH2_MSG_USERAUTH_GSSAPI_ERROR,SSH2_PKTCTX_GSSAPI);\n    translatea(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK,SSH2_PKTCTX_GSSAPI);\n    translatea(SSH2_MSG_USERAUTH_GSSAPI_MIC, SSH2_PKTCTX_GSSAPI);\n    translate(SSH2_MSG_DISCONNECT);\n    translate(SSH2_MSG_IGNORE);\n    translate(SSH2_MSG_UNIMPLEMENTED);\n    translate(SSH2_MSG_DEBUG);\n    translate(SSH2_MSG_SERVICE_REQUEST);\n    translate(SSH2_MSG_SERVICE_ACCEPT);\n    translate(SSH2_MSG_KEXINIT);\n    translate(SSH2_MSG_NEWKEYS);\n    translatek(SSH2_MSG_KEXDH_INIT, SSH2_PKTCTX_DHGROUP);\n    translatek(SSH2_MSG_KEXDH_REPLY, SSH2_PKTCTX_DHGROUP);\n    translatek(SSH2_MSG_KEX_DH_GEX_REQUEST_OLD, SSH2_PKTCTX_DHGEX);\n    translatek(SSH2_MSG_KEX_DH_GEX_REQUEST, SSH2_PKTCTX_DHGEX);\n    translatek(SSH2_MSG_KEX_DH_GEX_GROUP, SSH2_PKTCTX_DHGEX);\n    translatek(SSH2_MSG_KEX_DH_GEX_INIT, SSH2_PKTCTX_DHGEX);\n    translatek(SSH2_MSG_KEX_DH_GEX_REPLY, SSH2_PKTCTX_DHGEX);\n    translatek(SSH2_MSG_KEXRSA_PUBKEY, SSH2_PKTCTX_RSAKEX);\n    translatek(SSH2_MSG_KEXRSA_SECRET, SSH2_PKTCTX_RSAKEX);\n    translatek(SSH2_MSG_KEXRSA_DONE, SSH2_PKTCTX_RSAKEX);\n    translatek(SSH2_MSG_KEX_ECDH_INIT, SSH2_PKTCTX_ECDHKEX);\n    translatek(SSH2_MSG_KEX_ECDH_REPLY, SSH2_PKTCTX_ECDHKEX);\n    translate(SSH2_MSG_USERAUTH_REQUEST);\n    translate(SSH2_MSG_USERAUTH_FAILURE);\n    translate(SSH2_MSG_USERAUTH_SUCCESS);\n    translate(SSH2_MSG_USERAUTH_BANNER);\n    translatea(SSH2_MSG_USERAUTH_PK_OK, SSH2_PKTCTX_PUBLICKEY);\n    translatea(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, SSH2_PKTCTX_PASSWORD);\n    translatea(SSH2_MSG_USERAUTH_INFO_REQUEST, SSH2_PKTCTX_KBDINTER);\n    translatea(SSH2_MSG_USERAUTH_INFO_RESPONSE, SSH2_PKTCTX_KBDINTER);\n    translate(SSH2_MSG_GLOBAL_REQUEST);\n    translate(SSH2_MSG_REQUEST_SUCCESS);\n    translate(SSH2_MSG_REQUEST_FAILURE);\n    translate(SSH2_MSG_CHANNEL_OPEN);\n    translate(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n    translate(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n    translate(SSH2_MSG_CHANNEL_WINDOW_ADJUST);\n    translate(SSH2_MSG_CHANNEL_DATA);\n    translate(SSH2_MSG_CHANNEL_EXTENDED_DATA);\n    translate(SSH2_MSG_CHANNEL_EOF);\n    translate(SSH2_MSG_CHANNEL_CLOSE);\n    translate(SSH2_MSG_CHANNEL_REQUEST);\n    translate(SSH2_MSG_CHANNEL_SUCCESS);\n    translate(SSH2_MSG_CHANNEL_FAILURE);\n    return \"unknown\";\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187492, "func": "int sock_send_fd(int sock_fd, const uint8_t* buf, int len, int send_fd)\n{\n ssize_t ret;\n struct msghdr msg;\n unsigned char *buffer = (unsigned char *)buf;\n    memset(&msg, 0, sizeof(msg));\n\n struct cmsghdr *cmsg;\n char msgbuf[CMSG_SPACE(1)];\n    asrt(send_fd != -1);\n if(sock_fd == -1 || send_fd == -1)\n return -1;\n    msg.msg_control = msgbuf;\n    msg.msg_controllen = sizeof msgbuf;\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof send_fd);\n    memcpy(CMSG_DATA(cmsg), &send_fd, sizeof send_fd);\n\n int ret_len = len;\n while (len > 0) {\n struct iovec iv;\n        memset(&iv, 0, sizeof(iv));\n\n        iv.iov_base = buffer;\n        iv.iov_len = len;\n\n        msg.msg_iov = &iv;\n\n         msg.msg_iovlen = 1;\n \n         do {\n            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);\n         } while (ret < 0 && errno == EINTR);\n \n         if (ret < 0) {\n            BTIF_TRACE_ERROR(\"fd:%d, send_fd:%d, sendmsg ret:%d, errno:%d, %s\",\n                              sock_fd, send_fd, (int)ret, errno, strerror(errno));\n            ret_len = -1;\n break;\n }\n\n        buffer += ret;\n        len -= ret;\n\n        memset(&msg, 0, sizeof(msg));\n }\n    BTIF_TRACE_DEBUG(\"close fd:%d after sent\", send_fd);\n    close(send_fd);\n return ret_len;\n}\n", "target": 1, "flaw_line_index": "37"}
{"idx": 9033, "func": "static void vmxnet3_process_tx_queue(VMXNET3State *s, int qidx)\n{\n    struct Vmxnet3_TxDesc txd;\n    uint32_t txd_idx;\n    uint32_t data_len;\n    hwaddr data_pa;\n\n    for (;;) {\n        if (!vmxnet3_pop_next_tx_descr(s, qidx, &txd, &txd_idx)) {\n            break;\n        }\n\n        vmxnet3_dump_tx_descr(&txd);\n\n        if (!s->skip_current_tx_pkt) {\n            data_len = (txd.len > 0) ? txd.len : VMXNET3_MAX_TX_BUF_SIZE;\n            data_pa = le64_to_cpu(txd.addr);\n\n            if (!net_tx_pkt_add_raw_fragment(s->tx_pkt,\n                                                data_pa,\n                                                data_len)) {\n                s->skip_current_tx_pkt = true;\n            }\n        }\n\n        if (s->tx_sop) {\n            vmxnet3_tx_retrieve_metadata(s, &txd);\n            s->tx_sop = false;\n        }\n\n        if (txd.eop) {\n            if (!s->skip_current_tx_pkt && net_tx_pkt_parse(s->tx_pkt)) {\n                if (s->needs_vlan) {\n                    net_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);\n                }\n\n                vmxnet3_send_packet(s, qidx);\n            } else {\n                vmxnet3_on_tx_done_update_stats(s, qidx,\n                                                VMXNET3_PKT_STATUS_ERROR);\n            }\n\n            vmxnet3_complete_packet(s, qidx, txd_idx);\n            s->tx_sop = true;\n            s->skip_current_tx_pkt = false;\n            net_tx_pkt_reset(s->tx_pkt);\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187548, "func": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n\n         OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {\n     Mutex::Autolock autoLock(mLock);\n \n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     BufferMeta *buffer_meta =\n         static_cast<BufferMeta *>(header->pAppPrivate);\n     sp<ABuffer> backup = buffer_meta->getBuffer(header, true \n);\n    sp<ABuffer> codec = buffer_meta->getBuffer(header, false \n);\n\n if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource\n && backup->capacity() >= sizeof(VideoNativeMetadata)\n && codec->capacity() >= sizeof(VideoGrallocMetadata)\n && ((VideoNativeMetadata *)backup->base())->eType\n == kMetadataBufferTypeANWBuffer) {\n VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();\n VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();\n        CLOG_BUFFER(emptyBuffer, \"converting ANWB %p to handle %p\",\n                backupMeta.pBuffer, backupMeta.pBuffer->handle);\n        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;\n        codecMeta.eType = kMetadataBufferTypeGrallocSource;\n        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;\n        header->nOffset = 0;\n } else {\n if (rangeOffset > header->nAllocLen\n || rangeLength > header->nAllocLen - rangeOffset) {\n            CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));\n if (fenceFd >= 0) {\n ::close(fenceFd);\n }\n return BAD_VALUE;\n }\n        header->nFilledLen = rangeLength;\n        header->nOffset = rangeOffset;\n\n        buffer_meta->CopyToOMX(header);\n }\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 8908, "func": "int vrend_renderer_init(struct vrend_if_cbs *cbs, uint32_t flags)\n{\n   int gl_ver;\n   virgl_gl_context gl_context;\n   struct virgl_gl_ctx_param ctx_params;\n\n   if (!vrend_state.inited) {\n      vrend_state.inited = true;\n      vrend_object_init_resource_table();\n      vrend_clicbs = cbs;\n   }\n\n   ctx_params.shared = false;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n\n   gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   vrend_clicbs->make_current(0, gl_context);\n   gl_ver = epoxy_gl_version();\n\n   vrend_state.gl_major_ver = gl_ver / 10;\n   vrend_state.gl_minor_ver = gl_ver % 10;\n   if (gl_ver > 30 && !epoxy_has_gl_extension(\"GL_ARB_compatibility\")) {\n      fprintf(stderr, \"gl_version %d - core profile enabled\\n\", gl_ver);\n      vrend_state.use_core_profile = 1;\n   } else {\n      fprintf(stderr, \"gl_version %d - compat profile\\n\", gl_ver);\n   }\n\n   if (epoxy_has_gl_extension(\"GL_ARB_robustness\"))\n      vrend_state.have_robustness = true;\n   else\n      fprintf(stderr,\"WARNING: running without ARB robustness in place may crash\\n\");\n\n   if (epoxy_has_gl_extension(\"GL_MESA_pack_invert\"))\n      vrend_state.have_mesa_invert = true;\n   if (gl_ver >= 43 || epoxy_has_gl_extension(\"GL_ARB_vertex_attrib_binding\"))\n      vrend_state.have_vertex_attrib_binding = true;\n   if (gl_ver >= 33 || epoxy_has_gl_extension(\"GL_ARB_sampler_objects\"))\n      vrend_state.have_samplers = true;\n   if (gl_ver >= 33 || epoxy_has_gl_extension(\"GL_ARB_shader_bit_encoding\"))\n      vrend_state.have_bit_encoding = true;\n   if (gl_ver >= 31)\n      vrend_state.have_gl_prim_restart = true;\n   else if (epoxy_has_gl_extension(\"GL_NV_primitive_restart\"))\n      vrend_state.have_nv_prim_restart = true;\n   if (gl_ver >= 40 || epoxy_has_gl_extension(\"GL_ARB_transform_feedback2\"))\n      vrend_state.have_tf2 = true;\n\n   if (epoxy_has_gl_extension(\"GL_EXT_framebuffer_multisample\") && epoxy_has_gl_extension(\"GL_ARB_texture_multisample\")) {\n      vrend_state.have_multisample = true;\n      if (epoxy_has_gl_extension(\"GL_EXT_framebuffer_multisample_blit_scaled\"))\n         vrend_state.have_ms_scaled_blit = true;\n   }\n\n   vrend_resource_set_destroy_callback(vrend_destroy_resource_object);\n   vrend_object_set_destroy_callback(VIRGL_OBJECT_QUERY, vrend_destroy_query_object);\n   vrend_object_set_destroy_callback(VIRGL_OBJECT_SURFACE, vrend_destroy_surface_object);\n   vrend_object_set_destroy_callback(VIRGL_OBJECT_SHADER, vrend_destroy_shader_object);\n   vrend_object_set_destroy_callback(VIRGL_OBJECT_SAMPLER_VIEW, vrend_destroy_sampler_view_object);\n   vrend_object_set_destroy_callback(VIRGL_OBJECT_STREAMOUT_TARGET, vrend_destroy_so_target_object);\n   vrend_object_set_destroy_callback(VIRGL_OBJECT_SAMPLER_STATE, vrend_destroy_sampler_state_object);\n   vrend_object_set_destroy_callback(VIRGL_OBJECT_VERTEX_ELEMENTS, vrend_destroy_vertex_elements_object);\n\n   vrend_build_format_list();\n\n   vrend_clicbs->destroy_gl_context(gl_context);\n   list_inithead(&vrend_state.fence_list);\n   list_inithead(&vrend_state.fence_wait_list);\n   list_inithead(&vrend_state.waiting_query_list);\n   list_inithead(&vrend_state.active_ctx_list);\n   vrend_renderer_context_create_internal(0, 0, NULL);\n\n   vrend_state.eventfd = -1;\n   if (flags & VREND_USE_THREAD_SYNC) {\n      vrend_renderer_use_threaded_sync();\n   }\n\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188318, "func": "Track::GetContentEncodingByIndex(unsigned long idx) const {\n   const ptrdiff_t count =\n       content_encoding_entries_end_ - content_encoding_entries_;\n   assert(count >= 0);\n\n if (idx >= static_cast<unsigned long>(count))\n return NULL;\n\n return content_encoding_entries_[idx];\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188240, "func": "OMX_ERRORTYPE SoftRaw::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mChannelCount;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9202, "func": "int virtio_get_num_queues(VirtIODevice *vdev)\n{\n    int i;\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n        if (!virtio_queue_get_num(vdev, i)) {\n            break;\n        }\n    }\n\n    return i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8726, "func": "static int check_chain_extensions(X509_STORE_CTX *ctx)\n{\n#ifdef OPENSSL_NO_CHAIN_VERIFY\n    return 1;\n#else\n    int i, ok = 0, must_be_ca, plen = 0;\n    X509 *x;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    int proxy_path_length = 0;\n    int purpose;\n    int allow_proxy_certs;\n    cb = ctx->verify_cb;\n\n    must_be_ca = -1;\n\n    if (ctx->parent) {\n        allow_proxy_certs = 0;\n        purpose = X509_PURPOSE_CRL_SIGN;\n    } else {\n        allow_proxy_certs =\n            ! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\n        if (getenv(\"OPENSSL_ALLOW_PROXY_CERTS\"))\n            allow_proxy_certs = 1;\n        purpose = ctx->param->purpose;\n    }\n\n    for (i = 0; i < ctx->last_untrusted; i++) {\n        int ret;\n        x = sk_X509_value(ctx->chain, i);\n        if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\n            && (x->ex_flags & EXFLAG_CRITICAL)) {\n            ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {\n            ctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        ret = X509_check_ca(x);\n        switch (must_be_ca) {\n        case -1:\n            if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                && (ret != 1) && (ret != 0)) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        case 0:\n            if (ret != 0) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_NON_CA;\n            } else\n                ret = 1;\n            break;\n        default:\n            if ((ret == 0)\n                || ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                    && (ret != 1))) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        }\n        if (ret == 0) {\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        if (ctx->param->purpose > 0) {\n            ret = X509_check_purpose(x, purpose, must_be_ca > 0);\n            if ((ret == 0)\n                || ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                    && (ret != 1))) {\n                ctx->error = X509_V_ERR_INVALID_PURPOSE;\n                ctx->error_depth = i;\n                ctx->current_cert = x;\n                ok = cb(0, ctx);\n                if (!ok)\n                    goto end;\n            }\n        }\n        if ((i > 1) && !(x->ex_flags & EXFLAG_SI)\n            && (x->ex_pathlen != -1)\n            && (plen > (x->ex_pathlen + proxy_path_length + 1))) {\n            ctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        if (!(x->ex_flags & EXFLAG_SI))\n            plen++;\n        if (x->ex_flags & EXFLAG_PROXY) {\n            if (x->ex_pcpathlen != -1) {\n                if (proxy_path_length > x->ex_pcpathlen) {\n                    ctx->error = X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\n                    ctx->error_depth = i;\n                    ctx->current_cert = x;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto end;\n                }\n                proxy_path_length = x->ex_pcpathlen;\n            }\n            proxy_path_length++;\n            must_be_ca = 0;\n        } else\n            must_be_ca = 1;\n    }\n    ok = 1;\n end:\n    return ok;\n#endif\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9187, "func": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldub_p(vdev->config + addr);\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8818, "func": "translate_stencil_op(GLuint op)\n{\n   switch (op) {\n#define CASE(x) case PIPE_STENCIL_OP_##x: return GL_##x\n      CASE(KEEP);\n      CASE(ZERO);\n      CASE(REPLACE);\n      CASE(INCR);\n      CASE(DECR);\n      CASE(INCR_WRAP);\n      CASE(DECR_WRAP);\n      CASE(INVERT);\n   default:\n      assert(\"invalid stencilop token()\" == NULL);\n      return 0;\n   }\n#undef CASE\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187423, "func": "void SoftMPEG4::onQueueFilled(OMX_U32 \n) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n\n             PortInfo *port = editPortInfo(1);\n             OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n \n             PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n             mFramesConfigured = true;\n         }\n \n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n\n         int32_t bufferSize = inHeader->nFilledLen;\n         int32_t tmp = bufferSize;\n \n        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;\n         if (outHeader->nAllocLen < frameSize) {\n             android_errorWriteLog(0x534e4554, \"27833616\");\n             ALOGE(\"Insufficient output buffer size\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = frameSize;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n", "target": 1, "flaw_line_index": "140"}
{"idx": 188241, "func": "OMX_ERRORTYPE SoftRaw::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.raw\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mChannelCount = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187882, "func": "void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx) {\n   assert(pCluster);\n   assert(pCluster->m_index < 0);\n   assert(idx >= m_clusterCount);\n\n const long count = m_clusterCount + m_clusterPreloadCount;\n\n long& size = m_clusterSize;\n  assert(size >= count);\n\n\n   if (count >= size) {\n     const long n = (size <= 0) ? 2048 : 2 * size;\n \n    Cluster** const qq = new Cluster* [n];\n     Cluster** q = qq;\n \n     Cluster** p = m_clusters;\n Cluster** const pp = p + count;\n\n while (p != pp)\n *q++ = *p++;\n\n delete[] m_clusters;\n\n    m_clusters = qq;\n    size = n;\n }\n\n  assert(m_clusters);\n\n Cluster** const p = m_clusters + idx;\n\n Cluster** q = m_clusters + count;\n  assert(q >= p);\n  assert(q < (m_clusters + size));\n\n while (q > p) {\n Cluster** const qq = q - 1;\n    assert((*qq)->m_index < 0);\n\n *q = *qq;\n    q = qq;\n }\n\n \n   m_clusters[idx] = pCluster;\n   ++m_clusterPreloadCount;\n }\n", "target": 1, "flaw_line_index": "15"}
{"idx": 8486, "func": "UINT CSoundFile::GetSaveFormats() const\n{\n\tUINT n = 0;\n\tif ((!m_nSamples) || (!m_nChannels) || (m_nType == MOD_TYPE_NONE)) return 0;\n\tswitch(m_nType)\n\t{\n\tcase MOD_TYPE_MOD:\tn = MOD_TYPE_MOD;\n\tcase MOD_TYPE_S3M:\tn = MOD_TYPE_S3M;\n\t}\n\tn |= MOD_TYPE_XM | MOD_TYPE_IT;\n\tif (!m_nInstruments)\n\t{\n\t\tif (m_nSamples < 32) n |= MOD_TYPE_MOD;\n\t\tn |= MOD_TYPE_S3M;\n\t}\n\treturn n;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8979, "func": "vmxnet3_cleanup_msi(VMXNET3State *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    msi_uninit(d);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188175, "func": "static void local_socket_close(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n    local_socket_close_locked(s);\n    adb_mutex_unlock(&socket_list_lock);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 188522, "func": "void update_rate_histogram(struct rate_hist *hist,\n const vpx_codec_enc_cfg_t *cfg,\n const vpx_codec_cx_pkt_t *pkt) {\n int i;\n int64_t then = 0;\n int64_t avg_bitrate = 0;\n int64_t sum_sz = 0;\n const int64_t now = pkt->data.frame.pts * 1000 *\n (uint64_t)cfg->g_timebase.num /\n (uint64_t)cfg->g_timebase.den;\n\n int idx = hist->frames++ % hist->samples;\n  hist->pts[idx] = now;\n  hist->sz[idx] = (int)pkt->data.frame.sz;\n\n\n   if (now < cfg->rc_buf_initial_sz)\n     return;\n \n   then = now;\n \n for (i = hist->frames; i > 0 && hist->frames - i < hist->samples; i--) {\n const int i_idx = (i - 1) % hist->samples;\n\n    then = hist->pts[i_idx];\n if (now - then > cfg->rc_buf_sz)\n break;\n    sum_sz += hist->sz[i_idx];\n }\n\n if (now == then)\n return;\n\n  avg_bitrate = sum_sz * 8 * 1000 / (now - then);\n  idx = (int)(avg_bitrate * (RATE_BINS / 2) / (cfg->rc_target_bitrate * 1000));\n if (idx < 0)\n    idx = 0;\n if (idx > RATE_BINS - 1)\n    idx = RATE_BINS - 1;\n if (hist->bucket[idx].low > avg_bitrate)\n    hist->bucket[idx].low = (int)avg_bitrate;\n if (hist->bucket[idx].high < avg_bitrate)\n    hist->bucket[idx].high = (int)avg_bitrate;\n  hist->bucket[idx].count++;\n  hist->total++;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188135, "func": "void lppTransposer (HANDLE_SBR_LPP_TRANS hLppTrans, \n                    QMF_SCALE_FACTOR  *sbrScaleFactor, \n                    FIXP_DBL **qmfBufferReal, \n\n                    FIXP_DBL *degreeAlias, \n                    FIXP_DBL **qmfBufferImag, \n const int useLP,\n const int timeStep, \n const int firstSlotOffs, \n const int lastSlotOffs, \n const int nInvfBands, \n                    INVF_MODE *sbr_invf_mode, \n                    INVF_MODE *sbr_invf_mode_prev      \n )\n{\n  INT    bwIndex[MAX_NUM_PATCHES];\n  FIXP_DBL  bwVector[MAX_NUM_PATCHES]; \n\n int    i;\n int    loBand, start, stop;\n  TRANSPOSER_SETTINGS *pSettings = hLppTrans->pSettings;\n  PATCH_PARAM *patchParam = pSettings->patchParam;\n int    patch;\n\n  FIXP_SGL  alphar[LPC_ORDER], a0r, a1r;\n  FIXP_SGL  alphai[LPC_ORDER], a0i=0, a1i=0;\n  FIXP_SGL  bw = FL2FXCONST_SGL(0.0f);\n\n int    autoCorrLength;\n\n  FIXP_DBL k1, k1_below=0, k1_below2=0;\n\n  ACORR_COEFS ac;\n int    startSample;\n int    stopSample;\n int    stopSampleClear;\n\n int comLowBandScale;\n int ovLowBandShift;\n int lowBandShift;\n int targetStopBand;\n\n\n  alphai[0] = FL2FXCONST_SGL(0.0f);\n  alphai[1] = FL2FXCONST_SGL(0.0f);\n\n\n  startSample = firstSlotOffs * timeStep;\n  stopSample  = pSettings->nCols + lastSlotOffs * timeStep;\n\n\n  inverseFilteringLevelEmphasis(hLppTrans, nInvfBands, sbr_invf_mode, sbr_invf_mode_prev, bwVector);\n\n  stopSampleClear = stopSample;\n\n  autoCorrLength = pSettings->nCols + pSettings->overlap;\n\n  targetStopBand = patchParam[pSettings->noOfPatches-1].targetStartBand\n + patchParam[pSettings->noOfPatches-1].numBandsInPatch;\n\n int memSize = ((64) - targetStopBand) * sizeof(FIXP_DBL);\n\n if (!useLP) {\n for (i = startSample; i < stopSampleClear; i++) {\n FDKmemclear(&qmfBufferReal[i][targetStopBand], memSize);\n FDKmemclear(&qmfBufferImag[i][targetStopBand], memSize);\n }\n } else\n for (i = startSample; i < stopSampleClear; i++) {\n FDKmemclear(&qmfBufferReal[i][targetStopBand], memSize);\n\n   }\n \n  FDKmemclear(bwIndex, pSettings->noOfPatches*sizeof(INT));\n \n  comLowBandScale = fixMin(sbrScaleFactor->ov_lb_scale,sbrScaleFactor->lb_scale);\n\n  ovLowBandShift =  sbrScaleFactor->ov_lb_scale - comLowBandScale;\n  lowBandShift   =  sbrScaleFactor->lb_scale - comLowBandScale;\n\n\n if (!useLP) {\n    start = pSettings->lbStartPatching;\n    stop = pSettings->lbStopPatching;\n } else\n {\n    start = fixMax(1, pSettings->lbStartPatching - 2);\n    stop = patchParam[0].targetStartBand;\n }\n\n\n for ( loBand = start; loBand <  stop; loBand++ ) {\n\n    FIXP_DBL  lowBandReal[(((1024)/(32))+(6))+LPC_ORDER];\n    FIXP_DBL *plowBandReal = lowBandReal;\n    FIXP_DBL **pqmfBufferReal = qmfBufferReal;\n    FIXP_DBL  lowBandImag[(((1024)/(32))+(6))+LPC_ORDER];\n    FIXP_DBL *plowBandImag = lowBandImag;\n    FIXP_DBL **pqmfBufferImag = qmfBufferImag;\n int resetLPCCoeffs=0;\n int dynamicScale = DFRACT_BITS-1-LPC_SCALE_FACTOR;\n int acDetScale = 0; \n\n for(i=0;i<LPC_ORDER;i++){\n *plowBandReal++ = hLppTrans->lpcFilterStatesReal[i][loBand];\n if (!useLP)\n *plowBandImag++ = hLppTrans->lpcFilterStatesImag[i][loBand];\n }\n\n if (!useLP) {\n for(i=0;i<pSettings->nCols+pSettings->overlap;i++){\n *plowBandReal++ = (*pqmfBufferReal++)[loBand];\n *plowBandImag++ = (*pqmfBufferImag++)[loBand];\n }\n } else\n {\n      FDK_ASSERT((pSettings->overlap & 1) == 0);\n\n for(i=0;i<((pSettings->overlap+pSettings->nCols)>>1);i++) {\n *plowBandReal++ = (*pqmfBufferReal++)[loBand];\n *plowBandReal++ = (*pqmfBufferReal++)[loBand];\n }\n if (pSettings->nCols & 1) {\n *plowBandReal++ = (*pqmfBufferReal++)[loBand];\n }\n }\n\n    dynamicScale = fixMin(dynamicScale, getScalefactor(lowBandReal, LPC_ORDER+pSettings->overlap) + ovLowBandShift);\n    dynamicScale = fixMin(dynamicScale, getScalefactor(&lowBandReal[LPC_ORDER+pSettings->overlap], pSettings->nCols) + lowBandShift);\n if (!useLP) {\n      dynamicScale = fixMin(dynamicScale, getScalefactor(lowBandImag, LPC_ORDER+pSettings->overlap) + ovLowBandShift);\n      dynamicScale = fixMin(dynamicScale, getScalefactor(&lowBandImag[LPC_ORDER+pSettings->overlap], pSettings->nCols) + lowBandShift);\n }\n    dynamicScale = fixMax(0, dynamicScale-1); \n\n    scaleValues(&lowBandReal[0], LPC_ORDER+pSettings->overlap, dynamicScale-ovLowBandShift);\n    scaleValues(&lowBandReal[LPC_ORDER+pSettings->overlap], pSettings->nCols, dynamicScale-lowBandShift);\n\n if (!useLP) {\n      scaleValues(&lowBandImag[0], LPC_ORDER+pSettings->overlap, dynamicScale-ovLowBandShift);\n      scaleValues(&lowBandImag[LPC_ORDER+pSettings->overlap], pSettings->nCols, dynamicScale-lowBandShift);\n }\n\n\n if (!useLP) {\n        acDetScale += autoCorr2nd_cplx(&ac, lowBandReal+LPC_ORDER, lowBandImag+LPC_ORDER, autoCorrLength);\n }\n else\n {\n        acDetScale += autoCorr2nd_real(&ac, lowBandReal+LPC_ORDER, autoCorrLength);\n }\n\n      acDetScale += 2*(comLowBandScale + dynamicScale);\n      acDetScale *= 2; \n      acDetScale += ac.det_scale; \n\n if (acDetScale>126 ) {\n        resetLPCCoeffs = 1;\n }\n\n\n    alphar[1] = FL2FXCONST_SGL(0.0f);\n if (!useLP)\n      alphai[1] = FL2FXCONST_SGL(0.0f);\n\n if (ac.det != FL2FXCONST_DBL(0.0f)) {\n      FIXP_DBL tmp,absTmp,absDet;\n\n      absDet = fixp_abs(ac.det);\n\n if (!useLP) {\n        tmp = ( fMultDiv2(ac.r01r,ac.r12r) >> (LPC_SCALE_FACTOR-1) ) -\n ( (fMultDiv2(ac.r01i,ac.r12i) + fMultDiv2(ac.r02r,ac.r11r)) >> (LPC_SCALE_FACTOR-1) );\n } else\n {\n        tmp = ( fMultDiv2(ac.r01r,ac.r12r) >> (LPC_SCALE_FACTOR-1) ) -\n ( fMultDiv2(ac.r02r,ac.r11r) >> (LPC_SCALE_FACTOR-1) );\n }\n      absTmp = fixp_abs(tmp);\n\n {\n        INT scale;\n        FIXP_DBL result = fDivNorm(absTmp, absDet, &scale);\n        scale = scale+ac.det_scale;\n\n if ( (scale > 0) && (result >= (FIXP_DBL)MAXVAL_DBL>>scale) ) {\n          resetLPCCoeffs = 1;\n }\n else {\n          alphar[1] = FX_DBL2FX_SGL(scaleValue(result,scale));\n if((tmp<FL2FX_DBL(0.0f)) ^ (ac.det<FL2FX_DBL(0.0f))) {\n            alphar[1] = -alphar[1];\n }\n }\n }\n\n if (!useLP)\n {\n        tmp = ( fMultDiv2(ac.r01i,ac.r12r) >> (LPC_SCALE_FACTOR-1) ) +\n ( (fMultDiv2(ac.r01r,ac.r12i) - (FIXP_DBL)fMultDiv2(ac.r02i,ac.r11r)) >> (LPC_SCALE_FACTOR-1) ) ;\n\n        absTmp = fixp_abs(tmp);\n\n {\n          INT scale;\n          FIXP_DBL result = fDivNorm(absTmp, absDet, &scale);\n          scale = scale+ac.det_scale;\n\n if ( (scale > 0) && (result >= \n (FIXP_DBL)MAXVAL_DBL>>scale) ) {\n            resetLPCCoeffs = 1;\n }\n else {\n            alphai[1] = FX_DBL2FX_SGL(scaleValue(result,scale));\n if((tmp<FL2FX_DBL(0.0f)) ^ (ac.det<FL2FX_DBL(0.0f))) {\n              alphai[1] = -alphai[1];\n }\n }\n }\n }\n }\n\n    alphar[0] =  FL2FXCONST_SGL(0.0f);\n if (!useLP)\n      alphai[0] = FL2FXCONST_SGL(0.0f);\n\n if ( ac.r11r != FL2FXCONST_DBL(0.0f) ) {\n\n      FIXP_DBL tmp,absTmp;\n\n if (!useLP) {\n        tmp = (ac.r01r>>(LPC_SCALE_FACTOR+1)) +\n (fMultDiv2(alphar[1],ac.r12r) + fMultDiv2(alphai[1],ac.r12i));\n } else\n {\n if(ac.r01r>=FL2FXCONST_DBL(0.0f))\n          tmp = (ac.r01r>>(LPC_SCALE_FACTOR+1)) + fMultDiv2(alphar[1],ac.r12r);\n else\n          tmp = -((-ac.r01r)>>(LPC_SCALE_FACTOR+1)) + fMultDiv2(alphar[1],ac.r12r);\n }\n\n      absTmp = fixp_abs(tmp);\n\n\n if (absTmp >= (ac.r11r>>1)) {\n        resetLPCCoeffs=1;\n }\n else {\n        INT scale;\n        FIXP_DBL result = fDivNorm(absTmp, fixp_abs(ac.r11r), &scale);\n        alphar[0] =  FX_DBL2FX_SGL(scaleValue(result,scale+1));\n\n if((tmp>FL2FX_DBL(0.0f)) ^ (ac.r11r<FL2FX_DBL(0.0f)))\n          alphar[0] = -alphar[0];\n }\n\n if (!useLP)\n {\n        tmp = (ac.r01i>>(LPC_SCALE_FACTOR+1)) +\n (fMultDiv2(alphai[1],ac.r12r) - fMultDiv2(alphar[1],ac.r12i));\n\n        absTmp = fixp_abs(tmp);\n\n if (absTmp >= (ac.r11r>>1)) {\n          resetLPCCoeffs=1;\n }\n else {\n          INT scale;\n          FIXP_DBL result = fDivNorm(absTmp, fixp_abs(ac.r11r), &scale);\n          alphai[0] = FX_DBL2FX_SGL(scaleValue(result,scale+1));\n if((tmp>FL2FX_DBL(0.0f)) ^ (ac.r11r<FL2FX_DBL(0.0f)))\n            alphai[0] = -alphai[0];\n }\n }\n }\n\n\n if (!useLP)\n {\n if( (fMultDiv2(alphar[0],alphar[0]) + fMultDiv2(alphai[0],alphai[0])) >= FL2FXCONST_DBL(0.5f) )\n        resetLPCCoeffs=1;\n if( (fMultDiv2(alphar[1],alphar[1]) + fMultDiv2(alphai[1],alphai[1])) >= FL2FXCONST_DBL(0.5f) )\n        resetLPCCoeffs=1;\n }\n\n if(resetLPCCoeffs){\n      alphar[0] = FL2FXCONST_SGL(0.0f);\n      alphar[1] = FL2FXCONST_SGL(0.0f);\n if (!useLP)\n {\n        alphai[0] = FL2FXCONST_SGL(0.0f);\n        alphai[1] = FL2FXCONST_SGL(0.0f);\n }\n }\n\n if (useLP)\n {\n\n if(ac.r11r==FL2FXCONST_DBL(0.0f)) {\n        k1 = FL2FXCONST_DBL(0.0f);\n }\n else {\n if ( fixp_abs(ac.r01r) >= fixp_abs(ac.r11r) ) {\n if ( fMultDiv2(ac.r01r,ac.r11r) < FL2FX_DBL(0.0f)) {\n            k1 = (FIXP_DBL)MAXVAL_DBL \n;\n }else {\n            k1 = (FIXP_DBL)(MINVAL_DBL+1) \n;\n }\n }\n else {\n          INT scale;\n          FIXP_DBL result = fDivNorm(fixp_abs(ac.r01r), fixp_abs(ac.r11r), &scale);\n          k1 = scaleValue(result,scale);\n\n if(!((ac.r01r<FL2FX_DBL(0.0f)) ^ (ac.r11r<FL2FX_DBL(0.0f)))) {\n            k1 = -k1;\n }\n }\n }\n if(loBand > 1){\n        FIXP_DBL deg = \n (FIXP_DBL)MAXVAL_DBL - fPow2(k1_below);\n        degreeAlias[loBand] = FL2FXCONST_DBL(0.0f);\n if (((loBand & 1) == 0) && (k1 < FL2FXCONST_DBL(0.0f))){\n if (k1_below < FL2FXCONST_DBL(0.0f)) { \n            degreeAlias[loBand] = (FIXP_DBL)MAXVAL_DBL \n;\n if ( k1_below2 > FL2FXCONST_DBL(0.0f) ) { \n              degreeAlias[loBand-1] = deg;\n }\n }\n else if ( k1_below2 > FL2FXCONST_DBL(0.0f) ) { \n            degreeAlias[loBand] = deg;\n }\n }\n if (((loBand & 1) == 1) && (k1 > FL2FXCONST_DBL(0.0f))){\n if (k1_below > FL2FXCONST_DBL(0.0f)) { \n            degreeAlias[loBand] = (FIXP_DBL)MAXVAL_DBL \n;\n if ( k1_below2 < FL2FXCONST_DBL(0.0f) ) { \n              degreeAlias[loBand-1] = deg;\n }\n }\n else if ( k1_below2 < FL2FXCONST_DBL(0.0f) ) { \n            degreeAlias[loBand] = deg;\n }\n }\n }\n      k1_below2 = k1_below;\n      k1_below = k1;\n }\n\n    patch = 0;\n\n while ( patch < pSettings->noOfPatches ) { \n\n int hiBand = loBand + patchParam[patch].targetBandOffs;\n\n if ( loBand < patchParam[patch].sourceStartBand\n || loBand >= patchParam[patch].sourceStopBand\n ) {\n        patch++;\n continue;\n }\n\n\n       FDK_ASSERT( hiBand < (64) );\n \n      while (hiBand >= pSettings->bwBorders[bwIndex[patch]])\n         bwIndex[patch]++;\n \n      bw = FX_DBL2FX_SGL(bwVector[bwIndex[patch]]);\n\n      a0r = FX_DBL2FX_SGL(fMult(bw,alphar[0])); \n\n\n if (!useLP)\n        a0i = FX_DBL2FX_SGL(fMult(bw,alphai[0]));\n      bw =  FX_DBL2FX_SGL(fPow2(bw));\n      a1r = FX_DBL2FX_SGL(fMult(bw,alphar[1]));\n if (!useLP)\n        a1i = FX_DBL2FX_SGL(fMult(bw,alphai[1]));\n\n\n\n\n if ( bw <= FL2FXCONST_SGL(0.0f) ) {\n if (!useLP) {\n int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));\n for(i = startSample; i < stopSample; i++ ) {\n            qmfBufferReal[i][hiBand] = lowBandReal[LPC_ORDER+i]>>descale;\n            qmfBufferImag[i][hiBand] = lowBandImag[LPC_ORDER+i]>>descale;\n }\n } else\n {\n int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));\n for(i = startSample; i < stopSample; i++ ) {\n            qmfBufferReal[i][hiBand] = lowBandReal[LPC_ORDER+i]>>descale;\n }\n }\n }\n else { \n\n if (!useLP) {\n int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));\n#ifdef FUNCTION_LPPTRANSPOSER_func1\n          lppTransposer_func1(lowBandReal+LPC_ORDER+startSample,lowBandImag+LPC_ORDER+startSample,\n                              qmfBufferReal+startSample,qmfBufferImag+startSample,\n                              stopSample-startSample, (int) hiBand,\n                              dynamicScale,descale,\n                              a0r, a0i, a1r, a1i);\n#else\n for(i = startSample; i < stopSample; i++ ) {\n            FIXP_DBL accu1, accu2;\n\n            accu1 = (fMultDiv2(a0r,lowBandReal[LPC_ORDER+i-1]) - fMultDiv2(a0i,lowBandImag[LPC_ORDER+i-1]) +\n                     fMultDiv2(a1r,lowBandReal[LPC_ORDER+i-2]) - fMultDiv2(a1i,lowBandImag[LPC_ORDER+i-2]))>>dynamicScale;\n            accu2 = (fMultDiv2(a0i,lowBandReal[LPC_ORDER+i-1]) + fMultDiv2(a0r,lowBandImag[LPC_ORDER+i-1]) +\n                     fMultDiv2(a1i,lowBandReal[LPC_ORDER+i-2]) + fMultDiv2(a1r,lowBandImag[LPC_ORDER+i-2]))>>dynamicScale;\n\n            qmfBufferReal[i][hiBand] = (lowBandReal[LPC_ORDER+i]>>descale) + (accu1<<1);\n            qmfBufferImag[i][hiBand] = (lowBandImag[LPC_ORDER+i]>>descale) + (accu2<<1);\n }\n#endif\n } else\n {\n int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));\n\n          FDK_ASSERT(dynamicScale >= 0);\n for(i = startSample; i < stopSample; i++ ) {\n            FIXP_DBL accu1;\n\n            accu1 = (fMultDiv2(a0r,lowBandReal[LPC_ORDER+i-1]) + fMultDiv2(a1r,lowBandReal[LPC_ORDER+i-2]))>>dynamicScale;\n\n            qmfBufferReal[i][hiBand] = (lowBandReal[LPC_ORDER+i]>>descale) + (accu1<<1);\n }\n }\n } \n\n      patch++;\n\n } \n\n\n\n } \n\n if (useLP)\n {\n for ( loBand = pSettings->lbStartPatching; loBand <  pSettings->lbStopPatching; loBand++ ) {\n      patch = 0;\n while ( patch < pSettings->noOfPatches ) {\n\n        UCHAR hiBand = loBand + patchParam[patch].targetBandOffs;\n\n if ( loBand < patchParam[patch].sourceStartBand\n || loBand >= patchParam[patch].sourceStopBand\n || hiBand >= (64) \n ) {\n          patch++;\n continue;\n }\n\n if(hiBand != patchParam[patch].targetStartBand)\n          degreeAlias[hiBand] = degreeAlias[loBand];\n\n        patch++;\n }\n }\n }\n\n for (i = 0; i < nInvfBands; i++ ) {\n   hLppTrans->bwVectorOld[i] = bwVector[i];\n }\n\n  sbrScaleFactor->hb_scale = comLowBandScale-(LPC_SCALE_FACTOR);\n\n}\n", "target": 1, "flaw_line_index": "74,372"}
{"idx": 8998, "func": "vmxnet3_get_rx_ring_gen(VMXNET3State *s, int qidx, int ridx)\n{\n    return s->rxq_descr[qidx].rx_ring[ridx].gen;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8737, "func": "vcard7816_vm_process_apdu(VCard *card, VCardAPDU *apdu,\n                          VCardResponse **response)\n{\n    int bytes_to_copy, next_byte_count, count;\n    VCardApplet *current_applet;\n    VCardBufferResponse *buffer_response;\n    vcard_7816_status_t status;\n\n    if (apdu->a_gen_type !=  VCARD_7816_ISO) {\n        *response = vcard_make_response(\n                        VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);\n        return VCARD_DONE;\n    }\n\n    switch (apdu->a_secure_messaging) {\n    case 0x0: \n        break;\n    case 0x4: \n    case 0x8: \n    case 0xc: \n    default:\n        *response = vcard_make_response(\n                        VCARD7816_STATUS_ERROR_SECURE_NOT_SUPPORTED);\n        return VCARD_DONE;\n    }\n\n    switch (apdu->a_ins) {\n    case  VCARD7816_INS_MANAGE_CHANNEL: \n    case  VCARD7816_INS_EXTERNAL_AUTHENTICATE: \n    case  VCARD7816_INS_GET_CHALLENGE: \n    case  VCARD7816_INS_INTERNAL_AUTHENTICATE: \n    case  VCARD7816_INS_ERASE_BINARY: \n    case  VCARD7816_INS_READ_BINARY: \n    case  VCARD7816_INS_WRITE_BINARY: \n    case  VCARD7816_INS_UPDATE_BINARY: \n    case  VCARD7816_INS_READ_RECORD: \n    case  VCARD7816_INS_WRITE_RECORD: \n    case  VCARD7816_INS_UPDATE_RECORD: \n    case  VCARD7816_INS_APPEND_RECORD: \n    case  VCARD7816_INS_ENVELOPE:\n    case  VCARD7816_INS_PUT_DATA:\n        *response = vcard_make_response(\n                            VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);\n        break;\n\n    case  VCARD7816_INS_SELECT_FILE:\n        if (apdu->a_p1 != 0x04) {\n            *response = vcard_make_response(\n                            VCARD7816_STATUS_ERROR_FUNCTION_NOT_SUPPORTED);\n            break;\n        }\n\n        current_applet = vcard_find_applet(card, apdu->a_body, apdu->a_Lc);\n        vcard_select_applet(card, apdu->a_channel, current_applet);\n        if (current_applet) {\n            unsigned char *aid;\n            int aid_len;\n            aid = vcard_applet_get_aid(current_applet, &aid_len);\n            *response = vcard_response_new(card, aid, aid_len, apdu->a_Le,\n                                          VCARD7816_STATUS_SUCCESS);\n        } else {\n            *response = vcard_make_response(\n                             VCARD7816_STATUS_ERROR_FILE_NOT_FOUND);\n        }\n        break;\n\n    case  VCARD7816_INS_VERIFY:\n        if ((apdu->a_p1 != 0x00) || (apdu->a_p2 != 0x00)) {\n            *response = vcard_make_response(\n                            VCARD7816_STATUS_ERROR_WRONG_PARAMETERS);\n        } else {\n            if (apdu->a_Lc == 0) {\n                count = vcard_emul_get_login_count(card);\n                if (count < 0) {\n                    *response = vcard_make_response(\n                                    VCARD7816_STATUS_ERROR_DATA_NOT_FOUND);\n                } else {\n                    if (count > 0xf) {\n                        count = 0xf;\n                    }\n                    *response = vcard_response_new_status_bytes(\n                                                VCARD7816_SW1_WARNING_CHANGE,\n                                                                0xc0 | count);\n                    if (*response == NULL) {\n                        *response = vcard_make_response(\n                                    VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE);\n                    }\n                }\n            } else {\n                status = vcard_emul_login(card, apdu->a_body, apdu->a_Lc);\n                *response = vcard_make_response(status);\n            }\n        }\n        break;\n\n    case VCARD7816_INS_GET_RESPONSE:\n        buffer_response = vcard_get_buffer_response(card);\n        if (!buffer_response) {\n            *response = vcard_make_response(\n                            VCARD7816_STATUS_ERROR_DATA_NOT_FOUND);\n            break;\n        }\n        bytes_to_copy = MIN(buffer_response->len, apdu->a_Le);\n        next_byte_count = MIN(256, buffer_response->len - bytes_to_copy);\n        *response = vcard_response_new_bytes(\n                        card, buffer_response->current, bytes_to_copy,\n                        apdu->a_Le,\n                        next_byte_count ?\n                        VCARD7816_SW1_RESPONSE_BYTES : VCARD7816_SW1_SUCCESS,\n                        next_byte_count);\n        buffer_response->current += bytes_to_copy;\n        buffer_response->len -= bytes_to_copy;\n        if (*response == NULL || (next_byte_count == 0)) {\n            vcard_set_buffer_response(card, NULL);\n            vcard_buffer_response_delete(buffer_response);\n        }\n        if (*response == NULL) {\n            *response =\n                vcard_make_response(VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE);\n        }\n        break;\n\n    case VCARD7816_INS_GET_DATA:\n        *response =\n            vcard_make_response(VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);\n        break;\n\n    default:\n        *response =\n            vcard_make_response(VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);\n        break;\n    }\n\n    assert(*response != NULL);\n    return VCARD_DONE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8375, "func": "static void mptsas_process_port_enable(MPTSASState *s,\n                                       MPIMsgPortEnable *req)\n{\n    MPIMsgPortEnableReply reply;\n\n    mptsas_fix_port_enable_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    memset(&reply, 0, sizeof(reply));\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.PortNumber = req->PortNumber;\n    reply.Function   = req->Function;\n    reply.MsgContext = req->MsgContext;\n\n    mptsas_fix_port_enable_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188095, "func": "netdutils::Status XfrmController::ipSecSetEncapSocketOwner(const android::base::unique_fd& socket,\n int newUid, uid_t callerUid) {\n    ALOGD(\"XfrmController:%s, line=%d\", __FUNCTION__, __LINE__);\n\n const int fd = socket.get();\n struct stat info;\n if (fstat(fd, &info)) {\n return netdutils::statusFromErrno(errno, \"Failed to stat socket file descriptor\");\n }\n if (info.st_uid != callerUid) {\n return netdutils::statusFromErrno(EPERM, \"fchown disabled for non-owner calls\");\n }\n if (S_ISSOCK(info.st_mode) == 0) {\n return netdutils::statusFromErrno(EINVAL, \"File descriptor was not a socket\");\n\n     }\n \n     int optval;\n    socklen_t optlen;\n     netdutils::Status status =\n         getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);\n     if (status != netdutils::status::ok) {\n return status;\n }\n if (optval != UDP_ENCAP_ESPINUDP && optval != UDP_ENCAP_ESPINUDP_NON_IKE) {\n return netdutils::statusFromErrno(EINVAL, \"Socket did not have UDP-encap sockopt set\");\n }\n if (fchown(fd, newUid, -1)) {\n return netdutils::statusFromErrno(errno, \"Failed to fchown socket file descriptor\");\n }\n\n return netdutils::status::ok;\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 188023, "func": " status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {\n     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;\n     status_t err = OK;\n     switch (nalUnitType) {\n         case 32:  \n             err = parseVps(data + 2, size - 2);\n             break;\n         case 33:  \n             err = parseSps(data + 2, size - 2);\n             break;\n         case 34:  \n             err = parsePps(data + 2, size - 2);\n             break;\n         case 39:  \n case 40: \n break;\n default:\n            ALOGE(\"Unrecognized NAL unit type.\");\n return ERROR_MALFORMED;\n }\n\n if (err != OK) {\n return err;\n }\n\n    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);\n    buffer->setInt32Data(nalUnitType);\n    mNalUnits.push(buffer);\n return OK;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187365, "func": " int32_t DownmixLib_Create(const effect_uuid_t *uuid,\n        int32_t sessionId,\n        int32_t ioId,\n         effect_handle_t *pHandle) {\n     int ret;\n     int i;\n downmix_module_t *module;\n const effect_descriptor_t *desc;\n\n    ALOGV(\"DownmixLib_Create()\");\n\n#ifdef DOWNMIX_TEST_CHANNEL_INDEX\n    ALOGI(\"DOWNMIX_TEST_CHANNEL_INDEX: should work:\");\n Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |\n                    AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER);\n Downmix_testIndexComputation(CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK);\n Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER);\n Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER);\n    ALOGI(\"DOWNMIX_TEST_CHANNEL_INDEX: should NOT work:\");\n Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |\n                        AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT);\n Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |\n                            AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT);\n Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |\n                        AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT);\n Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |\n                            AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT);\n#endif\n\n if (pHandle == NULL || uuid == NULL) {\n return -EINVAL;\n }\n\n for (i = 0 ; i < kNbEffects ; i++) {\n        desc = gDescriptors[i];\n if (memcmp(uuid, &desc->uuid, sizeof(effect_uuid_t)) == 0) {\n break;\n }\n }\n\n if (i == kNbEffects) {\n return -ENOENT;\n }\n\n    module = malloc(sizeof(downmix_module_t));\n\n    module->itfe = &gDownmixInterface;\n\n    module->context.state = DOWNMIX_STATE_UNINITIALIZED;\n\n    ret = Downmix_Init(module);\n if (ret < 0) {\n        ALOGW(\"DownmixLib_Create() init failed\");\n        free(module);\n return ret;\n }\n\n *pHandle = (effect_handle_t) module;\n\n    ALOGV(\"DownmixLib_Create() %p , size %zu\", module, sizeof(downmix_module_t));\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8561, "func": "void ssh_connshare_log(Ssh ssh, int event, const char *logtext,\n                       const char *ds_err, const char *us_err)\n{\n    if (event == SHARE_NONE) {\n        if (logtext) {\n            logeventf(ssh, \"Could not set up connection sharing: %s\", logtext);\n        } else {\n            if (ds_err)\n                logeventf(ssh, \"Could not set up connection sharing\"\n                          \" as downstream: %s\", ds_err);\n            if (us_err)\n                logeventf(ssh, \"Could not set up connection sharing\"\n                          \" as upstream: %s\", us_err);\n        }\n    } else if (event == SHARE_DOWNSTREAM) {\n        logeventf(ssh, \"Using existing shared connection at %s\", logtext);\n        if ((flags & FLAG_VERBOSE) || (flags & FLAG_INTERACTIVE)) {\n            c_write_str(ssh,\"Reusing a shared connection to this server.\\r\\n\");\n        }\n    } else if (event == SHARE_UPSTREAM) {\n        logeventf(ssh, \"Sharing this connection at %s\", logtext);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187411, "func": "void RilSapSocket::sendResponse(MsgHeader* hdr) {\n size_t encoded_size = 0;\n uint32_t written_size;\n size_t buffer_size = 0;\n pb_ostream_t ostream;\n bool success = false;\n\n    pthread_mutex_lock(&write_lock);\n\n\n     if ((success = pb_get_encoded_size(&encoded_size, MsgHeader_fields,\n         hdr)) && encoded_size <= INT32_MAX && commandFd != -1) {\n         buffer_size = encoded_size + sizeof(uint32_t);\n        uint8_t buffer[buffer_size];\n         written_size = htonl((uint32_t) encoded_size);\n         ostream = pb_ostream_from_buffer(buffer, buffer_size);\n         pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));\n        success = pb_encode(&ostream, MsgHeader_fields, hdr);\n\n if (success) {\n            RLOGD(\"Size: %d (0x%x) Size as written: 0x%x\", encoded_size, encoded_size,\n        written_size);\n            log_hex(\"onRequestComplete\", &buffer[sizeof(written_size)], encoded_size);\n            RLOGI(\"[%d] < SAP RESPONSE type: %d. id: %d. error: %d\",\n        hdr->token, hdr->type, hdr->id,hdr->error );\n\n if ( 0 != blockingWrite_helper(commandFd, buffer, buffer_size)) {\n                RLOGE(\"Error %d while writing to fd\", errno);\n } else {\n                RLOGD(\"Write successful\");\n }\n } else {\n\n             RLOGE(\"Error while encoding response of type %d id %d buffer_size: %d: %s.\",\n             hdr->type, hdr->id, buffer_size, PB_GET_ERROR(&ostream));\n         }\n     } else {\n     RLOGE(\"Not sending response type %d: encoded_size: %u. commandFd: %d. encoded size result: %d\",\n         hdr->type, encoded_size, commandFd, success);\n }\n\n    pthread_mutex_unlock(&write_lock);\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 8777, "func": "static NOINLINE int send_renew(uint32_t xid, uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\tstruct in_addr temp_addr;\n\n\tinit_packet(&packet, DHCPREQUEST);\n\n\tpacket.xid = xid;\n\tpacket.ciaddr = ciaddr;\n\n\tadd_client_options(&packet);\n\n\ttemp_addr.s_addr = server;\n\tbb_error_msg(\"sending renew to %s\", inet_ntoa(temp_addr));\n\treturn bcast_or_ucast(&packet, ciaddr, server);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187758, "func": " make_random_bytes(png_uint_32* seed, void* pv, size_t size)\n {\n    png_uint_32 u0 = seed[0], u1 = seed[1];\n   png_bytep bytes = png_voidcast(png_bytep, pv);\n \n size_t i;\n for (i=0; i<size; ++i)\n {\n      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;\n      u1 <<= 8;\n      u1 |= u0 >> 24;\n      u0 <<= 8;\n      u0 |= u;\n *bytes++ = (png_byte)u;\n }\n\n   seed[0] = u0;\n   seed[1] = u1;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 188057, "func": "IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(\n dec_state_t *ps_dec,\n    WORD16      *pi2_outAddr, \n const UWORD8 *pu1_scan, \n    UWORD8      *pu1_pos, \n    UWORD16     u2_intra_flag, \n    UWORD16     u2_chroma_flag, \n    UWORD16     u2_d_picture, \n    UWORD16     u2_intra_vlc_format, \n    UWORD16     u2_mpeg2, \n    WORD32      *pi4_num_coeffs \n )\n{\n\n    UWORD32 u4_sym_len;\n\n    UWORD32 u4_decoded_value;\n    UWORD32 u4_level_first_byte;\n    WORD32  u4_level;\n    UWORD32 u4_run, u4_numCoeffs;\n    UWORD32 u4_buf;\n    UWORD32 u4_buf_nxt;\n    UWORD32 u4_offset;\n    UWORD32 *pu4_buf_aligned;\n    UWORD32 u4_bits;\n stream_t *ps_stream = &ps_dec->s_bit_stream;\n    WORD32  u4_pos;\n    UWORD32 u4_nz_cols;\n    UWORD32 u4_nz_rows;\n\n *pi4_num_coeffs = 0;\n\n    ps_dec->u4_non_zero_cols = 0;\n    ps_dec->u4_non_zero_rows = 0;\n    u4_nz_cols = ps_dec->u4_non_zero_cols;\n    u4_nz_rows = ps_dec->u4_non_zero_rows;\n\n    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)\n if(u2_intra_flag)\n {\n        WORD32 dc_size;\n        WORD32 dc_diff;\n        WORD32 maxLen;\n        WORD32 idx;\n\n\n        maxLen = MPEG2_DCT_DC_SIZE_LEN;\n        idx = 0;\n if(u2_chroma_flag != 0)\n {\n            maxLen += 1;\n            idx++;\n }\n\n\n {\n            WORD16  end = 0;\n            UWORD32 maxLen_tmp = maxLen;\n            UWORD16 m_iBit;\n\n\n            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)\n do\n {\n                maxLen_tmp--;\n                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);\n\n                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];\n }while(end > 0);\n            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;\n\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)\n\n }\n\n\n\n if (dc_size != 0)\n {\n            UWORD32 u4_bits;\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)\n            dc_diff = u4_bits;\n\n if ((dc_diff & (1 << (dc_size - 1))) == 0) \n                dc_diff -= (1 << dc_size) - 1;\n }\n else\n {\n            dc_diff = 0;\n }\n\n\n        pi2_outAddr[*pi4_num_coeffs] = dc_diff;\n        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n\n if (0 != dc_diff)\n {\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n\n        u4_numCoeffs = 1;\n }\n else\n {\n        UWORD32 u4_bits;\n\n        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)\n\n if(u4_bits == 1)\n {\n\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)\n if(u4_bits == 1)\n {\n                pi2_outAddr[*pi4_num_coeffs] = -1;\n }\n else\n {\n                pi2_outAddr[*pi4_num_coeffs] = 1;\n }\n\n            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n            u4_numCoeffs = 1;\n\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n else\n {\n            u4_numCoeffs = 0;\n }\n }\n if (1 == u2_d_picture)\n {\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);\n }\n\n\n\n if (1 == u2_intra_vlc_format && u2_intra_flag)\n {\n\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                WORD16 DecodedValue;\n\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)\n \n                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];\n                 u4_sym_len = (DecodedValue & 0xf);\n                 u4_level = DecodedValue >> 9;\n if(0 != u4_level)\n {\n                    u4_run = ((DecodedValue >> 4) & 0x1f);\n                    u4_numCoeffs       += u4_run;\n                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else\n {\n if (DecodedValue == END_OF_BLOCK_ONE)\n {\n                        u4_sym_len = 4;\n\n break;\n }\n else\n {\n                        lead_zeros = CLZ(u4_bits) - 20;\n if (0 != lead_zeros)\n {\n\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n if (1 == lead_zeros)\n {\n                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;\n }\n else\n {\n                                u4_sym_len         = 11 + lead_zeros;\n }\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                                u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else\n {\n\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                                u4_decoded_value     = u4_bits;\n                            u4_run              = (u4_decoded_value >> 8);\n                            u4_level_first_byte = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                    u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs += u4_run;\n\n                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];\n\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n                u4_nz_cols |= 1 << (u4_pos & 0x7);\n                u4_nz_rows |= 1 << (u4_pos >> 0x3);\n\n if (u4_numCoeffs > 64)\n {\n return IMPEG2D_MB_TEX_DECODE_ERR;\n }\n\n }\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n }\n else\n {\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                UWORD16 DecodedValue;\n\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)\n \n \n                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];\n                 u4_sym_len = BITS(DecodedValue, 3, 0);\n                u4_level = ((WORD16) DecodedValue) >> 9;\n\n if (0 != u4_level)\n {\n                    u4_run = BITS(DecodedValue, 8,4);\n\n                    u4_numCoeffs       += u4_run;\n\n                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else\n {\n if(DecodedValue == END_OF_BLOCK_ZERO)\n {\n                        u4_sym_len = 2;\n\n break;\n }\n else\n {\n                        lead_zeros = CLZ(u4_bits) - 20;\n if (0 != lead_zeros)\n {\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n                            u4_sym_len         = 11 + lead_zeros;\n\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n if (1 == lead_zeros)\n                                u4_sym_len--;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                            u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else\n {\n\n                            u4_sym_len             = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                            u4_decoded_value        = u4_bits;\n                            u4_run                 = (u4_decoded_value >> 8);\n                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n                u4_nz_cols |= 1 << (u4_pos & 0x7);\n                u4_nz_rows |= 1 << (u4_pos >> 0x3);\n if (u4_numCoeffs > 64)\n {\n return IMPEG2D_MB_TEX_DECODE_ERR;\n }\n\n }\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n\n }\n\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187405, "func": "static vpx_codec_err_t vp8_peek_si_internal(const uint8_t *data,\n unsigned int data_sz,\n vpx_codec_stream_info_t *si,\n                                            vpx_decrypt_cb decrypt_cb,\n void *decrypt_state)\n{\n vpx_codec_err_t res = VPX_CODEC_OK;\n\n if(data + data_sz <= data)\n {\n        res = VPX_CODEC_INVALID_PARAM;\n }\n else\n {\n uint8_t clear_buffer[10];\n const uint8_t *clear = data;\n if (decrypt_cb)\n {\n int n = MIN(sizeof(clear_buffer), data_sz);\n            decrypt_cb(decrypt_state, data, clear_buffer, n);\n            clear = clear_buffer;\n }\n        si->is_kf = 0;\n\n if (data_sz >= 10 && !(clear[0] & 0x01)) \n {\n            si->is_kf = 1;\n\n if (clear[3] != 0x9d || clear[4] != 0x01 || clear[5] != 0x2a)\n return VPX_CODEC_UNSUP_BITSTREAM;\n\n            si->w = (clear[6] | (clear[7] << 8)) & 0x3fff;\n\n             si->h = (clear[8] | (clear[9] << 8)) & 0x3fff;\n \n            if (!(si->h | si->w))\n                res = VPX_CODEC_UNSUP_BITSTREAM;\n         }\n         else\n         {\n            res = VPX_CODEC_UNSUP_BITSTREAM;\n }\n }\n\n return res;\n}\n", "target": 1, "flaw_line_index": "36,37"}
{"idx": 8623, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n                int x, int y, int w, int h)\n{\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n    rect->x = x;\n    rect->y = y;\n    rect->w = w;\n    rect->h = h;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187825, "func": "int Track::Info::CopyStr(char* Info::*str, Info& dst_) const {\n if (str == static_cast<char * Info::*>(NULL))\n return -1;\n\n char*& dst = dst_.*str;\n\n if (dst) \n return -1;\n\n const char* const src = this->*str;\n\n if (src == NULL)\n return 0;\n\n \n   const size_t len = strlen(src);\n \n  dst = new (std::nothrow) char[len + 1];\n \n   if (dst == NULL)\n     return -1;\n\n  strcpy(dst, src);\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "18"}
{"idx": 188517, "func": "static void die(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    if(fmt[strlen(fmt)-1] != '\\n')\n        printf(\"\\n\");\n    exit(EXIT_FAILURE);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8"}
{"idx": 9030, "func": "vmxnet3_pop_next_tx_descr(VMXNET3State *s,\n                          int qidx,\n                          struct Vmxnet3_TxDesc *txd,\n                          uint32_t *descr_idx)\n{\n    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet3_ring_read_curr_cell(d, ring, txd);\n    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {\n        smp_rmb();\n        vmxnet3_ring_read_curr_cell(d, ring, txd);\n        VMXNET3_RING_DUMP(VMW_RIPRN, \"TX\", qidx, ring);\n        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);\n        vmxnet3_inc_tx_consumption_counter(s, qidx);\n        return true;\n    }\n\n    return false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187909, "func": " std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n  if (!func_name.empty()) {\n#if defined(__APPLE__)\n    if (func_name[0] != '_') {\n      return func_name;\n    }\n#endif\n    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n    if (name) {\n      func_name = name;\n      free(name);\n    }\n  }\n   return func_name;\n }\n", "target": 1, "flaw_line_index": "3,4,5,6,7,8,9,10,11,12,13,14,15"}
{"idx": 187340, "func": "xsltStylePreCompute(xsltStylesheetPtr style, xmlNodePtr inst) {\n    if ((inst == NULL) || (inst->type != XML_ELEMENT_NODE) ||\n        (inst->psvi != NULL))\n\treturn;\n\n    if (IS_XSLT_ELEM(inst)) {\n\txsltStylePreCompPtr cur;\n\n\tif (IS_XSLT_NAME(inst, \"apply-templates\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltApplyTemplatesComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"with-param\")) {\n\t    xsltCheckParentElement(style, inst, BAD_CAST \"apply-templates\",\n\t                           BAD_CAST \"call-template\");\n\t    xsltWithParamComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"value-of\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltValueOfComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"copy\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltCopyComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"copy-of\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltCopyOfComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"if\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltIfComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"when\")) {\n\t    xsltCheckParentElement(style, inst, BAD_CAST \"choose\", NULL);\n\t    xsltWhenComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"choose\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltChooseComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"for-each\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltForEachComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"apply-imports\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltApplyImportsComp(style, inst);\n \t} else if (IS_XSLT_NAME(inst, \"attribute\")) {\n \t    xmlNodePtr parent = inst->parent;\n \n\t    if ((parent == NULL) || (parent->ns == NULL) ||\n \t\t((parent->ns != inst->ns) &&\n \t\t (!xmlStrEqual(parent->ns->href, inst->ns->href))) ||\n \t\t(!xmlStrEqual(parent->name, BAD_CAST \"attribute-set\"))) {\n\t\txsltCheckInstructionElement(style, inst);\n\t    }\n\t    xsltAttributeComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"element\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltElementComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"text\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltTextComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"sort\")) {\n\t    xsltCheckParentElement(style, inst, BAD_CAST \"apply-templates\",\n\t                           BAD_CAST \"for-each\");\n\t    xsltSortComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"comment\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltCommentComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"number\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltNumberComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"processing-instruction\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltProcessingInstructionComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"call-template\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    xsltCallTemplateComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"param\")) {\n\t    if (xsltCheckTopLevelElement(style, inst, 0) == 0)\n\t        xsltCheckInstructionElement(style, inst);\n\t    xsltParamComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"variable\")) {\n\t    if (xsltCheckTopLevelElement(style, inst, 0) == 0)\n\t        xsltCheckInstructionElement(style, inst);\n\t    xsltVariableComp(style, inst);\n\t} else if (IS_XSLT_NAME(inst, \"otherwise\")) {\n\t    xsltCheckParentElement(style, inst, BAD_CAST \"choose\", NULL);\n\t    xsltCheckInstructionElement(style, inst);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"template\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"output\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"preserve-space\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"strip-space\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if ((IS_XSLT_NAME(inst, \"stylesheet\")) ||\n\t           (IS_XSLT_NAME(inst, \"transform\"))) {\n\t    xmlNodePtr parent = inst->parent;\n\n\t    if ((parent == NULL) || (parent->type != XML_DOCUMENT_NODE)) {\n\t\txsltTransformError(NULL, style, inst,\n\t\t    \"element %s only allowed only as root element\\n\",\n\t\t\t\t   inst->name);\n\t\tstyle->errors++;\n\t    }\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"key\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"message\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"attribute-set\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"namespace-alias\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"include\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"import\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"decimal-format\")) {\n\t    xsltCheckTopLevelElement(style, inst, 1);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"fallback\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    return;\n\t} else if (IS_XSLT_NAME(inst, \"document\")) {\n\t    xsltCheckInstructionElement(style, inst);\n\t    inst->psvi = (void *) xsltDocumentComp(style, inst,\n\t\t\t\t(xsltTransformFunction) xsltDocumentElem);\n\t} else {\n\t    xsltTransformError(NULL, style, inst,\n\t\t \"xsltStylePreCompute: unknown xsl:%s\\n\", inst->name);\n\t    if (style != NULL) style->warnings++;\n\t}\n\n\tcur = (xsltStylePreCompPtr) inst->psvi;\n\tif (cur != NULL) {\n\t    int i = 0;\n\n\t    cur->nsList = xmlGetNsList(inst->doc, inst);\n            if (cur->nsList != NULL) {\n\t\twhile (cur->nsList[i] != NULL)\n\t\t    i++;\n\t    }\n\t    cur->nsNr = i;\n\t}\n    } else {\n\tinst->psvi =\n\t    (void *) xsltPreComputeExtModuleElement(style, inst);\n\n\tif (inst->psvi == NULL)\n\t    inst->psvi = (void *) xsltExtMarker;\n    }\n}\n", "target": 1, "flaw_line_index": "43"}
{"idx": 187560, "func": "status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)\n\n {\n     ALOGV(\"setDataSource(%d, %\" PRId64 \", %\" PRId64 \")\", fd, offset, length);\n     status_t err = UNKNOWN_ERROR;\n    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(fd, offset, length))) {\n            player.clear();\n }\n        err = attachNewPlayer(player);\n }\n return err;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 188174, "func": " void install_local_socket(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n \n     s->id = local_socket_next_id++;\n \n     if (local_socket_next_id == 0) {\n        local_socket_next_id = 1;\n     }\n \n     insert_local_socket(s, &local_socket_list);\n    adb_mutex_unlock(&socket_list_lock);\n }\n", "target": 1, "flaw_line_index": "2,8,12"}
{"idx": 8490, "func": "BOOL CSoundFile::RemoveSelectedSamples(BOOL *pbIns)\n{\n\tif (!pbIns) return FALSE;\n\tfor (UINT j=1; j<MAX_SAMPLES; j++)\n\t{\n\t\tif ((!pbIns[j]) && (Ins[j].pSample))\n\t\t{\n\t\t\tDestroySample(j);\n\t\t\tif ((j == m_nSamples) && (j > 1)) m_nSamples--;\n\t\t}\n\t}\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9129, "func": "struct vrend_context *vrend_lookup_renderer_ctx(uint32_t ctx_id)\n{\n   if (ctx_id >= VREND_MAX_CTX)\n      return NULL;\n\n   if (dec_ctx[ctx_id] == NULL)\n      return NULL;\n\n   return dec_ctx[ctx_id]->grctx;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8952, "func": "void net_tx_pkt_build_vheader(struct NetTxPkt *pkt, bool tso_enable,\n    bool csum_enable, uint32_t gso_size)\n{\n    struct tcp_hdr l4hdr;\n    assert(pkt);\n\n    assert(csum_enable || !tso_enable);\n\n    pkt->virt_hdr.gso_type = net_tx_pkt_get_gso_type(pkt, tso_enable);\n\n    switch (pkt->virt_hdr.gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n    case VIRTIO_NET_HDR_GSO_NONE:\n        pkt->virt_hdr.hdr_len = 0;\n        pkt->virt_hdr.gso_size = 0;\n        break;\n\n    case VIRTIO_NET_HDR_GSO_UDP:\n        pkt->virt_hdr.gso_size = gso_size;\n        pkt->virt_hdr.hdr_len = pkt->hdr_len + sizeof(struct udp_header);\n        break;\n\n    case VIRTIO_NET_HDR_GSO_TCPV4:\n    case VIRTIO_NET_HDR_GSO_TCPV6:\n        iov_to_buf(&pkt->vec[NET_TX_PKT_PL_START_FRAG], pkt->payload_frags,\n                   0, &l4hdr, sizeof(l4hdr));\n        pkt->virt_hdr.hdr_len = pkt->hdr_len + l4hdr.th_off * sizeof(uint32_t);\n        pkt->virt_hdr.gso_size = gso_size;\n        break;\n\n    default:\n        g_assert_not_reached();\n    }\n\n    if (csum_enable) {\n        switch (pkt->l4proto) {\n        case IP_PROTO_TCP:\n            pkt->virt_hdr.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n            pkt->virt_hdr.csum_start = pkt->hdr_len;\n            pkt->virt_hdr.csum_offset = offsetof(struct tcp_hdr, th_sum);\n            break;\n        case IP_PROTO_UDP:\n            pkt->virt_hdr.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n            pkt->virt_hdr.csum_start = pkt->hdr_len;\n            pkt->virt_hdr.csum_offset = offsetof(struct udp_hdr, uh_sum);\n            break;\n        default:\n            break;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187532, "func": "void CameraSource::signalBufferReturned(MediaBuffer *buffer) {\n    ALOGV(\"signalBufferReturned: %p\", buffer->data());\n Mutex::Autolock autoLock(mLock);\n\n     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();\n          it != mFramesBeingEncoded.end(); ++it) {\n         if ((*it)->pointer() ==  buffer->data()) {\n             releaseOneRecordingFrame((*it));\n             mFramesBeingEncoded.erase(it);\n             ++mNumFramesEncoded;\n            buffer->setObserver(0);\n            buffer->release();\n            mFrameCompleteCondition.signal();\n return;\n }\n }\n    CHECK(!\"signalBufferReturned: bogus buffer\");\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187709, "func": " random_32(void)\n {\n \n   for(;;)\n    {\n       png_byte mark[4];\n       png_uint_32 result;\n\n      store_pool_mark(mark);\n      result = png_get_uint_32(mark);\n\n if (result != 0)\n return result;\n }\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8357, "func": "static uint32_t mptsas_doorbell_read(MPTSASState *s)\n{\n    uint32_t ret;\n\n    ret = (s->who_init << MPI_DOORBELL_WHO_INIT_SHIFT) & MPI_DOORBELL_WHO_INIT_MASK;\n    ret |= s->state;\n    switch (s->doorbell_state) {\n    case DOORBELL_NONE:\n        break;\n\n    case DOORBELL_WRITE:\n        ret |= MPI_DOORBELL_ACTIVE;\n        break;\n\n    case DOORBELL_READ:\n        ret &= ~MPI_DOORBELL_DATA_MASK;\n\n        assert(s->intr_status & MPI_HIS_DOORBELL_INTERRUPT);\n        assert(s->doorbell_reply_idx <= s->doorbell_reply_size);\n\n        ret |= MPI_DOORBELL_ACTIVE;\n        if (s->doorbell_reply_idx < s->doorbell_reply_size) {\n            ret |= le16_to_cpu(s->doorbell_reply[s->doorbell_reply_idx++]);\n        }\n        break;\n\n    default:\n        abort();\n    }\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8587, "func": "static int ssh_rportcmp_ssh1(void *av, void *bv)\n{\n    struct ssh_rportfwd *a = (struct ssh_rportfwd *) av;\n    struct ssh_rportfwd *b = (struct ssh_rportfwd *) bv;\n    int i;\n    if ( (i = strcmp(a->dhost, b->dhost)) != 0)\n\treturn i < 0 ? -1 : +1;\n    if (a->dport > b->dport)\n\treturn +1;\n    if (a->dport < b->dport)\n\treturn -1;\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187667, "func": " image_transform_png_set_scale_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n return bit_depth > 8;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 9189, "func": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = lduw_p(vdev->config + addr);\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8688, "func": "mkalldirs (const char *path)\n{\n  const char *p;\n  char *t;\n  struct stat st;\n  int res;\n\n  p = path + strlen (path);\n  for (; *p != '/' && p != path; p--)\n    ;\n\n  if ((p == path) && (*p != '/'))\n    return 0;\n  t = strdupdelim (path, p);\n\n  if ((stat (t, &st) == 0))\n    {\n      if (S_ISDIR (st.st_mode))\n        {\n          xfree (t);\n          return 0;\n        }\n      else\n        {\n             http:\n             not redirect it too http:\n          DEBUGP ((\"Removing %s because of directory danger!\\n\", t));\n          if (unlink (t))\n            logprintf (LOG_NOTQUIET, \"Failed to unlink %s (%d): %s\\n\",\n                       t, errno, strerror(errno));\n        }\n    }\n  res = make_directory (t);\n  if (res != 0)\n    logprintf (LOG_NOTQUIET, \"%s: %s\\n\", t, strerror (errno));\n  xfree (t);\n  return res;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187969, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    UWORD32 u4_slice_vertical_position;\n    UWORD32 u4_slice_vertical_position_extension;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    ps_stream = &ps_dec->s_bit_stream;\n\n\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);\n    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);\n if(u4_slice_vertical_position > 2800)\n {\n        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);\n        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);\n }\n\n if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||\n (u4_slice_vertical_position == 0))\n {\n return IMPEG2D_INVALID_VERT_SIZE;\n }\n\n    u4_slice_vertical_position--;\n if (ps_dec->u2_mb_y != u4_slice_vertical_position)\n {\n        ps_dec->u2_mb_y    = u4_slice_vertical_position;\n        ps_dec->u2_mb_x    = 0;\n }\n    ps_dec->u2_first_mb = 1;\n\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n }\n\n if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }\n }\n    impeg2d_bit_stream_get_bit(ps_stream);\n\n    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n\n    e_error = ps_dec->pf_decode_slice(ps_dec);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)\n        impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "flaw_line_index": "45"}
{"idx": 188229, "func": "OMX_ERRORTYPE SoftGSM::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = 1;\n            pcmParams->nSamplingRate = 8000;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188258, "func": "void SparseBitSet::initFromRanges(const uint32_t* ranges, size_t nRanges) {\n if (nRanges == 0) {\n        mMaxVal = 0;\n        mIndices.reset();\n        mBitmaps.reset();\n return;\n }\n    mMaxVal = ranges[nRanges * 2 - 1];\n size_t indexSize = (mMaxVal + kPageMask) >> kLogValuesPerPage;\n    mIndices.reset(new uint32_t[indexSize]);\n uint32_t nPages = calcNumPages(ranges, nRanges);\n    mBitmaps.reset(new element[nPages << (kLogValuesPerPage - kLogBitsPerEl)]);\n    memset(mBitmaps.get(), 0, nPages << (kLogValuesPerPage - 3));\n    mZeroPageIndex = noZeroPage;\n uint32_t nonzeroPageEnd = 0;\n uint32_t currentPage = 0;\n\n     for (size_t i = 0; i < nRanges; i++) {\n         uint32_t start = ranges[i * 2];\n         uint32_t end = ranges[i * 2 + 1];\n         uint32_t startPage = start >> kLogValuesPerPage;\n         uint32_t endPage = (end - 1) >> kLogValuesPerPage;\n         if (startPage >= nonzeroPageEnd) {\n if (startPage > nonzeroPageEnd) {\n if (mZeroPageIndex == noZeroPage) {\n                    mZeroPageIndex = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);\n }\n for (uint32_t j = nonzeroPageEnd; j < startPage; j++) {\n                    mIndices[j] = mZeroPageIndex;\n }\n }\n            mIndices[startPage] = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);\n }\n\n size_t index = ((currentPage - 1) << (kLogValuesPerPage - kLogBitsPerEl)) +\n ((start & kPageMask) >> kLogBitsPerEl);\n size_t nElements = (end - (start & ~kElMask) + kElMask) >> kLogBitsPerEl;\n if (nElements == 1) {\n            mBitmaps[index] |= (kElAllOnes >> (start & kElMask)) &\n (kElAllOnes << ((-end) & kElMask));\n } else {\n            mBitmaps[index] |= kElAllOnes >> (start & kElMask);\n for (size_t j = 1; j < nElements - 1; j++) {\n                mBitmaps[index + j] = kElAllOnes;\n }\n            mBitmaps[index + nElements - 1] |= kElAllOnes << ((-end) & kElMask);\n }\n for (size_t j = startPage + 1; j < endPage + 1; j++) {\n            mIndices[j] = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);\n }\n        nonzeroPageEnd = endPage + 1;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8919, "func": "void vrend_renderer_set_sub_ctx(struct vrend_context *ctx, int sub_ctx_id)\n{\n   struct vrend_sub_context *sub;\n\n   if (ctx->sub && ctx->sub->sub_ctx_id == sub_ctx_id)\n      return;\n\n   LIST_FOR_EACH_ENTRY(sub, &ctx->sub_ctxs, head) {\n      if (sub->sub_ctx_id == sub_ctx_id) {\n         ctx->sub = sub;\n         vrend_clicbs->make_current(0, sub->gl_context);\n         break;\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187409, "func": " status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n                                              uint32_t cmdSize,\n                                              void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n if (mStatus != NO_ERROR) {\n return mStatus;\n }\n if (cmdCode == EFFECT_CMD_GET_PARAM &&\n (*replySize < sizeof(effect_param_t) ||\n ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {\n\n         android_errorWriteLog(0x534e4554, \"29251553\");\n         return -EINVAL;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187429, "func": " static int read_request(int fd, debugger_request_t* out_request) {\n   ucred cr;\n   socklen_t len = sizeof(cr);\n int status = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cr, &len);\n if (status != 0) {\n    ALOGE(\"cannot get credentials\");\n return -1;\n }\n\n  ALOGV(\"reading tid\");\n  fcntl(fd, F_SETFL, O_NONBLOCK);\n\n  pollfd pollfds[1];\n  pollfds[0].fd = fd;\n  pollfds[0].events = POLLIN;\n  pollfds[0].revents = 0;\n  status = TEMP_FAILURE_RETRY(poll(pollfds, 1, 3000));\n if (status != 1) {\n    ALOGE(\"timed out reading tid (from pid=%d uid=%d)\\n\", cr.pid, cr.uid);\n return -1;\n }\n\n debugger_msg_t msg;\n  memset(&msg, 0, sizeof(msg));\n  status = TEMP_FAILURE_RETRY(read(fd, &msg, sizeof(msg)));\n if (status < 0) {\n    ALOGE(\"read failure? %s (pid=%d uid=%d)\\n\", strerror(errno), cr.pid, cr.uid);\n return -1;\n }\n if (status != sizeof(debugger_msg_t)) {\n    ALOGE(\"invalid crash request of size %d (from pid=%d uid=%d)\\n\", status, cr.pid, cr.uid);\n return -1;\n }\n\n  out_request->action = static_cast<debugger_action_t>(msg.action);\n  out_request->tid = msg.tid;\n  out_request->pid = cr.pid;\n  out_request->uid = cr.uid;\n  out_request->gid = cr.gid;\n  out_request->abort_msg_address = msg.abort_msg_address;\n  out_request->original_si_code = msg.original_si_code;\n\n \n   if (msg.action == DEBUGGER_ACTION_CRASH) {\n    char buf[64];\n    struct stat s;\n    snprintf(buf, sizeof buf, \"/proc/%d/task/%d\", out_request->pid, out_request->tid);\n    if (stat(buf, &s)) {\n      ALOGE(\"tid %d does not exist in pid %d. ignoring debug request\\n\",\n          out_request->tid, out_request->pid);\n       return -1;\n     }\n  } else if (cr.uid == 0\n            || (cr.uid == AID_SYSTEM && msg.action == DEBUGGER_ACTION_DUMP_BACKTRACE)) {\n     status = get_process_info(out_request->tid, &out_request->pid,\n &out_request->uid, &out_request->gid);\n if (status < 0) {\n      ALOGE(\"tid %d does not exist. ignoring explicit dump request\\n\", out_request->tid);\n return -1;\n }\n\n if (!selinux_action_allowed(fd, out_request))\n return -1;\n } else {\n return -1;\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": "46,47,48,49,50,51,54,55"}
{"idx": 187692, "func": "modifier_init(png_modifier *pm)\n{\n   memset(pm, 0, sizeof *pm);\n   store_init(&pm->this);\n   pm->modifications = NULL;\n   pm->state = modifier_start;\n   pm->sbitlow = 1U;\n   pm->ngammas = 0;\n   pm->ngamma_tests = 0;\n   pm->gammas = 0;\n   pm->current_gamma = 0;\n   pm->encodings = 0;\n   pm->nencodings = 0;\n   pm->current_encoding = 0;\n   pm->encoding_counter = 0;\n   pm->encoding_ignored = 0;\n   pm->repeat = 0;\n   pm->test_uses_encoding = 0;\n   pm->maxout8 = pm->maxpc8 = pm->maxabs8 = pm->maxcalc8 = 0;\n   pm->maxout16 = pm->maxpc16 = pm->maxabs16 = pm->maxcalc16 = 0;\n   pm->maxcalcG = 0;\n   pm->limit = 4E-3;\n   pm->log8 = pm->log16 = 0; \n   pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = 0;\n   pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0;\n   pm->error_indexed = 0;\n   pm->use_update_info = 0;\n   pm->interlace_type = PNG_INTERLACE_NONE;\n\n    pm->test_standard = 0;\n    pm->test_size = 0;\n    pm->test_transform = 0;\n    pm->use_input_precision = 0;\n    pm->use_input_precision_sbit = 0;\n    pm->use_input_precision_16to8 = 0;\n   pm->calculations_use_input_precision = 0;\n   pm->assume_16_bit_calculations = 0;\n   pm->test_gamma_threshold = 0;\n   pm->test_gamma_transform = 0;\n   pm->test_gamma_sbit = 0;\n   pm->test_gamma_scale16 = 0;\n\n    pm->test_gamma_background = 0;\n    pm->test_gamma_alpha_mode = 0;\n    pm->test_gamma_expand16 = 0;\n    pm->test_exhaustive = 0;\n    pm->log = 0;\n \n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8431, "func": "pvscsi_on_command_data(PVSCSIState *s, uint32_t value)\n{\n    size_t bytes_arrived = s->curr_cmd_data_cntr * sizeof(uint32_t);\n\n    assert(bytes_arrived < sizeof(s->curr_cmd_data));\n    s->curr_cmd_data[s->curr_cmd_data_cntr++] = value;\n\n    pvscsi_do_command_processing(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9034, "func": "static void vmxnet3_put_int_state(QEMUFile *f, void *pv, size_t size)\n{\n    Vmxnet3IntState *r = pv;\n\n    qemu_put_byte(f, r->is_masked);\n    qemu_put_byte(f, r->is_pending);\n    qemu_put_byte(f, r->is_asserted);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187326, "func": "xsltInitCtxtKey(xsltTransformContextPtr ctxt, xsltDocumentPtr idoc,\n\t        xsltKeyDefPtr keyDef)\n{\n    int i, len, k;\n    xmlNodeSetPtr matchList = NULL, keylist;\n    xmlXPathObjectPtr matchRes = NULL, useRes = NULL;\n    xmlChar *str = NULL;\n    xsltKeyTablePtr table;\n    xmlNodePtr oldInst, cur;\n    xmlNodePtr oldContextNode;\n    xsltDocumentPtr oldDocInfo;\n    int\toldXPPos, oldXPSize;\n    xmlDocPtr oldXPDoc;\n    int oldXPNsNr;\n    xmlNsPtr *oldXPNamespaces;\n    xmlXPathContextPtr xpctxt;\n\n#ifdef KEY_INIT_DEBUG\nfprintf(stderr, \"xsltInitCtxtKey %s : %d\\n\", keyDef->name, ctxt->keyInitLevel);\n#endif\n\n    if ((keyDef->comp == NULL) || (keyDef->usecomp == NULL))\n\treturn(-1);\n\n    if (ctxt->keyInitLevel > ctxt->nbKeys) {\n#ifdef WITH_XSLT_DEBUG_KEYS\n\tXSLT_TRACE(ctxt,XSLT_TRACE_KEYS,\n\t           xsltGenericDebug(xsltGenericDebugContext,\n\t\t       \"xsltInitCtxtKey: key definition of %s is recursive\\n\",\n\t\t       keyDef->name));\n#endif\n\txsltTransformError(ctxt, NULL, keyDef->inst,\n\t    \"Key definition for %s is recursive\\n\", keyDef->name);\n\tctxt->state = XSLT_STATE_STOPPED;\n        return(-1);\n    }\n    ctxt->keyInitLevel++;\n\n    xpctxt = ctxt->xpathCtxt;\n    idoc->nbKeysComputed++;\n    oldInst = ctxt->inst;\n    oldDocInfo = ctxt->document;\n    oldContextNode = ctxt->node;\n\n    oldXPDoc = xpctxt->doc;\n    oldXPPos = xpctxt->proximityPosition;\n    oldXPSize = xpctxt->contextSize;\n    oldXPNsNr = xpctxt->nsNr;\n    oldXPNamespaces = xpctxt->namespaces;\n\n    ctxt->document = idoc;\n    ctxt->node = (xmlNodePtr) idoc->doc;\n    ctxt->inst = keyDef->inst;\n\n    xpctxt->doc = idoc->doc;\n    xpctxt->node = (xmlNodePtr) idoc->doc;\n    xpctxt->namespaces = keyDef->nsList;\n    xpctxt->nsNr = keyDef->nsNr;\n\n    matchRes = xmlXPathCompiledEval(keyDef->comp, xpctxt);\n    if (matchRes == NULL) {\n\n#ifdef WITH_XSLT_DEBUG_KEYS\n\tXSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n\t     \"xsltInitCtxtKey: %s evaluation failed\\n\", keyDef->match));\n#endif\n\txsltTransformError(ctxt, NULL, keyDef->inst,\n\t    \"Failed to evaluate the 'match' expression.\\n\");\n\tctxt->state = XSLT_STATE_STOPPED;\n\tgoto error;\n    } else {\n\tif (matchRes->type == XPATH_NODESET) {\n\t    matchList = matchRes->nodesetval;\n\n#ifdef WITH_XSLT_DEBUG_KEYS\n\t    if (matchList != NULL)\n\t\tXSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltInitCtxtKey: %s evaluates to %d nodes\\n\",\n\t\t\t\t keyDef->match, matchList->nodeNr));\n#endif\n\t} else {\n#ifdef WITH_XSLT_DEBUG_KEYS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n\t\t \"xsltInitCtxtKey: %s is not a node set\\n\", keyDef->match));\n#endif\n\t    xsltTransformError(ctxt, NULL, keyDef->inst,\n\t\t\"The 'match' expression did not evaluate to a node set.\\n\");\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t    goto error;\n\t}\n    }\n    if ((matchList == NULL) || (matchList->nodeNr <= 0))\n\tgoto exit;\n\n    table = (xsltKeyTablePtr) idoc->keys;\n    while (table != NULL) {\n        if (xmlStrEqual(table->name, keyDef->name) &&\n\t    (((keyDef->nameURI == NULL) && (table->nameURI == NULL)) ||\n\t     ((keyDef->nameURI != NULL) && (table->nameURI != NULL) &&\n\t      (xmlStrEqual(table->nameURI, keyDef->nameURI)))))\n\t    break;\n\ttable = table->next;\n    }\n    if (table == NULL) {\n        table = xsltNewKeyTable(keyDef->name, keyDef->nameURI);\n        if (table == NULL)\n\t    goto error;\n        table->next = idoc->keys;\n        idoc->keys = table;\n    }\n\n    xpctxt->contextSize = 1;\n    xpctxt->proximityPosition = 1;\n\n    for (i = 0; i < matchList->nodeNr; i++) {\n \tcur = matchList->nodeTab[i];\n \tif (! IS_XSLT_REAL_NODE(cur))\n \t    continue;\n \txpctxt->node = cur;\n\tif (useRes != NULL)\n\t    xmlXPathFreeObject(useRes);\n\tuseRes = xmlXPathCompiledEval(keyDef->usecomp, xpctxt);\n\tif (useRes == NULL) {\n\t    xsltTransformError(ctxt, NULL, keyDef->inst,\n\t\t\"Failed to evaluate the 'use' expression.\\n\");\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t    break;\n\t}\n\tif (useRes->type == XPATH_NODESET) {\n\t    if ((useRes->nodesetval != NULL) &&\n\t\t(useRes->nodesetval->nodeNr != 0))\n\t    {\n\t\tlen = useRes->nodesetval->nodeNr;\n\t\tstr = xmlXPathCastNodeToString(useRes->nodesetval->nodeTab[0]);\n\t    } else {\n\t\tcontinue;\n\t    }\n\t} else {\n\t    len = 1;\n\t    if (useRes->type == XPATH_STRING) {\n\t\tstr = useRes->stringval;\n\t\tuseRes->stringval = NULL;\n\t    } else {\n\t\tstr = xmlXPathCastToString(useRes);\n\t    }\n\t}\n\tk = 0;\n\twhile (1) {\n\t    if (str == NULL)\n\t\tgoto next_string;\n\n#ifdef WITH_XSLT_DEBUG_KEYS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"xsl:key : node associated to ('%s', '%s')\\n\", keyDef->name, str));\n#endif\n\n\t    keylist = xmlHashLookup(table->keys, str);\n\t    if (keylist == NULL) {\n\t\tkeylist = xmlXPathNodeSetCreate(cur);\n\t\tif (keylist == NULL)\n\t\t    goto error;\n\t\txmlHashAddEntry(table->keys, str, keylist);\n\t    } else {\n\t\txmlXPathNodeSetAdd(keylist, cur);\n\t    }\n\t    switch (cur->type) {\n\t\tcase XML_ELEMENT_NODE:\n\t\tcase XML_TEXT_NODE:\n\t\tcase XML_CDATA_SECTION_NODE:\n\t\tcase XML_PI_NODE:\n\t\tcase XML_COMMENT_NODE:\n\t\t    cur->psvi = keyDef;\n\t\t    break;\n\t\tcase XML_ATTRIBUTE_NODE:\n\t\t    ((xmlAttrPtr) cur)->psvi = keyDef;\n\t\t    break;\n\t\tcase XML_DOCUMENT_NODE:\n\t\tcase XML_HTML_DOCUMENT_NODE:\n\t\t    ((xmlDocPtr) cur)->psvi = keyDef;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t    xmlFree(str);\n\t    str = NULL;\n\nnext_string:\n\t    k++;\n\t    if (k >= len)\n\t\tbreak;\n\t    str = xmlXPathCastNodeToString(useRes->nodesetval->nodeTab[k]);\n\t}\n    }\n\nexit:\nerror:\n    ctxt->keyInitLevel--;\n    xpctxt->doc = oldXPDoc;\n    xpctxt->nsNr = oldXPNsNr;\n    xpctxt->namespaces = oldXPNamespaces;\n    xpctxt->proximityPosition = oldXPPos;\n    xpctxt->contextSize = oldXPSize;\n\n    ctxt->node = oldContextNode;\n    ctxt->document = oldDocInfo;\n    ctxt->inst = oldInst;\n\n    if (str)\n\txmlFree(str);\n    if (useRes != NULL)\n\txmlXPathFreeObject(useRes);\n    if (matchRes != NULL)\n\txmlXPathFreeObject(matchRes);\n    return(0);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188555, "func": "void reference_32x32_dct_2d(const int16_t input[kNumCoeffs],\n double output[kNumCoeffs]) {\n for (int i = 0; i < 32; ++i) {\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = input[j*32 + i];\n    reference_32x32_dct_1d(temp_in, temp_out, 1);\n     for (int j = 0; j < 32; ++j)\n       output[j * 32 + i] = temp_out[j];\n   }\n for (int i = 0; i < 32; ++i) {\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = output[j + i*32];\n    reference_32x32_dct_1d(temp_in, temp_out, 1);\n     for (int j = 0; j < 32; ++j)\n       output[j + i * 32] = temp_out[j] / 4;\n   }\n }\n", "target": 1, "flaw_line_index": "9,19"}
{"idx": 188616, "func": "unsigned int subpel_avg_variance_ref(const uint8_t *ref,\n                                     const uint8_t *src,\n                                     const uint8_t *second_pred,\n                                     int l2w, int l2h,\n                                     int xoff, int yoff,\n                                     unsigned int *sse_ptr) {\n  int se = 0;\n  unsigned int sse = 0;\n  const int w = 1 << l2w, h = 1 << l2h;\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n      const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n      const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n      const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n      const int r = a + (((b - a) * yoff + 8) >> 4);\n      int diff = ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];\n      se += diff;\n      sse += diff * diff;\n    }\n  }\n  *sse_ptr = sse;\n  return sse - (((int64_t) se * se) >> (l2w + l2h));\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27"}
{"idx": 187832, "func": "long Segment::DoParseNext(const Cluster*& pResult, long long& pos, long& len) {\n long long total, avail;\n\n long status = m_pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n\n const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n\n\n long long off_next = 0;\n long long cluster_size = -1;\n\n for (;;) {\n if ((total >= 0) && (pos >= total))\n return 1; \n\n if ((segment_stop >= 0) && (pos >= segment_stop))\n return 1; \n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long idpos = pos; \n const long long idoff = pos - m_start; \n\n const long long id = ReadUInt(m_pReader, idpos, len); \n\n if (id < 0) \n return static_cast<long>(id);\n\n if (id == 0) \n return -1; \n\n    pos += len; \n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n    pos += len; \n\n\n if (size == 0) \n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if ((segment_stop >= 0) && (size != unknown_size) &&\n ((pos + size) > segment_stop)) {\n return E_FILE_FORMAT_INVALID;\n }\n\n if (id == 0x0C53BB6B) { \n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID;\n\n const long long element_stop = pos + size;\n\n if ((segment_stop >= 0) && (element_stop > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n const long long element_start = idpos;\n\n       const long long element_size = element_stop - element_start;\n \n       if (m_pCues == NULL) {\n        m_pCues = new Cues(this, pos, size, element_start, element_size);\n        assert(m_pCues);  \n       }\n \n       pos += size;  \n      assert((segment_stop < 0) || (pos <= segment_stop));\n \n       continue;\n     }\n\n if (id != 0x0F43B675) { \n if (size == unknown_size)\n\n         return E_FILE_FORMAT_INVALID;\n \n       pos += size;  \n      assert((segment_stop < 0) || (pos <= segment_stop));\n \n       continue;\n     }\n \n#if 0  \n        len = static_cast<long>(size);\n        if (element_stop > avail)\n            return E_BUFFER_NOT_FULL;\n#endif\n     off_next = idoff;\n \n     if (size != unknown_size)\n      cluster_size = size;\n\n break;\n }\n\n  assert(off_next > 0); \n\n\n Cluster** const ii = m_clusters + m_clusterCount;\n Cluster** i = ii;\n\n Cluster** const jj = ii + m_clusterPreloadCount;\n Cluster** j = jj;\n\n while (i < j) {\n\n Cluster** const k = i + (j - i) / 2;\n    assert(k < jj);\n\n const Cluster* const pNext = *k;\n    assert(pNext);\n    assert(pNext->m_index < 0);\n\n    pos = pNext->GetPosition();\n    assert(pos >= 0);\n\n if (pos < off_next)\n      i = k + 1;\n else if (pos > off_next)\n      j = k;\n else {\n      pResult = pNext;\n return 0; \n }\n }\n\n  assert(i == j);\n\n long long pos_;\n long len_;\n\n  status = Cluster::HasBlockEntries(this, off_next, pos_, len_);\n\n if (status < 0) { \n    pos = pos_;\n    len = len_;\n\n return status;\n }\n\n if (status > 0) { \n\n     Cluster* const pNext = Cluster::Create(this,\n                                            -1,  \n                                            off_next);\n    assert(pNext);\n \n     const ptrdiff_t idx_next = i - m_clusters;  \n \n    PreloadCluster(pNext, idx_next);\n     assert(m_clusters);\n     assert(idx_next < m_clusterSize);\n     assert(m_clusters[idx_next] == pNext);\n\n    pResult = pNext;\n return 0; \n }\n\n\n if (cluster_size < 0) { \n const long long payload_pos = pos; \n\n for (;;) { \n if ((total >= 0) && (pos >= total))\n break;\n\n if ((segment_stop >= 0) && (pos >= segment_stop))\n break; \n\n\n if ((pos + 1) > avail) {\n        len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long idpos = pos;\n const long long id = ReadUInt(m_pReader, idpos, len);\n\n if (id < 0) \n return static_cast<long>(id);\n\n\n if (id == 0x0F43B675) \n break;\n\n if (id == 0x0C53BB6B) \n break;\n\n      pos += len; \n\n\n if ((pos + 1) > avail) {\n        len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n      result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n      pos += len; \n\n\n if (size == 0) \n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID; \n\n if ((segment_stop >= 0) && ((pos + size) > segment_stop)) \n\n         return E_FILE_FORMAT_INVALID;\n \n       pos += size;  \n      assert((segment_stop < 0) || (pos <= segment_stop));\n     }  \n \n     cluster_size = pos - payload_pos;\n    assert(cluster_size >= 0); \n\n    pos = payload_pos; \n\n   }\n \n   pos += cluster_size;  \n  assert((segment_stop < 0) || (pos <= segment_stop));\n \n   return 2;  \n }\n", "target": 1, "flaw_line_index": "113,114,118,129,134,135,136,137,138,207,208,212"}
{"idx": 187894, "func": "void* H264SwDecMalloc(u32 size)\n {\n    return malloc(size);\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 188102, "func": "void mca_ccb_hdl_req(tMCA_CCB* p_ccb, tMCA_CCB_EVT* p_data) {\n  BT_HDR* p_pkt = &p_data->hdr;\n uint8_t *p, *p_start;\n  tMCA_DCB* p_dcb;\n  tMCA_CTRL evt_data;\n  tMCA_CCB_MSG* p_rx_msg = NULL;\n uint8_t reject_code = MCA_RSP_NO_RESOURCE;\n bool send_rsp = false;\n bool check_req = false;\n uint8_t reject_opcode;\n\n  MCA_TRACE_DEBUG(\"mca_ccb_hdl_req status:%d\", p_ccb->status);\n\n   p_rx_msg = (tMCA_CCB_MSG*)p_pkt;\n   p = (uint8_t*)(p_pkt + 1) + p_pkt->offset;\n   evt_data.hdr.op_code = *p++;\n  BE_STREAM_TO_UINT16(evt_data.hdr.mdl_id, p);\n   reject_opcode = evt_data.hdr.op_code + 1;\n \n   MCA_TRACE_DEBUG(\"received mdl id: %d \", evt_data.hdr.mdl_id);\n   if (p_ccb->status == MCA_CCB_STAT_PENDING) {\n     MCA_TRACE_DEBUG(\"received req inpending state\");\n if ((p_ccb->status == MCA_CCB_STAT_PENDING) &&\n (evt_data.hdr.op_code == MCA_OP_MDL_ABORT_REQ)) {\n      reject_code = MCA_RSP_SUCCESS;\n      send_rsp = true;\n      p_ccb->status = MCA_CCB_STAT_NORM;\n if (p_ccb->p_tx_req &&\n ((p_dcb = mca_dcb_by_hdl(p_ccb->p_tx_req->dcb_idx)) != NULL)) {\n        mca_dcb_dealloc(p_dcb, NULL);\n        osi_free_and_reset((void**)&p_ccb->p_tx_req);\n }\n } else\n      reject_code = MCA_RSP_BAD_OP;\n } else if (p_ccb->p_rx_msg) {\n    MCA_TRACE_DEBUG(\"still handling prev req\");\n\n } else if (p_ccb->p_tx_req) {\n    MCA_TRACE_DEBUG(\"still waiting for a response ctrl_vpsm:0x%x\",\n                    p_ccb->ctrl_vpsm);\n if (p_ccb->ctrl_vpsm == 0) {\n      MCA_TRACE_DEBUG(\"local is ACP. accept the cmd from INT\");\n      check_req = true;\n      reject_code = MCA_RSP_SUCCESS;\n if ((p_ccb->p_tx_req->op_code == MCA_OP_MDL_CREATE_REQ) &&\n ((p_dcb = mca_dcb_by_hdl(p_ccb->p_tx_req->dcb_idx)) != NULL)) {\n        mca_dcb_dealloc(p_dcb, NULL);\n }\n      osi_free_and_reset((void**)&p_ccb->p_tx_req);\n      mca_stop_timer(p_ccb);\n } else {\n      osi_free(p_pkt);\n return;\n }\n } else if (p_pkt->layer_specific != MCA_RSP_SUCCESS) {\n    reject_code = (uint8_t)p_pkt->layer_specific;\n if (((evt_data.hdr.op_code >= MCA_NUM_STANDARD_OPCODE) &&\n (evt_data.hdr.op_code < MCA_FIRST_SYNC_OP)) ||\n (evt_data.hdr.op_code > MCA_LAST_SYNC_OP)) {\n      reject_opcode = MCA_OP_ERROR_RSP;\n      evt_data.hdr.mdl_id = 0;\n }\n } else {\n    check_req = true;\n    reject_code = MCA_RSP_SUCCESS;\n }\n\n if (check_req) {\n if (reject_code == MCA_RSP_SUCCESS) {\n      reject_code = MCA_RSP_BAD_MDL;\n if (MCA_IS_VALID_MDL_ID(evt_data.hdr.mdl_id) ||\n ((evt_data.hdr.mdl_id == MCA_ALL_MDL_ID) &&\n (evt_data.hdr.op_code == MCA_OP_MDL_DELETE_REQ))) {\n        reject_code = MCA_RSP_SUCCESS;\n switch (evt_data.hdr.op_code) {\n case MCA_OP_MDL_CREATE_REQ:\n            evt_data.create_ind.dep_id = *p++;\n            evt_data.create_ind.cfg = *p++;\n            p_rx_msg->mdep_id = evt_data.create_ind.dep_id;\n if (!mca_is_valid_dep_id(p_ccb->p_rcb, p_rx_msg->mdep_id)) {\n              MCA_TRACE_ERROR(\"%s: Invalid local MDEP ID %d\", __func__,\n                              p_rx_msg->mdep_id);\n              reject_code = MCA_RSP_BAD_MDEP;\n } else if (mca_ccb_uses_mdl_id(p_ccb, evt_data.hdr.mdl_id)) {\n              MCA_TRACE_DEBUG(\"the mdl_id is currently used in the CL(create)\");\n              mca_dcb_close_by_mdl_id(p_ccb, evt_data.hdr.mdl_id);\n } else {\n if (mca_dep_free_mdl(p_ccb, evt_data.create_ind.dep_id) == 0) {\n                MCA_TRACE_ERROR(\"%s: MAX_MDL is used by MDEP %d\", __func__,\n                                evt_data.create_ind.dep_id);\n                reject_code = MCA_RSP_MDEP_BUSY;\n }\n }\n break;\n\n case MCA_OP_MDL_RECONNECT_REQ:\n if (mca_ccb_uses_mdl_id(p_ccb, evt_data.hdr.mdl_id)) {\n              MCA_TRACE_ERROR(\"%s: MDL_ID %d busy, in CL(reconn)\", __func__,\n                              evt_data.hdr.mdl_id);\n              reject_code = MCA_RSP_MDL_BUSY;\n }\n break;\n\n case MCA_OP_MDL_ABORT_REQ:\n            reject_code = MCA_RSP_BAD_OP;\n break;\n\n case MCA_OP_MDL_DELETE_REQ:\n            mca_dcb_close_by_mdl_id(p_ccb, evt_data.hdr.mdl_id);\n            send_rsp = true;\n break;\n }\n }\n }\n }\n\n if (((reject_code != MCA_RSP_SUCCESS) &&\n (evt_data.hdr.op_code != MCA_OP_SYNC_INFO_IND)) ||\n      send_rsp) {\n    BT_HDR* p_buf = (BT_HDR*)osi_malloc(MCA_CTRL_MTU + sizeof(BT_HDR));\n    p_buf->offset = L2CAP_MIN_OFFSET;\n    p = p_start = (uint8_t*)(p_buf + 1) + L2CAP_MIN_OFFSET;\n *p++ = reject_opcode;\n *p++ = reject_code;\n bool valid_response = true;\n switch (reject_opcode) {\n case MCA_OP_ERROR_RSP:\n case MCA_OP_MDL_CREATE_RSP:\n case MCA_OP_MDL_RECONNECT_RSP:\n case MCA_OP_MDL_ABORT_RSP:\n case MCA_OP_MDL_DELETE_RSP:\n        UINT16_TO_BE_STREAM(p, evt_data.hdr.mdl_id);\n break;\n case MCA_OP_SYNC_CAP_RSP:\n        memset(p, 0, 7);\n        p += 7;\n break;\n case MCA_OP_SYNC_SET_RSP:\n        memset(p, 0, 14);\n        p += 14;\n break;\n default:\n        MCA_TRACE_ERROR(\"%s: reject_opcode 0x%02x not recognized\", __func__,\n                        reject_opcode);\n        valid_response = false;\n break;\n }\n if (valid_response) {\n      p_buf->len = p - p_start;\n      MCA_TRACE_ERROR(\"%s: reject_opcode=0x%02x, reject_code=0x%02x, length=%d\",\n                      __func__, reject_opcode, reject_code, p_buf->len);\n      L2CA_DataWrite(p_ccb->lcid, p_buf);\n } else {\n      osi_free(p_buf);\n }\n }\n\n if (reject_code == MCA_RSP_SUCCESS) {\n    p_rx_msg->op_code = evt_data.hdr.op_code;\n    p_rx_msg->mdl_id = evt_data.hdr.mdl_id;\n    p_ccb->p_rx_msg = p_rx_msg;\n if (send_rsp) {\n      osi_free(p_pkt);\n      p_ccb->p_rx_msg = NULL;\n }\n    mca_ccb_report_event(p_ccb, evt_data.hdr.op_code, &evt_data);\n } else\n    osi_free(p_pkt);\n}\n", "target": 1, "flaw_line_index": "17"}
{"idx": 8899, "func": "static void vrend_renderer_detach_res_ctx_p(struct vrend_context *ctx, int res_handle)\n{\n   struct vrend_resource *res;\n   res = vrend_object_lookup(ctx->res_hash, res_handle, 1);\n   if (!res)\n      return;\n\n   vrend_object_remove(ctx->res_hash, res_handle, 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188554, "func": "void reference_32x32_dct_1d(const double in[32], double out[32], int stride) {\n   const double kInvSqrt2 = 0.707106781186547524400844362104;\n   for (int k = 0; k < 32; k++) {\n     out[k] = 0.0;\n for (int n = 0; n < 32; n++)\n      out[k] += in[n] * cos(kPi * (2 * n + 1) * k / 64.0);\n if (k == 0)\n      out[k] = out[k] * kInvSqrt2;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188120, "func": " static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,\n Handle<JSObject> receiver,\n Handle<Object> value,\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     for (uint32_t k = start_from; k < length; ++k) {\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n }\n\n PropertyDetails details = GetDetailsImpl(*dictionary, entry);\n switch (details.kind()) {\n case kData: {\n Object* element_k = dictionary->ValueAt(entry);\n if (value->StrictEquals(element_k)) {\n return Just<int64_t>(k);\n }\n break;\n }\n case kAccessor: {\n LookupIterator it(isolate, receiver, k,\n LookupIterator::OWN_SKIP_INTERCEPTOR);\n          DCHECK(it.IsFound());\n          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n Handle<Object> element_k;\n\n          ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),\n Nothing<int64_t>());\n\n if (value->StrictEquals(*element_k)) return Just<int64_t>(k);\n\n if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {\n return IndexOfValueSlowPath(isolate, receiver, value, k + 1,\n                                        length);\n }\n\n if (*dictionary == receiver->elements()) continue;\n\n if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {\n return IndexOfValueSlowPath(isolate, receiver, value, k + 1,\n                                        length);\n }\n          dictionary = handle(\n SeededNumberDictionary::cast(receiver->elements()), isolate);\n break;\n }\n }\n }\n return Just<int64_t>(-1);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8518, "func": "static void hash_uint32(const struct ssh_hash *h, void *s, unsigned i)\n{\n    unsigned char intblk[4];\n    PUT_32BIT(intblk, i);\n    h->bytes(s, intblk, 4);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187855, "func": "bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,\n                      unsigned char*& buf, size_t& buflen) {\n  assert(pReader);\n  assert(pos >= 0);\n  long long total, available;\n  long status = pReader->Length(&total, &available);\n  assert(status >= 0);\n  assert((total < 0) || (available <= total));\n  if (status < 0)\n     return false;\n \n  long len;\n  const long long id = ReadUInt(pReader, pos, len);\n  assert(id >= 0);\n  assert(len > 0);\n  assert(len <= 8);\n  assert((pos + len) <= available);\n \n  if ((unsigned long)id != id_)\n     return false;\n \n   pos += len;  \n \n  const long long size_ = ReadUInt(pReader, pos, len);\n  assert(size_ >= 0);\n  assert(len > 0);\n  assert(len <= 8);\n  assert((pos + len) <= available);\n \n   pos += len;  \n  assert((pos + size_) <= available);\n \n  const long buflen_ = static_cast<long>(size_);\n \n  buf = new (std::nothrow) unsigned char[buflen_];\n  assert(buf);  \n \n   status = pReader->Read(pos, buflen_, buf);\n  assert(status == 0);  \n \n   buflen = buflen_;\n \n  pos += size_;  \n   return true;\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,12,13,14,15,16,17,19,24,25,26,27,28,31,33,35,36,39,43"}
{"idx": 187585, "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n\n         ih264d_err_pic_dispbuf_mgr(ps_dec);\n         return 0;\n     }\n     if(prev_slice_err == 1)\n     {\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n {\n                ps_dec->ps_cur_slice->u1_bottom_field_flag = 0;\n                ps_dec->ps_cur_slice->u1_field_pic_flag = 0;\n                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n {\n            num_entries *= 2;\n }\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187841, "func": "long Track::GetFirst(const BlockEntry*& pBlockEntry) const {\n const Cluster* pCluster = m_pSegment->GetFirst();\n\n for (int i = 0;;) {\n if (pCluster == NULL) {\n      pBlockEntry = GetEOS();\n return 1;\n\n     }\n \n     if (pCluster->EOS()) {\n#if 0\n            if (m_pSegment->Unparsed() <= 0) {  \n                pBlockEntry = GetEOS();\n                return 1;\n            }\n#else\n       if (m_pSegment->DoneParsing()) {\n         pBlockEntry = GetEOS();\n         return 1;\n       }\n#endif\n \n       pBlockEntry = 0;\n       return E_BUFFER_NOT_FULL;\n }\n\n long status = pCluster->GetFirst(pBlockEntry);\n\n if (status < 0) \n return status;\n\n if (pBlockEntry == 0) { \n      pCluster = m_pSegment->GetNext(pCluster);\n continue;\n }\n\n for (;;) {\n const Block* const pBlock = pBlockEntry->GetBlock();\n      assert(pBlock);\n\n const long long tn = pBlock->GetTrackNumber();\n\n if ((tn == m_info.number) && VetEntry(pBlockEntry))\n return 0;\n\n const BlockEntry* pNextEntry;\n\n      status = pCluster->GetNext(pBlockEntry, pNextEntry);\n\n if (status < 0) \n return status;\n\n if (pNextEntry == 0)\n break;\n\n      pBlockEntry = pNextEntry;\n }\n\n ++i;\n\n if (i >= 100)\n break;\n\n    pCluster = m_pSegment->GetNext(pCluster);\n }\n\n\n  pBlockEntry = GetEOS(); \n return 1;\n}\n", "target": 1, "flaw_line_index": "12,13,14,15,16,17,22"}
{"idx": 187690, "func": "modifier_color_encoding_is_set(PNG_CONST png_modifier *pm)\n {\n    return pm->current_gamma != 0;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188225, "func": "OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9185, "func": "void virtio_config_modern_writel(VirtIODevice *vdev,\n                                 uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stl_le_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187740, "func": "white_point(PNG_CONST color_encoding *encoding)\n {\n    CIE_color white;\n \n   white.X = encoding->red.X + encoding->green.X + encoding->blue.X;\n   white.Y = encoding->red.Y + encoding->green.Y + encoding->blue.Y;\n   white.Z = encoding->red.Z + encoding->green.Z + encoding->blue.Z;\n\n \n    return white;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187947, "func": "IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(\n dec_state_t *ps_dec,\n    WORD16      *pi2_outAddr, \n const UWORD8 *pu1_scan, \n    UWORD8      *pu1_pos, \n    UWORD16     u2_intra_flag, \n    UWORD16     u2_chroma_flag, \n    UWORD16     u2_d_picture, \n    UWORD16     u2_intra_vlc_format, \n    UWORD16     u2_mpeg2, \n    WORD32      *pi4_num_coeffs \n )\n{\n\n    UWORD32 u4_sym_len;\n\n    UWORD32 u4_decoded_value;\n    UWORD32 u4_level_first_byte;\n    WORD32  u4_level;\n    UWORD32 u4_run, u4_numCoeffs;\n    UWORD32 u4_buf;\n    UWORD32 u4_buf_nxt;\n    UWORD32 u4_offset;\n    UWORD32 *pu4_buf_aligned;\n    UWORD32 u4_bits;\n stream_t *ps_stream = &ps_dec->s_bit_stream;\n    WORD32  u4_pos;\n    UWORD32 u4_nz_cols;\n    UWORD32 u4_nz_rows;\n\n *pi4_num_coeffs = 0;\n\n    ps_dec->u4_non_zero_cols = 0;\n    ps_dec->u4_non_zero_rows = 0;\n    u4_nz_cols = ps_dec->u4_non_zero_cols;\n    u4_nz_rows = ps_dec->u4_non_zero_rows;\n\n    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)\n if(u2_intra_flag)\n {\n        WORD32 dc_size;\n        WORD32 dc_diff;\n        WORD32 maxLen;\n        WORD32 idx;\n\n\n        maxLen = MPEG2_DCT_DC_SIZE_LEN;\n        idx = 0;\n if(u2_chroma_flag != 0)\n {\n            maxLen += 1;\n            idx++;\n }\n\n\n {\n            WORD16  end = 0;\n            UWORD32 maxLen_tmp = maxLen;\n            UWORD16 m_iBit;\n\n\n            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)\n do\n {\n                maxLen_tmp--;\n                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);\n\n                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];\n }while(end > 0);\n            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;\n\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)\n\n }\n\n\n\n if (dc_size != 0)\n {\n            UWORD32 u4_bits;\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)\n            dc_diff = u4_bits;\n\n if ((dc_diff & (1 << (dc_size - 1))) == 0) \n                dc_diff -= (1 << dc_size) - 1;\n }\n else\n {\n            dc_diff = 0;\n }\n\n\n        pi2_outAddr[*pi4_num_coeffs] = dc_diff;\n        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n\n if (0 != dc_diff)\n {\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n\n        u4_numCoeffs = 1;\n }\n else\n {\n        UWORD32 u4_bits;\n\n        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)\n\n if(u4_bits == 1)\n {\n\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)\n if(u4_bits == 1)\n {\n                pi2_outAddr[*pi4_num_coeffs] = -1;\n }\n else\n {\n                pi2_outAddr[*pi4_num_coeffs] = 1;\n }\n\n            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n            u4_numCoeffs = 1;\n\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n else\n {\n            u4_numCoeffs = 0;\n }\n }\n if (1 == u2_d_picture)\n {\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);\n }\n\n\n\n if (1 == u2_intra_vlc_format && u2_intra_flag)\n {\n\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                WORD16 DecodedValue;\n\n                u4_sym_len = 17;\n                IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)\n\n DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];\n                u4_sym_len = (DecodedValue & 0xf);\n                u4_level = DecodedValue >> 9;\n if(0 != u4_level)\n {\n                    u4_run = ((DecodedValue >> 4) & 0x1f);\n                    u4_numCoeffs       += u4_run;\n                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else\n {\n if (DecodedValue == END_OF_BLOCK_ONE)\n {\n                        u4_sym_len = 4;\n\n break;\n }\n else\n {\n                        lead_zeros = CLZ(u4_bits) - 20;\n if (0 != lead_zeros)\n {\n\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n if (1 == lead_zeros)\n {\n                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;\n }\n else\n {\n                                u4_sym_len         = 11 + lead_zeros;\n }\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                                u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else\n {\n\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                                u4_decoded_value     = u4_bits;\n                            u4_run              = (u4_decoded_value >> 8);\n                            u4_level_first_byte = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                    u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs += u4_run;\n\n                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];\n\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n\n                 u4_nz_cols |= 1 << (u4_pos & 0x7);\n                 u4_nz_rows |= 1 << (u4_pos >> 0x3);\n \n \n             }\n             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n            if (u4_numCoeffs > 64)\n            {\n                return IMPEG2D_MB_TEX_DECODE_ERR;\n            }\n         }\n         else\n         {\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                UWORD16 DecodedValue;\n\n                u4_sym_len = 17;\n                IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)\n\n\n DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];\n                u4_sym_len = BITS(DecodedValue, 3, 0);\n                u4_level = ((WORD16) DecodedValue) >> 9;\n\n if (0 != u4_level)\n {\n                    u4_run = BITS(DecodedValue, 8,4);\n\n                    u4_numCoeffs       += u4_run;\n\n                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else\n {\n if(DecodedValue == END_OF_BLOCK_ZERO)\n {\n                        u4_sym_len = 2;\n\n break;\n }\n else\n {\n                        lead_zeros = CLZ(u4_bits) - 20;\n if (0 != lead_zeros)\n {\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n                            u4_sym_len         = 11 + lead_zeros;\n\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n if (1 == lead_zeros)\n                                u4_sym_len--;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                            u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else\n {\n\n                            u4_sym_len             = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                            u4_decoded_value        = u4_bits;\n                            u4_run                 = (u4_decoded_value >> 8);\n                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n \n                 u4_nz_cols |= 1 << (u4_pos & 0x7);\n                 u4_nz_rows |= 1 << (u4_pos >> 0x3);\n            }\n            if (u4_numCoeffs > 64)\n            {\n                return IMPEG2D_MB_TEX_DECODE_ERR;\n             }\n \n             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n\n }\n\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "flaw_line_index": "271,272,273,274,395,396,397,398"}
{"idx": 8762, "func": "static void add_client_options(struct dhcp_packet *packet)\n{\n\tint i, end, len;\n\n\tudhcp_add_simple_option(packet, DHCP_MAX_SIZE, htons(IP_UDP_DHCP_SIZE));\n\n\tend = udhcp_end_option(packet->options);\n\tlen = 0;\n\tfor (i = 1; i < DHCP_END; i++) {\n\t\tif (client_config.opt_mask[i >> 3] & (1 << (i & 7))) {\n\t\t\tpacket->options[end + OPT_DATA + len] = i;\n\t\t\tlen++;\n\t\t}\n\t}\n\tif (len) {\n\t\tpacket->options[end + OPT_CODE] = DHCP_PARAM_REQ;\n\t\tpacket->options[end + OPT_LEN] = len;\n\t\tpacket->options[end + OPT_DATA + len] = DHCP_END;\n\t}\n\n\tif (client_config.vendorclass)\n\t\tudhcp_add_binary_option(packet, client_config.vendorclass);\n\tif (client_config.hostname)\n\t\tudhcp_add_binary_option(packet, client_config.hostname);\n\tif (client_config.fqdn)\n\t\tudhcp_add_binary_option(packet, client_config.fqdn);\n\n\tif ((option_mask32 & OPT_B) && packet->ciaddr == 0)\n\t\tpacket->flags |= htons(BROADCAST_FLAG);\n\n\t{\n\t\tstruct option_set *curr = client_config.options;\n\t\twhile (curr) {\n\t\t\tudhcp_add_binary_option(packet, curr->data);\n\t\t\tcurr = curr->next;\n\t\t}\n\t}\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188567, "func": "   int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n     ExternalFrameBuffer *const ext_fb =\n         reinterpret_cast<ExternalFrameBuffer*>(fb->priv);\n    EXPECT_TRUE(ext_fb != NULL);\n     EXPECT_EQ(1, ext_fb->in_use);\n     ext_fb->in_use = 0;\n     return 0;\n }\n", "target": 1, "flaw_line_index": "2,5"}
{"idx": 9099, "func": "static int vrend_decode_create_sampler_view(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   uint32_t res_handle, format, val0, val1, swizzle_packed;\n\n   if (length != VIRGL_OBJ_SAMPLER_VIEW_SIZE)\n      return EINVAL;\n\n   res_handle = get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_VIEW_RES_HANDLE);\n   format = get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_VIEW_FORMAT);\n   val0 = get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_VIEW_BUFFER_FIRST_ELEMENT);\n   val1 = get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_VIEW_BUFFER_LAST_ELEMENT);\n   swizzle_packed = get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_VIEW_SWIZZLE);\n   return vrend_create_sampler_view(ctx->grctx, handle, res_handle, format, val0, val1,swizzle_packed);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8487, "func": "UINT CSoundFile::GetSongComments(LPSTR s, UINT len, UINT linesize)\n{\n\tLPCSTR p = m_lpszSongComments;\n\tif (!p) return 0;\n\tUINT i = 2, ln=0;\n\tif ((len) && (s)) s[0] = '\\x0D';\n\tif ((len > 1) && (s)) s[1] = '\\x0A';\n\twhile ((*p)\t&& (i+2 < len))\n\t{\n\t\tBYTE c = (BYTE)*p++;\n\t\tif ((c == 0x0D) || ((c == ' ') && (ln >= linesize)))\n\t\t\t{ if (s) { s[i++] = '\\x0D'; s[i++] = '\\x0A'; } else i+= 2; ln=0; }\n\t\telse\n\t\tif (c >= 0x20) { if (s) s[i++] = c; else i++; ln++; }\n\t}\n\tif (s) s[i] = 0;\n\treturn i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188224, "func": "OMX_ERRORTYPE SoftAVC::setConfig(\n        OMX_INDEXTYPE index, const OMX_PTR _params) {\n switch (index) {\n case OMX_IndexConfigVideoIntraVOPRefresh:\n {\n\n             OMX_CONFIG_INTRAREFRESHVOPTYPE *params =\n                 (OMX_CONFIG_INTRAREFRESHVOPTYPE *)_params;\n \n             if (params->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n            mKeyFrameRequested = params->IntraRefreshVOP;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexConfigVideoBitrate:\n {\n\n             OMX_VIDEO_CONFIG_BITRATETYPE *params =\n                 (OMX_VIDEO_CONFIG_BITRATETYPE *)_params;\n \n             if (params->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n if (mBitrate != params->nEncodeBitrate) {\n                mBitrate = params->nEncodeBitrate;\n                mBitrateUpdated = true;\n }\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::setConfig(index, _params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9019, "func": "static int vmxnet3_mcast_list_pre_load(void *opaque)\n{\n    VMXNET3State *s = opaque;\n\n    s->mcast_list = g_malloc(s->mcast_list_buff_size);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9155, "func": "static void vrend_use_program(struct vrend_context *ctx, GLuint program_id)\n{\n   if (ctx->sub->program_id != program_id) {\n      glUseProgram(program_id);\n      ctx->sub->program_id = program_id;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188024, "func": "status_t AMRSource::read(\n MediaBuffer **out, const ReadOptions *options) {\n *out = NULL;\n\n \n     int64_t seekTimeUs;\n     ReadOptions::SeekMode mode;\n    if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n         size_t size;\n         int64_t seekFrame = seekTimeUs / 20000ll;  \n         mCurrentTimeUs = seekFrame * 20000ll;\n\n size_t index = seekFrame < 0 ? 0 : seekFrame / 50;\n if (index >= mOffsetTableLength) {\n            index = mOffsetTableLength - 1;\n }\n\n        mOffset = mOffsetTable[index] + (mIsWide ? 9 : 6);\n\n for (size_t i = 0; i< seekFrame - index * 50; i++) {\n status_t err;\n if ((err = getFrameSizeByOffset(mDataSource, mOffset,\n                            mIsWide, &size)) != OK) {\n return err;\n }\n            mOffset += size;\n }\n }\n\n uint8_t header;\n ssize_t n = mDataSource->readAt(mOffset, &header, 1);\n\n if (n < 1) {\n return ERROR_END_OF_STREAM;\n }\n\n if (header & 0x83) {\n\n        ALOGE(\"padding bits must be 0, header is 0x%02x\", header);\n\n return ERROR_MALFORMED;\n }\n\n unsigned FT = (header >> 3) & 0x0f;\n\n size_t frameSize = getFrameSize(mIsWide, FT);\n if (frameSize == 0) {\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *buffer;\n status_t err = mGroup->acquire_buffer(&buffer);\n if (err != OK) {\n return err;\n }\n\n    n = mDataSource->readAt(mOffset, buffer->data(), frameSize);\n\n if (n != (ssize_t)frameSize) {\n        buffer->release();\n        buffer = NULL;\n\n if (n < 0) {\n return ERROR_IO;\n } else {\n            mOffset += n;\n return ERROR_END_OF_STREAM;\n }\n }\n\n    buffer->set_range(0, frameSize);\n    buffer->meta_data()->setInt64(kKeyTime, mCurrentTimeUs);\n    buffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n\n    mOffset += frameSize;\n    mCurrentTimeUs += 20000; \n\n *out = buffer;\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 188610, "func": "void SubpelVarianceTest<vp9_subp_avg_variance_fn_t>::RefTest() {\n  for (int x = 0; x < 16; ++x) {\n    for (int y = 0; y < 16; ++y) {\n      for (int j = 0; j < block_size_; j++) {\n        src_[j] = rnd.Rand8();\n        sec_[j] = rnd.Rand8();\n      }\n      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n        ref_[j] = rnd.Rand8();\n       }\n       unsigned int sse1, sse2;\n       unsigned int var1;\n      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,\n                                                   src_, width_, &sse1, sec_));\n       const unsigned int var2 = subpel_avg_variance_ref(ref_, src_, sec_,\n                                                         log2width_, log2height_,\n                                                        x, y, &sse2);\n       EXPECT_EQ(sse1, sse2) << \"at position \" << x << \", \" << y;\n       EXPECT_EQ(var1, var2) << \"at position \" << x << \", \" << y;\n     }\n   }\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,13,14,17"}
{"idx": 8579, "func": "static void ssh_pkt_getstring(struct Packet *pkt, char **p, int *length)\n{\n    int len;\n    *p = NULL;\n    *length = 0;\n    if (pkt->length - pkt->savedpos < 4)\n\treturn;\n    len = toint(GET_32BIT(pkt->body + pkt->savedpos));\n    if (len < 0)\n\treturn;\n    *length = len;\n    pkt->savedpos += 4;\n    if (pkt->length - pkt->savedpos < *length)\n\treturn;\n    *p = (char *)(pkt->body + pkt->savedpos);\n    pkt->savedpos += *length;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188338, "func": "Cluster::GetEntry(\n    const CuePoint& cp,\n    const CuePoint::TrackPosition& tp) const\n{\n    assert(m_pSegment);\n \n #if 0\n \n LoadBlockEntries();\n\n if (m_entries == NULL)\n return NULL;\n\n const long long count = m_entries_count;\n\n if (count <= 0)\n return NULL;\n\n const long long tc = cp.GetTimeCode();\n\n if ((tp.m_block > 0) && (tp.m_block <= count))\n {\n const size_t block = static_cast<size_t>(tp.m_block);\n const size_t index = block - 1;\n\n const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n\n if ((pBlock->GetTrackNumber() == tp.m_track) &&\n (pBlock->GetTimeCode(this) == tc))\n {\n return pEntry;\n }\n }\n\n const BlockEntry* const* i = m_entries;\n const BlockEntry* const* const j = i + count;\n\n while (i != j)\n {\n#ifdef _DEBUG\n const ptrdiff_t idx = i - m_entries;\n        idx;\n#endif\n\n const BlockEntry* const pEntry = *i++;\n        assert(pEntry);\n        assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n\n if (pBlock->GetTrackNumber() != tp.m_track)\n continue;\n\n const long long tc_ = pBlock->GetTimeCode(this);\n        assert(tc_ >= 0);\n\n if (tc_ < tc)\n continue;\n\n if (tc_ > tc)\n return NULL;\n\n const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n\n const long tn = static_cast<long>(tp.m_track);\n const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n\n if (pTrack == NULL)\n return NULL;\n\n const long long type = pTrack->GetType();\n\n if (type == 2) \n return pEntry;\n\n if (type != 1) \n return NULL;\n\n if (!pBlock->IsKey())\n return NULL;\n\n return pEntry;\n }\n\n return NULL;\n\n \n #else\n \n    const long long tc = cp.GetTimeCode();\n \n    if (tp.m_block > 0)\n    {\n        const long block = static_cast<long>(tp.m_block);\n        const long index = block - 1;\n \n        while (index >= m_entries_count)\n        {\n            long long pos;\n            long len;\n \n            const long status = Parse(pos, len);\n \n            if (status < 0)  \n                return NULL;\n \n            if (status > 0)  \n                return NULL;\n        }\n        const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if ((pBlock->GetTrackNumber() == tp.m_track) &&\n            (pBlock->GetTimeCode(this) == tc))\n        {\n            return pEntry;\n        }\n     }\n \n    long index = 0;\n \n    for (;;)\n    {\n        if (index >= m_entries_count)\n        {\n            long long pos;\n            long len;\n \n            const long status = Parse(pos, len);\n            if (status < 0)  \n                return NULL;\n            if (status > 0)  \n                return NULL;\n            assert(m_entries);\n            assert(index < m_entries_count);\n        }\n        const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if (pBlock->GetTrackNumber() != tp.m_track)\n        {\n            ++index;\n            continue;\n        }\n        const long long tc_ = pBlock->GetTimeCode(this);\n        if (tc_ < tc)\n        {\n            ++index;\n            continue;\n        }\n        if (tc_ > tc)\n            return NULL;\n        const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n        const long tn = static_cast<long>(tp.m_track);\n        const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n        if (pTrack == NULL)\n            return NULL;\n        const long long type = pTrack->GetType();\n        if (type == 2)  \n            return pEntry;\n        if (type != 1)  \n            return NULL;\n        if (!pBlock->IsKey())\n            return NULL;\n        return pEntry;\n     }\n \n #endif\n }\n", "target": 1, "flaw_line_index": "2,3,4,5,97,99,100,101,102,104,105,106,107,109,111,112,114,115,116,117,118,119,120,121,122,123,124,125,126,129,131,132,133,134,135,136,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177"}
{"idx": 8637, "func": "size_t mptsas_config_io_unit_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDevice *pci = PCI_DEVICE(s);\n    uint64_t unique_value = 0x53504D554D4551LL;  \n\n    unique_value |= (uint64_t)pci->devfn << 56;\n    return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x00,\n                              \"q\", unique_value);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8611, "func": "static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,\n                uint32_t c, int x, int y, int w, int h)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    int bypl = surface_stride(surface);\n    int width = surface_bytes_per_pixel(surface) * w;\n    int line = h;\n    int column;\n    uint8_t *fst;\n    uint8_t *dst;\n    uint8_t *src;\n    uint8_t col[4];\n\n    if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {\n        return -1;\n    }\n\n    col[0] = c;\n    col[1] = c >> 8;\n    col[2] = c >> 16;\n    col[3] = c >> 24;\n\n    fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;\n\n    if (line--) {\n        dst = fst;\n        src = col;\n        for (column = width; column > 0; column--) {\n            *(dst++) = *(src++);\n            if (src - col == surface_bytes_per_pixel(surface)) {\n                src = col;\n            }\n        }\n        dst = fst;\n        for (; line > 0; line--) {\n            dst += bypl;\n            memcpy(dst, fst, width);\n        }\n    }\n\n    vmsvga_update_rect_delayed(s, x, y, w, h);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8353, "func": "static int mptsas_build_sgl(MPTSASState *s, MPTSASRequest *req, hwaddr addr)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    hwaddr next_chain_addr;\n    uint32_t left;\n    hwaddr sgaddr;\n    uint32_t chain_offset;\n\n    chain_offset = req->scsi_io.ChainOffset;\n    next_chain_addr = addr + chain_offset * sizeof(uint32_t);\n    sgaddr = addr + sizeof(MPIMsgSCSIIORequest);\n    pci_dma_sglist_init(&req->qsg, pci, 4);\n    left = req->scsi_io.DataLength;\n\n    for(;;) {\n        dma_addr_t addr, len;\n        uint32_t flags_and_length;\n\n        flags_and_length = ldl_le_pci_dma(pci, sgaddr);\n        len = flags_and_length & MPI_SGE_LENGTH_MASK;\n        if ((flags_and_length & MPI_SGE_FLAGS_ELEMENT_TYPE_MASK)\n            != MPI_SGE_FLAGS_SIMPLE_ELEMENT ||\n            (!len &&\n             !(flags_and_length & MPI_SGE_FLAGS_END_OF_LIST) &&\n             !(flags_and_length & MPI_SGE_FLAGS_END_OF_BUFFER))) {\n            return MPI_IOCSTATUS_INVALID_SGL;\n        }\n\n        len = MIN(len, left);\n        if (!len) {\n            break;\n        }\n\n        addr = mptsas_ld_sg_base(s, flags_and_length, &sgaddr);\n        qemu_sglist_add(&req->qsg, addr, len);\n        left -= len;\n\n        if (flags_and_length & MPI_SGE_FLAGS_END_OF_LIST) {\n            break;\n        }\n\n        if (flags_and_length & MPI_SGE_FLAGS_LAST_ELEMENT) {\n            if (!chain_offset) {\n                break;\n            }\n\n            flags_and_length = ldl_le_pci_dma(pci, next_chain_addr);\n            if ((flags_and_length & MPI_SGE_FLAGS_ELEMENT_TYPE_MASK)\n                != MPI_SGE_FLAGS_CHAIN_ELEMENT) {\n                return MPI_IOCSTATUS_INVALID_SGL;\n            }\n\n            sgaddr = mptsas_ld_sg_base(s, flags_and_length, &next_chain_addr);\n            chain_offset =\n                (flags_and_length & MPI_SGE_CHAIN_OFFSET_MASK) >> MPI_SGE_CHAIN_OFFSET_SHIFT;\n            next_chain_addr = sgaddr + chain_offset * sizeof(uint32_t);\n        }\n    }\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8522, "func": "static int s_write(Ssh ssh, void *data, int len)\n{\n    if (ssh->logctx)\n\tlog_packet(ssh->logctx, PKT_OUTGOING, -1, NULL, data, len,\n\t\t   0, NULL, NULL, 0, NULL);\n    if (!ssh->s)\n        return 0;\n    return sk_write(ssh->s, (char *)data, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8867, "func": "static void vrend_free_programs(struct vrend_sub_context *sub)\n{\n   struct vrend_linked_shader_program *ent, *tmp;\n\n   if (LIST_IS_EMPTY(&sub->programs))\n      return;\n\n   LIST_FOR_EACH_ENTRY_SAFE(ent, tmp, &sub->programs, head) {\n      vrend_destroy_program(ent);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8367, "func": "static uint64_t mptsas_mmio_read(void *opaque, hwaddr addr,\n                                  unsigned size)\n{\n    MPTSASState *s = opaque;\n    uint32_t ret = 0;\n\n    switch (addr & ~3) {\n    case MPI_DOORBELL_OFFSET:\n        ret = mptsas_doorbell_read(s);\n        break;\n\n    case MPI_DIAGNOSTIC_OFFSET:\n        ret = s->diagnostic;\n        break;\n\n    case MPI_HOST_INTERRUPT_STATUS_OFFSET:\n        ret = s->intr_status;\n        break;\n\n    case MPI_HOST_INTERRUPT_MASK_OFFSET:\n        ret = s->intr_mask;\n        break;\n\n    case MPI_REPLY_POST_FIFO_OFFSET:\n        ret = mptsas_reply_post_read(s);\n        break;\n\n    default:\n        trace_mptsas_mmio_unhandled_read(s, addr);\n        break;\n    }\n    trace_mptsas_mmio_read(s, addr, ret);\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8812, "func": "static int thread_sync(void *arg)\n{\n   virgl_gl_context gl_context = vrend_state.sync_context;\n   struct vrend_fence *fence, *stor;\n\n   pipe_mutex_lock(vrend_state.fence_mutex);\n   vrend_clicbs->make_current(0, gl_context);\n\n   while (!vrend_state.stop_sync_thread) {\n      if (LIST_IS_EMPTY(&vrend_state.fence_wait_list) &&\n          pipe_condvar_wait(vrend_state.fence_cond, vrend_state.fence_mutex) != 0) {\n         fprintf(stderr, \"error while waiting on condition\\n\");\n         break;\n      }\n\n      LIST_FOR_EACH_ENTRY_SAFE(fence, stor, &vrend_state.fence_wait_list, fences) {\n         if (vrend_state.stop_sync_thread)\n            break;\n         list_del(&fence->fences);\n         pipe_mutex_unlock(vrend_state.fence_mutex);\n         wait_sync(fence);\n         pipe_mutex_lock(vrend_state.fence_mutex);\n      }\n   }\n\n   vrend_clicbs->make_current(0, 0);\n   vrend_clicbs->destroy_gl_context(vrend_state.sync_context);\n   pipe_mutex_unlock(vrend_state.fence_mutex);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187918, "func": "static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kSegCountOffset = 6;\n const size_t kEndCountOffset = 14;\n const size_t kHeaderSize = 16;\n const size_t kSegmentSize = 8; \n if (kEndCountOffset > size) {\n return false;\n }\n size_t segCount = readU16(data, kSegCountOffset) >> 1;\n if (kHeaderSize + segCount * kSegmentSize > size) {\n return false;\n }\n for (size_t i = 0; i < segCount; i++) {\n uint32_t end = readU16(data, kEndCountOffset + 2 * i);\n\n         uint32_t start = readU16(data, kHeaderSize + 2 * (segCount + i));\n         if (end < start) {\n             return false;\n         }\n         uint32_t rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));\n if (rangeOffset == 0) {\n uint32_t delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));\n if (((end + delta) & 0xffff) > end - start) {\n                addRange(coverage, start, end + 1);\n } else {\n for (uint32_t j = start; j < end + 1; j++) {\n if (((j + delta) & 0xffff) != 0) {\n                        addRange(coverage, j, j + 1);\n }\n }\n }\n } else {\n for (uint32_t j = start; j < end + 1; j++) {\n uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +\n (i + j - start) * 2;\n if (actualRangeOffset + 2 > size) {\n continue;\n }\n uint32_t glyphId = readU16(data, actualRangeOffset);\n if (glyphId != 0) {\n                    addRange(coverage, j, j + 1);\n }\n }\n }\n }\n return true;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9210, "func": "static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)\n{\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->notify) {\n        k->notify(qbus->parent, vector);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8868, "func": "static void vrend_free_sync_thread(void)\n{\n   if (!vrend_state.sync_thread)\n      return;\n\n   pipe_mutex_lock(vrend_state.fence_mutex);\n   vrend_state.stop_sync_thread = true;\n   pipe_mutex_unlock(vrend_state.fence_mutex);\n\n   pipe_condvar_signal(vrend_state.fence_cond);\n   pipe_thread_wait(vrend_state.sync_thread);\n   vrend_state.sync_thread = 0;\n\n   pipe_condvar_destroy(vrend_state.fence_cond);\n   pipe_mutex_destroy(vrend_state.fence_mutex);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8815, "func": "static GLenum translate_blend_func(uint32_t pipe_blend)\n{\n   switch(pipe_blend){\n   case PIPE_BLEND_ADD: return GL_FUNC_ADD;\n   case PIPE_BLEND_SUBTRACT: return GL_FUNC_SUBTRACT;\n   case PIPE_BLEND_REVERSE_SUBTRACT: return GL_FUNC_REVERSE_SUBTRACT;\n   case PIPE_BLEND_MIN: return GL_MIN;\n   case PIPE_BLEND_MAX: return GL_MAX;\n   default:\n      assert(\"invalid blend token()\" == NULL);\n      return 0;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187348, "func": "xsltElement(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t    xmlNodePtr inst, xsltStylePreCompPtr castedComp) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemElementPtr comp = (xsltStyleItemElementPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    xmlChar *prop = NULL;\n    const xmlChar *name, *prefix = NULL, *nsName = NULL;\n    xmlNodePtr copy;\n    xmlNodePtr oldInsert;\n\n    if (ctxt->insert == NULL)\n\treturn;\n\n    if (!comp->has_name)\n        return;\n\n    oldInsert = ctxt->insert;\n\n    if (comp->name == NULL) {\n        prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t    (const xmlChar *) \"name\", XSLT_NAMESPACE);\n        if (prop == NULL) {\n            xsltTransformError(ctxt, NULL, inst,\n\t\t\"xsl:element: The attribute 'name' is missing.\\n\");\n            goto error;\n        }\n\tif (xmlValidateQName(prop, 0)) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\"xsl:element: The effective name '%s' is not a \"\n\t\t\"valid QName.\\n\", prop);\n\t}\n\tname = xsltSplitQName(ctxt->dict, prop, &prefix);\n\txmlFree(prop);\n    } else {\n#ifdef XSLT_REFACTORED\n\tprefix = comp->nsPrefix;\n\tname = comp->name;\n#else\n\tname = xsltSplitQName(ctxt->dict, comp->name, &prefix);\n#endif\n    }\n\n    if (ctxt->output->dict == ctxt->dict) {\n\tcopy = xmlNewDocNodeEatName(ctxt->output, NULL, (xmlChar *)name, NULL);\n    } else {\n\tcopy = xmlNewDocNode(ctxt->output, NULL, (xmlChar *)name, NULL);\n    }\n    if (copy == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"xsl:element : creation of %s failed\\n\", name);\n \treturn;\n     }\n     copy = xsltAddChild(ctxt->insert, copy);\n \n    if (comp->has_ns) {\n\tif (comp->ns != NULL) {\n\t    if (comp->ns[0] != 0)\n\t\tnsName = comp->ns;\n\t} else {\n\t    xmlChar *tmpNsName;\n\t    tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t(const xmlChar *) \"namespace\", XSLT_NAMESPACE);\n\t    if ((tmpNsName != NULL) && (tmpNsName[0] != 0))\n\t\tnsName = xmlDictLookup(ctxt->dict, BAD_CAST tmpNsName, -1);\n\t    xmlFree(tmpNsName);\n\t}\n\n        if (xmlStrEqual(nsName, BAD_CAST \"http:\n            xsltTransformError(ctxt, NULL, inst,\n                \"xsl:attribute: Namespace http:\n                \"forbidden.\\n\");\n            goto error;\n        }\n        if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {\n            prefix = BAD_CAST \"xml\";\n        } else if (xmlStrEqual(prefix, BAD_CAST \"xml\")) {\n            prefix = NULL;\n        }\n    } else {\n\txmlNsPtr ns;\n\tns = xmlSearchNs(inst->doc, inst, prefix);\n\tif (ns == NULL) {\n            if (prefix != NULL) {\n                xsltTransformError(ctxt, NULL, inst,\n                    \"xsl:element: The QName '%s:%s' has no \"\n                    \"namespace binding in scope in the stylesheet; \"\n                    \"this is an error, since the namespace was not \"\n                    \"specified by the instruction itself.\\n\", prefix, name);\n            }\n\t} else\n\t    nsName = ns->href;\n    }\n    if (nsName != NULL) {\n\tif (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n\t    xmlChar *pref = xmlStrdup(BAD_CAST \"ns_1\");\n\n\t    copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, copy);\n\n\t    xmlFree(pref);\n\t} else {\n\t    copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,\n\t\tcopy);\n\t}\n    } else if ((copy->parent != NULL) &&\n\t(copy->parent->type == XML_ELEMENT_NODE) &&\n\t(copy->parent->ns != NULL))\n    {\n\txsltGetSpecialNamespace(ctxt, inst, NULL, NULL, copy);\n    }\n\n    ctxt->insert = copy;\n\n    if (comp->has_use) {\n\tif (comp->use != NULL) {\n\t    xsltApplyAttributeSet(ctxt, node, inst, comp->use);\n\t} else {\n\t    xmlChar *attrSets = NULL;\n\t    attrSets = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t(const xmlChar *)\"use-attribute-sets\", NULL);\n\t    if (attrSets != NULL) {\n\t\txsltApplyAttributeSet(ctxt, node, inst, attrSets);\n\t\txmlFree(attrSets);\n\t    }\n\t}\n    }\n    if (inst->children != NULL)\n\txsltApplySequenceConstructor(ctxt, ctxt->node, inst->children,\n\t    NULL);\n\nerror:\n    ctxt->insert = oldInsert;\n    return;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188015, "func": "static ssize_t read_and_process_frames(struct audio_stream_in *stream, void* buffer, ssize_t frames_num)\n{\n struct stream_in *in = (struct stream_in *)stream;\n\n     ssize_t frames_wr = 0; \n     size_t bytes_per_sample = audio_bytes_per_sample(stream->common.get_format(&stream->common));\n     void *proc_buf_out = buffer;\n#ifdef PREPROCESSING_ENABLED\n    audio_buffer_t in_buf;\n    audio_buffer_t out_buf;\n    int i;\n    bool has_processing = in->num_preprocessors != 0;\n#endif\n\n     size_t src_channels = in->config.channels;\n     size_t dst_channels = audio_channel_count_from_in_mask(in->main_channels);\n     bool channel_remapping_needed = (dst_channels != src_channels);\n    size_t src_buffer_size = frames_num * src_channels * bytes_per_sample;\n \n #ifdef PREPROCESSING_ENABLED\n     if (has_processing) {\n\n         while (frames_wr < frames_num) {\n             if (in->proc_buf_frames < (size_t)frames_num) {\n                ssize_t frames_rd;\n                if (in->proc_buf_size < (size_t)frames_num) {\n                    in->proc_buf_size = (size_t)frames_num;\n                    in->proc_buf_in = realloc(in->proc_buf_in, src_buffer_size);\n                    ALOG_ASSERT((in->proc_buf_in != NULL),\n                                \"process_frames() failed to reallocate proc_buf_in\");\n                    if (channel_remapping_needed) {\n                        in->proc_buf_out = realloc(in->proc_buf_out, src_buffer_size);\n                        ALOG_ASSERT((in->proc_buf_out != NULL),\n                                    \"process_frames() failed to reallocate proc_buf_out\");\n                        proc_buf_out = in->proc_buf_out;\n                    }\n                }\n                frames_rd = read_frames(in,\n                                        in->proc_buf_in +\n                                            in->proc_buf_frames * src_channels * bytes_per_sample,\n                                        frames_num - in->proc_buf_frames);\n                  if (frames_rd < 0) {\n                     frames_wr = frames_rd;\n                     break;\n }\n                in->proc_buf_frames += frames_rd;\n }\n\n \n             in_buf.frameCount = in->proc_buf_frames;\n            in_buf.s16 = in->proc_buf_in;\n             out_buf.frameCount = frames_num - frames_wr;\n            out_buf.s16 = (int16_t *)proc_buf_out + frames_wr * in->config.channels;\n \n            for (i = 0; i < in->num_preprocessors; i++) {\n                 (*in->preprocessors[i].effect_itfe)->process(in->preprocessors[i].effect_itfe,\n                                                    &in_buf,\n                                                    &out_buf);\n }\n\n            in->proc_buf_frames -= in_buf.frameCount;\n\n \n             if (in->proc_buf_frames) {\n                 memcpy(in->proc_buf_in,\n                       in->proc_buf_in + in_buf.frameCount * src_channels * bytes_per_sample,\n                       in->proc_buf_frames * in->config.channels * audio_bytes_per_sample(in_get_format(in)));\n             }\n \n if (out_buf.frameCount == 0) {\n                ALOGW(\"No frames produced by preproc\");\n continue;\n }\n\n if ((frames_wr + (ssize_t)out_buf.frameCount) <= frames_num) {\n                frames_wr += out_buf.frameCount;\n } else {\n                ALOGE(\"preprocessing produced too many frames: %d + %zd  > %d !\",\n (unsigned int)frames_wr, out_buf.frameCount, (unsigned int)frames_num);\n                frames_wr = frames_num;\n }\n }\n }\n else\n\n #endif \n     {\n        if (channel_remapping_needed) {\n            if (in->proc_buf_size < src_buffer_size) {\n                in->proc_buf_size = src_buffer_size;\n                in->proc_buf_out = realloc(in->proc_buf_out, src_buffer_size);\n                ALOG_ASSERT((in->proc_buf_out != NULL),\n                            \"process_frames() failed to reallocate proc_buf_out\");\n            }\n            proc_buf_out = in->proc_buf_out;\n        }\n         frames_wr = read_frames(in, proc_buf_out, frames_num);\n         ALOG_ASSERT(frames_wr <= frames_num, \"read more frames than requested\");\n     }\n \n    if (channel_remapping_needed) {\n         size_t ret = adjust_channels(proc_buf_out, src_channels, buffer, dst_channels,\n            bytes_per_sample, frames_wr * src_channels * bytes_per_sample);\n         ALOG_ASSERT(ret == (frames_wr * dst_channels * bytes_per_sample));\n     }\n \n return frames_wr;\n}\n", "target": 1, "flaw_line_index": "8,9,10,11,12,13,18,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,51,53,55,66,67,88,88,89,90,91,92,93,94,95,96,101,103"}
{"idx": 187992, "func": "OMX_ERRORTYPE SoftMPEG4Encoder::initEncParams() {\n    CHECK(mHandle != NULL);\n    memset(mHandle, 0, sizeof(tagvideoEncControls));\n\n    CHECK(mEncParams != NULL);\n    memset(mEncParams, 0, sizeof(tagvideoEncOptions));\n if (!PVGetDefaultEncOption(mEncParams, 0)) {\n        ALOGE(\"Failed to get default encoding parameters\");\n return OMX_ErrorUndefined;\n }\n    mEncParams->encMode = mEncodeMode;\n    mEncParams->encWidth[0] = mWidth;\n    mEncParams->encHeight[0] = mHeight;\n    mEncParams->encFrameRate[0] = mFramerate >> 16; \n    mEncParams->rcType = VBR_1;\n    mEncParams->vbvDelay = 5.0f;\n\n    mEncParams->profile_level = CORE_PROFILE_LEVEL2;\n    mEncParams->packetSize = 32;\n    mEncParams->rvlcEnable = PV_OFF;\n    mEncParams->numLayers = 1;\n    mEncParams->timeIncRes = 1000;\n    mEncParams->tickPerSrc = ((int64_t)mEncParams->timeIncRes << 16) / mFramerate;\n\n    mEncParams->bitRate[0] = mBitrate;\n    mEncParams->iQuant[0] = 15;\n    mEncParams->pQuant[0] = 12;\n    mEncParams->quantType[0] = 0;\n    mEncParams->noFrameSkipped = PV_OFF;\n\n\n     if (mColorFormat != OMX_COLOR_FormatYUV420Planar || mInputDataIsMeta) {\n         free(mInputFrameData);\n         mInputFrameData =\n             (uint8_t *) malloc((mWidth * mHeight * 3 ) >> 1);\n         CHECK(mInputFrameData != NULL);\n }\n\n if (mWidth % 16 != 0 || mHeight % 16 != 0) {\n        ALOGE(\"Video frame size %dx%d must be a multiple of 16\",\n            mWidth, mHeight);\n return OMX_ErrorBadParameter;\n }\n\n if (mIDRFrameRefreshIntervalInSec < 0) {\n        mEncParams->intraPeriod = -1;\n } else if (mIDRFrameRefreshIntervalInSec == 0) {\n        mEncParams->intraPeriod = 1; \n } else {\n        mEncParams->intraPeriod =\n (mIDRFrameRefreshIntervalInSec * mFramerate) >> 16;\n }\n\n    mEncParams->numIntraMB = 0;\n    mEncParams->sceneDetect = PV_ON;\n    mEncParams->searchRange = 16;\n    mEncParams->mv8x8Enable = PV_OFF;\n    mEncParams->gobHeaderInterval = 0;\n    mEncParams->useACPred = PV_ON;\n    mEncParams->intraDCVlcTh = 0;\n\n return OMX_ErrorNone;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187484, "func": " int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)\n{\n if(h < 0 || h >= MAX_THREAD)\n {\n        APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\n return FALSE;\n }\n if(ts[h].cmd_fdw == -1)\n {\n        APPL_TRACE_ERROR(\"cmd socket is not created. socket thread may not initialized\");\n return FALSE;\n }\n sock_cmd_t cmd = {CMD_USER_PRIVATE, 0, type, size, user_id};\n    APPL_TRACE_DEBUG(\"post cmd type:%d, size:%d, h:%d, \", type, size, h);\n sock_cmd_t* cmd_send = &cmd;\n int size_send = sizeof(cmd);\n if(data && size)\n {\n        size_send = sizeof(cmd) + size;\n        cmd_send = (sock_cmd_t*)alloca(size_send);\n if(cmd_send)\n {\n *cmd_send = cmd;\n            memcpy(cmd_send + 1, data, size);\n }\n else\n {\n            APPL_TRACE_ERROR(\"alloca failed at h:%d, cmd type:%d, size:%d\", h, type, size_send);\n\n             return FALSE;\n         }\n     }\n    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;\n }\n", "target": 1, "flaw_line_index": "33"}
{"idx": 8359, "func": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n    hwaddr addr;\n    int size;\n\n    addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n    pci_dma_read(pci, addr, req, sizeof(hdr));\n\n    if (hdr->Function < ARRAY_SIZE(mpi_request_sizes) &&\n        mpi_request_sizes[hdr->Function]) {\n        size = mpi_request_sizes[hdr->Function];\n        assert(size <= MPTSAS_MAX_REQUEST_SIZE);\n        pci_dma_read(pci, addr + sizeof(hdr), &req[sizeof(hdr)],\n                     size - sizeof(hdr));\n    }\n\n    if (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST) {\n        mptsas_process_scsi_io_request(s, (MPIMsgSCSIIORequest *)req, addr);\n    } else {\n        mptsas_process_message(s, (MPIRequestHeader *)req);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8608, "func": "static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)\n{\n    int num;\n\n    if (!s->config || !s->enable) {\n        return 0;\n    }\n\n    s->fifo_min  = le32_to_cpu(s->fifo[SVGA_FIFO_MIN]);\n    s->fifo_max  = le32_to_cpu(s->fifo[SVGA_FIFO_MAX]);\n    s->fifo_next = le32_to_cpu(s->fifo[SVGA_FIFO_NEXT]);\n    s->fifo_stop = le32_to_cpu(s->fifo[SVGA_FIFO_STOP]);\n\n    if ((s->fifo_min | s->fifo_max | s->fifo_next | s->fifo_stop) & 3) {\n        return 0;\n    }\n    if (s->fifo_min < sizeof(uint32_t) * 4) {\n        return 0;\n    }\n    if (s->fifo_max > SVGA_FIFO_SIZE ||\n        s->fifo_min >= SVGA_FIFO_SIZE ||\n        s->fifo_stop >= SVGA_FIFO_SIZE ||\n        s->fifo_next >= SVGA_FIFO_SIZE) {\n        return 0;\n    }\n    if (s->fifo_max < s->fifo_min + 10 * 1024) {\n        return 0;\n    }\n\n    num = s->fifo_next - s->fifo_stop;\n    if (num < 0) {\n        num += s->fifo_max - s->fifo_min;\n    }\n    return num >> 2;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9141, "func": "static boolean is_digit_alpha_underscore( const char *cur )\n{\n   return is_digit( cur ) || is_alpha_underscore( cur );\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187472, "func": "void close_uinput (void)\n\n {\n     BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__);\n     if (uinput_fd > 0) {\n        ioctl(uinput_fd, UI_DEV_DESTROY);\n \n         close(uinput_fd);\n         uinput_fd = -1;\n }\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 8314, "func": "XFixesSetPictureClipRegion (Display *dpy, XID picture,\n\t\t\t    int clip_x_origin, int clip_y_origin,\n\t\t\t    XserverRegion region)\n{\n    XFixesExtDisplayInfo\t    *info = XFixesFindDisplay (dpy);\n    xXFixesSetPictureClipRegionReq  *req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesSetPictureClipRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesSetPictureClipRegion;\n    req->picture = picture;\n    req->region = region;\n    req->xOrigin = clip_x_origin;\n    req->yOrigin = clip_y_origin;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8394, "func": "void virtio_queue_set_notification(VirtQueue *vq, int enable)\n{\n    vq->notification = enable;\n    if (virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX)) {\n        vring_set_avail_event(vq, vring_avail_idx(vq));\n    } else if (enable) {\n        vring_used_flags_unset_bit(vq, VRING_USED_F_NO_NOTIFY);\n    } else {\n        vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY);\n    }\n    if (enable) {\n        smp_mb();\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8421, "func": "pvscsi_on_cmd_abort(PVSCSIState *s)\n{\n    PVSCSICmdDescAbortCmd *cmd = (PVSCSICmdDescAbortCmd *) s->curr_cmd_data;\n    PVSCSIRequest *r, *next;\n\n    trace_pvscsi_on_cmd_abort(cmd->context, cmd->target);\n\n    QTAILQ_FOREACH_SAFE(r, &s->pending_queue, next, next) {\n        if (r->req.context == cmd->context) {\n            break;\n        }\n    }\n    if (r) {\n        assert(!r->completed);\n        r->cmp.hostStatus = BTSTAT_ABORTQUEUE;\n        scsi_req_cancel(r->sreq);\n    }\n\n    return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187919, "func": " virtual status_t configureVideoTunnelMode(\n            node_id node, OMX_U32 portIndex, OMX_BOOL tunneled,\n            OMX_U32 audioHwSync, native_handle_t **sidebandHandle ) {\n Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n        data.writeInt32((int32_t)node);\n        data.writeInt32(portIndex);\n        data.writeInt32((int32_t)tunneled);\n        data.writeInt32(audioHwSync);\n\n         remote()->transact(CONFIGURE_VIDEO_TUNNEL_MODE, data, &reply);\n \n         status_t err = reply.readInt32();\n        if (sidebandHandle) {\n             *sidebandHandle = (native_handle_t *)reply.readNativeHandle();\n         }\n         return err;\n }\n", "target": 1, "flaw_line_index": "14"}
{"idx": 187880, "func": "long Cluster::ParseSimpleBlock(long long block_size, long long& pos,\n long& len) {\n const long long block_start = pos;\n const long long block_stop = pos + block_size;\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long total, avail;\n\n long status = pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((pos + len) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long track = ReadUInt(pReader, pos, len);\n\n if (track < 0) \n return static_cast<long>(track);\n\n\n   if (track == 0)\n     return E_FILE_FORMAT_INVALID;\n \n#if 0\n    const Tracks* const pTracks = m_pSegment->GetTracks();\n    assert(pTracks);\n    const long tn = static_cast<long>(track);\n    const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n    if (pTrack == NULL)\n        return E_FILE_FORMAT_INVALID;\n#endif\n   pos += len;  \n \n   if ((pos + 2) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + 2) > avail) {\n    len = 2;\n return E_BUFFER_NOT_FULL;\n }\n\n  pos += 2; \n\n if ((pos + 1) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n unsigned char flags;\n\n  status = pReader->Read(pos, 1, &flags);\n\n if (status < 0) { \n    len = 1;\n return status;\n }\n\n ++pos; \n  assert(pos <= avail);\n\n if (pos >= block_stop)\n return E_FILE_FORMAT_INVALID;\n\n const int lacing = int(flags & 0x06) >> 1;\n\n if ((lacing != 0) && (block_stop > avail)) {\n    len = static_cast<long>(block_stop - pos);\n return E_BUFFER_NOT_FULL;\n }\n\n  status = CreateBlock(0x23, \n                       block_start, block_size,\n 0); \n\n if (status != 0)\n return status;\n\n  m_pos = block_stop;\n\n return 0; \n}\n", "target": 1, "flaw_line_index": "47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71"}
{"idx": 8771, "func": "static void perform_renew(void)\n{\n\tbb_error_msg(\"performing DHCP renew\");\n\tswitch (state) {\n\tcase BOUND:\n\t\tchange_listen_mode(LISTEN_KERNEL);\n\tcase RENEWING:\n\tcase REBINDING:\n\t\tstate = RENEW_REQUESTED;\n\t\tbreak;\n\tcase RENEW_REQUESTED: \n\t\tudhcp_run_script(NULL, \"deconfig\");\n\tcase REQUESTING:\n\tcase RELEASED:\n\t\tchange_listen_mode(LISTEN_RAW);\n\t\tstate = INIT_SELECTING;\n\t\tbreak;\n\tcase INIT_SELECTING:\n\t\tbreak;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187350, "func": "xsltIf(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,\n\t           xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n    int res = 0;\n\n#ifdef XSLT_REFACTORED\n    xsltStyleItemIfPtr comp = (xsltStyleItemIfPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n\n    if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL))\n\treturn;\n    if ((comp == NULL) || (comp->test == NULL) || (comp->comp == NULL)) {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"Internal error in xsltIf(): \"\n\t    \"The XSLT 'if' instruction was not compiled.\\n\");\n\treturn;\n    }\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,\n\t \"xsltIf: test %s\\n\", comp->test));\n#endif\n \n #ifdef XSLT_FAST_IF\n     {\n\txmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n\txmlDocPtr oldXPContextDoc = xpctxt->doc;\n\txmlNsPtr *oldXPNamespaces = xpctxt->namespaces;\n\txmlNodePtr oldXPContextNode = xpctxt->node;\n\tint oldXPProximityPosition = xpctxt->proximityPosition;\n\tint oldXPContextSize = xpctxt->contextSize;\n\tint oldXPNsNr = xpctxt->nsNr;\n \txmlDocPtr oldLocalFragmentTop = ctxt->localRVT;\n \n\txpctxt->node = contextNode;\n\tif (comp != NULL) {\n#ifdef XSLT_REFACTORED\n\t    if (comp->inScopeNs != NULL) {\n\t\txpctxt->namespaces = comp->inScopeNs->list;\n\t\txpctxt->nsNr = comp->inScopeNs->xpathNumber;\n\t    } else {\n\t\txpctxt->namespaces = NULL;\n\t\txpctxt->nsNr = 0;\n\t    }\n#else\n\t    xpctxt->namespaces = comp->nsList;\n\t    xpctxt->nsNr = comp->nsNr;\n#endif\n\t} else {\n\t    xpctxt->namespaces = NULL;\n\t    xpctxt->nsNr = 0;\n\t}\n\tres = xmlXPathCompiledEvalToBoolean(comp->comp, xpctxt);\n \n \tif (oldLocalFragmentTop != ctxt->localRVT)\n \t    xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n\txpctxt->doc = oldXPContextDoc;\n\txpctxt->node = oldXPContextNode;\n\txpctxt->contextSize = oldXPContextSize;\n\txpctxt->proximityPosition = oldXPProximityPosition;\n\txpctxt->nsNr = oldXPNsNr;\n\txpctxt->namespaces = oldXPNamespaces;\n     }\n \n #ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,\n\t\"xsltIf: test evaluate to %d\\n\", res));\n#endif\n\n    if (res == -1) {\n\tctxt->state = XSLT_STATE_STOPPED;\n\tgoto error;\n    }\n    if (res == 1) {\n\txsltApplySequenceConstructor(ctxt,\n\t    contextNode, inst->children, NULL);\n    }\n \n #else \n     {\n\txmlXPathObjectPtr xpobj = NULL;\n\t{\n\t    xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n\t    xmlDocPtr oldXPContextDoc = xpctxt->doc;\n\t    xmlNsPtr *oldXPNamespaces = xpctxt->namespaces;\n\t    xmlNodePtr oldXPContextNode = xpctxt->node;\n\t    int oldXPProximityPosition = xpctxt->proximityPosition;\n\t    int oldXPContextSize = xpctxt->contextSize;\n\t    int oldXPNsNr = xpctxt->nsNr;\n\t    xpctxt->node = contextNode;\n\t    if (comp != NULL) {\n#ifdef XSLT_REFACTORED\n\t\tif (comp->inScopeNs != NULL) {\n\t\t    xpctxt->namespaces = comp->inScopeNs->list;\n\t\t    xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n\t\t} else {\n\t\t    xpctxt->namespaces = NULL;\n\t\t    xpctxt->nsNr = 0;\n\t\t}\n#else\n\t\txpctxt->namespaces = comp->nsList;\n\t\txpctxt->nsNr = comp->nsNr;\n#endif\n\t    } else {\n\t\txpctxt->namespaces = NULL;\n\t\txpctxt->nsNr = 0;\n\t    }\n\t    xpobj = xmlXPathCompiledEval(comp->comp, xpctxt);\n\t    xpctxt->doc = oldXPContextDoc;\n\t    xpctxt->node = oldXPContextNode;\n\t    xpctxt->contextSize = oldXPContextSize;\n\t    xpctxt->proximityPosition = oldXPProximityPosition;\n\t    xpctxt->nsNr = oldXPNsNr;\n\t    xpctxt->namespaces = oldXPNamespaces;\n\t}\n \tif (xpobj != NULL) {\n \t    if (xpobj->type != XPATH_BOOLEAN)\n \t\txpobj = xmlXPathConvertBoolean(xpobj);\n\t    if (xpobj->type == XPATH_BOOLEAN) {\n\t\tres = xpobj->boolval;\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\tXSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,\n\t\t    \"xsltIf: test evaluate to %d\\n\", res));\n#endif\n\t\tif (res) {\n\t\t    xsltApplySequenceConstructor(ctxt,\n\t\t\tcontextNode, inst->children, NULL);\n\t\t}\n\t    } else {\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\tXSLT_TRACE(ctxt, XSLT_TRACE_IF,\n\t\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t    \"xsltIf: test didn't evaluate to a boolean\\n\"));\n#endif\n\t\tctxt->state = XSLT_STATE_STOPPED;\n\t    }\n\t    xmlXPathFreeObject(xpobj);\n\t} else {\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t}\n    }\n#endif \n\nerror:\n    return;\n}\n", "target": 1, "flaw_line_index": "28,29,30,31,32,33,34,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,54,54,55,59,60,61,62,63,64,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,109,109,110,111,112,113,114,115,116,117"}
{"idx": 9151, "func": "vrend_shader_state_reference(struct vrend_shader_selector **ptr, struct vrend_shader_selector *shader)\n{\n   struct vrend_shader_selector *old_shader = *ptr;\n\n   if (pipe_reference(&(*ptr)->reference, &shader->reference))\n      vrend_destroy_shader_selector(old_shader);\n   *ptr = shader;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187687, "func": "make_transform_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,\n    png_byte PNG_CONST bit_depth, unsigned int palette_number,\n     int interlace_type, png_const_charp name)\n {\n    context(ps, fault);\n\n   check_interlace_type(interlace_type);\n\n Try\n\n    {\n       png_infop pi;\n       png_structp pp = set_store_for_write(ps, &pi, name);\n      png_uint_32 h;\n \n\n       if (pp == NULL)\n          Throw ps;\n \n       h = transform_height(pp, colour_type, bit_depth);\n \n      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth), h,\n         bit_depth, colour_type, interlace_type,\n          PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n \n #ifdef PNG_TEXT_SUPPORTED\n#  if defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED)\n#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_zTXt\n#  else\n#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_NONE\n#  endif\n {\n static char key[] = \"image name\"; \n size_t pos;\n         png_text text;\n char copy[FILE_NAME_SIZE];\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         pos = safecat(copy, sizeof copy, 0, ps->wname);\n         text.text = copy;\n         text.text_length = pos;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n\n         png_set_text(pp, pi, &text, 1);\n }\n#endif\n\n\n       if (colour_type == 3) \n          init_standard_palette(ps, pp, pi, 1U << bit_depth, 1\n);\n \n       png_write_info(pp, pi);\n \n       if (png_get_rowbytes(pp, pi) !=\n           transform_rowsize(pp, colour_type, bit_depth))\n         png_error(pp, \"row size incorrect\");\n \n       else\n       {\n         int npasses = png_set_interlace_handling(pp);\n          int pass;\n \n          if (npasses != npasses_from_interlace_type(pp, interlace_type))\n            png_error(pp, \"write: png_set_interlace_handling failed\");\n\n for (pass=0; pass<npasses; ++pass)\n\n          {\n             png_uint_32 y;\n \n             for (y=0; y<h; ++y)\n             {\n                png_byte buffer[TRANSFORM_ROWMAX];\n \n                transform_row(pp, buffer, colour_type, bit_depth, y);\n                png_write_row(pp, buffer);\n             }\n          }\n }\n\n#ifdef PNG_TEXT_SUPPORTED\n {\n static char key[] = \"end marker\";\n static char comment[] = \"end\";\n         png_text text;\n\n         text.compression = TEXT_COMPRESSION;\n         text.key = key;\n         text.text = comment;\n         text.text_length = (sizeof comment)-1;\n         text.itxt_length = 0;\n         text.lang = 0;\n         text.lang_key = 0;\n\n         png_set_text(pp, pi, &text, 1);\n }\n#endif\n\n      png_write_end(pp, pi);\n\n      store_storefile(ps, FILEID(colour_type, bit_depth, palette_number,\n         interlace_type, 0, 0, 0));\n\n      store_write_reset(ps);\n }\n\n Catch(fault)\n {\n      store_write_reset(fault);\n }\n\n }\n", "target": 1, "flaw_line_index": "2,14,22,23,60,64"}
{"idx": 8576, "func": "static void ssh_pkt_defersend(Ssh ssh)\n{\n    int backlog;\n    backlog = s_write(ssh, ssh->deferred_send_data, ssh->deferred_len);\n    ssh->deferred_len = ssh->deferred_size = 0;\n    sfree(ssh->deferred_send_data);\n    ssh->deferred_send_data = NULL;\n    if (backlog > SSH_MAX_BACKLOG)\n\tssh_throttle_all(ssh, 1, backlog);\n\n    if (ssh->version == 2) {\n\tssh->outgoing_data_size += ssh->deferred_data_size;\n\tssh->deferred_data_size = 0;\n\tif (!ssh->kex_in_progress &&\n\t    !ssh->bare_connection &&\n\t    ssh->max_data_size != 0 &&\n\t    ssh->outgoing_data_size > ssh->max_data_size)\n\t    do_ssh2_transport(ssh, \"too much data sent\", -1, NULL);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9175, "func": "void qemu_put_virtqueue_element(QEMUFile *f, VirtQueueElement *elem)\n{\n    VirtQueueElementOld data;\n    int i;\n\n    memset(&data, 0, sizeof(data));\n    data.index = elem->index;\n    data.in_num = elem->in_num;\n    data.out_num = elem->out_num;\n\n    for (i = 0; i < elem->in_num; i++) {\n        data.in_addr[i] = elem->in_addr[i];\n    }\n\n    for (i = 0; i < elem->out_num; i++) {\n        data.out_addr[i] = elem->out_addr[i];\n    }\n\n    for (i = 0; i < elem->in_num; i++) {\n        data.in_sg[i].iov_len = elem->in_sg[i].iov_len;\n    }\n\n    for (i = 0; i < elem->out_num; i++) {\n        data.out_sg[i].iov_len = elem->out_sg[i].iov_len;\n    }\n    qemu_put_buffer(f, (uint8_t *)&data, sizeof(VirtQueueElementOld));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187677, "func": "image_transform_png_set_tRNS_to_alpha_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n   PNG_CONST transform_display *display)\n {\n    if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n       image_pixel_convert_PLTE(that);\n \n    if (that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n \n    else\n    {\n if (that->bit_depth < 8)\n         that->bit_depth =8;\n\n       if (that->sample_depth < 8)\n          that->sample_depth = 8;\n    }\n \n    this->next->mod(this->next, that, pp, display);\n }\n", "target": 1, "flaw_line_index": "3,9"}
{"idx": 187524, "func": "OMX_ERRORTYPE  omx_video::allocate_output_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes)\n{\n (void)hComp, (void)port;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n    OMX_BUFFERHEADERTYPE       *bufHdr= NULL; \n unsigned                         i= 0; \n#ifdef _MSM8974_\n int align_size;\n#endif\n    DEBUG_PRINT_HIGH(\"allocate_output_buffer()for %u bytes\", (unsigned int)bytes);\n if (!m_out_mem_ptr) {\n int nBufHdrSize        = 0;\n        DEBUG_PRINT_HIGH(\"%s: size = %u, actual cnt %u\", __FUNCTION__,\n (unsigned int)m_sOutPortDef.nBufferSize, (unsigned int)m_sOutPortDef.nBufferCountActual);\n        nBufHdrSize        = m_sOutPortDef.nBufferCountActual * sizeof(OMX_BUFFERHEADERTYPE);\n\n        m_out_mem_ptr = (OMX_BUFFERHEADERTYPE  *)calloc(nBufHdrSize,1);\n\n#ifdef USE_ION\n        m_pOutput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sOutPortDef.nBufferCountActual);\n if (m_pOutput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pOutput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n        m_pOutput_pmem = (struct pmem *) calloc(sizeof(struct pmem), m_sOutPortDef.nBufferCountActual);\n if (m_pOutput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pOutput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n if (m_out_mem_ptr && m_pOutput_pmem) {\n            bufHdr          =  m_out_mem_ptr;\n\n for (i=0; i < m_sOutPortDef.nBufferCountActual ; i++) {\n                bufHdr->nSize              = sizeof(OMX_BUFFERHEADERTYPE);\n                bufHdr->nVersion.nVersion  = OMX_SPEC_VERSION;\n                bufHdr->nAllocLen          = bytes;\n                bufHdr->nFilledLen         = 0;\n                bufHdr->pAppPrivate        = appData;\n                bufHdr->nOutputPortIndex   = PORT_INDEX_OUT;\n                bufHdr->pOutputPortPrivate = (OMX_PTR)&m_pOutput_pmem[i];\n                bufHdr->pBuffer            = NULL;\n                bufHdr++;\n                m_pOutput_pmem[i].fd = -1;\n#ifdef USE_ION\n                m_pOutput_ion[i].ion_device_fd =-1;\n                m_pOutput_ion[i].fd_ion_data.fd=-1;\n                m_pOutput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() failed for m_out_mem_ptr/m_pOutput_pmem\");\n            eRet = OMX_ErrorInsufficientResources;\n }\n }\n\n    DEBUG_PRINT_HIGH(\"actual cnt = %u\", (unsigned int)m_sOutPortDef.nBufferCountActual);\n for (i=0; i< m_sOutPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_out_bm_count,i)) {\n            DEBUG_PRINT_LOW(\"Found a Free Output Buffer %d\",i);\n break;\n }\n }\n if (eRet == OMX_ErrorNone) {\n if (i < m_sOutPortDef.nBufferCountActual) {\n#ifdef USE_ION\n#ifdef _MSM8974_\n            align_size = ((m_sOutPortDef.nBufferSize + 4095)/4096) * 4096;\n            m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(align_size,\n &m_pOutput_ion[i].ion_alloc_data,\n &m_pOutput_ion[i].fd_ion_data, ION_FLAG_CACHED);\n#else\n            m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sOutPortDef.nBufferSize,\n &m_pOutput_ion[i].ion_alloc_data,\n &m_pOutput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pOutput_ion[i].ion_device_fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n\n            m_pOutput_pmem[i].fd = m_pOutput_ion[i].fd_ion_data.fd;\n#else\n            m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n if (m_pOutput_pmem[i].fd == 0) {\n                m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pOutput_pmem[i].fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n\n             m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;\n             m_pOutput_pmem[i].offset = 0;\n \n            m_pOutput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n             if(!secure_session) {\n #ifdef _MSM8974_\n                 m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                    align_size,PROT_READ|PROT_WRITE,\n                    MAP_SHARED,m_pOutput_pmem[i].fd,0);\n#else\n                m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                    m_pOutput_pmem[i].size,PROT_READ|PROT_WRITE,\n                    MAP_SHARED,m_pOutput_pmem[i].fd,0);\n\n #endif\n             if (m_pOutput_pmem[i].buffer == MAP_FAILED) {\n                     DEBUG_PRINT_ERROR(\"ERROR: MMAP_FAILED in o/p alloc buffer\");\n                 close (m_pOutput_pmem[i].fd);\n #ifdef USE_ION\n                 free_ion_memory(&m_pOutput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n }\n else {\n\n                 m_pOutput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));\n                 (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);\n                 native_handle_t *handle = native_handle_create(1, 0);\n                 handle->data[0] = m_pOutput_pmem[i].fd;\n char *data = (char*) m_pOutput_pmem[i].buffer;\n                OMX_U32 type = 1;\n                memcpy(data, &type, sizeof(OMX_U32));\n                memcpy(data + sizeof(OMX_U32), &handle, sizeof(native_handle_t*));\n }\n\n *bufferHdr = (m_out_mem_ptr + i );\n (*bufferHdr)->pBuffer = (OMX_U8 *)m_pOutput_pmem[i].buffer;\n (*bufferHdr)->pAppPrivate = appData;\n\n            BITMASK_SET(&m_out_bm_count,i);\n\n if (dev_use_buf(&m_pOutput_pmem[i],PORT_INDEX_OUT,i) != true) {\n                DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf FAILED for o/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: All o/p buffers are allocated, invalid allocate buf call\"\n \"for index [%d] actual: %u\", i, (unsigned int)m_sOutPortDef.nBufferCountActual);\n }\n }\n\n return eRet;\n}\n", "target": 1, "flaw_line_index": "105"}
{"idx": 8693, "func": "run_test (const char *test, const char *expected_result, enum url_scheme scheme,\n          bool expected_change)\n{\n  char *test_copy = xstrdup (test);\n  bool modified = path_simplify (scheme, test_copy);\n\n  if (0 != strcmp (test_copy, expected_result))\n    {\n      printf (\"Failed path_simplify(\\\"%s\\\"): expected \\\"%s\\\", got \\\"%s\\\".\\n\",\n              test, expected_result, test_copy);\n      mu_assert (\"\", 0);\n    }\n  if (modified != expected_change)\n    {\n      if (expected_change)\n        printf (\"Expected modification with path_simplify(\\\"%s\\\").\\n\",\n                test);\n      else\n        printf (\"Expected no modification with path_simplify(\\\"%s\\\").\\n\",\n                test);\n    }\n  xfree (test_copy);\n  mu_assert (\"\", modified == expected_change);\n  return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188021, "func": "IHEVCD_ERROR_T ihevcd_mv_buf_mgr_add_bufs(codec_t *ps_codec)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 i;\n    WORD32 max_dpb_size;\n    WORD32 mv_bank_size_allocated;\n    WORD32 pic_mv_bank_size;\n\n sps_t *ps_sps;\n    UWORD8 *pu1_buf;\n mv_buf_t *ps_mv_buf;\n\n\n    ps_sps = ps_codec->s_parse.ps_sps;\n\n\n    max_dpb_size = ps_sps->ai1_sps_max_dec_pic_buffering[ps_sps->i1_sps_max_sub_layers - 1];\n\n     max_dpb_size++;\n \n     pu1_buf = (UWORD8 *)ps_codec->pv_mv_bank_buf_base;\n \n     ps_mv_buf = (mv_buf_t *)pu1_buf;\n    pu1_buf += max_dpb_size * sizeof(mv_buf_t);\n    ps_codec->ps_mv_buf = ps_mv_buf;\n    mv_bank_size_allocated = ps_codec->i4_total_mv_bank_size - max_dpb_size  * sizeof(mv_buf_t);\n\n    pic_mv_bank_size = ihevcd_get_pic_mv_bank_size(ALIGN64(ps_sps->i2_pic_width_in_luma_samples) *\n                                                   ALIGN64(ps_sps->i2_pic_height_in_luma_samples));\n\n for(i = 0; i < max_dpb_size; i++)\n {\n        WORD32 buf_ret;\n        WORD32 num_pu;\n        WORD32 num_ctb;\n        WORD32 pic_size;\n        pic_size = ALIGN64(ps_sps->i2_pic_width_in_luma_samples) *\n                        ALIGN64(ps_sps->i2_pic_height_in_luma_samples);\n\n\n        num_pu = pic_size / (MIN_PU_SIZE * MIN_PU_SIZE);\n        num_ctb = pic_size / (MIN_CTB_SIZE * MIN_CTB_SIZE);\n\n\n        mv_bank_size_allocated -= pic_mv_bank_size;\n\n if(mv_bank_size_allocated < 0)\n {\n            ps_codec->s_parse.i4_error_code = IHEVCD_INSUFFICIENT_MEM_MVBANK;\n return IHEVCD_INSUFFICIENT_MEM_MVBANK;\n }\n\n        ps_mv_buf->pu4_pic_pu_idx = (UWORD32 *)pu1_buf;\n        pu1_buf += (num_ctb + 1) * sizeof(WORD32);\n\n        ps_mv_buf->pu1_pic_pu_map = pu1_buf;\n        pu1_buf += num_pu;\n\n        ps_mv_buf->pu1_pic_slice_map = (UWORD16 *)pu1_buf;\n        pu1_buf += ALIGN4(num_ctb * sizeof(UWORD16));\n\n        ps_mv_buf->ps_pic_pu = (pu_t *)pu1_buf;\n        pu1_buf += num_pu * sizeof(pu_t);\n\n        buf_ret = ihevc_buf_mgr_add((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, ps_mv_buf, i);\n\n if(0 != buf_ret)\n {\n            ps_codec->s_parse.i4_error_code = IHEVCD_BUF_MGR_ERROR;\n return IHEVCD_BUF_MGR_ERROR;\n }\n\n        ps_mv_buf++;\n\n }\n return ret;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187650, "func": "image_transform_png_set_expand_16_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_expand_16(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8814, "func": "static GLenum translate_blend_factor(uint32_t pipe_factor)\n{\n   switch (pipe_factor) {\n   case PIPE_BLENDFACTOR_ONE: return GL_ONE;\n   case PIPE_BLENDFACTOR_SRC_COLOR: return GL_SRC_COLOR;\n   case PIPE_BLENDFACTOR_SRC_ALPHA: return GL_SRC_ALPHA;\n\n   case PIPE_BLENDFACTOR_DST_COLOR: return GL_DST_COLOR;\n   case PIPE_BLENDFACTOR_DST_ALPHA: return GL_DST_ALPHA;\n\n   case PIPE_BLENDFACTOR_CONST_COLOR: return GL_CONSTANT_COLOR;\n   case PIPE_BLENDFACTOR_CONST_ALPHA: return GL_CONSTANT_ALPHA;\n\n   case PIPE_BLENDFACTOR_SRC1_COLOR: return GL_SRC1_COLOR;\n   case PIPE_BLENDFACTOR_SRC1_ALPHA: return GL_SRC1_ALPHA;\n   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE: return GL_SRC_ALPHA_SATURATE;\n   case PIPE_BLENDFACTOR_ZERO: return GL_ZERO;\n\n\n   case PIPE_BLENDFACTOR_INV_SRC_COLOR: return GL_ONE_MINUS_SRC_COLOR;\n   case PIPE_BLENDFACTOR_INV_SRC_ALPHA: return GL_ONE_MINUS_SRC_ALPHA;\n\n   case PIPE_BLENDFACTOR_INV_DST_COLOR: return GL_ONE_MINUS_DST_COLOR;\n   case PIPE_BLENDFACTOR_INV_DST_ALPHA: return GL_ONE_MINUS_DST_ALPHA;\n\n   case PIPE_BLENDFACTOR_INV_CONST_COLOR: return GL_ONE_MINUS_CONSTANT_COLOR;\n   case PIPE_BLENDFACTOR_INV_CONST_ALPHA: return GL_ONE_MINUS_CONSTANT_ALPHA;\n\n   case PIPE_BLENDFACTOR_INV_SRC1_COLOR: return GL_ONE_MINUS_SRC1_COLOR;\n   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA: return GL_ONE_MINUS_SRC1_ALPHA;\n\n   default:\n      assert(\"invalid blend token()\" == NULL);\n      return 0;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188572, "func": "  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride, tx_type_);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 9049, "func": "static inline size_t vmxnet3_ring_curr_cell_idx(Vmxnet3Ring *ring)\n{\n    return ring->next;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187953, "func": "static void timer_config_save(UNUSED_ATTR void *data) {\n   assert(config != NULL);\n   assert(alarm_timer != NULL);\n \n  static const size_t CACHE_MAX = 256;\n  const char *keys[CACHE_MAX];\n  size_t num_keys = 0;\n  size_t total_candidates = 0;\n \n   pthread_mutex_lock(&lock);\n  for (const config_section_node_t *snode = config_section_begin(config); snode != config_section_end(config); snode = config_section_next(snode)) {\n    const char *section = config_section_name(snode);\n    if (!string_is_bdaddr(section))\n      continue;\n    if (config_has_key(config, section, \"LinkKey\") ||\n        config_has_key(config, section, \"LE_KEY_PENC\") ||\n        config_has_key(config, section, \"LE_KEY_PID\") ||\n        config_has_key(config, section, \"LE_KEY_PCSRK\") ||\n        config_has_key(config, section, \"LE_KEY_LENC\") ||\n        config_has_key(config, section, \"LE_KEY_LCSRK\"))\n      continue;\n    if (num_keys < CACHE_MAX)\n      keys[num_keys++] = section;\n    ++total_candidates;\n  }\n  if (total_candidates > CACHE_MAX * 2)\n    while (num_keys > 0)\n      config_remove_section(config, keys[--num_keys]);\n   config_save(config, CONFIG_FILE_PATH);\n   pthread_mutex_unlock(&lock);\n }\n", "target": 1, "flaw_line_index": "5,6,7,8,9,10,11,12,13,14,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32"}
{"idx": 188198, "func": " void SoftAVC::drainAllOutputBuffers(bool eos) {\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n    H264SwDecPicture decodedPicture;\n\n if (mHeadersDecoded) {\n while (!outQueue.empty()\n && H264SWDEC_PIC_RDY == H264SwDecNextPicture(\n\n                     mHandle, &decodedPicture, eos \n)) {\n             int32_t picId = decodedPicture.picId;\n             uint8_t *data = (uint8_t *) decodedPicture.pOutputPicture;\n            drainOneOutputBuffer(picId, data);\n         }\n     }\n \n if (!eos) {\n return;\n }\n\n while (!outQueue.empty()) {\n BufferInfo *outInfo = *outQueue.begin();\n        outQueue.erase(outQueue.begin());\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n        outHeader->nTimeStamp = 0;\n        outHeader->nFilledLen = 0;\n        outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n        outInfo->mOwnedByUs = false;\n        notifyFillBufferDone(outHeader);\n\n        mEOSStatus = OUTPUT_FRAMES_FLUSHED;\n }\n}\n", "target": 1, "flaw_line_index": "13"}
{"idx": 8423, "func": "pvscsi_on_cmd_config(PVSCSIState *s)\n{\n    trace_pvscsi_on_cmd_noimpl(\"PVSCSI_CMD_CONFIG\");\n    return PVSCSI_COMMAND_PROCESSING_FAILED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9177, "func": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n                            VirtIOHandleOutput handle_output)\n{\n    return virtio_add_queue_internal(vdev, queue_size, handle_output, false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8934, "func": "void vrend_set_framebuffer_state(struct vrend_context *ctx,\n                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],\n                                 uint32_t zsurf_handle)\n{\n   struct vrend_surface *surf, *zsurf;\n   int i;\n   int old_num;\n   GLenum status;\n   GLint new_height = -1;\n   bool new_ibf = false;\n\n   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);\n\n   if (zsurf_handle) {\n      zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);\n      if (!zsurf) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);\n         return;\n      }\n   } else\n      zsurf = NULL;\n\n   if (ctx->sub->zsurf != zsurf) {\n      vrend_surface_reference(&ctx->sub->zsurf, zsurf);\n      vrend_hw_set_zsurf_texture(ctx);\n   }\n\n   old_num = ctx->sub->nr_cbufs;\n   ctx->sub->nr_cbufs = nr_cbufs;\n   ctx->sub->old_nr_cbufs = old_num;\n\n   for (i = 0; i < nr_cbufs; i++) {\n      if (surf_handle[i] != 0) {\n         surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);\n         if (!surf) {\n            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);\n            return;\n         }\n      } else\n         surf = NULL;\n\n      if (ctx->sub->surf[i] != surf) {\n         vrend_surface_reference(&ctx->sub->surf[i], surf);\n         vrend_hw_set_color_surface(ctx, i);\n      }\n   }\n\n   if (old_num > ctx->sub->nr_cbufs) {\n      for (i = ctx->sub->nr_cbufs; i < old_num; i++) {\n         vrend_surface_reference(&ctx->sub->surf[i], NULL);\n         vrend_hw_set_color_surface(ctx, i);\n      }\n   }\n\n   if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {\n      new_height = 0;\n      new_ibf = false;\n   } else if (ctx->sub->nr_cbufs == 0) {\n      new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);\n      new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;\n   }\n   else {\n      surf = NULL;\n      for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n         if (ctx->sub->surf[i]) {\n            surf = ctx->sub->surf[i];\n            break;\n         }\n      }\n      if (surf == NULL) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);\n         return;\n      }\n      new_height = u_minify(surf->texture->base.height0, surf->val0);\n      new_ibf = surf->texture->y_0_top ? true : false;\n   }\n\n   if (new_height != -1) {\n      if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {\n         ctx->sub->fb_height = new_height;\n         ctx->sub->inverted_fbo_content = new_ibf;\n         ctx->sub->scissor_state_dirty = (1 << 0);\n         ctx->sub->viewport_state_dirty = (1 << 0);\n      }\n   }\n\n   vrend_hw_emit_framebuffer_state(ctx);\n\n   if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {\n      status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n      if (status != GL_FRAMEBUFFER_COMPLETE)\n         fprintf(stderr,\"failed to complete framebuffer 0x%x %s\\n\", status, ctx->debug_name);\n   }\n   ctx->sub->shader_dirty = true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9018, "func": "static bool vmxnet3_mc_list_needed(void *opaque)\n{\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187447, "func": "static int adev_open_output_stream(struct audio_hw_device *dev,\n audio_io_handle_t handle,\n audio_devices_t devices,\n audio_output_flags_t flags,\n struct audio_config *config,\n struct audio_stream_out **stream_out,\n const char *address)\n\n{\n struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device *)dev;\n struct a2dp_stream_out *out;\n int ret = 0;\n int i;\n    UNUSED(address);\n    UNUSED(handle);\n    UNUSED(devices);\n    UNUSED(flags);\n\n    INFO(\"opening output\");\n\n    out = (struct a2dp_stream_out *)calloc(1, sizeof(struct a2dp_stream_out));\n\n if (!out)\n return -ENOMEM;\n\n    out->stream.common.get_sample_rate = out_get_sample_rate;\n    out->stream.common.set_sample_rate = out_set_sample_rate;\n    out->stream.common.get_buffer_size = out_get_buffer_size;\n    out->stream.common.get_channels = out_get_channels;\n    out->stream.common.get_format = out_get_format;\n    out->stream.common.set_format = out_set_format;\n    out->stream.common.standby = out_standby;\n    out->stream.common.dump = out_dump;\n    out->stream.common.set_parameters = out_set_parameters;\n    out->stream.common.get_parameters = out_get_parameters;\n    out->stream.common.add_audio_effect = out_add_audio_effect;\n    out->stream.common.remove_audio_effect = out_remove_audio_effect;\n    out->stream.get_latency = out_get_latency;\n    out->stream.set_volume = out_set_volume;\n    out->stream.write = out_write;\n    out->stream.get_render_position = out_get_render_position;\n    out->stream.get_presentation_position = out_get_presentation_position;\n\n\n    a2dp_stream_common_init(&out->common);\n\n    out->common.cfg.channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG;\n    out->common.cfg.format = AUDIO_STREAM_DEFAULT_FORMAT;\n    out->common.cfg.rate = AUDIO_STREAM_DEFAULT_RATE;\n\n if (config)\n {\n      config->format = out_get_format((const struct audio_stream *)&out->stream);\n      config->sample_rate = out_get_sample_rate((const struct audio_stream *)&out->stream);\n      config->channel_mask = out_get_channels((const struct audio_stream *)&out->stream);\n }\n *stream_out = &out->stream;\n    a2dp_dev->output = out;\n\n    a2dp_open_ctrl_path(&out->common);\n if (out->common.ctrl_fd == AUDIO_SKT_DISCONNECTED)\n {\n        ERROR(\"ctrl socket failed to connect (%s)\", strerror(errno));\n        ret = -1;\n goto err_open;\n }\n\n\n     DEBUG(\"success\");\n    usleep(250000);\n     return 0;\n \n err_open:\n    free(out);\n *stream_out = NULL;\n    a2dp_dev->output = NULL;\n    ERROR(\"failed\");\n return ret;\n}\n", "target": 1, "flaw_line_index": "70"}
{"idx": 8556, "func": "static int ssh_closing(Plug plug, const char *error_msg, int error_code,\n\t\t       int calling_back)\n{\n    Ssh ssh = (Ssh) plug;\n    int need_notify = ssh_do_close(ssh, FALSE);\n\n    if (!error_msg) {\n\tif (!ssh->close_expected)\n\t    error_msg = \"Server unexpectedly closed network connection\";\n\telse\n\t    error_msg = \"Server closed network connection\";\n    }\n\n    if (ssh->close_expected && ssh->clean_exit && ssh->exitcode < 0)\n\tssh->exitcode = 0;\n\n    if (need_notify)\n        notify_remote_exit(ssh->frontend);\n\n    if (error_msg)\n\tlogevent(error_msg);\n    if (!ssh->close_expected || !ssh->clean_exit)\n\tconnection_fatal(ssh->frontend, \"%s\", error_msg);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8743, "func": "vcard_response_delete(VCardResponse *response)\n{\n    if (response == NULL) {\n        return;\n    }\n    switch (response->b_type) {\n    case VCARD_MALLOC:\n        g_free(response->b_data);\n        g_free(response);\n        break;\n    case VCARD_MALLOC_DATA:\n        g_free(response->b_data);\n        break;\n    case VCARD_MALLOC_STRUCT:\n        g_free(response);\n        break;\n    case VCARD_STATIC:\n        break;\n    default:\n        g_warn_if_reached();\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9041, "func": "vmxnet3_read_next_rx_descr(VMXNET3State *s, int qidx, int ridx,\n                           struct Vmxnet3_RxDesc *dbuf, uint32_t *didx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    Vmxnet3Ring *ring = &s->rxq_descr[qidx].rx_ring[ridx];\n    *didx = vmxnet3_ring_curr_cell_idx(ring);\n    vmxnet3_ring_read_curr_cell(d, ring, dbuf);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8926, "func": "static void vrend_reset_fences(void)\n{\n   struct vrend_fence *fence, *stor;\n\n   if (vrend_state.sync_thread)\n      pipe_mutex_lock(vrend_state.fence_mutex);\n\n   LIST_FOR_EACH_ENTRY_SAFE(fence, stor, &vrend_state.fence_list, fences) {\n      free_fence_locked(fence);\n   }\n\n   if (vrend_state.sync_thread)\n      pipe_mutex_unlock(vrend_state.fence_mutex);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187968, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    UWORD32     u4_start_code;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;\n\n    ps_stream      = &ps_dec->s_bit_stream;\n\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n            impeg2d_dec_user_data(ps_dec);\n }\n else\n {\n            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\n switch(u4_start_code)\n {\n case SEQ_DISPLAY_EXT_ID:\n                impeg2d_dec_seq_disp_ext(ps_dec);\n break;\n case SEQ_SCALABLE_EXT_ID:\n                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;\n break;\n default:\n                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\n                impeg2d_peek_next_start_code(ps_dec);\n break;\n }\n }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n }\n return e_error;\n}\n", "target": 1, "flaw_line_index": "14"}
{"idx": 9180, "func": "void virtio_cleanup(VirtIODevice *vdev)\n{\n    qemu_del_vm_change_state_handler(vdev->vmstate);\n    g_free(vdev->config);\n    g_free(vdev->vq);\n    g_free(vdev->vector_queues);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188546, "func": "  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187727, "func": "store_image_row(PNG_CONST png_store* ps, png_const_structp pp, int nImage,\n    png_uint_32 y)\n {\n    png_size_t coffset = (nImage * ps->image_h + y) * (ps->cb_row + 5) + 2;\n\n if (ps->image == NULL)\n      png_error(pp, \"no allocated image\");\n\n if (coffset + ps->cb_row + 3 > ps->cb_image)\n      png_error(pp, \"image too small\");\n\n return ps->image + coffset;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188060, "func": "WORD32 ih264d_parse_nal_unit(iv_obj_t *dec_hdl,\n ivd_video_decode_op_t *ps_dec_op,\n                          UWORD8 *pu1_buf,\n                          UWORD32 u4_length)\n{\n\n dec_bit_stream_t *ps_bitstrm;\n\n\n dec_struct_t *ps_dec = (dec_struct_t *)dec_hdl->pv_codec_handle;\n ivd_video_decode_ip_t *ps_dec_in =\n (ivd_video_decode_ip_t *)ps_dec->pv_dec_in;\n dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;\n    UWORD8 u1_first_byte, u1_nal_ref_idc;\n    UWORD8 u1_nal_unit_type;\n    WORD32 i_status = OK;\n    ps_bitstrm = ps_dec->ps_bitstrm;\n\n if(pu1_buf)\n {\n if(u4_length)\n {\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ih264d_process_nal_unit(ps_dec->ps_bitstrm, pu1_buf,\n                                    u4_length);\n\n            SWITCHOFFTRACE;\n            u1_first_byte = ih264d_get_bits_h264(ps_bitstrm, 8);\n\n if(NAL_FORBIDDEN_BIT(u1_first_byte))\n {\n                H264_DEC_DEBUG_PRINT(\"\\nForbidden bit set in Nal Unit, Let's try\\n\");\n }\n            u1_nal_unit_type = NAL_UNIT_TYPE(u1_first_byte);\n if ((ps_dec->u4_slice_start_code_found == 1)\n && (ps_dec->u1_pic_decode_done != 1)\n && (u1_nal_unit_type > IDR_SLICE_NAL))\n {\n return ERROR_INCOMPLETE_FRAME;\n }\n            ps_dec->u1_nal_unit_type = u1_nal_unit_type;\n            u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_first_byte));\n switch(u1_nal_unit_type)\n {\n case SLICE_DATA_PARTITION_A_NAL:\n case SLICE_DATA_PARTITION_B_NAL:\n case SLICE_DATA_PARTITION_C_NAL:\n if(!ps_dec->i4_decode_header)\n                        ih264d_parse_slice_partition(ps_dec, ps_bitstrm);\n\n break;\n\n case IDR_SLICE_NAL:\n case SLICE_NAL:\n\n                    DEBUG_THREADS_PRINTF(\"Decoding  a slice NAL\\n\");\n if(!ps_dec->i4_decode_header)\n {\n if(ps_dec->i4_header_decoded == 3)\n {\n                            ps_dec->u4_slice_start_code_found = 1;\n\n                            ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n\n                            i_status = ih264d_parse_decode_slice(\n (UWORD8)(u1_nal_unit_type\n\n                                                             == IDR_SLICE_NAL),\n                                             u1_nal_ref_idc, ps_dec);\n \n                            if((ps_dec->u4_first_slice_in_pic != 0)&&\n                                ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0))\n                            {\n                                ps_dec->u4_first_slice_in_pic = 1;\n                            }\n                             if(i_status != OK)\n                             {\n                                 return i_status;\n }\n }\n else\n {\n                            H264_DEC_DEBUG_PRINT(\n \"\\nSlice NAL Supplied but no header has been supplied\\n\");\n }\n }\n break;\n\n case SEI_NAL:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                        i_status = ih264d_parse_sei_message(ps_dec, ps_bitstrm);\n if(i_status != OK)\n return i_status;\n                        ih264d_parse_sei(ps_dec, ps_bitstrm);\n }\n break;\n case SEQ_PARAM_NAL:\n                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                    i_status = ih264d_parse_sps(ps_dec, ps_bitstrm);\n if(i_status == ERROR_INV_SPS_PPS_T)\n return i_status;\n if(!i_status)\n                        ps_dec->i4_header_decoded |= 0x1;\n break;\n\n case PIC_PARAM_NAL:\n                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                    i_status = ih264d_parse_pps(ps_dec, ps_bitstrm);\n if(i_status == ERROR_INV_SPS_PPS_T)\n return i_status;\n if(!i_status)\n                        ps_dec->i4_header_decoded |= 0x2;\n break;\n case ACCESS_UNIT_DELIMITER_RBSP:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_access_unit_delimiter_rbsp(ps_dec);\n }\n break;\n case END_OF_STREAM_RBSP:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_parse_end_of_stream(ps_dec);\n }\n break;\n case FILLER_DATA_NAL:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_parse_filler_data(ps_dec, ps_bitstrm);\n }\n break;\n default:\n                    H264_DEC_DEBUG_PRINT(\"\\nUnknown NAL type %d\\n\", u1_nal_unit_type);\n break;\n }\n\n }\n\n }\n\n return i_status;\n\n}\n", "target": 1, "flaw_line_index": "73,74,75,76,77,78"}
{"idx": 188017, "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice(dec_state_t *ps_dec)\n{\n    WORD16 *pi2_vld_out;\n    UWORD32 i;\n yuv_buf_t *ps_cur_frm_buf      = &ps_dec->s_cur_frm_buf;\n\n    UWORD32 u4_frm_offset          = 0;\n const dec_mb_params_t *ps_dec_mb_params;\n    IMPEG2D_ERROR_CODES_T e_error   = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    pi2_vld_out = ps_dec->ai2_vld_buf;\n    memset(ps_dec->ai2_pred_mv,0,sizeof(ps_dec->ai2_pred_mv));\n\n    ps_dec->u2_prev_intra_mb    = 0;\n    ps_dec->u2_first_mb       = 1;\n\n    ps_dec->u2_picture_width = ps_dec->u2_frame_width;\n\n if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n {\n        ps_dec->u2_picture_width <<= 1;\n if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n {\n            u4_frm_offset = ps_dec->u2_frame_width;\n }\n }\n\n do\n {\n        UWORD32 u4_x_offset, u4_y_offset;\n        WORD32 ret;\n\n\n        UWORD32 u4_x_dst_offset = 0;\n        UWORD32 u4_y_dst_offset = 0;\n        UWORD8  *pu1_out_p;\n        UWORD8  *pu1_pred;\n        WORD32 u4_pred_strd;\n\n        IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n\n if(ps_dec->e_pic_type == B_PIC)\n            ret = impeg2d_dec_pnb_mb_params(ps_dec);\n else\n            ret = impeg2d_dec_p_mb_params(ps_dec);\n\n \n         if(ret)\n             return IMPEG2D_MB_TEX_DECODE_ERR;\n         IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n \n         u4_x_dst_offset = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        u4_y_dst_offset = (ps_dec->u2_mb_y << 4) * ps_dec->u2_picture_width;\n        pu1_out_p = ps_cur_frm_buf->pu1_y + u4_x_dst_offset + u4_y_dst_offset;\n if(ps_dec->u2_prev_intra_mb == 0)\n {\n            UWORD32 offset_x, offset_y, stride;\n            UWORD16 index = (ps_dec->u2_motion_type);\n if(ps_dec->e_mb_pred == BIDIRECT)\n {\n                ps_dec_mb_params = &ps_dec->ps_func_bi_direct[index];\n }\n else\n {\n                ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n }\n\n            stride = ps_dec->u2_picture_width;\n\n            offset_x = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n\n            offset_y = (ps_dec->u2_mb_y << 4);\n\n            ps_dec->s_dest_buf.pu1_y = ps_cur_frm_buf->pu1_y + offset_y * stride + offset_x;\n\n            stride = stride >> 1;\n\n            ps_dec->s_dest_buf.pu1_u = ps_cur_frm_buf->pu1_u + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            ps_dec->s_dest_buf.pu1_v = ps_cur_frm_buf->pu1_v + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            PROFILE_DISABLE_MC_IF0\n            ps_dec_mb_params->pf_mc(ps_dec);\n\n }\n for(i = 0; i < NUM_LUMA_BLKS; ++i)\n {\n if((ps_dec->u2_cbp & (1 << (BLOCKS_IN_MB - 1 - i))) != 0)\n {\n                e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                              ps_dec->u2_prev_intra_mb, Y_LUMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n                u4_x_offset = gai2_impeg2_blk_x_off[i];\n\n if(ps_dec->u2_field_dct == 0)\n                    u4_y_offset = gai2_impeg2_blk_y_off_frm[i] ;\n else\n                    u4_y_offset = gai2_impeg2_blk_y_off_fld[i] ;\n\n\n\n\n\n                IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n                PROFILE_DISABLE_IDCT_IF0\n {\n                    WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                        idx = 0;\n else\n                        idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                        pu1_pred = pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset;\n                        u4_pred_strd = ps_dec->u2_picture_width << ps_dec->u2_field_dct;\n }\n else\n {\n                        pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                        u4_pred_strd = 8;\n }\n\n                    ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                            ps_dec->ai2_idct_stg1,\n                                                            pu1_pred,\n                                                            pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset,\n 8,\n                                                            u4_pred_strd,\n                                                            ps_dec->u2_picture_width << ps_dec->u2_field_dct,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n }\n }\n\n }\n\n        u4_x_dst_offset >>= 1;\n        u4_y_dst_offset >>= 2;\n\n\n if((ps_dec->u2_cbp & 0x02) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_u + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, U_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n\n }\n\n\n if((ps_dec->u2_cbp & 0x01) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_v + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, V_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n }\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_first_mb = 0;\n        ps_dec->u2_mb_x++;\n\n if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n {\n return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n }\n else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n }\n }\n while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n return e_error;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188119, "func": " static Maybe<bool> IncludesValueImpl(Isolate* isolate,\n Handle<JSObject> object,\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n    Handle<Map> original_map = handle(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n if (search_for_hole) return Just(true);\n continue;\n }\n\n Handle<Object> element_k =\n Subclass::GetImpl(isolate, *parameter_map, entry);\n\n if (element_k->IsAccessorPair()) {\n LookupIterator it(isolate, object, k, LookupIterator::OWN);\n        DCHECK(it.IsFound());\n        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,\n Object::GetPropertyWithAccessor(&it),\n Nothing<bool>());\n\n if (value->SameValueZero(*element_k)) return Just(true);\n\n if (object->map() != *original_map) {\n return IncludesValueSlowPath(isolate, object, value, k + 1, length);\n }\n } else if (value->SameValueZero(*element_k)) {\n return Just(true);\n }\n }\n return Just(false);\n }\n", "target": 1, "flaw_line_index": "7"}
{"idx": 9017, "func": "vmxnet3_is_registered_vlan(VMXNET3State *s, const void *data)\n{\n    uint16_t vlan_tag = eth_get_pkt_tci(data) & VLAN_VID_MASK;\n    if (IS_SPECIAL_VLAN_ID(vlan_tag)) {\n        return true;\n    }\n\n    return VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, vlan_tag);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188252, "func": "void SoftAMR::onQueueFilled(OMX_U32 \n) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            notifyEmptyBufferDone(inHeader);\n            continue;\n        }\n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n\n             return;\n         }\n \n         if (inHeader->nOffset == 0) {\n             mAnchorTimeUs = inHeader->nTimeStamp;\n             mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n int32_t numBytesRead;\n\n if (mMode == MODE_NARROW) {\n if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            numBytesRead =\n AMRDecode(mState,\n (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; \n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n } else {\n if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n size_t frameSize = getFrameSize(mode);\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n", "target": 1, "flaw_line_index": "15,16,17,18,19,20"}
{"idx": 8592, "func": "static void ssh_socket_log(Plug plug, int type, SockAddr addr, int port,\n                           const char *error_msg, int error_code)\n{\n    Ssh ssh = (Ssh) plug;\n\n\n    if (!ssh->attempting_connshare)\n        backend_socket_log(ssh->frontend, type, addr, port,\n                           error_msg, error_code, ssh->conf,\n                           ssh->session_started);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187504, "func": "static reactor_status_t run_reactor(reactor_t *reactor, int iterations) {\n  assert(reactor != NULL);\n\n  reactor->run_thread = pthread_self();\n  reactor->is_running = true;\n\n struct epoll_event events[MAX_EVENTS];\n for (int i = 0; iterations == 0 || i < iterations; ++i) {\n    pthread_mutex_lock(&reactor->list_lock);\n    list_clear(reactor->invalidation_list);\n    pthread_mutex_unlock(&reactor->list_lock);\n\n \n     int ret;\n     do {\n      ret = epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1);\n     } while (ret == -1 && errno == EINTR);\n \n     if (ret == -1) {\n      LOG_ERROR(\"%s error in epoll_wait: %s\", __func__, strerror(errno));\n      reactor->is_running = false;\n return REACTOR_STATUS_ERROR;\n }\n\n for (int j = 0; j < ret; ++j) {\n if (events[j].data.ptr == NULL) {\n eventfd_t value;\n        eventfd_read(reactor->event_fd, &value);\n        reactor->is_running = false;\n return REACTOR_STATUS_STOP;\n }\n\n reactor_object_t *object = (reactor_object_t *)events[j].data.ptr;\n\n      pthread_mutex_lock(&reactor->list_lock);\n if (list_contains(reactor->invalidation_list, object)) {\n        pthread_mutex_unlock(&reactor->list_lock);\n continue;\n }\n\n      pthread_mutex_lock(&object->lock);\n      pthread_mutex_unlock(&reactor->list_lock);\n\n      reactor->object_removed = false;\n if (events[j].events & (EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR) && object->read_ready)\n        object->read_ready(object->context);\n if (!reactor->object_removed && events[j].events & EPOLLOUT && object->write_ready)\n        object->write_ready(object->context);\n      pthread_mutex_unlock(&object->lock);\n\n if (reactor->object_removed) {\n        pthread_mutex_destroy(&object->lock);\n        osi_free(object);\n }\n }\n }\n\n  reactor->is_running = false;\n return REACTOR_STATUS_DONE;\n}\n", "target": 1, "flaw_line_index": "16"}
{"idx": 8544, "func": "static int ssh2_pkt_getbool(struct Packet *pkt)\n{\n    unsigned long value;\n    if (pkt->length - pkt->savedpos < 1)\n\treturn 0;\t\t       \n    value = pkt->body[pkt->savedpos] != 0;\n    pkt->savedpos++;\n    return value;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8600, "func": "agent_pending_query *agent_query(\n    void *in, int inlen, void **out, int *outlen,\n    void (*callback)(void *, void *, int), void *callback_ctx)\n{\n    HWND hwnd;\n    char *mapname;\n    HANDLE filemap;\n    unsigned char *p, *ret;\n    int id, retlen;\n    COPYDATASTRUCT cds;\n    SECURITY_ATTRIBUTES sa, *psa;\n    PSECURITY_DESCRIPTOR psd = NULL;\n    PSID usersid = NULL;\n\n    *out = NULL;\n    *outlen = 0;\n\n    hwnd = FindWindow(\"Pageant\", \"Pageant\");\n    if (!hwnd)\n\treturn NULL;\t\t       \n    mapname = dupprintf(\"PageantRequest%08x\", (unsigned)GetCurrentThreadId());\n\n    psa = NULL;\n#ifndef NO_SECURITY\n    if (got_advapi()) {\n        usersid = get_user_sid();\n\n        if (usersid) {\n            psd = (PSECURITY_DESCRIPTOR)\n                LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);\n            if (psd) {\n                if (p_InitializeSecurityDescriptor\n                    (psd, SECURITY_DESCRIPTOR_REVISION) &&\n                    p_SetSecurityDescriptorOwner(psd, usersid, FALSE)) {\n                    sa.nLength = sizeof(sa);\n                    sa.bInheritHandle = TRUE;\n                    sa.lpSecurityDescriptor = psd;\n                    psa = &sa;\n                } else {\n                    LocalFree(psd);\n                    psd = NULL;\n                }\n            }\n        }\n    }\n#endif \n\n    filemap = CreateFileMapping(INVALID_HANDLE_VALUE, psa, PAGE_READWRITE,\n\t\t\t\t0, AGENT_MAX_MSGLEN, mapname);\n    if (filemap == NULL || filemap == INVALID_HANDLE_VALUE) {\n        sfree(mapname);\n\treturn NULL;\t\t       \n    }\n    p = MapViewOfFile(filemap, FILE_MAP_WRITE, 0, 0, 0);\n    memcpy(p, in, inlen);\n    cds.dwData = AGENT_COPYDATA_ID;\n    cds.cbData = 1 + strlen(mapname);\n    cds.lpData = mapname;\n\n    id = SendMessage(hwnd, WM_COPYDATA, (WPARAM) NULL, (LPARAM) &cds);\n    if (id > 0) {\n\tretlen = 4 + GET_32BIT(p);\n\tret = snewn(retlen, unsigned char);\n\tif (ret) {\n\t    memcpy(ret, p, retlen);\n\t    *out = ret;\n\t    *outlen = retlen;\n\t}\n    }\n    UnmapViewOfFile(p);\n    CloseHandle(filemap);\n    sfree(mapname);\n    if (psd)\n        LocalFree(psd);\n    return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8374, "func": "static void mptsas_process_message(MPTSASState *s, MPIRequestHeader *req)\n{\n    trace_mptsas_process_message(s, req->Function, req->MsgContext);\n    switch (req->Function) {\n    case MPI_FUNCTION_SCSI_TASK_MGMT:\n        mptsas_process_scsi_task_mgmt(s, (MPIMsgSCSITaskMgmt *)req);\n        break;\n\n    case MPI_FUNCTION_IOC_INIT:\n        mptsas_process_ioc_init(s, (MPIMsgIOCInit *)req);\n        break;\n\n    case MPI_FUNCTION_IOC_FACTS:\n        mptsas_process_ioc_facts(s, (MPIMsgIOCFacts *)req);\n        break;\n\n    case MPI_FUNCTION_PORT_FACTS:\n        mptsas_process_port_facts(s, (MPIMsgPortFacts *)req);\n        break;\n\n    case MPI_FUNCTION_PORT_ENABLE:\n        mptsas_process_port_enable(s, (MPIMsgPortEnable *)req);\n        break;\n\n    case MPI_FUNCTION_EVENT_NOTIFICATION:\n        mptsas_process_event_notification(s, (MPIMsgEventNotify *)req);\n        break;\n\n    case MPI_FUNCTION_CONFIG:\n        mptsas_process_config(s, (MPIMsgConfig *)req);\n        break;\n\n    default:\n        trace_mptsas_unhandled_cmd(s, req->Function, 0);\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_FUNCTION);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8729, "func": "static int check_id(X509_STORE_CTX *ctx)\n{\n    X509_VERIFY_PARAM *vpm = ctx->param;\n    X509_VERIFY_PARAM_ID *id = vpm->id;\n    X509 *x = ctx->cert;\n    if (id->hosts && check_hosts(x, id) <= 0) {\n        if (!check_id_error(ctx, X509_V_ERR_HOSTNAME_MISMATCH))\n            return 0;\n    }\n    if (id->email && X509_check_email(x, id->email, id->emaillen, 0) <= 0) {\n        if (!check_id_error(ctx, X509_V_ERR_EMAIL_MISMATCH))\n            return 0;\n    }\n    if (id->ip && X509_check_ip(x, id->ip, id->iplen, 0) <= 0) {\n        if (!check_id_error(ctx, X509_V_ERR_IP_ADDRESS_MISMATCH))\n            return 0;\n    }\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188091, "func": "sp<VBRISeeker> VBRISeeker::CreateFromSource(\n const sp<DataSource> &source, off64_t post_id3_pos) {\n off64_t pos = post_id3_pos;\n\n uint8_t header[4];\n ssize_t n = source->readAt(pos, header, sizeof(header));\n if (n < (ssize_t)sizeof(header)) {\n return NULL;\n }\n\n uint32_t tmp = U32_AT(&header[0]);\n size_t frameSize;\n int sampleRate;\n if (!GetMPEGAudioFrameSize(tmp, &frameSize, &sampleRate)) {\n return NULL;\n }\n\n    pos += sizeof(header) + 32;\n\n uint8_t vbriHeader[26];\n    n = source->readAt(pos, vbriHeader, sizeof(vbriHeader));\n if (n < (ssize_t)sizeof(vbriHeader)) {\n return NULL;\n }\n\n if (memcmp(vbriHeader, \"VBRI\", 4)) {\n return NULL;\n }\n\n size_t numFrames = U32_AT(&vbriHeader[14]);\n\n int64_t durationUs =\n        numFrames * 1000000ll * (sampleRate >= 32000 ? 1152 : 576) / sampleRate;\n\n    ALOGV(\"duration = %.2f secs\", durationUs / 1E6);\n\n size_t numEntries = U16_AT(&vbriHeader[18]);\n size_t entrySize = U16_AT(&vbriHeader[22]);\n size_t scale = U16_AT(&vbriHeader[20]);\n\n    ALOGV(\"%zu entries, scale=%zu, size_per_entry=%zu\",\n         numEntries,\n\n          scale,\n          entrySize);\n \n     size_t totalEntrySize = numEntries * entrySize;\n    uint8_t *buffer = new uint8_t[totalEntrySize];\n \n     n = source->readAt(pos + sizeof(vbriHeader), buffer, totalEntrySize);\n     if (n < (ssize_t)totalEntrySize) {\n delete[] buffer;\n        buffer = NULL;\n\n\n         return NULL;\n     }\n \n    sp<VBRISeeker> seeker = new VBRISeeker;\n     seeker->mBasePos = post_id3_pos + frameSize;\n if (durationUs) {\n        seeker->mDurationUs = durationUs;\n }\n\n off64_t offset = post_id3_pos;\n for (size_t i = 0; i < numEntries; ++i) {\n uint32_t numBytes;\n switch (entrySize) {\n case 1: numBytes = buffer[i]; break;\n case 2: numBytes = U16_AT(buffer + 2 * i); break;\n case 3: numBytes = U24_AT(buffer + 3 * i); break;\n default:\n {\n                CHECK_EQ(entrySize, 4u);\n                numBytes = U32_AT(buffer + 4 * i); break;\n }\n }\n\n        numBytes *= scale;\n\n        seeker->mSegments.push(numBytes);\n\n        ALOGV(\"entry #%zu: %u offset %#016llx\", i, numBytes, (long long)offset);\n        offset += numBytes;\n }\n\n delete[] buffer;\n    buffer = NULL;\n\n    ALOGI(\"Found VBRI header.\");\n\n return seeker;\n}\n", "target": 1, "flaw_line_index": "49,60"}
{"idx": 187419, "func": "int validate_camera_metadata_structure(const camera_metadata_t *metadata,\n const size_t *expected_size) {\n\n if (metadata == NULL) {\n        ALOGE(\"%s: metadata is null!\", __FUNCTION__);\n return ERROR;\n }\n\n {\n static const struct {\n const char *name;\n size_t alignment;\n } alignments[] = {\n {\n .name = \"camera_metadata\",\n .alignment = METADATA_ALIGNMENT\n },\n {\n .name = \"camera_metadata_buffer_entry\",\n .alignment = ENTRY_ALIGNMENT\n },\n {\n .name = \"camera_metadata_data\",\n .alignment = DATA_ALIGNMENT\n },\n };\n\n for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {\n uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);\n\n if ((uintptr_t)metadata != aligned_ptr) {\n                ALOGE(\"%s: Metadata pointer is not aligned (actual %p, \"\n \"expected %p) to type %s\",\n                      __FUNCTION__, metadata,\n (void*)aligned_ptr, alignments[i].name);\n return ERROR;\n }\n }\n }\n\n\n if (expected_size != NULL && metadata->size > *expected_size) {\n        ALOGE(\"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\",\n              __FUNCTION__, metadata->size, *expected_size);\n return ERROR;\n }\n\n if (metadata->entry_count > metadata->entry_capacity) {\n        ALOGE(\"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \"\n \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->entry_count, metadata->entry_capacity);\n\n         return ERROR;\n     }\n \n    const metadata_uptrdiff_t entries_end =\n        metadata->entries_start + metadata->entry_capacity;\n     if (entries_end < metadata->entries_start || \n         entries_end > metadata->data_start) {\n \n        ALOGE(\"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->entries_start + metadata->entry_capacity),\n              metadata->data_start);\n return ERROR;\n }\n\n const metadata_uptrdiff_t data_end =\n        metadata->data_start + metadata->data_capacity;\n if (data_end < metadata->data_start || \n        data_end > metadata->size) {\n\n        ALOGE(\"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->data_start + metadata->data_capacity),\n              metadata->size);\n return ERROR;\n }\n\n const metadata_size_t entry_count = metadata->entry_count;\n camera_metadata_buffer_entry_t *entries = get_entries(metadata);\n\n for (size_t i = 0; i < entry_count; ++i) {\n\n if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {\n            ALOGE(\"%s: Entry index %zu had bad alignment (address %p),\"\n \" expected alignment %zu\",\n                  __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);\n return ERROR;\n }\n\n camera_metadata_buffer_entry_t entry = entries[i];\n\n if (entry.type >= NUM_TYPES) {\n            ALOGE(\"%s: Entry index %zu had a bad type %d\",\n                  __FUNCTION__, i, entry.type);\n return ERROR;\n }\n\n uint32_t tag_section = entry.tag >> 16;\n int tag_type = get_camera_metadata_tag_type(entry.tag);\n if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {\n            ALOGE(\"%s: Entry index %zu had tag type %d, but the type was %d\",\n                  __FUNCTION__, i, tag_type, entry.type);\n return ERROR;\n }\n\n size_t data_size;\n if (validate_and_calculate_camera_metadata_entry_data_size(&data_size, entry.type,\n                entry.count) != OK) {\n            ALOGE(\"%s: Entry data size is invalid. type: %u count: %u\", __FUNCTION__, entry.type,\n                    entry.count);\n return ERROR;\n }\n\n if (data_size != 0) {\n camera_metadata_data_t *data =\n (camera_metadata_data_t*) (get_data(metadata) +\n                                               entry.data.offset);\n\n if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {\n                ALOGE(\"%s: Entry index %zu had bad data alignment (address %p),\"\n \" expected align %zu, (tag name %s, data size %zu)\",\n                      __FUNCTION__, i, data, DATA_ALIGNMENT,\n                      get_camera_metadata_tag_name(entry.tag) ?: \"unknown\",\n                      data_size);\n return ERROR;\n }\n\n size_t data_entry_end = entry.data.offset + data_size;\n if (data_entry_end < entry.data.offset || \n                data_entry_end > metadata->data_capacity) {\n\n                ALOGE(\"%s: Entry index %zu data ends (%zu) beyond the capacity \"\n \"%\" PRIu32, __FUNCTION__, i, data_entry_end,\n                      metadata->data_capacity);\n return ERROR;\n }\n\n } else if (entry.count == 0) {\n if (entry.data.offset != 0) {\n                ALOGE(\"%s: Entry index %zu had 0 items, but offset was non-0 \"\n \"(%\" PRIu32 \"), tag name: %s\", __FUNCTION__, i, entry.data.offset,\n                        get_camera_metadata_tag_name(entry.tag) ?: \"unknown\");\n return ERROR;\n }\n } \n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "57,58"}
{"idx": 187498, "func": "static uint16_t transmit_data(serial_data_type_t type, uint8_t *data, uint16_t length) {\n  assert(data != NULL);\n  assert(length > 0);\n\n if (type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO) {\n    LOG_ERROR(\"%s invalid data type: %d\", __func__, type);\n return 0;\n }\n\n --data;\n uint8_t previous_byte = *data;\n *(data) = type;\n ++length;\n\n \n   uint16_t transmitted_length = 0;\n   while (length > 0) {\n    ssize_t ret = write(uart_fd, data + transmitted_length, length);\n     switch (ret) {\n       case -1:\n         LOG_ERROR(\"In %s, error writing to the uart serial port: %s\", __func__, strerror(errno));\n goto done;\n case 0:\n goto done;\n default:\n        transmitted_length += ret;\n        length -= ret;\n break;\n }\n }\n\ndone:;\n *(data) = previous_byte;\n\n if (transmitted_length > 0)\n --transmitted_length;\n\n return transmitted_length;\n}\n", "target": 1, "flaw_line_index": "19"}
{"idx": 8942, "func": "void vrend_set_single_vbo(struct vrend_context *ctx,\n                          int index,\n                          uint32_t stride,\n                          uint32_t buffer_offset,\n                          uint32_t res_handle)\n{\n   struct vrend_resource *res;\n\n   if (ctx->sub->vbo[index].stride != stride ||\n       ctx->sub->vbo[index].buffer_offset != buffer_offset ||\n       ctx->sub->vbo_res_ids[index] != res_handle)\n      ctx->sub->vbo_dirty = true;\n\n   ctx->sub->vbo[index].stride = stride;\n   ctx->sub->vbo[index].buffer_offset = buffer_offset;\n\n   if (res_handle == 0) {\n      vrend_resource_reference((struct vrend_resource **)&ctx->sub->vbo[index].buffer, NULL);\n      ctx->sub->vbo_res_ids[index] = 0;\n   } else if (ctx->sub->vbo_res_ids[index] != res_handle) {\n      res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n      if (!res) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n         ctx->sub->vbo_res_ids[index] = 0;\n         return;\n      }\n      vrend_resource_reference((struct vrend_resource **)&ctx->sub->vbo[index].buffer, res);\n      ctx->sub->vbo_res_ids[index] = res_handle;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8929, "func": "vrend_sampler_view_reference(struct vrend_sampler_view **ptr, struct vrend_sampler_view *view)\n{\n   struct vrend_sampler_view *old_view = *ptr;\n\n   if (pipe_reference(&(*ptr)->reference, &view->reference))\n      vrend_destroy_sampler_view(old_view);\n   *ptr = view;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187517, "func": "static int accept_server_socket(int sfd)\n{\n struct sockaddr_un remote;\n struct pollfd pfd;\n int fd;\n socklen_t len = sizeof(struct sockaddr_un);\n\n    BTIF_TRACE_EVENT(\"accept fd %d\", sfd);\n\n\n     pfd.fd = sfd;\n     pfd.events = POLLIN;\n \n    if (poll(&pfd, 1, 0) == 0)\n     {\n         BTIF_TRACE_EVENT(\"accept poll timeout\");\n         return -1;\n }\n\n \n \n    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)\n     {\n          BTIF_TRACE_ERROR(\"sock accept failed (%s)\", strerror(errno));\n          return -1;\n }\n\n\n return fd;\n}\n", "target": 1, "flaw_line_index": "14,23"}
{"idx": 188088, "func": "int vp8dx_receive_compressed_data(VP8D_COMP *pbi, size_t size,\n const uint8_t *source,\n int64_t time_stamp)\n{\n    VP8_COMMON *cm = &pbi->common;\n int retcode = -1;\n (void)size;\n (void)source;\n\n    pbi->common.error.error_code = VPX_CODEC_OK;\n\n    retcode = check_fragments_for_errors(pbi);\n if(retcode <= 0)\n return retcode;\n\n    cm->new_fb_idx = get_free_fb (cm);\n\n    pbi->dec_fb_ref[INTRA_FRAME] = &cm->yv12_fb[cm->new_fb_idx];\n    pbi->dec_fb_ref[LAST_FRAME] = &cm->yv12_fb[cm->lst_fb_idx];\n    pbi->dec_fb_ref[GOLDEN_FRAME] = &cm->yv12_fb[cm->gld_fb_idx];\n    pbi->dec_fb_ref[ALTREF_FRAME] = &cm->yv12_fb[cm->alt_fb_idx];\n\n if (setjmp(pbi->common.error.jmp))\n {\n        cm->yv12_fb[cm->lst_fb_idx].corrupted = 1;\n\n \n         if (cm->fb_idx_ref_cnt[cm->new_fb_idx] > 0)\n           cm->fb_idx_ref_cnt[cm->new_fb_idx]--;\n         goto decode_exit;\n     }\n \n    pbi->common.error.setjmp = 1;\n\n    retcode = vp8_decode_frame(pbi);\n\n if (retcode < 0)\n {\n if (cm->fb_idx_ref_cnt[cm->new_fb_idx] > 0)\n          cm->fb_idx_ref_cnt[cm->new_fb_idx]--;\n\n        pbi->common.error.error_code = VPX_CODEC_ERROR;\n goto decode_exit;\n }\n\n if (swap_frame_buffers (cm))\n {\n        pbi->common.error.error_code = VPX_CODEC_ERROR;\n goto decode_exit;\n }\n\n    vp8_clear_system_state();\n\n if (cm->show_frame)\n {\n        cm->current_video_frame++;\n        cm->show_frame_mi = cm->mi;\n }\n\n #if CONFIG_ERROR_CONCEALMENT\n if (pbi->ec_enabled && pbi->common.prev_mi)\n {\n        MODE_INFO* tmp = pbi->common.prev_mi;\n int row, col;\n        pbi->common.prev_mi = pbi->common.mi;\n        pbi->common.mi = tmp;\n\n for (row = 0; row < pbi->common.mb_rows; ++row)\n {\n for (col = 0; col < pbi->common.mb_cols; ++col)\n {\n const int i = row*pbi->common.mode_info_stride + col;\n                pbi->common.mi[i].mbmi.segment_id =\n                        pbi->common.prev_mi[i].mbmi.segment_id;\n }\n }\n }\n#endif\n\n    pbi->ready_for_new_data = 0;\n    pbi->last_time_stamp = time_stamp;\n\ndecode_exit:\n    pbi->common.error.setjmp = 0;\n    vp8_clear_system_state();\n return retcode;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187549, "func": " status_t OMXNodeInstance::fillBuffer(OMX::buffer_id buffer, int fenceFd) {\n     Mutex::Autolock autoLock(mLock);\n \n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     header->nFilledLen = 0;\n     header->nOffset = 0;\n     header->nFlags = 0;\n\n status_t res = storeFenceInMeta_l(header, fenceFd, kPortIndexOutput);\n if (res != OK) {\n        CLOG_ERROR(fillBuffer::storeFenceInMeta, res, EMPTY_BUFFER(buffer, header, fenceFd));\n return res;\n }\n\n {\n Mutex::Autolock _l(mDebugLock);\n        mOutputBuffersWithCodec.add(header);\n        CLOG_BUMPED_BUFFER(fillBuffer, WITH_STATS(EMPTY_BUFFER(buffer, header, fenceFd)));\n }\n\n    OMX_ERRORTYPE err = OMX_FillThisBuffer(mHandle, header);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(fillBuffer, err, EMPTY_BUFFER(buffer, header, fenceFd));\n Mutex::Autolock _l(mDebugLock);\n        mOutputBuffersWithCodec.remove(header);\n }\n return StatusFromOMXError(err);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187574, "func": " static int remove_bond(const bt_bdaddr_t *bd_addr)\n {\n     if (interface_ready() == FALSE)\n         return BT_STATUS_NOT_READY;\n\n return btif_dm_remove_bond(bd_addr);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187617, "func": "main(int argc, char **argv)\n{\n   png_uint_32 opts = FAST_WRITE;\n   format_list formats;\n const char *touch = NULL;\n int log_pass = 0;\n int redundant = 0;\n int stride_extra = 0;\n int retval = 0;\n int c;\n\n   init_sRGB_to_d();\n#if 0\n   init_error_via_linear();\n#endif\n   format_init(&formats);\n\n for (c=1; c<argc; ++c)\n {\n const char *arg = argv[c];\n\n if (strcmp(arg, \"--log\") == 0)\n         log_pass = 1;\n else if (strcmp(arg, \"--fresh\") == 0)\n {\n         memset(gpc_error, 0, sizeof gpc_error);\n         memset(gpc_error_via_linear, 0, sizeof gpc_error_via_linear);\n }\n else if (strcmp(arg, \"--file\") == 0)\n#        ifdef PNG_STDIO_SUPPORTED\n            opts |= READ_FILE;\n#        else\n return 77; \n#        endif\n else if (strcmp(arg, \"--memory\") == 0)\n         opts &= ~READ_FILE;\n else if (strcmp(arg, \"--stdio\") == 0)\n#        ifdef PNG_STDIO_SUPPORTED\n            opts |= USE_STDIO;\n#        else\n return 77; \n#        endif\n else if (strcmp(arg, \"--name\") == 0)\n         opts &= ~USE_STDIO;\n else if (strcmp(arg, \"--verbose\") == 0)\n         opts |= VERBOSE;\n else if (strcmp(arg, \"--quiet\") == 0)\n         opts &= ~VERBOSE;\n else if (strcmp(arg, \"--preserve\") == 0)\n         opts |= KEEP_TMPFILES;\n else if (strcmp(arg, \"--nopreserve\") == 0)\n         opts &= ~KEEP_TMPFILES;\n else if (strcmp(arg, \"--keep-going\") == 0)\n         opts |= KEEP_GOING;\n else if (strcmp(arg, \"--fast\") == 0)\n         opts |= FAST_WRITE;\n else if (strcmp(arg, \"--slow\") == 0)\n         opts &= ~FAST_WRITE;\n else if (strcmp(arg, \"--accumulate\") == 0)\n         opts |= ACCUMULATE;\n else if (strcmp(arg, \"--redundant\") == 0)\n         redundant = 1;\n else if (strcmp(arg, \"--stop\") == 0)\n         opts &= ~KEEP_GOING;\n else if (strcmp(arg, \"--strict\") == 0)\n         opts |= STRICT;\n else if (strcmp(arg, \"--sRGB-16bit\") == 0)\n         opts |= sRGB_16BIT;\n else if (strcmp(arg, \"--linear-16bit\") == 0)\n         opts &= ~sRGB_16BIT;\n else if (strcmp(arg, \"--tmpfile\") == 0)\n {\n if (c+1 < argc)\n {\n if (strlen(argv[++c]) >= sizeof tmpf)\n {\n               fflush(stdout);\n               fprintf(stderr, \"%s: %s is too long for a temp file prefix\\n\",\n                  argv[0], argv[c]);\n               exit(99);\n\n             }\n \n            strcpy(tmpf, argv[c]);\n          }\n \n          else\n {\n            fflush(stdout);\n            fprintf(stderr, \"%s: %s requires a temporary file prefix\\n\",\n               argv[0], arg);\n            exit(99);\n }\n }\n else if (strcmp(arg, \"--touch\") == 0)\n {\n if (c+1 < argc)\n            touch = argv[++c];\n\n else\n {\n            fflush(stdout);\n            fprintf(stderr, \"%s: %s requires a file name argument\\n\",\n               argv[0], arg);\n            exit(99);\n }\n }\n else if (arg[0] == '+')\n {\n         png_uint_32 format = formatof(arg+1);\n\n if (format > FORMAT_COUNT)\n            exit(99);\n\n         format_set(&formats, format);\n }\n else if (arg[0] == '-' && arg[1] != 0 && (arg[1] != '0' || arg[2] != 0))\n {\n         fflush(stdout);\n         fprintf(stderr, \"%s: unknown option: %s\\n\", argv[0], arg);\n         exit(99);\n }\n else\n {\n if (format_is_initial(&formats))\n            format_default(&formats, redundant);\n\n if (arg[0] == '-')\n {\n const int term = (arg[1] == '0' ? 0 : '\\n');\n unsigned int ich = 0;\n\n static char buffer[4096];\n\n do\n {\n int ch = getchar();\n\n if (ch == EOF || ch == term || ch == 0)\n {\n                  buffer[ich] = 0;\n\n if (ich > 0 && !test_one_file(buffer, &formats, opts,\n                     stride_extra, log_pass))\n                     retval = 1;\n\n if (ch == EOF)\n break;\n\n                  ich = 0;\n --ich; \n }\n\n else\n                  buffer[ich] = (char)ch;\n } while (++ich < sizeof buffer);\n\n if (ich)\n {\n               buffer[32] = 0;\n               buffer[4095] = 0;\n               fprintf(stderr, \"%s...%s: file name too long\\n\", buffer,\n                  buffer+(4096-32));\n               exit(99);\n }\n }\n\n else if (!test_one_file(arg, &formats, opts, stride_extra, log_pass))\n            retval = 1;\n }\n }\n\n if (opts & ACCUMULATE)\n\n    {\n       unsigned int in;\n \n       printf(\"static png_uint_16 gpc_error[16\n] =\\n\");\n       printf(\"{\\n\");\n       for (in=0; in<16; ++in)\n {\n unsigned int out;\n         printf(\" { \n\\n \", format_names[in]);\n for (out=0; out<16; ++out)\n {\n unsigned int alpha;\n            printf(\" {\");\n for (alpha=0; alpha<4; ++alpha)\n {\n               printf(\" %d\", gpc_error[in][out][alpha]);\n if (alpha < 3) putchar(',');\n }\n            printf(\" }\");\n if (out < 15)\n {\n               putchar(',');\n if (out % 4 == 3) printf(\"\\n \");\n }\n }\n         printf(\"\\n }\");\n\n if (in < 15)\n            putchar(',');\n else\n            putchar('\\n');\n }\n      printf(\"};\\n\");\n\n      printf(\"static png_uint_16 gpc_error_via_linear[16][4\n][4] =\\n\");\n      printf(\"{\\n\");\n for (in=0; in<16; ++in)\n {\n unsigned int out;\n         printf(\" { \n\\n \", format_names[in]);\n for (out=0; out<4; ++out)\n {\n unsigned int alpha;\n            printf(\" {\");\n for (alpha=0; alpha<4; ++alpha)\n {\n               printf(\" %d\", gpc_error_via_linear[in][out][alpha]);\n if (alpha < 3) putchar(',');\n }\n            printf(\" }\");\n if (out < 3)\n               putchar(',');\n }\n         printf(\"\\n }\");\n\n if (in < 15)\n            putchar(',');\n else\n            putchar('\\n');\n }\n      printf(\"};\\n\");\n\n      printf(\"static png_uint_16 gpc_error_to_colormap[8\n][4] =\\n\");\n      printf(\"{\\n\");\n for (in=0; in<8; ++in)\n {\n unsigned int out;\n         printf(\" { \n\\n \", format_names[in]);\n for (out=0; out<8; ++out)\n {\n unsigned int alpha;\n            printf(\" {\");\n for (alpha=0; alpha<4; ++alpha)\n {\n               printf(\" %d\", gpc_error_to_colormap[in][out][alpha]);\n if (alpha < 3) putchar(',');\n }\n            printf(\" }\");\n if (out < 7)\n {\n               putchar(',');\n if (out % 4 == 3) printf(\"\\n \");\n }\n }\n         printf(\"\\n }\");\n\n if (in < 7)\n            putchar(',');\n else\n\n             putchar('\\n');\n       }\n       printf(\"};\\n\");\n    }\n \n    if (retval == 0 && touch != NULL)\n {\n FILE *fsuccess = fopen(touch, \"wt\");\n\n if (fsuccess != NULL)\n {\n int error = 0;\n         fprintf(fsuccess, \"PNG simple API tests succeeded\\n\");\n         fflush(fsuccess);\n         error = ferror(fsuccess);\n\n if (fclose(fsuccess) || error)\n {\n            fflush(stdout);\n            fprintf(stderr, \"%s: write failed\\n\", touch);\n            exit(99);\n }\n }\n\n else\n {\n         fflush(stdout);\n         fprintf(stderr, \"%s: open failed\\n\", touch);\n         exit(99);\n }\n }\n\n return retval;\n}\n", "target": 1, "flaw_line_index": "84"}
{"idx": 9227, "func": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_vq(vq);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187922, "func": "valid_length(uint8_t option, int dl, int *type)\n{\n const struct dhcp_opt *opt;\n ssize_t sz;\n\n if (dl == 0)\n return -1;\n\n for (opt = dhcp_opts; opt->option; opt++) {\n if (opt->option != option)\n continue;\n\n \n \t\tif (type)\n \t\t\t*type = opt->type;\n \t\tif (opt->type == 0 ||\n \t\t    opt->type & (STRING | RFC3442 | RFC5969))\n \t\t\treturn 0;\n \t\tsz = 0;\n\t\tif (opt->type & (UINT32 | IPV4))\n \t\t\tsz = sizeof(uint32_t);\n\t\tif (opt->type & UINT16)\n \t\t\tsz = sizeof(uint16_t);\n\t\tif (opt->type & UINT8)\n \t\t\tsz = sizeof(uint8_t);\n\t\tif (opt->type & (IPV4 | ARRAY))\n\t\t\treturn dl % sz;\n\t\treturn (dl == sz ? 0 : -1);\n \t}\n \n return 0;\n}\n", "target": 1, "flaw_line_index": "20,22,24,26,27,28"}
{"idx": 8717, "func": "static bool name_is_illegal(const char *name)\n{\n    return !*name || strchr(name, '/') != NULL;\n     return !*name || strchr(name, '/') != NULL;\n }\n", "target": 0, "flaw_line_index": ""}
{"idx": 188563, "func": " static bool compare_img(const vpx_image_t *img1,\n                         const vpx_image_t *img2) {\n   bool match = (img1->fmt == img2->fmt) &&\n                (img1->d_w == img2->d_w) &&\n                (img1->d_h == img2->d_h);\n \n const unsigned int width_y  = img1->d_w;\n const unsigned int height_y = img1->d_h;\n unsigned int i;\n for (i = 0; i < height_y; ++i)\n    match = (memcmp(img1->planes[VPX_PLANE_Y] + i * img1->stride[VPX_PLANE_Y],\n                    img2->planes[VPX_PLANE_Y] + i * img2->stride[VPX_PLANE_Y],\n                    width_y) == 0) && match;\n const unsigned int width_uv  = (img1->d_w + 1) >> 1;\n const unsigned int height_uv = (img1->d_h + 1) >> 1;\n for (i = 0; i <  height_uv; ++i)\n    match = (memcmp(img1->planes[VPX_PLANE_U] + i * img1->stride[VPX_PLANE_U],\n                    img2->planes[VPX_PLANE_U] + i * img2->stride[VPX_PLANE_U],\n                    width_uv) == 0) && match;\n for (i = 0; i < height_uv; ++i)\n    match = (memcmp(img1->planes[VPX_PLANE_V] + i * img1->stride[VPX_PLANE_V],\n                    img2->planes[VPX_PLANE_V] + i * img2->stride[VPX_PLANE_V],\n                    width_uv) == 0) && match;\n\n   return match;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187792, "func": "AudioSource::AudioSource(\n audio_source_t inputSource, const String16 &opPackageName,\n uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)\n\n     : mStarted(false),\n       mSampleRate(sampleRate),\n       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),\n       mPrevSampleTimeUs(0),\n       mFirstSampleTimeUs(-1ll),\n       mNumFramesReceived(0),\n       mNumClientOwnedBuffers(0) {\n     ALOGV(\"sampleRate: %u, outSampleRate: %u, channelCount: %u\",\n            sampleRate, outSampleRate, channelCount);\n    CHECK(channelCount == 1 || channelCount == 2);\n    CHECK(sampleRate > 0);\n\n size_t minFrameCount;\n status_t status = AudioRecord::getMinFrameCount(&minFrameCount,\n                                           sampleRate,\n                                           AUDIO_FORMAT_PCM_16_BIT,\n                                           audio_channel_in_mask_from_count(channelCount));\n if (status == OK) {\n uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;\n\n size_t bufCount = 2;\n while ((bufCount * frameCount) < minFrameCount) {\n            bufCount++;\n }\n\n        mRecord = new AudioRecord(\n                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,\n                    audio_channel_in_mask_from_count(channelCount),\n                    opPackageName,\n (size_t) (bufCount * frameCount),\n AudioRecordCallbackFunction,\n this,\n                    frameCount \n);\n        mInitCheck = mRecord->initCheck();\n if (mInitCheck != OK) {\n            mRecord.clear();\n }\n } else {\n        mInitCheck = status;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188221, "func": "OMX_ERRORTYPE SoftAVCEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n int32_t indexFull = index;\n\n switch (indexFull) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *) params;\n \n             if (bitRate->nPortIndex != 1 ||\n                 bitRate->eControlRate != OMX_Video_ControlRateVariable) {\n                 return OMX_ErrorUndefined;\n }\n\n            mBitrate = bitRate->nTargetBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoAvc:\n {\n\n             OMX_VIDEO_PARAM_AVCTYPE *avcType =\n                 (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcType->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (avcType->eProfile != OMX_VIDEO_AVCProfileBaseline ||\n                avcType->nRefFrames != 1 ||\n                avcType->nBFrames != 0 ||\n                avcType->bUseHadamard != OMX_TRUE ||\n (avcType->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) != 0 ||\n                avcType->nRefIdx10ActiveMinus1 != 0 ||\n                avcType->nRefIdx11ActiveMinus1 != 0 ||\n                avcType->bWeightedPPrediction != OMX_FALSE ||\n                avcType->bEntropyCodingCABAC != OMX_FALSE ||\n                avcType->bconstIpred != OMX_FALSE ||\n                avcType->bDirect8x8Inference != OMX_FALSE ||\n                avcType->bDirectSpatialTemporal != OMX_FALSE ||\n                avcType->nCabacInitIdc != 0) {\n return OMX_ErrorUndefined;\n }\n\n if (OK != ConvertOmxAvcLevelToAvcSpecLevel(avcType->eLevel, &mAVCEncLevel)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8694, "func": "scheme_default_port (enum url_scheme scheme)\n{\n  return supported_schemes[scheme].default_port;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187351, "func": "xsltNumber(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t   xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemNumberPtr comp = (xsltStyleItemNumberPtr) castedComp;\n #else\n     xsltStylePreCompPtr comp = castedComp;\n #endif\n     if (comp == NULL) {\n \txsltTransformError(ctxt, NULL, inst,\n \t     \"xsl:number : compilation failed\\n\");\n\treturn;\n    }\n\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n\treturn;\n\n     comp->numdata.doc = inst->doc;\n     comp->numdata.node = inst;\n \n     xsltNumberFormat(ctxt, &comp->numdata, node);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187378, "func": "static EAS_RESULT Parse_wave (SDLS_SYNTHESIZER_DATA *pDLSData, EAS_I32 pos, EAS_U16 waveIndex)\n{\n    EAS_RESULT result;\n    EAS_U32 temp;\n    EAS_I32 size;\n    EAS_I32 endChunk;\n    EAS_I32 chunkPos;\n    EAS_I32 wsmpPos = 0;\n    EAS_I32 fmtPos = 0;\n    EAS_I32 dataPos = 0;\n    EAS_I32 dataSize = 0;\n    S_WSMP_DATA *p;\n void *pSample;\n    S_WSMP_DATA wsmp;\n\n    chunkPos = pos + 12;\n if ((result = EAS_HWFileSeek(pDLSData->hwInstData, pDLSData->fileHandle, pos)) != EAS_SUCCESS)\n return result;\n\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n if (temp != CHUNK_WAVE)\n {\n { \n }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n    pos = chunkPos;\n    endChunk = pos + size;\n while (pos < endChunk)\n {\n        chunkPos = pos;\n\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n switch (temp)\n {\n case CHUNK_WSMP:\n                wsmpPos = chunkPos + 8;\n break;\n\n case CHUNK_FMT:\n                fmtPos = chunkPos + 8;\n break;\n\n case CHUNK_DATA:\n                dataPos = chunkPos + 8;\n                dataSize = size;\n break;\n\n default:\n break;\n }\n\n     }\n \n    if (dataSize > MAX_DLS_WAVE_SIZE)\n     {\n         return EAS_ERROR_SOUND_LIBRARY;\n     }\n\n if (pDLSData->pDLS == NULL)\n        p = &wsmp;\n else\n        p = &pDLSData->wsmpData[waveIndex];\n\n    p->fineTune = 0;\n    p->unityNote = 60;\n    p->gain = 0;\n    p->loopStart = 0;\n    p->loopLength = 0;\n\n if (!fmtPos)\n {\n { \n }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n if (!dataPos)\n {\n { \n }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n if (wsmpPos)\n {\n if ((result = Parse_wsmp(pDLSData, wsmpPos, p)) != EAS_SUCCESS)\n return result;\n }\n\n if ((result = Parse_fmt(pDLSData, fmtPos, p)) != EAS_SUCCESS)\n return result;\n\n\n if (bitDepth == 8)\n {\n if (p->bitsPerSample == 8)\n            size = dataSize;\n else\n            size = dataSize >> 1;\n if (p->loopLength)\n            size++;\n }\n\n else\n {\n if (p->bitsPerSample == 16)\n            size = dataSize;\n else\n            size = dataSize << 1;\n if (p->loopLength)\n            size += 2;\n }\n\n if (pDLSData->pDLS == NULL)\n {\n        pDLSData->wavePoolSize += (EAS_U32) size;\n return EAS_SUCCESS;\n }\n\n    pSample = pDLSData->pDLS->pDLSSamples + pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleOffsets[waveIndex] = pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleLen[waveIndex] = (EAS_U32) size;\n    pDLSData->wavePoolOffset += (EAS_U32) size;\n if (pDLSData->wavePoolOffset > pDLSData->wavePoolSize)\n {\n { \n }\n return EAS_ERROR_SOUND_LIBRARY;\n }\n\n if ((result = Parse_data(pDLSData, dataPos, dataSize, p, pSample)) != EAS_SUCCESS)\n return result;\n\n return EAS_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "61"}
{"idx": 187620, "func": "check(FILE *fp, int argc, const char **argv, png_uint_32p flags\n,\n   display *d, int set_callback)\n{\n int i, npasses, ipass;\n   png_uint_32 height;\n\n   d->keep = PNG_HANDLE_CHUNK_AS_DEFAULT;\n   d->before_IDAT = 0;\n   d->after_IDAT = 0;\n\n   d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error,\n      warning);\n if (d->png_ptr == NULL)\n {\n      fprintf(stderr, \"%s(%s): could not allocate png struct\\n\", d->file,\n         d->test);\n      exit(1);\n }\n\n   d->info_ptr = png_create_info_struct(d->png_ptr);\n   d->end_ptr = png_create_info_struct(d->png_ptr);\n if (d->info_ptr == NULL || d->end_ptr == NULL)\n {\n      fprintf(stderr, \"%s(%s): could not allocate png info\\n\", d->file,\n         d->test);\n      clean_display(d);\n      exit(1);\n }\n\n   png_init_io(d->png_ptr, fp);\n\n#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n if (set_callback)\n         png_set_read_user_chunk_fn(d->png_ptr, d, read_callback);\n#  else\n      UNUSED(set_callback)\n#  endif\n\n for (i=0; i<argc; ++i)\n {\n const char *equals = strchr(argv[i], '=');\n\n if (equals != NULL)\n {\n int chunk, option;\n\n if (strcmp(equals+1, \"default\") == 0)\n            option = PNG_HANDLE_CHUNK_AS_DEFAULT;\n else if (strcmp(equals+1, \"discard\") == 0)\n            option = PNG_HANDLE_CHUNK_NEVER;\n else if (strcmp(equals+1, \"if-safe\") == 0)\n            option = PNG_HANDLE_CHUNK_IF_SAFE;\n else if (strcmp(equals+1, \"save\") == 0)\n            option = PNG_HANDLE_CHUNK_ALWAYS;\n else\n {\n            fprintf(stderr, \"%s(%s): %s: unrecognized chunk option\\n\", d->file,\n               d->test, argv[i]);\n            display_exit(d);\n }\n\n switch (equals - argv[i])\n {\n case 4: \n               chunk = find(argv[i]);\n\n if (chunk >= 0)\n {\n                  png_byte name[5];\n \n                  memcpy(name, chunk_info[chunk].name, 5);\n                  png_set_keep_unknown_chunks(d->png_ptr, option, name, 1);\n                  chunk_info[chunk].keep = option;\n                   continue;\n                }\n \n break;\n\n\n             case 7: \n                if (memcmp(argv[i], \"default\", 7) == 0)\n                {\n                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, 0);\n                   d->keep = option;\n                   continue;\n                }\n\n break;\n\n\n             case 3: \n                if (memcmp(argv[i], \"all\", 3) == 0)\n                {\n                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, -1);\n                   d->keep = option;\n \n                   for (chunk = 0; chunk < NINFO; ++chunk)\n if (chunk_info[chunk].all)\n                        chunk_info[chunk].keep = option;\n continue;\n }\n\n break;\n\n default: \n\n break;\n }\n }\n\n      fprintf(stderr, \"%s(%s): %s: unrecognized chunk argument\\n\", d->file,\n         d->test, argv[i]);\n      display_exit(d);\n }\n\n   png_read_info(d->png_ptr, d->info_ptr);\n\n switch (png_get_interlace_type(d->png_ptr, d->info_ptr))\n {\n case PNG_INTERLACE_NONE:\n         npasses = 1;\n break;\n\n case PNG_INTERLACE_ADAM7:\n         npasses = PNG_INTERLACE_ADAM7_PASSES;\n break;\n\n default:\n         fprintf(stderr, \"%s(%s): invalid interlace type\\n\", d->file, d->test);\n         clean_display(d);\n         exit(1);\n }\n\n if (chunk_info[0\n].keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n {\n      png_start_read_image(d->png_ptr);\n      height = png_get_image_height(d->png_ptr, d->info_ptr);\n\n if (npasses > 1)\n {\n         png_uint_32 width = png_get_image_width(d->png_ptr, d->info_ptr);\n\n for (ipass=0; ipass<npasses; ++ipass)\n {\n            png_uint_32 wPass = PNG_PASS_COLS(width, ipass);\n\n if (wPass > 0)\n {\n               png_uint_32 y;\n\n for (y=0; y<height; ++y) if (PNG_ROW_IN_INTERLACE_PASS(y, ipass))\n                  png_read_row(d->png_ptr, NULL, NULL);\n }\n }\n } \n\n else \n {\n         png_uint_32 y;\n\n for (y=0; y<height; ++y)\n            png_read_row(d->png_ptr, NULL, NULL);\n }\n }\n\n   png_read_end(d->png_ptr, d->end_ptr);\n\n   flags[0] = get_valid(d, d->info_ptr);\n   flags[1] = get_unknown(d, d->info_ptr, 0\n);\n\n   flags[chunk_info[0\n].keep != PNG_HANDLE_CHUNK_AS_DEFAULT] |=\n      PNG_INFO_IDAT;\n\n   flags[2] = get_valid(d, d->end_ptr);\n   flags[3] = get_unknown(d, d->end_ptr, 1\n);\n\n   clean_display(d);\n\n return d->keep;\n}\n", "target": 1, "flaw_line_index": "70,72,73,74,84,95"}
{"idx": 8309, "func": "XFixesFetchRegion (Display *dpy, XserverRegion region, int *nrectanglesRet)\n{\n    XRectangle\tbounds;\n\n    return XFixesFetchRegionAndBounds (dpy, region, nrectanglesRet, &bounds);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8780, "func": "static int udhcp_raw_socket(int ifindex)\n{\n\tint fd;\n\tstruct sockaddr_ll sock;\n\n\tlog2(\"opening raw socket on ifindex %d\", ifindex);\n\n\tfd = xsocket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));\n\tlog2(\"got raw socket fd\");\n\n\tmemset(&sock, 0, sizeof(sock)); \n\tsock.sll_family = AF_PACKET;\n\tsock.sll_protocol = htons(ETH_P_IP);\n\tsock.sll_ifindex = ifindex;\n\txbind(fd, (struct sockaddr *) &sock, sizeof(sock));\n\n#if 0 \n\tif (CLIENT_PORT == 68) {\n\t\t *\thttp:\n\t\tstatic const struct sock_filter filter_instr[] = {\n\t\t\tBPF_STMT(BPF_LD|BPF_B|BPF_ABS, 9),\n\t\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, IPPROTO_UDP, 0, 6),\n\t\t\tBPF_STMT(BPF_LD|BPF_H|BPF_ABS, 6),\n\t\t\tBPF_JUMP(BPF_JMP|BPF_JSET|BPF_K, 0x1fff, 4, 0),\n\t\t\tBPF_STMT(BPF_LDX|BPF_B|BPF_MSH, 0),\n\t\t\tBPF_STMT(BPF_LD|BPF_H|BPF_IND, 2),\n\t\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, 68, 0, 1),\n\t\t\tBPF_STMT(BPF_RET|BPF_K, 0x7fffffff),\n\t\t\tBPF_STMT(BPF_RET|BPF_K, 0),\n\t\t};\n\t\tstatic const struct sock_fprog filter_prog = {\n\t\t\t.len = sizeof(filter_instr) / sizeof(filter_instr[0]),\n\t\t\t.filter = (struct sock_filter *) filter_instr,\n\t\t};\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, &filter_prog,\n\t\t\t\tsizeof(filter_prog)) >= 0)\n\t\t\tlog1(\"attached filter to raw socket fd\"); \n\t}\n#endif\n\n\tif (setsockopt_1(fd, SOL_PACKET, PACKET_AUXDATA) != 0) {\n\t\tif (errno != ENOPROTOOPT)\n\t\t\tlog1(\"can't set PACKET_AUXDATA on raw socket\");\n\t}\n\n\tlog1(\"created raw socket\");\n\n\treturn fd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9026, "func": "vmxnet3_on_tx_done_update_stats(VMXNET3State *s, int qidx,\n    Vmxnet3PktStatus status)\n{\n    size_t tot_len = net_tx_pkt_get_total_len(s->tx_pkt);\n    struct UPT1_TxStats *stats = &s->txq_descr[qidx].txq_stats;\n\n    switch (status) {\n    case VMXNET3_PKT_STATUS_OK:\n        switch (net_tx_pkt_get_packet_type(s->tx_pkt)) {\n        case ETH_PKT_BCAST:\n            stats->bcastPktsTxOK++;\n            stats->bcastBytesTxOK += tot_len;\n            break;\n        case ETH_PKT_MCAST:\n            stats->mcastPktsTxOK++;\n            stats->mcastBytesTxOK += tot_len;\n            break;\n        case ETH_PKT_UCAST:\n            stats->ucastPktsTxOK++;\n            stats->ucastBytesTxOK += tot_len;\n            break;\n        default:\n            g_assert_not_reached();\n        }\n\n        if (s->offload_mode == VMXNET3_OM_TSO) {\n            stats->TSOPktsTxOK++;\n            stats->TSOBytesTxOK += tot_len;\n        }\n        break;\n\n    case VMXNET3_PKT_STATUS_DISCARD:\n        stats->pktsTxDiscard++;\n        break;\n\n    case VMXNET3_PKT_STATUS_ERROR:\n        stats->pktsTxError++;\n        break;\n\n    default:\n        g_assert_not_reached();\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187950, "func": " void btif_config_flush(void) {\n  assert(config != NULL);\n  assert(alarm_timer != NULL);\n\n \n   alarm_cancel(alarm_timer);\n \n  pthread_mutex_lock(&lock);\n  config_save(config, CONFIG_FILE_PATH);\n  pthread_mutex_unlock(&lock);\n }\n", "target": 1, "flaw_line_index": "8,9,10"}
{"idx": 9176, "func": "static bool virtio_64bit_features_needed(void *opaque)\n{\n    VirtIODevice *vdev = opaque;\n\n    return (vdev->host_features >> 32) != 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8879, "func": "vrend_insert_format(struct vrend_format_table *entry, uint32_t bindings)\n{\n   tex_conv_table[entry->format] = *entry;\n   tex_conv_table[entry->format].bindings = bindings;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188203, "func": "void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (NULL == mCodecCtx) {\n if (OK != initDecoder()) {\n return;\n }\n }\n if (outputBufferWidth() != mStride) {\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n \n             GETTIME(&mTimeStart, NULL);\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n                mIsInFlush = false;\n\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n", "target": 1, "flaw_line_index": "88"}
{"idx": 8734, "func": "static int internal_verify(X509_STORE_CTX *ctx)\n{\n    int ok = 0, n;\n    X509 *xs, *xi;\n    EVP_PKEY *pkey = NULL;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n\n    cb = ctx->verify_cb;\n\n    n = sk_X509_num(ctx->chain);\n    ctx->error_depth = n - 1;\n    n--;\n    xi = sk_X509_value(ctx->chain, n);\n\n    if (ctx->check_issued(ctx, xi, xi))\n        xs = xi;\n    else {\n        if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n            xs = xi;\n            goto check_cert;\n        }\n        if (n <= 0) {\n            ctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\n            ctx->current_cert = xi;\n            ok = cb(0, ctx);\n            goto end;\n        } else {\n            n--;\n            ctx->error_depth = n;\n            xs = sk_X509_value(ctx->chain, n);\n        }\n    }\n\n    while (n >= 0) {\n        ctx->error_depth = n;\n\n        if (!xs->valid\n            && (xs != xi\n                || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {\n            if ((pkey = X509_get_pubkey(xi)) == NULL) {\n                ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n                ctx->current_cert = xi;\n                ok = (*cb) (0, ctx);\n                if (!ok)\n                    goto end;\n            } else if (X509_verify(xs, pkey) <= 0) {\n                ctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\n                ctx->current_cert = xs;\n                ok = (*cb) (0, ctx);\n                if (!ok) {\n                    EVP_PKEY_free(pkey);\n                    goto end;\n                }\n            }\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n        }\n\n        xs->valid = 1;\n\n check_cert:\n        ok = check_cert_time(ctx, xs);\n        if (!ok)\n            goto end;\n\n        ctx->current_issuer = xi;\n        ctx->current_cert = xs;\n        ok = (*cb) (1, ctx);\n        if (!ok)\n            goto end;\n\n        n--;\n        if (n >= 0) {\n            xi = xs;\n            xs = sk_X509_value(ctx->chain, n);\n        }\n    }\n    ok = 1;\n end:\n    return ok;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187430, "func": "static void worker_process(int fd, debugger_request_t& request) {\n  std::string tombstone_path;\n int tombstone_fd = -1;\n switch (request.action) {\n case DEBUGGER_ACTION_DUMP_TOMBSTONE:\n case DEBUGGER_ACTION_CRASH:\n      tombstone_fd = open_tombstone(&tombstone_path);\n if (tombstone_fd == -1) {\n        ALOGE(\"debuggerd: failed to open tombstone file: %s\\n\", strerror(errno));\n        exit(1);\n }\n break;\n\n case DEBUGGER_ACTION_DUMP_BACKTRACE:\n break;\n\n default:\n      ALOGE(\"debuggerd: unexpected request action: %d\", request.action);\n      exit(1);\n }\n\n\n \n  if (ptrace(PTRACE_ATTACH, request.tid, 0, 0) != 0) {\n     ALOGE(\"debuggerd: ptrace attach failed: %s\", strerror(errno));\n     exit(1);\n   }\n \n   bool attach_gdb = should_attach_gdb(request);\n if (attach_gdb) {\n if (init_getevent() != 0) {\n      ALOGE(\"debuggerd: failed to initialize input device, not waiting for gdb\");\n      attach_gdb = false;\n }\n\n }\n\n  std::set<pid_t> siblings;\n if (!attach_gdb) {\n    ptrace_siblings(request.pid, request.tid, siblings);\n }\n\n  std::unique_ptr<BacktraceMap> backtrace_map(BacktraceMap::Create(request.pid));\n\n int amfd = -1;\n  std::unique_ptr<std::string> amfd_data;\n if (request.action == DEBUGGER_ACTION_CRASH) {\n    amfd = activity_manager_connect();\n    amfd_data.reset(new std::string);\n }\n\n bool succeeded = false;\n\n if (!drop_privileges()) {\n    ALOGE(\"debuggerd: failed to drop privileges, exiting\");\n    _exit(1);\n }\n\n int crash_signal = SIGKILL;\n  succeeded = perform_dump(request, fd, tombstone_fd, backtrace_map.get(), siblings,\n &crash_signal, amfd_data.get());\n if (succeeded) {\n if (request.action == DEBUGGER_ACTION_DUMP_TOMBSTONE) {\n if (!tombstone_path.empty()) {\n        android::base::WriteFully(fd, tombstone_path.c_str(), tombstone_path.length());\n }\n }\n }\n\n if (attach_gdb) {\n if (!send_signal(request.pid, 0, SIGSTOP)) {\n      ALOGE(\"debuggerd: failed to stop process for gdb attach: %s\", strerror(errno));\n      attach_gdb = false;\n }\n }\n\n if (!attach_gdb) {\n    activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get());\n }\n\n if (ptrace(PTRACE_DETACH, request.tid, 0, 0) != 0) {\n    ALOGE(\"debuggerd: ptrace detach from %d failed: %s\", request.tid, strerror(errno));\n }\n\n for (pid_t sibling : siblings) {\n    ptrace(PTRACE_DETACH, sibling, 0, 0);\n }\n\n if (!attach_gdb && request.action == DEBUGGER_ACTION_CRASH) {\n if (!send_signal(request.pid, request.tid, crash_signal)) {\n      ALOGE(\"debuggerd: failed to kill process %d: %s\", request.pid, strerror(errno));\n }\n }\n\n if (attach_gdb) {\n    wait_for_user_action(request);\n\n    activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get());\n\n if (!send_signal(request.pid, 0, SIGCONT)) {\n      ALOGE(\"debuggerd: failed to resume process %d: %s\", request.pid, strerror(errno));\n }\n\n    uninit_getevent();\n }\n\n  close(amfd);\n\n  exit(!succeeded);\n}\n", "target": 1, "flaw_line_index": "36"}
{"idx": 187747, "func": "BOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace, BOOL alpha)\n {\n   png_struct    *png_ptr = NULL;\n   png_info      *info_ptr = NULL;\n   png_byte      *png_pixels = NULL;\n   png_byte      **row_pointers = NULL;\n   png_byte      *pix_ptr = NULL;\n  png_uint_32   row_bytes;\n \n   char          type_token[16];\n   char          width_token[16];\n   char          height_token[16];\n   char          maxval_token[16];\n  int           color_type;\n   unsigned long   ul_width=0, ul_alpha_width=0;\n   unsigned long   ul_height=0, ul_alpha_height=0;\n   unsigned long   ul_maxval=0;\n  png_uint_32   width, alpha_width;\n  png_uint_32   height, alpha_height;\n   png_uint_32   maxval;\n  int           bit_depth = 0;\n  int           channels;\n   int           alpha_depth = 0;\n  int           alpha_present;\n   int           row, col;\n   BOOL          raw, alpha_raw = FALSE;\n #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n  BOOL          packed_bitmap = FALSE;\n#endif\n  png_uint_32   tmp16;\n int           i;\n\n\n  get_token(pnm_file, type_token);\n if (type_token[0] != 'P')\n {\n return FALSE;\n }\n else if ((type_token[1] == '1') || (type_token[1] == '4'))\n {\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n    raw = (type_token[1] == '4');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    bit_depth = 1;\n    packed_bitmap = TRUE;\n#else\n    fprintf (stderr, \"PNM2PNG built without PNG_WRITE_INVERT_SUPPORTED and \\n\");\n    fprintf (stderr, \"PNG_WRITE_PACK_SUPPORTED can't read PBM (P1,P4) files\\n\");\n#endif\n }\n else if ((type_token[1] == '2') || (type_token[1] == '5'))\n {\n    raw = (type_token[1] == '5');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n\n if (maxval <= 1)\n      bit_depth = 1;\n else if (maxval <= 3)\n      bit_depth = 2;\n else if (maxval <= 15)\n      bit_depth = 4;\n else if (maxval <= 255)\n      bit_depth = 8;\n else \n      bit_depth = 16;\n }\n else if ((type_token[1] == '3') || (type_token[1] == '6'))\n {\n    raw = (type_token[1] == '6');\n    color_type = PNG_COLOR_TYPE_RGB;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n if (maxval <= 1)\n      bit_depth = 1;\n else if (maxval <= 3)\n      bit_depth = 2;\n else if (maxval <= 15)\n      bit_depth = 4;\n else if (maxval <= 255)\n      bit_depth = 8;\n else \n      bit_depth = 16;\n }\n else\n {\n return FALSE;\n }\n\n\n if (alpha)\n {\n if (color_type == PNG_COLOR_TYPE_GRAY)\n      color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n if (color_type == PNG_COLOR_TYPE_RGB)\n      color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n\n    get_token(alpha_file, type_token);\n if (type_token[0] != 'P')\n {\n return FALSE;\n }\n else if ((type_token[1] == '2') || (type_token[1] == '5'))\n {\n      alpha_raw = (type_token[1] == '5');\n      get_token(alpha_file, width_token);\n      sscanf (width_token, \"%lu\", &ul_alpha_width);\n      alpha_width=(png_uint_32) ul_alpha_width;\n if (alpha_width != width)\n return FALSE;\n      get_token(alpha_file, height_token);\n      sscanf (height_token, \"%lu\", &ul_alpha_height);\n      alpha_height = (png_uint_32) ul_alpha_height;\n if (alpha_height != height)\n return FALSE;\n      get_token(alpha_file, maxval_token);\n      sscanf (maxval_token, \"%lu\", &ul_maxval);\n      maxval = (png_uint_32) ul_maxval;\n if (maxval <= 1)\n        alpha_depth = 1;\n else if (maxval <= 3)\n        alpha_depth = 2;\n else if (maxval <= 15)\n        alpha_depth = 4;\n else if (maxval <= 255)\n        alpha_depth = 8;\n else \n        alpha_depth = 16;\n if (alpha_depth != bit_depth)\n return FALSE;\n }\n else\n {\n return FALSE;\n }\n } \n\n if (color_type == PNG_COLOR_TYPE_GRAY)\n    channels = 1;\n else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    channels = 2;\n else if (color_type == PNG_COLOR_TYPE_RGB)\n\n     channels = 3;\n   else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n     channels = 4;\n   else\n    channels = 0; \n \n   alpha_present = (channels - 1) % 2;\n \n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n if (packed_bitmap)\n    row_bytes = (width * channels * bit_depth + 7) / 8;\n else\n#endif\n\n     row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2);\n \n  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL)\n     return FALSE;\n \n   pix_ptr = png_pixels;\n \n  for (row = 0; row < height; row++)\n   {\n #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n     if (packed_bitmap) {\n      for (i = 0; i < row_bytes; i++)\n         *pix_ptr++ = get_data (pnm_file, 8);\n     } else\n #endif\n     {\n      for (col = 0; col < width; col++)\n       {\n         for (i = 0; i < (channels - alpha_present); i++)\n         {\n if (raw)\n *pix_ptr++ = get_data (pnm_file, bit_depth);\n else\n if (bit_depth <= 8)\n *pix_ptr++ = get_value (pnm_file, bit_depth);\n else\n {\n              tmp16 = get_value (pnm_file, bit_depth);\n *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);\n              pix_ptr++;\n *pix_ptr = (png_byte) (tmp16 & 0xFF);\n              pix_ptr++;\n }\n }\n\n if (alpha) \n {\n if (alpha_raw)\n *pix_ptr++ = get_data (alpha_file, alpha_depth);\n else\n if (alpha_depth <= 8)\n *pix_ptr++ = get_value (alpha_file, bit_depth);\n else\n {\n              tmp16 = get_value (alpha_file, bit_depth);\n *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);\n *pix_ptr++ = (png_byte) (tmp16 & 0xFF);\n }\n } \n } \n } \n\n   } \n \n  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n   if (!png_ptr)\n   {\n     return FALSE;\n   }\n   info_ptr = png_create_info_struct (png_ptr);\n   if (!info_ptr)\n   {\n     png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n     return FALSE;\n   }\n \n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n if (packed_bitmap == TRUE)\n {\n    png_set_packing (png_ptr);\n    png_set_invert_mono (png_ptr);\n }\n#endif\n\n\n   if (setjmp (png_jmpbuf(png_ptr)))\n   {\n    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n     return FALSE;\n   }\n \n  png_init_io (png_ptr, png_file);\n\n  png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type,\n (!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7,\n    PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n\n  png_write_info (png_ptr, info_ptr);\n\n\n   if (row_pointers == (unsigned char**) NULL)\n   {\n    if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)\n     {\n      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n       return FALSE;\n     }\n   }\n \n  for (i = 0; i < (height); i++)\n     row_pointers[i] = png_pixels + i * row_bytes;\n \n   png_write_image (png_ptr, row_pointers);\n \n   png_write_end (png_ptr, info_ptr);\n \n  png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n \n   if (row_pointers != (unsigned char**) NULL)\n     free (row_pointers);\n if (png_pixels != (unsigned char*) NULL)\n    free (png_pixels);\n\n return TRUE;\n} \n", "target": 1, "flaw_line_index": "8,14,18,19,21,22,24,169,181,186,190,195,233,256,271,273,278,282,285"}
{"idx": 8834, "func": "static void *vrend_create_shader_state(struct vrend_context *ctx,\n                                       const struct pipe_stream_output_info *so_info,\n                                       unsigned pipe_shader_type)\n{\n   struct vrend_shader_selector *sel = CALLOC_STRUCT(vrend_shader_selector);\n\n   if (!sel)\n      return NULL;\n\n   sel->type = pipe_shader_type;\n   sel->sinfo.so_info = *so_info;\n   pipe_reference_init(&sel->reference, 1);\n\n   return sel;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187592, "func": "int readpng2_init(mainprog_info *mainprog_ptr)\n{\n    png_structp  png_ptr; \n    png_infop  info_ptr;\n\n\n \n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n       readpng2_error_handler, readpng2_warning_handler);\n     if (!png_ptr)\n         return 4;   \n\n    info_ptr = png_create_info_struct(png_ptr);\n if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n return 4; \n }\n\n\n\n\n\n if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n return 2;\n }\n\n\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n {\n static PNG_CONST png_byte chunks_to_process[] = {\n 98, 75, 71, 68, '\\0', \n 103, 65, 77, 65, '\\0', \n 115, 82, 71, 66, '\\0', \n };\n\n       png_set_keep_unknown_chunks(png_ptr, -1 \n,\n          NULL, -1);\n\n       png_set_keep_unknown_chunks(png_ptr,\n 0 \n, chunks_to_process,\n sizeof(chunks_to_process)/5);\n }\n#endif \n\n\n\n    png_set_progressive_read_fn(png_ptr, mainprog_ptr,\n      readpng2_info_callback, readpng2_row_callback, readpng2_end_callback);\n\n\n\n    mainprog_ptr->png_ptr = png_ptr;\n    mainprog_ptr->info_ptr = info_ptr;\n\n\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 188179, "func": " void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 9047, "func": "static void vmxnet3_reset_mac(VMXNET3State *s)\n{\n    memcpy(&s->conf.macaddr.a, &s->perm_mac.a, sizeof(s->perm_mac.a));\n    VMW_CFPRN(\"MAC address set to: \" MAC_FMT, MAC_ARG(s->conf.macaddr.a));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187616, "func": "freeimage(Image *image)\n{\n   freebuffer(image);\n   png_image_free(&image->image);\n\n if (image->input_file != NULL)\n {\n      fclose(image->input_file);\n      image->input_file = NULL;\n }\n\n if (image->input_memory != NULL)\n {\n      free(image->input_memory);\n      image->input_memory = NULL;\n      image->input_memory_size = 0;\n }\n\n \n    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)\n    {\n      remove(image->tmpfile_name);\n       image->tmpfile_name[0] = 0;\n    }\n }\n", "target": 1, "flaw_line_index": "22"}
{"idx": 188500, "func": "int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n vpx_codec_err_t res;\n VpxVideoReader *reader = NULL;\n const VpxInterface *decoder = NULL;\n const VpxVideoInfo *info = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  res = vpx_codec_dec_init(&codec, decoder->interface(), NULL,\n                            VPX_CODEC_USE_POSTPROC);\n   if (res == VPX_CODEC_INCAPABLE)\n     die_codec(&codec, \"Postproc not supported by this decoder.\");\n\n if (res)\n    die_codec(&codec, \"Failed to initialize decoder.\");\n\n while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n\n ++frame_cnt;\n\n if (frame_cnt % 30 == 1) {\n vp8_postproc_cfg_t pp = {0, 0, 0};\n\n if (vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp))\n      die_codec(&codec, \"Failed to turn off postproc.\");\n } else if (frame_cnt % 30 == 16) {\n vp8_postproc_cfg_t pp = {VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE,\n 4, 0};\n if (vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp))\n        die_codec(&codec, \"Failed to turn on postproc.\");\n };\n\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 15000))\n      die_codec(&codec, \"Failed to decode frame\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n      vpx_img_write(img, outfile);\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec\");\n\n  printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n         info->frame_width, info->frame_height, argv[2]);\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n return EXIT_SUCCESS;\n}\n", "target": 1, "flaw_line_index": "29,31"}
{"idx": 9058, "func": "static void vmxnet3_rx_need_csum_calculate(struct NetRxPkt *pkt,\n                                           const void *pkt_data,\n                                           size_t pkt_len)\n{\n    struct virtio_net_hdr *vhdr;\n    bool isip4, isip6, istcp, isudp;\n    uint8_t *data;\n    int len;\n\n    if (!net_rx_pkt_has_virt_hdr(pkt)) {\n        return;\n    }\n\n    vhdr = net_rx_pkt_get_vhdr(pkt);\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n        return;\n    }\n\n    net_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n        return;\n    }\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n        VMW_PKPRN(\"packet len:%zu < csum_start(%d) + csum_offset(%d) + 2, \"\n                  \"cannot calculate checksum\",\n                  pkt_len, vhdr->csum_start, vhdr->csum_offset);\n        return;\n    }\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n    len = pkt_len - vhdr->csum_start;\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187872, "func": "long ContentEncoding::ParseContentEncodingEntry(long long start, long long size,\n IMkvReader* pReader) {\n  assert(pReader);\n\n long long pos = start;\n const long long stop = start + size;\n\n int compression_count = 0;\n int encryption_count = 0;\n\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) \n return status;\n\n if (id == 0x1034) \n ++compression_count;\n\n if (id == 0x1035) \n\n       ++encryption_count;\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n   if (compression_count <= 0 && encryption_count <= 0)\n return -1;\n\n \n   if (compression_count > 0) {\n     compression_entries_ =\n        new (std::nothrow) ContentCompression* [compression_count];\n     if (!compression_entries_)\n       return -1;\n     compression_entries_end_ = compression_entries_;\n }\n\n \n   if (encryption_count > 0) {\n     encryption_entries_ =\n        new (std::nothrow) ContentEncryption* [encryption_count];\n     if (!encryption_entries_) {\n       delete[] compression_entries_;\n       return -1;\n }\n    encryption_entries_end_ = encryption_entries_;\n }\n\n  pos = start;\n while (pos < stop) {\n long long id, size;\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) \n return status;\n\n if (id == 0x1031) {\n      encoding_order_ = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x1032) {\n      encoding_scope_ = UnserializeUInt(pReader, pos, size);\n if (encoding_scope_ < 1)\n return -1;\n } else if (id == 0x1033) {\n      encoding_type_ = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x1034) {\n ContentCompression* const compression =\n new (std::nothrow) ContentCompression();\n if (!compression)\n return -1;\n\n      status = ParseCompressionEntry(pos, size, pReader, compression);\n if (status) {\n delete compression;\n return status;\n }\n *compression_entries_end_++ = compression;\n } else if (id == 0x1035) {\n ContentEncryption* const encryption =\n new (std::nothrow) ContentEncryption();\n if (!encryption)\n return -1;\n\n      status = ParseEncryptionEntry(pos, size, pReader, encryption);\n if (status) {\n delete encryption;\n return status;\n }\n *encryption_entries_end_++ = encryption;\n\n     }\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n   return 0;\n }\n", "target": 1, "flaw_line_index": "26,35,44,100"}
{"idx": 8609, "func": "static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)\n{\n    return le32_to_cpu(vmsvga_fifo_read_raw(s));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8864, "func": "static inline bool vrend_format_can_sample(enum virgl_formats format)\n{\n   return tex_conv_table[format].bindings & VREND_BIND_SAMPLER;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8448, "func": "pvscsi_ring_flush_msg(PVSCSIRingInfo *mgr)\n{\n    smp_wmb();\n\n    trace_pvscsi_ring_flush_msg(mgr->filled_msg_ptr);\n\n    RS_SET_FIELD(mgr, msgProdIdx, mgr->filled_msg_ptr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8539, "func": "static void ssh2_pkt_addbool(struct Packet *pkt, unsigned char value)\n{\n    ssh_pkt_adddata(pkt, &value, 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8846, "func": "static void vrend_destroy_shader_selector(struct vrend_shader_selector *sel)\n{\n   struct vrend_shader *p = sel->current, *c;\n   int i;\n   while (p) {\n      c = p->next_variant;\n      vrend_shader_destroy(p);\n      p = c;\n   }\n   if (sel->sinfo.so_names)\n      for (i = 0; i < sel->sinfo.so_info.num_outputs; i++)\n         free(sel->sinfo.so_names[i]);\n   free(sel->tmp_buf);\n   free(sel->sinfo.so_names);\n   free(sel->sinfo.interpinfo);\n   free(sel->tokens);\n   free(sel);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187488, "func": " static inline void set_socket_blocking(int s, int blocking)\n {\n     int opts;\n    opts = fcntl(s, F_GETFL);\n     if (opts<0) APPL_TRACE_ERROR(\"set blocking (%s)\", strerror(errno));\n     if(blocking)\n         opts &= ~O_NONBLOCK;\n     else opts |= O_NONBLOCK;\n    if (fcntl(s, F_SETFL, opts) < 0)\n         APPL_TRACE_ERROR(\"set blocking (%s)\", strerror(errno));\n }\n", "target": 1, "flaw_line_index": "4,9"}
{"idx": 8581, "func": "static const char *ssh_pkt_type(Ssh ssh, int type)\n{\n    if (ssh->version == 1)\n\treturn ssh1_pkt_type(type);\n    else\n\treturn ssh2_pkt_type(ssh->pkt_kctx, ssh->pkt_actx, type);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9046, "func": "static void vmxnet3_reset_interrupt_states(VMXNET3State *s)\n{\n    int i;\n    for (i = 0; i < ARRAY_SIZE(s->interrupt_states); i++) {\n        s->interrupt_states[i].is_asserted = false;\n        s->interrupt_states[i].is_pending = false;\n        s->interrupt_states[i].is_masked = true;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9057, "func": "vmxnet3_rx_filter_may_indicate(VMXNET3State *s, const void *data,\n    size_t size)\n{\n    struct eth_header *ehdr = PKT_GET_ETH_HDR(data);\n\n    if (VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_PROMISC)) {\n        return true;\n    }\n\n    if (!vmxnet3_is_registered_vlan(s, data)) {\n        return false;\n    }\n\n    switch (net_rx_pkt_get_packet_type(s->rx_pkt)) {\n    case ETH_PKT_UCAST:\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_UCAST)) {\n            return false;\n        }\n        if (memcmp(s->conf.macaddr.a, ehdr->h_dest, ETH_ALEN)) {\n            return false;\n        }\n        break;\n\n    case ETH_PKT_BCAST:\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_BCAST)) {\n            return false;\n        }\n        break;\n\n    case ETH_PKT_MCAST:\n        if (VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_ALL_MULTI)) {\n            return true;\n        }\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_MCAST)) {\n            return false;\n        }\n        if (!vmxnet3_is_allowed_mcast_group(s, ehdr->h_dest)) {\n            return false;\n        }\n        break;\n\n    default:\n        g_assert_not_reached();\n    }\n\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8702, "func": "test_are_urls_equal(void)\n{\n  unsigned i;\n  static const struct {\n    const char *url1;\n    const char *url2;\n    bool expected_result;\n  } test_array[] = {\n    { \"http:\n    { \"http:\n    { \"http:\n    { \"http:\n    { \"http:\n    { \"http:\n  };\n\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      mu_assert (\"test_are_urls_equal: wrong result\",\n                 are_urls_equal (test_array[i].url1, test_array[i].url2) == test_array[i].expected_result);\n    }\n\n  return NULL;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9146, "func": "streq_nocase_uprcase(const char *str1,\n                     const char *str2)\n{\n   while (*str1 && *str2) {\n      if (*str1 != uprcase(*str2))\n         return FALSE;\n      str1++;\n      str2++;\n   }\n   return *str1 == 0 && *str2 == 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8802, "func": "static char *get_skip_str(int *skip_val)\n{\n   char *start_skip = NULL;\n   if (*skip_val < 0) {\n      *skip_val = 0;\n      return NULL;\n   }\n\n   if (*skip_val == 1) {\n      start_skip = strdup(\"gl_SkipComponents1\");\n      *skip_val -= 1;\n   } else if (*skip_val == 2) {\n      start_skip = strdup(\"gl_SkipComponents2\");\n      *skip_val -= 2;\n   } else if (*skip_val == 3) {\n      start_skip = strdup(\"gl_SkipComponents3\");\n      *skip_val -= 3;\n   } else if (*skip_val >= 4) {\n      start_skip = strdup(\"gl_SkipComponents4\");\n      *skip_val -= 4;\n   }\n   return start_skip;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188505, "func": " static void set_active_map(const vpx_codec_enc_cfg_t *cfg,\n                            vpx_codec_ctx_t *codec) {\n   unsigned int i;\n  vpx_active_map_t map = {0};\n \n   map.rows = (cfg->g_h + 15) / 16;\n   map.cols = (cfg->g_w + 15) / 16;\n\n map.active_map = (uint8_t *)malloc(map.rows * map.cols);\n for (i = 0; i < map.rows * map.cols; ++i)\n map.active_map[i] = i % 2;\n\n if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))\n    die_codec(codec, \"Failed to set active map\");\n\n  free(map.active_map);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8410, "func": "pvscsi_do_command_processing(PVSCSIState *s)\n{\n    size_t bytes_arrived = s->curr_cmd_data_cntr * sizeof(uint32_t);\n\n    assert(s->curr_cmd < PVSCSI_CMD_LAST);\n    if (bytes_arrived >= pvscsi_commands[s->curr_cmd].data_size) {\n        s->reg_command_status = pvscsi_commands[s->curr_cmd].handler_fn(s);\n        s->curr_cmd = PVSCSI_CMD_FIRST;\n        s->curr_cmd_data_cntr   = 0;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9208, "func": "void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)\n{\n    if (!virtio_should_notify(vdev, vq)) {\n        return;\n    }\n\n    trace_virtio_notify(vdev, vq);\n    vdev->isr |= 0x01;\n    virtio_notify_vector(vdev, vq->vector);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8336, "func": "static int xhci_ep_nuke_one_xfer(XHCITransfer *t, TRBCCode report)\n{\n    int killed = 0;\n\n    if (report && (t->running_async || t->running_retry)) {\n        t->status = report;\n        xhci_xfer_report(t);\n    }\n\n    if (t->running_async) {\n        usb_cancel_packet(&t->packet);\n        t->running_async = 0;\n        killed = 1;\n    }\n    if (t->running_retry) {\n        XHCIEPContext *epctx = t->xhci->slots[t->slotid-1].eps[t->epid-1];\n        if (epctx) {\n            epctx->retry = NULL;\n            timer_del(epctx->kick_timer);\n        }\n        t->running_retry = 0;\n        killed = 1;\n    }\n    g_free(t->trbs);\n\n    t->trbs = NULL;\n    t->trb_count = t->trb_alloced = 0;\n\n    return killed;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9011, "func": "static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)\n{\n    return s->interrupt_states[lidx].is_asserted;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8980, "func": "vmxnet3_cleanup_msix(VMXNET3State *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    if (s->msix_used) {\n        vmxnet3_unuse_msix_vectors(s, VMXNET3_MAX_INTRS);\n        msix_uninit(d, &s->msix_bar, &s->msix_bar);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9051, "func": "static inline uint8_t vmxnet3_ring_curr_gen(Vmxnet3Ring *ring)\n{\n    return ring->gen;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9183, "func": "uint32_t virtio_config_modern_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = lduw_le_p(vdev->config + addr);\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187565, "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\n if(prev_slice_err == 1)\n {\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n {\n                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n\n                 }\n             }\n         }\n     }\n     else\n     {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n {\n            num_entries *= 2;\n }\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n \n     H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n \n    ps_dec->u2_cur_slice_num++;\n \n     if(ps_dec->u4_first_slice_in_pic != 0)\n         ps_dec->ps_parse_cur_slice++;\n \n     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": "390"}
{"idx": 8408, "func": "pvscsi_dbg_dump_tx_rings_config(PVSCSICmdDescSetupRings *rc)\n{\n    int i;\n    trace_pvscsi_tx_rings_ppn(\"Rings State\", rc->ringsStatePPN);\n\n    trace_pvscsi_tx_rings_num_pages(\"Request Ring\", rc->reqRingNumPages);\n    for (i = 0; i < rc->reqRingNumPages; i++) {\n        trace_pvscsi_tx_rings_ppn(\"Request Ring\", rc->reqRingPPNs[i]);\n    }\n\n    trace_pvscsi_tx_rings_num_pages(\"Confirm Ring\", rc->cmpRingNumPages);\n    for (i = 0; i < rc->cmpRingNumPages; i++) {\n        trace_pvscsi_tx_rings_ppn(\"Confirm Ring\", rc->cmpRingPPNs[i]);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187625, "func": "static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n if (pm->assume_16_bit_calculations ||\n (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxabs16;\n else\n\n       return pm->maxabs8;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188608, "func": " void VarianceTest<VarianceFunctionType>::RefTest() {\n   for (int i = 0; i < 10; ++i) {\n     for (int j = 0; j < block_size_; j++) {\n      src_[j] = rnd.Rand8();\n      ref_[j] = rnd.Rand8();\n     }\n     unsigned int sse1, sse2;\n     unsigned int var1;\n    REGISTER_STATE_CHECK(var1 = variance_(src_, width_, ref_, width_, &sse1));\n     const unsigned int var2 = variance_ref(src_, ref_, log2width_,\n                                           log2height_, &sse2);\n     EXPECT_EQ(sse1, sse2);\n     EXPECT_EQ(var1, var2);\n   }\n}\n", "target": 1, "flaw_line_index": "4,5,9,11"}
{"idx": 9000, "func": "static int vmxnet3_get_rxq_descr(QEMUFile *f, void *pv, size_t size)\n{\n    Vmxnet3RxqDescr *r = pv;\n    int i;\n\n    for (i = 0; i < VMXNET3_RX_RINGS_PER_QUEUE; i++) {\n        vmxnet3_get_ring_from_file(f, &r->rx_ring[i]);\n    }\n\n    vmxnet3_get_ring_from_file(f, &r->comp_ring);\n    r->intr_idx = qemu_get_byte(f);\n    r->rx_stats_pa = qemu_get_be64(f);\n\n    vmxnet3_get_rx_stats_from_file(f, &r->rxq_stats);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8596, "func": "static unsigned int ssh_tty_parse_specchar(char *s)\n{\n    unsigned int ret;\n    if (*s) {\n\tchar *next = NULL;\n\tret = ctrlparse(s, &next);\n\tif (!next) ret = s[0];\n    } else {\n\tret = 255; \n    }\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8946, "func": "void vrend_set_viewport_states(struct vrend_context *ctx,\n                               uint32_t start_slot,\n                               uint32_t num_viewports,\n                               const struct pipe_viewport_state *state)\n{\n   GLint x, y;\n   GLsizei width, height;\n   GLclampd near_val, far_val;\n   bool viewport_is_negative = (state[0].scale[1] < 0) ? true : false;\n   int i, idx;\n\n   if (num_viewports > PIPE_MAX_VIEWPORTS ||\n       start_slot > (PIPE_MAX_VIEWPORTS - num_viewports)) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_CMD_BUFFER, num_viewports);\n      return;\n   }\n\n   for (i = 0; i < num_viewports; i++) {\n      GLfloat abs_s1 = fabsf(state[i].scale[1]);\n\n      idx = start_slot + i;\n      width = state[i].scale[0] * 2.0f;\n      height = abs_s1 * 2.0f;\n      x = state[i].translate[0] - state[i].scale[0];\n      y = state[i].translate[1] - state[i].scale[1];\n\n      near_val = state[i].translate[2] - state[i].scale[2];\n      far_val = near_val + (state[i].scale[2] * 2.0);\n\n      if (ctx->sub->vps[idx].cur_x != x ||\n          ctx->sub->vps[idx].cur_y != y ||\n          ctx->sub->vps[idx].width != width ||\n          ctx->sub->vps[idx].height != height) {\n         ctx->sub->viewport_state_dirty |= (1 << idx);\n         ctx->sub->vps[idx].cur_x = x;\n         ctx->sub->vps[idx].cur_y = y;\n         ctx->sub->vps[idx].width = width;\n         ctx->sub->vps[idx].height = height;\n      }\n\n      if (idx == 0) {\n         if (ctx->sub->viewport_is_negative != viewport_is_negative)\n            ctx->sub->viewport_is_negative = viewport_is_negative;\n\n         ctx->sub->depth_scale = fabsf(far_val - near_val);\n         ctx->sub->depth_transform = near_val;\n      }\n\n      if (ctx->sub->vps[idx].near_val != near_val ||\n          ctx->sub->vps[idx].far_val != far_val) {\n         ctx->sub->vps[idx].near_val = near_val;\n         ctx->sub->vps[idx].far_val = far_val;\n         if (idx)\n            glDepthRangeIndexed(idx, ctx->sub->vps[idx].near_val, ctx->sub->vps[idx].far_val);\n         else\n            glDepthRange(ctx->sub->vps[idx].near_val, ctx->sub->vps[idx].far_val);\n      }\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187877, "func": " bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,\n                           Entry* pEntry) {\n   if (size_ <= 0)\n return false;\n\n long long pos = start;\n const long long stop = start + size_;\n\n long len;\n\n \n \n  const long long seekIdId = ReadUInt(pReader, pos, len);\n \n   if (seekIdId != 0x13AB)  \n     return false;\n\n if ((pos + len) > stop)\n return false;\n\n  pos += len; \n\n const long long seekIdSize = ReadUInt(pReader, pos, len);\n\n if (seekIdSize <= 0)\n return false;\n\n if ((pos + len) > stop)\n return false;\n\n  pos += len; \n\n if ((pos + seekIdSize) > stop)\n return false;\n\n\n  pEntry->id = ReadUInt(pReader, pos, len); \n\n if (pEntry->id <= 0)\n return false;\n\n if (len != seekIdSize)\n return false;\n\n  pos += seekIdSize; \n\n const long long seekPosId = ReadUInt(pReader, pos, len);\n\n if (seekPosId != 0x13AC) \n return false;\n\n if ((pos + len) > stop)\n return false;\n\n  pos += len; \n\n const long long seekPosSize = ReadUInt(pReader, pos, len);\n\n if (seekPosSize <= 0)\n return false;\n\n if ((pos + len) > stop)\n return false;\n\n  pos += len; \n\n if ((pos + seekPosSize) > stop)\n return false;\n\n  pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);\n\n if (pEntry->pos < 0)\n return false;\n\n  pos += seekPosSize; \n\n if (pos != stop)\n return false;\n\n \n   return true;\n }\n", "target": 1, "flaw_line_index": "14,15"}
{"idx": 8990, "func": "static int vmxnet3_get_int_state(QEMUFile *f, void *pv, size_t size)\n{\n    Vmxnet3IntState *r = pv;\n\n    r->is_masked = qemu_get_byte(f);\n    r->is_pending = qemu_get_byte(f);\n    r->is_asserted = qemu_get_byte(f);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187867, "func": "long Tracks::Parse() {\n  assert(m_trackEntries == NULL);\n  assert(m_trackEntriesEnd == NULL);\n\n const long long stop = m_start + m_size;\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n int count = 0;\n long long pos = m_start;\n\n while (pos < stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) \n return status;\n\n if (size == 0) \n continue;\n\n if (id == 0x2E) \n\n       ++count;\n \n     pos += size;  \n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   if (count <= 0)\n     return 0;  \n \n  m_trackEntries = new (std::nothrow) Track* [count];\n \n   if (m_trackEntries == NULL)\n     return -1;\n\n  m_trackEntriesEnd = m_trackEntries;\n\n  pos = m_start;\n\n while (pos < stop) {\n const long long element_start = pos;\n\n long long id, payload_size;\n\n const long status =\n ParseElementHeader(pReader, pos, stop, id, payload_size);\n\n if (status < 0) \n return status;\n\n if (payload_size == 0) \n continue;\n\n const long long payload_stop = pos + payload_size;\n    assert(payload_stop <= stop); \n\n const long long element_size = payload_stop - element_start;\n\n if (id == 0x2E) { \n Track*& pTrack = *m_trackEntriesEnd;\n      pTrack = NULL;\n\n const long status = ParseTrackEntry(pos, payload_size, element_start,\n                                          element_size, pTrack);\n\n if (status)\n return status;\n\n if (pTrack)\n ++m_trackEntriesEnd;\n\n     }\n \n     pos = payload_stop;\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   return 0;  \n }\n", "target": 1, "flaw_line_index": "27,30,35,79,82"}
{"idx": 8419, "func": "pvscsi_log2(uint32_t input)\n{\n    int log = 0;\n    assert(input > 0);\n    while (input >> ++log) {\n    }\n    return log;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8610, "func": "static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)\n{\n    uint32_t cmd = s->fifo[s->fifo_stop >> 2];\n\n    s->fifo_stop += 4;\n    if (s->fifo_stop >= s->fifo_max) {\n        s->fifo_stop = s->fifo_min;\n    }\n    s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n    return cmd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9089, "func": "static int vrend_decode_bind_shader(struct vrend_decode_ctx *ctx, int length)\n{\n   uint32_t handle, type;\n   if (length != VIRGL_BIND_SHADER_SIZE)\n      return EINVAL;\n\n   handle = get_buf_entry(ctx, VIRGL_BIND_SHADER_HANDLE);\n   type = get_buf_entry(ctx, VIRGL_BIND_SHADER_TYPE);\n\n   vrend_bind_shader(ctx->grctx, handle, type);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9002, "func": "static int vmxnet3_get_txq_descr(QEMUFile *f, void *pv, size_t size)\n{\n    Vmxnet3TxqDescr *r = pv;\n\n    vmxnet3_get_ring_from_file(f, &r->tx_ring);\n    vmxnet3_get_ring_from_file(f, &r->comp_ring);\n    r->intr_idx = qemu_get_byte(f);\n    r->tx_stats_pa = qemu_get_be64(f);\n\n    vmxnet3_get_tx_stats_from_file(f, &r->txq_stats);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188506, "func": " static void set_roi_map(const vpx_codec_enc_cfg_t *cfg,\n                         vpx_codec_ctx_t *codec) {\n   unsigned int i;\n  vpx_roi_map_t roi = {0};\n \n   roi.rows = (cfg->g_h + 15) / 16;\n   roi.cols = (cfg->g_w + 15) / 16;\n\n  roi.delta_q[0] = 0;\n  roi.delta_q[1] = -2;\n  roi.delta_q[2] = -4;\n  roi.delta_q[3] = -6;\n\n  roi.delta_lf[0] = 0;\n  roi.delta_lf[1] = 1;\n  roi.delta_lf[2] = 2;\n  roi.delta_lf[3] = 3;\n\n  roi.static_threshold[0] = 1500;\n  roi.static_threshold[1] = 1000;\n  roi.static_threshold[2] = 500;\n  roi.static_threshold[3] = 0;\n\n  roi.roi_map = (uint8_t *)malloc(roi.rows * roi.cols);\n for (i = 0; i < roi.rows * roi.cols; ++i)\n    roi.roi_map[i] = i % 4;\n\n if (vpx_codec_control(codec, VP8E_SET_ROI_MAP, &roi))\n    die_codec(codec, \"Failed to set ROI map\");\n\n  free(roi.roi_map);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8483, "func": "BOOL CSoundFile::GetPatternName(UINT nPat, LPSTR lpszName, UINT cbSize) const\n{\n\tif ((!lpszName) || (!cbSize)) return FALSE;\n\tlpszName[0] = 0;\n\tif (cbSize > MAX_PATTERNNAME) cbSize = MAX_PATTERNNAME;\n\tif ((m_lpszPatternNames) && (nPat < m_nPatternNames))\n\t{\n\t\tmemcpy(lpszName, m_lpszPatternNames + nPat * MAX_PATTERNNAME, cbSize);\n\t\tlpszName[cbSize-1] = 0;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8365, "func": "static dma_addr_t mptsas_ld_sg_base(MPTSASState *s, uint32_t flags_and_length,\n                                    dma_addr_t *sgaddr)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    dma_addr_t addr;\n\n    if (flags_and_length & MPI_SGE_FLAGS_64_BIT_ADDRESSING) {\n        addr = ldq_le_pci_dma(pci, *sgaddr + 4);\n        *sgaddr += 12;\n    } else {\n        addr = ldl_le_pci_dma(pci, *sgaddr + 4);\n        *sgaddr += 8;\n    }\n    return addr;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9160, "func": "static bool blit_build_vs_passthrough(struct vrend_blitter_ctx *blit_ctx)\n{\n   blit_ctx->vs = glCreateShader(GL_VERTEX_SHADER);\n\n   if (!build_and_check(blit_ctx->vs, VS_PASSTHROUGH)) {\n      glDeleteShader(blit_ctx->vs);\n      blit_ctx->vs = 0;\n      return false;\n   }\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188508, "func": "void usage_exit() {\n   fprintf(stderr, \"Usage: %s <codec> <width> <height> <infile> <outfile>\\n\",\n           exec_name);\n   exit(EXIT_FAILURE);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187900, "func": "status_t BnGraphicBufferProducer::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n case REQUEST_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferIdx   = data.readInt32();\n            sp<GraphicBuffer> buffer;\n int result = requestBuffer(bufferIdx, &buffer);\n            reply->writeInt32(buffer != 0);\n if (buffer != 0) {\n                reply->write(*buffer);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferCount = data.readInt32();\n int result = setBufferCount(bufferCount);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DEQUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool async = static_cast<bool>(data.readInt32());\n uint32_t width = data.readUint32();\n uint32_t height = data.readUint32();\n PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n uint32_t usage = data.readUint32();\n int buf = 0;\n            sp<Fence> fence;\n int result = dequeueBuffer(&buf, &fence, async, width, height,\n                    format, usage);\n            reply->writeInt32(buf);\n            reply->writeInt32(fence != NULL);\n if (fence != NULL) {\n                reply->write(*fence);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int slot = data.readInt32();\n int result = detachBuffer(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DETACH_NEXT_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer;\n            sp<Fence> fence;\n int32_t result = detachNextBuffer(&buffer, &fence);\n            reply->writeInt32(result);\n if (result == NO_ERROR) {\n                reply->writeInt32(buffer != NULL);\n if (buffer != NULL) {\n                    reply->write(*buffer);\n }\n                reply->writeInt32(fence != NULL);\n if (fence != NULL) {\n                    reply->write(*fence);\n }\n }\n return NO_ERROR;\n }\n case ATTACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer = new GraphicBuffer();\n            data.read(*buffer.get());\n int slot = 0;\n int result = attachBuffer(&slot, buffer);\n            reply->writeInt32(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case QUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n QueueBufferInput input(data);\n QueueBufferOutput* const output =\n reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            memset(output, 0, sizeof(QueueBufferOutput));\n status_t result = queueBuffer(buf, input, output);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case CANCEL_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n            sp<Fence> fence = new Fence();\n            data.read(*fence.get());\n            cancelBuffer(buf, fence);\n return NO_ERROR;\n }\n case QUERY: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int value = 0;\n int what = data.readInt32();\n int res = query(what, &value);\n            reply->writeInt32(value);\n            reply->writeInt32(res);\n return NO_ERROR;\n }\n case CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<IProducerListener> listener;\n if (data.readInt32() == 1) {\n                listener = IProducerListener::asInterface(data.readStrongBinder());\n }\n int api = data.readInt32();\n bool producerControlledByApp = data.readInt32();\n\n             QueueBufferOutput* const output =\n                     reinterpret_cast<QueueBufferOutput *>(\n                             reply->writeInplace(sizeof(QueueBufferOutput)));\n             status_t res = connect(listener, api, producerControlledByApp, output);\n             reply->writeInt32(res);\n             return NO_ERROR;\n }\n case DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int api = data.readInt32();\n status_t res = disconnect(api);\n            reply->writeInt32(res);\n return NO_ERROR;\n }\n case SET_SIDEBAND_STREAM: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<NativeHandle> stream;\n if (data.readInt32()) {\n                stream = NativeHandle::create(data.readNativeHandle(), true);\n }\n status_t result = setSidebandStream(stream);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case ALLOCATE_BUFFERS: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool async = static_cast<bool>(data.readInt32());\n uint32_t width = data.readUint32();\n uint32_t height = data.readUint32();\n PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n uint32_t usage = data.readUint32();\n            allocateBuffers(async, width, height, format, usage);\n return NO_ERROR;\n }\n case ALLOW_ALLOCATION: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool allow = static_cast<bool>(data.readInt32());\n status_t result = allowAllocation(allow);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_GENERATION_NUMBER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n uint32_t generationNumber = data.readUint32();\n status_t result = setGenerationNumber(generationNumber);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case GET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            reply->writeString8(getConsumerName());\n return NO_ERROR;\n }\n }\n return BBinder::onTransact(code, data, reply, flags);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8906, "func": "void vrend_renderer_get_rect(int res_handle, struct iovec *iov, unsigned int num_iovs,\n                             uint32_t offset, int x, int y, int width, int height)\n{\n   struct vrend_resource *res = vrend_resource_lookup(res_handle, 0);\n   struct vrend_transfer_info transfer_info;\n   struct pipe_box box;\n   int elsize;\n\n   memset(&transfer_info, 0, sizeof(transfer_info));\n\n   elsize = util_format_get_blocksize(res->base.format);\n   box.x = x;\n   box.y = y;\n   box.z = 0;\n   box.width = width;\n   box.height = height;\n   box.depth = 1;\n\n   transfer_info.box = &box;\n\n   transfer_info.stride = util_format_get_nblocksx(res->base.format, res->base.width0) * elsize;\n   transfer_info.offset = offset;\n   transfer_info.handle = res->handle;\n   transfer_info.iovec = iov;\n   transfer_info.iovec_cnt = num_iovs;\n   vrend_renderer_transfer_iov(&transfer_info, VREND_TRANSFER_READ);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8508, "func": "static void c_write_str(Ssh ssh, const char *buf)\n{\n    c_write(ssh, buf, strlen(buf));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187502, "func": "static bool has_byte(const eager_reader_t *reader) {\n  assert(reader != NULL);\n\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(reader->bytes_available_fd, &read_fds);\n\n struct timeval timeout;\n\n   timeout.tv_sec = 0;\n   timeout.tv_usec = 0;\n \n  select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout);\n   return FD_ISSET(reader->bytes_available_fd, &read_fds);\n }\n", "target": 1, "flaw_line_index": "14"}
{"idx": 187857, "func": "long Block::Parse(const Cluster* pCluster) {\n if (pCluster == NULL)\n return -1;\n\n if (pCluster->m_pSegment == NULL)\n return -1;\n\n  assert(m_start >= 0);\n  assert(m_size >= 0);\n  assert(m_track <= 0);\n  assert(m_frames == NULL);\n  assert(m_frame_count <= 0);\n\n long long pos = m_start;\n const long long stop = m_start + m_size;\n\n long len;\n\n IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;\n\n  m_track = ReadUInt(pReader, pos, len);\n\n if (m_track <= 0)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > stop)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; \n\n if ((stop - pos) < 2)\n return E_FILE_FORMAT_INVALID;\n\n long status;\n long long value;\n\n  status = UnserializeInt(pReader, pos, 2, value);\n\n if (status)\n return E_FILE_FORMAT_INVALID;\n\n if (value < SHRT_MIN)\n return E_FILE_FORMAT_INVALID;\n\n if (value > SHRT_MAX)\n return E_FILE_FORMAT_INVALID;\n\n  m_timecode = static_cast<short>(value);\n\n  pos += 2;\n\n if ((stop - pos) <= 0)\n return E_FILE_FORMAT_INVALID;\n\n  status = pReader->Read(pos, 1, &m_flags);\n\n if (status)\n return E_FILE_FORMAT_INVALID;\n\n const int lacing = int(m_flags & 0x06) >> 1;\n\n ++pos; \n\n if (lacing == 0) { \n if (pos > stop)\n\n       return E_FILE_FORMAT_INVALID;\n \n     m_frame_count = 1;\n    m_frames = new Frame[m_frame_count];\n \n     Frame& f = m_frames[0];\n     f.pos = pos;\n \n     const long long frame_size = stop - pos;\n \n    if (frame_size > LONG_MAX)\n       return E_FILE_FORMAT_INVALID;\n \n     f.len = static_cast<long>(frame_size);\n\n return 0; \n }\n\n if (pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n unsigned char biased_count;\n\n  status = pReader->Read(pos, 1, &biased_count);\n\n if (status)\n\n     return E_FILE_FORMAT_INVALID;\n \n   ++pos;  \n  assert(pos <= stop);\n \n   m_frame_count = int(biased_count) + 1;\n \n  m_frames = new Frame[m_frame_count];\n  assert(m_frames);\n \n   if (lacing == 1) {  \n     Frame* pf = m_frames;\n     Frame* const pf_end = pf + m_frame_count;\n \n    long size = 0;\n     int frame_count = m_frame_count;\n \n     while (frame_count > 1) {\n long frame_size = 0;\n\n for (;;) {\n unsigned char val;\n\n if (pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n        status = pReader->Read(pos, 1, &val);\n\n if (status)\n return E_FILE_FORMAT_INVALID;\n\n ++pos; \n\n        frame_size += val;\n\n if (val < 255)\n break;\n }\n\n \n       Frame& f = *pf++;\n       assert(pf < pf_end);\n \n       f.pos = 0;  \n \n       f.len = frame_size;\n       size += frame_size;  \n \n       --frame_count;\n     }\n \n    assert(pf < pf_end);\n    assert(pos <= stop);\n \n     {\n       Frame& f = *pf++;\n\n if (pf != pf_end)\n return E_FILE_FORMAT_INVALID;\n\n      f.pos = 0; \n\n const long long total_size = stop - pos;\n\n if (total_size < size)\n return E_FILE_FORMAT_INVALID;\n\n \n       const long long frame_size = total_size - size;\n \n      if (frame_size > LONG_MAX)\n         return E_FILE_FORMAT_INVALID;\n \n       f.len = static_cast<long>(frame_size);\n }\n\n    pf = m_frames;\n while (pf != pf_end) {\n\n       Frame& f = *pf++;\n       assert((pos + f.len) <= stop);\n \n       f.pos = pos;\n       pos += f.len;\n     }\n \n     assert(pos == stop);\n   } else if (lacing == 2) {  \n     const long long total_size = stop - pos;\n \n     if ((total_size % m_frame_count) != 0)\n return E_FILE_FORMAT_INVALID;\n\n \n     const long long frame_size = total_size / m_frame_count;\n \n    if (frame_size > LONG_MAX)\n       return E_FILE_FORMAT_INVALID;\n \n     Frame* pf = m_frames;\n Frame* const pf_end = pf + m_frame_count;\n\n \n     while (pf != pf_end) {\n       assert((pos + frame_size) <= stop);\n \n       Frame& f = *pf++;\n \n      f.pos = pos;\n      f.len = static_cast<long>(frame_size);\n\n      pos += frame_size;\n\n     }\n \n     assert(pos == stop);\n   } else {\n     assert(lacing == 3);  \n \n     if (pos >= stop)\n       return E_FILE_FORMAT_INVALID;\n \n    long size = 0;\n     int frame_count = m_frame_count;\n \n     long long frame_size = ReadUInt(pReader, pos, len);\n \n    if (frame_size < 0)\n       return E_FILE_FORMAT_INVALID;\n \n     if (frame_size > LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > stop)\n return E_FILE_FORMAT_INVALID;\n\n    pos += len; \n\n if ((pos + frame_size) > stop)\n return E_FILE_FORMAT_INVALID;\n\n Frame* pf = m_frames;\n Frame* const pf_end = pf + m_frame_count;\n\n {\n Frame& curr = *pf;\n\n      curr.pos = 0; \n\n      curr.len = static_cast<long>(frame_size);\n      size += curr.len; \n }\n\n --frame_count;\n\n while (frame_count > 1) {\n if (pos >= stop)\n\n         return E_FILE_FORMAT_INVALID;\n \n       assert(pf < pf_end);\n \n       const Frame& prev = *pf++;\n       assert(prev.len == frame_size);\n if (prev.len != frame_size)\n\n         return E_FILE_FORMAT_INVALID;\n \n       assert(pf < pf_end);\n \n       Frame& curr = *pf;\n \n      curr.pos = 0; \n\n const long long delta_size_ = ReadUInt(pReader, pos, len);\n\n if (delta_size_ < 0)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > stop)\n\n         return E_FILE_FORMAT_INVALID;\n \n       pos += len;  \n      assert(pos <= stop);\n \n       const int exp = 7 * len - 1;\n       const long long bias = (1LL << exp) - 1LL;\n const long long delta_size = delta_size_ - bias;\n\n \n       frame_size += delta_size;\n \n      if (frame_size < 0)\n         return E_FILE_FORMAT_INVALID;\n \n       if (frame_size > LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n\n      curr.len = static_cast<long>(frame_size);\n      size += curr.len; \n\n\n       --frame_count;\n     }\n \n    {\n      assert(pos <= stop);\n      assert(pf < pf_end);\n \n       const Frame& prev = *pf++;\n       assert(prev.len == frame_size);\n       if (prev.len != frame_size)\n         return E_FILE_FORMAT_INVALID;\n \n      assert(pf < pf_end);\n \n       Frame& curr = *pf++;\n      assert(pf == pf_end);\n \n       curr.pos = 0;  \n \n const long long total_size = stop - pos;\n\n if (total_size < size)\n return E_FILE_FORMAT_INVALID;\n\n \n       frame_size = total_size - size;\n \n      if (frame_size > LONG_MAX)\n         return E_FILE_FORMAT_INVALID;\n \n       curr.len = static_cast<long>(frame_size);\n }\n\n    pf = m_frames;\n\n     while (pf != pf_end) {\n       Frame& f = *pf++;\n       assert((pos + f.len) <= stop);\n \n       f.pos = pos;\n       pos += f.len;\n     }\n \n    assert(pos == stop);\n   }\n \n   return 0;  \n}\n", "target": 1, "flaw_line_index": "70,77,97,101,102,108,145,146,164,190,216,221,278,287,300,301,302,309,312,324,340"}
{"idx": 187712, "func": " safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST color_encoding *e, double encoding_gamma)\n {\n    if (e != 0)\n    {\n if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \"(\");\n      pos = safecat(buffer, bufsize, pos, \"R(\");\n      pos = safecatd(buffer, bufsize, pos, e->red.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),G(\");\n      pos = safecatd(buffer, bufsize, pos, e->green.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),B(\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \")\");\n if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \")\");\n }\n\n if (encoding_gamma != 0)\n {\n      pos = safecat(buffer, bufsize, pos, \"^\");\n      pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);\n }\n\n \n    return pos;\n }\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8558, "func": "static void ssh_comp_none_cleanup(void *handle)\n{\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187452, "func": "void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_mask,\n                    UINT8 app_id)\n{\n    UINT32 i;\n btif_hh_device_t *p_dev = NULL;\n\n if (dev_handle == BTA_HH_INVALID_HANDLE) {\n        APPL_TRACE_WARNING(\"%s: Oops, dev_handle (%d) is invalid...\",\n                           __FUNCTION__, dev_handle);\n return;\n }\n\n for (i = 0; i < BTIF_HH_MAX_HID; i++) {\n        p_dev = &btif_hh_cb.devices[i];\n if (p_dev->dev_status != BTHH_CONN_STATE_UNKNOWN &&\n            p_dev->dev_handle == dev_handle) {\n            APPL_TRACE_WARNING(\"%s: Found an existing device with the same handle \"\n \"dev_status = %d\",__FUNCTION__,\n                                                                p_dev->dev_status);\n            APPL_TRACE_WARNING(\"%s:     bd_addr = [%02X:%02X:%02X:%02X:%02X:]\", __FUNCTION__,\n                 p_dev->bd_addr.address[0], p_dev->bd_addr.address[1], p_dev->bd_addr.address[2],\n                 p_dev->bd_addr.address[3], p_dev->bd_addr.address[4]);\n                 APPL_TRACE_WARNING(\"%s:     attr_mask = 0x%04x, sub_class = 0x%02x, app_id = %d\",\n\n                                   __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);\n \n             if(p_dev->fd<0) {\n                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\"%s: Error: failed to open uhid, err:%s\",\n                                                                     __FUNCTION__,strerror(errno));\n return;\n }else\n                    APPL_TRACE_DEBUG(\"%s: uhid fd = %d\", __FUNCTION__, p_dev->fd);\n }\n\n            p_dev->hh_keep_polling = 1;\n            p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);\n break;\n }\n        p_dev = NULL;\n }\n\n if (p_dev == NULL) {\n for (i = 0; i < BTIF_HH_MAX_HID; i++) {\n if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_UNKNOWN) {\n                p_dev = &btif_hh_cb.devices[i];\n                p_dev->dev_handle = dev_handle;\n                p_dev->attr_mask  = attr_mask;\n                p_dev->sub_class  = sub_class;\n                p_dev->app_id     = app_id;\n                p_dev->local_vup  = FALSE;\n\n \n                 btif_hh_cb.device_num++;\n                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\"%s: Error: failed to open uhid, err:%s\",\n                                                                     __FUNCTION__,strerror(errno));\n return;\n }else{\n                    APPL_TRACE_DEBUG(\"%s: uhid fd = %d\", __FUNCTION__, p_dev->fd);\n                    p_dev->hh_keep_polling = 1;\n                    p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);\n }\n\n\n break;\n }\n }\n }\n\n if (p_dev == NULL) {\n        APPL_TRACE_ERROR(\"%s: Error: too many HID devices are connected\", __FUNCTION__);\n return;\n }\n\n    p_dev->dev_status = BTHH_CONN_STATE_CONNECTED;\n    APPL_TRACE_DEBUG(\"%s: Return device status %d\", __FUNCTION__, p_dev->dev_status);\n}\n", "target": 1, "flaw_line_index": "29,59"}
{"idx": 188176, "func": "static void local_socket_close_locked(asocket* s) {\n    D(\"entered local_socket_close_locked. LS(%d) fd=%d\", s->id, s->fd);\n     if (s->peer) {\n         D(\"LS(%d): closing peer. peer->id=%d peer->fd=%d\", s->id, s->peer->id, s->peer->fd);\n\n         if (s->peer->shutdown) {\n             s->peer->shutdown(s->peer);\n         }\n        s->peer->peer = 0;\n        if (s->peer->close == local_socket_close) {\n            local_socket_close_locked(s->peer);\n        } else {\n            s->peer->close(s->peer);\n        }\n        s->peer = 0;\n     }\n \n if (s->closing || s->has_write_error || s->pkt_first == NULL) {\n int id = s->id;\n        local_socket_destroy(s);\n        D(\"LS(%d): closed\", id);\n return;\n }\n\n    D(\"LS(%d): closing\", s->id);\n    s->closing = 1;\n    fdevent_del(&s->fde, FDE_READ);\n    remove_socket(s);\n    D(\"LS(%d): put on socket_closing_list fd=%d\", s->id, s->fd);\n    insert_local_socket(s, &local_socket_closing_list);\n    CHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);\n}\n", "target": 1, "flaw_line_index": "2,9,10,11,12,13,14,15,16"}
{"idx": 187603, "func": "image_size_of_type(int color_type, int bit_depth, unsigned int *colors)\n {\n    if (*colors)\n       return 16;\n\n else\n\n    {\n       int pixel_depth = pixel_depth_of_type(color_type, bit_depth);\n \n      if (pixel_depth < 8)\n          return 64;\n \n       else if (pixel_depth > 16)\n return 1024;\n\n else\n return 256;\n }\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 188003, "func": " static int _make_decode_table(codebook *s,char *lengthlist,long quantvals,\n\t\t\t      oggpack_buffer *opb,int maptype){\n   int i;\n   ogg_uint32_t *work;\n \n if (!lengthlist) return 1;\n if(s->dec_nodeb==4){\n    s->dec_table=_ogg_malloc((s->entries*2+1)*sizeof(*work));\n if (!s->dec_table) return 1;\n\n     if(_make_words(lengthlist,s->entries,\n\t\t   s->dec_table,quantvals,s,opb,maptype))return 1;\n \n     return 0;\n   }\n\n if (s->used_entries > INT_MAX/2 ||\n      s->used_entries*2 > INT_MAX/((long) sizeof(*work)) - 1) return 1;\n  work=calloc((s->entries*2+1),sizeof(*work));\n if (!work) return 1;\n if(_make_words(lengthlist,s->entries,work,quantvals,s,opb,maptype)) goto error_out;\n\n   if (s->used_entries > INT_MAX/(s->dec_leafw+1)) goto error_out;\n   if (s->dec_nodeb && s->used_entries * (s->dec_leafw+1) > INT_MAX/s->dec_nodeb) goto error_out;\n   s->dec_table=_ogg_malloc((s->used_entries*(s->dec_leafw+1)-2)*\n\t\t\t   s->dec_nodeb);\n   if (!s->dec_table) goto error_out;\n \n   if(s->dec_leafw==1){\n     switch(s->dec_nodeb){\n     case 1:\n       for(i=0;i<s->used_entries*2-2;i++)\n\t  ((unsigned char *)s->dec_table)[i]=(unsigned char)\n\t    (((work[i] & 0x80000000UL) >> 24) | work[i]);\n       break;\n     case 2:\n       for(i=0;i<s->used_entries*2-2;i++)\n\t  ((ogg_uint16_t *)s->dec_table)[i]=(ogg_uint16_t)\n\t    (((work[i] & 0x80000000UL) >> 16) | work[i]);\n       break;\n     }\n \n }else{\n long top=s->used_entries*3-2;\n if(s->dec_nodeb==1){\n\n       unsigned char *out=(unsigned char *)s->dec_table;\n \n       for(i=s->used_entries*2-4;i>=0;i-=2){\n\tif(work[i]&0x80000000UL){\n\t  if(work[i+1]&0x80000000UL){\n\t    top-=4;\n\t    out[top]=(work[i]>>8 & 0x7f)|0x80;\n\t    out[top+1]=(work[i+1]>>8 & 0x7f)|0x80;\n\t    out[top+2]=work[i] & 0xff;\n\t    out[top+3]=work[i+1] & 0xff;\n\t  }else{\n\t    top-=3;\n\t    out[top]=(work[i]>>8 & 0x7f)|0x80;\n\t    out[top+1]=work[work[i+1]*2];\n\t    out[top+2]=work[i] & 0xff;\n\t  }\n\t}else{\n\t  if(work[i+1]&0x80000000UL){\n\t    top-=3;\n\t    out[top]=work[work[i]*2];\n\t    out[top+1]=(work[i+1]>>8 & 0x7f)|0x80;\n\t    out[top+2]=work[i+1] & 0xff;\n\t  }else{\n\t    top-=2;\n\t    out[top]=work[work[i]*2];\n\t    out[top+1]=work[work[i+1]*2];\n\t  }\n\t}\n\twork[i]=top;\n       }\n     }else{\n       ogg_uint16_t *out=(ogg_uint16_t *)s->dec_table;\n       for(i=s->used_entries*2-4;i>=0;i-=2){\n\tif(work[i]&0x80000000UL){\n\t  if(work[i+1]&0x80000000UL){\n\t    top-=4;\n\t    out[top]=(work[i]>>16 & 0x7fff)|0x8000;\n\t    out[top+1]=(work[i+1]>>16 & 0x7fff)|0x8000;\n\t    out[top+2]=work[i] & 0xffff;\n\t    out[top+3]=work[i+1] & 0xffff;\n\t  }else{\n\t    top-=3;\n\t    out[top]=(work[i]>>16 & 0x7fff)|0x8000;\n\t    out[top+1]=work[work[i+1]*2];\n\t    out[top+2]=work[i] & 0xffff;\n\t  }\n\t}else{\n\t  if(work[i+1]&0x80000000UL){\n\t    top-=3;\n\t    out[top]=work[work[i]*2];\n\t    out[top+1]=(work[i+1]>>16 & 0x7fff)|0x8000;\n\t    out[top+2]=work[i+1] & 0xffff;\n\t  }else{\n\t    top-=2;\n\t    out[top]=work[work[i]*2];\n\t    out[top+1]=work[work[i+1]*2];\n\t  }\n\t}\n\twork[i]=top;\n       }\n     }\n   }\n\n  free(work);\n return 0;\nerror_out:\n  free(work);\n return 1;\n}\n", "target": 1, "flaw_line_index": "2,12,26,33,34,38,39,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105"}
{"idx": 8621, "func": "static void vmsvga_update_display(void *opaque)\n{\n    struct vmsvga_state_s *s = opaque;\n    DisplaySurface *surface;\n    bool dirty = false;\n\n    if (!s->enable) {\n        s->vga.hw_ops->gfx_update(&s->vga);\n        return;\n    }\n\n    vmsvga_check_size(s);\n    surface = qemu_console_surface(s->vga.con);\n\n    vmsvga_fifo_run(s);\n    vmsvga_update_rect_flush(s);\n\n    if (memory_region_is_logging(&s->vga.vram, DIRTY_MEMORY_VGA)) {\n        vga_sync_dirty_bitmap(&s->vga);\n        dirty = memory_region_get_dirty(&s->vga.vram, 0,\n            surface_stride(surface) * surface_height(surface),\n            DIRTY_MEMORY_VGA);\n    }\n    if (s->invalidated || dirty) {\n        s->invalidated = 0;\n        dpy_gfx_update(s->vga.con, 0, 0,\n                   surface_width(surface), surface_height(surface));\n    }\n    if (dirty) {\n        memory_region_reset_dirty(&s->vga.vram, 0,\n            surface_stride(surface) * surface_height(surface),\n            DIRTY_MEMORY_VGA);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9131, "func": "void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,\n                                            const char *debug_name)\n{\n   struct vrend_decode_ctx *dctx;\n\n   if (handle >= VREND_MAX_CTX)\n      return;\n\n   dctx = dec_ctx[handle];\n   if (dctx)\n      return;\n\n   dctx = malloc(sizeof(struct vrend_decode_ctx));\n   if (!dctx)\n      return;\n\n   dctx->grctx = vrend_create_context(handle, nlen, debug_name);\n   if (!dctx->grctx) {\n      free(dctx);\n      return;\n   }\n\n   dctx->ds = &dctx->ids;\n\n   dec_ctx[handle] = dctx;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8335, "func": "static void xhci_ep_kick_timer(void *opaque)\n{\n    XHCIEPContext *epctx = opaque;\n    xhci_kick_ep(epctx->xhci, epctx->slotid, epctx->epid, 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8967, "func": "bool net_tx_pkt_send_loopback(struct NetTxPkt *pkt, NetClientState *nc)\n{\n    bool res;\n\n    pkt->is_loopback = true;\n    res = net_tx_pkt_send(pkt, nc);\n    pkt->is_loopback = false;\n\n    return res;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187927, "func": "int sysMapFile(const char* fn, MemMapping* pMap)\n{\n    memset(pMap, 0, sizeof(*pMap));\n\n if (fn && fn[0] == '@') {\n FILE* mapf = fopen(fn+1, \"r\");\n if (mapf == NULL) {\n            LOGV(\"Unable to open '%s': %s\\n\", fn+1, strerror(errno));\n return -1;\n }\n\n \n         if (sysMapBlockFile(mapf, pMap) != 0) {\n             LOGW(\"Map of '%s' failed\\n\", fn);\n             return -1;\n         }\n \n        fclose(mapf);\n } else {\n int fd = open(fn, O_RDONLY, 0);\n if (fd < 0) {\n            LOGE(\"Unable to open '%s': %s\\n\", fn, strerror(errno));\n return -1;\n }\n\n if (sysMapFD(fd, pMap) != 0) {\n            LOGE(\"Map of '%s' failed\\n\", fn);\n            close(fd);\n return -1;\n }\n\n        close(fd);\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9053, "func": "static inline void vmxnet3_ring_inc(Vmxnet3Ring *ring)\n{\n    if (++ring->next >= ring->size) {\n        ring->next = 0;\n        ring->gen ^= 1;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187886, "func": "Segment::Segment(IMkvReader* pReader, long long elem_start,\n long long start, long long size)\n : m_pReader(pReader),\n      m_element_start(elem_start),\n      m_start(start),\n      m_size(size),\n      m_pos(start),\n      m_pUnknownSize(0),\n      m_pSeekHead(NULL),\n      m_pInfo(NULL),\n\n       m_pTracks(NULL),\n       m_pCues(NULL),\n       m_pChapters(NULL),\n       m_clusters(NULL),\n       m_clusterCount(0),\n       m_clusterPreloadCount(0),\n      m_clusterSize(0) {}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8373, "func": "static void mptsas_process_ioc_init(MPTSASState *s, MPIMsgIOCInit *req)\n{\n    MPIMsgIOCInitReply reply;\n\n    mptsas_fix_ioc_init_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    s->who_init               = req->WhoInit;\n    s->reply_frame_size       = req->ReplyFrameSize;\n    s->max_buses              = req->MaxBuses;\n    s->max_devices            = req->MaxDevices ? req->MaxDevices : 256;\n    s->host_mfa_high_addr     = (hwaddr)req->HostMfaHighAddr << 32;\n    s->sense_buffer_high_addr = (hwaddr)req->SenseBufferHighAddr << 32;\n\n    if (s->state == MPI_IOC_STATE_READY) {\n        s->state = MPI_IOC_STATE_OPERATIONAL;\n    }\n\n    memset(&reply, 0, sizeof(reply));\n    reply.WhoInit    = s->who_init;\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.Function   = req->Function;\n    reply.MaxDevices = s->max_devices;\n    reply.MaxBuses   = s->max_buses;\n    reply.MsgContext = req->MsgContext;\n\n    mptsas_fix_ioc_init_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8333, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    slot = &xhci->slots[slotid-1];\n\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    }\n\n    xhci_ep_nuke_xfers(xhci, slotid, epid, 0);\n\n    epctx = slot->eps[epid-1];\n\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    }\n\n    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) {\n        usb_packet_cleanup(&epctx->transfers[i].packet);\n    }\n\n    if (xhci->dcbaap_low || xhci->dcbaap_high) {\n        xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    }\n\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n\n    return CC_SUCCESS;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9147, "func": "static char uprcase( char c )\n{\n   if (c >= 'a' && c <= 'z')\n      return c + 'A' - 'a';\n   return c;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188541, "func": "   void RunAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n uint32_t max_error = 0;\n\n     int64_t total_error = 0;\n     const int count_test_block = 10000;\n     for (int i = 0; i < count_test_block; ++i) {\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n                                      test_temp_block, pitch_));\n      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n        total_error += error;\n\n       }\n     }\n \n    EXPECT_GE(1u, max_error)\n         << \"Error: 16x16 FHT/IHT has an individual round trip error > 1\";\n \n    EXPECT_GE(count_test_block , total_error)\n         << \"Error: 16x16 FHT/IHT has average round trip error > 1 per block\";\n   }\n", "target": 1, "flaw_line_index": "8,9,10,11,13,15,16,17,20,21,22,34,37"}
{"idx": 187431, "func": "static vpx_codec_err_t decoder_peek_si_internal(const uint8_t *data,\n unsigned int data_sz,\n vpx_codec_stream_info_t *si,\n int *is_intra_only,\n\n                                                 vpx_decrypt_cb decrypt_cb,\n                                                 void *decrypt_state) {\n   int intra_only_flag = 0;\n  uint8_t clear_buffer[9];\n \n   if (data + data_sz <= data)\n     return VPX_CODEC_INVALID_PARAM;\n\n  si->is_kf = 0;\n  si->w = si->h = 0;\n\n if (decrypt_cb) {\n    data_sz = VPXMIN(sizeof(clear_buffer), data_sz);\n    decrypt_cb(decrypt_state, data, clear_buffer, data_sz);\n\n     data = clear_buffer;\n   }\n \n   {\n     int show_frame;\n     int error_resilient;\n struct vpx_read_bit_buffer rb = { data, data + data_sz, 0, NULL, NULL };\n const int frame_marker = vpx_rb_read_literal(&rb, 2);\n const BITSTREAM_PROFILE profile = vp9_read_profile(&rb);\n\n if (frame_marker != VP9_FRAME_MARKER)\n return VPX_CODEC_UNSUP_BITSTREAM;\n\n\n     if (profile >= MAX_PROFILES)\n       return VPX_CODEC_UNSUP_BITSTREAM;\n \n    if ((profile >= 2 && data_sz <= 1) || data_sz < 1)\n      return VPX_CODEC_UNSUP_BITSTREAM;\n     if (vpx_rb_read_bit(&rb)) {  \n       vpx_rb_read_literal(&rb, 3);  \n       return VPX_CODEC_OK;\n     }\n \n    if (data_sz <= 8)\n       return VPX_CODEC_UNSUP_BITSTREAM;\n \n     si->is_kf = !vpx_rb_read_bit(&rb);\n    show_frame = vpx_rb_read_bit(&rb);\n    error_resilient = vpx_rb_read_bit(&rb);\n\n if (si->is_kf) {\n if (!vp9_read_sync_code(&rb))\n return VPX_CODEC_UNSUP_BITSTREAM;\n\n if (!parse_bitdepth_colorspace_sampling(profile, &rb))\n return VPX_CODEC_UNSUP_BITSTREAM;\n      vp9_read_frame_size(&rb, (int *)&si->w, (int *)&si->h);\n } else {\n      intra_only_flag = show_frame ? 0 : vpx_rb_read_bit(&rb);\n\n      rb.bit_offset += error_resilient ? 0 : 2; \n\n if (intra_only_flag) {\n if (!vp9_read_sync_code(&rb))\n return VPX_CODEC_UNSUP_BITSTREAM;\n if (profile > PROFILE_0) {\n if (!parse_bitdepth_colorspace_sampling(profile, &rb))\n return VPX_CODEC_UNSUP_BITSTREAM;\n }\n        rb.bit_offset += REF_FRAMES; \n        vp9_read_frame_size(&rb, (int *)&si->w, (int *)&si->h);\n }\n }\n }\n if (is_intra_only != NULL)\n *is_intra_only = intra_only_flag;\n return VPX_CODEC_OK;\n}\n", "target": 1, "flaw_line_index": "9,38,39,45"}
{"idx": 187958, "func": "status_t CameraService::dump(int fd, const Vector<String16>& args) {\n String8 result;\n if (checkCallingPermission(String16(\"android.permission.DUMP\")) == false) {\n        result.appendFormat(\"Permission Denial: \"\n \"can't dump CameraService from pid=%d, uid=%d\\n\",\n                getCallingPid(),\n                getCallingUid());\n        write(fd, result.string(), result.size());\n } else {\n bool locked = tryLock(mServiceLock);\n if (!locked) {\n            result.append(\"CameraService may be deadlocked\\n\");\n            write(fd, result.string(), result.size());\n }\n\n bool hasClient = false;\n if (!mModule) {\n            result = String8::format(\"No camera module available!\\n\");\n            write(fd, result.string(), result.size());\n return NO_ERROR;\n }\n\n        result = String8::format(\"Camera module HAL API version: 0x%x\\n\",\n                mModule->common.hal_api_version);\n        result.appendFormat(\"Camera module API version: 0x%x\\n\",\n                mModule->common.module_api_version);\n        result.appendFormat(\"Camera module name: %s\\n\",\n                mModule->common.name);\n        result.appendFormat(\"Camera module author: %s\\n\",\n                mModule->common.author);\n        result.appendFormat(\"Number of camera devices: %d\\n\\n\", mNumberOfCameras);\n        write(fd, result.string(), result.size());\n for (int i = 0; i < mNumberOfCameras; i++) {\n            result = String8::format(\"Camera %d static information:\\n\", i);\n            camera_info info;\n\n status_t rc = mModule->get_camera_info(i, &info);\n if (rc != OK) {\n                result.appendFormat(\"  Error reading static information!\\n\");\n                write(fd, result.string(), result.size());\n } else {\n                result.appendFormat(\"  Facing: %s\\n\",\n                        info.facing == CAMERA_FACING_BACK ? \"BACK\" : \"FRONT\");\n                result.appendFormat(\"  Orientation: %d\\n\", info.orientation);\n int deviceVersion;\n if (mModule->common.module_api_version <\n                        CAMERA_MODULE_API_VERSION_2_0) {\n                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;\n } else {\n                    deviceVersion = info.device_version;\n }\n                result.appendFormat(\"  Device version: 0x%x\\n\", deviceVersion);\n if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {\n                    result.appendFormat(\"  Device static metadata:\\n\");\n                    write(fd, result.string(), result.size());\n                    dump_indented_camera_metadata(info.static_camera_characteristics,\n                            fd, 2, 4);\n } else {\n                    write(fd, result.string(), result.size());\n }\n }\n\n            sp<BasicClient> client = mClient[i].promote();\n if (client == 0) {\n                result = String8::format(\"  Device is closed, no client instance\\n\");\n                write(fd, result.string(), result.size());\n continue;\n }\n\n             hasClient = true;\n             result = String8::format(\"  Device is open. Client instance dump:\\n\");\n             write(fd, result.string(), result.size());\n            client->dump(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\"\\nNo active camera clients yet.\\n\");\n            write(fd, result.string(), result.size());\n }\n\n if (locked) mServiceLock.unlock();\n\n        write(fd, \"\\n\", 1);\n        camera3::CameraTraces::dump(fd, args);\n\n int n = args.size();\n for (int i = 0; i + 1 < n; i++) {\n String16 verboseOption(\"-v\");\n if (args[i] == verboseOption) {\n String8 levelStr(args[i+1]);\n int level = atoi(levelStr.string());\n                result = String8::format(\"\\nSetting log level to %d.\\n\", level);\n                setLogLevel(level);\n                write(fd, result.string(), result.size());\n }\n }\n\n }\n return NO_ERROR;\n}\n", "target": 1, "flaw_line_index": "74"}
{"idx": 8831, "func": "int vrend_create_sampler_state(struct vrend_context *ctx,\n                               uint32_t handle,\n                               struct pipe_sampler_state *templ)\n{\n   struct vrend_sampler_state *state = CALLOC_STRUCT(vrend_sampler_state);\n   int ret_handle;\n\n   if (!state)\n      return ENOMEM;\n\n   state->base = *templ;\n\n   if (vrend_state.have_samplers) {\n      glGenSamplers(1, &state->id);\n\n      glSamplerParameteri(state->id, GL_TEXTURE_WRAP_S, convert_wrap(templ->wrap_s));\n      glSamplerParameteri(state->id, GL_TEXTURE_WRAP_T, convert_wrap(templ->wrap_t));\n      glSamplerParameteri(state->id, GL_TEXTURE_WRAP_R, convert_wrap(templ->wrap_r));\n      glSamplerParameterf(state->id, GL_TEXTURE_MIN_FILTER, convert_min_filter(templ->min_img_filter, templ->min_mip_filter));\n      glSamplerParameterf(state->id, GL_TEXTURE_MAG_FILTER, convert_mag_filter(templ->mag_img_filter));\n      glSamplerParameterf(state->id, GL_TEXTURE_MIN_LOD, templ->min_lod);\n      glSamplerParameterf(state->id, GL_TEXTURE_MAX_LOD, templ->max_lod);\n      glSamplerParameterf(state->id, GL_TEXTURE_LOD_BIAS, templ->lod_bias);\n      glSamplerParameteri(state->id, GL_TEXTURE_COMPARE_MODE, templ->compare_mode ? GL_COMPARE_R_TO_TEXTURE : GL_NONE);\n      glSamplerParameteri(state->id, GL_TEXTURE_COMPARE_FUNC, GL_NEVER + templ->compare_func);\n\n      glSamplerParameterIuiv(state->id, GL_TEXTURE_BORDER_COLOR, templ->border_color.ui);\n   }\n   ret_handle = vrend_renderer_object_insert(ctx, state, sizeof(struct vrend_sampler_state), handle,\n                                             VIRGL_OBJECT_SAMPLER_STATE);\n   if (!ret_handle) {\n      if (vrend_state.have_samplers)\n         glDeleteSamplers(1, &state->id);\n      FREE(state);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8895, "func": "void vrend_renderer_create_sub_ctx(struct vrend_context *ctx, int sub_ctx_id)\n{\n   struct vrend_sub_context *sub;\n   struct virgl_gl_ctx_param ctx_params;\n\n   LIST_FOR_EACH_ENTRY(sub, &ctx->sub_ctxs, head) {\n      if (sub->sub_ctx_id == sub_ctx_id) {\n         return;\n      }\n   }\n\n   sub = CALLOC_STRUCT(vrend_sub_context);\n   if (!sub)\n      return;\n\n   ctx_params.shared = (ctx->ctx_id == 0 && sub_ctx_id == 0) ? false : true;\n   ctx_params.major_ver = vrend_state.gl_major_ver;\n   ctx_params.minor_ver = vrend_state.gl_minor_ver;\n   sub->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   vrend_clicbs->make_current(0, sub->gl_context);\n\n   sub->sub_ctx_id = sub_ctx_id;\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      glGenVertexArrays(1, &sub->vaoid);\n      glBindVertexArray(sub->vaoid);\n   }\n\n   glGenFramebuffers(1, &sub->fb_id);\n   glGenFramebuffers(2, sub->blit_fb_ids);\n\n   list_inithead(&sub->programs);\n   list_inithead(&sub->streamout_list);\n\n   sub->object_hash = vrend_object_init_ctx_table();\n\n   ctx->sub = sub;\n   list_add(&sub->head, &ctx->sub_ctxs);\n   if (sub_ctx_id == 0)\n      ctx->sub0 = sub;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8733, "func": "static int check_trust(X509_STORE_CTX *ctx)\n{\n    int i, ok;\n    X509 *x = NULL;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    cb = ctx->verify_cb;\n    for (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {\n        x = sk_X509_value(ctx->chain, i);\n        ok = X509_check_trust(x, ctx->param->trust, 0);\n        if (ok == X509_TRUST_TRUSTED)\n            return X509_TRUST_TRUSTED;\n        if (ok == X509_TRUST_REJECTED) {\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ctx->error = X509_V_ERR_CERT_REJECTED;\n            ok = cb(0, ctx);\n            if (!ok)\n                return X509_TRUST_REJECTED;\n        }\n    }\n    if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n        X509 *mx;\n        if (ctx->last_untrusted < sk_X509_num(ctx->chain))\n            return X509_TRUST_TRUSTED;\n        x = sk_X509_value(ctx->chain, 0);\n        mx = lookup_cert_match(ctx, x);\n        if (mx) {\n            (void)sk_X509_set(ctx->chain, 0, mx);\n            X509_free(x);\n            ctx->last_untrusted = 0;\n            return X509_TRUST_TRUSTED;\n        }\n    }\n\n    return X509_TRUST_UNTRUSTED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8324, "func": "XSetModifierMapping(\n    register Display *dpy,\n    register XModifierKeymap *modifier_map)\n{\n    register xSetModifierMappingReq *req;\n    xSetModifierMappingReply rep;\n    int         mapSize = modifier_map->max_keypermod << 3;\t\n\n    LockDisplay(dpy);\n    GetReq(SetModifierMapping, req);\n    req->length += mapSize >> 2;\n    req->numKeyPerModifier = modifier_map->max_keypermod;\n\n    Data(dpy, modifier_map->modifiermap, mapSize);\n\n    (void) _XReply(dpy, (xReply *) & rep,\n\t(SIZEOF(xSetModifierMappingReply) - SIZEOF(xReply)) >> 2, xTrue);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (rep.success);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188074, "func": "WORD32 ihevcd_parse_transform_tree(codec_t *ps_codec,\n                                   WORD32 x0, WORD32 y0,\n                                   WORD32 cu_x_base, WORD32 cu_y_base,\n                                   WORD32 log2_trafo_size,\n                                   WORD32 trafo_depth,\n                                   WORD32 blk_idx,\n                                   WORD32 intra_pred_mode)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n sps_t *ps_sps;\n pps_t *ps_pps;\n    WORD32 value;\n    WORD32 x1, y1;\n    WORD32 max_trafo_depth;\n\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n    WORD32 intra_split_flag;\n    WORD32 split_transform_flag;\n    WORD32 ctxt_idx;\n cab_ctxt_t *ps_cabac = &ps_codec->s_parse.s_cabac;\n\n    max_trafo_depth = ps_codec->s_parse.s_cu.i4_max_trafo_depth;\n    ps_sps = ps_codec->s_parse.ps_sps;\n    ps_pps = ps_codec->s_parse.ps_pps;\n    intra_split_flag = ps_codec->s_parse.s_cu.i4_intra_split_flag;\n\n {\n        split_transform_flag = 0;\n if((log2_trafo_size <= ps_sps->i1_log2_max_transform_block_size) &&\n (log2_trafo_size > ps_sps->i1_log2_min_transform_block_size) &&\n (trafo_depth < max_trafo_depth) &&\n !(intra_split_flag && (trafo_depth == 0)))\n {\n            ctxt_idx = IHEVC_CAB_SPLIT_TFM + (5 - log2_trafo_size);\n\n            TRACE_CABAC_CTXT(\"split_transform_flag\", ps_cabac->u4_range, ctxt_idx);\n            split_transform_flag = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n            AEV_TRACE(\"split_transform_flag\", split_transform_flag,\n                      ps_cabac->u4_range);\n\n }\n else\n {\n            WORD32 inter_split_flag = 0;\n\n if((0 == ps_sps->i1_max_transform_hierarchy_depth_inter) &&\n (PRED_MODE_INTER == ps_codec->s_parse.s_cu.i4_pred_mode) &&\n (PART_2Nx2N != ps_codec->s_parse.s_cu.i4_part_mode) &&\n (0 == trafo_depth))\n {\n                inter_split_flag = 1;\n }\n\n if((log2_trafo_size > ps_sps->i1_log2_max_transform_block_size) ||\n ((1 == intra_split_flag) && (0 == trafo_depth)) ||\n (1 == inter_split_flag))\n {\n                split_transform_flag = 1;\n }\n }\n\n if(0 == trafo_depth)\n {\n            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = 0;\n            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = 0;\n }\n else\n {\n            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1];\n            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1];\n }\n if(trafo_depth == 0 || log2_trafo_size > 2)\n {\n            ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth;\n if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1])\n {\n                TRACE_CABAC_CTXT(\"cbf_cb\", ps_cabac->u4_range, ctxt_idx);\n                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n                AEV_TRACE(\"cbf_cb\", value, ps_cabac->u4_range);\n                ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = value;\n }\n\n if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1])\n {\n                TRACE_CABAC_CTXT(\"cbf_cr\", ps_cabac->u4_range, ctxt_idx);\n                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n                AEV_TRACE(\"cbf_cr\", value, ps_cabac->u4_range);\n                ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = value;\n }\n }\n if(split_transform_flag)\n {\n            WORD32 intra_pred_mode_tmp;\n            x1 = x0 + ((1 << log2_trafo_size) >> 1);\n            y1 = y0 + ((1 << log2_trafo_size) >> 1);\n\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];\n            ihevcd_parse_transform_tree(ps_codec, x0, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 0, intra_pred_mode_tmp);\n\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[1];\n            ihevcd_parse_transform_tree(ps_codec, x1, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 1, intra_pred_mode_tmp);\n\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[2];\n            ihevcd_parse_transform_tree(ps_codec, x0, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 2, intra_pred_mode_tmp);\n\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[3];\n            ihevcd_parse_transform_tree(ps_codec, x1, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 3, intra_pred_mode_tmp);\n\n }\n else\n {\n            WORD32 ctb_x_base;\n            WORD32 ctb_y_base;\n            WORD32 cu_qp_delta_abs;\n\n\n\n tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            cu_qp_delta_abs = 0;\n            ctb_x_base = ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size;\n            ctb_y_base = ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size;\n\n if((ps_codec->s_parse.s_cu.i4_pred_mode == PRED_MODE_INTRA) ||\n (trafo_depth != 0) ||\n (ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth]) ||\n (ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth]))\n {\n                ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX;\n                ctxt_idx += (trafo_depth == 0) ? 1 : 0;\n\n                TRACE_CABAC_CTXT(\"cbf_luma\", ps_cabac->u4_range, ctxt_idx);\n                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n                AEV_TRACE(\"cbf_luma\", value, ps_cabac->u4_range);\n\n                ps_codec->s_parse.s_cu.i1_cbf_luma = value;\n }\n else\n {\n                ps_codec->s_parse.s_cu.i1_cbf_luma = 1;\n }\n\n            ps_tu->b1_cb_cbf = 0;\n            ps_tu->b1_cr_cbf = 0;\n            ps_tu->b1_y_cbf = 0;\n            ps_tu->b4_pos_x = ((x0 - ctb_x_base) >> 2);\n            ps_tu->b4_pos_y = ((y0 - ctb_y_base) >> 2);\n            ps_tu->b1_transquant_bypass = ps_codec->s_parse.s_cu.i4_cu_transquant_bypass;\n            ps_tu->b3_size = (log2_trafo_size - 2);\n            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n\n            ps_tu->b6_luma_intra_mode = intra_pred_mode;\n            ps_tu->b3_chroma_intra_mode_idx = ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx;\n\n if(ps_codec->s_parse.s_cu.i1_cbf_luma ||\n                            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] ||\n                            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])\n {\n                WORD32 intra_pred_mode_chroma;\n if(ps_pps->i1_cu_qp_delta_enabled_flag && !ps_codec->s_parse.i4_is_cu_qp_delta_coded)\n {\n\n\n                    WORD32 c_max        = TU_MAX_QP_DELTA_ABS;\n                    WORD32 ctxt_inc     = IHEVC_CAB_QP_DELTA_ABS;\n                    WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS;\n\n                    TRACE_CABAC_CTXT(\"cu_qp_delta_abs\", ps_cabac->u4_range, ctxt_inc);\n                    cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary(ps_cabac,\n                                                                      ps_bitstrm,\n                                                                      c_max,\n                                                                      ctxt_inc,\n 0,\n                                                                      ctxt_inc_max);\n if(cu_qp_delta_abs >= c_max)\n {\n                        value = ihevcd_cabac_decode_bypass_bins_egk(ps_cabac, ps_bitstrm, 0);\n                        cu_qp_delta_abs += value;\n\n                     }\n                     AEV_TRACE(\"cu_qp_delta_abs\", cu_qp_delta_abs, ps_cabac->u4_range);\n \n                     ps_codec->s_parse.i4_is_cu_qp_delta_coded = 1;\n \n \n if(cu_qp_delta_abs)\n {\n                        value = ihevcd_cabac_decode_bypass_bin(ps_cabac, ps_bitstrm);\n                        AEV_TRACE(\"cu_qp_delta_sign\", value, ps_cabac->u4_range);\n\n if(value)\n\n                             cu_qp_delta_abs = -cu_qp_delta_abs;\n \n                     }\n                     ps_codec->s_parse.s_cu.i4_cu_qp_delta = cu_qp_delta_abs;\n \n                 }\n\n if(ps_codec->s_parse.s_cu.i1_cbf_luma)\n {\n                    ps_tu->b1_y_cbf = 1;\n                    ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size, 0, intra_pred_mode);\n }\n\n if(4 == ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx)\n                    intra_pred_mode_chroma = ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];\n else\n {\n                    intra_pred_mode_chroma = gau1_intra_pred_chroma_modes[ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx];\n\n if(intra_pred_mode_chroma ==\n                                    ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0])\n {\n                        intra_pred_mode_chroma = INTRA_ANGULAR(34);\n }\n\n }\n if(log2_trafo_size > 2)\n {\n if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])\n {\n                        ps_tu->b1_cb_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 1, intra_pred_mode_chroma);\n }\n\n if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])\n {\n                        ps_tu->b1_cr_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 2, intra_pred_mode_chroma);\n }\n }\n else if(blk_idx == 3)\n {\n if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])\n {\n                        ps_tu->b1_cb_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 1, intra_pred_mode_chroma);\n }\n\n if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])\n {\n                        ps_tu->b1_cr_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 2, intra_pred_mode_chroma);\n }\n }\n else\n {\n                    ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n }\n }\n else\n {\n if((3 != blk_idx) && (2 == log2_trafo_size))\n {\n                    ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n }\n }\n\n {\n if((ps_codec->s_parse.s_cu.i4_pos_x << 3) == (ps_tu->b4_pos_x << 2) &&\n (ps_codec->s_parse.s_cu.i4_pos_y << 3) == (ps_tu->b4_pos_y << 2))\n {\n                    ps_tu->b1_first_tu_in_cu = 1;\n }\n else\n {\n                    ps_tu->b1_first_tu_in_cu = 0;\n }\n }\n            ps_codec->s_parse.ps_tu++;\n            ps_codec->s_parse.s_cu.i4_tu_cnt++;\n            ps_codec->s_parse.i4_pic_tu_idx++;\n }\n }\n return ret;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187868, "func": "long Cluster::Parse(long long& pos, long& len) const {\n long status = Load(pos, len);\n\n if (status < 0)\n return status;\n\n  assert(m_pos >= m_element_start);\n  assert(m_timecode >= 0);\n\n const long long cluster_stop =\n (m_element_size < 0) ? -1 : m_element_start + m_element_size;\n\n if ((cluster_stop >= 0) && (m_pos >= cluster_stop))\n return 1; \n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long total, avail;\n\n  status = pReader->Length(&total, &avail);\n\n if (status < 0) \n return status;\n\n  assert((total < 0) || (avail <= total));\n\n  pos = m_pos;\n\n for (;;) {\n if ((cluster_stop >= 0) && (pos >= cluster_stop))\n break;\n\n if ((total >= 0) && (pos >= total)) {\n if (m_element_size < 0)\n        m_element_size = pos - m_element_start;\n\n break;\n }\n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long id = ReadUInt(pReader, pos, len);\n\n if (id < 0) \n return static_cast<long>(id);\n\n if (id == 0) \n return E_FILE_FORMAT_INVALID;\n\n\n if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) { \n if (m_element_size < 0)\n        m_element_size = pos - m_element_start;\n\n break;\n }\n\n    pos += len; \n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) \n return static_cast<long>(result);\n\n if (result > 0) \n return E_BUFFER_NOT_FULL;\n\n if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(pReader, pos, len);\n\n if (size < 0) \n return static_cast<long>(size);\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID;\n\n    pos += len; \n\n if ((cluster_stop >= 0) && (pos > cluster_stop))\n return E_FILE_FORMAT_INVALID;\n\n\n if (size == 0) \n continue;\n\n const long long block_stop = pos + size;\n\n if (cluster_stop >= 0) {\n if (block_stop > cluster_stop) {\n if ((id == 0x20) || (id == 0x23))\n return E_FILE_FORMAT_INVALID;\n\n        pos = cluster_stop;\n break;\n }\n } else if ((total >= 0) && (block_stop > total)) {\n      m_element_size = total - m_element_start;\n      pos = total;\n break;\n } else if (block_stop > avail) {\n      len = static_cast<long>(size);\n return E_BUFFER_NOT_FULL;\n }\n\n Cluster* const this_ = const_cast<Cluster*>(this);\n\n if (id == 0x20) \n return this_->ParseBlockGroup(size, pos, len);\n\n if (id == 0x23) \n\n       return this_->ParseSimpleBlock(size, pos, len);\n \n     pos += size;  \n    assert((cluster_stop < 0) || (pos <= cluster_stop));\n   }\n \n   assert(m_element_size > 0);\n \n   m_pos = pos;\n  assert((cluster_stop < 0) || (m_pos <= cluster_stop));\n \n   if (m_entries_count > 0) {\n     const long idx = m_entries_count - 1;\n\n const BlockEntry* const pLast = m_entries[idx];\n    assert(pLast);\n\n const Block* const pBlock = pLast->GetBlock();\n    assert(pBlock);\n\n const long long start = pBlock->m_start;\n\n if ((total >= 0) && (start > total))\n return -1; \n\n const long long size = pBlock->m_size;\n\n const long long stop = start + size;\n    assert((cluster_stop < 0) || (stop <= cluster_stop));\n\n if ((total >= 0) && (stop > total))\n return -1; \n }\n\n return 1; \n}\n", "target": 1, "flaw_line_index": "155,161"}
{"idx": 187645, "func": "image_transform_mod_end(PNG_CONST image_transform *this, image_pixel *that,\n    png_const_structp pp, PNG_CONST transform_display *display)\n {\n   PNG_CONST unsigned int scale = (1U<<that->sample_depth)-1;\n \n    UNUSED(this)\n    UNUSED(pp)\n   UNUSED(display)\n\n    that->red = sample_scale(that->redf, scale);\n \n   that->rede += 1./(2*((1U<<that->red_sBIT)-1));\n\n\n    if (that->colour_type & PNG_COLOR_MASK_COLOR)\n    {\n       that->green = sample_scale(that->greenf, scale);\n       that->blue = sample_scale(that->bluef, scale);\n       that->greene += 1./(2*((1U<<that->green_sBIT)-1));\n       that->bluee += 1./(2*((1U<<that->blue_sBIT)-1));\n    }\n else\n {\n      that->blue = that->green = that->red;\n      that->bluef = that->greenf = that->redf;\n      that->bluee = that->greene = that->rede;\n }\n\n if ((that->colour_type & PNG_COLOR_MASK_ALPHA) ||\n      that->colour_type == PNG_COLOR_TYPE_PALETTE)\n {\n      that->alpha = sample_scale(that->alphaf, scale);\n      that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1));\n }\n\n    else\n    {\n       that->alpha = scale; \n      that->alpha = 1;     \n       that->alphae = 0;    \n    }\n }\n", "target": 1, "flaw_line_index": "2,4,39"}
{"idx": 187777, "func": "int effect_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData)\n{\n\n effect_context_t * context = (effect_context_t *)self;\n int retsize;\n int status = 0;\n\n    pthread_mutex_lock(&lock);\n\n if (!effect_exists(context)) {\n        status = -ENOSYS;\n goto exit;\n }\n\n if (context == NULL || context->state == EFFECT_STATE_UNINITIALIZED) {\n        status = -ENOSYS;\n goto exit;\n }\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n if (context->ops.init)\n *(int *) pReplyData = context->ops.init(context);\n else\n *(int *) pReplyData = 0;\n break;\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n || pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n *(int *) pReplyData = set_config(context, (effect_config_t *) pCmdData);\n break;\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL ||\n *replySize != sizeof(effect_config_t)) {\n            status = -EINVAL;\n goto exit;\n }\n if (!context->offload_enabled) {\n            status = -EINVAL;\n goto exit;\n }\n\n        get_config(context, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n if (context->ops.reset)\n            context->ops.reset(context);\n break;\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n if (context->state != EFFECT_STATE_INITIALIZED) {\n            status = -ENOSYS;\n goto exit;\n }\n        context->state = EFFECT_STATE_ACTIVE;\n if (context->ops.enable)\n            context->ops.enable(context);\n        ALOGV(\"%s EFFECT_CMD_ENABLE\", __func__);\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n if (context->state != EFFECT_STATE_ACTIVE) {\n            status = -ENOSYS;\n goto exit;\n }\n        context->state = EFFECT_STATE_INITIALIZED;\n if (context->ops.disable)\n            context->ops.disable(context);\n        ALOGV(\"%s EFFECT_CMD_DISABLE\", __func__);\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_GET_PARAM: {\n\n         if (pCmdData == NULL ||\n             cmdSize < (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n             pReplyData == NULL ||\n            *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) +\n                               sizeof(uint16_t))) {\n             status = -EINVAL;\n             ALOGV(\"EFFECT_CMD_GET_PARAM invalid command cmdSize %d *replySize %d\",\n                   cmdSize, *replySize);\n goto exit;\n }\n if (!context->offload_enabled) {\n            status = -EINVAL;\n goto exit;\n }\n effect_param_t *q = (effect_param_t *)pCmdData;\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + q->psize);\n effect_param_t *p = (effect_param_t *)pReplyData;\n if (context->ops.get_parameter)\n            context->ops.get_parameter(context, p, replySize);\n } break;\n case EFFECT_CMD_SET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) +\n sizeof(uint16_t)) ||\n            pReplyData == NULL || *replySize != sizeof(int32_t)) {\n            status = -EINVAL;\n            ALOGV(\"EFFECT_CMD_SET_PARAM invalid command cmdSize %d *replySize %d\",\n                  cmdSize, *replySize);\n goto exit;\n }\n *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (context->ops.set_parameter)\n *(int32_t *)pReplyData = context->ops.set_parameter(context, p,\n *replySize);\n\n } break;\n case EFFECT_CMD_SET_DEVICE: {\n uint32_t device;\n        ALOGV(\"\\t EFFECT_CMD_SET_DEVICE start\");\n if (pCmdData == NULL || cmdSize < sizeof(uint32_t)) {\n            status = -EINVAL;\n            ALOGV(\"EFFECT_CMD_SET_DEVICE invalid command cmdSize %d\", cmdSize);\n goto exit;\n }\n        device = *(uint32_t *)pCmdData;\n if (context->ops.set_device)\n            context->ops.set_device(context, device);\n } break;\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n case EFFECT_CMD_OFFLOAD: {\n output_context_t *out_ctxt;\n\n if (cmdSize != sizeof(effect_offload_param_t) || pCmdData == NULL\n || pReplyData == NULL || *replySize != sizeof(int)) {\n            ALOGV(\"%s EFFECT_CMD_OFFLOAD bad format\", __func__);\n            status = -EINVAL;\n break;\n }\n\n effect_offload_param_t* offload_param = (effect_offload_param_t*)pCmdData;\n\n        ALOGV(\"%s EFFECT_CMD_OFFLOAD offload %d output %d\", __func__,\n              offload_param->isOffload, offload_param->ioHandle);\n\n *(int *)pReplyData = 0;\n\n        context->offload_enabled = offload_param->isOffload;\n if (context->out_handle == offload_param->ioHandle)\n break;\n\n        out_ctxt = get_output(context->out_handle);\n if (out_ctxt != NULL)\n            remove_effect_from_output(out_ctxt, context);\n\n        context->out_handle = offload_param->ioHandle;\n        out_ctxt = get_output(context->out_handle);\n if (out_ctxt != NULL)\n            add_effect_to_output(out_ctxt, context);\n\n } break;\n\n\n default:\n if (cmdCode >= EFFECT_CMD_FIRST_PROPRIETARY && context->ops.command)\n            status = context->ops.command(context, cmdCode, cmdSize,\n                                          pCmdData, replySize, pReplyData);\n else {\n            ALOGW(\"%s invalid command %d\", __func__, cmdCode);\n            status = -EINVAL;\n }\n break;\n }\n\nexit:\n    pthread_mutex_unlock(&lock);\n\n return status;\n}\n", "target": 1, "flaw_line_index": "92,93"}
{"idx": 187974, "func": " UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;\n }\n    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +\n        MB_ADDR_INCR_OFFSET;\n return(u2_mb_addr_incr);\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8699, "func": "strpbrk_or_eos (const char *s, const char *accept)\n{\n  char *p = strpbrk (s, accept);\n  if (!p)\n    p = strchr (s, '\\0');\n  return p;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187885, "func": "long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {\n const long status = GetFirst(pResult);\n\n if (status < 0) \n return status;\n\n  assert(pResult);\n\n if (pResult->EOS())\n return 0;\n\n const Cluster* pCluster = pResult->GetCluster();\n  assert(pCluster);\n  assert(pCluster->GetIndex() >= 0);\n\n if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n return 0;\n\n Cluster** const clusters = m_pSegment->m_clusters;\n  assert(clusters);\n\n const long count = m_pSegment->GetCount(); \n  assert(count > 0);\n\n Cluster** const i = clusters + pCluster->GetIndex();\n  assert(i);\n  assert(*i == pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n Cluster** const j = clusters + count;\n\n Cluster** lo = i;\n Cluster** hi = j;\n\n while (lo < hi) {\n\n Cluster** const mid = lo + (hi - lo) / 2;\n    assert(mid < hi);\n\n    pCluster = *mid;\n    assert(pCluster);\n    assert(pCluster->GetIndex() >= 0);\n    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n\n const long long t = pCluster->GetTime();\n\n if (t <= time_ns)\n      lo = mid + 1;\n else\n      hi = mid;\n\n    assert(lo <= hi);\n }\n\n  assert(lo == hi);\n  assert(lo > i);\n  assert(lo <= j);\n\n  pCluster = *--lo;\n  assert(pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n  pResult = pCluster->GetEntry(this, time_ns);\n\n if ((pResult != 0) && !pResult->EOS()) \n return 0;\n\n while (lo != i) {\n    pCluster = *--lo;\n\n     assert(pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n#if 0\n        pResult = pCluster->GetMaxKey(this);\n#else\n     pResult = pCluster->GetEntry(this, time_ns);\n#endif\n \n     if ((pResult != 0) && !pResult->EOS())\n       return 0;\n }\n\n\n  pResult = GetEOS();\n return 0;\n}\n", "target": 1, "flaw_line_index": "78,79,80,81,82,83,84,85,87"}
{"idx": 187981, "func": "status_t BnCrypto::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(initCheck());\n\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(isCryptoSchemeSupported(uuid));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n\n size_t opaqueSize = data.readInt32();\n void *opaqueData = NULL;\n\n if (opaqueSize > 0) {\n                opaqueData = malloc(opaqueSize);\n                data.read(opaqueData, opaqueSize);\n }\n\n            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));\n\n if (opaqueData != NULL) {\n                free(opaqueData);\n                opaqueData = NULL;\n }\n\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(destroyPlugin());\n\n return OK;\n }\n\n case REQUIRES_SECURE_COMPONENT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n const char *mime = data.readCString();\n            reply->writeInt32(requiresSecureDecoderComponent(mime));\n\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n bool secure = data.readInt32() != 0;\n CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();\n\n uint8_t key[16];\n            data.read(key, sizeof(key));\n\n uint8_t iv[16];\n            data.read(iv, sizeof(iv));\n\n size_t totalSize = data.readInt32();\n            sp<IMemory> sharedBuffer =\n                interface_cast<IMemory>(data.readStrongBinder());\n int32_t offset = data.readInt32();\n\n int32_t numSubSamples = data.readInt32();\n\n CryptoPlugin::SubSample *subSamples =\n new CryptoPlugin::SubSample[numSubSamples];\n\n            data.read(\n                    subSamples,\n sizeof(CryptoPlugin::SubSample) * numSubSamples);\n\n void *secureBufferId, *dstPtr;\n if (secure) {\n                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));\n } else {\n                dstPtr = calloc(1, totalSize);\n }\n\n AString errorDetailMsg;\n ssize_t result;\n\n size_t sumSubsampleSizes = 0;\n bool overflow = false;\n for (int32_t i = 0; i < numSubSamples; ++i) {\n CryptoPlugin::SubSample &ss = subSamples[i];\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {\n                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;\n } else {\n                    overflow = true;\n }\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {\n                    sumSubsampleSizes += ss.mNumBytesOfClearData;\n } else {\n                    overflow = true;\n }\n }\n\n \n             if (overflow || sumSubsampleSizes != totalSize) {\n                 result = -EINVAL;\n            } else if (offset + totalSize > sharedBuffer->size()) {\n                 result = -EINVAL;\n             } else {\n                 result = decrypt(\n                    secure,\n                    key,\n                    iv,\n                    mode,\n                    sharedBuffer, offset,\n                    subSamples, numSubSamples,\n                    secure ? secureBufferId : dstPtr,\n &errorDetailMsg);\n }\n\n            reply->writeInt32(result);\n\n if (isCryptoError(result)) {\n                reply->writeCString(errorDetailMsg.c_str());\n }\n\n if (!secure) {\n if (result >= 0) {\n                    CHECK_LE(result, static_cast<ssize_t>(totalSize));\n                    reply->write(dstPtr, result);\n }\n                free(dstPtr);\n                dstPtr = NULL;\n }\n\n delete[] subSamples;\n            subSamples = NULL;\n\n return OK;\n }\n\n case NOTIFY_RESOLUTION:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n int32_t width = data.readInt32();\n int32_t height = data.readInt32();\n            notifyResolution(width, height);\n\n return OK;\n }\n\n case SET_MEDIADRM_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(setMediaDrmSession(sessionId));\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "121"}
{"idx": 188233, "func": "OMX_ERRORTYPE SoftMP3::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioMp3:\n {\n\n             OMX_AUDIO_PARAM_MP3TYPE *mp3Params =\n                 (OMX_AUDIO_PARAM_MP3TYPE *)params;\n \n             if (mp3Params->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mp3Params->nChannels = mNumChannels;\n            mp3Params->nBitRate = 0 \n;\n            mp3Params->nSampleRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187725, "func": "store_current_palette(png_store *ps, int *npalette)\n{\n    if (ps->current == NULL)\n       store_log(ps, ps->pread, \"no current stream for palette\", 1);\n \n    *npalette = ps->current->npalette;\n return ps->current->palette;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187541, "func": "OMX_ERRORTYPE  omx_video::allocate_input_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes)\n{\n (void)hComp, (void)port;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned   i = 0;\n\n    DEBUG_PRINT_HIGH(\"allocate_input_buffer()::\");\n if (bytes != m_sInPortDef.nBufferSize) {\n        DEBUG_PRINT_ERROR(\"ERROR: Buffer size mismatch error: bytes[%u] != nBufferSize[%u]\",\n (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);\n return OMX_ErrorBadParameter;\n }\n\n if (!m_inp_mem_ptr) {\n        DEBUG_PRINT_HIGH(\"%s: size = %u, actual cnt %u\", __FUNCTION__,\n (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountActual);\n        m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\\n                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);\n if (m_inp_mem_ptr == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");\n return OMX_ErrorInsufficientResources;\n }\n\n        DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);\n        m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);\n\n if (m_pInput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n#ifdef USE_ION\n        m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);\n if (m_pInput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n            m_pInput_pmem[i].fd = -1;\n#ifdef USE_ION\n            m_pInput_ion[i].ion_device_fd =-1;\n            m_pInput_ion[i].fd_ion_data.fd =-1;\n            m_pInput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n }\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_inp_bm_count,i)) {\n break;\n }\n }\n if (i < m_sInPortDef.nBufferCountActual) {\n\n *bufferHdr = (m_inp_mem_ptr + i);\n (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);\n (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;\n (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;\n (*bufferHdr)->pAppPrivate       = appData;\n (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;\n (*bufferHdr)->pInputPortPrivate = (OMX_PTR)&m_pInput_pmem[i];\n\n#ifdef USE_ION\n#ifdef _MSM8974_\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,0);\n#else\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pInput_ion[i].ion_device_fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n\n        m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;\n#else\n        m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n\n if (m_pInput_pmem[i].fd == 0) {\n            m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pInput_pmem[i].fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n        m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n        m_pInput_pmem[i].offset = 0;\n\n        m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n if(!secure_session) {\n            m_pInput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,\n                MAP_SHARED,m_pInput_pmem[i].fd,0);\n if (m_pInput_pmem[i].buffer == MAP_FAILED) {\n                DEBUG_PRINT_ERROR(\"ERROR: mmap FAILED= %d\", errno);\n            close(m_pInput_pmem[i].fd);\n#ifdef USE_ION\n            free_ion_memory(&m_pInput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n } else {\n\n             m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));\n         }\n \n         (*bufferHdr)->pBuffer           = (OMX_U8 *)m_pInput_pmem[i].buffer;\n        DEBUG_PRINT_LOW(\"Virtual address in allocate buffer is %p\", m_pInput_pmem[i].buffer);\n        BITMASK_SET(&m_inp_bm_count,i);\n if (!mUseProxyColorFormat && (dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true)) {\n            DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf FAILED for i/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: All i/p buffers are allocated, invalid allocate buf call\"\n \"for index [%d]\", i);\n        eRet = OMX_ErrorInsufficientResources;\n }\n\n return eRet;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187911, "func": "static int aacDecoder_drcExtractAndMap (\n        HANDLE_AAC_DRC  self,\n        HANDLE_FDK_BITSTREAM hBs,\n CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo[],\n        UCHAR  pceInstanceTag,\n        UCHAR  channelMapping[], \n int    validChannels )\n{\n CDrcPayload  threadBs[MAX_DRC_THREADS];\n CDrcPayload *validThreadBs[MAX_DRC_THREADS];\n CDrcParams *pParams;\n  UINT backupBsPosition;\n int  i, thread, validThreads = 0;\n int  numExcludedChns[MAX_DRC_THREADS];\n\n  FDK_ASSERT(self != NULL);\n  FDK_ASSERT(hBs != NULL);\n  FDK_ASSERT(pAacDecoderStaticChannelInfo != NULL);\n\n  pParams = &self->params;\n\n  self->numThreads = 0;\n  backupBsPosition = FDKgetValidBits(hBs);\n\n for (i = 0; i < self->numPayloads && self->numThreads < MAX_DRC_THREADS; i++) {\n int bitsParsed;\n\n FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\n    threadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\n\n    bitsParsed = aacDecoder_drcParse( hBs,\n &threadBs[self->numThreads],\n                                      self->drcPayloadPosition[i] );\n if (bitsParsed > 0) {\n      self->numThreads++;\n }\n\n   }\n   self->numPayloads = 0;\n \n   if (self->dvbAncDataAvailable)\n   { \n     int bitsParsed;\n\n FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\n    threadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\n\n    bitsParsed = aacDecoder_drcReadCompression( hBs,\n &threadBs[self->numThreads],\n                                                self->dvbAncDataPosition );\n if (bitsParsed > 0) {\n      self->numThreads++;\n }\n }\n  self->dvbAncDataAvailable = 0;\n\n FDKpushBiDirectional(hBs, FDKgetValidBits(hBs) - backupBsPosition);\n\n\n \n \n   for (thread = 0; thread < self->numThreads; thread++) {\n     CDrcPayload *pThreadBs = &threadBs[thread];\n int numExclChns = 0;\n\n switch ((AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType) {\n default:\n continue;\n case MPEG_DRC_EXT_DATA:\n case DVB_DRC_ANC_DATA:\n break;\n }\n\n if (pThreadBs->pceInstanceTag >= 0) { \n if (pThreadBs->pceInstanceTag != pceInstanceTag) {\n continue; \n }\n }\n\n if (pThreadBs->excludedChnsMask > 0) {\n      INT exclMask = pThreadBs->excludedChnsMask;\n int ch;\n for (ch = 0; ch < validChannels; ch++) {\n        numExclChns += exclMask & 0x1;\n        exclMask >>= 1;\n }\n }\n if (numExclChns < validChannels) {\n      validThreadBs[validThreads] = pThreadBs;\n      numExcludedChns[validThreads] = numExclChns;\n      validThreads++;\n }\n }\n\n if (validThreads > 1) {\n int ch;\n\n for (ch = 0; ch < validChannels; ch++) {\n int present = 0;\n\n for (thread = 0; thread < validThreads; thread++) {\n CDrcPayload *pThreadBs = validThreadBs[thread];\n\n\n if ( (pThreadBs->channelData.drcDataType == MPEG_DRC_EXT_DATA)\n && ( (numExcludedChns[thread] == 0)\n || (!(pThreadBs->excludedChnsMask & (1<<ch))) ) ) {\n          present++;\n }\n }\n\n\n if (present > 1) {\n return -1;\n }\n }\n }\n\n for (thread = 0; thread < validThreads; thread++)\n {\n CDrcPayload *pThreadBs = validThreadBs[thread];\n    INT exclMask = pThreadBs->excludedChnsMask;\n    AACDEC_DRC_PAYLOAD_TYPE drcPayloadType = (AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType;\n int ch;\n\n if (pThreadBs->progRefLevel >= 0) {\n      self->progRefLevel = pThreadBs->progRefLevel;\n      self->progRefLevelPresent = 1;\n      self->prlExpiryCount = 0; \n }\n\n if (drcPayloadType == DVB_DRC_ANC_DATA) {\n      self->presMode = pThreadBs->presMode;\n }\n\n for (ch = 0; ch < validChannels; ch++) {\n int mapedChannel = channelMapping[ch];\n\n if ( ((exclMask & (1<<mapedChannel)) == 0)\n && ( (drcPayloadType == MPEG_DRC_EXT_DATA)\n || ((drcPayloadType == DVB_DRC_ANC_DATA) && self->params.applyHeavyCompression)\n ) ) {\n        pAacDecoderStaticChannelInfo[ch]->drcData = pThreadBs->channelData;\n }\n }\n }\n\n if ( (pParams->expiryFrame > 0)\n && (self->prlExpiryCount++ > pParams->expiryFrame) )\n { \n    self->progRefLevelPresent = 0;\n    self->progRefLevel = pParams->targetRefLevel;\n    self->prlExpiryCount = 0;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9223, "func": "hwaddr virtio_queue_get_used_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.used;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8966, "func": "bool net_tx_pkt_send(struct NetTxPkt *pkt, NetClientState *nc)\n{\n    assert(pkt);\n\n    if (!pkt->has_virt_hdr &&\n        pkt->virt_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n        net_tx_pkt_do_sw_csum(pkt);\n    }\n\n    if (VIRTIO_NET_HDR_GSO_NONE != pkt->virt_hdr.gso_type) {\n        if (pkt->payload_len >\n            ETH_MAX_IP_DGRAM_LEN -\n            pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len) {\n            return false;\n        }\n    }\n\n    if (pkt->has_virt_hdr ||\n        pkt->virt_hdr.gso_type == VIRTIO_NET_HDR_GSO_NONE) {\n        net_tx_pkt_sendv(pkt, nc, pkt->vec,\n            pkt->payload_frags + NET_TX_PKT_PL_START_FRAG);\n        return true;\n    }\n\n    return net_tx_pkt_do_sw_fragmentation(pkt, nc);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8311, "func": "XFixesInvertRegion (Display *dpy, XserverRegion dst,\n\t\t    XRectangle *rect, XserverRegion src)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesInvertRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesInvertRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesInvertRegion;\n    req->x = rect->x;\n    req->y = rect->y;\n    req->width = rect->width;\n    req->height = rect->height;\n    req->source = src;\n    req->destination = dst;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187610, "func": "display_log(struct display *dp, error_level level, const char *fmt, ...)\n{\n   dp->results |= 1U << level;\n\n if (level > (error_level)(dp->options & LEVEL_MASK))\n {\n const char *lp;\n      va_list ap;\n\n switch (level)\n {\n case INFORMATION:    lp = \"information\"; break;\n case LIBPNG_WARNING: lp = \"warning(libpng)\"; break;\n case APP_WARNING:    lp = \"warning(pngimage)\"; break;\n case APP_FAIL:       lp = \"error(continuable)\"; break;\n case LIBPNG_ERROR:   lp = \"error(libpng)\"; break;\n case LIBPNG_BUG:     lp = \"bug(libpng)\"; break;\n case APP_ERROR:      lp = \"error(pngimage)\"; break;\n case USER_ERROR:     lp = \"error(user)\"; break;\n\n case INTERNAL_ERROR: \n case VERBOSE: case WARNINGS: case ERRORS: case QUIET:\n default:             lp = \"bug(pngimage)\"; break;\n }\n\n      fprintf(stderr, \"%s: %s: %s\",\n         dp->filename != NULL ? dp->filename : \"<stdin>\", lp, dp->operation);\n\n if (dp->transforms != 0)\n {\n\n          int tr = dp->transforms;\n \n          if (is_combo(tr))\n            fprintf(stderr, \"(0x%x)\", tr);\n \n          else\n             fprintf(stderr, \"(%s)\", transform_name(tr));\n }\n\n      fprintf(stderr, \": \");\n\n      va_start(ap, fmt);\n      vfprintf(stderr, fmt, ap);\n      va_end(ap);\n\n      fputc('\\n', stderr);\n }\n\n if (level > APP_FAIL || (level > ERRORS && !(dp->options & CONTINUE)))\n      longjmp(dp->error_return, level);\n}\n", "target": 1, "flaw_line_index": "35"}
{"idx": 8506, "func": "static void c_write(Ssh ssh, const char *buf, int len)\n{\n    if (flags & FLAG_STDERR)\n\tc_write_stderr(1, buf, len);\n    else\n\tfrom_backend(ssh->frontend, 1, buf, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8595, "func": "static unsigned int ssh_tty_parse_boolean(char *s)\n{\n    if (stricmp(s, \"yes\") == 0 ||\n\tstricmp(s, \"on\") == 0 ||\n\tstricmp(s, \"true\") == 0 ||\n\tstricmp(s, \"+\") == 0)\n\treturn 1; \n    else if (stricmp(s, \"no\") == 0 ||\n\t     stricmp(s, \"off\") == 0 ||\n\t     stricmp(s, \"false\") == 0 ||\n\t     stricmp(s, \"-\") == 0)\n\treturn 0; \n    else\n\treturn (atoi(s) != 0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187956, "func": "int Effect_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n EffectContext * pContext = (EffectContext *) self;\n int retsize;\n\n\n if(pContext->EffectType == LVM_BASS_BOOST){\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n }\n if(pContext->EffectType == LVM_VOLUME){\n }\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Effect_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d\",\n                        pContext->EffectType);\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n if(pContext->EffectType == LVM_BASS_BOOST){\n                android::BassSetStrength(pContext, 0);\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n                android::VirtualizerSetStrength(pContext, 0);\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n                android::EqualizerSetPreset(pContext, 0);\n }\n if(pContext->EffectType == LVM_VOLUME){\n *(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);\n }\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData    == NULL || cmdSize     != sizeof(effect_config_t) ||\n                    pReplyData  == NULL || replySize == NULL || *replySize  != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n            android::Effect_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n\n \n             effect_param_t *p = (effect_param_t *)pCmdData;\n             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                     cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                     pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n if(pContext->EffectType == LVM_BASS_BOOST){\n                p->status = android::BassBoost_getParameter(pContext,\n                                                            p->data,\n (size_t *)&p->vsize,\n                                                            p->data + voffset);\n }\n\n if(pContext->EffectType == LVM_VIRTUALIZER){\n                p->status = android::Virtualizer_getParameter(pContext,\n (void *)p->data,\n (size_t *)&p->vsize,\n                                                              p->data + voffset);\n\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n                p->status = android::Equalizer_getParameter(pContext,\n                                                            p->data,\n &p->vsize,\n                                                            p->data + voffset);\n\n }\n if(pContext->EffectType == LVM_VOLUME){\n                p->status = android::Volume_getParameter(pContext,\n (void *)p->data,\n (size_t *)&p->vsize,\n                                                         p->data + voffset);\n\n }\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n if(pContext->EffectType == LVM_BASS_BOOST){\n\n if (pCmdData   == NULL ||\n                        cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::BassBoost_setParameter(pContext,\n (void *)p->data,\n                                                                    p->data + p->psize);\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n\n if (pCmdData   == NULL ||\n                        cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::Virtualizer_setParameter(pContext,\n (void *)p->data,\n                                                                       p->data + p->psize);\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n\n if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n *(int *)pReplyData = android::Equalizer_setParameter(pContext,\n (void *)p->data,\n                                                                     p->data + p->psize);\n }\n if(pContext->EffectType == LVM_VOLUME){\n\n if (pCmdData   == NULL ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL ||\n *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n *(int *)pReplyData = android::Volume_setParameter(pContext,\n (void *)p->data,\n                                                                 p->data + p->psize);\n }\n } break;\n\n case EFFECT_CMD_ENABLE:\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start\");\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n\n *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);\n break;\n\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n {\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start\");\n if (pCmdData   == NULL){\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR\");\n return -EINVAL;\n }\n\n uint32_t device = *(uint32_t *)pCmdData;\n\n if (pContext->EffectType == LVM_BASS_BOOST) {\n if((device == AUDIO_DEVICE_OUT_SPEAKER) ||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST\");\n\n\n if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;\n } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n\n\n if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;\n }\n }\n if (pContext->EffectType == LVM_VIRTUALIZER) {\n if((device == AUDIO_DEVICE_OUT_SPEAKER)||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT)||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER\");\n\n\n if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n }\n                    pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;\n } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n\n\n if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n }\n                    pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;\n }\n }\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end\");\n break;\n }\n case EFFECT_CMD_SET_VOLUME:\n {\n uint32_t leftVolume, rightVolume;\n int16_t  leftdB, rightdB;\n int16_t  maxdB, pandB;\n int32_t  vol_ret[2] = {1<<24,1<<24}; \n int      status = 0;\n LVM_ControlParams_t ActiveParams; \n            LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; \n\n if(pReplyData == LVM_NULL){\n break;\n }\n\n if (pCmdData == NULL || cmdSize != 2 * sizeof(uint32_t) || pReplyData == NULL ||\n                    replySize == NULL || *replySize < 2*sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n            leftVolume  = ((*(uint32_t *)pCmdData));\n            rightVolume = ((*((uint32_t *)pCmdData + 1)));\n\n if(leftVolume == 0x1000000){\n                leftVolume -= 1;\n }\n if(rightVolume == 0x1000000){\n                rightVolume -= 1;\n }\n\n            leftdB  = android::LVC_Convert_VolToDb(leftVolume);\n            rightdB = android::LVC_Convert_VolToDb(rightVolume);\n\n            pandB = rightdB - leftdB;\n\n            maxdB = leftdB;\n if(rightdB > maxdB){\n                maxdB = rightdB;\n }\n\n            memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);\n            android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));\n\n LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_GetControlParameters\", \"VolumeSetStereoPosition\")\n if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n\n ActiveParams.VC_Balance  = pandB;\n            ALOGV(\"\\t\\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\\n\", ActiveParams.VC_Balance );\n\n LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_SetControlParameters\", \"VolumeSetStereoPosition\")\n if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n break;\n }\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n default:\n return -EINVAL;\n }\n\n return 0;\n} \n", "target": 1, "flaw_line_index": ""}
{"idx": 187685, "func": "make_size(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo,\n    int PNG_CONST bdhi)\n {\n    for (; bdlo <= bdhi; ++bdlo)\n    {\n      png_uint_32 width;\n\n for (width = 1; width <= 16; ++width)\n {\n         png_uint_32 height;\n\n for (height = 1; height <= 16; ++height)\n {\n            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,\n               width, height, 0);\n            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,\n               width, height, 1);\n\n #        ifdef PNG_WRITE_INTERLACING_SUPPORTED\n             make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,\n                width, height, 0);\n             make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,\n                width, height, 1);\n #        endif\n }\n }\n }\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 9088, "func": "static int vrend_decode_bind_sampler_states(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length < 2)\n      return EINVAL;\n\n   uint32_t shader_type = get_buf_entry(ctx, VIRGL_BIND_SAMPLER_STATES_SHADER_TYPE);\n   uint32_t start_slot = get_buf_entry(ctx, VIRGL_BIND_SAMPLER_STATES_START_SLOT);\n   uint32_t num_states = length - 2;\n\n   if (shader_type >= PIPE_SHADER_TYPES)\n      return EINVAL;\n\n   vrend_bind_sampler_states(ctx->grctx, shader_type, start_slot, num_states,\n                             get_buf_ptr(ctx, VIRGL_BIND_SAMPLER_STATES_S0_HANDLE));\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9230, "func": "static void virtio_queue_notify_aio_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_aio_output) {\n        VirtIODevice *vdev = vq->vdev;\n\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_aio_output(vdev, vq);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188599, "func": "   virtual void SetUp() {\n     source_stride_ = (width_ + 31) & ~31;\n     reference_stride_ = width_ * 2;\n     rnd_.Reset(ACMRandom::DeterministicSeed());\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8673, "func": "void mptsas_process_config(MPTSASState *s, MPIMsgConfig *req)\n{\n    PCIDevice *pci = PCI_DEVICE(s);\n\n    MPIMsgConfigReply reply;\n    const MPTSASConfigPage *page;\n    size_t length;\n    uint8_t type;\n    uint8_t *data = NULL;\n    uint32_t flags_and_length;\n    uint32_t dmalen;\n    uint64_t pa;\n\n    mptsas_fix_config_endianness(req);\n\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    memset(&reply, 0, sizeof(reply));\n    reply.Action      = req->Action;\n    reply.Function    = req->Function;\n    reply.MsgContext  = req->MsgContext;\n    reply.MsgLength   = sizeof(reply) / 4;\n    reply.PageType    = req->PageType;\n    reply.PageNumber  = req->PageNumber;\n    reply.PageLength  = req->PageLength;\n    reply.PageVersion = req->PageVersion;\n\n    type = req->PageType & MPI_CONFIG_PAGETYPE_MASK;\n    if (type == MPI_CONFIG_PAGETYPE_EXTENDED) {\n        type = req->ExtPageType;\n        if (type <= MPI_CONFIG_PAGETYPE_MASK) {\n            reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_TYPE;\n            goto out;\n        }\n\n        reply.ExtPageType = req->ExtPageType;\n    }\n\n    page = mptsas_find_config_page(type, req->PageNumber);\n\n    switch(req->Action) {\n    case MPI_CONFIG_ACTION_PAGE_DEFAULT:\n    case MPI_CONFIG_ACTION_PAGE_HEADER:\n    case MPI_CONFIG_ACTION_PAGE_READ_NVRAM:\n    case MPI_CONFIG_ACTION_PAGE_READ_CURRENT:\n    case MPI_CONFIG_ACTION_PAGE_READ_DEFAULT:\n    case MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT:\n    case MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM:\n        break;\n\n    default:\n        reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_ACTION;\n        goto out;\n    }\n\n    if (!page) {\n        page = mptsas_find_config_page(type, 1);\n        if (page) {\n            reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;\n        } else {\n            reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_TYPE;\n        }\n        goto out;\n    }\n\n    if (req->Action == MPI_CONFIG_ACTION_PAGE_DEFAULT ||\n        req->Action == MPI_CONFIG_ACTION_PAGE_HEADER) {\n        length = page->mpt_config_build(s, NULL, req->PageAddress);\n        if ((ssize_t)length < 0) {\n            reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;\n            goto out;\n        } else {\n            goto done;\n        }\n    }\n\n    if (req->Action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||\n        req->Action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {\n        length = page->mpt_config_build(s, NULL, req->PageAddress);\n        if ((ssize_t)length < 0) {\n            reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;\n        } else {\n            reply.IOCStatus = MPI_IOCSTATUS_CONFIG_CANT_COMMIT;\n        }\n        goto out;\n    }\n\n    flags_and_length = req->PageBufferSGE.FlagsLength;\n    dmalen = flags_and_length & MPI_SGE_LENGTH_MASK;\n    if (dmalen == 0) {\n        length = page->mpt_config_build(s, NULL, req->PageAddress);\n        if ((ssize_t)length < 0) {\n            reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;\n            goto out;\n        } else {\n            goto done;\n        }\n    }\n\n    if (flags_and_length & MPI_SGE_FLAGS_64_BIT_ADDRESSING) {\n        pa = req->PageBufferSGE.u.Address64;\n    } else {\n        pa = req->PageBufferSGE.u.Address32;\n    }\n\n    length = page->mpt_config_build(s, &data, req->PageAddress);\n    if ((ssize_t)length < 0) {\n        reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;\n        goto out;\n    } else {\n        assert(data[2] == page->number);\n        pci_dma_write(pci, pa, data, MIN(length, dmalen));\n        goto done;\n    }\n\n    abort();\n\ndone:\n    if (type > MPI_CONFIG_PAGETYPE_MASK) {\n        reply.ExtPageLength = length / 4;\n        reply.ExtPageType   = req->ExtPageType;\n    } else {\n        reply.PageLength    = length / 4;\n    }\n\nout:\n    mptsas_fix_config_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n    g_free(data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187372, "func": "int Reverb_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n int retsize;\n    LVREV_ControlParams_st    ActiveParams; \n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; \n\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n\n \n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_INIT: ERROR\");\n                 return -EINVAL;\n }\n *(int *) pReplyData = 0;\n break;\n\n\n         case EFFECT_CMD_SET_CONFIG:\n            if (pCmdData == NULL ||\n                cmdSize != sizeof(effect_config_t) ||\n                pReplyData == NULL ||\n                *replySize != sizeof(int)) {\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_SET_CONFIG: ERROR\");\n                 return -EINVAL;\n }\n *(int *) pReplyData = android::Reverb_setConfig(pContext,\n (effect_config_t *) pCmdData);\n\n             break;\n \n         case EFFECT_CMD_GET_CONFIG:\n            if (pReplyData == NULL ||\n                *replySize != sizeof(effect_config_t)) {\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_GET_CONFIG: ERROR\");\n                 return -EINVAL;\n }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n Reverb_setConfig(pContext, &pContext->config);\n break;\n\n\n         case EFFECT_CMD_GET_PARAM:{\n            if (pCmdData == NULL ||\n                    cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                    pReplyData == NULL ||\n                    *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_GET_PARAM: ERROR\");\n                 return -EINVAL;\n             }\n            effect_param_t *p = (effect_param_t *)pCmdData;\n \n             memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n \n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n (void *)p->data,\n &p->vsize,\n                                                          p->data + voffset);\n\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n\n\n \n            if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)))\n                    || pReplyData == NULL || *replySize != sizeof(int32_t)) {\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_SET_PARAM: ERROR\");\n                 return -EINVAL;\n }\n\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::Reverb_setParameter(pContext,\n (void *)p->data,\n                                                              p->data + p->psize);\n } break;\n\n case EFFECT_CMD_ENABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n break;\n case EFFECT_CMD_DISABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n\n if (pReplyData != NULL) { \n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n *(uint32_t *)pReplyData = (1 << 24);\n *((uint32_t *)pReplyData + 1) = (1 << 24);\n if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n }\n } else { \n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"DEFAULT start %d ERROR\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n} \n", "target": 1, "flaw_line_index": "26,38,39,40,41,52,53,72,73,74,75,80,112,113"}
{"idx": 8515, "func": "static void free_rportfwd(struct ssh_rportfwd *pf)\n{\n    if (pf) {\n        sfree(pf->sportdesc);\n        sfree(pf->shost);\n        sfree(pf->dhost);\n        sfree(pf);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9138, "func": "static boolean eat_white( const char **pcur )\n{\n   const char *cur = *pcur;\n\n   eat_opt_white( pcur );\n   return *pcur > cur;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188633, "func": "int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,\n uint32_t *size)\n{\n equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n int32_t *param_tmp = (int32_t *)p->data;\n int32_t param = *param_tmp++;\n int32_t param2;\n char *name;\n void *value = p->data + voffset;\n int i;\n\n    ALOGV(\"%s\", __func__);\n\n    p->status = 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n case EQ_PARAM_CUR_PRESET:\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n case EQ_PARAM_BAND_LEVEL:\n case EQ_PARAM_GET_BAND:\n if (p->vsize < sizeof(int16_t))\n           p->status = -EINVAL;\n        p->vsize = sizeof(int16_t);\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n if (p->vsize < 2 * sizeof(int16_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int16_t);\n break;\n case EQ_PARAM_BAND_FREQ_RANGE:\n if (p->vsize < 2 * sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int32_t);\n break;\n\n case EQ_PARAM_CENTER_FREQ:\n if (p->vsize < sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = sizeof(int32_t);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n break;\n\n case EQ_PARAM_PROPERTIES:\n if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))\n            p->status = -EINVAL;\n        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);\n break;\n\n default:\n        p->status = -EINVAL;\n }\n\n *size = sizeof(effect_param_t) + voffset + p->vsize;\n\n if (p->status != 0)\n return 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n\tALOGV(\"%s: EQ_PARAM_NUM_BANDS\", __func__);\n *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n\tALOGV(\"%s: EQ_PARAM_LEVEL_RANGE\", __func__);\n *(int16_t *)value = -1500;\n *((int16_t *)value + 1) = 1500;\n break;\n\n\n     case EQ_PARAM_BAND_LEVEL:\n \tALOGV(\"%s: EQ_PARAM_BAND_LEVEL\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n             break;\n         }\n         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_CENTER_FREQ:\n \tALOGV(\"%s: EQ_PARAM_CENTER_FREQ\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n           p->status = -EINVAL;\n             break;\n         }\n         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_BAND_FREQ_RANGE:\n \tALOGV(\"%s: EQ_PARAM_BAND_FREQ_RANGE\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n            break;\n         }\n        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,\n ((uint32_t *)value + 1));\n break;\n\n case EQ_PARAM_GET_BAND:\n\tALOGV(\"%s: EQ_PARAM_GET_BAND\", __func__);\n        param2 = *param_tmp;\n *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);\n break;\n\n case EQ_PARAM_CUR_PRESET:\n\tALOGV(\"%s: EQ_PARAM_CUR_PRESET\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n\tALOGV(\"%s: EQ_PARAM_GET_NUM_OF_PRESETS\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n\tALOGV(\"%s: EQ_PARAM_GET_PRESET_NAME\", __func__);\n        param2 = *param_tmp;\n\tALOGV(\"param2: %d\", param2);\n if (param2 >= equalizer_get_num_presets(eq_ctxt)) {\n            p->status = -EINVAL;\n break;\n }\n        name = (char *)value;\n        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);\n        name[p->vsize - 1] = 0;\n        p->vsize = strlen(name) + 1;\n break;\n\n case EQ_PARAM_PROPERTIES: {\n\tALOGV(\"%s: EQ_PARAM_PROPERTIES\", __func__);\n int16_t *prop = (int16_t *)value;\n        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);\n        prop[1] = (int16_t)NUM_EQ_BANDS;\n for (i = 0; i < NUM_EQ_BANDS; i++) {\n            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);\n }\n } break;\n\n default:\n        p->status = -EINVAL;\n break;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "79,90,91,101"}
{"idx": 187738, "func": " transform_range_check(png_const_structp pp, unsigned int r, unsigned int g,\n    unsigned int b, unsigned int a, unsigned int in_digitized, double in,\n    unsigned int out, png_byte sample_depth, double err, double limit,\n   PNG_CONST char *name, double digitization_error)\n {\n unsigned int max = (1U<<sample_depth)-1;\n double in_min = ceil((in-err)*max - digitization_error);\n double in_max = floor((in+err)*max + digitization_error);\n if (err > limit || !(out >= in_min && out <= in_max))\n {\n char message[256];\n size_t pos;\n\n      pos = safecat(message, sizeof message, 0, name);\n      pos = safecat(message, sizeof message, pos, \" output value error: rgba(\");\n      pos = safecatn(message, sizeof message, pos, r);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, g);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, b);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, a);\n      pos = safecat(message, sizeof message, pos, \"): \");\n      pos = safecatn(message, sizeof message, pos, out);\n      pos = safecat(message, sizeof message, pos, \" expected: \");\n      pos = safecatn(message, sizeof message, pos, in_digitized);\n      pos = safecat(message, sizeof message, pos, \" (\");\n      pos = safecatd(message, sizeof message, pos, (in-err)*max, 3);\n      pos = safecat(message, sizeof message, pos, \"..\");\n      pos = safecatd(message, sizeof message, pos, (in+err)*max, 3);\n      pos = safecat(message, sizeof message, pos, \")\");\n\n      png_error(pp, message);\n }\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 187691, "func": "modifier_current_encoding(PNG_CONST png_modifier *pm, color_encoding *ce)\n {\n    if (pm->current_encoding != 0)\n       *ce = *pm->current_encoding;\n\n else\n      memset(ce, 0, sizeof *ce);\n\n   ce->gamma = pm->current_gamma;\n\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8407, "func": "pvscsi_convert_sglist(PVSCSIRequest *r)\n{\n    uint32_t chunk_size, elmcnt = 0;\n    uint64_t data_length = r->req.dataLen;\n    PVSCSISGState sg = r->sg;\n    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {\n        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {\n            pvscsi_get_next_sg_elem(&sg);\n            trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                        r->sg.resid);\n        }\n        chunk_size = MIN(data_length, sg.resid);\n        if (chunk_size) {\n            qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n        }\n\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187626, "func": "static double calcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxcalc16;\n else if (pm->assume_16_bit_calculations)\n return pm->maxcalcG;\n else\n\n       return pm->maxcalc8;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188613, "func": "   virtual void TearDown() {\n    delete[] src_;\n    delete[] ref_;\n     libvpx_test::ClearSystemState();\n   }\n", "target": 1, "flaw_line_index": "2,3"}
{"idx": 8738, "func": "vcard_apdu_set_class(VCardAPDU *apdu) {\n    apdu->a_channel = 0;\n    apdu->a_secure_messaging = 0;\n    apdu->a_type = apdu->a_cla & 0xf0;\n    apdu->a_gen_type = VCARD_7816_ISO;\n\n    switch (apdu->a_type) {\n    case 0x00:\n    case 0x80:\n    case 0x90:\n    case 0xa0:\n        apdu->a_channel = apdu->a_cla & 3;\n        apdu->a_secure_messaging = apdu->a_cla & 0xe;\n        break;\n    case 0xb0:\n    case 0xc0:\n        break;\n\n    case 0x10:\n    case 0x20:\n    case 0x30:\n    case 0x40:\n    case 0x50:\n    case 0x60:\n    case 0x70:\n        apdu->a_gen_type = VCARD_7816_RFU;\n        break;\n    case 0xd0:\n    case 0xe0:\n    case 0xf0:\n    default:\n        apdu->a_gen_type =\n            (apdu->a_cla == 0xff) ? VCARD_7816_PTS : VCARD_7816_PROPRIETARY;\n        break;\n    }\n    return VCARD7816_STATUS_SUCCESS;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187756, "func": " main(void)\n {\n    fprintf(stderr,\n       \"pngfix needs libpng with a zlib >=1.2.4 (not 0x%x)\\n\",\n      PNG_ZLIB_VERNUM);\n    return 77;\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 9222, "func": "hwaddr virtio_queue_get_ring_size(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.used - vdev->vq[n].vring.desc +\n\t    virtio_queue_get_used_size(vdev, n);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8313, "func": "XFixesSetGCClipRegion (Display *dpy, GC gc,\n\t\t       int clip_x_origin, int clip_y_origin,\n\t\t       XserverRegion region)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesSetGCClipRegionReq\t    *req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesSetGCClipRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesSetGCClipRegion;\n    req->gc = gc->gid;\n    req->region = region;\n    req->xOrigin = clip_x_origin;\n    req->yOrigin = clip_y_origin;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187623, "func": "image_transform_png_set_@_mod(PNG_CONST image_transform *this,\n    image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n{\n   this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6"}
{"idx": 8326, "func": "static void mcf_fec_read_bd(mcf_fec_bd *bd, uint32_t addr)\n{\n    cpu_physical_memory_read(addr, bd, sizeof(*bd));\n    be16_to_cpus(&bd->flags);\n    be16_to_cpus(&bd->length);\n    be32_to_cpus(&bd->data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8876, "func": "static void vrend_hw_set_zsurf_texture(struct vrend_context *ctx)\n{\n   struct vrend_resource *tex;\n   int first_layer, last_layer;\n   if (!ctx->sub->zsurf) {\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_STENCIL_ATTACHMENT,\n                                GL_TEXTURE_2D, 0, 0);\n      return;\n\n   }\n   tex = ctx->sub->zsurf->texture;\n   if (!tex)\n      return;\n\n   first_layer = ctx->sub->zsurf->val1 & 0xffff;\n   last_layer = (ctx->sub->zsurf->val1 >> 16) & 0xffff;\n\n   vrend_fb_bind_texture(tex, 0, ctx->sub->zsurf->val0,\n                         first_layer != last_layer ? 0xffffffff : first_layer);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8459, "func": "static bool pvscsi_vmstate_need_pcie_device(void *opaque)\n{\n    PVSCSIState *s = PVSCSI(opaque);\n\n    return !(s->compat_flags & PVSCSI_COMPAT_DISABLE_PCIE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187522, "func": " static byte parseHexByte(const char * &str) {\n     byte b = parseHexChar(str[0]);\n    if (str[1] == ':' || str[1] == '\\0') {\n        str += 2;\n        return b;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 3;\n        return b;\n     }\n }\n", "target": 1, "flaw_line_index": "3,4,5,8,9"}
{"idx": 9012, "func": "vmxnet3_io_bar0_read(void *opaque, hwaddr addr, unsigned size)\n{\n    VMXNET3State *s = opaque;\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n        return s->interrupt_states[l].is_masked;\n    }\n\n    VMW_CBPRN(\"BAR0 unknown read [%\" PRIx64 \"], size %d\", addr, size);\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187762, "func": "zlib_advance(struct zlib *zlib, png_uint_32 nbytes)\n#  define ZLIB_TOO_FAR_BACK (-1)\n#  define ZLIB_OK           0\n#  define ZLIB_STREAM_END   1\n#  define ZLIB_FATAL        2\n{\n int state = zlib->state;\n int endrc = ZLIB_OK;\n   png_uint_32 in_bytes = 0;\n struct file *file = zlib->file;\n\n   assert(state >= 0);\n\n while (in_bytes < nbytes && endrc == ZLIB_OK)\n {\n      png_uint_32 out_bytes;\n int flush;\n      png_byte bIn = reread_byte(file);\n      png_byte bOut;\n\n switch (state)\n {\n case 0: \n {\n int file_bits = 8+(bIn >> 4);\n int new_bits = zlib->window_bits;\n\n\n                zlib->file_bits = file_bits;\n \n                if (new_bits == 0) \n                  zlib->window_bits = file_bits;\n \n                else if (new_bits != file_bits) \n                   bIn = (png_byte)((bIn & 0xf) + ((new_bits-8) << 4));\n }\n\n            zlib->header[0] = bIn;\n            zlib->state = state = 1;\n break;\n\n case 1: \n {\n int b2 = bIn & 0xe0; \n\n               b2 += 0x1f - ((zlib->header[0] << 8) + b2) % 0x1f;\n\n\n                if (bIn != b2)\n                {\n                   if (zlib->file_bits == zlib->window_bits)\n                      zlib->cksum = 1;\n\n                  bIn = (png_byte)b2;\n }\n }\n\n            zlib->header[1] = bIn;\n            zlib->state = state = 2;\n break;\n\n default: \n break;\n }\n\n      zlib->z.next_in = &bIn;\n      zlib->z.avail_in = 1;\n      zlib->z.next_out = &bOut;\n      zlib->z.avail_out = 0; \n\n      flush = Z_NO_FLUSH;\n      out_bytes = 0;\n\n for (;endrc == ZLIB_OK;\n         flush = Z_SYNC_FLUSH,\n         zlib->z.next_out = &bOut,\n         zlib->z.avail_out = 1,\n ++out_bytes)\n {\n         zlib->rc = inflate(&zlib->z, flush);\n         out_bytes -= zlib->z.avail_out;\n\n switch (zlib->rc)\n {\n case Z_BUF_ERROR:\n if (zlib->z.avail_out == 0)\n continue; \n\n if (zlib->z.avail_in == 0)\n break; \n\n               zlib_message(zlib, 1\n);\n               endrc = ZLIB_FATAL; \n break;\n\n case Z_OK:\n               assert(zlib->z.avail_out == 0 || zlib->z.avail_in == 0);\n continue;\n\n case Z_STREAM_END:\n               zlib->state = 3; \n               endrc = ZLIB_STREAM_END;\n break;\n\n case Z_NEED_DICT:\n               zlib_message(zlib, 0\n);\n               endrc = ZLIB_FATAL;\n break;\n\n case Z_DATA_ERROR:\n if (zlib->z.msg != NULL &&\n                  strcmp(zlib->z.msg, \"invalid distance too far back\") == 0)\n {\n                  endrc = ZLIB_TOO_FAR_BACK;\n break;\n }\n\n default:\n               zlib_message(zlib, 0\n);\n               endrc = ZLIB_FATAL;\n break;\n } \n\n break;\n } \n\n      zlib->uncompressed_digits = uarb_add32(zlib->uncompressed_bytes,\n         zlib->uncompressed_digits, out_bytes);\n\n      assert(zlib->z.avail_in == 0 || endrc != ZLIB_OK);\n\n      in_bytes += 1 - zlib->z.avail_in;\n } \n\n   assert(in_bytes == nbytes || endrc != ZLIB_OK);\n\n   zlib->compressed_digits = uarb_add32(zlib->compressed_bytes,\n      zlib->compressed_digits, in_bytes - zlib->z.avail_in);\n\n if (endrc == ZLIB_STREAM_END && zlib->window_bits < zlib->ok_bits)\n {\n struct chunk *chunk = zlib->chunk;\n\n      chunk->uncompressed_digits = uarb_copy(chunk->uncompressed_bytes,\n         zlib->uncompressed_bytes, zlib->uncompressed_digits);\n      chunk->compressed_digits = uarb_copy(chunk->compressed_bytes,\n         zlib->compressed_bytes, zlib->compressed_digits);\n      chunk->rewrite_buffer[0] = zlib->header[0];\n      chunk->rewrite_buffer[1] = zlib->header[1];\n\n if (zlib->window_bits != zlib->file_bits || zlib->cksum)\n {\n         chunk->rewrite_offset = zlib->rewrite_offset;\n         chunk->rewrite_length = 2;\n }\n\n else\n {\n         chunk->rewrite_offset = 0;\n         chunk->rewrite_length = 0;\n }\n\n if (in_bytes < nbytes)\n         chunk_message(chunk, \"extra compressed data\");\n\n      zlib->extra_bytes = nbytes - in_bytes;\n      zlib->ok_bits = zlib->window_bits;\n }\n\n return endrc;\n}\n", "target": 1, "flaw_line_index": "32"}
{"idx": 187408, "func": "status_t MediaHTTP::connect(\n const char *uri,\n const KeyedVector<String8, String8> *headers,\n off64_t \n) {\n if (mInitCheck != OK) {\n return mInitCheck;\n }\n\n KeyedVector<String8, String8> extHeaders;\n if (headers != NULL) {\n        extHeaders = *headers;\n }\n\n if (extHeaders.indexOfKey(String8(\"User-Agent\")) < 0) {\n\n         extHeaders.add(String8(\"User-Agent\"), String8(MakeUserAgent().c_str()));\n     }\n \n    bool success = mHTTPConnection->connect(uri, &extHeaders);\n \n     mLastHeaders = extHeaders;\n    mLastURI = uri;\n \n     mCachedSizeValid = false;\n \n     if (success) {\n        AString sanitized = uriDebugString(uri);\n         mName = String8::format(\"MediaHTTP(%s)\", sanitized.c_str());\n     }\n \n return success ? OK : UNKNOWN_ERROR;\n}\n", "target": 1, "flaw_line_index": "20,23,28"}
{"idx": 188077, "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n\n     UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n     parse_part_params_t *ps_part_info;\n     WORD32 ret;\n \n     if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n     {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))\n {\n        num_mb_skip++;\n }\n    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\n if(prev_slice_err == 1)\n\n     {\n         ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n        if(!ps_dec->u1_first_slice_in_stream)\n        {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n        }\n         {\n             WORD32 i, j, poc = 0;\n \n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = -1;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n {\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n {\n if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)\n {\n                           j = i;\n break;\n }\n }\n }\n\n if(j == -1)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n        ps_dec->u4_first_slice_in_pic = 0;\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))\n {\n                ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;\n                ps_dec->u2_cur_mb_addr--;\n }\n\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n if(u1_num_mbs)\n {\n                ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n                ps_dec->u2_cur_mb_addr--;\n                ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <\n (UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))\n {\n                ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n                ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n                ps_dec->u2_cur_slice_num++;\n                ps_dec->ps_parse_cur_slice++;\n }\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->u2_mbx =\n (MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby =\n (DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby <<= u1_mbaff;\n\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n\n if(ps_dec->u4_first_slice_in_pic != 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": "48,49,50,51,52,53,54"}
{"idx": 187891, "func": "Chapters::~Chapters() {\n while (m_editions_count > 0) {\n\n     Edition& e = m_editions[--m_editions_count];\n     e.Clear();\n   }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187425, "func": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n\n {\n     const char *perm = \"add\";\n \n    if (uid >= AID_APP) {\n         return 0; \n     }\n \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187528, "func": " int venc_dev::venc_input_log_buffers(OMX_BUFFERHEADERTYPE *pbuffer, int fd, int plane_offset) {\n     if (!m_debug.infile) {\n         int size = snprintf(m_debug.infile_name, PROPERTY_VALUE_MAX, \"%s/input_enc_%lu_%lu_%p.yuv\",\n                             m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n if ((size > PROPERTY_VALUE_MAX) && (size < 0)) {\n             DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging size:%d\",\n                                m_debug.infile_name, size);\n }\n        m_debug.infile = fopen (m_debug.infile_name, \"ab\");\n if (!m_debug.infile) {\n            DEBUG_PRINT_HIGH(\"Failed to open input file: %s for logging\", m_debug.infile_name);\n            m_debug.infile_name[0] = '\\0';\n return -1;\n }\n }\n if (m_debug.infile && pbuffer && pbuffer->nFilledLen) {\n unsigned long i, msize;\n int stride = VENUS_Y_STRIDE(COLOR_FMT_NV12, m_sVenc_cfg.input_width);\n int scanlines = VENUS_Y_SCANLINES(COLOR_FMT_NV12, m_sVenc_cfg.input_height);\n unsigned char *pvirt,*ptemp;\n\n char *temp = (char *)pbuffer->pBuffer;\n\n        msize = VENUS_BUFFER_SIZE(COLOR_FMT_NV12, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height);\n if (metadatamode == 1) {\n            pvirt= (unsigned char *)mmap(NULL, msize, PROT_READ|PROT_WRITE,MAP_SHARED, fd, plane_offset);\n if (pvirt) {\n               ptemp = pvirt;\n for (i = 0; i < m_sVenc_cfg.input_height; i++) {\n                    fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile);\n                    ptemp += stride;\n }\n               ptemp = pvirt + (stride * scanlines);\n for(i = 0; i < m_sVenc_cfg.input_height/2; i++) {\n                   fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile);\n                   ptemp += stride;\n }\n               munmap(pvirt, msize);\n } else if (pvirt == MAP_FAILED) {\n                 DEBUG_PRINT_ERROR(\"%s mmap failed\", __func__);\n return -1;\n }\n } else {\n for (i = 0; i < m_sVenc_cfg.input_height; i++) {\n                 fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile);\n                 temp += stride;\n }\n\n            temp = (char *)pbuffer->pBuffer + (stride * scanlines);\n\n for(i = 0; i < m_sVenc_cfg.input_height/2; i++) {\n                fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile);\n                temp += stride;\n }\n }\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8917, "func": "int vrend_renderer_resource_get_info(int res_handle,\n                                     struct vrend_renderer_resource_info *info)\n{\n   struct vrend_resource *res;\n   int elsize;\n\n   if (!info)\n      return EINVAL;\n   res = vrend_resource_lookup(res_handle, 0);\n   if (!res)\n      return EINVAL;\n\n   elsize = util_format_get_blocksize(res->base.format);\n\n   info->handle = res_handle;\n   info->tex_id = res->id;\n   info->width = res->base.width0;\n   info->height = res->base.height0;\n   info->depth = res->base.depth0;\n   info->format = res->base.format;\n   info->flags = res->y_0_top ? VIRGL_RESOURCE_Y_0_TOP : 0;\n   info->stride = util_format_get_nblocksx(res->base.format, u_minify(res->base.width0, 0)) * elsize;\n\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8571, "func": "static void ssh_pkt_addstring(struct Packet *pkt, const char *data)\n{\n    ssh_pkt_addstring_start(pkt);\n    ssh_pkt_addstring_str(pkt, data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187751, "func": " allocate(struct file *file, int allocate_idat)\n {\n   struct control *control = png_voidcast(struct control*, file->alloc_ptr);\n \n    if (allocate_idat)\n    {\n      assert(file->idat == NULL);\n      IDAT_init(&control->idat, file);\n }\n\n else \n {\n      assert(file->chunk == NULL);\n      chunk_init(&control->chunk, file);\n }\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 9137, "func": "static void eat_until_eol( const char **pcur )\n{\n   while (**pcur != '\\0' && **pcur != '\\n')\n      (*pcur)++;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8774, "func": "static NOINLINE int send_decline(\n uint32_t server, uint32_t requested)\n{\n\tstruct dhcp_packet packet;\n\n\tinit_packet(&packet, DHCPDECLINE);\n\n#if 0\n\tpacket.xid = xid;\n#endif\n\tudhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);\n\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\n\tbb_error_msg(\"sending %s\", \"decline\");\n\treturn raw_bcast_from_client_config_ifindex(&packet, INADDR_ANY);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188238, "func": "OMX_ERRORTYPE SoftOpus::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamAudioAndroidOpus:\n {\n\n             OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *opusParams =\n                 (OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *)params;\n \n             if (opusParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            opusParams->nAudioBandWidth = 0;\n            opusParams->nSampleRate = kRate;\n            opusParams->nBitRate = 0;\n\n if (!isConfigured()) {\n                opusParams->nChannels = 1;\n } else {\n                opusParams->nChannels = mHeader->channels;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n            pcmParams->nSamplingRate = kRate;\n\n if (!isConfigured()) {\n                pcmParams->nChannels = 1;\n } else {\n                pcmParams->nChannels = mHeader->channels;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187634, "func": "gamma_image_validate(gamma_display *dp, png_const_structp pp,\n\n    png_infop pi)\n {\n   PNG_CONST png_store* PNG_CONST ps = dp->this.ps;\n   PNG_CONST png_byte in_ct = dp->this.colour_type;\n   PNG_CONST png_byte in_bd = dp->this.bit_depth;\n   PNG_CONST png_uint_32 w = dp->this.w;\n   PNG_CONST png_uint_32 h = dp->this.h;\n   PNG_CONST size_t cbRow = dp->this.cbRow;\n   PNG_CONST png_byte out_ct = png_get_color_type(pp, pi);\n   PNG_CONST png_byte out_bd = png_get_bit_depth(pp, pi);\n \n   PNG_CONST unsigned int samples_per_pixel = (out_ct & 2U) ? 3U : 1U;\n    int processing;\n    png_uint_32 y;\n   PNG_CONST store_palette_entry *in_palette = dp->this.palette;\n   PNG_CONST int in_is_transparent = dp->this.is_transparent;\n    int out_npalette = -1;\n    int out_is_transparent = 0; \n    store_palette out_palette;\n   validate_info vi;\n\n   store_image_check(dp->this.ps, pp, 0);\n\n   init_validate_info(&vi, dp, pp, in_ct==3?8:in_bd, out_ct==3?8:out_bd);\n\n \n    processing = (vi.gamma_correction > 0 && !dp->threshold_test)\n       || in_bd != out_bd || in_ct != out_ct || vi.do_background;\n \n if (in_ct == 3 && out_ct == 3)\n      processing = 0;\n\n if (processing && out_ct == 3)\n      out_is_transparent = read_palette(out_palette, &out_npalette, pp, pi);\n\n for (y=0; y<h; ++y)\n {\n      png_const_bytep pRow = store_image_row(ps, pp, 0, y);\n      png_byte std[STANDARD_ROWMAX];\n\n      transform_row(pp, std, in_ct, in_bd, y);\n\n if (processing)\n {\n unsigned int x;\n\n for (x=0; x<w; ++x)\n {\n\n             double alpha = 1; \n \n            PNG_CONST unsigned int in_index =\n               in_ct == 3 ? sample(std, 3, in_bd, x, 0) : 256;\n            PNG_CONST unsigned int out_index =\n               out_ct == 3 ? sample(std, 3, out_bd, x, 0) : 256;\n \n            if ((in_ct & PNG_COLOR_MASK_ALPHA) != 0 || (in_ct == 3 &&\n               in_is_transparent))\n             {\n               PNG_CONST unsigned int input_alpha = in_ct == 3 ?\n                   dp->this.palette[in_index].alpha :\n                  sample(std, in_ct, in_bd, x, samples_per_pixel);\n \n                unsigned int output_alpha = 65536 \n;\n \n if (out_ct == 3)\n {\n if (out_is_transparent)\n                     output_alpha = out_palette[out_index].alpha;\n }\n\n \n                else if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0)\n                   output_alpha = sample(pRow, out_ct, out_bd, x,\n                     samples_per_pixel);\n \n                if (output_alpha != 65536)\n                   alpha = gamma_component_validate(\"alpha\", &vi, input_alpha,\n                     output_alpha, -1\n);\n\n else \n {\n                  alpha = input_alpha >> vi.isbit_shift;\n                  alpha /= vi.sbit_max;\n\n                }\n             }\n \n             if ((in_ct & PNG_COLOR_MASK_COLOR) == 0) \n                (void)gamma_component_validate(\"gray\", &vi,\n                  sample(std, in_ct, in_bd, x, 0),\n                  sample(pRow, out_ct, out_bd, x, 0), alpha\n,\n                  vi.background_red);\n             else \n             {\n                (void)gamma_component_validate(\"red\", &vi,\n                   in_ct == 3 ? in_palette[in_index].red :\n                     sample(std, in_ct, in_bd, x, 0),\n                   out_ct == 3 ? out_palette[out_index].red :\n                     sample(pRow, out_ct, out_bd, x, 0),\n                   alpha\n, vi.background_red);\n \n                (void)gamma_component_validate(\"green\", &vi,\n                   in_ct == 3 ? in_palette[in_index].green :\n                     sample(std, in_ct, in_bd, x, 1),\n                   out_ct == 3 ? out_palette[out_index].green :\n                     sample(pRow, out_ct, out_bd, x, 1),\n                   alpha\n, vi.background_green);\n \n                (void)gamma_component_validate(\"blue\", &vi,\n                   in_ct == 3 ? in_palette[in_index].blue :\n                     sample(std, in_ct, in_bd, x, 2),\n                   out_ct == 3 ? out_palette[out_index].blue :\n                     sample(pRow, out_ct, out_bd, x, 2),\n                   alpha\n, vi.background_blue);\n             }\n          }\n }\n\n else if (memcmp(std, pRow, cbRow) != 0)\n {\n char msg[64];\n\n         sprintf(msg, \"gamma: below threshold row %lu changed\",\n (unsigned long)y);\n\n         png_error(pp, msg);\n }\n } \n\n   dp->this.ps->validated = 1;\n}\n", "target": 1, "flaw_line_index": "5,6,7,8,9,10,11,12,14,17,18,54,55,56,57,59,60,62,64,78,95,97,98,103,105,111,113,119,121"}
{"idx": 8905, "func": "int vrend_renderer_get_poll_fd(void)\n{\n   if (!vrend_state.inited)\n      return -1;\n\n   return vrend_state.eventfd;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8826, "func": "static bool vrend_check_query(struct vrend_query *query)\n{\n   uint64_t result;\n   struct virgl_host_query_state *state;\n   bool ret;\n\n   ret = vrend_get_one_query_result(query->id, false, &result);\n   if (ret == false)\n      return false;\n\n   state = (struct virgl_host_query_state *)query->res->ptr;\n   state->result = result;\n   state->query_state = VIRGL_QUERY_STATE_DONE;\n   return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187933, "func": " MediaMetadataRetriever::MediaMetadataRetriever()\n {\n     ALOGV(\"constructor\");\n    const sp<IMediaPlayerService>& service(getService());\n     if (service == 0) {\n         ALOGE(\"failed to obtain MediaMetadataRetrieverService\");\n         return;\n }\n    sp<IMediaMetadataRetriever> retriever(service->createMetadataRetriever());\n if (retriever == 0) {\n        ALOGE(\"failed to create IMediaMetadataRetriever object from server\");\n }\n    mRetriever = retriever;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8924, "func": "static void vrend_renderer_use_threaded_sync(void)\n{\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9166, "func": "static void blitter_set_texcoords(struct vrend_blitter_ctx *blit_ctx,\n                                  struct vrend_resource *src_res,\n                                  int level,\n                                  float layer, unsigned sample,\n                                  int x1, int y1, int x2, int y2)\n{\n   float coord[4];\n   float face_coord[4][2];\n   int i;\n   get_texcoords(src_res, level, x1, y1, x2, y2, coord);\n\n   if (src_res->base.target == PIPE_TEXTURE_CUBE ||\n       src_res->base.target == PIPE_TEXTURE_CUBE_ARRAY) {\n      set_texcoords_in_vertices(coord, &face_coord[0][0], 2);\n      util_map_texcoords2d_onto_cubemap((unsigned)layer % 6,\n                                        &face_coord[0][0], 2,\n                                        &blit_ctx->vertices[0][1][0], 8,\n                                        FALSE);\n   } else {\n      set_texcoords_in_vertices(coord, &blit_ctx->vertices[0][1][0], 8);\n   }\n\n   switch (src_res->base.target) {\n   case PIPE_TEXTURE_3D:\n   {\n      float r = layer / (float)u_minify(src_res->base.depth0,\n                                        level);\n      for (i = 0; i < 4; i++)\n         blit_ctx->vertices[i][1][2] = r; \n   }\n   break;\n\n   case PIPE_TEXTURE_1D_ARRAY:\n      for (i = 0; i < 4; i++)\n         blit_ctx->vertices[i][1][1] = (float) layer; \n      break;\n\n   case PIPE_TEXTURE_2D_ARRAY:\n      for (i = 0; i < 4; i++) {\n         blit_ctx->vertices[i][1][2] = (float) layer;  \n         blit_ctx->vertices[i][1][3] = (float) sample; \n      }\n      break;\n   case PIPE_TEXTURE_CUBE_ARRAY:\n      for (i = 0; i < 4; i++)\n         blit_ctx->vertices[i][1][3] = (float) ((unsigned)layer / 6); \n      break;\n   case PIPE_TEXTURE_2D:\n      for (i = 0; i < 4; i++) {\n         blit_ctx->vertices[i][1][3] = (float) sample; \n      }\n      break;\n   default:;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188122, "func": "void btif_av_event_deep_copy(uint16_t event, char* p_dest, char* p_src) {\n  BTIF_TRACE_DEBUG(\"%s\", __func__);\n  tBTA_AV* av_src = (tBTA_AV*)p_src;\n  tBTA_AV* av_dest = (tBTA_AV*)p_dest;\n\n  maybe_non_aligned_memcpy(av_dest, av_src, sizeof(*av_src));\n switch (event) {\n case BTA_AV_META_MSG_EVT:\n if (av_src->meta_msg.p_data && av_src->meta_msg.len) {\n        av_dest->meta_msg.p_data = (uint8_t*)osi_calloc(av_src->meta_msg.len);\n        memcpy(av_dest->meta_msg.p_data, av_src->meta_msg.p_data,\n               av_src->meta_msg.len);\n }\n\n if (av_src->meta_msg.p_msg) {\n        av_dest->meta_msg.p_msg = (tAVRC_MSG*)osi_calloc(sizeof(tAVRC_MSG));\n        memcpy(av_dest->meta_msg.p_msg, av_src->meta_msg.p_msg,\n sizeof(tAVRC_MSG));\n\n        tAVRC_MSG* p_msg_src = av_src->meta_msg.p_msg;\n        tAVRC_MSG* p_msg_dest = av_dest->meta_msg.p_msg;\n\n if ((p_msg_src->hdr.opcode == AVRC_OP_VENDOR) &&\n (p_msg_src->vendor.p_vendor_data && p_msg_src->vendor.vendor_len)) {\n          p_msg_dest->vendor.p_vendor_data =\n (uint8_t*)osi_calloc(p_msg_src->vendor.vendor_len);\n\n           memcpy(p_msg_dest->vendor.p_vendor_data,\n                  p_msg_src->vendor.p_vendor_data, p_msg_src->vendor.vendor_len);\n         }\n       }\n       break;\n \n default:\n break;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8820, "func": "static void vrend_apply_sampler_state(struct vrend_context *ctx,\n                                      struct vrend_resource *res,\n                                      uint32_t shader_type,\n                                      int id,\n                                      int sampler_id,\n                                      uint32_t srgb_decode)\n{\n   struct vrend_texture *tex = (struct vrend_texture *)res;\n   struct vrend_sampler_state *vstate = ctx->sub->sampler_state[shader_type][id];\n   struct pipe_sampler_state *state = &vstate->base;\n   bool set_all = false;\n   GLenum target = tex->base.target;\n\n   if (!state) {\n      fprintf(stderr, \"cannot find sampler state for %d %d\\n\", shader_type, id);\n      return;\n   }\n   if (res->base.nr_samples > 1) {\n      tex->state = *state;\n      return;\n   }\n\n   if (target == GL_TEXTURE_BUFFER) {\n      tex->state = *state;\n      return;\n   }\n\n   if (vrend_state.have_samplers) {\n      glBindSampler(sampler_id, vstate->id);\n      glSamplerParameteri(vstate->id, GL_TEXTURE_SRGB_DECODE_EXT,\n                          srgb_decode);\n      return;\n   }\n\n   if (tex->state.max_lod == -1)\n      set_all = true;\n\n   if (tex->state.wrap_s != state->wrap_s || set_all)\n      glTexParameteri(target, GL_TEXTURE_WRAP_S, convert_wrap(state->wrap_s));\n   if (tex->state.wrap_t != state->wrap_t || set_all)\n      glTexParameteri(target, GL_TEXTURE_WRAP_T, convert_wrap(state->wrap_t));\n   if (tex->state.wrap_r != state->wrap_r || set_all)\n      glTexParameteri(target, GL_TEXTURE_WRAP_R, convert_wrap(state->wrap_r));\n   if (tex->state.min_img_filter != state->min_img_filter ||\n       tex->state.min_mip_filter != state->min_mip_filter || set_all)\n      glTexParameterf(target, GL_TEXTURE_MIN_FILTER, convert_min_filter(state->min_img_filter, state->min_mip_filter));\n   if (tex->state.mag_img_filter != state->mag_img_filter || set_all)\n      glTexParameterf(target, GL_TEXTURE_MAG_FILTER, convert_mag_filter(state->mag_img_filter));\n   if (res->target != GL_TEXTURE_RECTANGLE) {\n      if (tex->state.min_lod != state->min_lod || set_all)\n         glTexParameterf(target, GL_TEXTURE_MIN_LOD, state->min_lod);\n      if (tex->state.max_lod != state->max_lod || set_all)\n         glTexParameterf(target, GL_TEXTURE_MAX_LOD, state->max_lod);\n      if (tex->state.lod_bias != state->lod_bias || set_all)\n         glTexParameterf(target, GL_TEXTURE_LOD_BIAS, state->lod_bias);\n   }\n\n   if (tex->state.compare_mode != state->compare_mode || set_all)\n      glTexParameteri(target, GL_TEXTURE_COMPARE_MODE, state->compare_mode ? GL_COMPARE_R_TO_TEXTURE : GL_NONE);\n   if (tex->state.compare_func != state->compare_func || set_all)\n      glTexParameteri(target, GL_TEXTURE_COMPARE_FUNC, GL_NEVER + state->compare_func);\n\n   if (memcmp(&tex->state.border_color, &state->border_color, 16) || set_all)\n      glTexParameterIuiv(target, GL_TEXTURE_BORDER_COLOR, state->border_color.ui);\n   tex->state = *state;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188114, "func": "WORD32 ixheaacd_qmf_hbe_data_reinit(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,\n                                    WORD16 *p_freq_band_tab[2],\n                                    WORD16 *p_num_sfb, WORD32 upsamp_4_flag) {\n  WORD32 synth_size, sfb, patch, stop_patch;\n\n if (ptr_hbe_txposer != NULL) {\n    ptr_hbe_txposer->start_band = p_freq_band_tab[LOW][0];\n    ptr_hbe_txposer->end_band = p_freq_band_tab[LOW][p_num_sfb[LOW]];\n\n    ptr_hbe_txposer->synth_size =\n 4 * ((ptr_hbe_txposer->start_band + 4) / 8 + 1);\n    ptr_hbe_txposer->k_start =\n        ixheaacd_start_subband2kL_tbl[ptr_hbe_txposer->start_band];\n\n    ptr_hbe_txposer->upsamp_4_flag = upsamp_4_flag;\n\n if (upsamp_4_flag) {\n if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 16)\n        ptr_hbe_txposer->k_start = 16 - ptr_hbe_txposer->synth_size;\n } else if (ptr_hbe_txposer->core_frame_length == 768) {\n if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 24)\n        ptr_hbe_txposer->k_start = 24 - ptr_hbe_txposer->synth_size;\n }\n\n    memset(ptr_hbe_txposer->synth_buf, 0, 1280 * sizeof(FLOAT32));\n    synth_size = ptr_hbe_txposer->synth_size;\n    ptr_hbe_txposer->synth_buf_offset = 18 * synth_size;\n switch (synth_size) {\n case 4:\n        ptr_hbe_txposer->synth_cos_tab =\n\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n         break;\n       case 8:\n         ptr_hbe_txposer->synth_cos_tab =\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_8;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_16;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n         break;\n       case 12:\n         ptr_hbe_txposer->synth_cos_tab =\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_12;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_24;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;\n         break;\n       case 16:\n         ptr_hbe_txposer->synth_cos_tab =\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_16;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_32;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n         break;\n       case 20:\n         ptr_hbe_txposer->synth_cos_tab =\n (FLOAT32 *)ixheaacd_synth_cos_table_kl_20;\n        ptr_hbe_txposer->analy_cos_sin_tab =\n (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_40;\n break;\n default:\n        ptr_hbe_txposer->synth_cos_tab =\n\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n     }\n \n     ptr_hbe_txposer->synth_wind_coeff = ixheaacd_map_prot_filter(synth_size);\n\n    memset(ptr_hbe_txposer->analy_buf, 0, 640 * sizeof(FLOAT32));\n    synth_size = 2 * ptr_hbe_txposer->synth_size;\n    ptr_hbe_txposer->analy_wind_coeff = ixheaacd_map_prot_filter(synth_size);\n\n    memset(ptr_hbe_txposer->x_over_qmf, 0, MAX_NUM_PATCHES * sizeof(WORD32));\n    sfb = 0;\n if (upsamp_4_flag) {\n      stop_patch = MAX_NUM_PATCHES;\n      ptr_hbe_txposer->max_stretch = MAX_STRETCH;\n } else {\n      stop_patch = MAX_STRETCH;\n }\n\n for (patch = 1; patch <= stop_patch; patch++) {\n while (sfb <= p_num_sfb[LOW] &&\n             p_freq_band_tab[LOW][sfb] <= patch * ptr_hbe_txposer->start_band)\n        sfb++;\n if (sfb <= p_num_sfb[LOW]) {\n if ((patch * ptr_hbe_txposer->start_band -\n             p_freq_band_tab[LOW][sfb - 1]) <= 3) {\n          ptr_hbe_txposer->x_over_qmf[patch - 1] =\n              p_freq_band_tab[LOW][sfb - 1];\n } else {\n          WORD32 sfb = 0;\n while (sfb <= p_num_sfb[HIGH] &&\n                 p_freq_band_tab[HIGH][sfb] <=\n                     patch * ptr_hbe_txposer->start_band)\n            sfb++;\n          ptr_hbe_txposer->x_over_qmf[patch - 1] =\n              p_freq_band_tab[HIGH][sfb - 1];\n }\n } else {\n        ptr_hbe_txposer->x_over_qmf[patch - 1] = ptr_hbe_txposer->end_band;\n        ptr_hbe_txposer->max_stretch = min(patch, MAX_STRETCH);\n\n         break;\n       }\n     }\n  }\n  if (ptr_hbe_txposer->k_start < 0) {\n    return -1;\n   }\n   return 0;\n }\n", "target": 1, "flaw_line_index": "35,36,43,44,51,52,59,60,74,75,118,119,120"}
{"idx": 187376, "func": " int PreProcessingFx_ProcessReverse(effect_handle_t     self,\n                                    audio_buffer_t    *inBuffer,\n                                   audio_buffer_t    *outBuffer)\n {\n     preproc_effect_t * effect = (preproc_effect_t *)self;\n     int    status = 0;\n\n if (effect == NULL){\n        ALOGW(\"PreProcessingFx_ProcessReverse() ERROR effect == NULL\");\n return -EINVAL;\n }\n preproc_session_t * session = (preproc_session_t *)effect->session;\n\n if (inBuffer == NULL  || inBuffer->raw == NULL){\n        ALOGW(\"PreProcessingFx_ProcessReverse() ERROR bad pointer\");\n return -EINVAL;\n }\n\n    session->revProcessedMsk |= (1<<effect->procId);\n\n\n\n if ((session->revProcessedMsk & session->revEnabledMsk) == session->revEnabledMsk) {\n        effect->session->revProcessedMsk = 0;\n if (session->revResampler != NULL) {\n size_t fr = session->frameCount - session->framesRev;\n if (inBuffer->frameCount < fr) {\n                fr = inBuffer->frameCount;\n }\n if (session->revBufSize < session->framesRev + fr) {\n                session->revBufSize = session->framesRev + fr;\n                session->revBuf = (int16_t *)realloc(session->revBuf,\n                                  session->revBufSize * session->inChannelCount * sizeof(int16_t));\n }\n            memcpy(session->revBuf + session->framesRev * session->inChannelCount,\n                   inBuffer->s16,\n                   fr * session->inChannelCount * sizeof(int16_t));\n\n            session->framesRev += fr;\n            inBuffer->frameCount = fr;\n if (session->framesRev < session->frameCount) {\n return 0;\n }\n spx_uint32_t frIn = session->framesRev;\n spx_uint32_t frOut = session->apmFrameCount;\n if (session->inChannelCount == 1) {\n                speex_resampler_process_int(session->revResampler,\n 0,\n                                            session->revBuf,\n &frIn,\n                                            session->revFrame->_payloadData,\n &frOut);\n } else {\n                speex_resampler_process_interleaved_int(session->revResampler,\n                                                        session->revBuf,\n &frIn,\n                                                        session->revFrame->_payloadData,\n &frOut);\n }\n            memcpy(session->revBuf,\n                   session->revBuf + frIn * session->inChannelCount,\n (session->framesRev - frIn) * session->inChannelCount * sizeof(int16_t));\n            session->framesRev -= frIn;\n } else {\n size_t fr = session->frameCount - session->framesRev;\n if (inBuffer->frameCount < fr) {\n                fr = inBuffer->frameCount;\n }\n            memcpy(session->revFrame->_payloadData + session->framesRev * session->inChannelCount,\n                   inBuffer->s16,\n                   fr * session->inChannelCount * sizeof(int16_t));\n            session->framesRev += fr;\n            inBuffer->frameCount = fr;\n if (session->framesRev < session->frameCount) {\n return 0;\n }\n            session->framesRev = 0;\n }\n        session->revFrame->_payloadDataLengthInSamples =\n                session->apmFrameCount * session->inChannelCount;\n        effect->session->apm->AnalyzeReverseStream(session->revFrame);\n return 0;\n } else {\n return -ENODATA;\n }\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8405, "func": "pvscsi_command_complete(SCSIRequest *req, uint32_t status, size_t resid)\n{\n    PVSCSIRequest *pvscsi_req = req->hba_private;\n    PVSCSIState *s;\n\n    if (!pvscsi_req) {\n        trace_pvscsi_command_complete_not_found(req->tag);\n        return;\n    }\n    s = pvscsi_req->dev;\n\n    if (resid) {\n        trace_pvscsi_command_complete_data_run();\n        pvscsi_req->cmp.hostStatus = BTSTAT_DATARUN;\n    }\n\n    pvscsi_req->cmp.scsiStatus = status;\n    if (pvscsi_req->cmp.scsiStatus == CHECK_CONDITION) {\n        uint8_t sense[SCSI_SENSE_BUF_SIZE];\n        int sense_len =\n            scsi_req_get_sense(pvscsi_req->sreq, sense, sizeof(sense));\n\n        trace_pvscsi_command_complete_sense_len(sense_len);\n        pvscsi_write_sense(pvscsi_req, sense, sense_len);\n    }\n    qemu_sglist_destroy(&pvscsi_req->sgl);\n    pvscsi_complete_request(s, pvscsi_req);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187572, "func": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n Mutex::Autolock lock(mLock);\n Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n return NULL;\n }\n VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n return NULL;\n }\n size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n delete frame;\n return NULL;\n }\n    mThumbnail = new MemoryBase(heap, 0, size);\n if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n delete frame;\n return NULL;\n }\n VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n\n     ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n     memcpy(frameCopy->mData, frame->mData, frame->mSize);\n     delete frame;  \n     return mThumbnail;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188047, "func": "status_t FLACParser::init()\n{\n    mDecoder = FLAC__stream_decoder_new();\n if (mDecoder == NULL) {\n        ALOGE(\"new failed\");\n return NO_INIT;\n }\n    FLAC__stream_decoder_set_md5_checking(mDecoder, false);\n    FLAC__stream_decoder_set_metadata_ignore_all(mDecoder);\n    FLAC__stream_decoder_set_metadata_respond(\n            mDecoder, FLAC__METADATA_TYPE_STREAMINFO);\n    FLAC__stream_decoder_set_metadata_respond(\n            mDecoder, FLAC__METADATA_TYPE_PICTURE);\n    FLAC__stream_decoder_set_metadata_respond(\n            mDecoder, FLAC__METADATA_TYPE_VORBIS_COMMENT);\n    FLAC__StreamDecoderInitStatus initStatus;\n    initStatus = FLAC__stream_decoder_init_stream(\n            mDecoder,\n            read_callback, seek_callback, tell_callback,\n            length_callback, eof_callback, write_callback,\n            metadata_callback, error_callback, (void *) this);\n if (initStatus != FLAC__STREAM_DECODER_INIT_STATUS_OK) {\n        ALOGE(\"init_stream failed %d\", initStatus);\n return NO_INIT;\n }\n if (!FLAC__stream_decoder_process_until_end_of_metadata(mDecoder)) {\n        ALOGE(\"end_of_metadata failed\");\n return NO_INIT;\n\n     }\n     if (mStreamInfoValid) {\n        if (getChannels() == 0 || getChannels() > 8) {\n             ALOGE(\"unsupported channel count %u\", getChannels());\n             return NO_INIT;\n         }\n switch (getBitsPerSample()) {\n case 8:\n case 16:\n case 24:\n break;\n default:\n            ALOGE(\"unsupported bits per sample %u\", getBitsPerSample());\n return NO_INIT;\n }\n switch (getSampleRate()) {\n case 8000:\n case 11025:\n case 12000:\n case 16000:\n case 22050:\n case 24000:\n case 32000:\n case 44100:\n case 48000:\n case 88200:\n case 96000:\n break;\n default:\n            ALOGE(\"unsupported sample rate %u\", getSampleRate());\n return NO_INIT;\n }\n\n         static const struct {\n             unsigned mChannels;\n             unsigned mBitsPerSample;\n            void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);\n         } table[] = {\n             { 1,  8, copyMono8    },\n             { 2,  8, copyStereo8  },\n { 8, 8, copyMultiCh8  },\n { 1, 16, copyMono16   },\n { 2, 16, copyStereo16 },\n { 8, 16, copyMultiCh16 },\n { 1, 24, copyMono24   },\n { 2, 24, copyStereo24 },\n { 8, 24, copyMultiCh24 },\n };\n for (unsigned i = 0; i < sizeof(table)/sizeof(table[0]); ++i) {\n if (table[i].mChannels >= getChannels() &&\n                    table[i].mBitsPerSample == getBitsPerSample()) {\n                mCopy = table[i].mCopy;\n break;\n }\n }\n if (mTrackMetadata != 0) {\n            mTrackMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);\n            mTrackMetadata->setInt32(kKeyChannelCount, getChannels());\n            mTrackMetadata->setInt32(kKeySampleRate, getSampleRate());\n            mTrackMetadata->setInt32(kKeyPcmEncoding, kAudioEncodingPcm16bit);\n            mTrackMetadata->setInt64(kKeyDuration,\n (getTotalSamples() * 1000000LL) / getSampleRate());\n }\n } else {\n        ALOGE(\"missing STREAMINFO\");\n return NO_INIT;\n }\n if (mFileMetadata != 0) {\n        mFileMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_FLAC);\n }\n return OK;\n}\n", "target": 1, "flaw_line_index": "40,77"}
{"idx": 188635, "func": "uint8_t rfc_parse_data(tRFC_MCB* p_mcb, MX_FRAME* p_frame, BT_HDR* p_buf) {\n uint8_t ead, eal, fcs;\n uint8_t* p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n uint8_t* p_start = p_data;\n uint16_t len;\n\n if (p_buf->len < RFCOMM_CTRL_FRAME_LEN) {\n    RFCOMM_TRACE_ERROR(\"Bad Length1: %d\", p_buf->len);\n return (RFC_EVENT_BAD_FRAME);\n }\n\n  RFCOMM_PARSE_CTRL_FIELD(ead, p_frame->cr, p_frame->dlci, p_data);\n if (!ead) {\n    RFCOMM_TRACE_ERROR(\"Bad Address(EA must be 1)\");\n return (RFC_EVENT_BAD_FRAME);\n }\n  RFCOMM_PARSE_TYPE_FIELD(p_frame->type, p_frame->pf, p_data);\n\n \n   eal = *(p_data)&RFCOMM_EA;\n   len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1;\n  if (eal == 0 && p_buf->len < RFCOMM_CTRL_FRAME_LEN) {\n     len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2);\n   } else if (eal == 0) {\n     RFCOMM_TRACE_ERROR(\"Bad Length when EAL = 0: %d\", p_buf->len);\n    android_errorWriteLog(0x534e4554, \"78288018\");\n return RFC_EVENT_BAD_FRAME;\n }\n\n  p_buf->len -= (3 + !ead + !eal + 1); \n  p_buf->offset += (3 + !ead + !eal);\n\n if ((p_mcb->flow == PORT_FC_CREDIT) && (p_frame->type == RFCOMM_UIH) &&\n (p_frame->dlci != RFCOMM_MX_DLCI) && (p_frame->pf == 1)) {\n    p_frame->credit = *p_data++;\n    p_buf->len--;\n    p_buf->offset++;\n } else\n    p_frame->credit = 0;\n\n if (p_buf->len != len) {\n    RFCOMM_TRACE_ERROR(\"Bad Length2 %d %d\", p_buf->len, len);\n return (RFC_EVENT_BAD_FRAME);\n }\n\n  fcs = *(p_data + len);\n\n switch (p_frame->type) {\n case RFCOMM_SABME:\n if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad SABME\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_SABME);\n\n case RFCOMM_UA:\n if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UA\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_UA);\n\n case RFCOMM_DM:\n if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || len ||\n !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DM\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_DM);\n\n case RFCOMM_DISC:\n if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DISC\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_DISC);\n\n case RFCOMM_UIH:\n if (!RFCOMM_VALID_DLCI(p_frame->dlci)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - invalid DLCI\");\n return (RFC_EVENT_BAD_FRAME);\n } else if (!rfc_check_fcs(2, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - FCS\");\n return (RFC_EVENT_BAD_FRAME);\n } else if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - response\");\n return (RFC_EVENT_UIH);\n } else\n return (RFC_EVENT_UIH);\n }\n\n return (RFC_EVENT_BAD_FRAME);\n}\n", "target": 1, "flaw_line_index": "22"}
{"idx": 188045, "func": " static void copyStereo8(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned \n) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i] << 8;\n *dst++ = src[1][i] << 8;\n\n     }\n }\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8792, "func": "static inline int conv_a8_blend(int blend_factor)\n{\n   if (blend_factor == PIPE_BLENDFACTOR_DST_ALPHA)\n      return PIPE_BLENDFACTOR_DST_COLOR;\n   if (blend_factor == PIPE_BLENDFACTOR_INV_DST_ALPHA)\n      return PIPE_BLENDFACTOR_INV_DST_COLOR;\n   return blend_factor;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8957, "func": "static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,\n    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)\n{\n    size_t fetched = 0;\n    struct iovec *src = pkt->vec;\n\n    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;\n\n    while (fetched < IP_FRAG_ALIGN_SIZE(pkt->virt_hdr.gso_size)) {\n\n        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {\n            break;\n        }\n\n        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {\n            break;\n        }\n\n\n        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;\n        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,\n            IP_FRAG_ALIGN_SIZE(pkt->virt_hdr.gso_size) - fetched);\n\n        *src_offset += dst[*dst_idx].iov_len;\n        fetched += dst[*dst_idx].iov_len;\n\n        if (*src_offset == src[*src_idx].iov_len) {\n            *src_offset = 0;\n            (*src_idx)++;\n        }\n\n        (*dst_idx)++;\n    }\n\n    return fetched;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188115, "func": "AMediaCodecCryptoInfo *AMediaCodecCryptoInfo_new(\n int numsubsamples,\n uint8_t key[16],\n uint8_t iv[16],\n cryptoinfo_mode_t mode,\n size_t *clearbytes,\n\n         size_t *encryptedbytes) {\n \n    size_t cryptosize = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2;\n     AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize);\n     if (!ret) {\n         ALOGE(\"couldn't allocate %zu bytes\", cryptosize);\n return NULL;\n }\n    ret->numsubsamples = numsubsamples;\n    memcpy(ret->key, key, 16);\n    memcpy(ret->iv, iv, 16);\n    ret->mode = mode;\n    ret->pattern.encryptBlocks = 0;\n    ret->pattern.skipBlocks = 0;\n\n    ret->clearbytes = (size_t*) (ret + 1); \n    ret->encryptedbytes = ret->clearbytes + numsubsamples; \n\n    memcpy(ret->clearbytes, clearbytes, numsubsamples * sizeof(size_t));\n    memcpy(ret->encryptedbytes, encryptedbytes, numsubsamples * sizeof(size_t));\n\n return ret;\n}\n", "target": 1, "flaw_line_index": "11"}
{"idx": 8689, "func": "path_simplify (enum url_scheme scheme, char *path)\n{\n  char *h = path;               \n  char *t = path;               \n  char *beg = path;\n  char *end = strchr (path, '\\0');\n\n  while (h < end)\n    {\n\n      if (h[0] == '.' && (h[1] == '/' || h[1] == '\\0'))\n        {\n          h += 2;\n        }\n      else if (h[0] == '.' && h[1] == '.' && (h[2] == '/' || h[2] == '\\0'))\n        {\n          if (t > beg)\n            {\n              for (--t; t > beg && t[-1] != '/'; t--)\n                ;\n            }\n          else if (scheme == SCHEME_FTP\n#ifdef HAVE_SSL\n              || scheme == SCHEME_FTPS\n#endif\n              )\n            {\n              beg = t + 3;\n              goto regular;\n            }\n          h += 3;\n        }\n      else\n        {\n        regular:\n          if (t == h)\n            {\n              while (h < end && *h != '/')\n                t++, h++;\n              if (h < end)\n                t++, h++;\n            }\n          else\n            {\n              while (h < end && *h != '/')\n                *t++ = *h++;\n              if (h < end)\n                *t++ = *h++;\n            }\n        }\n    }\n\n  if (t != h)\n    *t = '\\0';\n\n  return t != h;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188061, "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n    UNUSED(u1_is_idr_slice);\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))\n {\n        num_mb_skip++;\n }\n    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\n if(prev_slice_err == 1)\n {\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = -1;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n {\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n {\n if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)\n {\n                           j = i;\n break;\n }\n }\n }\n\n if(j == -1)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n\n                 }\n             }\n         }\n        ps_dec->u4_first_slice_in_pic = 0;\n     }\n     else\n     {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))\n {\n                ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;\n                ps_dec->u2_cur_mb_addr--;\n }\n\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n if(u1_num_mbs)\n {\n                ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n                ps_dec->u2_cur_mb_addr--;\n                ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <\n (UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))\n {\n                ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n                ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n                ps_dec->u2_cur_slice_num++;\n                ps_dec->ps_parse_cur_slice++;\n }\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->u2_mbx =\n (MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby =\n (DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby <<= u1_mbaff;\n\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n\n if(ps_dec->u4_first_slice_in_pic != 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "flaw_line_index": "135"}
{"idx": 8972, "func": "static bool _vmxnet3_assert_interrupt_line(VMXNET3State *s, uint32_t int_idx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    if (s->msix_used && msix_enabled(d)) {\n        VMW_IRPRN(\"Sending MSI-X notification for vector %u\", int_idx);\n        msix_notify(d, int_idx);\n        return false;\n    }\n    if (msi_enabled(d)) {\n        VMW_IRPRN(\"Sending MSI notification for vector %u\", int_idx);\n        msi_notify(d, int_idx);\n        return false;\n    }\n\n    VMW_IRPRN(\"Asserting line for interrupt %u\", int_idx);\n    pci_irq_assert(d);\n    return true;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187840, "func": " const CuePoint* Cues::GetFirst() const {\n  if (m_cue_points == NULL)\n     return NULL;\n \n  if (m_count == 0)\n    return NULL;\n#if 0\n    LoadCuePoint();  \n    const size_t count = m_count + m_preload_count;\n    if (count == 0)  \n        return NULL;\n#endif\n   CuePoint* const* const pp = m_cue_points;\n  assert(pp);\n \n   CuePoint* const pCP = pp[0];\n  assert(pCP);\n  assert(pCP->GetTimeCode() >= 0);\n \n   return pCP;\n }\n", "target": 1, "flaw_line_index": "2,5,6,7,8,9,10,11,12,14,17,18"}
{"idx": 8605, "func": "static void vmsvga_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->realize = pci_vmsvga_realize;\n    k->romfile = \"vgabios-vmware.bin\";\n    k->vendor_id = PCI_VENDOR_ID_VMWARE;\n    k->device_id = SVGA_PCI_DEVICE_ID;\n    k->class_id = PCI_CLASS_DISPLAY_VGA;\n    k->subsystem_vendor_id = PCI_VENDOR_ID_VMWARE;\n    k->subsystem_id = SVGA_PCI_DEVICE_ID;\n    dc->reset = vmsvga_reset;\n    dc->vmsd = &vmstate_vmware_vga;\n    dc->props = vga_vmware_properties;\n    dc->hotpluggable = false;\n    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8653, "func": "size_t mptsas_config_manufacturing_5(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(5, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x02,\n                              \"q*b*b*w*l*l\", s->sas_addr);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8516, "func": "static void hash_mpint(const struct ssh_hash *h, void *s, Bignum b)\n{\n    unsigned char *p;\n    int len;\n    p = ssh2_mpint_fmt(b, &len);\n    hash_string(h, s, p, len);\n    sfree(p);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187784, "func": "status_t NuPlayer::GenericSource::initFromDataSource() {\n    sp<MediaExtractor> extractor;\n String8 mimeType;\n float confidence;\n    sp<AMessage> dummy;\n bool isWidevineStreaming = false;\n\n    CHECK(mDataSource != NULL);\n\n if (mIsWidevine) {\n        isWidevineStreaming = SniffWVM(\n                mDataSource, &mimeType, &confidence, &dummy);\n if (!isWidevineStreaming ||\n                strcasecmp(\n                    mimeType.string(), MEDIA_MIMETYPE_CONTAINER_WVM)) {\n            ALOGE(\"unsupported widevine mime: %s\", mimeType.string());\n return UNKNOWN_ERROR;\n }\n } else if (mIsStreaming) {\n if (!mDataSource->sniff(&mimeType, &confidence, &dummy)) {\n return UNKNOWN_ERROR;\n }\n        isWidevineStreaming = !strcasecmp(\n                mimeType.string(), MEDIA_MIMETYPE_CONTAINER_WVM);\n }\n\n if (isWidevineStreaming) {\n        mCachedSource.clear();\n        mDataSource = mHttpSource;\n        mWVMExtractor = new WVMExtractor(mDataSource);\n        mWVMExtractor->setAdaptiveStreamingMode(true);\n if (mUIDValid) {\n            mWVMExtractor->setUID(mUID);\n }\n        extractor = mWVMExtractor;\n } else {\n        extractor = MediaExtractor::Create(mDataSource,\n                mimeType.isEmpty() ? NULL : mimeType.string());\n }\n\n if (extractor == NULL) {\n return UNKNOWN_ERROR;\n }\n\n if (extractor->getDrmFlag()) {\n        checkDrmStatus(mDataSource);\n }\n\n    mFileMeta = extractor->getMetaData();\n if (mFileMeta != NULL) {\n int64_t duration;\n if (mFileMeta->findInt64(kKeyDuration, &duration)) {\n            mDurationUs = duration;\n }\n\n if (!mIsWidevine) {\n const char *fileMime;\n if (mFileMeta->findCString(kKeyMIMEType, &fileMime)\n && !strncasecmp(fileMime, \"video/wvm\", 9)) {\n                mIsWidevine = true;\n }\n }\n }\n\n int32_t totalBitrate = 0;\n\n size_t numtracks = extractor->countTracks();\n if (numtracks == 0) {\n return UNKNOWN_ERROR;\n }\n\n \n     for (size_t i = 0; i < numtracks; ++i) {\n         sp<MediaSource> track = extractor->getTrack(i);\n \n         sp<MetaData> meta = extractor->getTrackMetaData(i);\n \n const char *mime;\n        CHECK(meta->findCString(kKeyMIMEType, &mime));\n\n if (!strncasecmp(mime, \"audio/\", 6)) {\n if (mAudioTrack.mSource == NULL) {\n                mAudioTrack.mIndex = i;\n                mAudioTrack.mSource = track;\n                mAudioTrack.mPackets =\n new AnotherPacketSource(mAudioTrack.mSource->getFormat());\n\n if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) {\n                    mAudioIsVorbis = true;\n } else {\n                    mAudioIsVorbis = false;\n }\n }\n } else if (!strncasecmp(mime, \"video/\", 6)) {\n if (mVideoTrack.mSource == NULL) {\n                mVideoTrack.mIndex = i;\n                mVideoTrack.mSource = track;\n                mVideoTrack.mPackets =\n new AnotherPacketSource(mVideoTrack.mSource->getFormat());\n\n int32_t secure;\n if (meta->findInt32(kKeyRequiresSecureBuffers, &secure)\n && secure) {\n                    mIsSecure = true;\n if (mUIDValid) {\n                        extractor->setUID(mUID);\n }\n }\n\n             }\n         }\n \n        if (track != NULL) {\n            mSources.push(track);\n            int64_t durationUs;\n            if (meta->findInt64(kKeyDuration, &durationUs)) {\n                if (durationUs > mDurationUs) {\n                    mDurationUs = durationUs;\n                }\n            }\n            int32_t bitrate;\n            if (totalBitrate >= 0 && meta->findInt32(kKeyBitRate, &bitrate)) {\n                totalBitrate += bitrate;\n            } else {\n                totalBitrate = -1;\n             }\n         }\n     }\n \n     mBitrate = totalBitrate;\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "122,123,124,125,126,127,128,129,130,131,132,133,134"}
{"idx": 188452, "func": "long Tracks::ParseTrackEntry(\n    long long track_start,\n    long long track_size,\n    long long element_start,\n    long long element_size,\n    Track*& pResult) const\n{\n    if (pResult)\n        return -1;\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = track_start;\n    const long long track_stop = track_start + track_size;\n    Track::Info info;\n    info.type = 0;\n    info.number = 0;\n    info.uid = 0;\n    info.defaultDuration = 0;\n    Track::Settings v;\n    v.start = -1;\n    v.size = -1;\n    Track::Settings a;\n    a.start = -1;\n    a.size = -1;\n    Track::Settings e;  \n    e.start = -1;\n    e.size = -1;\n    long long lacing = 1;  \n    while (pos < track_stop)\n    {\n        long long id, size;\n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                track_stop,\n                                id,\n                                size);\n        if (status < 0)  \n            return status;\n        if (size < 0)\n            return E_FILE_FORMAT_INVALID;\n        const long long start = pos;\n        if (id == 0x60)  \n        {\n            v.start = start;\n            v.size = size;\n        }\n        else if (id == 0x61)  \n        {\n            a.start = start;\n            a.size = size;\n        }\n        else if (id == 0x2D80) \n        {\n            e.start = start;\n            e.size = size;\n        }\n        else if (id == 0x33C5)  \n        {\n            if (size > 8)\n                return E_FILE_FORMAT_INVALID;\n            info.uid = 0;\n            long long pos_ = start;\n            const long long pos_end = start + size;\n            while (pos_ != pos_end)\n            {\n                unsigned char b;\n                const int status = pReader->Read(pos_, 1, &b);\n                if (status)\n                    return status;\n                info.uid <<= 8;\n                info.uid |= b;\n                ++pos_;\n            }\n        }\n        else if (id == 0x57)  \n        {\n            const long long num = UnserializeUInt(pReader, pos, size);\n            if ((num <= 0) || (num > 127))\n                return E_FILE_FORMAT_INVALID;\n            info.number = static_cast<long>(num);\n        }\n        else if (id == 0x03)  \n        {\n            const long long type = UnserializeUInt(pReader, pos, size);\n            if ((type <= 0) || (type > 254))\n                return E_FILE_FORMAT_INVALID;\n            info.type = static_cast<long>(type);\n        }\n        else if (id == 0x136E)  \n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.nameAsUTF8);\n            if (status)\n                return status;\n        }\n        else if (id == 0x02B59C)  \n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.language);\n            if (status)\n                return status;\n        }\n        else if (id == 0x03E383)  \n        {\n            const long long duration = UnserializeUInt(pReader, pos, size);\n            if (duration < 0)\n                return E_FILE_FORMAT_INVALID;\n            info.defaultDuration = static_cast<unsigned long long>(duration);\n        }\n        else if (id == 0x06)  \n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.codecId);\n            if (status)\n                return status;\n        }\n        else if (id == 0x1C)  \n        {\n            lacing = UnserializeUInt(pReader, pos, size);\n            if ((lacing < 0) || (lacing > 1))\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x23A2)  \n        {\n            delete[] info.codecPrivate;\n            info.codecPrivate = NULL;\n            info.codecPrivateSize = 0;\n            const size_t buflen = static_cast<size_t>(size);\n            if (buflen)\n            {\n                typedef unsigned char* buf_t;\n                const buf_t buf = new (std::nothrow) unsigned char[buflen];\n                if (buf == NULL)\n                    return -1;\n                const int status = pReader->Read(pos, buflen, buf);\n                if (status)\n                {\n                    delete[] buf;\n                    return status;\n                }\n                info.codecPrivate = buf;\n                info.codecPrivateSize = buflen;\n            }\n        }\n        else if (id == 0x058688)  \n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.codecNameAsUTF8);\n            if (status)\n                return status;\n        }\n        else if (id == 0x16AA)  \n        {\n            info.codecDelay = UnserializeUInt(pReader, pos, size);\n        }\n        else if (id == 0x16BB) \n        {\n            info.seekPreRoll = UnserializeUInt(pReader, pos, size);\n        }\n        pos += size;  \n        assert(pos <= track_stop);\n    }\n    assert(pos == track_stop);\n    if (info.number <= 0)  \n        return E_FILE_FORMAT_INVALID;\n    if (GetTrackByNumber(info.number))\n        return E_FILE_FORMAT_INVALID;\n    if (info.type <= 0)  \n        return E_FILE_FORMAT_INVALID;\n    info.lacing = (lacing > 0) ? true : false;\n    if (info.type == Track::kVideo)\n    {\n        if (v.start < 0)\n            return E_FILE_FORMAT_INVALID;\n        if (a.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        info.settings = v;\n        VideoTrack* pTrack = NULL;\n        const long status = VideoTrack::Parse(m_pSegment,\n                                              info,\n                                              element_start,\n                                              element_size,\n                                              pTrack);\n        if (status)\n            return status;\n        pResult = pTrack;\n        assert(pResult);\n        if (e.start >= 0)\n            pResult->ParseContentEncodingsEntry(e.start, e.size);\n    }\n    else if (info.type == Track::kAudio)\n    {\n        if (a.start < 0)\n            return E_FILE_FORMAT_INVALID;\n        if (v.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        info.settings = a;\n        AudioTrack* pTrack = NULL;\n        const long status = AudioTrack::Parse(m_pSegment,\n                                              info,\n                                              element_start,\n                                              element_size,\n                                              pTrack);\n        if (status)\n            return status;\n        pResult = pTrack;\n        assert(pResult);\n        if (e.start >= 0)\n            pResult->ParseContentEncodingsEntry(e.start, e.size);\n    }\n    else\n    {\n        if (a.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        if (v.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        if (e.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        info.settings.start = -1;\n        info.settings.size = 0;\n        Track* pTrack = NULL;\n        const long status = Track::Create(m_pSegment,\n                                          info,\n                                          element_start,\n                                          element_size,\n                                          pTrack);\n        if (status)\n            return status;\n        pResult = pTrack;\n        assert(pResult);\n    }\n    return 0;  \n}\n", "target": 1, "flaw_line_index": "2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246"}
{"idx": 8819, "func": "static void vrend_alpha_test_enable(struct vrend_context *ctx, bool alpha_test_enable)\n{\n   if (vrend_state.use_core_profile) {\n      return;\n   }\n   if (ctx->sub->alpha_test_enabled != alpha_test_enable) {\n      ctx->sub->alpha_test_enabled = alpha_test_enable;\n      if (alpha_test_enable)\n         glEnable(GL_ALPHA_TEST);\n      else\n         glDisable(GL_ALPHA_TEST);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8873, "func": "static void vrend_hw_emit_framebuffer_state(struct vrend_context *ctx)\n{\n   static const GLenum buffers[8] = {\n      GL_COLOR_ATTACHMENT0_EXT,\n      GL_COLOR_ATTACHMENT1_EXT,\n      GL_COLOR_ATTACHMENT2_EXT,\n      GL_COLOR_ATTACHMENT3_EXT,\n      GL_COLOR_ATTACHMENT4_EXT,\n      GL_COLOR_ATTACHMENT5_EXT,\n      GL_COLOR_ATTACHMENT6_EXT,\n      GL_COLOR_ATTACHMENT7_EXT,\n   };\n   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);\n\n   if (ctx->sub->nr_cbufs == 0) {\n      glReadBuffer(GL_NONE);\n      glDisable(GL_FRAMEBUFFER_SRGB_EXT);\n   } else {\n      struct vrend_surface *surf = NULL;\n      int i;\n      for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n         if (ctx->sub->surf[i]) {\n            surf = ctx->sub->surf[i];\n         }\n      }\n      if (util_format_is_srgb(surf->format)) {\n         glEnable(GL_FRAMEBUFFER_SRGB_EXT);\n      } else {\n         glDisable(GL_FRAMEBUFFER_SRGB_EXT);\n      }\n   }\n   glDrawBuffers(ctx->sub->nr_cbufs, buffers);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187962, "func": " status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"ProCamera2Client[%d] (%p) PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    result.append(\"  State: \");\n\n    mFrameProcessor->dump(fd, args);\n\n return dumpDevice(fd, args);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9031, "func": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    net_tx_pkt_init(&s->tx_pkt, PCI_DEVICE(s),\n                    s->max_tx_frags, s->peer_has_vhdr);\n    net_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n        }\n    }\n\n    vmxnet3_validate_queues(s);\n    vmxnet3_validate_interrupts(s);\n\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187901, "func": "void SoftAMR::onQueueFilled(OMX_U32 \n) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n\n         int32_t numBytesRead;\n \n         if (mMode == MODE_NARROW) {\n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; \n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n\n                 return;\n             }\n         } else {\n             int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n \n             if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n size_t frameSize = getFrameSize(mode);\n            CHECK_GE(inHeader->nFilledLen, frameSize);\n\n int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8583, "func": "static void ssh_process_incoming_data(Ssh ssh,\n\t\t\t\t      const unsigned char **data, int *datalen)\n{\n    struct Packet *pktin;\n\n    pktin = ssh->s_rdpkt(ssh, data, datalen);\n    if (pktin) {\n\tssh->protocol(ssh, NULL, 0, pktin);\n\tssh_free_packet(pktin);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8870, "func": "void vrend_get_query_result(struct vrend_context *ctx, uint32_t handle,\n                            uint32_t wait)\n{\n   struct vrend_query *q;\n   bool ret;\n\n   q = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_QUERY);\n   if (!q)\n      return;\n\n   ret = vrend_check_query(q);\n   if (ret == false)\n      list_addtail(&q->waiting_queries, &vrend_state.waiting_query_list);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187717, "func": " set_store_for_read(png_store *ps, png_infopp ppi, png_uint_32 id,\n   PNG_CONST char *name)\n {\n    safecat(ps->test, sizeof ps->test, 0, name);\n\n if (ps->pread != NULL)\n      png_error(ps->pread, \"read store already in use\");\n\n   store_read_reset(ps);\n\n#  ifdef PNG_USER_MEM_SUPPORTED\n if (!ps->speed)\n         ps->pread = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, ps,\n             store_error, store_warning, &ps->read_memory_pool, store_malloc,\n             store_free);\n\n else\n#  endif\n   ps->pread = png_create_read_struct(PNG_LIBPNG_VER_STRING, ps, store_error,\n      store_warning);\n\n if (ps->pread == NULL)\n {\n struct exception_context *the_exception_context = &ps->exception_context;\n\n      store_log(ps, NULL, \"png_create_read_struct returned NULL (unexpected)\",\n 1 \n);\n\n Throw ps;\n }\n\n#  ifdef PNG_SET_OPTION_SUPPORTED\n {\n int opt;\n for (opt=0; opt<ps->noptions; ++opt)\n if (png_set_option(ps->pread, ps->options[opt].option,\n               ps->options[opt].setting) == PNG_OPTION_INVALID)\n                  png_error(ps->pread, \"png option invalid\");\n }\n#  endif\n\n   store_read_set(ps, id);\n\n if (ppi != NULL)\n *ppi = ps->piread = png_create_info_struct(ps->pread);\n\n return ps->pread;\n}\n", "target": 1, "flaw_line_index": "2"}
{"idx": 8649, "func": "size_t mptsas_config_manufacturing_10(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(10, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187764, "func": "zlib_init(struct zlib *zlib, struct IDAT *idat, struct chunk *chunk,\n int window_bits, png_uint_32 offset)\n{\n   CLEAR(*zlib);\n\n   zlib->idat = idat;\n   zlib->chunk = chunk;\n   zlib->file = chunk->file;\n   zlib->global = chunk->global;\n   zlib->rewrite_offset = offset; \n\n   zlib->z.next_in = Z_NULL;\n   zlib->z.avail_in = 0;\n   zlib->z.zalloc = Z_NULL;\n   zlib->z.zfree = Z_NULL;\n   zlib->z.opaque = Z_NULL;\n\n   zlib->state = -1;\n   zlib->window_bits = window_bits;\n\n   zlib->compressed_digits = 0;\n   zlib->uncompressed_digits = 0;\n\n\n   zlib->file_bits = 16;\n    zlib->ok_bits = 16; \n    zlib->cksum = 0; \n \n   zlib->rc = inflateInit2(&zlib->z, 0);\n if (zlib->rc != Z_OK)\n {\n      zlib_message(zlib, 1\n);\n return 0;\n }\n\n else\n {\n      zlib->state = 0; \n return 1;\n }\n}\n", "target": 1, "flaw_line_index": "25"}
{"idx": 9181, "func": "uint32_t virtio_config_modern_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldub_p(vdev->config + addr);\n    return val;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8586, "func": "static int ssh_receive(Plug plug, int urgent, char *data, int len)\n{\n    Ssh ssh = (Ssh) plug;\n    ssh_gotdata(ssh, (unsigned char *)data, len);\n    if (ssh->state == SSH_STATE_CLOSED) {\n\tssh_do_close(ssh, TRUE);\n\treturn 0;\n    }\n    return 1;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8986, "func": "vmxnet3_dump_tx_descr(struct Vmxnet3_TxDesc *descr)\n{\n    VMW_PKPRN(\"TX DESCR: \"\n              \"addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n              \"dtype: %d, ext1: %d, msscof: %d, hlen: %d, om: %d, \"\n              \"eop: %d, cq: %d, ext2: %d, ti: %d, tci: %d\",\n              le64_to_cpu(descr->addr), descr->len, descr->gen, descr->rsvd,\n              descr->dtype, descr->ext1, descr->msscof, descr->hlen, descr->om,\n              descr->eop, descr->cq, descr->ext2, descr->ti, descr->tci);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187702, "func": "static void perform_gamma_sbit_tests(png_modifier *pm)\n{\n   png_byte sbit;\n\n for (sbit=pm->sbitlow; sbit<(1<<READ_BDHI); ++sbit)\n {\n\n       png_byte colour_type = 0, bit_depth = 0;\n       unsigned int npalette = 0;\n \n      while (next_format(&colour_type, &bit_depth, &npalette, 1\n))\n          if ((colour_type & PNG_COLOR_MASK_ALPHA) == 0 &&\n             ((colour_type == 3 && sbit < 8) ||\n             (colour_type != 3 && sbit < bit_depth)))\n {\n unsigned int i;\n\n for (i=0; i<pm->ngamma_tests; ++i)\n {\n unsigned int j;\n\n for (j=0; j<pm->ngamma_tests; ++j) if (i != j)\n {\n               gamma_transform_test(pm, colour_type, bit_depth, npalette,\n                  pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],\n                  sbit, pm->use_input_precision_sbit, 0 \n);\n\n if (fail(pm))\n return;\n }\n }\n }\n }\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 8770, "func": "static void perform_release(uint32_t server_addr, uint32_t requested_ip)\n{\n\tchar buffer[sizeof(\"255.255.255.255\")];\n\tstruct in_addr temp_addr;\n\n\tif (state == BOUND\n\t || state == RENEWING\n\t || state == REBINDING\n\t || state == RENEW_REQUESTED\n\t) {\n\t\ttemp_addr.s_addr = server_addr;\n\t\tstrcpy(buffer, inet_ntoa(temp_addr));\n\t\ttemp_addr.s_addr = requested_ip;\n\t\tbb_error_msg(\"unicasting a release of %s to %s\",\n\t\t\t\tinet_ntoa(temp_addr), buffer);\n\t\tsend_release(server_addr, requested_ip); \n\t}\n\tbb_error_msg(\"entering released state\");\n\tudhcp_run_script(NULL, \"deconfig\");\n\n\tchange_listen_mode(LISTEN_NONE);\n\tstate = RELEASED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9229, "func": "void virtio_queue_notify(VirtIODevice *vdev, int n)\n{\n    virtio_queue_notify_vq(&vdev->vq[n]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8472, "func": "void CSoundFile::FreePattern(LPVOID pat)\n{\n\tif (pat) delete [] (signed char*)pat;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8835, "func": "int vrend_create_so_target(struct vrend_context *ctx,\n                           uint32_t handle,\n                           uint32_t res_handle,\n                           uint32_t buffer_offset,\n                           uint32_t buffer_size)\n{\n   struct vrend_so_target *target;\n   struct vrend_resource *res;\n   int ret_handle;\n   res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n   if (!res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n      return EINVAL;\n   }\n\n   target = CALLOC_STRUCT(vrend_so_target);\n   if (!target)\n      return ENOMEM;\n\n   pipe_reference_init(&target->reference, 1);\n   target->res_handle = res_handle;\n   target->buffer_offset = buffer_offset;\n   target->buffer_size = buffer_size;\n   target->sub_ctx = ctx->sub;\n   vrend_resource_reference(&target->buffer, res);\n\n   ret_handle = vrend_renderer_object_insert(ctx, target, sizeof(*target), handle,\n                                             VIRGL_OBJECT_STREAMOUT_TARGET);\n   if (ret_handle == 0) {\n      FREE(target);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187383, "func": "status_t BnHDCP::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case HDCP_SET_OBSERVER:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n return OK;\n }\n\n case HDCP_INIT_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n const char *host = data.readCString();\n unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n return OK;\n }\n\n case HDCP_SHUTDOWN_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n return OK;\n }\n\n case HDCP_GET_CAPS:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n return OK;\n }\n\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n \n            void *inData = malloc(2 * size);\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR;\n status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n case HDCP_ENCRYPT_NATIVE:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n size_t offset = data.readInt32();\n size_t size = data.readInt32();\n uint32_t streamCTR = data.readInt32();\n void *outData = malloc(size);\n uint64_t inputCTR;\n\n status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(outData);\n            outData = NULL;\n\n return OK;\n }\n\n\n         case HDCP_DECRYPT:\n         {\n             size_t size = data.readInt32();\n \n            void *inData = malloc(2 * size);\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR = data.readInt64();\n status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": "47,102"}
{"idx": 9107, "func": "static int vrend_decode_draw_vbo(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_draw_info info;\n   uint32_t cso;\n   if (length != VIRGL_DRAW_VBO_SIZE)\n      return EINVAL;\n   memset(&info, 0, sizeof(struct pipe_draw_info));\n\n   info.start = get_buf_entry(ctx, VIRGL_DRAW_VBO_START);\n   info.count = get_buf_entry(ctx, VIRGL_DRAW_VBO_COUNT);\n   info.mode = get_buf_entry(ctx, VIRGL_DRAW_VBO_MODE);\n   info.indexed = get_buf_entry(ctx, VIRGL_DRAW_VBO_INDEXED);\n   info.instance_count = get_buf_entry(ctx, VIRGL_DRAW_VBO_INSTANCE_COUNT);\n   info.index_bias = get_buf_entry(ctx, VIRGL_DRAW_VBO_INDEX_BIAS);\n   info.start_instance = get_buf_entry(ctx, VIRGL_DRAW_VBO_START_INSTANCE);\n   info.primitive_restart = get_buf_entry(ctx, VIRGL_DRAW_VBO_PRIMITIVE_RESTART);\n   info.restart_index = get_buf_entry(ctx, VIRGL_DRAW_VBO_RESTART_INDEX);\n   info.min_index = get_buf_entry(ctx, VIRGL_DRAW_VBO_MIN_INDEX);\n   info.max_index = get_buf_entry(ctx, VIRGL_DRAW_VBO_MAX_INDEX);\n\n   cso = get_buf_entry(ctx, VIRGL_DRAW_VBO_COUNT_FROM_SO);\n\n   vrend_draw_vbo(ctx->grctx, &info, cso);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8477, "func": "UINT CSoundFile::GetCurrentPos() const\n{\n\tUINT pos = 0;\n\n\tfor (UINT i=0; i<m_nCurrentPattern; i++) if (Order[i] < MAX_PATTERNS)\n\t\tpos += PatternSize[Order[i]];\n\treturn pos + m_nRow;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188570, "func": "   void RunCoeffCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 5000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j)\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n \n       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n }\n }\n", "target": 1, "flaw_line_index": "4,5,6,9,11,14"}
{"idx": 187436, "func": "bool SoftVPX::outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader) {\n uint32_t width = outputBufferWidth();\n uint32_t height = outputBufferHeight();\n\n     uint64_t nFilledLen = width;\n     nFilledLen *= height;\n     if (nFilledLen > UINT32_MAX / 3) {\n        ALOGE(\"b/29421675, nFilledLen overflow %llu w %u h %u\", nFilledLen, width, height);\n         android_errorWriteLog(0x534e4554, \"29421675\");\n         return false;\n     } else if (outHeader->nAllocLen < outHeader->nFilledLen) {\n        ALOGE(\"b/27597103, buffer too small\");\n        android_errorWriteLog(0x534e4554, \"27597103\");\n return false;\n }\n\n return true;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 188133, "func": "WORD32 ihevcd_create(iv_obj_t *ps_codec_obj,\n\n                            void *pv_api_ip,\n                            void *pv_api_op)\n {\n     ihevcd_cxa_create_op_t *ps_create_op;\n \n     WORD32 ret;\n     codec_t *ps_codec;\n     ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;\n \n     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n     ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);\n \n    if((IV_FAIL == ret) && (NULL != ps_codec_obj))\n     {\n        ihevcd_free_static_bufs(ps_codec_obj);\n         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n \n return IV_FAIL;\n }\n    ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;\n    ret = ihevcd_init(ps_codec);\n\n    TRACE_INIT(NULL);\n    STATS_INIT();\n\n return ret;\n}\n", "target": 1, "flaw_line_index": "15,17"}
{"idx": 188006, "func": " static inline ogg_uint32_t decode_packed_entry_number(codebook *book,\n\t\t\t\t\t\t      oggpack_buffer *b){\n   ogg_uint32_t chase=0;\n   int  read=book->dec_maxlength;\n   long lok = oggpack_look(b,read),i;\n\n while(lok<0 && read>1)\n    lok = oggpack_look(b, --read);\n\n if(lok<0){\n    oggpack_adv(b,1); \n return -1;\n }\n\n switch (book->dec_method)\n {\n case 0:\n {\n\n       unsigned char *t=(unsigned char *)book->dec_table;\n \n       for(i=0;i<read;i++){\n\tchase=t[chase*2+((lok>>i)&1)];\n\tif(chase&0x80UL)break;\n       }\n       chase&=0x7fUL;\n       break;\n }\n case 1:\n {\n\n       unsigned char *t=(unsigned char *)book->dec_table;\n       for(i=0;i<read;i++){\n\tint bit=(lok>>i)&1;\n\tint next=t[chase+bit];\n\tif(next&0x80){\n\t  chase= (next<<8) | t[chase+bit+1+(!bit || t[chase]&0x80)];\n\t  break;\n\t}\n\tchase=next;\n       }\n       chase&=~0x8000UL;\n break;\n }\n case 2:\n {\n\n       for(i=0;i<read;i++){\n\tchase=((ogg_uint16_t *)(book->dec_table))[chase*2+((lok>>i)&1)];\n\tif(chase&0x8000UL)break;\n       }\n       chase&=~0x8000UL;\n break;\n }\n case 3:\n {\n\n       ogg_uint16_t *t=(ogg_uint16_t *)book->dec_table;\n       for(i=0;i<read;i++){\n\tint bit=(lok>>i)&1;\n\tint next=t[chase+bit];\n\tif(next&0x8000){\n\t  chase= (next<<16) | t[chase+bit+1+(!bit || t[chase]&0x8000)];\n\t  break;\n\t}\n\tchase=next;\n       }\n       chase&=~0x80000000UL;\n break;\n }\n case 4:\n\n     {\n       for(i=0;i<read;i++){\n\tchase=((ogg_uint32_t *)(book->dec_table))[chase*2+((lok>>i)&1)];\n\tif(chase&0x80000000UL)break;\n       }\n       chase&=~0x80000000UL;\n break;\n }\n }\n\n if(i<read){\n    oggpack_adv(b,i+1);\n return chase;\n }\n  oggpack_adv(b,read+1);\n return(-1);\n}\n", "target": 1, "flaw_line_index": "2,23,24,34,35,36,37,38,39,40,50,51,62,63,64,65,66,67,68,79,80"}
{"idx": 8497, "func": "BOOL CSoundFile::SetPatternName(UINT nPat, LPCSTR lpszName)\n{\n        char szName[MAX_PATTERNNAME] = \"\";   \n\tif (nPat >= MAX_PATTERNS) return FALSE;\n\tif (lpszName) lstrcpyn(szName, lpszName, MAX_PATTERNNAME);\n\tszName[MAX_PATTERNNAME-1] = 0;\n\tif (!m_lpszPatternNames) m_nPatternNames = 0;\n\tif (nPat >= m_nPatternNames)\n\t{\n\t\tif (!lpszName[0]) return TRUE;\n\t\tUINT len = (nPat+1)*MAX_PATTERNNAME;\n\t\tchar *p = new char[len];   \n\t\tif (!p) return FALSE;\n\t\tmemset(p, 0, len);\n\t\tif (m_lpszPatternNames)\n\t\t{\n\t\t\tmemcpy(p, m_lpszPatternNames, m_nPatternNames * MAX_PATTERNNAME);\n\t\t\tdelete m_lpszPatternNames;\n\t\t\tm_lpszPatternNames = NULL;\n\t\t}\n\t\tm_lpszPatternNames = p;\n\t\tm_nPatternNames = nPat + 1;\n\t}\n\tmemcpy(m_lpszPatternNames + nPat * MAX_PATTERNNAME, szName, MAX_PATTERNNAME);\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188005, "func": "static int decode_map(codebook *s, oggpack_buffer *b, ogg_int32_t *v, int point){\n ogg_uint32_t entry = decode_packed_entry_number(s,b);\n int i;\n if(oggpack_eop(b))return(-1);\n\n\n switch(s->dec_type){\n case 1:{\n int mask=(1<<s->q_bits)-1;\n for(i=0;i<s->dim;i++){\n      v[i]=entry&mask;\n      entry>>=s->q_bits;\n }\n break;\n }\n case 2:{\n\n     int mask=(1<<s->q_pack)-1;\n     for(i=0;i<s->dim;i++){\n       if(s->q_bits<=8)\n\tv[i]=((unsigned char *)(s->q_val))[entry&mask];\n       else\n\tv[i]=((ogg_uint16_t *)(s->q_val))[entry&mask];\n       entry>>=s->q_pack;\n     }\n     break;\n }\n case 3:{\n void *ptr=((char *)s->q_val)+entry*s->q_pack;\n\n \n     if(s->q_bits<=8){\n       for(i=0;i<s->dim;i++)\n\tv[i]=((unsigned char *)ptr)[i];\n     }else{\n       for(i=0;i<s->dim;i++)\n\tv[i]=((ogg_uint16_t *)ptr)[i];\n     }\n     break;\n   }\n default:\n return -1;\n }\n\n {\n int         shiftM = point-s->q_delp;\n ogg_int32_t add    = point-s->q_minp;\n int         mul    = s->q_del;\n\n if(add>0)\n      add= s->q_min >> add;\n else\n      add= s->q_min << -add;\n if (shiftM<0)\n {\n      mul <<= -shiftM;\n      shiftM = 0;\n }\n    add <<= shiftM;\n\n for(i=0;i<s->dim;i++)\n      v[i]= ((add + v[i] * mul) >> shiftM);\n\n \n     if(s->q_seq)\n       for(i=1;i<s->dim;i++)\n\tv[i]+=v[i-1];\n   }\n \n   return 0;\n}\n", "target": 1, "flaw_line_index": "21,23,34,37,67"}
{"idx": 187523, "func": "OMX_ERRORTYPE  omx_video::allocate_input_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes)\n{\n (void)hComp, (void)port;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned   i = 0;\n\n    DEBUG_PRINT_HIGH(\"allocate_input_buffer()::\");\n if (bytes != m_sInPortDef.nBufferSize) {\n        DEBUG_PRINT_ERROR(\"ERROR: Buffer size mismatch error: bytes[%u] != nBufferSize[%u]\",\n (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);\n return OMX_ErrorBadParameter;\n }\n\n if (!m_inp_mem_ptr) {\n        DEBUG_PRINT_HIGH(\"%s: size = %u, actual cnt %u\", __FUNCTION__,\n (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountActual);\n        m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\\n                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);\n if (m_inp_mem_ptr == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");\n return OMX_ErrorInsufficientResources;\n }\n\n        DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);\n        m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);\n\n if (m_pInput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n#ifdef USE_ION\n        m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);\n if (m_pInput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n            m_pInput_pmem[i].fd = -1;\n#ifdef USE_ION\n            m_pInput_ion[i].ion_device_fd =-1;\n            m_pInput_ion[i].fd_ion_data.fd =-1;\n            m_pInput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n }\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_inp_bm_count,i)) {\n break;\n }\n }\n if (i < m_sInPortDef.nBufferCountActual) {\n\n *bufferHdr = (m_inp_mem_ptr + i);\n (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);\n (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;\n (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;\n (*bufferHdr)->pAppPrivate       = appData;\n (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;\n (*bufferHdr)->pInputPortPrivate = (OMX_PTR)&m_pInput_pmem[i];\n\n#ifdef USE_ION\n#ifdef _MSM8974_\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,0);\n#else\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pInput_ion[i].ion_device_fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n\n        m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;\n#else\n        m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n\n if (m_pInput_pmem[i].fd == 0) {\n            m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pInput_pmem[i].fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n\n         m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n         m_pInput_pmem[i].offset = 0;\n \n        m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n         if(!secure_session) {\n             m_pInput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                 m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,\n                 MAP_SHARED,m_pInput_pmem[i].fd,0);\n         if (m_pInput_pmem[i].buffer == MAP_FAILED) {\n                 DEBUG_PRINT_ERROR(\"ERROR: mmap FAILED= %d\", errno);\n             close(m_pInput_pmem[i].fd);\n #ifdef USE_ION\n             free_ion_memory(&m_pInput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n } else {\n\n             m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));\n             (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);\n         }\n \n (*bufferHdr)->pBuffer           = (OMX_U8 *)m_pInput_pmem[i].buffer;\n        DEBUG_PRINT_LOW(\"Virtual address in allocate buffer is %p\", m_pInput_pmem[i].buffer);\n        BITMASK_SET(&m_inp_bm_count,i);\n if (!mUseProxyColorFormat && (dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true)) {\n            DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf FAILED for i/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: All i/p buffers are allocated, invalid allocate buf call\"\n \"for index [%d]\", i);\n        eRet = OMX_ErrorInsufficientResources;\n }\n\n return eRet;\n}\n", "target": 1, "flaw_line_index": "101"}
{"idx": 187491, "func": "int sock_send_all(int sock_fd, const uint8_t* buf, int len)\n{\n int s = len;\n\n     int ret;\n     while(s)\n     {\n        do ret = send(sock_fd, buf, s, 0);\n         while(ret < 0 && errno == EINTR);\n         if(ret <= 0)\n         {\n            BTIF_TRACE_ERROR(\"sock fd:%d send errno:%d, ret:%d\", sock_fd, errno, ret);\n return -1;\n }\n        buf += ret;\n        s -= ret;\n }\n return len;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 188040, "func": "static void copyMultiCh16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\n {\n     for (unsigned i = 0; i < nSamples; ++i) {\n         for (unsigned c = 0; c < nChannels; ++c) {\n *dst++ = src[c][i];\n }\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8950, "func": "int vrend_create_shader(struct vrend_context *ctx,\n                        uint32_t handle,\n                        const struct pipe_stream_output_info *so_info,\n                        const char *shd_text, uint32_t offlen, uint32_t num_tokens,\n                        uint32_t type, uint32_t pkt_length)\n{\n   struct vrend_shader_selector *sel = NULL;\n   int ret_handle;\n   bool new_shader = true, long_shader = false;\n   bool finished = false;\n   int ret;\n\n   if (type > PIPE_SHADER_GEOMETRY)\n      return EINVAL;\n\n   if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)\n      new_shader = false;\n   else if (((offlen + 3) / 4) > pkt_length)\n      long_shader = true;\n\n   if (ctx->sub->long_shader_in_progress_handle[type]) {\n      if (new_shader == true)\n         return EINVAL;\n      if (handle != ctx->sub->long_shader_in_progress_handle[type])\n         return EINVAL;\n   }\n\n   if (new_shader) {\n     sel = vrend_create_shader_state(ctx, so_info, type);\n     if (sel == NULL)\n       return ENOMEM;\n\n     if (long_shader) {\n        sel->buf_len = ((offlen + 3) / 4) * 4; \n        sel->tmp_buf = malloc(sel->buf_len);\n        if (!sel->tmp_buf) {\n           ret = ENOMEM;\n           goto error;\n        }\n        memcpy(sel->tmp_buf, shd_text, pkt_length * 4);\n        sel->buf_offset = pkt_length * 4;\n        ctx->sub->long_shader_in_progress_handle[type] = handle;\n     } else\n        finished = true;\n   } else {\n      sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);\n      if (!sel) {\n         fprintf(stderr, \"got continuation without original shader %d\\n\", handle);\n         ret = EINVAL;\n         goto error;\n      }\n\n      offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;\n      if (offlen != sel->buf_offset) {\n         fprintf(stderr, \"Got mismatched shader continuation %d vs %d\\n\",\n                 offlen, sel->buf_offset);\n         ret = EINVAL;\n         goto error;\n      }\n      if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {\n         fprintf(stderr, \"Got too large shader continuation %d vs %d\\n\",\n                 pkt_length * 4 + sel->buf_offset, sel->buf_len);\n         ret = EINVAL;\n         goto error;\n      }\n\n      memcpy(sel->tmp_buf + sel->buf_offset, shd_text, pkt_length * 4);\n\n      sel->buf_offset += pkt_length * 4;\n      if (sel->buf_offset >= sel->buf_len) {\n         finished = true;\n         shd_text = sel->tmp_buf;\n      }\n   }\n\n   if (finished) {\n      struct tgsi_token *tokens;\n\n      tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));\n      if (!tokens) {\n         ret = ENOMEM;\n         goto error;\n      }\n\n      if (vrend_dump_shaders)\n         fprintf(stderr,\"shader\\n%s\\n\", shd_text);\n      if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      }\n\n      if (vrend_finish_shader(ctx, sel, tokens)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      } else {\n         free(sel->tmp_buf);\n         sel->tmp_buf = NULL;\n      }\n      free(tokens);\n      ctx->sub->long_shader_in_progress_handle[type] = 0;\n   }\n\n   if (new_shader) {\n      ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);\n      if (ret_handle == 0) {\n         ret = ENOMEM;\n         goto error;\n      }\n   }\n\n   return 0;\n\nerror:\n   if (new_shader)\n      vrend_destroy_shader_selector(sel);\n   else\n      vrend_renderer_object_destroy(ctx, handle);\n\n   return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8769, "func": "static int mton(uint32_t mask)\n{\n\tint i = 0;\n\tmask = ntohl(mask); \n\twhile (mask) {\n\t\ti++;\n\t\tmask <<= 1;\n\t}\n\treturn i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9039, "func": "static void vmxnet3_put_txq_descr(QEMUFile *f, void *pv, size_t size)\n{\n    Vmxnet3TxqDescr *r = pv;\n\n    vmxnet3_put_ring_to_file(f, &r->tx_ring);\n    vmxnet3_put_ring_to_file(f, &r->comp_ring);\n    qemu_put_byte(f, r->intr_idx);\n    qemu_put_be64(f, r->tx_stats_pa);\n    vmxnet3_put_tx_stats_to_file(f, &r->txq_stats);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8790, "func": "static int check_resource_valid(struct vrend_renderer_resource_create_args *args)\n{\n   if (args->handle == 0)\n      return -1;\n\n   if (args->target >= PIPE_MAX_TEXTURE_TYPES)\n      return -1;\n\n   if (args->format >= VIRGL_FORMAT_MAX)\n      return -1;\n\n   if (args->nr_samples > 1) {\n      if (args->target != PIPE_TEXTURE_2D && args->target != PIPE_TEXTURE_2D_ARRAY)\n         return -1;\n      if (args->last_level > 0)\n         return -1;\n   }\n\n   if (args->last_level > 0) {\n      if (args->target == PIPE_BUFFER || args->target == PIPE_TEXTURE_RECT)\n         return -1;\n      if (args->last_level > (floor(log2(MAX2(args->width, args->height))) + 1))\n         return -1;\n   }\n   if (args->flags != 0 && args->flags != VIRGL_RESOURCE_Y_0_TOP)\n      return -1;\n\n   if (args->flags & VIRGL_RESOURCE_Y_0_TOP)\n      if (args->target != PIPE_TEXTURE_2D && args->target != PIPE_TEXTURE_RECT)\n         return -1;\n\n   if (args->target == PIPE_TEXTURE_CUBE) {\n      if (args->array_size != 6)\n         return -1;\n   } else if (args->target == PIPE_TEXTURE_CUBE_ARRAY) {\n      if (args->array_size % 6)\n         return -1;\n   } else if (args->array_size > 1) {\n      if (args->target != PIPE_TEXTURE_2D_ARRAY &&\n          args->target != PIPE_TEXTURE_1D_ARRAY)\n         return -1;\n   }\n\n   if (args->bind == 0 ||\n       args->bind == VREND_RES_BIND_CUSTOM ||\n       args->bind == VREND_RES_BIND_INDEX_BUFFER ||\n       args->bind == VREND_RES_BIND_STREAM_OUTPUT ||\n       args->bind == VREND_RES_BIND_VERTEX_BUFFER ||\n       args->bind == VREND_RES_BIND_CONSTANT_BUFFER) {\n      if (args->target != PIPE_BUFFER)\n         return -1;\n      if (args->height != 1 || args->depth != 1)\n         return -1;\n   } else {\n      if (!((args->bind & VREND_RES_BIND_SAMPLER_VIEW) ||\n            (args->bind & VREND_RES_BIND_DEPTH_STENCIL) ||\n            (args->bind & VREND_RES_BIND_RENDER_TARGET) ||\n            (args->bind & VREND_RES_BIND_CURSOR)))\n         return -1;\n\n      if (args->target == PIPE_TEXTURE_2D ||\n          args->target == PIPE_TEXTURE_RECT ||\n          args->target == PIPE_TEXTURE_CUBE ||\n          args->target == PIPE_TEXTURE_2D_ARRAY ||\n          args->target == PIPE_TEXTURE_CUBE_ARRAY) {\n         if (args->depth != 1)\n            return -1;\n      }\n      if (args->target == PIPE_TEXTURE_1D ||\n          args->target == PIPE_TEXTURE_1D_ARRAY) {\n         if (args->height != 1 || args->depth != 1)\n            return -1;\n      }\n   }\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8883, "func": "void vrend_object_bind_blend(struct vrend_context *ctx,\n                             uint32_t handle)\n{\n   struct pipe_blend_state *state;\n\n   if (handle == 0) {\n      memset(&ctx->sub->blend_state, 0, sizeof(ctx->sub->blend_state));\n      vrend_blend_enable(ctx, false);\n      return;\n   }\n   state = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_BLEND);\n   if (!state) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_HANDLE, handle);\n      return;\n   }\n\n   ctx->sub->blend_state = *state;\n\n   vrend_hw_emit_blend(ctx, &ctx->sub->blend_state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187509, "func": " ssize_t socket_write(const socket_t *socket, const void *buf, size_t count) {\n   assert(socket != NULL);\n   assert(buf != NULL);\n \n  return send(socket->fd, buf, count, MSG_DONTWAIT);\n }\n", "target": 1, "flaw_line_index": "5"}
{"idx": 8514, "func": "static int do_ssh_init(Ssh ssh, unsigned char c)\n{\n    static const char protoname[] = \"SSH-\";\n\n    struct do_ssh_init_state {\n\tint crLine;\n\tint vslen;\n\tchar version[10];\n\tchar *vstring;\n\tint vstrsize;\n\tint i;\n\tint proto1, proto2;\n    };\n    crState(do_ssh_init_state);\n    \n    crBeginState;\n\n    for (;;) {\n        for (s->i = 0; protoname[s->i]; s->i++) {\n            if ((char)c != protoname[s->i]) goto no;\n            crReturn(1);\n        }\n\tbreak;\n      no:\n\twhile (c != '\\012')\n\t    crReturn(1);\n\tcrReturn(1);\n    }\n\n    ssh->session_started = TRUE;\n\n    s->vstrsize = sizeof(protoname) + 16;\n    s->vstring = snewn(s->vstrsize, char);\n    strcpy(s->vstring, protoname);\n    s->vslen = strlen(protoname);\n    s->i = 0;\n    while (1) {\n\tif (s->vslen >= s->vstrsize - 1) {\n\t    s->vstrsize += 16;\n\t    s->vstring = sresize(s->vstring, s->vstrsize, char);\n\t}\n\ts->vstring[s->vslen++] = c;\n\tif (s->i >= 0) {\n\t    if (c == '-') {\n\t\ts->version[s->i] = '\\0';\n\t\ts->i = -1;\n\t    } else if (s->i < sizeof(s->version) - 1)\n\t\ts->version[s->i++] = c;\n\t} else if (c == '\\012')\n\t    break;\n\tcrReturn(1);\t\t       \n    }\n\n    ssh->agentfwd_enabled = FALSE;\n    ssh->rdpkt2_state.incoming_sequence = 0;\n\n    s->vstring[s->vslen] = 0;\n    s->vstring[strcspn(s->vstring, \"\\015\\012\")] = '\\0';\n    logeventf(ssh, \"Server version: %s\", s->vstring);\n    ssh_detect_bugs(ssh, s->vstring);\n\n\n    s->proto1 = ssh_versioncmp(s->version, \"2.0\") < 0;\n    s->proto2 = ssh_versioncmp(s->version, \"1.99\") >= 0;\n\n    if (conf_get_int(ssh->conf, CONF_sshprot) == 0) {\n\tif (!s->proto1) {\n\t    bombout((\"SSH protocol version 1 required by our configuration \"\n\t\t     \"but not provided by server\"));\n\t    crStop(0);\n\t}\n    } else if (conf_get_int(ssh->conf, CONF_sshprot) == 3) {\n\tif (!s->proto2) {\n\t    bombout((\"SSH protocol version 2 required by our configuration \"\n\t\t     \"but server only provides (old, insecure) SSH-1\"));\n\t    crStop(0);\n\t}\n    } else {\n\tassert(!\"Unexpected value for CONF_sshprot\");\n    }\n\n    if (s->proto2 && (conf_get_int(ssh->conf, CONF_sshprot) >= 2 || !s->proto1))\n\tssh->version = 2;\n    else\n\tssh->version = 1;\n\n    logeventf(ssh, \"Using SSH protocol version %d\", ssh->version);\n\n    if (conf_get_int(ssh->conf, CONF_sshprot) != 3)\n\tssh_send_verstring(ssh, protoname, s->version);\n\n    if (ssh->version == 2) {\n\tsize_t len;\n\tlen = strcspn(s->vstring, \"\\015\\012\");\n\tssh->v_s = snewn(len + 1, char);\n\tmemcpy(ssh->v_s, s->vstring, len);\n\tssh->v_s[len] = 0;\n\t    \n\tssh->protocol = ssh2_protocol;\n\tssh2_protocol_setup(ssh);\n\tssh->s_rdpkt = ssh2_rdpkt;\n    } else {\n\tssh->protocol = ssh1_protocol;\n\tssh1_protocol_setup(ssh);\n\tssh->s_rdpkt = ssh1_rdpkt;\n    }\n    if (ssh->version == 2)\n\tdo_ssh2_transport(ssh, NULL, -1, NULL);\n\n    update_specials_menu(ssh->frontend);\n    ssh->state = SSH_STATE_BEFORE_SIZE;\n    ssh->pinger = pinger_new(ssh->conf, &ssh_backend, ssh);\n\n    sfree(s->vstring);\n\n    crFinish(0);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188632, "func": "void impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)\n {\n     stream_t *ps_stream = &ps_dec->s_bit_stream;\n     UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n const dec_mb_params_t *ps_dec_mb_params;\n if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n }\n else\n {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n\n if(ps_dec->u2_first_mb)\n {\n            ps_dec->u2_mb_x = u2_mb_addr_incr - 1;\n            ps_dec->u2_mb_x = MIN(ps_dec->u2_mb_x, (ps_dec->u2_num_horiz_mb - 1));\n\n            u2_mb_addr_incr = 1;\n            ps_dec->u2_first_mb = 0;\n }\n else\n {\n if(ps_dec->u2_is_mpeg2 &&\n ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb))\n {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n }\n\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n }\n\n }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n }\n {\n        WORD32 i4_motion_type = ps_dec->u2_motion_type;\n\n if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n {\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len += MB_MOTION_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n }\n\n\n if ((u2_mb_type & MB_FORW_OR_BACK) &&\n ((i4_motion_type == 0) ||\n (i4_motion_type == 3) ||\n (i4_motion_type == 4) ||\n (i4_motion_type >= 7)))\n {\n            i4_motion_type = 1;\n }\n\n }\n {\n if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n }\n }\n if(u2_mb_type & MB_QUANT)\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n if(u2_mb_type & MB_BIDRECT)\n {\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = BIDIRECT;\n         ps_dec_mb_params = &ps_dec->ps_func_bi_direct[u2_index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n     }\n     else if(u2_mb_type & MB_FORW_OR_BACK)\n {\n\n        UWORD16 u2_refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = (e_pred_direction_t)u2_refPic;\n         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[u2_index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n \n     }\n else if(u2_mb_type & MB_TYPE_INTRA)\n {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n }\n else\n {\n        ps_dec->u2_prev_intra_mb =0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n }\n\n if((u2_mb_type & MB_TYPE_INTRA))\n {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n }\n else\n {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n if((ps_dec->u2_coded_mb))\n {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n }\n else\n {\n\n             ps_dec->u2_cbp  = 0;\n         }\n     }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8705, "func": "uri_merge (const char *base, const char *link)\n{\n  int linklength;\n  const char *end;\n  char *merge;\n\n  if (url_has_scheme (link))\n    return xstrdup (link);\n\n  end = path_end (base);\n  linklength = strlen (link);\n\n  if (!*link)\n    {\n      return xstrdup (base);\n    }\n  else if (*link == '?')\n    {\n      int baselength = end - base;\n      merge = xmalloc (baselength + linklength + 1);\n      memcpy (merge, base, baselength);\n      memcpy (merge + baselength, link, linklength);\n      merge[baselength + linklength] = '\\0';\n    }\n  else if (*link == '#')\n    {\n      int baselength;\n      const char *end1 = strchr (base, '#');\n      if (!end1)\n        end1 = base + strlen (base);\n      baselength = end1 - base;\n      merge = xmalloc (baselength + linklength + 1);\n      memcpy (merge, base, baselength);\n      memcpy (merge + baselength, link, linklength);\n      merge[baselength + linklength] = '\\0';\n    }\n  else if (*link == '/' && *(link + 1) == '/')\n    {\n      /* LINK begins with \"\n         replace everything after (and including) the double slash\n\n      /* uri_merge(\"foo\", \"\n      /* uri_merge(\"\n      /* uri_merge(\"http:\n\n      int span;\n      const char *slash;\n      const char *start_insert;\n\n      slash = memchr (base, '/', end - base);\n      if (slash && *(slash + 1) == '/')\n        start_insert = slash;\n      else\n        start_insert = base;\n\n      span = start_insert - base;\n      merge = xmalloc (span + linklength + 1);\n      if (span)\n        memcpy (merge, base, span);\n      memcpy (merge + span, link, linklength);\n      merge[span + linklength] = '\\0';\n    }\n  else if (*link == '/')\n    {\n         So, if BASE is \"http:\n         \"http:\n      const char *start_insert = NULL; \n    again:\n      slash = memchr (pos, '/', end - pos);\n      if (slash && !seen_slash_slash)\n        if (*(slash + 1) == '/')\n          {\n            pos = slash + 2;\n            seen_slash_slash = true;\n            goto again;\n          }\n\n         \"\n\n      if (!slash && !seen_slash_slash)\n        start_insert = base;\n      else if (!slash && seen_slash_slash)\n        /* example: \"http:\n        start_insert = end;\n      else if (slash && !seen_slash_slash)\n        start_insert = base;\n      else if (slash && seen_slash_slash)\n        /* example: \"http:\n        start_insert = slash;\n\n      span = start_insert - base;\n      merge = xmalloc (span + linklength + 1);\n      if (span)\n        memcpy (merge, base, span);\n      memcpy (merge + span, link, linklength);\n      merge[span + linklength] = '\\0';\n    }\n  else\n    {\n      bool need_explicit_slash = false;\n      int span;\n      const char *start_insert;\n      const char *last_slash = find_last_char (base, end, '/');\n      if (!last_slash)\n        {\n          start_insert = base;\n        }\n      else if (last_slash && last_slash >= base + 2\n               && last_slash[-2] == ':' && last_slash[-1] == '/')\n        {\n          /* example: http:\n          start_insert = end + 1;\n          need_explicit_slash = true;\n        }\n      else\n        {\n          start_insert = last_slash + 1;\n        }\n\n      span = start_insert - base;\n      merge = xmalloc (span + linklength + 1);\n      if (span)\n        memcpy (merge, base, span);\n      if (need_explicit_slash)\n        merge[span - 1] = '/';\n      memcpy (merge + span, link, linklength);\n      merge[span + linklength] = '\\0';\n    }\n\n  return merge;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8646, "func": "size_t mptsas_config_ioc_5(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(5, MPI_CONFIG_PAGETYPE_IOC, 0x00,\n                              \"*l*b*b*w\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8951, "func": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n    size_t len)\n{\n    hwaddr mapped_len = 0;\n    struct iovec *ventry;\n    assert(pkt);\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n    if (!len) {\n        return true;\n     }\n\n    ventry = &pkt->raw[pkt->raw_frags];\n    mapped_len = len;\n\n    ventry->iov_base = pci_dma_map(pkt->pci_dev, pa,\n                                   &mapped_len, DMA_DIRECTION_TO_DEVICE);\n\n    if ((ventry->iov_base != NULL) && (len == mapped_len)) {\n        ventry->iov_len = mapped_len;\n        pkt->raw_frags++;\n        return true;\n    } else {\n        return false;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188589, "func": "   virtual void SetUp() {\n    full_itxfm_ = GET_PARAM(0);\n    partial_itxfm_ = GET_PARAM(1);\n    tx_size_  = GET_PARAM(2);\n    last_nonzero_ = GET_PARAM(3);\n   }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 187679, "func": "image_transform_set_end(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n {\n    UNUSED(this)\n   UNUSED(that)\n   UNUSED(pp)\n   UNUSED(pi)\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8388, "func": "static void mptsas_soft_reset(MPTSASState *s)\n{\n    uint32_t save_mask;\n\n    trace_mptsas_reset(s);\n\n    save_mask = s->intr_mask;\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n    mptsas_update_interrupt(s);\n\n    qbus_reset_all(&s->bus.qbus);\n    s->intr_status = 0;\n    s->intr_mask = save_mask;\n\n    s->reply_free_tail = 0;\n    s->reply_free_head = 0;\n    s->reply_post_tail = 0;\n    s->reply_post_head = 0;\n    s->request_post_tail = 0;\n    s->request_post_head = 0;\n    qemu_bh_cancel(s->request_bh);\n\n    s->state = MPI_IOC_STATE_READY;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8529, "func": "static void ssh1_pkt_addmp(struct Packet *pkt, Bignum b)\n{\n    int len = ssh1_bignum_length(b);\n    unsigned char *data = snewn(len, unsigned char);\n    (void) ssh1_write_bignum(data, b);\n    ssh_pkt_adddata(pkt, data, len);\n    sfree(data);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188138, "func": " WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)\n {\n     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;\n    dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;\n     dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n     WORD32 j;\n     UWORD8 u1_buf_mode;\n struct MMCParams *ps_mmc_params;\n    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;\n\n    ps_slice->u1_mmco_equalto5 = 0;\n {\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_slice->u1_no_output_of_prior_pics_flag =\n                            ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: no_output_of_prior_pics_flag\",\n                            ps_slice->u1_no_output_of_prior_pics_flag);\n            ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(\n                            ps_bitstrm);\n            COPYTHECONTEXT(\"SH: long_term_reference_flag\",\n                            ps_slice->u1_long_term_reference_flag);\n            ps_dpb_cmds->u1_idr_pic = 1;\n            ps_dpb_cmds->u1_no_output_of_prior_pics_flag =\n                            ps_slice->u1_no_output_of_prior_pics_flag;\n            ps_dpb_cmds->u1_long_term_reference_flag =\n                            ps_slice->u1_long_term_reference_flag;\n }\n else\n {\n            u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm); \n            COPYTHECONTEXT(\"SH: adaptive_ref_pic_buffering_flag\", u1_buf_mode);\n            ps_dpb_cmds->u1_buf_mode = u1_buf_mode;\n            j = 0;\n\n if(u1_buf_mode == 1)\n {\n                UWORD32 u4_mmco;\n                UWORD32 u4_diff_pic_num;\n                UWORD32 u4_lt_idx, u4_max_lt_idx;\n\n                u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n while(u4_mmco != END_OF_MMCO)\n {\n if (j >= MAX_REF_BUFS)\n {\n#ifdef __ANDROID__\n                        ALOGE(\"b/25818142\");\n                        android_errorWriteLog(0x534e4554, \"25818142\");\n#endif\n                        ps_dpb_cmds->u1_num_of_commands = 0;\n return -1;\n }\n                    ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];\n                    ps_mmc_params->u4_mmco = u4_mmco;\n switch(u4_mmco)\n {\n case MARK_ST_PICNUM_AS_NONREF:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n break;\n\n case MARK_LT_INDEX_AS_NONREF:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case MARK_ST_PICNUM_AS_LT_INDEX:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case SET_MAX_LT_INDEX:\n {\n                            u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n                            ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;\n break;\n }\n case RESET_REF_PICTURES:\n {\n                            ps_slice->u1_mmco_equalto5 = 1;\n break;\n }\n\n case SET_LT_INDEX:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n default:\n break;\n }\n                    u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                         pu4_bitstrm_buf);\n\n                    j++;\n }\n                ps_dpb_cmds->u1_num_of_commands = j;\n\n }\n }\n        ps_dpb_cmds->u1_dpb_commands_read = 1;\n        ps_dpb_cmds->u1_dpb_commands_read_slc = 1;\n\n }\n    u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;\n return u4_bit_ofst;\n}\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8460, "func": "static bool pvscsi_vmstate_test_pci_device(void *opaque, int version_id)\n{\n    return !pvscsi_vmstate_need_pcie_device(opaque);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9050, "func": "static inline hwaddr vmxnet3_ring_curr_cell_pa(Vmxnet3Ring *ring)\n{\n    return ring->pa + ring->next * ring->cell_size;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8681, "func": "are_urls_equal (const char *u1, const char *u2)\n{\n  const char *p, *q;\n  int pp, qq;\n  char ch1, ch2;\n  assert(u1 && u2);\n\n  p = u1;\n  q = u2;\n\n  while (*p && *q\n         && (pp = getchar_from_escaped_string (p, &ch1))\n         && (qq = getchar_from_escaped_string (q, &ch2))\n         && (c_tolower(ch1) == c_tolower(ch2)))\n    {\n      p += pp;\n      q += qq;\n    }\n\n  return (*p == 0 && *q == 0 ? true : false);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8498, "func": "BOOL CSoundFile::SetResamplingMode(UINT nMode)\n{\n\tDWORD d = gdwSoundSetup & ~(SNDMIX_NORESAMPLING|SNDMIX_HQRESAMPLER|SNDMIX_ULTRAHQSRCMODE);\n\tswitch(nMode)\n\t{\n\tcase SRCMODE_NEAREST:\td |= SNDMIX_NORESAMPLING; break;\n\tcase SRCMODE_LINEAR:\tbreak;\n\tcase SRCMODE_SPLINE:\td |= SNDMIX_HQRESAMPLER; break;\n\tcase SRCMODE_POLYPHASE:\td |= (SNDMIX_HQRESAMPLER|SNDMIX_ULTRAHQSRCMODE); break;\n\tdefault:\n\t\treturn FALSE;\n\t}\n\tgdwSoundSetup = d;\n\treturn TRUE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188629, "func": "EAS_BOOL WT_CheckSampleEnd (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame, EAS_BOOL update)\n{\n    EAS_U32 endPhaseAccum;\n    EAS_U32 endPhaseFrac;\n    EAS_I32 numSamples;\n    EAS_BOOL done = EAS_FALSE;\n\n    endPhaseFrac = pWTVoice->phaseFrac + (pWTIntFrame->frame.phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS);\n    endPhaseAccum = pWTVoice->phaseAccum + GET_PHASE_INT_PART(endPhaseFrac);\n if (endPhaseAccum >= pWTVoice->loopEnd)\n {\n        numSamples = (EAS_I32) (pWTVoice->loopEnd - pWTVoice->phaseAccum);\n\n        numSamples = (EAS_I32) ((numSamples << NUM_PHASE_FRAC_BITS) - pWTVoice->phaseFrac);\n if (pWTIntFrame->frame.phaseIncrement) {\n            pWTIntFrame->numSamples = 1 + (numSamples / pWTIntFrame->frame.phaseIncrement);\n } else {\n            pWTIntFrame->numSamples = numSamples;\n\n         }\n         if (pWTIntFrame->numSamples < 0) {\n             ALOGE(\"b/26366256\");\n             pWTIntFrame->numSamples = 0;\n         }\n \n        done = EAS_TRUE;\n }\n\n if (update)\n {\n        pWTVoice->phaseFrac = endPhaseFrac;\n        pWTVoice->phaseAccum = endPhaseAccum;\n }\n\n return done;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8970, "func": "void net_tx_pkt_uninit(struct NetTxPkt *pkt)\n{\n    if (pkt) {\n        g_free(pkt->vec);\n        g_free(pkt->raw);\n        g_free(pkt);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8389, "func": "static void mptsas_turbo_reply(MPTSASState *s, uint32_t msgctx)\n{\n    if (MPTSAS_FIFO_FULL(s, reply_post)) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);\n        return;\n    }\n\n    MPTSAS_FIFO_PUT(s, reply_post, msgctx);\n\n    s->intr_status |= MPI_HIS_REPLY_MESSAGE_INTERRUPT;\n    mptsas_update_interrupt(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187714, "func": " sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,\n    png_uint_32 x, unsigned int sample_index)\n {\n    png_uint_32 bit_index, result;\n \n   x *= bit_depth;\n   bit_index = x;\n\n if ((colour_type & 1) == 0) \n {\n if (colour_type & 2)\n         bit_index *= 3;\n\n if (colour_type & 4)\n         bit_index += x; \n\n if (colour_type & (2+4))\n         bit_index += sample_index * bit_depth;\n }\n\n   row += bit_index >> 3;\n   result = *row;\n\n if (bit_depth == 8)\n\n       return result;\n \n    else if (bit_depth > 8)\n      return (result << 8) + *++row;\n \n    bit_index &= 7;\n   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);\n }\n", "target": 1, "flaw_line_index": "2,29,30,32"}
{"idx": 188605, "func": "int main(int argc, char **argv) {\n ::testing::InitGoogleTest(&argc, argv);\n\n\n #if ARCH_X86 || ARCH_X86_64\n   const int simd_caps = x86_simd_caps();\n   if (!(simd_caps & HAS_MMX))\n    append_negative_gtest_filter(\":MMX\n    append_negative_gtest_filter(\":SSE\n    append_negative_gtest_filter(\":SSE2\n    append_negative_gtest_filter(\":SSE3\n    append_negative_gtest_filter(\":SSSE3\n    append_negative_gtest_filter(\":SSE4_1\n    append_negative_gtest_filter(\":AVX\n    append_negative_gtest_filter(\":AVX2", "target": 1, "flaw_line_index": "8,9,10,11,12,13,14,15"}
{"idx": 188544, "func": "  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride, tx_type_);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188575, "func": "  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8379, "func": "void mptsas_reply(MPTSASState *s, MPIDefaultReply *reply)\n{\n    if (s->doorbell_state == DOORBELL_WRITE) {\n        s->doorbell_state = DOORBELL_READ;\n        s->doorbell_reply_idx = 0;\n        s->doorbell_reply_size = reply->MsgLength * 2;\n        memcpy(s->doorbell_reply, reply, s->doorbell_reply_size * 2);\n        s->intr_status |= MPI_HIS_DOORBELL_INTERRUPT;\n        mptsas_update_interrupt(s);\n    } else {\n        mptsas_post_reply(s, reply);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188228, "func": "OMX_ERRORTYPE SoftG711::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n if(pcmParams->nPortIndex == 0) {\n                mNumChannels = pcmParams->nChannels;\n }\n\n            mSamplingRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (mIsMLaw) {\n                 if (strncmp((const char *)roleParams->cRole,\n                             \"audio_decoder.g711mlaw\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n } else {\n if (strncmp((const char *)roleParams->cRole,\n \"audio_decoder.g711alaw\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188502, "func": "static void usage(char *progname) {\n   printf(\"Usage:\\n\");\n   printf(\"%s <input_yuv> <width>x<height> <target_width>x<target_height> \",\n         progname);\n   printf(\"<output_yuv> [<frames>]\\n\");\n }\n", "target": 1, "flaw_line_index": "4"}
{"idx": 8840, "func": "static void vrend_destroy_query(struct vrend_query *query)\n{\n   vrend_resource_reference(&query->res, NULL);\n   list_del(&query->waiting_queries);\n   glDeleteQueries(1, &query->id);\n   free(query);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8871, "func": "static void vrend_hw_emit_blend(struct vrend_context *ctx, struct pipe_blend_state *state)\n{\n   if (state->logicop_enable != ctx->sub->hw_blend_state.logicop_enable) {\n      ctx->sub->hw_blend_state.logicop_enable = state->logicop_enable;\n      if (state->logicop_enable) {\n         glEnable(GL_COLOR_LOGIC_OP);\n         glLogicOp(translate_logicop(state->logicop_func));\n      } else\n         glDisable(GL_COLOR_LOGIC_OP);\n   }\n\n   if (state->independent_blend_enable) {\n      int i;\n\n      for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {\n         if (state->rt[i].blend_enable) {\n            glBlendFuncSeparateiARB(i, translate_blend_factor(state->rt[i].rgb_src_factor),\n                                    translate_blend_factor(state->rt[i].rgb_dst_factor),\n                                    translate_blend_factor(state->rt[i].alpha_src_factor),\n                                    translate_blend_factor(state->rt[i].alpha_dst_factor));\n            glBlendEquationSeparateiARB(i, translate_blend_func(state->rt[i].rgb_func),\n                                        translate_blend_func(state->rt[i].alpha_func));\n            glEnableIndexedEXT(GL_BLEND, i);\n         } else\n            glDisableIndexedEXT(GL_BLEND, i);\n\n         if (state->rt[i].colormask != ctx->sub->hw_blend_state.rt[i].colormask) {\n            ctx->sub->hw_blend_state.rt[i].colormask = state->rt[i].colormask;\n            glColorMaskIndexedEXT(i, state->rt[i].colormask & PIPE_MASK_R ? GL_TRUE : GL_FALSE,\n                                  state->rt[i].colormask & PIPE_MASK_G ? GL_TRUE : GL_FALSE,\n                                  state->rt[i].colormask & PIPE_MASK_B ? GL_TRUE : GL_FALSE,\n                                  state->rt[i].colormask & PIPE_MASK_A ? GL_TRUE : GL_FALSE);\n         }\n      }\n   } else {\n      if (state->rt[0].blend_enable) {\n         glBlendFuncSeparate(translate_blend_factor(state->rt[0].rgb_src_factor),\n                             translate_blend_factor(state->rt[0].rgb_dst_factor),\n                             translate_blend_factor(state->rt[0].alpha_src_factor),\n                             translate_blend_factor(state->rt[0].alpha_dst_factor));\n         glBlendEquationSeparate(translate_blend_func(state->rt[0].rgb_func),\n                                 translate_blend_func(state->rt[0].alpha_func));\n         vrend_blend_enable(ctx, true);\n      }\n      else\n         vrend_blend_enable(ctx, false);\n\n      if (state->rt[0].colormask != ctx->sub->hw_blend_state.rt[0].colormask) {\n         int i;\n         for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++)\n            ctx->sub->hw_blend_state.rt[i].colormask = state->rt[i].colormask;\n         glColorMask(state->rt[0].colormask & PIPE_MASK_R ? GL_TRUE : GL_FALSE,\n                     state->rt[0].colormask & PIPE_MASK_G ? GL_TRUE : GL_FALSE,\n                     state->rt[0].colormask & PIPE_MASK_B ? GL_TRUE : GL_FALSE,\n                     state->rt[0].colormask & PIPE_MASK_A ? GL_TRUE : GL_FALSE);\n      }\n   }\n\n   if (vrend_state.have_multisample) {\n      if (state->alpha_to_coverage)\n         glEnable(GL_SAMPLE_ALPHA_TO_COVERAGE);\n      else\n         glDisable(GL_SAMPLE_ALPHA_TO_COVERAGE);\n\n      if (state->alpha_to_one)\n         glEnable(GL_SAMPLE_ALPHA_TO_ONE);\n      else\n         glDisable(GL_SAMPLE_ALPHA_TO_ONE);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187844, "func": "const Cluster* Segment::GetNext(const Cluster* pCurr) {\n  assert(pCurr);\n  assert(pCurr != &m_eos);\n  assert(m_clusters);\n\n long idx = pCurr->m_index;\n\n if (idx >= 0) {\n    assert(m_clusterCount > 0);\n    assert(idx < m_clusterCount);\n    assert(pCurr == m_clusters[idx]);\n\n ++idx;\n\n if (idx >= m_clusterCount)\n return &m_eos; \n\n Cluster* const pNext = m_clusters[idx];\n    assert(pNext);\n    assert(pNext->m_index >= 0);\n    assert(pNext->m_index == idx);\n\n return pNext;\n }\n\n  assert(m_clusterPreloadCount > 0);\n\n long long pos = pCurr->m_element_start;\n\n  assert(m_size >= 0); \n const long long stop = m_start + m_size; \n\n {\n long len;\n\n long long result = GetUIntLength(m_pReader, pos, len);\n    assert(result == 0);\n    assert((pos + len) <= stop); \n\n     if (result != 0)\n       return NULL;\n \n    const long long id = ReadUInt(m_pReader, pos, len);\n    assert(id == 0x0F43B675);  \n    if (id != 0x0F43B675)\n       return NULL;\n \n     pos += len;  \n\n    result = GetUIntLength(m_pReader, pos, len);\n    assert(result == 0); \n    assert((pos + len) <= stop); \n\n const long long size = ReadUInt(m_pReader, pos, len);\n    assert(size > 0); \n\n    pos += len; \n    assert((pos + size) <= stop); \n\n\n    pos += size; \n }\n\n long long off_next = 0;\n\n while (pos < stop) {\n long len;\n\n long long result = GetUIntLength(m_pReader, pos, len);\n    assert(result == 0);\n    assert((pos + len) <= stop); \n if (result != 0)\n return NULL;\n\n \n     const long long idpos = pos;  \n \n    const long long id = ReadUInt(m_pReader, idpos, len);\n    assert(id > 0);  \n \n     pos += len;  \n \n    result = GetUIntLength(m_pReader, pos, len);\n    assert(result == 0); \n    assert((pos + len) <= stop); \n\n const long long size = ReadUInt(m_pReader, pos, len);\n    assert(size >= 0); \n\n    pos += len; \n    assert((pos + size) <= stop); \n\n\n if (size == 0) \n continue;\n\n if (id == 0x0F43B675) { \n const long long off_next_ = idpos - m_start;\n\n long long pos_;\n long len_;\n\n const long status = Cluster::HasBlockEntries(this, off_next_, pos_, len_);\n\n      assert(status >= 0);\n\n if (status > 0) {\n        off_next = off_next_;\n break;\n }\n }\n\n    pos += size; \n }\n\n if (off_next <= 0)\n return 0;\n\n Cluster** const ii = m_clusters + m_clusterCount;\n Cluster** i = ii;\n\n Cluster** const jj = ii + m_clusterPreloadCount;\n Cluster** j = jj;\n\n while (i < j) {\n\n Cluster** const k = i + (j - i) / 2;\n    assert(k < jj);\n\n Cluster* const pNext = *k;\n    assert(pNext);\n    assert(pNext->m_index < 0);\n\n\n    pos = pNext->GetPosition();\n\n if (pos < off_next)\n      i = k + 1;\n else if (pos > off_next)\n      j = k;\n else\n return pNext;\n }\n\n\n   assert(i == j);\n \n   Cluster* const pNext = Cluster::Create(this, -1, off_next);\n  assert(pNext);\n \n   const ptrdiff_t idx_next = i - m_clusters;  \n \n  PreloadCluster(pNext, idx_next);\n   assert(m_clusters);\n   assert(idx_next < m_clusterSize);\n   assert(m_clusters[idx_next] == pNext);\n\n return pNext;\n}\n", "target": 1, "flaw_line_index": "43,44,45,81,82"}
{"idx": 8439, "func": "pvscsi_raise_message_interrupt(PVSCSIState *s)\n{\n    s->reg_interrupt_status |= PVSCSI_INTR_MSG_0;\n\n    smp_wmb();\n\n    pvscsi_update_irq_status(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8724, "func": "static int cert_self_signed(X509 *x)\n{\n    X509_check_purpose(x, -1, 0);\n    if (x->ex_flags & EXFLAG_SS)\n        return 1;\n    else\n        return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8364, "func": "static void mptsas_interrupt_status_write(MPTSASState *s)\n{\n    switch (s->doorbell_state) {\n    case DOORBELL_NONE:\n    case DOORBELL_WRITE:\n        s->intr_status &= ~MPI_HIS_DOORBELL_INTERRUPT;\n        break;\n\n    case DOORBELL_READ:\n        assert(s->intr_status & MPI_HIS_DOORBELL_INTERRUPT);\n        if (s->doorbell_reply_idx == s->doorbell_reply_size) {\n            s->doorbell_state = DOORBELL_NONE;\n        }\n        break;\n\n    default:\n        abort();\n    }\n    mptsas_update_interrupt(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9074, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n{\n    int i;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    VMXNET3_READ_DRV_SHARED(d, s->drv_shmem,\n                            devRead.rxFilterConf.vfTable,\n                            s->vlan_table,\n                            sizeof(s->vlan_table));\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n    }\n\n    VMW_CFPRN(\"Configured VLANs:\");\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187672, "func": "image_transform_png_set_strip_16_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_strip_16(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187451, "func": "static int skt_write(int fd, const void *p, size_t len)\n{\n int sent;\n struct pollfd pfd;\n\n    FNLOG();\n\n    pfd.fd = fd;\n    pfd.events = POLLOUT;\n\n\n \n    if (poll(&pfd, 1, 500) == 0)\n         return 0;\n \n     ts_log(\"skt_write\", len, NULL);\n \n    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)\n     {\n         ERROR(\"write failed with errno=%d\\n\", errno);\n         return -1;\n }\n\n return sent;\n}\n", "target": 1, "flaw_line_index": "13,18"}
{"idx": 8589, "func": "static void ssh_send_verstring(Ssh ssh, const char *protoname, char *svers)\n{\n    char *verstring;\n\n    if (ssh->version == 2) {\n\tverstring = dupprintf(\"%s2.0-%s\\015\\012\", protoname, sshver);\n    } else {\n        assert(!strcmp(protoname, \"SSH-\")); \n\tverstring = dupprintf(\"SSH-%s-%s\\012\",\n\t\t\t      (ssh_versioncmp(svers, \"1.5\") <= 0 ?\n\t\t\t       svers : \"1.5\"),\n\t\t\t      sshver);\n    }\n\n    ssh_fix_verstring(verstring + strlen(protoname));\n#ifdef FUZZING\n    verstring[0] = 'I';\n#endif\n\n    if (ssh->version == 2) {\n\tsize_t len;\n\tlen = strcspn(verstring, \"\\015\\012\");\n\tssh->v_c = snewn(len + 1, char);\n\tmemcpy(ssh->v_c, verstring, len);\n\tssh->v_c[len] = 0;\n    }\n\n    logeventf(ssh, \"We claim version: %.*s\",\n\t      strcspn(verstring, \"\\015\\012\"), verstring);\n    s_write(ssh, verstring, strlen(verstring));\n    sfree(verstring);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188143, "func": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n const size_t size = p->readInt32();\n const void* regionData = p->readInplace(size);\n if (regionData == NULL) {\n\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n    region->readFromMemory(regionData, size);\n \n     return reinterpret_cast<jlong>(region);\n }\n", "target": 1, "flaw_line_index": "16"}
{"idx": 8318, "func": "XFixesTranslateRegion (Display *dpy, XserverRegion region, int dx, int dy)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesTranslateRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesTranslateRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesTranslateRegion;\n    req->region = region;\n    req->dx = dx;\n    req->dy = dy;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9153, "func": "static void vrend_stencil_test_enable(struct vrend_context *ctx, bool stencil_test_enable)\n{\n   if (ctx->sub->stencil_test_enabled != stencil_test_enable) {\n      ctx->sub->stencil_test_enabled = stencil_test_enable;\n      if (stencil_test_enable)\n         glEnable(GL_STENCIL_TEST);\n      else\n         glDisable(GL_STENCIL_TEST);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8669, "func": "static int mptsas_device_addr_get(MPTSASState *s, int address)\n{\n    uint32_t handle, i;\n    uint32_t form = address >> MPI_SAS_PHY_PGAD_FORM_SHIFT;\n    if (form == MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE) {\n        handle = address & MPI_SAS_DEVICE_PGAD_GNH_HANDLE_MASK;\n        do {\n            if (handle == 65535) {\n                handle = MPTSAS_NUM_PORTS + 1;\n            } else {\n                ++handle;\n            }\n            i = handle - 1 - MPTSAS_NUM_PORTS;\n        } while (i < MPTSAS_NUM_PORTS && !scsi_device_find(&s->bus, 0, i, 0));\n\n    } else if (form == MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID) {\n        if (address & MPI_SAS_DEVICE_PGAD_BT_BUS_MASK) {\n            return -EINVAL;\n        }\n        i = address & MPI_SAS_DEVICE_PGAD_BT_TID_MASK;\n\n    } else if (form == MPI_SAS_DEVICE_PGAD_FORM_HANDLE) {\n        handle = address & MPI_SAS_DEVICE_PGAD_H_HANDLE_MASK;\n        i = handle - 1 - MPTSAS_NUM_PORTS;\n\n    } else {\n        return -EINVAL;\n    }\n\n    if (i >= MPTSAS_NUM_PORTS) {\n        return -EINVAL;\n    }\n\n    return i;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8784, "func": "static const char *valid_domain_label(const char *label)\n{\n\tunsigned char ch;\n\n\tif (label[0] == '-')\n\t\treturn NULL;\n\tfor (;;) {\n\t\tch = *label;\n\t\tif ((ch|0x20) < 'a' || (ch|0x20) > 'z') {\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\tif (ch == '\\0' || ch == '.')\n\t\t\t\t\treturn label;\n\t\t\t\tif (ch != '-' && ch != '_')\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tlabel++;\n\t}\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8797, "func": "static GLuint convert_wrap(int wrap)\n{\n   switch(wrap){\n   case PIPE_TEX_WRAP_REPEAT: return GL_REPEAT;\n   case PIPE_TEX_WRAP_CLAMP: if (vrend_state.use_core_profile == false) return GL_CLAMP; else return GL_CLAMP_TO_EDGE;\n\n   case PIPE_TEX_WRAP_CLAMP_TO_EDGE: return GL_CLAMP_TO_EDGE;\n   case PIPE_TEX_WRAP_CLAMP_TO_BORDER: return GL_CLAMP_TO_BORDER;\n\n   case PIPE_TEX_WRAP_MIRROR_REPEAT: return GL_MIRRORED_REPEAT;\n   case PIPE_TEX_WRAP_MIRROR_CLAMP: return GL_MIRROR_CLAMP_EXT;\n   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE: return GL_MIRROR_CLAMP_TO_EDGE_EXT;\n   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER: return GL_MIRROR_CLAMP_TO_BORDER_EXT;\n   default:\n      assert(0);\n      return -1;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188527, "func": "   virtual void SetUp() {\n     UUT_ = GET_PARAM(2);\n     for (int i = 0; i < kOutputBufferSize; ++i) {\n       if (IsIndexInBorder(i))\n        output_[i] = 255;\n else\n        output_[i] = 0;\n\n     }\n \n     ::libvpx_test::ACMRandom prng;\n    for (int i = 0; i < kInputBufferSize; ++i)\n      input_[i] = prng.Rand8Extremes();\n   }\n", "target": 1, "flaw_line_index": "12,13"}
{"idx": 187455, "func": " static int uhid_write(int fd, const struct uhid_event *ev)\n {\n    ssize_t ret = write(fd, ev, sizeof(*ev));\n     if (ret < 0){\n         int rtn = -errno;\n         APPL_TRACE_ERROR(\"%s: Cannot write to uhid:%s\",\n                         __FUNCTION__, strerror(errno));\n return rtn;\n } else if (ret != (ssize_t)sizeof(*ev)) {\n        APPL_TRACE_ERROR(\"%s: Wrong size written to uhid: %zd != %zu\",\n                         __FUNCTION__, ret, sizeof(*ev));\n return -EFAULT;\n }\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 8475, "func": "void CSoundFile::FrequencyToTranspose(MODINSTRUMENT *psmp)\n{\n\tint f2t = FrequencyToTranspose(psmp->nC4Speed);\n\tint transp = f2t >> 7;\n\tint ftune = f2t & 0x7F;\n\tif (ftune > 80)\n\t{\n\t\ttransp++;\n\t\tftune -= 128;\n\t}\n\tif (transp > 127) transp = 127;\n\tif (transp < -127) transp = -127;\n\tpsmp->RelativeTone = transp;\n\tpsmp->nFineTune = ftune;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187404, "func": "static vpx_codec_err_t vp8_decode(vpx_codec_alg_priv_t *ctx,\n const uint8_t *data,\n unsigned int            data_sz,\n void *user_priv,\n long                    deadline)\n{\n vpx_codec_err_t res = VPX_CODEC_OK;\n unsigned int resolution_change = 0;\n unsigned int w, h;\n\n if (!ctx->fragments.enabled && (data == NULL && data_sz == 0))\n {\n return 0;\n }\n\n if(update_fragments(ctx, data, data_sz, &res) <= 0)\n return res;\n\n    w = ctx->si.w;\n    h = ctx->si.h;\n\n    res = vp8_peek_si_internal(ctx->fragments.ptrs[0], ctx->fragments.sizes[0],\n &ctx->si, ctx->decrypt_cb, ctx->decrypt_state);\n\n if((res == VPX_CODEC_UNSUP_BITSTREAM) && !ctx->si.is_kf)\n {\n        res = VPX_CODEC_OK;\n }\n\n if(!ctx->decoder_init && !ctx->si.is_kf)\n        res = VPX_CODEC_UNSUP_BITSTREAM;\n\n if ((ctx->si.h != h) || (ctx->si.w != w))\n        resolution_change = 1;\n\n if (!res && !ctx->decoder_init)\n {\n      VP8D_CONFIG oxcf;\n\n      oxcf.Width = ctx->si.w;\n      oxcf.Height = ctx->si.h;\n      oxcf.Version = 9;\n      oxcf.postprocess = 0;\n      oxcf.max_threads = ctx->cfg.threads;\n      oxcf.error_concealment =\n (ctx->base.init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT);\n\n if (!ctx->postproc_cfg_set\n && (ctx->base.init_flags & VPX_CODEC_USE_POSTPROC)) {\n         ctx->postproc_cfg.post_proc_flag =\n             VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE;\n         ctx->postproc_cfg.deblocking_level = 4;\n         ctx->postproc_cfg.noise_level = 0;\n }\n\n       res = vp8_create_decoder_instances(&ctx->yv12_frame_buffers, &oxcf);\n       ctx->decoder_init = 1;\n }\n\n if (ctx->decoder_init) {\n      ctx->yv12_frame_buffers.pbi[0]->decrypt_cb = ctx->decrypt_cb;\n      ctx->yv12_frame_buffers.pbi[0]->decrypt_state = ctx->decrypt_state;\n }\n\n if (!res)\n {\n        VP8D_COMP *pbi = ctx->yv12_frame_buffers.pbi[0];\n if (resolution_change)\n {\n            VP8_COMMON *const pc = & pbi->common;\n            MACROBLOCKD *const xd  = & pbi->mb;\n#if CONFIG_MULTITHREAD\n int i;\n#endif\n            pc->Width = ctx->si.w;\n            pc->Height = ctx->si.h;\n {\n int prev_mb_rows = pc->mb_rows;\n\n\n                 if (setjmp(pbi->common.error.jmp))\n                 {\n                     pbi->common.error.setjmp = 0;\n                     vp8_clear_system_state();\n                     return -1;\n }\n\n                pbi->common.error.setjmp = 1;\n\n if (pc->Width <= 0)\n {\n                    pc->Width = w;\n                    vpx_internal_error(&pc->error, VPX_CODEC_CORRUPT_FRAME,\n \"Invalid frame width\");\n }\n\n if (pc->Height <= 0)\n {\n                    pc->Height = h;\n                    vpx_internal_error(&pc->error, VPX_CODEC_CORRUPT_FRAME,\n \"Invalid frame height\");\n }\n\n if (vp8_alloc_frame_buffers(pc, pc->Width, pc->Height))\n                    vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,\n \"Failed to allocate frame buffers\");\n\n                xd->pre = pc->yv12_fb[pc->lst_fb_idx];\n                xd->dst = pc->yv12_fb[pc->new_fb_idx];\n\n#if CONFIG_MULTITHREAD\n for (i = 0; i < pbi->allocated_decoding_thread_count; i++)\n {\n                    pbi->mb_row_di[i].mbd.dst = pc->yv12_fb[pc->new_fb_idx];\n                    vp8_build_block_doffsets(&pbi->mb_row_di[i].mbd);\n }\n#endif\n                vp8_build_block_doffsets(&pbi->mb);\n\n#if CONFIG_ERROR_CONCEALMENT\n\n if (pbi->ec_enabled)\n {\n                    pc->prev_mip = vpx_calloc(\n (pc->mb_cols + 1) * (pc->mb_rows + 1),\n sizeof(MODE_INFO));\n\n if (!pc->prev_mip)\n {\n                        vp8_de_alloc_frame_buffers(pc);\n                        vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,\n \"Failed to allocate\"\n \"last frame MODE_INFO array\");\n }\n\n                    pc->prev_mi = pc->prev_mip + pc->mode_info_stride + 1;\n\n if (vp8_alloc_overlap_lists(pbi))\n                        vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,\n \"Failed to allocate overlap lists \"\n \"for error concealment\");\n }\n\n#endif\n\n#if CONFIG_MULTITHREAD\n if (pbi->b_multithreaded_rd)\n                    vp8mt_alloc_temp_buffers(pbi, pc->Width, prev_mb_rows);\n#else\n (void)prev_mb_rows;\n#endif\n }\n\n            pbi->common.error.setjmp = 0;\n\n            pbi->common.fb_idx_ref_cnt[0] = 0;\n }\n\n        pbi->fragments = ctx->fragments;\n\n        ctx->user_priv = user_priv;\n if (vp8dx_receive_compressed_data(pbi, data_sz, data, deadline))\n {\n            res = update_error_state(ctx, &pbi->common.error);\n }\n\n        ctx->fragments.count = 0;\n }\n\n return res;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8643, "func": "size_t mptsas_config_ioc_2(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(2, MPI_CONFIG_PAGETYPE_IOC, 0x04,\n                              \"*l*b*b*b*b\");\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187499, "func": "static uint16_t transmit_data_on(int fd, uint8_t *data, uint16_t length) {\n  assert(data != NULL);\n  assert(length > 0);\n\n \n   uint16_t transmitted_length = 0;\n   while (length > 0) {\n    ssize_t ret = write(fd, data + transmitted_length, length);\n     switch (ret) {\n       case -1:\n         LOG_ERROR(\"In %s, error writing to the serial port with fd %d: %s\", __func__, fd, strerror(errno));\n return transmitted_length;\n case 0:\n return transmitted_length;\n default:\n        transmitted_length += ret;\n        length -= ret;\n break;\n }\n }\n\n return transmitted_length;\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 188230, "func": "OMX_ERRORTYPE SoftGSM::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels != 1) {\n return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nSamplingRate != 8000) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.gsm\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187954, "func": "status_t BnGraphicBufferProducer::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n case REQUEST_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferIdx   = data.readInt32();\n            sp<GraphicBuffer> buffer;\n int result = requestBuffer(bufferIdx, &buffer);\n            reply->writeInt32(buffer != 0);\n if (buffer != 0) {\n                reply->write(*buffer);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case SET_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferCount = data.readInt32();\n int result = setBufferCount(bufferCount);\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case DEQUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool async      = data.readInt32();\n uint32_t w      = data.readInt32();\n uint32_t h      = data.readInt32();\n uint32_t format = data.readInt32();\n uint32_t usage  = data.readInt32();\n int buf = 0;\n            sp<Fence> fence;\n int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);\n            reply->writeInt32(buf);\n            reply->writeInt32(fence != NULL);\n if (fence != NULL) {\n                reply->write(*fence);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n } break;\n case QUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n QueueBufferInput input(data);\n\n             QueueBufferOutput* const output =\n                     reinterpret_cast<QueueBufferOutput *>(\n                             reply->writeInplace(sizeof(QueueBufferOutput)));\n             status_t result = queueBuffer(buf, input, output);\n             reply->writeInt32(result);\n             return NO_ERROR;\n } break;\n case CANCEL_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n            sp<Fence> fence = new Fence();\n            data.read(*fence.get());\n            cancelBuffer(buf, fence);\n return NO_ERROR;\n } break;\n case QUERY: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int value = 0;\n int what = data.readInt32();\n int res = query(what, &value);\n            reply->writeInt32(value);\n            reply->writeInt32(res);\n return NO_ERROR;\n } break;\n case CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<IBinder> token = data.readStrongBinder();\n int api = data.readInt32();\n bool producerControlledByApp = data.readInt32();\n QueueBufferOutput* const output =\n reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n status_t res = connect(token, api, producerControlledByApp, output);\n            reply->writeInt32(res);\n return NO_ERROR;\n } break;\n case DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int api = data.readInt32();\n status_t res = disconnect(api);\n            reply->writeInt32(res);\n return NO_ERROR;\n } break;\n }\n return BBinder::onTransact(code, data, reply, flags);\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188549, "func": " virtual void SetUp() {\n\n     fwd_txfm_ = GET_PARAM(0);\n     inv_txfm_ = GET_PARAM(1);\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 16;\n     fwd_txfm_ref = fdct16x16_ref;\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187627, "func": "check_interlace_type(int PNG_CONST interlace_type)\n {\n    if (interlace_type != PNG_INTERLACE_NONE)\n    {\n      fprintf(stderr, \"pngvalid: no interlace support\\n\");\n\n       exit(99);\n    }\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188253, "func": "void SoftAMR::onQueueFilled(OMX_U32 \n) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n int32_t numBytesRead;\n\n if (mMode == MODE_NARROW) {\n if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n\n                 return;\n             }\n \n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; \n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n } else {\n if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n\n             }\n \n             size_t frameSize = getFrameSize(mode);\n            CHECK_GE(inHeader->nFilledLen, frameSize);\n \n             int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n \n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n", "target": 1, "flaw_line_index": "101"}
{"idx": 187359, "func": "status_t SampleTable::setCompositionTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n size_t numEntries = U32_AT(&header[4]);\n\n if (data_size != (numEntries + 1) * 8) {\n return ERROR_MALFORMED;\n\n     }\n \n     mNumCompositionTimeDeltaEntries = numEntries;\n    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n\n    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n\n if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n < (ssize_t)numEntries * 8) {\n delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "29"}
{"idx": 188628, "func": "void WT_VoiceGain (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n    EAS_PCM *pInputBuffer;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I32 numSamples;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    EAS_I32 gainLeft, gainRight;\n#endif\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n    pInputBuffer = pWTIntFrame->pAudioBuffer;\n\n    gainIncrement = (pWTIntFrame->frame.gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    gainLeft = pWTVoice->gainLeft;\n    gainRight = pWTVoice->gainRight;\n#endif\n\n while (numSamples--) {\n\n        tmp0 = *pInputBuffer++;\n        gain += gainIncrement;\n        tmp2 = gain >> 16;\n\n        tmp2 *= tmp0;\n\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n        tmp2 = tmp2 >> 14;\n\n        tmp1 = *pMixBuffer;\n\n        tmp0 = tmp2 * gainLeft;\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n        tmp1 = *pMixBuffer;\n\n        tmp0 = tmp2 * gainRight;\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n#else\n\n        tmp1 = *pMixBuffer;\n        tmp2 = tmp2 >> (NUM_MIXER_GUARD_BITS - 1);\n        tmp1 += tmp2;\n *pMixBuffer++ = tmp1;\n#endif\n\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8452, "func": "pvscsi_ring_msg_has_room(PVSCSIRingInfo *mgr)\n{\n    uint32_t prodIdx = RS_GET_FIELD(mgr, msgProdIdx);\n    uint32_t consIdx = RS_GET_FIELD(mgr, msgConsIdx);\n\n    return (prodIdx - consIdx) < (mgr->msg_len_mask + 1);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188100, "func": "tBTA_AV_EVT bta_av_proc_meta_cmd(tAVRC_RESPONSE* p_rc_rsp,\n                                 tBTA_AV_RC_MSG* p_msg, uint8_t* p_ctype) {\n  tBTA_AV_EVT evt = BTA_AV_META_MSG_EVT;\n uint8_t u8, pdu, *p;\n uint16_t u16;\n  tAVRC_MSG_VENDOR* p_vendor = &p_msg->msg.vendor;\n\n  pdu = *(p_vendor->p_vendor_data);\n  p_rc_rsp->pdu = pdu;\n *p_ctype = AVRC_RSP_REJ;\n\n if ((AVRC_MIN_META_CMD_LEN + p_vendor->vendor_len) > AVRC_META_CMD_BUF_SIZE) {\n    p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM;\n    APPL_TRACE_ERROR(\"%s: Invalid meta-command length: %d\", __func__,\n                     p_vendor->vendor_len);\n return 0;\n }\n\n if (p_vendor->hdr.subunit_type != AVRC_SUB_PANEL) {\n    APPL_TRACE_DEBUG(\"%s: SUBUNIT must be PANEL\", __func__);\n    evt = 0;\n    p_vendor->hdr.ctype = AVRC_RSP_NOT_IMPL;\n    p_vendor->vendor_len = 0;\n    p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM;\n } else if (!AVRC_IsValidAvcType(pdu, p_vendor->hdr.ctype)) {\n    APPL_TRACE_DEBUG(\"%s: Invalid pdu/ctype: 0x%x, %d\", __func__, pdu,\n                     p_vendor->hdr.ctype);\n    evt = 0;\n    p_rc_rsp->rsp.status = AVRC_STS_BAD_CMD;\n } else {\n switch (pdu) {\n\n       case AVRC_PDU_GET_CAPABILITIES:\n         evt = 0;\n         u8 = *(p_vendor->p_vendor_data + 4);\n         p = p_vendor->p_vendor_data + 2;\n         p_rc_rsp->get_caps.capability_id = u8;\n         BE_STREAM_TO_UINT16(u16, p);\n        if ((u16 != 1) || (p_vendor->vendor_len != 5)) {\n           p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;\n         } else {\n           p_rc_rsp->get_caps.status = AVRC_STS_NO_ERROR;\n if (u8 == AVRC_CAP_COMPANY_ID) {\n *p_ctype = AVRC_RSP_IMPL_STBL;\n            p_rc_rsp->get_caps.count = p_bta_av_cfg->num_co_ids;\n            memcpy(p_rc_rsp->get_caps.param.company_id,\n                   p_bta_av_cfg->p_meta_co_ids,\n (p_bta_av_cfg->num_co_ids << 2));\n } else if (u8 == AVRC_CAP_EVENTS_SUPPORTED) {\n *p_ctype = AVRC_RSP_IMPL_STBL;\n            p_rc_rsp->get_caps.count = p_bta_av_cfg->num_evt_ids;\n            memcpy(p_rc_rsp->get_caps.param.event_id,\n                   p_bta_av_cfg->p_meta_evt_ids, p_bta_av_cfg->num_evt_ids);\n } else {\n            APPL_TRACE_DEBUG(\"%s: Invalid capability ID: 0x%x\", __func__, u8);\n            p_rc_rsp->get_caps.status = AVRC_STS_BAD_PARAM;\n }\n }\n break;\n\n case AVRC_PDU_REGISTER_NOTIFICATION:\n        p_rc_rsp->rsp.status = bta_av_chk_notif_evt_id(p_vendor);\n if (p_rc_rsp->rsp.status != BTA_AV_STS_NO_RSP) evt = 0;\n break;\n }\n }\n\n return evt;\n}\n", "target": 1, "flaw_line_index": "39"}
{"idx": 187495, "func": "static void update_logging() {\n bool should_log = module_started &&\n (logging_enabled_via_api || stack_config->get_btsnoop_turned_on());\n\n if (should_log == is_logging)\n return;\n\n  is_logging = should_log;\n if (should_log) {\n    btsnoop_net_open();\n\n const char *log_path = stack_config->get_btsnoop_log_path();\n\n if (stack_config->get_btsnoop_should_save_last()) {\n char last_log_path[PATH_MAX];\n      snprintf(last_log_path, PATH_MAX, \"%s.%llu\", log_path, btsnoop_timestamp());\n if (!rename(log_path, last_log_path) && errno != ENOENT)\n\n         LOG_ERROR(\"%s unable to rename '%s' to '%s': %s\", __func__, log_path, last_log_path, strerror(errno));\n     }\n \n    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n     if (logfile_fd == INVALID_FD) {\n       LOG_ERROR(\"%s unable to open '%s': %s\", __func__, log_path, strerror(errno));\n       is_logging = false;\n       return;\n     }\n \n    write(logfile_fd, \"btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\", 16);\n   } else {\n     if (logfile_fd != INVALID_FD)\n       close(logfile_fd);\n\n    logfile_fd = INVALID_FD;\n    btsnoop_net_close();\n }\n}\n", "target": 1, "flaw_line_index": "23,30"}
{"idx": 8446, "func": "pvscsi_ring_cleanup(PVSCSIRingInfo *mgr)\n{\n    mgr->rs_pa = 0;\n    mgr->txr_len_mask = 0;\n    mgr->rxr_len_mask = 0;\n    mgr->msg_len_mask = 0;\n    mgr->consumed_ptr = 0;\n    mgr->filled_cmp_ptr = 0;\n    mgr->filled_msg_ptr = 0;\n    memset(mgr->req_ring_pages_pa, 0, sizeof(mgr->req_ring_pages_pa));\n    memset(mgr->cmp_ring_pages_pa, 0, sizeof(mgr->cmp_ring_pages_pa));\n    memset(mgr->msg_ring_pages_pa, 0, sizeof(mgr->msg_ring_pages_pa));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8628, "func": "static inline void eth_pulse_irq(struct xlx_ethlite *s)\n{\n    if (s->regs[R_TX_GIE0] & GIE_GIE) {\n        qemu_irq_pulse(s->irq);\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188165, "func": "status_t OMXNodeInstance::useBuffer(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n\n     }\n \n     Mutex::Autolock autoLock(mLock);\n    if (allottedSize > params->size()) {\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n     OMX_ERRORTYPE err = OMX_UseBuffer(\n             mHandle, &header, portIndex, buffer_meta,\n            allottedSize, static_cast<OMX_U8 *>(params->pointer()));\n \n     if (err != OMX_ErrorNone) {\n         CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(\n                portIndex, (size_t)allottedSize, params->pointer()));\n \n         delete buffer_meta;\n         buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u(%zu)@%p\", allottedSize, params->size(), params->pointer()));\n return OK;\n}\n", "target": 1, "flaw_line_index": "11,15,21,25"}
{"idx": 187674, "func": "image_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n       that->colour_type = PNG_COLOR_TYPE_GRAY;\n else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)\n      that->colour_type = PNG_COLOR_TYPE_RGB;\n\n   that->have_tRNS = 0;\n   that->alphaf = 1;\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "3"}
{"idx": 187935, "func": "WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 u4_isdc,\n                                                UWORD32 u4_total_coeff_trail_one, \n dec_bit_stream_t *ps_bitstrm )\n{\n    UWORD32 u4_total_zeroes;\n    WORD32 i;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n\n     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;\n     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;\n     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;\n    WORD16 i2_level_arr[16];\n \n     tu_sblk4x4_coeff_data_t *ps_tu_4x4;\n     WORD16 *pi2_coeff_data;\n dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;\n\n    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;\n    ps_tu_4x4->u2_sig_coeff_map = 0;\n    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];\n\n    i = u4_total_coeff - 1;\n if(u4_trailing_ones)\n {\n        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;\n        WORD16 (*ppi2_trlone_lkup)[3] =\n (WORD16 (*)[3])gai2_ih264d_trailing_one_level;\n        WORD16 *pi2_trlone_lkup;\n\n        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);\n\n        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];\n\n while(u4_cnt--)\n            i2_level_arr[i--] = *pi2_trlone_lkup++;\n }\n\n if(i >= 0)\n {\n        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;\n        UWORD16 u2_lev_code, u2_abs_value;\n        UWORD32 u4_lev_prefix;\n\n if(u4_trailing_ones < 3)\n {\n            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                                  pu4_bitstrm_buf);\n\n            u4_lev_suffix_size =\n (15 <= u4_lev_prefix) ? (u4_lev_prefix - 3) : 1;\n\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code = 2 + (MIN(u4_lev_prefix,15) << 1) + u4_lev_suffix;\n\n if(16 <= u4_lev_prefix)\n {\n                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n }\n else\n {\n            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                                  pu4_bitstrm_buf);\n\n            u2_lev_code = MIN(15, u4_lev_prefix);\n\n            u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);\n\n if(14 == u4_lev_prefix)\n                u4_lev_suffix_size = 4;\n else if(15 <= u4_lev_prefix)\n {\n                u2_lev_code += 15;\n                u4_lev_suffix_size = (u4_lev_prefix - 3);\n }\n else\n                u4_lev_suffix_size = 0;\n\n if(16 <= u4_lev_prefix)\n {\n                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n if(u4_lev_suffix_size)\n {\n                GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                        u4_lev_suffix_size);\n                u2_lev_code += u4_lev_suffix;\n }\n }\n\n        u2_abs_value = (u2_lev_code + 2) >> 1;\n        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;\n\n while(i >= 0)\n {\n\n            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                                  pu4_bitstrm_buf);\n\n            u4_lev_suffix_size =\n (15 <= u4_lev_prefix) ?\n (u4_lev_prefix - 3) : u4_suffix_len;\n\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)\n + u4_lev_suffix;\n\n if(16 <= u4_lev_prefix)\n {\n                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n            u2_abs_value = (u2_lev_code + 2) >> 1;\n\n            i2_level_arr[i--] =\n (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n            u4_suffix_len +=\n (u4_suffix_len < 6) ?\n (u2_abs_value\n > (3\n << (u4_suffix_len\n - 1))) :\n 0;\n }\n\n }\n\n if(u4_total_coeff < (16 - u4_isdc))\n {\n        UWORD32 u4_index;\n const UWORD8 (*ppu1_total_zero_lkup)[16] =\n (const UWORD8 (*)[16])gau1_ih264d_table_total_zero_11to15;\n\n        NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 4);\n        u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 11][u4_index];\n\n        FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));\n        u4_total_zeroes &= 0xf;\n }\n else\n        u4_total_zeroes = 0;\n\n {\n const UWORD8 *pu1_table_runbefore;\n        UWORD32 u4_run;\n        WORD32 k;\n        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;\n        WORD32 u4_zeroes_left = u4_total_zeroes;\n        k = u4_total_coeff - 1;\n\n        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;\n while((u4_zeroes_left > 0) && k)\n {\n            UWORD32 u4_code;\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];\n            u4_run = u4_code >> 2;\n\n            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n\n if(u4_zeroes_left < 0)\n return -1;\n while(k >= 0)\n {\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_scan_pos--;\n }\n }\n\n {\n        WORD32 offset;\n        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;\n        offset = ALIGN4(offset);\n        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);\n }\n\n    ps_bitstrm->u4_ofst = u4_bitstream_offset;\n return 0;\n}\n", "target": 1, "flaw_line_index": "12"}
{"idx": 188568, "func": " virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n\n     video_->Init();\n     video_->Begin();\n \n    vpx_codec_dec_cfg_t cfg = {0};\n     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n     ASSERT_TRUE(decoder_ != NULL);\n   }\n", "target": 1, "flaw_line_index": "8"}
{"idx": 188222, "func": "OMX_ERRORTYPE SoftAVC::internalGetParameter(OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *)params;\n \n             if (bitRate->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            bitRate->eControlRate = OMX_Video_ControlRateVariable;\n            bitRate->nTargetBitrate = mBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoAvc:\n\n         {\n             OMX_VIDEO_PARAM_AVCTYPE *avcParams = (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            OMX_VIDEO_AVCLEVELTYPE omxLevel = OMX_VIDEO_AVCLevel41;\n if (OMX_ErrorNone\n != ConvertAvcSpecLevelToOmxAvcLevel(mAVCEncLevel, &omxLevel)) {\n return OMX_ErrorUndefined;\n }\n\n            avcParams->eProfile = OMX_VIDEO_AVCProfileBaseline;\n            avcParams->eLevel = omxLevel;\n            avcParams->nRefFrames = 1;\n            avcParams->bUseHadamard = OMX_TRUE;\n            avcParams->nAllowedPictureTypes = (OMX_VIDEO_PictureTypeI\n | OMX_VIDEO_PictureTypeP | OMX_VIDEO_PictureTypeB);\n            avcParams->nRefIdx10ActiveMinus1 = 0;\n            avcParams->nRefIdx11ActiveMinus1 = 0;\n            avcParams->bWeightedPPrediction = OMX_FALSE;\n            avcParams->bconstIpred = OMX_FALSE;\n            avcParams->bDirect8x8Inference = OMX_FALSE;\n            avcParams->bDirectSpatialTemporal = OMX_FALSE;\n            avcParams->nCabacInitIdc = 0;\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9145, "func": "static boolean str_match_nocase_whole( const char **pcur, const char *str )\n{\n   const char *cur = *pcur;\n\n   if (str_match_no_case(&cur, str) &&\n       !is_digit_alpha_underscore(cur)) {\n      *pcur = cur;\n      return TRUE;\n   }\n   return FALSE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8602, "func": "static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)\n{\n    printf(\"%s: what are we supposed to return?\\n\", __func__);\n    return 0xcafe;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8785, "func": "static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_optflag *optflag, const char *opt_name)\n{\n\tunsigned upper_length;\n\tint len, type, optlen;\n\tchar *dest, *ret;\n\n\tlen = option[-OPT_DATA + OPT_LEN];\n\n\ttype = optflag->flags & OPTION_TYPE_MASK;\n\toptlen = dhcp_option_lengths[type];\n\tupper_length = len_of_option_as_string[type]\n\t\t* ((unsigned)(len + optlen) / (unsigned)optlen);\n\n\tdest = ret = xmalloc(upper_length + strlen(opt_name) + 2);\n\tdest += sprintf(ret, \"%s=\", opt_name);\n\n\twhile (len >= optlen) {\n\t\tswitch (type) {\n\t\tcase OPTION_IP:\n\t\tcase OPTION_IP_PAIR:\n\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\tif (type == OPTION_IP)\n\t\t\t\tbreak;\n\t\t\tdest += sprint_nip(dest, \"/\", option + 4);\n\t\t\tbreak;\n\t\tcase OPTION_U8:\n\t\t\tdest += sprintf(dest, \"%u\", *option);\n\t\t\tbreak;\n\t\tcase OPTION_U16: {\n\t\t\tuint16_t val_u16;\n\t\t\tmove_from_unaligned16(val_u16, option);\n\t\t\tdest += sprintf(dest, \"%u\", ntohs(val_u16));\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32:\n\t\tcase OPTION_U32: {\n\t\t\tuint32_t val_u32;\n\t\t\tmove_from_unaligned32(val_u32, option);\n\t\t\tdest += sprintf(dest, type == OPTION_U32 ? \"%lu\" : \"%ld\", (unsigned long) ntohl(val_u32));\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_STRING_HOST:\n\t\t\tmemcpy(dest, option, len);\n\t\t\tdest[len] = '\\0';\n\t\t\tif (type == OPTION_STRING_HOST && !good_hostname(dest))\n\t\t\t\tsafe_strncpy(dest, \"bad\", len);\n\t\t\treturn ret;\n\t\tcase OPTION_STATIC_ROUTES: {\n\t\t\tconst char *pfx = \"\";\n\n\t\t\twhile (len >= 1 + 4) { \n\t\t\t\tuint32_t nip;\n\t\t\t\tuint8_t *p;\n\t\t\t\tunsigned mask;\n\t\t\t\tint bytes;\n\n\t\t\t\tmask = *option++;\n\t\t\t\tif (mask > 32)\n\t\t\t\t\tbreak;\n\t\t\t\tlen--;\n\n\t\t\t\tnip = 0;\n\t\t\t\tp = (void*) &nip;\n\t\t\t\tbytes = (mask + 7) / 8; \n\t\t\t\twhile (--bytes >= 0) {\n\t\t\t\t\t*p++ = *option++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t\tif (len < 4)\n\t\t\t\t\tbreak;\n\n\t\t\t\tdest += sprint_nip(dest, pfx, (void*) &nip);\n\t\t\t\tpfx = \" \";\n\t\t\t\tdest += sprintf(dest, \"/%u \", mask);\n\t\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\t\toption += 4;\n\t\t\t\tlen -= 4;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\tcase OPTION_6RD:\n\t\t\tif (len >= (1 + 1 + 16 + 4)\n\t\t\t && option[0] <= 32\n\t\t\t && (option[1] + 32 - option[0]) <= 128\n\t\t\t) {\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\tdest += sprint_nip6(dest, \n option);\n\t\t\t\toption += 16;\n\t\t\t\tlen -= 1 + 1 + 16 + 4;\n\t\t\t\twhile (1) {\n\t\t\t\t\tdest += sprint_nip(dest, \" \", option);\n\t\t\t\t\toption += 4;\n\t\t\t\t\tlen -= 4; \n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n\t\t\tdest = dname_dec(option, len, ret);\n\t\t\tif (dest) {\n\t\t\t\tfree(ret);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t\treturn ret;\n\t\tcase OPTION_SIP_SERVERS:\n\t\t\toption++;\n\t\t\tlen--;\n\t\t\tif (option[-1] == 0) {\n\t\t\t\tdest = dname_dec(option, len, ret);\n\t\t\t\tif (dest) {\n\t\t\t\t\tfree(ret);\n\t\t\t\t\treturn dest;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif (option[-1] == 1) {\n\t\t\t\tconst char *pfx = \"\";\n\t\t\t\twhile (1) {\n\t\t\t\t\tlen -= 4;\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdest += sprint_nip(dest, pfx, option);\n\t\t\t\t\tpfx = \" \";\n\t\t\t\t\toption += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n#endif\n\t\t} \n\n\t\toption += optlen;\n\t\tlen -= optlen;\n\t\tif (len < optlen \n)\n\t\t\tbreak;\n\t\t*dest++ = ' ';\n\t\t*dest = '\\0';\n\t} \n\n\treturn ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9081, "func": "static bool vmxnet3_vmstate_need_pcie_device(void *opaque)\n{\n    VMXNET3State *s = VMXNET3(opaque);\n\n    return !(s->compat_flags & VMXNET3_COMPAT_FLAG_DISABLE_PCIE);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187975, "func": "WORD32 ih264d_parse_islice_data_cabac(dec_struct_t * ps_dec,\n dec_slice_params_t * ps_slice,\n                                      UWORD16 u2_first_mb_in_slice)\n{\n    UWORD8 uc_more_data_flag;\n    UWORD8 u1_num_mbs, u1_mb_idx;\n dec_mb_info_t *ps_cur_mb_info;\n deblk_mb_t *ps_cur_deblk_mb;\n\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    WORD16 i2_cur_mb_addr;\n    UWORD8 u1_mbaff;\n    UWORD8 u1_num_mbs_next, u1_end_of_row, u1_tfr_n_mb;\n    WORD32 ret = OK;\n\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n\n if(ps_bitstrm->u4_ofst & 0x07)\n {\n        ps_bitstrm->u4_ofst += 8;\n        ps_bitstrm->u4_ofst &= 0xFFFFFFF8;\n }\n    ret = ih264d_init_cabac_dec_envirnoment(&(ps_dec->s_cab_dec_env), ps_bitstrm);\n if(ret != OK)\n return ret;\n    ih264d_init_cabac_contexts(I_SLICE, ps_dec);\n\n    ps_dec->i1_prev_mb_qp_delta = 0;\n\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    u1_num_mbs = u1_mb_idx;\n\n    uc_more_data_flag = 1;\n    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;\n do\n {\n        UWORD16 u2_mbx;\n\n        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n {\n            ret = ERROR_MB_ADDRESS_T;\n break;\n }\n\n {\n            UWORD8 u1_mb_type;\n\n            ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n            ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n            ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n\n            ps_cur_mb_info->u1_end_of_slice = 0;\n\n            ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 0);\n            u2_mbx = ps_dec->u2_mbx;\n\n            ps_cur_mb_info->u1_tran_form8x8 = 0;\n            ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;\n\n            ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n                ih264d_set_deblocking_parameters(\n                                ps_cur_deblk_mb, ps_slice,\n                                ps_dec->u1_mb_ngbr_availablity,\n                                ps_dec->u1_cur_mb_fld_dec_flag);\n\n            ps_cur_deblk_mb->u1_mb_type = ps_cur_deblk_mb->u1_mb_type\n | D_INTRA_MB;\n\n            u1_mb_type = ih264d_parse_mb_type_intra_cabac(0, ps_dec);\n if(u1_mb_type > 25)\n return ERROR_MB_TYPE;\n            ps_cur_mb_info->u1_mb_type = u1_mb_type;\n            COPYTHECONTEXT(\"u1_mb_type\", u1_mb_type);\n\n if(25 == u1_mb_type)\n {\n                ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;\n                ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);\n if(ret != OK)\n return ret;\n                ps_cur_deblk_mb->u1_mb_qp = 0;\n }\n else\n {\n                ret = ih264d_parse_imb_cabac(ps_dec, ps_cur_mb_info, u1_mb_type);\n if(ret != OK)\n return ret;\n                ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n }\n\n if(u1_mbaff)\n {\n                ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n            i2_cur_mb_addr++;\n\n if(ps_cur_mb_info->u1_topmb && u1_mbaff)\n                uc_more_data_flag = 1;\n else\n {\n                uc_more_data_flag = ih264d_decode_terminate(&ps_dec->s_cab_dec_env,\n                                                          ps_bitstrm);\n                uc_more_data_flag = !uc_more_data_flag;\n                COPYTHECONTEXT(\"Decode Sliceterm\",!uc_more_data_flag);\n }\n {\n\n mv_pred_t *ps_mv_nmb_start = ps_dec->ps_mv_cur + (u1_num_mbs << 4);\n mv_pred_t s_mvPred =\n {\n { 0, 0, 0, 0 },\n { -1, -1 }, 0, 0};\n                ih264d_rep_mv_colz(\n                                ps_dec, &s_mvPred, ps_mv_nmb_start, 0,\n (UWORD8)(ps_dec->u1_cur_mb_fld_dec_flag << 1),\n 4, 4);\n }\n if(ps_dec->u4_num_cores < 3)\n {\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n                    ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,\n\n                                          (UWORD16)(u1_num_mbs >> u1_mbaff));\n             }\n             u1_num_mbs++;\n            ps_dec->u2_total_mbs_coded++;\n \n         }\n \n        u1_num_mbs_next = i2_pic_wdin_mbs - u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || (!uc_more_data_flag);\n        ps_cur_mb_info->u1_end_of_slice = (!uc_more_data_flag);\n\n if(u1_tfr_n_mb || (!uc_more_data_flag))\n {\n\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n\n                                             u1_num_mbs_next, u1_tfr_n_mb,\n                                             u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n\n }\n }\n while(uc_more_data_flag);\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n\n - (u2_first_mb_in_slice << u1_mbaff);\n\n return ret;\n}\n", "target": 1, "flaw_line_index": "132"}
{"idx": 187577, "func": "void bdt_enable(void)\n{\n    bdt_log(\"ENABLE BT\");\n if (bt_enabled) {\n\n         bdt_log(\"Bluetooth is already enabled\");\n         return;\n     }\n    status = sBtInterface->enable();\n \n     check_return_status(status);\n }\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8432, "func": "pvscsi_on_issue_scsi(PVSCSIState *s)\n{\n    trace_pvscsi_on_cmd_noimpl(\"PVSCSI_CMD_ISSUE_SCSI\");\n    return PVSCSI_COMMAND_PROCESSING_FAILED;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187501, "func": "bool config_save(const config_t *config, const char *filename) {\n  assert(config != NULL);\n\n   assert(filename != NULL);\n   assert(*filename != '\\0');\n \n  char *temp_filename = osi_calloc(strlen(filename) + 5);\n  if (!temp_filename) {\n    LOG_ERROR(\"%s unable to allocate memory for filename.\", __func__);\n    return false;\n   }\n \n  strcpy(temp_filename, filename);\n  strcat(temp_filename, \".new\");\n \n  FILE *fp = fopen(temp_filename, \"wt\");\n   if (!fp) {\n     LOG_ERROR(\"%s unable to write file '%s': %s\", __func__, temp_filename, strerror(errno));\n     goto error;\n }\n\n \n   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {\n     const section_t *section = (const section_t *)list_node(node);\n    fprintf(fp, \"[%s]\\n\", section->name);\n \n     for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {\n       const entry_t *entry = (const entry_t *)list_node(enode);\n      fprintf(fp, \"%s = %s\\n\", entry->key, entry->value);\n     }\n \n    if (list_next(node) != list_end(config->sections))\n      fputc('\\n', fp);\n   }\n \n  fflush(fp);\n  fclose(fp);\n \n   if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {\n    LOG_ERROR(\"%s unable to change file permissions '%s': %s\", __func__, filename, strerror(errno));\n\n     goto error;\n   }\n \n   if (rename(temp_filename, filename) == -1) {\n     LOG_ERROR(\"%s unable to commit file '%s': %s\", __func__, filename, strerror(errno));\n     goto error;\n   }\n \n   osi_free(temp_filename);\n   return true;\n \nerror:;\n   unlink(temp_filename);\n   osi_free(temp_filename);\n   return false;\n }\n", "target": 1, "flaw_line_index": "7,8,9,10,13,14,16,25,29,33,34,37,38,55"}
{"idx": 8433, "func": "pvscsi_post_load(void *opaque, int version_id)\n{\n    trace_pvscsi_state(\"postload\");\n    return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9119, "func": "static int vrend_decode_set_render_condition(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != VIRGL_RENDER_CONDITION_SIZE)\n      return EINVAL;\n\n   uint32_t handle = get_buf_entry(ctx, VIRGL_RENDER_CONDITION_HANDLE);\n   bool condition = get_buf_entry(ctx, VIRGL_RENDER_CONDITION_CONDITION) & 1;\n   uint mode = get_buf_entry(ctx, VIRGL_RENDER_CONDITION_MODE);\n\n   vrend_render_condition(ctx->grctx, handle, condition, mode);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187928, "func": "sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const\n{\n if (mHeap == 0) {\n Parcel data, reply;\n        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());\n if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {\n            sp<IBinder> heap = reply.readStrongBinder();\n ssize_t o = reply.readInt32();\n size_t s = reply.readInt32();\n\n             if (heap != 0) {\n                 mHeap = interface_cast<IMemoryHeap>(heap);\n                 if (mHeap != 0) {\n                    mOffset = o;\n                    mSize = s;\n                 }\n             }\n         }\n     }\n     if (offset) *offset = mOffset;\n     if (size) *size = mSize;\n    return mHeap;\n }\n", "target": 1, "flaw_line_index": "14,15,22"}
{"idx": 188598, "func": "   void SADs(unsigned int *results) {\n    const uint8_t* refs[] = {GetReference(0), GetReference(1),\n                             GetReference(2), GetReference(3)};\n \n    REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,\n                                      refs, reference_stride_,\n                                      results));\n   }\n", "target": 1, "flaw_line_index": "2,3,5,6,7"}
{"idx": 9122, "func": "static int vrend_decode_set_scissor_state(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_scissor_state ss[PIPE_MAX_VIEWPORTS];\n   uint32_t temp;\n   uint32_t num_scissor, start_slot;\n   int s;\n   if (length < 1)\n      return EINVAL;\n\n   if ((length - 1) % 2)\n      return EINVAL;\n\n   num_scissor = (length - 1) / 2;\n   if (num_scissor > PIPE_MAX_VIEWPORTS)\n      return EINVAL;\n\n   start_slot = get_buf_entry(ctx, VIRGL_SET_SCISSOR_START_SLOT);\n\n   for (s = 0; s < num_scissor; s++) {\n      temp = get_buf_entry(ctx, VIRGL_SET_SCISSOR_MINX_MINY(s));\n      ss[s].minx = temp & 0xffff;\n      ss[s].miny = (temp >> 16) & 0xffff;\n\n      temp = get_buf_entry(ctx, VIRGL_SET_SCISSOR_MAXX_MAXY(s));\n      ss[s].maxx = temp & 0xffff;\n      ss[s].maxy = (temp >> 16) & 0xffff;\n   }\n\n   vrend_set_scissor_state(ctx->grctx, start_slot, num_scissor, ss);\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8650, "func": "size_t mptsas_config_manufacturing_2(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n    return MPTSAS_CONFIG_PACK(2, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"wb*b*l\",\n                              pcic->device_id, pcic->revision);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188601, "func": "   static void TearDownTestCase() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(reference_data_);\n    reference_data_ = NULL;\n   }\n", "target": 1, "flaw_line_index": "2,3,4,5"}
{"idx": 8804, "func": "static void iov_buffer_upload(void *cookie, uint32_t doff, void *src, int len)\n{\n   struct virgl_sub_upload_data *d = cookie;\n   glBufferSubData(d->target, d->box->x + doff, len, src);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187929, "func": "WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)\n{\n dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;\n dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    WORD32 j;\n    UWORD8 u1_buf_mode;\n struct MMCParams *ps_mmc_params;\n    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;\n\n    ps_slice->u1_mmco_equalto5 = 0;\n {\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_slice->u1_no_output_of_prior_pics_flag =\n                            ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: no_output_of_prior_pics_flag\",\n                            ps_slice->u1_no_output_of_prior_pics_flag);\n            ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(\n                            ps_bitstrm);\n            COPYTHECONTEXT(\"SH: long_term_reference_flag\",\n                            ps_slice->u1_long_term_reference_flag);\n            ps_dpb_cmds->u1_idr_pic = 1;\n            ps_dpb_cmds->u1_no_output_of_prior_pics_flag =\n                            ps_slice->u1_no_output_of_prior_pics_flag;\n            ps_dpb_cmds->u1_long_term_reference_flag =\n                            ps_slice->u1_long_term_reference_flag;\n }\n else\n {\n            u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm); \n            COPYTHECONTEXT(\"SH: adaptive_ref_pic_buffering_flag\", u1_buf_mode);\n            ps_dpb_cmds->u1_buf_mode = u1_buf_mode;\n            j = 0;\n\n if(u1_buf_mode == 1)\n {\n                UWORD32 u4_mmco;\n                UWORD32 u4_diff_pic_num;\n                UWORD32 u4_lt_idx, u4_max_lt_idx;\n\n                u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n\n                                      pu4_bitstrm_buf);\n                 while(u4_mmco != END_OF_MMCO)\n                 {\n                     ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];\n                     ps_mmc_params->u4_mmco = u4_mmco;\n                     switch(u4_mmco)\n {\n case MARK_ST_PICNUM_AS_NONREF:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n break;\n\n case MARK_LT_INDEX_AS_NONREF:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case MARK_ST_PICNUM_AS_LT_INDEX:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case SET_MAX_LT_INDEX:\n {\n                            u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n                            ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;\n break;\n }\n case RESET_REF_PICTURES:\n {\n                            ps_slice->u1_mmco_equalto5 = 1;\n break;\n }\n\n case SET_LT_INDEX:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n default:\n break;\n }\n                    u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                         pu4_bitstrm_buf);\n\n                    j++;\n }\n                ps_dpb_cmds->u1_num_of_commands = j;\n\n }\n }\n        ps_dpb_cmds->u1_dpb_commands_read = 1;\n        ps_dpb_cmds->u1_dpb_commands_read_slc = 1;\n\n }\n    u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;\n return u4_bit_ofst;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 8545, "func": "static Bignum ssh2_pkt_getmp(struct Packet *pkt)\n{\n    char *p;\n    int length;\n    Bignum b;\n\n    ssh_pkt_getstring(pkt, &p, &length);\n    if (!p)\n\treturn NULL;\n    if (p[0] & 0x80)\n\treturn NULL;\n    b = bignum_from_bytes((unsigned char *)p, length);\n    return b;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187361, "func": "status_t SampleTable::setTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n if (mTimeToSample != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n }\n\n return OK;\n}\n", "target": 1, "flaw_line_index": "20"}
{"idx": 187957, "func": "int Reverb_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n int retsize;\n    LVREV_ControlParams_st    ActiveParams; \n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; \n\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_INIT: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Reverb_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n Reverb_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n\n             effect_param_t *p = (effect_param_t *)pCmdData;\n             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                     cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                     pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n (void *)p->data,\n (size_t *)&p->vsize,\n                                                          p->data + voffset);\n\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n\n\n if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::Reverb_setParameter(pContext,\n (void *)p->data,\n                                                              p->data + p->psize);\n } break;\n\n case EFFECT_CMD_ENABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n break;\n case EFFECT_CMD_DISABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n\n if (pReplyData != NULL) { \n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n *(uint32_t *)pReplyData = (1 << 24);\n *((uint32_t *)pReplyData + 1) = (1 << 24);\n if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n }\n } else { \n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"DEFAULT start %d ERROR\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n} \n", "target": 1, "flaw_line_index": ""}
{"idx": 187485, "func": " bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)\n{\n if (thread_handle < 0 || thread_handle >= MAX_THREAD)\n {\n        APPL_TRACE_ERROR(\"%s invalid thread handle: %d\", __func__, thread_handle);\n return false;\n }\n if (fd == -1)\n {\n        APPL_TRACE_ERROR(\"%s invalid file descriptor.\", __func__);\n return false;\n\n     }\n \n     sock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};\n    return send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n }\n", "target": 1, "flaw_line_index": "16"}
{"idx": 8944, "func": "void vrend_set_streamout_targets(struct vrend_context *ctx,\n                                 uint32_t append_bitmask,\n                                 uint32_t num_targets,\n                                 uint32_t *handles)\n{\n   struct vrend_so_target *target;\n   int i;\n\n   if (num_targets) {\n      bool found = false;\n      struct vrend_streamout_object *obj;\n      LIST_FOR_EACH_ENTRY(obj, &ctx->sub->streamout_list, head) {\n         if (obj->num_targets == num_targets) {\n            if (!memcmp(handles, obj->handles, num_targets * 4)) {\n               found = true;\n               break;\n            }\n         }\n      }\n      if (found) {\n         ctx->sub->current_so = obj;\n         glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, obj->id);\n         return;\n      }\n\n      obj = CALLOC_STRUCT(vrend_streamout_object);\n      if (vrend_state.have_tf2) {\n         glGenTransformFeedbacks(1, &obj->id);\n         glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, obj->id);\n      }\n      obj->num_targets = num_targets;\n      for (i = 0; i < num_targets; i++) {\n         obj->handles[i] = handles[i];\n         target = vrend_object_lookup(ctx->sub->object_hash, handles[i], VIRGL_OBJECT_STREAMOUT_TARGET);\n         if (!target) {\n            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_HANDLE, handles[i]);\n            free(obj);\n            return;\n         }\n         vrend_so_target_reference(&obj->so_targets[i], target);\n      }\n      vrend_hw_emit_streamout_targets(ctx, obj);\n      list_addtail(&obj->head, &ctx->sub->streamout_list);\n      ctx->sub->current_so = obj;\n      obj->xfb_state = XFB_STATE_STARTED_NEED_BEGIN;\n   } else {\n      if (vrend_state.have_tf2)\n         glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, 0);\n      ctx->sub->current_so = NULL;\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 9084, "func": "static inline void *get_buf_ptr(struct vrend_decode_ctx *ctx,\n                                uint32_t offset)\n{\n   return &ctx->ds->buf[ctx->ds->buf_offset + offset];\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188566, "func": " int GetFreeFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n const int idx = FindFreeBufferIndex();\n if (idx == num_buffers_)\n return -1;\n\n\n     if (ext_fb_list_[idx].size < min_size) {\n       delete [] ext_fb_list_[idx].data;\n       ext_fb_list_[idx].data = new uint8_t[min_size];\n       ext_fb_list_[idx].size = min_size;\n     }\n \n SetFrameBuffer(idx, fb);\n return 0;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 8517, "func": "static void hash_string(const struct ssh_hash *h, void *s, void *str, int len)\n{\n    unsigned char lenblk[4];\n    PUT_32BIT(lenblk, len);\n    h->bytes(s, lenblk, 4);\n    h->bytes(s, str, len);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8682, "func": "char_needs_escaping (const char *p)\n{\n  if (*p == '%')\n    {\n      if (c_isxdigit (*(p + 1)) && c_isxdigit (*(p + 2)))\n        return false;\n      else\n        return true;\n    }\n  else if (URL_UNSAFE_CHAR (*p) && !URL_RESERVED_CHAR (*p))\n    return true;\n  else\n    return false;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8798, "func": "static void dump_stream_out(struct pipe_stream_output_info *so)\n{\n   int i;\n   if (!so)\n      return;\n   printf(\"streamout: %d\\n\", so->num_outputs);\n   printf(\"strides: \");\n   for (i = 0; i < 4; i++)\n      printf(\"%d \", so->stride[i]);\n   printf(\"\\n\");\n   printf(\"outputs:\\n\");\n   for (i = 0; i < so->num_outputs; i++) {\n      printf(\"\\t%d: reg: %d sc: %d, nc: %d ob: %d do: %d\\n\",\n             i,\n             so->output[i].register_index,\n             so->output[i].start_component,\n             so->output[i].num_components,\n             so->output[i].output_buffer,\n             so->output[i].dst_offset);\n   }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187395, "func": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n\n     if (err != NO_ERROR) return 0;\n \n     native_handle* h = native_handle_create(numFds, numInts);\n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n         if (h->data[i] < 0) err = BAD_VALUE;\n }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187514, "func": "static bool write_hci_command(hci_packet_t type, const void *packet, size_t length) {\n int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n if (sock == INVALID_FD)\n goto error;\n\n struct sockaddr_in addr;\n\n   addr.sin_family = AF_INET;\n   addr.sin_addr.s_addr = htonl(0x7F000001);\n   addr.sin_port = htons(8873);\n  if (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)\n     goto error;\n \n  if (send(sock, &type, 1, 0) != 1)\n     goto error;\n \n  if (send(sock, &length, 2, 0) != 2)\n     goto error;\n \n  if (send(sock, packet, length, 0) != (ssize_t)length)\n     goto error;\n \n   close(sock);\n return true;\n\nerror:;\n  close(sock);\n return false;\n}\n", "target": 1, "flaw_line_index": "11,14,17,20"}
{"idx": 8809, "func": "static void set_stream_out_varyings(int prog_id, struct vrend_shader_info *sinfo)\n{\n   struct pipe_stream_output_info *so = &sinfo->so_info;\n   char *varyings[PIPE_MAX_SHADER_OUTPUTS*2];\n   int i, j;\n   int n_outputs = 0;\n   int last_buffer = 0;\n   char *start_skip;\n   int buf_offset = 0;\n   int skip;\n   if (!so->num_outputs)\n      return;\n\n   if (vrend_dump_shaders)\n      dump_stream_out(so);\n\n   for (i = 0; i < so->num_outputs; i++) {\n      if (last_buffer != so->output[i].output_buffer) {\n\n         skip = so->stride[last_buffer] - buf_offset;\n         while (skip) {\n            start_skip = get_skip_str(&skip);\n            if (start_skip)\n               varyings[n_outputs++] = start_skip;\n         }\n         for (j = last_buffer; j < so->output[i].output_buffer; j++)\n            varyings[n_outputs++] = strdup(\"gl_NextBuffer\");\n         last_buffer = so->output[i].output_buffer;\n         buf_offset = 0;\n      }\n\n      skip = so->output[i].dst_offset - buf_offset;\n      while (skip) {\n         start_skip = get_skip_str(&skip);\n         if (start_skip)\n            varyings[n_outputs++] = start_skip;\n      }\n      buf_offset = so->output[i].dst_offset;\n\n      buf_offset += so->output[i].num_components;\n      if (sinfo->so_names[i])\n         varyings[n_outputs++] = strdup(sinfo->so_names[i]);\n   }\n\n   skip = so->stride[last_buffer] - buf_offset;\n   while (skip) {\n      start_skip = get_skip_str(&skip);\n      if (start_skip)\n         varyings[n_outputs++] = start_skip;\n   }\n\n   glTransformFeedbackVaryings(prog_id, n_outputs,\n                               (const GLchar **)varyings, GL_INTERLEAVED_ATTRIBS_EXT);\n\n   for (i = 0; i < n_outputs; i++)\n      if (varyings[i])\n         free(varyings[i]);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8438, "func": "pvscsi_raise_completion_interrupt(PVSCSIState *s)\n{\n    s->reg_interrupt_status |= PVSCSI_INTR_CMPL_0;\n\n    smp_wmb();\n\n    pvscsi_update_irq_status(s);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187583, "func": " int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,\n\t\togg_int32_t **in,int *nonzero,int ch){\n \n   int i,j,k,s,used=0;\n   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;\n  codebook *phrasebook=ci->book_param+info->groupbook;\n int samples_per_partition=info->grouping;\n int partitions_per_word=phrasebook->dim;\n int pcmend=ci->blocksizes[vd->W];\n\n if(info->type<2){\n int max=pcmend>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       for(i=0;i<ch;i++)\n\tif(nonzero[i])\n\t  in[used++]=in[i];\n       ch=used;\n \n       if(used){\n \n\tchar **partword=(char **)alloca(ch*sizeof(*partword));\n\tfor(j=0;j<ch;j++)\n\t  partword[j]=(char *)alloca(partwords*partitions_per_word*\n\t\t\t\t     sizeof(*partword[j]));\n \n\tfor(s=0;s<info->stages;s++){\n \n\t  for(i=0;i<partvals;){\n\t    if(s==0){\n \n\t      partword[0][i+partitions_per_word-1]=1;\n\t      for(k=partitions_per_word-2;k>=0;k--)\n\t\tpartword[0][i+k]=partword[0][i+k+1]*info->partitions;\n \n\t      for(j=1;j<ch;j++)\n\t\tfor(k=partitions_per_word-1;k>=0;k--)\n\t\t  partword[j][i+k]=partword[j-1][i+k];\n \n\t      for(j=0;j<ch;j++){\n\t\tint temp=vorbis_book_decode(phrasebook,&vd->opb);\n\t\tif(temp==-1)goto eopbreak;\n \n\t\tfor(k=0;k<partitions_per_word;k++){\n\t\t  ogg_uint32_t div=partword[j][i+k];\n\t\t  partword[j][i+k]=temp/div;\n\t\t  temp-=partword[j][i+k]*div;\n\t\t}\n \n\t      }\n\t    }\n \n\t    for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n\t      for(j=0;j<ch;j++){\n\t\tlong offset=info->begin+i*samples_per_partition;\n\t\tif(info->stagemasks[(int)partword[j][i]]&(1<<s)){\n\t\t  codebook *stagebook=ci->book_param+\n\t\t    info->stagebooks[(partword[j][i]<<3)+s];\n\t\t  if(info->type){\n\t\t    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t       samples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }else{\n\t\t    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t\tsamples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }\n\t\t}\n\t      }\n\t  }\n\t}\n       }\n     }\n   }else{\n int max=(pcmend*ch)>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       char *partword=\n\t(char *)alloca(partwords*partitions_per_word*sizeof(*partword));\n       int beginoff=info->begin/ch;\n \n       for(i=0;i<ch;i++)if(nonzero[i])break;\n if(i==ch)return(0); \n\n      samples_per_partition/=ch;\n\n for(s=0;s<info->stages;s++){\n for(i=0;i<partvals;){\n\n if(s==0){\n int temp;\n\t    partword[i+partitions_per_word-1]=1;\n for(k=partitions_per_word-2;k>=0;k--)\n\t      partword[i+k]=partword[i+k+1]*info->partitions;\n\n\t    temp=vorbis_book_decode(phrasebook,&vd->opb);\n if(temp==-1)goto eopbreak;\n\n for(k=0;k<partitions_per_word;k++){\n ogg_uint32_t div=partword[i+k];\n\t      partword[i+k]=temp/div;\n\t      temp-=partword[i+k]*div;\n }\n }\n\n for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n if(info->stagemasks[(int)partword[i]]&(1<<s)){\n\t      codebook *stagebook=ci->book_param+\n\t\tinfo->stagebooks[(partword[i]<<3)+s];\n if(vorbis_book_decodevv_add(stagebook,in,\n\t\t\t\t\t  i*samples_per_partition+beginoff,ch,\n &vd->opb,\n\t\t\t\t\t  samples_per_partition,-8)==-1)\n goto eopbreak;\n }\n }\n }\n }\n }\n eopbreak:\n\n return 0;\n}\n", "target": 1, "flaw_line_index": "2,22,23,28,29,30,31,33,35,36,36,38,39,40,42,43,44,46,47,48,49,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,91"}
{"idx": 187693, "func": "modifier_total_encodings(PNG_CONST png_modifier *pm)\n {\n    return 1 +                 \n       pm->ngammas +           \n      pm->nencodings + \n ((pm->bit_depth == 16 || pm->assume_16_bit_calculations) ?\n         pm->nencodings : 0); \n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 9144, "func": "static boolean str_match_no_case( const char **pcur, const char *str )\n{\n   const char *cur = *pcur;\n\n   while (*str != '\\0' && *str == uprcase( *cur )) {\n      str++;\n      cur++;\n   }\n   if (*str == '\\0') {\n      *pcur = cur;\n      return TRUE;\n   }\n   return FALSE;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187671, "func": "image_transform_png_set_strip_16_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->bit_depth == 16)\n    {\n      that->sample_depth = that->bit_depth = 8;\n if (that->red_sBIT > 8) that->red_sBIT = 8;\n if (that->green_sBIT > 8) that->green_sBIT = 8;\n if (that->blue_sBIT > 8) that->blue_sBIT = 8;\n if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;\n\n#     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED\n#        if PNG_LIBPNG_VER >= 10504\n#           error PNG_READ_ACCURATE_SCALE should not be set\n#        endif\n\n          {\n            PNG_CONST double d = (255-128.5)/65535;\n             that->rede += d;\n             that->greene += d;\n             that->bluee += d;\n            that->alphae += d;\n }\n#     endif\n }\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "flaw_line_index": "3,19"}
{"idx": 187963, "func": "INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n     return;\n }\n", "target": 1, "flaw_line_index": "6"}
{"idx": 187983, "func": " int SoundPool::load(const char* path, int priority __unused)\n {\n     ALOGV(\"load: path=%s, priority=%d\", path, priority);\n    Mutex::Autolock lock(&mLock);\n    sp<Sample> sample = new Sample(++mNextSampleID, path);\n    mSamples.add(sample->sampleID(), sample);\n    doLoad(sample);\n    return sample->sampleID();\n }\n", "target": 1, "flaw_line_index": "4,5,6,7,8"}
{"idx": 187448, "func": "static ssize_t in_read(struct audio_stream_in *stream, void* buffer,\n size_t bytes)\n{\n struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;\n int read;\n\n    DEBUG(\"read %zu bytes, state: %d\", bytes, in->common.state);\n\n if (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)\n {\n        DEBUG(\"stream suspended\");\n return -1;\n }\n\n if ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||\n (in->common.state == AUDIO_A2DP_STATE_STANDBY))\n {\n        pthread_mutex_lock(&in->common.lock);\n\n if (start_audio_datapath(&in->common) < 0)\n {\n\n int us_delay = calc_audiotime(in->common.cfg, bytes);\n\n \n             DEBUG(\"emulate a2dp read delay (%d us)\", us_delay);\n \n            usleep(us_delay);\n             pthread_mutex_unlock(&in->common.lock);\n             return -1;\n         }\n\n        pthread_mutex_unlock(&in->common.lock);\n }\n else if (in->common.state != AUDIO_A2DP_STATE_STARTED)\n {\n        ERROR(\"stream not in stopped or standby\");\n return -1;\n }\n\n    read = skt_read(in->common.audio_fd, buffer, bytes);\n\n if (read == -1)\n {\n        skt_disconnect(in->common.audio_fd);\n        in->common.audio_fd = AUDIO_SKT_DISCONNECTED;\n        in->common.state = AUDIO_A2DP_STATE_STOPPED;\n } else if (read == 0) {\n        DEBUG(\"read time out - return zeros\");\n        memset(buffer, 0, bytes);\n        read = bytes;\n }\n\n    DEBUG(\"read %d bytes out of %zu bytes\", read, bytes);\n return read;\n}\n", "target": 1, "flaw_line_index": "28"}
{"idx": 9098, "func": "static int vrend_decode_create_sampler_state(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_sampler_state state;\n   int i;\n   uint32_t tmp;\n\n   if (length != VIRGL_OBJ_SAMPLER_STATE_SIZE)\n      return EINVAL;\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_STATE_S0);\n   state.wrap_s = tmp & 0x7;\n   state.wrap_t = (tmp >> 3) & 0x7;\n   state.wrap_r = (tmp >> 6) & 0x7;\n   state.min_img_filter = (tmp >> 9) & 0x3;\n   state.min_mip_filter = (tmp >> 11) & 0x3;\n   state.mag_img_filter = (tmp >> 13) & 0x3;\n   state.compare_mode = (tmp >> 15) & 0x1;\n   state.compare_func = (tmp >> 16) & 0x7;\n\n   state.lod_bias = uif(get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_STATE_LOD_BIAS));\n   state.min_lod = uif(get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_STATE_MIN_LOD));\n   state.max_lod = uif(get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_STATE_MAX_LOD));\n\n   for (i = 0; i < 4; i++)\n      state.border_color.ui[i] = get_buf_entry(ctx, VIRGL_OBJ_SAMPLER_STATE_BORDER_COLOR(i));\n   return vrend_create_sampler_state(ctx->grctx, handle, &state);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188562, "func": " void EncoderTest::RunLoop(VideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = {0};\n \n   stats_.Reset();\n \n  ASSERT_TRUE(passes_ == 1 || passes_ == 2);\n for (unsigned int pass = 0; pass < passes_; pass++) {\n    last_pts_ = 0;\n\n if (passes_ == 1)\n      cfg_.g_pass = VPX_RC_ONE_PASS;\n else if (pass == 0)\n      cfg_.g_pass = VPX_RC_FIRST_PASS;\n else\n      cfg_.g_pass = VPX_RC_LAST_PASS;\n\n BeginPassHook(pass);\n\n     Encoder* const encoder = codec_->CreateEncoder(cfg_, deadline_, init_flags_,\n                                                    &stats_);\n     ASSERT_TRUE(encoder != NULL);\n    Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n     bool again;\n    for (again = true, video->Begin(); again; video->Next()) {\n       again = (video->img() != NULL);\n \n       PreEncodeFrameHook(video);\n PreEncodeFrameHook(video, encoder);\n      encoder->EncodeFrame(video, frame_flags_);\n\n CxDataIterator iter = encoder->GetCxData();\n\n bool has_cxdata = false;\n bool has_dxdata = false;\n while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {\n        pkt = MutateEncoderOutputHook(pkt);\n        again = true;\n switch (pkt->kind) {\n case VPX_CODEC_CX_FRAME_PKT:\n            has_cxdata = true;\n\n             if (decoder && DoDecode()) {\n               vpx_codec_err_t res_dec = decoder->DecodeFrame(\n                   (const uint8_t*)pkt->data.frame.buf, pkt->data.frame.sz);\n              ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n               has_dxdata = true;\n             }\n             ASSERT_GE(pkt->data.frame.pts, last_pts_);\n            last_pts_ = pkt->data.frame.pts;\n FramePktHook(pkt);\n break;\n\n case VPX_CODEC_PSNR_PKT:\n PSNRPktHook(pkt);\n break;\n\n default:\n break;\n\n         }\n       }\n \n       if (has_dxdata && has_cxdata) {\n         const vpx_image_t *img_enc = encoder->GetPreviewFrame();\n         DxDataIterator dec_iter = decoder->GetDxData();\n const vpx_image_t *img_dec = dec_iter.Next();\n if (img_enc && img_dec) {\n const bool res = compare_img(img_enc, img_dec);\n if (!res) { \n MismatchHook(img_enc, img_dec);\n }\n }\n if (img_dec)\n DecompressedFrameHook(*img_dec, video->pts());\n }\n if (!Continue())\n break;\n }\n\n EndPassHook();\n\n if (decoder)\n delete decoder;\n delete encoder;\n\n if (!Continue())\n break;\n }\n}\n", "target": 1, "flaw_line_index": "2,22,24,45"}
{"idx": 8937, "func": "void vrend_set_num_vbo(struct vrend_context *ctx,\n                       int num_vbo)\n{\n   int old_num = ctx->sub->num_vbos;\n   int i;\n\n   ctx->sub->num_vbos = num_vbo;\n   ctx->sub->old_num_vbos = old_num;\n\n   if (old_num != num_vbo)\n      ctx->sub->vbo_dirty = true;\n\n   for (i = num_vbo; i < old_num; i++) {\n      vrend_resource_reference((struct vrend_resource **)&ctx->sub->vbo[i].buffer, NULL);\n      ctx->sub->vbo_res_ids[i] = 0;\n   }\n\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188094, "func": "status_t BnSoundTriggerHwService::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n\n         case LIST_MODULES: {\n             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n             unsigned int numModulesReq = data.readInt32();\n             unsigned int numModules = numModulesReq;\n             struct sound_trigger_module_descriptor *modules =\n                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,\n                                                    sizeof(struct sound_trigger_module_descriptor));\n             status_t status = listModules(modules, &numModules);\n             reply->writeInt32(status);\n             reply->writeInt32(numModules);\n            ALOGV(\"LIST_MODULES status %d got numModules %d\", status, numModules);\n\n if (status == NO_ERROR) {\n if (numModulesReq > numModules) {\n                    numModulesReq = numModules;\n }\n                reply->write(modules,\n                             numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n            free(modules);\n return NO_ERROR;\n }\n\n case ATTACH: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n sound_trigger_module_handle_t handle;\n            data.read(&handle, sizeof(sound_trigger_module_handle_t));\n            sp<ISoundTriggerClient> client =\n                    interface_cast<ISoundTriggerClient>(data.readStrongBinder());\n            sp<ISoundTrigger> module;\n status_t status = attach(handle, client, module);\n            reply->writeInt32(status);\n if (module != 0) {\n                reply->writeInt32(1);\n                reply->writeStrongBinder(IInterface::asBinder(module));\n } else {\n                reply->writeInt32(0);\n }\n return NO_ERROR;\n } break;\n\n case SET_CAPTURE_STATE: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n            reply->writeInt32(setCaptureState((bool)data.readInt32()));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188112, "func": "WORD32 ixheaacd_complex_anal_filt(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer) {\n  WORD32 idx;\n  WORD32 anal_size = 2 * ptr_hbe_txposer->synth_size;\n  WORD32 N = (10 * anal_size);\n\n for (idx = 0; idx < (ptr_hbe_txposer->no_bins >> 1); idx++) {\n    WORD32 i, j, k, l;\n    FLOAT32 window_output[640];\n    FLOAT32 u[128], u_in[256], u_out[256];\n    FLOAT32 accu_r, accu_i;\n const FLOAT32 *inp_signal;\n    FLOAT32 *anal_buf;\n\n    FLOAT32 *analy_cos_sin_tab = ptr_hbe_txposer->analy_cos_sin_tab;\n const FLOAT32 *interp_window_coeff = ptr_hbe_txposer->analy_wind_coeff;\n    FLOAT32 *x = ptr_hbe_txposer->analy_buf;\n\n    memset(ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1], 0,\n           TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof(FLOAT32));\n\n    inp_signal = ptr_hbe_txposer->ptr_input_buf +\n                 idx * 2 * ptr_hbe_txposer->synth_size + 1;\n    anal_buf = &ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1]\n [4 * ptr_hbe_txposer->k_start];\n\n for (i = N - 1; i >= anal_size; i--) {\n      x[i] = x[i - anal_size];\n }\n\n for (i = anal_size - 1; i >= 0; i--) {\n      x[i] = inp_signal[anal_size - 1 - i];\n }\n\n for (i = 0; i < N; i++) {\n      window_output[i] = x[i] * interp_window_coeff[i];\n }\n\n for (i = 0; i < 2 * anal_size; i++) {\n      accu_r = 0.0;\n for (j = 0; j < 5; j++) {\n        accu_r = accu_r + window_output[i + j * 2 * anal_size];\n }\n      u[i] = accu_r;\n }\n\n if (anal_size == 40) {\n for (i = 1; i < anal_size; i++) {\n        FLOAT32 temp1 = u[i] + u[2 * anal_size - i];\n        FLOAT32 temp2 = u[i] - u[2 * anal_size - i];\n        u[i] = temp1;\n        u[2 * anal_size - i] = temp2;\n }\n\n for (k = 0; k < anal_size; k++) {\n        accu_r = u[anal_size];\n if (k & 1)\n          accu_i = u[0];\n else\n          accu_i = -u[0];\n for (l = 1; l < anal_size; l++) {\n          accu_r = accu_r + u[0 + l] * analy_cos_sin_tab[2 * l + 0];\n          accu_i = accu_i + u[2 * anal_size - l] * analy_cos_sin_tab[2 * l + 1];\n }\n        analy_cos_sin_tab += (2 * anal_size);\n *anal_buf++ = (FLOAT32)accu_r;\n *anal_buf++ = (FLOAT32)accu_i;\n }\n } else {\n      FLOAT32 *ptr_u = u_in;\n      FLOAT32 *ptr_v = u_out;\n for (k = 0; k < anal_size * 2; k++) {\n\n         *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);\n         *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);\n       }\n      if (ixheaacd_cmplx_anal_fft != NULL)\n        (*ixheaacd_cmplx_anal_fft)(u_in, u_out, anal_size * 2);\n       else\n         return -1;\n \n for (k = 0; k < anal_size / 2; k++) {\n *(anal_buf + 1) = -*ptr_v++;\n *anal_buf = *ptr_v++;\n\n        anal_buf += 2;\n\n *(anal_buf + 1) = *ptr_v++;\n *anal_buf = -*ptr_v++;\n\n        anal_buf += 2;\n }\n }\n }\n return 0;\n}\n", "target": 1, "flaw_line_index": "76,77"}
{"idx": 187796, "func": "static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\n const char* name;\n size_t namelen;\n if (node->graft_path) {\n        name = node->graft_path;\n        namelen = node->graft_pathlen;\n } else if (node->actual_name) {\n        name = node->actual_name;\n        namelen = node->namelen;\n } else {\n        name = node->name;\n        namelen = node->namelen;\n }\n\n if (bufsize < namelen + 1) {\n return -1;\n }\n\n \n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\n         if (pathlen < 0) {\n             return -1;\n         }\n        buf[pathlen++] = '/';\n }\n\n    memcpy(buf + pathlen, name, namelen + 1); \n return pathlen + namelen;\n}\n", "target": 1, "flaw_line_index": "22"}
{"idx": 9087, "func": "static int vrend_decode_bind_object(struct vrend_decode_ctx *ctx, uint16_t length)\n{\n   if (length != 1)\n      return EINVAL;\n\n   uint32_t header = get_buf_entry(ctx, VIRGL_OBJ_BIND_HEADER);\n   uint32_t handle = get_buf_entry(ctx, VIRGL_OBJ_BIND_HANDLE);\n   uint8_t obj_type = (header >> 8) & 0xff;\n\n   switch (obj_type) {\n   case VIRGL_OBJECT_BLEND:\n      vrend_object_bind_blend(ctx->grctx, handle);\n      break;\n   case VIRGL_OBJECT_DSA:\n      vrend_object_bind_dsa(ctx->grctx, handle);\n      break;\n   case VIRGL_OBJECT_RASTERIZER:\n      vrend_object_bind_rasterizer(ctx->grctx, handle);\n      break;\n   case VIRGL_OBJECT_VERTEX_ELEMENTS:\n      vrend_bind_vertex_elements_state(ctx->grctx, handle);\n      break;\n   default:\n      return EINVAL;\n   }\n\n   return 0;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188025, "func": "bool NuMediaExtractor::getTotalBitrate(int64_t *bitrate) const {\n if (mTotalBitrate >= 0) {\n *bitrate = mTotalBitrate;\n return true;\n\n     }\n \n     off64_t size;\n    if (mDurationUs >= 0 && mDataSource->getSize(&size) == OK) {\n         *bitrate = size * 8000000ll / mDurationUs;  \n         return true;\n     }\n\n return false;\n}\n", "target": 1, "flaw_line_index": "9"}
{"idx": 8706, "func": "url_error (const char *url, int error_code)\n{\n  assert (error_code >= 0 && ((size_t) error_code) < countof (parse_errors));\n\n  if (error_code == PE_UNSUPPORTED_SCHEME)\n    {\n      char *error, *p;\n      char *scheme = xstrdup (url);\n      assert (url_has_scheme (url));\n\n      if ((p = strchr (scheme, ':')))\n        *p = '\\0';\n      if (!c_strcasecmp (scheme, \"https\"))\n        error = aprintf (_(\"HTTPS support not compiled in\"));\n      else\n        error = aprintf (_(parse_errors[error_code]), quote (scheme));\n      xfree (scheme);\n\n      return error;\n    }\n  else\n    return xstrdup (_(parse_errors[error_code]));\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187780, "func": "void ih264d_init_decoder(void * ps_dec_params)\n{\n\n     dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;\n     dec_slice_params_t *ps_cur_slice;\n     pocstruct_t *ps_prev_poc, *ps_cur_poc;\n \n     ih264d_free_dynamic_bufs(ps_dec);\n\n    ps_cur_slice = ps_dec->ps_cur_slice;\n    ps_dec->init_done = 0;\n\n    ps_dec->u4_num_cores = 1;\n\n    ps_dec->u2_pic_ht = ps_dec->u2_pic_wd = 0;\n\n    ps_dec->u1_separate_parse = DEFAULT_SEPARATE_PARSE;\n    ps_dec->u4_app_disable_deblk_frm = 0;\n    ps_dec->i4_degrade_type = 0;\n    ps_dec->i4_degrade_pics = 0;\n\n    ps_dec->i4_app_skip_mode = IVD_SKIP_NONE;\n    ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n\n    memset(ps_dec->ps_pps, 0,\n ((sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS));\n    memset(ps_dec->ps_sps, 0,\n ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS));\n\n\n    ps_dec->p_DeblockPicture[0] = ih264d_deblock_picture_non_mbaff;\n    ps_dec->p_DeblockPicture[1] = ih264d_deblock_picture_mbaff;\n\n    ps_dec->s_cab_dec_env.pv_codec_handle = ps_dec;\n\n    ps_dec->u4_num_fld_in_frm = 0;\n\n    ps_dec->ps_dpb_mgr->pv_codec_handle = ps_dec;\n\n    ps_dec->ps_sei->u1_is_valid = 0;\n\n    ps_dec->ps_cur_pps = NULL;\n    ps_dec->ps_cur_sps = NULL;\n    ps_dec->u1_init_dec_flag = 0;\n    ps_dec->u1_first_slice_in_stream = 1;\n    ps_dec->u1_first_pb_nal_in_pic = 1;\n    ps_dec->u1_last_pic_not_decoded = 0;\n    ps_dec->u4_app_disp_width = 0;\n    ps_dec->i4_header_decoded = 0;\n    ps_dec->u4_total_frames_decoded = 0;\n\n    ps_dec->i4_error_code = 0;\n    ps_dec->i4_content_type = -1;\n    ps_dec->ps_cur_slice->u1_mbaff_frame_flag = 0;\n\n    ps_dec->ps_dec_err_status->u1_err_flag = ACCEPT_ALL_PICS; \n    ps_dec->ps_dec_err_status->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n    ps_dec->ps_dec_err_status->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n    ps_dec->ps_dec_err_status->u4_cur_frm = INIT_FRAME;\n    ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n\n    ps_dec->u1_pr_sl_type = 0xFF;\n    ps_dec->u2_mbx = 0xffff;\n    ps_dec->u2_mby = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n\n    ps_prev_poc = &ps_dec->s_prev_pic_poc;\n    ps_cur_poc = &ps_dec->s_cur_pic_poc;\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb = 0;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb = 0;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom = 0;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;\n    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;\n    ps_prev_poc->i4_top_field_order_count = ps_cur_poc->i4_top_field_order_count =\n 0;\n    ps_prev_poc->i4_bottom_field_order_count =\n                    ps_cur_poc->i4_bottom_field_order_count = 0;\n    ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field = 0;\n    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst = 0;\n    ps_cur_slice->u1_mmco_equalto5 = 0;\n    ps_cur_slice->u2_frame_num = 0;\n\n    ps_dec->i4_max_poc = 0;\n    ps_dec->i4_prev_max_display_seq = 0;\n    ps_dec->u1_recon_mb_grp = 4;\n\n    ps_dec->u1_second_field = 0;\n    ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n\n    ps_dec->u2_crop_offset_y = 0;\n    ps_dec->u2_crop_offset_uv = 0;\n\n    ps_dec->i4_vui_frame_rate = -1;\n    ps_dec->i4_pic_type = -1;\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n\n    ps_dec->u1_res_changed = 0;\n\n\n    ps_dec->u1_frame_decoded_flag = 0;\n\n    ps_dec->u4_skip_frm_mask = SKIP_NONE;\n\n    ps_dec->pf_cavlc_4x4res_block[0] = ih264d_cavlc_4x4res_block_totalcoeff_1;\n    ps_dec->pf_cavlc_4x4res_block[1] =\n                    ih264d_cavlc_4x4res_block_totalcoeff_2to10;\n    ps_dec->pf_cavlc_4x4res_block[2] =\n                    ih264d_cavlc_4x4res_block_totalcoeff_11to16;\n\n    ps_dec->pf_cavlc_parse4x4coeff[0] = ih264d_cavlc_parse4x4coeff_n0to7;\n    ps_dec->pf_cavlc_parse4x4coeff[1] = ih264d_cavlc_parse4x4coeff_n8;\n\n    ps_dec->pf_cavlc_parse_8x8block[0] =\n                    ih264d_cavlc_parse_8x8block_none_available;\n    ps_dec->pf_cavlc_parse_8x8block[1] =\n                    ih264d_cavlc_parse_8x8block_left_available;\n    ps_dec->pf_cavlc_parse_8x8block[2] =\n                    ih264d_cavlc_parse_8x8block_top_available;\n    ps_dec->pf_cavlc_parse_8x8block[3] =\n                    ih264d_cavlc_parse_8x8block_both_available;\n\n    ps_dec->pf_fill_bs1[0][0] = ih264d_fill_bs1_16x16mb_pslice;\n    ps_dec->pf_fill_bs1[0][1] = ih264d_fill_bs1_non16x16mb_pslice;\n\n    ps_dec->pf_fill_bs1[1][0] = ih264d_fill_bs1_16x16mb_bslice;\n    ps_dec->pf_fill_bs1[1][1] = ih264d_fill_bs1_non16x16mb_bslice;\n\n    ps_dec->pf_fill_bs_xtra_left_edge[0] =\n                    ih264d_fill_bs_xtra_left_edge_cur_frm;\n    ps_dec->pf_fill_bs_xtra_left_edge[1] =\n                    ih264d_fill_bs_xtra_left_edge_cur_fld;\n\n    ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);\n\n    ps_dec->u2_prv_frame_num = 0;\n    ps_dec->u1_top_bottom_decoded = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->s_cab_dec_env.cabac_table = gau4_ih264d_cabac_table;\n\n    ps_dec->pu1_left_mv_ctxt_inc = ps_dec->u1_left_mv_ctxt_inc_arr[0];\n    ps_dec->pi1_left_ref_idx_ctxt_inc =\n &ps_dec->i1_left_ref_idx_ctx_inc_arr[0][0];\n    ps_dec->pu1_left_yuv_dc_csbp = &ps_dec->u1_yuv_dc_csbp_topmb;\n\n    ps_dec->u1_flushfrm = 0;\n\n {\n        ps_dec->s_cab_dec_env.pv_codec_handle = (void*)ps_dec;\n        ps_dec->ps_bitstrm->pv_codec_handle = (void*)ps_dec;\n        ps_dec->ps_cur_slice->pv_codec_handle = (void*)ps_dec;\n        ps_dec->ps_dpb_mgr->pv_codec_handle = (void*)ps_dec;\n }\n\n    memset(ps_dec->disp_bufs, 0, (MAX_DISP_BUFS_NEW) * sizeof(disp_buf_t));\n    memset(ps_dec->u4_disp_buf_mapping, 0,\n (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));\n    memset(ps_dec->u4_disp_buf_to_be_freed, 0,\n (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));\n\n    ih264d_init_arch(ps_dec);\n    ih264d_init_function_ptr(ps_dec);\n    ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;\n    ps_dec->init_done = 1;\n\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188626, "func": " void WT_NoiseGenerator (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n {\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 nInterpolatedSample;\n    EAS_I32 numSamples;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n    tmp0 = (EAS_I32) (pWTVoice->phaseAccum) >> 18;\n    tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;\n\n while (numSamples--) {\n        nInterpolatedSample = MULT_AUDIO_COEF( tmp0, (PHASE_ONE - pWTVoice->phaseFrac));\n        nInterpolatedSample += MULT_AUDIO_COEF( tmp1, pWTVoice->phaseFrac);\n *pOutputBuffer++ = (EAS_PCM) nInterpolatedSample;\n\n        pWTVoice->phaseFrac += (EAS_U32) phaseInc;\n if (GET_PHASE_INT_PART(pWTVoice->phaseFrac)) {\n            tmp0 = tmp1;\n            pWTVoice->phaseAccum = pWTVoice->loopEnd;\n            pWTVoice->loopEnd = (5 * pWTVoice->loopEnd + 1);\n            tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;\n            pWTVoice->phaseFrac = GET_PHASE_FRAC_PART(pWTVoice->phaseFrac);\n }\n\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188242, "func": "OMX_ERRORTYPE SoftVorbis::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioVorbis:\n {\n\n             OMX_AUDIO_PARAM_VORBISTYPE *vorbisParams =\n                 (OMX_AUDIO_PARAM_VORBISTYPE *)params;\n \n             if (vorbisParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            vorbisParams->nBitRate = 0;\n            vorbisParams->nMinBitRate = 0;\n            vorbisParams->nMaxBitRate = 0;\n            vorbisParams->nAudioBandWidth = 0;\n            vorbisParams->nQuality = 3;\n            vorbisParams->bManaged = OMX_FALSE;\n            vorbisParams->bDownmix = OMX_FALSE;\n\n if (!isConfigured()) {\n                vorbisParams->nChannels = 1;\n                vorbisParams->nSampleRate = 44100;\n } else {\n                vorbisParams->nChannels = mVi->channels;\n                vorbisParams->nSampleRate = mVi->rate;\n                vorbisParams->nBitRate = mVi->bitrate_nominal;\n                vorbisParams->nMinBitRate = mVi->bitrate_lower;\n                vorbisParams->nMaxBitRate = mVi->bitrate_upper;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n if (!isConfigured()) {\n                pcmParams->nChannels = 1;\n                pcmParams->nSamplingRate = 44100;\n } else {\n                pcmParams->nChannels = mVi->channels;\n                pcmParams->nSamplingRate = mVi->rate;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 188110, "func": "VOID ixheaacd_esbr_radix4bfly(const WORD32 *w, WORD32 *x, WORD32 index1,\n\n                               WORD32 index) {\n   int i;\n   WORD32 l1, l2, h2, fft_jmp;\n  WORD32 xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;\n  WORD32 xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;\n   WORD32 x_0, x_1, x_l1_0, x_l1_1, x_l2_0, x_l2_1;\n   WORD32 x_h2_0, x_h2_1;\n   WORD32 si10, si20, si30, co10, co20, co30;\n\n  WORD64 mul_1, mul_2, mul_3, mul_4, mul_5, mul_6;\n  WORD64 mul_7, mul_8, mul_9, mul_10, mul_11, mul_12;\n  WORD32 *x_l1;\n  WORD32 *x_l2;\n  WORD32 *x_h2;\n const WORD32 *w_ptr = w;\n  WORD32 i1;\n\n  h2 = index << 1;\n  l1 = index << 2;\n  l2 = (index << 2) + (index << 1);\n\n  x_l1 = &(x[l1]);\n  x_l2 = &(x[l2]);\n  x_h2 = &(x[h2]);\n\n  fft_jmp = 6 * (index);\n\n for (i1 = 0; i1 < index1; i1++) {\n for (i = 0; i < index; i++) {\n      si10 = (*w_ptr++);\n      co10 = (*w_ptr++);\n      si20 = (*w_ptr++);\n      co20 = (*w_ptr++);\n      si30 = (*w_ptr++);\n      co30 = (*w_ptr++);\n\n      x_0 = x[0];\n      x_h2_0 = x[h2];\n\n       x_l1_0 = x[l1];\n       x_l2_0 = x[l2];\n \n      xh0_0 = x_0 + x_l1_0;\n      xl0_0 = x_0 - x_l1_0;\n \n      xh20_0 = x_h2_0 + x_l2_0;\n      xl20_0 = x_h2_0 - x_l2_0;\n \n      x[0] = xh0_0 + xh20_0;\n      xt0_0 = xh0_0 - xh20_0;\n \n       x_1 = x[1];\n       x_h2_1 = x[h2 + 1];\n       x_l1_1 = x[l1 + 1];\n       x_l2_1 = x[l2 + 1];\n \n      xh1_0 = x_1 + x_l1_1;\n      xl1_0 = x_1 - x_l1_1;\n \n      xh21_0 = x_h2_1 + x_l2_1;\n      xl21_0 = x_h2_1 - x_l2_1;\n \n      x[1] = xh1_0 + xh21_0;\n      yt0_0 = xh1_0 - xh21_0;\n \n      xt1_0 = xl0_0 + xl21_0;\n      xt2_0 = xl0_0 - xl21_0;\n \n      yt2_0 = xl1_0 + xl20_0;\n      yt1_0 = xl1_0 - xl20_0;\n \n       mul_11 = ixheaacd_mult64(xt2_0, co30);\n       mul_3 = ixheaacd_mult64(yt2_0, si30);\n      x[l2] = (WORD32)((mul_3 + mul_11) >> 32) << RADIXSHIFT;\n\n      mul_5 = ixheaacd_mult64(xt2_0, si30);\n      mul_9 = ixheaacd_mult64(yt2_0, co30);\n      x[l2 + 1] = (WORD32)((mul_9 - mul_5) >> 32) << RADIXSHIFT;\n\n      mul_12 = ixheaacd_mult64(xt0_0, co20);\n      mul_2 = ixheaacd_mult64(yt0_0, si20);\n      x[l1] = (WORD32)((mul_2 + mul_12) >> 32) << RADIXSHIFT;\n\n      mul_6 = ixheaacd_mult64(xt0_0, si20);\n      mul_8 = ixheaacd_mult64(yt0_0, co20);\n      x[l1 + 1] = (WORD32)((mul_8 - mul_6) >> 32) << RADIXSHIFT;\n\n      mul_4 = ixheaacd_mult64(xt1_0, co10);\n      mul_1 = ixheaacd_mult64(yt1_0, si10);\n      x[h2] = (WORD32)((mul_1 + mul_4) >> 32) << RADIXSHIFT;\n\n      mul_10 = ixheaacd_mult64(xt1_0, si10);\n      mul_7 = ixheaacd_mult64(yt1_0, co10);\n      x[h2 + 1] = (WORD32)((mul_7 - mul_10) >> 32) << RADIXSHIFT;\n\n      x += 2;\n }\n    x += fft_jmp;\n    w_ptr = w_ptr - fft_jmp;\n }\n}\n", "target": 1, "flaw_line_index": "6,7,45,46,48,49,51,52,59,60,62,63,65,66,68,69,71,72"}
{"idx": 188197, "func": "void SoftMPEG4::onQueueFilled(OMX_U32 \n) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n PortInfo *port = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n\n PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n\n            mFramesConfigured = true;\n }\n\n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n\n         int32_t bufferSize = inHeader->nFilledLen;\n         int32_t tmp = bufferSize;\n \n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n\n         ++mInputBufferCount;\n \n         outHeader->nOffset = 0;\n        outHeader->nFilledLen = (mWidth * mHeight * 3) / 2;\n \n         List<BufferInfo *>::iterator it = outQueue.begin();\n         while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n", "target": 1, "flaw_line_index": "184"}
{"idx": 187943, "func": "void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pAudioBuffer;\n    EAS_I32 k;\n    EAS_I32 b1;\n    EAS_I32 b2;\n    EAS_I32 z1;\n    EAS_I32 z2;\n    EAS_I32 acc0;\n    EAS_I32 acc1;\n    EAS_I32 numSamples;\n\n \n     numSamples = pWTIntFrame->numSamples;\n     pAudioBuffer = pWTIntFrame->pAudioBuffer;\n \n     z1 = pFilter->z1;\n    z2 = pFilter->z2;\n    b1 = -pWTIntFrame->frame.b1;\n\n    b2 = -pWTIntFrame->frame.b2 >> 1;\n\n    k = pWTIntFrame->frame.k >> 1;\n\n while (numSamples--)\n {\n\n        acc0 = *pAudioBuffer;\n        acc1 = z1 * b1;\n        acc1 += z2 * b2;\n        acc0 = acc1 + k * acc0;\n        z2 = z1;\n\n        z1 = acc0 >> 14;\n *pAudioBuffer++ = (EAS_I16) z1;\n }\n\n    pFilter->z1 = (EAS_I16) z1;\n    pFilter->z2 = (EAS_I16) z2;\n}\n", "target": 1, "flaw_line_index": ""}
{"idx": 187850, "func": " long Segment::Load() {\n  assert(m_clusters == NULL);\n  assert(m_clusterSize == 0);\n  assert(m_clusterCount == 0);\n\n\n const long long header_status = ParseHeaders();\n\n if (header_status < 0) \n return static_cast<long>(header_status);\n\n\n   if (header_status > 0)  \n     return E_BUFFER_NOT_FULL;\n \n  assert(m_pInfo);\n  assert(m_pTracks);\n \n   for (;;) {\n     const int status = LoadCluster();\n\n if (status < 0) \n return status;\n\n if (status >= 1) \n return 0;\n }\n}\n", "target": 1, "flaw_line_index": "20,21"}
{"idx": 188171, "func": " static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n {\n     const char *perm = \"add\";\n     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n }\n", "target": 1, "flaw_line_index": ""}
{"idx": 187612, "func": "transform_name(int t)\n{\n unsigned int i;\n\n \n    t &= -t; \n \n   for (i=0; i<TTABLE_SIZE; ++i)\n    {\n       if ((transform_info[i].transform & t) != 0)\n          return transform_info[i].name;\n }\n\n return \"invalid transform\";\n}\n", "target": 1, "flaw_line_index": "8"}
{"idx": 187354, "func": "xsltProcessUserParamInternal(xsltTransformContextPtr ctxt,\n\t\t             const xmlChar * name,\n\t\t\t     const xmlChar * value,\n\t\t\t     int eval) {\n\n    xsltStylesheetPtr style;\n    const xmlChar *prefix;\n    const xmlChar *href;\n    xmlXPathCompExprPtr xpExpr;\n    xmlXPathObjectPtr result;\n\n    xsltStackElemPtr elem;\n    int res;\n    void *res_ptr;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if (name == NULL)\n\treturn(0);\n    if (value == NULL)\n\treturn(0);\n\n    style = ctxt->style;\n\n#ifdef WITH_XSLT_DEBUG_VARIABLE\n    XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n\t    \"Evaluating user parameter %s=%s\\n\", name, value));\n#endif\n\n    name = xsltSplitQName(ctxt->dict, name, &prefix);\n     href = NULL;\n    if (prefix != NULL) {\n\txmlNsPtr ns;\n \n\tns = xmlSearchNs(style->doc, xmlDocGetRootElement(style->doc),\n\t\t\t prefix);\n\tif (ns == NULL) {\n\t    xsltTransformError(ctxt, style, NULL,\n\t    \"user param : no namespace bound to prefix %s\\n\", prefix);\n\t    href = NULL;\n\t} else {\n\t    href = ns->href;\n\t}\n     }\n \n     if (name == NULL)\n\treturn (-1);\n\n    res_ptr = xmlHashLookup2(ctxt->globalVars, name, href);\n    if (res_ptr != 0) {\n\txsltTransformError(ctxt, style, NULL,\n\t    \"Global parameter %s already defined\\n\", name);\n    }\n    if (ctxt->globalVars == NULL)\n\tctxt->globalVars = xmlHashCreate(20);\n\n    while (style != NULL) {\n        elem = ctxt->style->variables;\n\twhile (elem != NULL) {\n\t    if ((elem->comp != NULL) &&\n\t        (elem->comp->type == XSLT_FUNC_VARIABLE) &&\n\t\t(xmlStrEqual(elem->name, name)) &&\n\t\t(xmlStrEqual(elem->nameURI, href))) {\n\t\treturn(0);\n\t    }\n            elem = elem->next;\n\t}\n        style = xsltNextImport(style);\n    }\n    style = ctxt->style;\n    elem = NULL;\n\n\n    result = NULL;\n    if (eval != 0) {\n        xpExpr = xmlXPathCompile(value);\n\tif (xpExpr != NULL) {\n\t    xmlDocPtr oldXPDoc;\n\t    xmlNodePtr oldXPContextNode;\n\t    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n\t    xmlNsPtr *oldXPNamespaces;\n\t    xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n\n\t    oldXPDoc = xpctxt->doc;\n\t    oldXPContextNode = xpctxt->node;\n\t    oldXPProximityPosition = xpctxt->proximityPosition;\n\t    oldXPContextSize = xpctxt->contextSize;\n\t    oldXPNamespaces = xpctxt->namespaces;\n\t    oldXPNsNr = xpctxt->nsNr;\n\n\t    xpctxt->doc = ctxt->initialContextDoc;\n\t    xpctxt->node = ctxt->initialContextNode;\n\t    xpctxt->contextSize = 1;\n\t    xpctxt->proximityPosition = 1;\n\t    xpctxt->namespaces = NULL;\n\t    xpctxt->nsNr = 0;\n\n\t    result = xmlXPathCompiledEval(xpExpr, xpctxt);\n\n\t    xpctxt->doc = oldXPDoc;\n\t    xpctxt->node = oldXPContextNode;\n\t    xpctxt->contextSize = oldXPContextSize;\n\t    xpctxt->proximityPosition = oldXPProximityPosition;\n\t    xpctxt->namespaces = oldXPNamespaces;\n\t    xpctxt->nsNr = oldXPNsNr;\n\n\t    xmlXPathFreeCompExpr(xpExpr);\n\t}\n\tif (result == NULL) {\n\t    xsltTransformError(ctxt, style, NULL,\n\t\t\"Evaluating user parameter %s failed\\n\", name);\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t    return(-1);\n\t}\n    }\n\n\n#ifdef WITH_XSLT_DEBUG_VARIABLE\n#ifdef LIBXML_DEBUG_ENABLED\n    if ((xsltGenericDebugContext == stdout) ||\n        (xsltGenericDebugContext == stderr))\n\t    xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n\t\t\t\t    result, 0);\n#endif\n#endif\n\n    elem = xsltNewStackElem(NULL);\n    if (elem != NULL) {\n\telem->name = name;\n\telem->select = xmlDictLookup(ctxt->dict, value, -1);\n\tif (href != NULL)\n\t    elem->nameURI = xmlDictLookup(ctxt->dict, href, -1);\n\telem->tree = NULL;\n\telem->computed = 1;\n\tif (eval == 0) {\n\t    elem->value = xmlXPathNewString(value);\n\t}\n\telse {\n\t    elem->value = result;\n\t}\n    }\n\n\n    res = xmlHashAddEntry2(ctxt->globalVars, name, href, elem);\n    if (res != 0) {\n\txsltFreeStackElem(elem);\n\txsltTransformError(ctxt, style, NULL,\n\t    \"Global parameter %s already defined\\n\", name);\n    }\n    return(0);\n}\n", "target": 1, "flaw_line_index": "30,32,33,35,36,37,38,39,40,41,42,43"}
{"idx": 9015, "func": "vmxnet3_io_bar1_write(void *opaque,\n                      hwaddr addr,\n                      uint64_t val,\n                      unsigned size)\n{\n    VMXNET3State *s = opaque;\n\n    switch (addr) {\n    case VMXNET3_REG_VRRS:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_VRRS] = %\" PRIx64 \", size %d\",\n                  val, size);\n        break;\n\n    case VMXNET3_REG_UVRS:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_UVRS] = %\" PRIx64 \", size %d\",\n                  val, size);\n        break;\n\n    case VMXNET3_REG_DSAL:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_DSAL] = %\" PRIx64 \", size %d\",\n                  val, size);\n        if (val == 0) {\n            vmxnet3_deactivate_device(s);\n        }\n        s->temp_shared_guest_driver_memory = val;\n        s->drv_shmem = 0;\n        break;\n\n    case VMXNET3_REG_DSAH:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_DSAH] = %\" PRIx64 \", size %d\",\n                  val, size);\n        s->drv_shmem = s->temp_shared_guest_driver_memory | (val << 32);\n        break;\n\n    case VMXNET3_REG_CMD:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_CMD] = %\" PRIx64 \", size %d\",\n                  val, size);\n        vmxnet3_handle_command(s, val);\n        break;\n\n    case VMXNET3_REG_MACL:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_MACL] = %\" PRIx64 \", size %d\",\n                  val, size);\n        s->temp_mac = val;\n        break;\n\n    case VMXNET3_REG_MACH:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_MACH] = %\" PRIx64 \", size %d\",\n                  val, size);\n        vmxnet3_set_variable_mac(s, val, s->temp_mac);\n        break;\n\n    case VMXNET3_REG_ICR:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_ICR] = %\" PRIx64 \", size %d\",\n                  val, size);\n        g_assert_not_reached();\n        break;\n\n    case VMXNET3_REG_ECR:\n        VMW_CBPRN(\"Write BAR1 [VMXNET3_REG_ECR] = %\" PRIx64 \", size %d\",\n                  val, size);\n        vmxnet3_ack_events(s, val);\n        break;\n\n    default:\n        VMW_CBPRN(\"Unknown Write to BAR1 [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n                  addr, val, size);\n        break;\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188535, "func": "   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n     }\n   }\n", "target": 1, "flaw_line_index": "5,6,7,8"}
{"idx": 9100, "func": "static int vrend_decode_create_shader(struct vrend_decode_ctx *ctx,\n                                      uint32_t handle,\n                                      uint16_t length)\n{\n   struct pipe_stream_output_info so_info;\n   int i, ret;\n   uint32_t shader_offset;\n   unsigned num_tokens, num_so_outputs, offlen;\n   uint8_t *shd_text;\n   uint32_t type;\n\n   if (length < 5)\n      return EINVAL;\n\n   type = get_buf_entry(ctx, VIRGL_OBJ_SHADER_TYPE);\n   num_tokens = get_buf_entry(ctx, VIRGL_OBJ_SHADER_NUM_TOKENS);\n   offlen = get_buf_entry(ctx, VIRGL_OBJ_SHADER_OFFSET);\n   num_so_outputs = get_buf_entry(ctx, VIRGL_OBJ_SHADER_SO_NUM_OUTPUTS);\n\n   if (num_so_outputs > PIPE_MAX_SO_OUTPUTS)\n      return EINVAL;\n\n   shader_offset = 6;\n   if (num_so_outputs) {\n      so_info.num_outputs = num_so_outputs;\n      if (so_info.num_outputs) {\n         for (i = 0; i < 4; i++)\n            so_info.stride[i] = get_buf_entry(ctx, VIRGL_OBJ_SHADER_SO_STRIDE(i));\n         for (i = 0; i < so_info.num_outputs; i++) {\n            uint32_t tmp = get_buf_entry(ctx, VIRGL_OBJ_SHADER_SO_OUTPUT0(i));\n\n            so_info.output[i].register_index = tmp & 0xff;\n            so_info.output[i].start_component = (tmp >> 8) & 0x3;\n            so_info.output[i].num_components = (tmp >> 10) & 0x7;\n            so_info.output[i].output_buffer = (tmp >> 13) & 0x7;\n            so_info.output[i].dst_offset = (tmp >> 16) & 0xffff;\n         }\n      }\n      shader_offset += 4 + (2 * num_so_outputs);\n   } else\n     memset(&so_info, 0, sizeof(so_info));\n\n   shd_text = get_buf_ptr(ctx, shader_offset);\n   ret = vrend_create_shader(ctx->grctx, handle, &so_info, (const char *)shd_text, offlen, num_tokens, type, length - shader_offset + 1);\n\n   return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188619, "func": "  LosslessTestLarge()\n       : EncoderTest(GET_PARAM(0)),\n         psnr_(kMaxPsnr),\n         nframes_(0),\n         encoding_mode_(GET_PARAM(1)) {\n   }\n", "target": 1, "flaw_line_index": ""}
{"idx": 188576, "func": "   void RunMemCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 5000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j) {\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n       }\n      if (i == 0)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = 255;\n      if (i == 1)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = -255;\n \n       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n                                      output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         EXPECT_EQ(output_block[j], output_ref_block[j]);\n        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n            << \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n       }\n     }\n   }\n", "target": 1, "flaw_line_index": "4,5,6,7,10,12,13,15,17,18,20,23,24,29,30"}
{"idx": 8995, "func": "vmxnet3_get_next_head_rx_descr(VMXNET3State *s,\n                               struct Vmxnet3_RxDesc *descr_buf,\n                               uint32_t *descr_idx,\n                               uint32_t *ridx)\n{\n    for (;;) {\n        uint32_t ring_gen;\n        vmxnet3_read_next_rx_descr(s, RXQ_IDX, RX_HEAD_BODY_RING,\n                                   descr_buf, descr_idx);\n\n        ring_gen = vmxnet3_get_rx_ring_gen(s, RXQ_IDX, RX_HEAD_BODY_RING);\n        if (descr_buf->gen != ring_gen) {\n            return false;\n        }\n\n        smp_rmb();\n        vmxnet3_read_next_rx_descr(s, RXQ_IDX, RX_HEAD_BODY_RING,\n                                   descr_buf, descr_idx);\n\n        vmxnet3_inc_rx_consumption_counter(s, RXQ_IDX, RX_HEAD_BODY_RING);\n\n        if (descr_buf->btype == VMXNET3_RXD_BTYPE_HEAD) {\n            *ridx = RX_HEAD_BODY_RING;\n            return true;\n        }\n    }\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 8755, "func": "void FAST_FUNC udhcp_add_simple_option(struct dhcp_packet *packet, uint8_t code, uint32_t data)\n{\n\tconst struct dhcp_optflag *dh;\n\n\tfor (dh = dhcp_optflags; dh->code; dh++) {\n\t\tif (dh->code == code) {\n\t\t\tuint8_t option[6], len;\n\n\t\t\toption[OPT_CODE] = code;\n\t\t\tlen = dhcp_option_lengths[dh->flags & OPTION_TYPE_MASK];\n\t\t\toption[OPT_LEN] = len;\n\t\t\tif (BB_BIG_ENDIAN)\n\t\t\t\tdata <<= 8 * (4 - len);\n\t\t\tmove_to_unaligned32(&option[OPT_DATA], data);\n\t\t\tudhcp_add_binary_option(packet, option);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbb_error_msg(\"can't add option 0x%02x\", code);\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 187555, "func": "status_t OMXNodeInstance::useBuffer(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size()) {\n\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_ERRORTYPE err = OMX_UseBuffer(\n            mHandle, &header, portIndex, buffer_meta,\n            allottedSize, static_cast<OMX_U8 *>(params->pointer()));\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(\n                portIndex, (size_t)allottedSize, params->pointer()));\n\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u(%zu)@%p\", allottedSize, params->size(), params->pointer()));\n return OK;\n}\n", "target": 1, "flaw_line_index": "10"}
{"idx": 8563, "func": "static int ssh_do_close(Ssh ssh, int notify_exit)\n{\n    int ret = 0;\n    struct ssh_channel *c;\n\n    ssh->state = SSH_STATE_CLOSED;\n    expire_timer_context(ssh);\n    if (ssh->s) {\n        sk_close(ssh->s);\n        ssh->s = NULL;\n        if (notify_exit)\n            notify_remote_exit(ssh->frontend);\n        else\n            ret = 1;\n    }\n    if (ssh->channels) {\n\twhile (NULL != (c = index234(ssh->channels, 0))) {\n\t    ssh_channel_close_local(c, NULL);\n\t    del234(ssh->channels, c); \n\t    if (ssh->version == 2)\n\t\tbufchain_clear(&c->v.v2.outbuffer);\n\t    sfree(c);\n\t}\n    }\n    if (ssh->portfwds) {\n\tstruct ssh_portfwd *pf;\n\twhile (NULL != (pf = index234(ssh->portfwds, 0))) {\n\t    if (pf->local)\n\t\tpfl_terminate(pf->local);\n\t    del234(ssh->portfwds, pf); \n\t    free_portfwd(pf);\n\t}\n\tfreetree234(ssh->portfwds);\n\tssh->portfwds = NULL;\n    }\n\n    if (ssh->connshare) {\n        sharestate_free(ssh->connshare);\n        ssh->connshare = NULL;\n    }\n\n    return ret;\n}\n", "target": 0, "flaw_line_index": ""}
{"idx": 188227, "func": "OMX_ERRORTYPE SoftG711::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n if (pcmParams->nPortIndex == 0) {\n                pcmParams->ePCMMode = mIsMLaw ? OMX_AUDIO_PCMModeMULaw\n : OMX_AUDIO_PCMModeALaw;\n } else {\n                pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n }\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "flaw_line_index": ""}
